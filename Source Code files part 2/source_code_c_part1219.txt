2732,32731,32727,32731,32731,32730,32727,32726,32726,32724,32722}
     },
     {
      538,
      -32703,
      {6433,18681,25659,15024,25104,32068,15251,-2401,18941,18817,-21159,4550,19621,32718,-985,30327,11111,16318,13021,24230,32718,32718,28682,32719,32717,31372,30392,32723,31408,32721,32721,32724}
     },
     {
      570,
      -32575,
      {-5574,-9598,-8261,-3348,32718,32724,32719,32717,32719,32720,32721,32717,21517,32717,32720,31232,5703,5777,20553,4659,32716,32717,26907,31054,32575,32716,32717,32719,32718,32716,32717,32720}
     },
     {
      602,
      16633,
      {-28317,-32719,-32721,-32725,-32717,-32720,-32725,-32730,-32716,-32724,-32728,-32732,-32718,-32724,-32727,-32724,-32726,-32725,-32724,-32727,-32729,-32727,-32727,-32726,-32728,-32725,-32721,-32724,-32724,-32722,10888,23416}
     },
     {
      634,
      -32699,
      {31067,23187,32427,32362,31415,32520,32694,32720,32670,32721,32720,32719,32399,32721,32722,32720,32720,32727,32726,32725,32726,32726,32725,32724,32724,32725,32725,32722,32721,32723,32721,32720}
     },
     {
      666,
      -189,
      {-5994,-11934,-23583,-14385,-29298,-32489,-25487,-24087,-32717,-32488,-31990,-32115,-32716,-32464,-31861,-32172,-32235,-32723,-32724,-25618,-32134,-32502,-32723,-32451,-32374,-32489,-32620,-32286,-32718,-32721,-32700,1575}
     },
     {
      698,
      -32718,
      {19529,32727,32722,32720,32723,32723,32722,32724,-7818,32718,32722,32726,-14441,32718,32721,32723,32723,32725,32724,32721,32726,32724,32726,32723,32726,32725,32727,32721,32723,32720,32720,32719}
     },
     {
      730,
      -32617,
      {32719,32718,29981,15840,32719,32719,32717,30738,32718,32719,32719,32717,32718,32719,32718,32717,-32718,-17547,32409,-7337,-32719,11715,32667,22131,22363,19626,29565,26626,19260,17039,21623,31884}
     },
     {
      762,
      -32677,
      {11148,32719,32719,-13318,32721,32723,32720,-25451,32722,32720,32720,548,32719,32719,20163,505,-32720,-32723,-32724,-14552,-32721,-24595,-32721,-32720,-21496,-2271,-32720,-13109,589,-28920,-27762,-17254}
     },
// *********** Cells of layer 2 *********************************************

     {
      0,
      -767,
      {-787,1723,-1698,-866,-774,528,424,-281,-1256,-807,514,-488,2027,-651,-722,260,-658,924,-960,371,1445,-789,89,-820,87,-621,1684,-398,-1043,-1955,-868,-1355}
     },
     {
      32,
      -1649,
      {-1065,-864,355,-463,-53,-273,879,349,1680,-664,733,522,814,2203,314,118,526,-1744,-1082,-450,543,-57,783,-826,1023,-234,1205,134,3181,1350,-18,-477}
     },
     {
      64,
      -423,
      {-350,-150,-571,-709,1002,738,-430,-673,-725,-46,-22,-683,1205,-3,154,-638,-181,-235,157,32,-1439,-147,-699,-1058,-667,-375,-1541,-947,-37,-382,-390,-320}
     },
     {
      96,
      2320,
      {-570,-230,-971,-62,860,-359,-78,-627,36,503,997,-159,513,129,-642,156,-1356,626,807,102,905,1065,228,-188,-226,-103,1638,-41,832,-502,-899,-536}
     },
     {
      0,
      -127,
      {3775,1141,979,1810,-94,716,-148,280,-174,1127,-1265,-11,-214,-1098,1758,942,5,-680,-1286,-687,-1052,1604,3827,-1403,-912,5488,-444,123,192,290,692,1154}
     },
     {
      32,
      -1221,
      {214,-308,748,1105,-3521,984,-1255,-786,-746,546,571,-1690,-3523,-155,193,-2202,-2251,2097,1045,-315,-3242,612,-230,147,1041,-3688,-302,-1858,-747,288,-1760,1805}
     },
     {
      64,
      -691,
      {-862,-1022,247,-736,-407,-266,-408,-1110,-43,253,-283,-950,157,-1075,379,239,-289,373,-718,-465,342,-233,-1360,2443,-2,-417,214,475,-697,84,-1342,664}
     },
     {
      96,
      -1523,
      {582,774,-1132,25,-508,-1069,293,-2334,1156,191,-740,-64,913,1210,481,193,648,2633,-1637,-124,141,-1043,-1227,-493,-779,20,-565,0,365,577,-848,591}
     },
     {
      0,
      1309,
      {-996,-81,1591,-93,500,-864,408,-933,1441,-214,197,-879,-813,-1241,-1026,-539,-626,-2379,-85,-192,-1698,1078,7,-426,-153,-1453,604,-22,610,1759,109,1755}
     },
     {
      32,
      301,
      {1118,351,-222,322,-2650,-300,493,-704,-2219,604,871,506,-424,-1697,-1095,-289,-1495,1158,-59,1353,-839,-816,652,-731,-731,531,-1003,608,-860,-876,558,476}
     },
     {
      64,
      -602,
      {-111,-706,-74,-1840,-806,-1052,-1551,-125,-565,450,31,-633,-540,-401,1140,-1137,-370,-230,-659,-935,85,-294,-1076,-397,303,194,-238,460,-320,255,30,-386}
     },
     {
      96,
      520,
      {431,212,-288,1285,544,-1573,-62,-751,584,-2383,-30,1937,301,-231,-744,-186,1550,-2681,-210,1927,878,610,127,559,362,-934,56,2484,31,-787,803,-119}
     },
     {
      0,
      -952,
      {365,-812,-654,1313,-596,579,-155,-15,2267,827,-520,1163,-2311,1195,-1488,-360,-963,8,177,-516,564,-178,-749,631,-2145,2053,-1022,1392,455,454,1081,788}
     },
     {
      32,
      -252,
      {119,-1792,1904,424,-2558,818,592,64,-888,-288,-173,1927,-1129,-2705,-1408,-339,146,-53,-2323,411,-3619,-1913,-91,-2055,273,-1690,-600,-1918,-192,483,-2340,-3590}
     },
     {
      64,
      -1839,
      {1007,-291,-786,-656,-886,-937,274,155,-218,98,1822,-446,84,-100,87,-197,1075,222,578,5,194,282,496,-376,200,521,-259,-138,-139,598,157,548}
     },
     {
      96,
      -1274,
      {-461,-197,-264,531,219,133,-589,-57,-432,500,603,-58,872,-911,143,575,471,-434,-124,155,-819,-89,215,-70,-316,-174,-239,438,-864,-60,53,-466}
     },
     {
      0,
      320,
      {-105,794,3548,123,-427,162,1195,-571,4653,-1096,-423,-135,448,-1324,-2217,407,-1917,1434,-1284,-541,1858,-20,-1254,-551,391,2388,735,16,103,997,69,-2374}
     },
     {
      32,
      -322,
      {29,-2682,2048,590,-1570,314,-775,-48,1485,103,719,856,876,-260,-859,-307,-1859,-263,-2793,234,1355,-159,-729,4,58,-1914,2335,2258,-637,172,-293,-388}
     },
     {
      64,
      -216,
      {56,-444,83,-330,-1179,-353,-548,-516,-33,-376,-225,-123,-129,-163,-681,-157,-254,-354,109,-944,87,-735,71,-2041,-191,1543,63,-266,641,418,-900,-593}
     },
     {
      96,
      -827,
      {-389,-1109,-659,-142,883,-733,-892,-1762,-530,-458,127,-187,370,-1266,1081,2181,-1222,33,-792,-349,380,279,-940,595,1000,914,456,-100,-339,-283,694,626}
     },
     {
      0,
      2495,
      {452,600,-1362,1113,232,1808,-951,-1601,-1668,-423,644,-1300,2790,-183,421,586,-199,661,-1563,-1285,-152,-959,71,-634,-592,1482,-1395,-799,-1723,-124,-1114,-1041}
     },
     {
      32,
      -216,
      {1604,-747,440,-134,-654,69,1560,-351,-548,437,1191,738,727,-709,-323,-684,-657,-8,-1138,-315,-1530,-463,985,-781,731,-675,-821,-930,-715,-251,419,-459}
     },
     {
      64,
      -814,
      {-319,-681,540,-457,-973,-662,-333,65,-515,-881,-136,-423,-284,-998,-215,-323,-70,307,203,488,1021,-467,747,1115,-1505,-674,446,-5,21,-23,476,478}
     },
     {
      96,
      301,
      {484,1004,-402,127,-781,-411,-82,-318,-232,393,-84,-17,695,-702,209,-282,20,1400,-48,291,803,-1665,-1098,-238,444,-386,-429,168,497,466,-80,-85}
     },
     {
      0,
      2057,
      {-1757,-154,-527,-362,-54,-2452,-446,1069,260,-3333,609,1041,-1557,-858,-492,798,1445,815,277,-265,-433,-2674,-496,-286,146,-1258,-1186,-259,-1970,-845,-652,-2045}
     },
     {
      32,
      -775,
      {1099,912,-791,752,-462,235,1057,-662,86,480,470,-724,-336,786,72,858,747,37,877,-962,-348,582,-1390,-12,-47,1190,-1342,-1766,-32,65,524,28}
     },
     {
      64,
      -894,
      {-64,-193,-206,-405,-182,-184,-66,634,-26,290,-1432,432,-159,-909,-102,193,224,-225,-16,453,122,-161,694,-496,7,-947,-475,106,462,223,1003,12}
     },
     {
      96,
      3201,
      {452,-127,117,-1489,38,612,-43,-425,131,22,-620,-1323,-450,288,-242,340,793,327,-1675,-1242,-97,-102,216,230,36,11,-994,-659,174,77,306,-103}
     },
     {
      0,
      1325,
      {-1010,-1321,-1266,-1688,919,-2661,-445,-965,-1107,602,-167,-255,1071,-2319,939,267,-2096,-2387,-607,-190,-305,-1235,1582,-490,1200,-739,1923,-603,-300,2088,-1318,-12}
     },
     {
      32,
      698,
      {-701,-507,-916,802,-158,-1175,-890,-600,28,1083,-1102,-384,-955,350,1827,-217,1996,-2017,340,73,2180,-799,-1603,-141,57,1641,-294,-1218,-796,-751,-161,-903}
     },
     {
      64,
      162,
      {-345,-955,-41,-1767,84,-351,-808,-1389,-618,1094,-406,-1777,-66,-412,-48,-569,-746,-1056,-901,144,-23,142,-190,537,-64,-399,331,-245,-1984,-3,-530,1137}
     },
     {
      96,
      1785,
      {-346,-262,-498,-398,433,79,268,-846,-7,-271,513,-259,1172,-57,-752,-967,258,-199,-425,265,807,-377,-394,-739,159,28,-136,451,417,-3,-952,413}
     },
     {
      0,
      1558,
      {-1353,-347,757,-36,-860,-1522,957,1062,-1363,-3112,1921,-35,-328,2326,-267,-830,-961,1004,-429,-457,1685,-1644,-1844,725,457,-3077,2226,-384,366,-1329,-1607,-969}
     },
     {
      32,
      1157,
      {-275,-576,-395,-149,-959,529,-1978,56,897,-391,-1726,812,-154,697,-1295,634,-3530,2742,185,-993,-726,1404,-1441,-210,-281,-898,1174,-481,-71,685,-1495,-1083}
     },
     {
      64,
      -1446,
      {-456,-1073,539,-159,63,356,751,326,-229,-237,271,931,-82,-576,-1308,869,-866,-1769,127,-206,653,317,1073,-419,567,831,137,245,-357,842,737,-972}
     },
     {
      96,
      3052,
      {123,137,-367,-1261,659,12,-1089,254,-473,601,-1220,-1396,-1642,1061,-240,1585,346,-736,-286,-1663,-38,38,1353,551,340,-735,-84,-1876,-985,26,311,-617}
     },
     {
      0,
      212,
      {-714,151,-62,-24,-218,-657,132,101,2078,380,-447,215,-1734,-1354,-764,181,-459,-305,-563,-193,-17,560,-796,-737,-555,22,-719,-359,650,-144,234,-708}
     },
     {
      32,
      1354,
      {-110,1305,-1122,-185,702,-801,-1378,158,879,-916,-2240,1734,-347,872,-1193,861,-2679,2026,123,-387,-3943,582,-1498,354,153,-1368,895,-516,-1413,95,-474,-752}
     },
     {
      64,
      1318,
      {-1033,-477,-118,-71,359,131,-244,-796,34,-210,-352,-906,134,-600,284,-82,-410,223,-622,-233,-590,-808,-909,-339,143,-118,-390,-345,-759,-536,-927,137}
     },
     {
      96,
      -1280,
      {-302,-737,502,-782,-634,454,-32,982,20,-820,282,-404,745,-670,1754,-132,-32,-248,618,-243,-295,-1028,981,2175,-216,137,315,-254,558,-258,546,-236}
     },
     {
      0,
      288,
      {-558,-62,-813,-307,-406,-272,156,-384,-1762,97,-97,-806,2259,-1160,432,847,-231,-1172,-1431,-8,456,-1490,865,360,1347,1731,1383,254,-1638,-444,-1550,-2563}
     },
     {
      32,
      1283,
      {855,521,-321,-165,-1320,90,-1082,-252,-188,-507,-362,663,-843,-198,-510,164,-1596,1049,-294,265,-1024,-968,-264,-91,-489,-259,-60,-1460,-181,-109,-184,-284}
     },
     {
      64,
      1498,
      {-514,-839,-590,-913,1070,561,-695,-503,154,-873,-543,-1351,472,-67,-609,-782,-211,-680,-831,-703,-1074,-2775,-329,-2265,-547,298,-1168,-864,-228,-1134,-1123,-308}
     },
     {
      96,
      -2024,
      {713,278,-21,476,-611,-115,38,-1245,-214,-86,-939,363,462,-208,375,-789,-515,270,721,489,96,564,-1888,-1608,169,1033,522,-65,499,182,345,-531}
     },
     {
      0,
      2578,
      {-68,1052,630,-1130,824,-161,-711,-1538,218,-1194,174,423,1023,-2114,1423,-952,47,-130,-1873,-837,-183,-744,776,-1610,1481,1139,1070,-1392,-1244,156,-1143,-821}
     },
     {
      32,
      592,
      {-285,1177,-935,-1024,866,-777,-1235,637,2702,-1146,-1437,-78,486,1500,1425,-818,2253,-2050,259,901,2196,-1399,-1105,465,-213,939,-1184,995,-217,-1204,-744,-1286}
     },
     {
      64,
      831,
      {-612,-2397,-693,-2157,-610,-270,-442,-898,-296,256,-435,496,-746,1,-32,-682,-1206,547,-375,-698,1359,-795,-461,777,-1051,1054,-298,320,-302,-109,1048,1460}
     },
     {
      96,
      -1848,
      {-100,-923,-449,475,-29,1324,-907,455,34,-770,856,9,642,585,-746,800,153,18,-320,134,1402,-784,-2235,-656,-169,630,-67,68,347,-840,980,2029}
     },
     {
      0,
      -185,
      {-73,-18,32,432,895,-51,-457,680,418,-718,-593,-293,87,-1318,1257,-84,328,-478,44,-1817,-186,270,824,-1461,431,-341,-1103,674,-19,1184,-521,-622}
     },
     {
      32,
      -1423,
      {-818,-285,-343,512,1352,1015,-148,163,-1083,-291,882,-1062,1858,-546,-1499,-558,498,-1709,513,1035,816,-157,1134,509,353,686,-1509,498,-695,-379,267,1032}
     },
     {
      64,
      -168,
      {-1439,-462,206,-496,-1120,-1198,-945,388,223,56,-407,644,276,-863,-916,-206,-571,-106,-333,-698,1295,-1022,976,-3,157,540,247,573,-292,942,952,207}
     },
     {
      96,
      -2608,
      {208,529,-633,462,364,1013,466,-312,-518,-351,299,-142,0,1100,-48,-956,233,-702,679,408,-1670,182,-142,2,-664,561,-471,717,-28,720,142,27}
     },
     {
      0,
      1150,
      {-919,30,1050,222,293,-18,-777,190,-1892,-525,638,-248,1150,-1739,1084,-1091,408,824,565,-962,1458,-673,974,-2149,-556,76,-822,-1129,-800,435,-474,-1248}
     },
     {
      32,
      -2069,
      {734,-2059,1902,1211,276,1273,951,-1015,645,476,-1342,-1333,521,660,-652,675,-1753,-71,-798,-636,-2117,-669,159,-611,815,-1099,-1659,-2171,-1666,1045,94,-2566}
     },
     {
      64,
      0,
      {-775,-1411,-1031,193,-826,-315,-363,372,-647,-471,-316,-748,-697,-988,-2166,-951,-179,-468,461,-599,38,189,-456,-1560,-1190,430,-233,97,78,308,-567,-765}
     },
     {
      96,
      995,
      {182,73,-99,-135,-257,-64,-594,-2867,239,-117,505,-361,720,-144,-230,-549,41,63,-8,-274,1140,-880,39,-468,321,-120,1039,-29,201,-567,-978,-148}
     },
     {
      0,
      1529,
      {1410,1092,-881,575,-970,1227,-152,-1153,-1498,-1026,-312,-6,2253,-1628,1680,886,998,1319,-2341,0,201,-888,1585,-783,-749,1858,-1130,-194,-2359,-588,-589,-2709}
     },
     {
      32,
      607,
      {-422,20,708,753,-1196,-1159,76,-580,1806,703,444,138,-202,596,629,-85,-997,-1201,84,-1127,783,-2245,220,280,297,430,816,-1063,-54,-163,-656,-1451}
     },
     {
      64,
      0,
      {-420,-2455,-151,205,394,-639,189,-144,-110,-995,-476,178,-956,-876,-1686,-825,-564,-506,-357,-209,-751,-917,22,-297,-239,-927,-80,-298,-402,-845,-192,-930}
     },
     {
      96,
      324,
      {-139,-724,-1231,-110,422,-628,800,-206,-117,-1637,283,406,-241,95,-210,-127,-429,1424,1560,179,-298,974,127,253,35,-1292,-114,418,-639,188,698,1089}
     },
     {
      0,
      -2309,
      {265,-669,-74,-1439,-618,-374,870,-2034,1596,231,-827,1053,-641,-4324,-103,155,-882,1191,-178,330,-863,1860,183,1150,720,-2603,-523,803,1538,1203,51,-571}
     },
     {
      32,
      1143,
      {-1016,-384,-1465,-612,799,334,-2218,502,1781,-291,-2249,-502,1196,2035,-227,-1831,1283,161,1291,-572,328,-1408,274,1347,-602,1245,-642,-1447,1616,-90,-354,-1849}
     },
     {
      64,
      213,
      {980,-318,625,770,120,456,736,-281,537,145,-4,-199,543,-191,-102,565,-419,-1952,-955,-639,-1117,149,-756,-2058,171,-763,215,-1055,318,675,-1011,-405}
     },
     {
      96,
      1710,
      {-708,-492,223,-558,701,1254,-950,952,-1006,-552,521,-102,-1444,1970,-296,-178,-400,-1382,-340,-159,-84,395,996,-79,-199,85,365,-244,-524,-387,193,-951}
     },
     {
      0,
      594,
      {362,-1376,751,458,104,-1087,963,1055,-697,-540,-340,0,1387,1358,1263,109,1519,-568,-158,-568,-1226,3896,1461,767,318,-1069,412,554,40,259,-1225,826}
     },
     {
      32,
      1641,
      {-2122,-1740,-360,-185,590,-299,-755,136,378,-266,-812,-1240,627,247,-743,-314,-1182,452,1093,615,1163,374,384,366,252,381,298,409,-1902,-168,-527,79}
     },
     {
      64,
      -465,
      {345,-519,-50,-362,122,-258,565,-2,409,-846,1787,1424,211,-1012,-1498,301,822,125,-433,345,-450,505,514,-1049,122,76,373,559,240,639,531,-899}
     },
     {
      96,
      858,
      {-573,-113,-555,79,2,-1546,111,-575,548,-501,-1002,-550,945,-61,732,988,-942,-123,758,-117,-212,-97,-803,638,-200,415,604,-328,586,-596,-273,129}
     },
     {
      0,
      1275,
      {467,-1437,1164,881,198,-1180,752,696,403,-1577,-810,-1136,-343,404,-194,-766,587,-1158,1280,-219,-503,729,1230,-682,-276,-1879,-76,-645,11,1693,850,2198}
     },
     {
      32,
      -2039,
      {362,1484,977,1901,-2382,163,601,-1684,-2050,2021,2140,-2335,688,-5532,1374,894,-1135,-1383,-158,-160,-486,-198,1176,-865,-328,-861,-2158,-524,-822,231,1058,1001}
     },
     {
      64,
      761,
      {-651,-437,-153,-35,-1775,-444,-105,-253,-342,-730,-195,-388,-753,-546,615,2,-635,-843,-179,338,-1380,-1493,363,-333,-594,-633,-121,-178,938,-1094,-453,-718}
     },
     {
      96,
      3787,
      {-41,-756,-520,129,302,-501,320,-592,2,-1144,197,9,1156,-1206,-560,136,692,-858,37,-349,883,56,111,1200,191,15,-94,-222,330,-960,307,86}
     },
     {
      0,
      788,
      {-1505,82,657,-663,-386,-2400,1142,-1167,726,-512,762,1065,-1678,1002,-1658,-1046,-2388,136,207,-164,-1433,723,-2082,1135,1389,-3534,915,-745,1007,602,-27,130}
     },
     {
      32,
      1116,
      {728,-1022,-1087,342,-251,396,-1608,-436,-74,505,-2405,-660,-299,-63,-903,-58,515,1254,681,-487,-2389,-856,-353,119,-1066,105,-1068,-1028,1378,-119,-850,-939}
     },
     {
      64,
      -904,
      {-715,-503,-557,710,478,61,-1258,-79,-64,-1184,-302,-363,970,687,-782,-902,667,-198,-686,-1514,-1991,715,-1080,-937,-1227,367,-918,86,-842,85,192,-1983}
     },
     {
      96,
      1750,
      {-386,-26,-1053,-53,701,-518,-903,-1348,-566,-1093,585,-179,414,-1115,-1073,-99,365,1232,793,-90,472,-397,-21,45,382,-106,-87,138,325,179,-70,-77}
     },
     {
      0,
      590,
      {-1097,-1302,-2178,-1949,-566,-1872,1228,149,-336,-1482,-626,-671,-1656,-3141,997,852,1546,-98,-2218,1501,-511,-390,180,213,-314,-3364,394,-144,-747,1190,873,1965}
     },
     {
      32,
      558,
      {743,-570,1968,-1409,-1166,162,840,414,-808,-1744,-96,720,88,-21,613,999,-659,-1210,-3694,336,-679,-297,600,553,-1047,-831,1603,-1820,-3254,-974,-1259,-809}
     },
     {
      64,
      -2019,
      {-183,-788,275,-1055,-745,-254,-1605,-231,-1006,309,-1488,-699,-305,-407,199,-852,29,714,-90,-64,490,-206,-523,1582,206,-502,-278,246,-286,-615,-1451,676}
     },
     {
      96,
      -42,
      {26,-584,-325,-203,1068,-718,41,-101,855,307,-686,-570,-246,26,305,91,-265,1768,-738,-291,730,-412,-85,-968,594,107,-482,-468,-48,396,-250,-1118}
     },
     {
      0,
      2707,
      {-717,-1168,346,-1608,450,231,-189,-1337,-1034,130,1101,683,2297,-621,-2394,911,-767,584,-160,-2197,2026,-1394,819,-1144,226,1021,587,-2146,-2709,1245,-777,-635}
     },
     {
      32,
      1786,
      {-148,1237,-1317,-59,552,1499,-310,-690,-2106,-674,-1931,156,1261,-1113,-2478,-508,-2134,3027,-1334,-5,-363,335,191,935,-1099,-1428,101,-1803,1145,2306,1422,-808}
     },
     {
      64,
      146,
      {1172,-298,816,122,1328,71,21,407,-129,177,1265,343,83,-438,1165,120,908,1014,-473,144,623,28,824,482,-545,-415,-435,28,576,1182,1134,44}
     },
     {
      96,
      -139,
      {-107,-40,-320,-347,-530,751,-435,-693,237,663,1799,16,689,365,-431,-1579,75,2134,63,-210,1074,-267,743,-1766,-941,-856,2053,196,496,888,-160,1292}
     },
     {
      0,
      372,
      {-2368,1506,882,-1319,-1704,-2110,-1291,79,-1133,-65,969,-1336,372,1122,-2440,-20,-1146,798,-627,2183,-608,-277,-3107,-1404,1106,-748,1949,-782,259,-1396,690,1059}
     },
     {
      32,
      677,
      {1215,1631,-1560,-50,185,897,-26,-9,-106,-692,-1883,-696,-297,1506,-44,-309,1728,-347,-719,292,-301,253,386,-1538,-330,-135,-1547,-1106,-3784,-556,-1425,72}
     },
     {
      64,
      -732,
      {-717,-1717,-535,963,1177,-798,-625,1257,-1362,-861,-561,-641,-196,-1146,-184,-613,453,-61,304,-5,972,-815,-350,-1817,-538,-780,-694,1022,-483,5,386,451}
     },
     {
      96,
      1919,
      {1083,137,206,-372,-491,1380,-613,-894,-737,-28,15,-380,-215,-221,-21,-776,-362,220,-361,-232,1243,-688,379,-1121,-320,234,103,-269,344,62,-7,508}
     },
     {
      0,
      -1106,
      {-417,-130,-431,-1034,-684,34,477,431,560,758,621,1248,26,493,-565,153,22,591,-77,-1510,1083,502,902,430,-1267,454,566,65,-270,-594,-224,-346}
     },
     {
      32,
      -1313,
      {447,1485,1245,296,-2309,546,515,3631,509,-86,3052,1029,1550,-1345,-144,-642,-2759,509,-416,14,-2091,-1828,357,-240,613,-1621,-457,-1241,1288,549,102,408}
     },
     {
      64,
      2056,
      {-560,295,-505,-85,541,889,-498,-1184,304,105,-1630,-759,398,-376,250,-280,-414,-409,154,-565,-23,-596,-743,1114,-852,271,-469,-470,-165,-1438,-826,506}
     },
     {
      96,
      2088,
      {-851,-2052,-233,-511,577,-1135,1555,8,726,-701,-995,-380,-34,-1475,-267,583,-218,-1464,-100,-167,326,11,987,1581,-947,-443,513,-36,182,735,-42,966}
     },
     {
      0,
      36,
      {196,-289,893,-2744,-278,-1030,-495,246,-219,-61,598,776,-411,1059,-299,800,-450,3129,-1613,-25,-586,-69,-120,-2345,-2541,436,-1097,205,1244,348,-1385,-1797}
     },
     {
      32,
      889,
      {-1236,-2032,-143,-203,963,1505,-1095,2818,598,-547,-2305,1766,-198,2060,-1610,-643,-531,1322,-544,1623,-1304,622,3883,-1693,-501,-1098,1263,-59,1020,128,-515,-1734}
     },
     {
      64,
      235,
      {-1603,-729,-462,-2106,-350,207,-615,-260,-753,-377,-1160,-1173,-611,-576,-1303,-486,114,600,-574,141,-98,-162,-19,1557,-676,817,185,74,-148,-550,-42,170}
     },
     {
      96,
      2026,
      {1530,287,-272,-157,-1033,493,-1399,659,-746,327,377,-138,-377,-850,-388,-192,1155,-1143,-211,-190,-458,-1046,202,-734,-314,-322,529,-116,-280,-1013,825,121}
     },
     {
      0,
      521,
      {-2021,-213,570,1007,1551,-1813,1404,-2138,-1152,-1952,991,-434,123,-356,2134,-1161,-1386,753,597,-136,580,-320,262,-991,1633,-1470,808,-653,1001,-894,-1104,77}
     },
     {
      32,
      4016,
      {-2813,-1366,-1579,1902,-2564,681,-2567,-2002,720,1258,-2013,916,-1480,2370,65,-429,-1346,-52,-698,475,-2070,-2444,-787,-2790,-562,839,-2690,-2667,712,417,-726,-857}
     },
     {
      64,
      1569,
      {-1736,-302,-17,-781,-445,-1081,-538,-1699,-140,1154,-368,-458,-530,215,109,-244,-1254,-2185,265,-150,-1439,-90,-977,354,-654,-381,-423,458,-1604,-520,-1130,509}
     },
     {
      96,
      -2229,
      {752,-731,-124,856,285,-340,-1909,136,402,597,-288,805,-98,-421,96,-15,317,-722,-387,583,-87,-30,1101,-456,-599,212,83,-12,-14,-938,898,61}
     },
     {
      0,
      -27,
      {1179,-1789,111,-89,-2016,330,-282,-651,-2254,1173,1087,-907,1806,-1526,-868,375,1194,408,-982,-724,-385,-1472,2014,1149,-231,1532,-470,1850,-2990,1202,-523,-1969}
     },
     {
      32,
      669,
      {-303,774,1196,893,792,-1670,893,-1273,399,26,-113,1347,180,930,-523,67,-1811,1060,637,266,-1842,-2948,-1367,78,1701,-3089,381,-1432,-86,883,637,-1031}
     },
     {
      64,
      -557,
      {-1040,-345,-811,-914,-662,1145,-128,309,92,-356,355,438,158,-14,-1205,-324,211,-257,672,364,-2339,531,0,157,-689,1271,-63,-320,-224,-847,-748,-498}
     },
     {
      96,
      2178,
      {-633,-182,-648,-437,261,-1270,-1068,443,-1003,-579,1042,-476,295,1285,-310,-1360,-303,2187,1049,-258,496,-477,-483,-696,1176,-786,2279,-463,563,139,558,286}
     },
     {
      0,
      1995,
      {511,792,902,-1110,1020,-221,-979,-1671,345,-1980,-628,588,2043,-1776,744,415,-388,117,-1807,-236,-878,-1953,1222,-1455,375,1846,-602,-133,-2201,-156,-257,-698}
     },
     {
      32,
      -122,
      {-504,234,888,-423,1405,-1044,616,1615,841,-321,994,-409,1153,-692,253,-1926,1002,-3026,1128,-629,-394,-2656,-1873,-2028,-57,1198,1140,-333,-1699,-1173,-404,-2068}
     },
     {
      64,
      -370,
      {169,-635,-313,-207,-119,-1207,-362,372,238,-1229,522,827,395,-32,-1209,178,-390,-621,-108,-53,1540,-90,-79,-740,1488,533,784,117,-25,379,341,2}
     },
     {
      96,
      -1498,
      {521,1110,264,207,-278,392,1042,-49,-925,58,486,310,48,776,-16,-686,121,-930,811,242,1313,-212,288,314,-45,399,-1056,-484,755,-277,182,-411}
     },
     {
      0,
      1537,
      {-738,-1284,2438,-1967,846,-1449,-856,-1404,-486,-326,697,531,-534,3947,-1182,996,-1076,-48,569,-949,-2349,173,-1840,-98,988,-1149,2208,-290,2148,638,-1393,772}
     },
     {
      32,
      434,
      {-371,3579,-368,-375,-1529,605,-2941,-1016,-457,-350,1997,855,538,593,-1933,-509,-1659,901,-267,-195,336,-2018,-2635,-254,-216,1195,-574,-1601,-434,99,1087,2026}
     },
     {
      64,
      181,
      {-197,-44,584,-316,-1085,-532,-317,191,-170,-1223,-208,175,-161,-176,-907,190,-675,-846,-524,-37,-202,-387,-98,-2504,483,199,830,-31,-452,334,480,-1448}
     },
     {
      96,
      2182,
      {23,79,-89,733,-216,554,-677,294,537,99,-30,-255,831,-516,371,-328,-365,423,316,137,-217,-1251,-641,-337,-308,-716,452,-41,799,-901,-36,-397}
     },
     {
      0,
      -1465,
      {2069,959,-4915,439,-357,-1145,-310,937,952,390,-2563,-256,-2225,-3125,-240,471,211,247,-1389,-635,-1789,268,72,-3516,-1039,1279,-692,1351,474,-1102,2313,-1055}
     },
     {
      32,
      4387,
      {1355,1610,-850,737,-1695,-1124,273,204,2518,-227,56,-510,-876,414,-2242,-247,-1450,-2269,-590,-1567,-1301,-3471,-1993,-50,-770,-95,-28,-560,1461,908,-992,-3416}
     },
     {
      64,
      0,
      {-996,-1101,-432,-568,-1181,-793,-157,-529,-705,-1289,-444,-357,-1654,-1108,-688,-331,-421,-668,-571,-867,-817,98,-235,-586,-577,-642,-565,-701,-629,-361,-554,-1867}
     },
     {
      96,
      -960,
      {415,307,-218,-437,1018,821,1073,-922,144,1004,-72,-148,814,314,-956,-1245,-751,244,126,-80,189,-65,-211,-647,-1277,-291,1832,-306,941,1104,-909,-1727}
     },
     {
      0,
      -1071,
      {-722,-1043,-621,1872,-337,-873,1982,1490,1962,-1783,-306,-1228,-2382,-1137,-1174,-789,-293,-106,793,-9,341,511,-214,49,-1033,-2209,-615,-165,779,2564,2790,2096}
     },
     {
      32,
      917,
      {1921,577,-44,-186,-1219,-356,835,1642,-1994,1208,-180,2306,222,-3545,1854,-1197,-147,387,-200,-1397,-2691,-1190,-196,-1603,18,308,-349,-1443,2237,707,-188,-201}
     },
     {
      64,
      0,
      {-287,-1000,-485,-798,-759,-752,23,-563,-827,-1592,-252,-337,-996,-1051,-1803,-659,-392,-1106,540,-362,-670,-18,-370,308,-481,-822,-1050,-911,-639,-700,-194,-1354}
     },
     {
      96,
      -362,
      {-1133,-130,150,638,-728,-382,-265,-1896,563,47,21,357,454,-1152,362,-652,-195,892,-36,462,127,-75,-1100,-1160,357,669,242,826,241,-379,-617,-680}
     },
     {
      0,
      1598,
      {-572,360,1783,-163,1695,102,-1340,586,-33,-1241,201,-1114,-1134,-961,-1160,181,-789,1369,-276,-515,-1428,516,1491,-463,-2334,-2037,-344,-1788,131,555,-1438,-129}
     },
     {
      32,
      -651,
      {388,1182,2243,-86,1028,695,490,-252,-186,-715,-920,1007,569,1250,-1910,2381,-2997,237,-826,800,1481,351,-1559,-714,957,-3168,229,-824,1280,375,-127,939}
     },
     {
      64,
      1269,
      {-595,373,-497,1360,-82,791,201,-708,-117,-808,-297,-439,568,298,-297,-234,-216,-521,-392,-396,33,-441,-826,-1152,479,347,-632,-550,71,-340,-307,-618}
     },
     {
      96,
      -163,
      {706,358,447,81,892,-1379,366,-228,230,766,297,-336,786,679,-507,53,-2004,-1574,727,-81,714,-669,652,45,-525,-499,642,383,587,-1436,400,582}
     },
     {
      0,
      1921,
      {449,106,-805,-2505,1217,-386,-100,443,-1244,-122,-453,335,-960,17,862,627,-2086,-830,-1141,-1088,-1409,-970,78,-1971,-1403,477,-89,492,-1261,792,-1639,-650}
     },
     {
      32,
      640,
      {-2258,-952,-1738,896,-358,-639,-729,-1100,756,1599,-312,687,61,287,-341,578,-793,1214,786,-799,-1531,-142,-330,-700,-43,-120,-1124,-1238,-1089,1176,377,-593}
     },
     {
      64,
      16,
      {141,-1007,607,912,1391,125,343,-234,419,565,147,-534,357,-1067,813,415,-489,-867,-313,-384,-1338,-1314,-438,-1708,990,-1355,-91,-49,-14,-291,-167,-938}
     },
     {
      96,
      2227,
      {1625,1136,145,-226,-1029,-1375,1223,833,1477,-609,136,-442,725,-491,-957,90,-174,21,12,-394,710,-1435,395,186,-645,475,-779,-39,802,-176,-1172,-686}
     },
     {
      0,
      1436,
      {-771,-1633,340,558,99,869,-477,-1093,-585,-58,411,1057,-1611,2279,-1744,195,824,-1209,368,-1519,-1344,1045,-1430,663,-269,-2076,1837,-1479,1146,-2,229,1069}
     },
     {
      32,
      2201,
      {174,-1696,-279,511,-1273,-780,-1826,-1201,-87,288,-2184,1012,-98,-795,677,-884,-166,-9,-2192,-1413,-1163,-1637,520,-1341,-1186,-7,515,677,-2152,-645,-506,-2399}
     },
     {
      64,
      161,
      {-104,-202,130,-1654,261,-996,-1138,-810,145,-476,-318,602,338,-48,-1136,-491,-395,-779,-443,-631,195,-1608,-259,-327,-760,236,-197,-458,113,415,-378,-875}
     },
     {
      96,
      1920,
      {-874,-1215,-442,-277,35,586,-626,-599,-216,-739,-517,-3,70,242,157,-246,-539,1816,61,-58,1031,-449,-1312,-810,593,-551,904,118,685,-733,-606,-1192}
     },
     {
      0,
      -1481,
      {1596,-539,444,89,1448,-552,309,2792,1818,-2979,1410,-635,-24,-912,-2519,-765,-1024,-1159,1337,-31,1238,-2095,-685,1249,921,-1042,125,559,-715,768,-1343,584}
     },
     {
      32,
      1617,
      {-2320,-679,-514,900,-1076,-729,-954,309,-3809,252,-168,2640,222,-935,-1409,-1447,-1465,-1501,-204,-887,508,133,1343,201,-306,-678,1302,94,267,470,1132,-557}
     },
     {
      64,
      -482,
      {309,0,-740,720,-1260,966,-719,-63,183,-572,1107,846,242,-697,-1466,107,-157,-1627,596,49,2008,295,810,-778,87,1320,37,362,283,-48,951,-266}
     },
     {
      96,
      1712,
      {-1314,-651,-343,-105,-231,-94,-222,898,-1488,161,-294,-562,83,-1289,-618,55,349,1726,1061,-294,420,-624,-269,3,166,533,559,-630,-229,-433,475,-105}
     },
     {
      0,
      -1176,
      {1147,-869,-427,-264,378,-594,-52,329,-523,700,-94,1279,292,401,-1516,-584,159,-1335,-785,753,-117,802,-534,-896,681,-920,-158,-335,334,534,1011,-1370}
     },
     {
      32,
      2930,
      {-300,-1274,-175,-123,-1204,-821,-1435,-230,1520,-1878,-1076,126,384,834,-657,-2729,-2559,509,619,1529,-2396,-2031,-1627,327,-923,-825,-1504,-419,-43,1081,-1085,-462}
     },
     {
      64,
      36,
      {100,562,-429,-1148,-2287,-290,-853,300,-745,474,608,460,514,119,15,-1041,-744,75,445,-141,-1109,-64,97,-1213,-14,-165,358,-83,-392,188,1513,-490}
     },
     {
      96,
      3892,
      {-800,313,467,-329,341,-480,31,-485,97,-416,170,-153,-123,1360,305,-562,117,-943,-203,-294,-297,250,-691,-572,525,-2119,-1149,-231,-419,225,-559,-89}
     },
     {
      0,
      1340,
      {64,-1073,-438,177,-524,-326,-592,-791,-1082,-131,-615,963,-88,1380,-265,977,-832,-610,1203,-344,-145,-621,-641,769,-38,1323,325,-159,-1602,1171,4,1320}
     },
     {
      32,
      179,
      {507,-2502,-1419,-725,641,-1069,-477,2087,1744,-738,-1109,1624,-1571,1287,-278,865,864,-2684,590,-1017,-797,-2495,556,-1733,-92,756,2677,2494,-253,-754,227,-2457}
     },
     {
      64,
      1264,
      {131,820,-77,1132,-109,780,-138,-558,-245,673,-94,-375,-290,1933,1370,-228,86,-320,-273,171,-845,613,-1591,-464,-537,-707,-424,-832,176,-689,-918,-451}
     },
     {
      96,
      -256,
      {-258,719,200,-247,102,-2076,1635,1195,-1009,457,-1202,-153,283,618,666,-97,845,-643,114,18,1286,349,-97,1141,10,-434,-522,-207,345,-28,12,-764}
     },
     {
      0,
      2592,
      {529,328,-533,814,469,-267,-239,-920,-2645,5,356,-154,2042,-373,-2340,-2239,-479,-501,1431,326,-2017,691,-22,-154,-1296,627,-529,-786,-441,-1414,1993,-1761}
     },
     {
      32,
      1269,
      {1850,-2427,-527,-1733,-1283,-1155,484,2684,-647,-1622,1634,1863,-1819,-2034,1592,1579,-990,-985,627,-795,-218,1737,-481,-1103,-859,-1706,1128,-1014,3014,-465,53,2170}
     },
     {
      64,
      -96,
      {-1105,-661,-310,-1065,-1638,179,-376,254,-829,-392,-224,-681,-1332,-188,-1600,-1128,-855,-192,-155,-259,1060,766,34,-363,-651,-1349,803,-324,-729,-756,-883,-70}
     },
     {
      96,
      -47,
      {-381,-187,-282,227,-202,-49,-102,-188,-1279,948,188,281,-416,1393,-1367,870,786,-2265,20,173,-518,1440,735,-224,-452,-76,-261,-6,-290,292,-719,-934}
     },
     {
      0,
      794,
      {170,-224,-1311,598,116,-2584,-1287,-130,-1210,151,934,615,-275,1348,287,-1838,-901,-885,1538,-17,-271,500,60,-656,270,-1551,2369,-1992,732,-1473,-66,-197}
     },
     {
      32,
      1982,
      {-244,1243,-246,-1642,800,-1025,-1124,4035,-317,-941,211,1602,-1424,1045,2118,511,-1170,95,-731,-2069,197,229,166,-655,-1353,-1197,1263,-151,1236,91,511,604}
     },
     {
      64,
      57,
      {1036,-469,-411,261,93,184,214,-8,1024,110,74,306,460,-123,-1815,758,-604,-1514,-689,-148,-627,-329,153,-2235,713,13,592,-535,585,403,-104,-1453}
     },
     {
      96,
      720,
      {499,110,-140,38,-132,1240,139,860,-1548,-1029,12,-317,-648,-973,1111,-109,389,-1817,619,-236,-1160,-841,136,-316,-263,-117,498,-370,-525,-326,-429,-471}
     },
     {
      0,
      8,
      {-1634,-2580,-361,180,247,170,640,-3419,399,-2613,862,1098,601,-680,193,2081,252,2077,436,-680,1876,1307,-1555,-2776,-842,-888,-496,-623,836,478,811,251}
     },
     {
      32,
      929,
      {-2181,230,-436,780,0,-2624,636,348,-33,1552,2092,-36,1947,443,-106,-1900,-898,-2807,1128,443,1628,90,-373,-134,1270,141,214,-1273,357,-1313,1482,-217}
     },
     {
      64,
      85,
      {1026,-644,-384,-537,296,379,0,-218,238,641,-592,-443,732,27,214,85,-537,-1366,-982,185,-84,48,-200,-1445,794,179,-182,10,234,286,63,-960}
     },
     {
      96,
      4417,
      {-130,327,-423,-294,-52,-469,193,164,786,-326,-166,47,-217,-594,-254,-441,-294,-433,2,70,321,-666,-132,-63,-188,305,97,-193,-212,-1971,82,120}
     },
     {
      0,
      425,
      {806,719,960,1845,-47,-960,203,3200,561,-89,-424,298,2367,-1686,1231,-739,78,-2320,711,-1450,3053,574,920,-1668,438,-1380,954,-944,-895,3010,68,203}
     },
     {
      32,
      1310,
      {931,-837,1182,152,712,1873,990,1634,-978,-420,-161,641,-1202,-1115,-1108,1321,-940,-1534,-902,-1326,910,122,386,-1087,-1950,-1838,-511,-1401,-710,1967,-1896,1791}
     },
     {
      64,
      1051,
      {26,-35,138,-213,441,531,195,-589,-336,173,-303,-675,332,126,597,-332,232,-667,-534,-366,-2485,-1404,-243,-656,-219,-263,-814,-94,479,-735,-401,-393}
     },
     {
      96,
      1576,
      {-1056,-996,924,-624,-2013,-392,-112,-55,1020,-1200,202,-624,-249,1454,1081,117,-1356,-619,161,-867,-192,551,-813,313,-649,208,175,-1453,-165,219,-326,-142}
     },
     {
      0,
      -593,
      {421,-1971,1613,-627,-2887,-61,0,1413,-1782,554,988,28,-1313,-944,2192,-1560,2057,-2682,2396,760,1405,789,579,11,698,-2113,1515,35,1426,790,1861,1571}
     },
     {
      32,
      1266,
      {177,-493,-317,-3566,920,-204,-669,-1261,-606,-1731,-1161,-268,191,-1262,51,-1574,141,-969,-184,-1550,-251,-1003,-510,-319,-738,-1346,-192,-562,-698,984,-1007,12}
     },
     {
      64,
      1421,
      {514,96,-337,-248,1269,319,547,174,-421,379,547,-1343,331,1097,-235,-206,142,-1361,-69,-243,-1455,-553,-570,-751,-54,801,-1154,-393,121,-540,-862,-813}
     },
     {
      96,
      -2378,
      {-505,-124,228,179,1181,-837,-371,-1765,-309,-463,-441,277,-583,577,2024,-496,1025,863,425,373,112,88,663,-1687,264,788,88,331,-67,572,-297,289}
     },
     {
      0,
      -788,
      {662,-560,418,24,-828,-1954,323,-263,215,-859,101,-177,-1432,-2547,-1948,636,-865,164,388,1109,1283,-1168,-1450,-1405,857,-2027,-1331,885,412,642,1561,-887}
     },
     {
      32,
      602,
      {57,-199,-1145,1239,-30,1600,-512,-508,1086,-1785,-1580,-1722,-1727,-1119,-2191,-1187,1053,533,-660,1121,-247,-465,-274,-286,-1974,-333,-286,579,-53,-257,-2228,-94}
     },
     {
      64,
      -1529,
      {489,-782,147,1052,-110,663,715,974,580,-112,-401,787,825,-554,-1222,670,-679,-826,167,-46,-177,204,508,-764,815,-67,-105,-492,664,424,-128,-612}
     },
     {
      96,
      1307,
      {-155,-115,-47,-476,-392,-33,-456,10,-738,522,691,-439,-3,62,-117,423,360,-926,-276,-258,-508,618,928,-292,-844,735,348,-299,-612,157,674,-1261}
     },
     {
      0,
      421,
      {487,-117,-896,1703,2,-1825,-569,4,2532,-657,-1070,1220,-1584,-1005,-435,-461,430,148,-290,490,953,-2814,-688,-1075,-1299,-1800,1474,-2627,-1494,-184,1390,-86}
     },
     {
      32,
      973,
      {82,-54,606,885,536,43,-1814,915,77,54,-2947,-489,880,170,-356,44,-943,-1829,524,-2727,-729,-630,476,-1624,-514,-1393,1562,88,511,2078,-2166,-2864}
     },
     {
      64,
      75,
      {-1507,-556,-516,131,-1114,641,-412,387,662,-877,-931,869,-74,-577,-1015,415,-1663,-1487,419,340,884,503,894,-1011,221,-133,792,-703,-169,617,383,-602}
     },
     {
      96,
      1118,
      {560,343,-597,-439,-336,50,-109,-25,-566,173,136,-604,728,-367,214,-566,561,-371,772,-1,-402,-359,972,231,773,-89,-24,-327,953,825,-20,-222}
     },
     {
      0,
      -194,
      {-725,-1316,128,-141,1344,-253,1256,404,1182,-315,-449,-240,-235,382,713,-697,-1926,1843,-759,385,2155,1237,-1817,163,-1270,-1883,2675,-2784,390,-116,-322,-1053}
     },
     {
      32,
      619,
      {-468,296,631,554,-283,1218,479,350,-723,-376,-355,3,-824,-1026,-2519,-224,-152,1951,-555,650,-42,-1481,265,-61,-451,-594,35,-1089,96,410,-521,-2354}
     },
     {
      64,
      -526,
      {-856,-521,-598,533,291,223,291,278,534,-946,891,912,769,-245,-1698,191,-139,22,362,187,-83,546,566,139,1289,524,1013,-357,741,697,557,-608}
     },
     {
      96,
      1324,
      {-603,-231,1017,36,290,121,-525,-334,660,145,-175,-34,-1228,-303,-2949,-496,-293,-1101,-326,-144,-210,114,-202,-330,-274,-114,513,154,-1276,175,968,-403}
     },
     {
      0,
      3000,
      {54,724,431,-2165,-503,-755,-143,1209,-1586,160,-123,-976,1078,-1258,-336,-49,-812,-1895,699,-1687,-83,-97,983,-51,-121,-1221,-2158,1087,-1457,114,-421,-711}
     },
     {
      32,
      2086,
      {-77,-730,-885,-2240,976,-95,-277,512,-782,-1001,-445,-939,1408,1937,-1305,-130,-1877,608,7,-294,437,-1545,-113,-454,-2286,825,-132,-1050,-340,-532,-1374,370}
     },
     {
      64,
      591,
      {836,-91,85,694,1386,328,569,7,36,737,143,-640,777,-321,721,285,668,-587,-737,-344,-398,-416,-214,-791,423,277,-840,-320,175,435,-457,-493}
     },
     {
      96,
      -1808,
      {1369,-2001,-458,343,266,-572,221,-383,-393,106,52,27,-189,875,318,64,-1189,1165,-1133,76,458,754,970,-167,-292,491,-1098,135,-74,270,428,781}
     },
     {
      0,
      1373,
      {-1700,-129,-391,-70,564,-783,-346,212,297,-532,-968,1573,-2409,-1559,-991,-580,472,-555,2265,650,107,-3068,-711,-177,-191,-1405,297,290,-1006,-1466,455,-724}
     },
     {
      32,
      331,
      {-1394,-285,-1826,1490,-567,-506,-780,-1005,-1377,-1007,906,-1640,813,-227,-842,-34,-2155,-785,1582,-1595,-294,-405,-293,134,817,-1649,-402,28,-221,511,-723,-1345}
     },
     {
      64,
      28,
      {1035,-955,-192,71,-449,459,-60,-1465,840,-212,-672,-1182,-58,-515,306,576,-911,52,714,-789,84,-975,-449,886,303,-718,4,-548,182,-127,-702,-91}
     },
     {
      96,
      1410,
      {613,342,306,-82,-4,-69,-356,481,229,522,-506,173,-2085,-84,-566,-1246,404,-17,597,-161,-296,925,-38,-2074,-374,916,-602,78,-1422,-348,1948,-718}
     },
     {
      0,
      284,
      {-883,1437,-167,-1971,1648,-1478,-1214,-1337,-456,-823,-1270,1343,249,89,722,997,-752,480,202,-1142,-1812,-229,-791,35,-2552,-77,33,-332,-797,-3529,918,-401}
     },
     {
      32,
      -161,
      {1725,-779,2175,96,-1169,-1093,-910,-537,-1299,171,1074,-585,-1539,-118,-400,524,671,-653,835,-609,873,-365,718,-1755,1789,1262,-1406,-141,317,-1358,-411,1822}
     },
     {
      64,
      1369,
      {405,604,-642,-446,240,-889,-498,-565,432,-298,555,-325,-111,836,28,-632,-832,-418,-214,-576,-53,-592,-628,-1435,47,280,400,32,-383,-656,-924,-155}
     },
     {
      96,
      1447,
      {-973,1068,1392,-49,238,310,-676,-1101,-710,247,35,-339,-418,-205,643,1424,303,652,24,-29,271,-7,-1234,-112,-1777,-865,522,54,-459,-571,-1594,1083}
     },
     {
      0,
      893,
      {173,-792,446,656,1780,-2636,-743,719,561,-1407,-307,673,135,1077,-2479,-724,604,59,115,-376,27,-1620,345,-611,1462,749,-2175,511,508,81,-1345,-1687}
     },
     {
      32,
      -1482,
      {-626,383,1803,-533,-122,-135,4378,-1039,-183,792,2669,311,-925,863,1184,1510,-313,-1616,-2733,-1192,1472,-1036,-1341,-1725,1232,180,-429,729,7,676,734,-242}
     },
     {
      64,
      -45,
      {-452,-127,-943,44,-947,-376,381,-1484,-536,666,600,168,-447,-123,-263,-124,5,-40,-1078,-497,-176,270,-268,39,-945,219,-614,145,-325,-473,-168,-345}
     },
     {
      96,
      1924,
      {69,43,-266,-167,-548,300,357,-40,233,-761,439,-470,1148,-627,-540,-845,-666,431,-233,-78,1246,355,-1019,-257,-126,49,-379,-8,381,-808,-684,1076}
     },
     {
      0,
      4839,
      {291,472,-480,-242,-2274,-1897,395,-650,-2815,-2062,-767,-1243,1029,-2746,1450,-1462,2925,-1809,-1380,1749,-825,-1338,294,-240,2580,-568,1292,1209,1494,1269,-1683,2361}
     },
     {
      32,
      1126,
      {1305,-1014,-2121,-366,-1291,3422,-961,-264,-2952,256,-2147,1513,474,-953,-852,-62,-916,2956,1276,-686,2108,1327,-199,-2828,-1366,385,-2058,540,-64,-1345,-354,-25}
     },
     {
      64,
      -959,
      {-522,-315,-592,244,-268,-614,-572,-235,520,-179,-745,-711,422,-371,-774,295,-161,218,43,-79,1075,-1304,66,-413,61,-236,-307,169,-345,277,-553,-598}
     },
     {
      96,
      -278,
      {-1569,1123,745,-29,55,-86,-329,463,-1466,1232,448,149,95,-817,2112,-745,150,-586,100,77,-242,12,35,-1169,-1678,-116,-107,-312,-11,1402,-1074,-352}
     },
     {
      0,
      -1099,
      {81,537,-150,-1831,1339,-1576,-568,501,-792,-1640,-731,-688,-84,1134,-2583,867,58,-533,81,39,-1931,604,-302,-1202,1798,-62,573,44,818,283,-747,220}
     },
     {
      32,
      1645,
      {-196,161,-1707,-381,1622,44,-2028,-347,-2386,-583,-1894,-1063,796,1695,-525,610,-1537,1640,736,-748,-823,-2284,294,-418,-500,629,-46,-28,931,-188,-183,-2014}
     },
     {
      64,
      -631,
      {-252,-988,-24,-215,-92,772,131,1018,-766,-70,358,-30,-164,-930,48,-273,491,336,1279,155,-1109,639,-626,671,-539,111,708,305,45,-408,416,7}
     },
     {
      96,
      187,
      {-1111,-596,182,-166,-293,-106,3899,-1631,-836,-137,-580,-460,767,-750,-150,-19,1775,913,742,-677,518,-71,323,-1711,-175,285,759,-694,321,-62,80,-133}
     },
     {
      0,
      816,
      {-3597,1952,1756,961,148,1473,-1027,-1119,540,1731,118,-1355,-1235,-3099,398,-154,-734,-2383,157,264,-1855,1092,501,-81,-300,346,-2352,-114,-1218,1384,-1057,-345}
     },
     {
      32,
      -806,
      {-1915,-318,-136,1305,-69,-563,-1332,-2050,-444,703,2282,36,-1562,-1540,1357,-245,-496,-871,-8,-1135,1583,-1424,-1139,-736,2424,851,26,1926,-313,-937,215,-232}
     },
     {
      64,
      -567,
      {-809,-602,-8,-1447,406,-456,-197,346,-1950,334,363,-255,-379,-608,170,-156,378,-77,872,646,772,-211,332,741,-123,-523,-261,24,258,-44,-297,518}
     },
     {
      96,
      430,
      {-1127,703,-301,-807,115,582,-213,1160,-299,120,12,-800,-827,-650,888,-609,-506,1251,-1003,-756,68,446,295,160,-2776,1784,-321,-782,-550,-861,-1014,576}
     },
     {
      0,
      -581,
      {1820,805,-680,-692,1490,-1820,-778,1439,873,-600,876,-1516,336,-2843,-1494,921,694,841,945,-2734,637,-533,-13,-1440,655,-939,479,-803,-1052,-1830,-914,-1794}
     },
     {
      32,
      4205,
      {93,-2120,-1234,1319,-2623,-673,134,-923,-531,1461,1780,43,-506,549,-1377,-1338,-714,-143,157,950,166,-2299,658,-2341,1840,222,1064,-2536,355,-1927,-1045,1606}
     },
     {
      64,
      642,
      {-422,936,-569,-1383,244,-545,-389,-574,-343,-1079,0,-214,117,897,179,-888,892,-524,143,91,-618,-276,-20,-1391,-808,247,383,212,-500,-521,78,-979}
     },
     {
      96,
      2543,
      {-702,-40,-233,-701,-83,-245,145,-89,-829,359,377,-293,292,-1179,179,-862,1103,-453,1074,-146,-453,-1250,-778,-225,1084,-499,1892,157,839,-853,616,-78}
     },
     {
      0,
      504,
      {637,-2474,-53,-2504,2074,-1347,-1012,-455,210,76,540,-2361,-447,2662,-2279,-1314,247,-602,1885,-2264,1454,36,91,1971,1662,-1797,-602,-341,827,1460,-462,-376}
     },
     {
      32,
      191,
      {2658,405,548,-1305,714,1324,1787,109,-1618,-1109,1569,634,791,1391,-454,-128,-304,-948,-513,-1888,15,1235,1342,-1423,-3099,-581,-327,-1366,-1320,-174,588,921}
     },
     {
      64,
      -771,
      {-903,-570,-234,1082,280,102,166,-291,583,203,-221,682,-359,-735,-1132,826,69,-672,-268,724,-437,815,575,1324,-218,38,207,238,-960,119,226,57}
     },
     {
      96,
      522,
      {170,1447,-128,-196,401,-597,-2271,672,-288,-483,-680,-525,483,-860,-1169,-61,64,1081,-1127,-371,556,-528,870,161,334,-218,604,-1032,331,-1373,414,-278}
     },
     {
      0,
      896,
      {407,950,-2262,-1205,317,-544,220,1085,-829,-2090,675,-1185,1236,999,-2870,-574,-1644,560,-451,-1286,-1317,-1572,-1922,2567,-1080,-467,1499,386,-861,1119,-408,900}
     },
     {
      32,
      -482,
      {-211,-1393,-1004,-725,774,1510,671,379,381,636,-1693,1035,-517,-685,1298,-299,1306,3097,647,472,-434,-670,-1928,-1204,57,1422,-646,95,644,580,-977,-1211}
     },
     {
      64,
      -418,
      {622,-505,-96,641,478,795,3,-100,24,354,504,-34,-337,-257,38,752,-397,-1515,-195,186,283,-252,-726,257,900,-99,246,-112,943,272,-420,-419}
     },
     {
      96,
      593,
      {879,499,-143,-171,-285,-117,611,-967,273,967,-1093,-345,-6,-141,-991,-783,56,417,-1611,-70,-407,-333,858,-630,1721,649,-1658,107,214,689,-647,-310}
     },
     {
      0,
      -281,
      {3029,-1909,-1109,-425,-937,121,987,-232,312,-905,1399,656,229,2618,-280,369,1019,1733,-1323,-307,1886,-1539,-445,1673,623,558,1295,82,-4,-732,-1208,-306}
     },
     {
      32,
      239,
      {1501,1459,-984,1552,-280,-836,2321,-1270,1117,1218,323,-612,-16,1591,-387,2028,-877,0,-414,-791,-155,670,-876,-2639,655,536,-1541,-1567,-44,-572,886,1398}
     },
     {
      64,
      430,
      {-569,-203,-447,-1379,426,-544,-568,726,-511,-175,-171,53,-192,-180,35,-978,-341,-938,-2,-749,-157,-910,89,-64,-1288,-365,-248,-618,-1161,483,-389,-501}
     },
     {
      96,
      -477,
      {271,45,-601,512,855,611,-838,-1975,335,946,972,469,208,-1667,-1481,-595,-731,-654,-44,284,994,-702,-278,-348,830,802,-2877,97,523,1186,-402,-916}
     },
     {
      0,
      33,
      {640,645,-1107,939,-2522,2180,-350,1682,-389,-375,906,553,1246,1509,-1469,-759,-386,1388,-1482,-1639,1140,-2215,-1503,1893,-317,491,2957,851,-46,880,-2123,-474}
     },
     {
      32,
      2042,
      {-444,-1849,-1746,-700,2389,1227,1611,702,296,1399,-2461,-497,-82,514,-1428,-1259,-216,3,2040,1682,-270,1622,-214,-988,1104,-484,157,-624,-334,156,-523,438}
     },
     {
      64,
      -357,
      {413,-694,776,158,-301,492,156,-712,-152,716,34,220,-990,-881,478,-353,74,-142,140,-593,-103,83,-523,1900,743,-638,-247,258,580,513,-1142,151}
     },
     {
      96,
      -98,
      {-1906,488,-875,-902,-652,732,-55,-484,413,-48,812,-1525,-1081,-149,1714,668,-654,1056,-882,-1080,-80,120,1322,759,-1575,493,-490,-2222,-857,-771,-379,755}
     },
     {
      0,
      1082,
      {1536,-720,335,-324,23,-68,-962,1749,-972,566,-2472,-513,-2426,352,-12,273,628,-1468,-439,970,174,1849,1586,1151,-143,-3979,-2960,1081,-1063,939,2329,330}
     },
     {
      32,
      2502,
      {1739,196,476,-246,-1161,-210,2165,-161,-1715,-882,337,-1027,-1876,-149,39,676,475,-2927,-857,-3197,10,260,-824,-738,-192,1158,-616,1285,-545,-871,927,-260}
     },
     {
      64,
      -182,
      {-334,-401,-529,-501,-629,234,490,400,337,-139,155,-485,-662,-699,-269,69,634,1206,178,-8,-2976,1219,-652,-680,637,-612,46,-616,360,249,-85,-53}
     },
     {
      96,
      -1674,
      {-1015,-1005,1037,-749,816,1380,-87,-88,-661,-447,530,-462,1396,1692,-99,606,-2120,-412,943,-231,762,321,496,215,690,-1190,-144,-308,887,-943,319,633}
     },
     {
      0,
      -8,
      {-2140,346,-1025,-969,374,67,345,-247,-3254,-2151,-134,1140,1007,115,-575,725,140,995,-1126,371,-1385,-846,86,-658,58,-1386,-454,28,677,160,879,-1940}
     },
     {
      32,
      4996,
      {829,281,-1072,-1375,-343,154,1868,845,-499,-154,-18,1068,-477,371,702,731,-725,1792,1387,-889,428,266,-830,812,-3711,-1262,-2076,-770,564,-488,-388,-970}
     },
     {
      64,
      284,
      {-453,-219,59,-968,-633,-389,-175,-424,390,-795,-230,-178,-619,-500,70,-408,208,-663,-252,-882,-10,-1407,-671,880,-344,-180,-1581,-29,255,-477,-554,41}
     },
     {
      96,
      934,
      {393,-1112,233,538,343,-328,-505,-441,-29,-1032,760,411,1438,-1702,108,513,-749,-120,561,708,137,-1955,292,415,439,-786,1361,641,759,-1145,-453,160}
     },
     {
      0,
      1208,
      {-2069,1655,-126,-772,772,823,-283,-1116,744,-664,-537,1375,-57,1031,1258,-163,-878,623,-159,-2582,-767,1442,-419,-2703,-1810,767,-31,-1799,-73,-341,-690,790}
     },
     {
      32,
      -969,
      {-1924,-1054,1688,-2186,1719,2531,468,-35,1780,-1232,8,1584,-592,3204,-882,-1206,1622,-1905,1714,-729,592,3210,464,-890,-1255,2811,-369,460,-1483,54,-1345,-76}
     },
     {
      64,
      163,
      {437,-2,14,-9,950,-396,-869,-464,-466,478,-455,-454,285,-355,352,-337,100,-1426,-584,41,1469,-978,-15,-745,-986,578,-375,-9,-170,-462,-141,-744}
     },
     {
      96,
      889,
      {-229,-541,123,745,-465,-1010,-95,339,157,-780,1498,588,917,-2535,-250,-503,2391,-1040,750,526,199,-1142,751,-324,1024,154,751,656,878,-571,-1050,-107}
     },
     {
      0,
      -467,
      {-349,704,-1063,-1721,749,2810,-670,184,130,-1439,-849,-1061,1630,-983,-692,507,-1044,1411,290,-364,-1493,2057,458,1142,-1082,3,230,-307,304,-677,-1838,-717}
     },
     {
      32,
      511,
      {-189,-3403,-1166,407,-490,1169,703,1732,391,700,342,-1320,-1019,29,-1,-301,399,491,1309,-1,613,-864,-408,5,1038,-229,-760,171,26,929,-753,2557}
     },
     {
      64,
      48,
      {153,-306,241,187,33,-26,-76,-879,234,708,-239,-309,525,-412,709,-225,220,134,-290,-745,-638,-1392,-593,900,386,52,-766,-282,306,218,-959,383}
     },
     {
      96,
      873,
      {1235,-444,1080,-780,392,272,88,-21,-605,-1209,-97,-549,77,754,-72,-1294,-477,-183,36,-733,212,-584,51,-771,-245,282,929,-629,88,1198,34,-317}
     },
     {
      0,
      94,
      {-1054,1256,620,-796,1587,-1256,-109,1413,-357,-184,2178,-482,1000,1968,1470,-633,-240,-1091,-828,742,234,69,47,782,129,-1174,-940,66,91,546,-2114,-1870}
     },
     {
      32,
      1440,
      {-127,-455,-777,-666,386,-1773,-1183,804,345,-17,-927,-828,1031,-430,-784,1435,-502,25,223,331,-1241,721,-371,-430,1541,332,-235,-842,-454,-467,85,-202}
     },
     {
      64,
      -36,
      {479,-171,-183,-1486,-753,-465,221,-363,-855,-336,688,-521,-961,-5,513,-636,119,1236,-347,111,-17,1198,262,-164,-542,89,-329,357,-119,-133,201,-298}
     },
     {
      96,
      1928,
      {-633,-423,436,-1412,838,1116,1633,-411,265,518,63,-1490,-869,-204,-742,-766,-33,824,14,-1263,-228,301,-216,562,-2314,21,-705,-1488,-662,148,353,587}
     },
     {
      0,
      452,
      {-2546,166,-102,233,234,-340,-652,1894,-1539,-144,-1068,384,-410,1385,-611,-152,820,1589,-2514,374,-129,-1329,-104,-92,1598,238,-614,193,653,-272,-540,-1111}
     },
     {
      32,
      737,
      {98,-1658,-775,-749,61,-2114,675,867,1136,780,-311,204,1443,-428,-62,1406,-5,-545,446,-71,-2222,1008,533,-181,-158,-906,323,-1215,-809,463,149,1435}
     },
     {
      64,
      170,
      {14,152,-438,-640,-689,-219,1,407,-4,70,-61,248,-421,0,-422,62,-536,-40,395,-223,307,-659,158,165,11,297,252,-119,209,-398,-146,-14}
     },
     {
      96,
      987,
      {-730,-637,376,302,466,-245,-130,-525,-885,-345,-122,379,29,-605,-302,-182,-628,-685,-188,519,165,87,-655,268,-1167,-118,521,296,285,-414,-101,-458}
     },
     {
      0,
      860,
      {-345,-355,-428,-574,-2225,-318,-664,-6,-802,-137,700,-545,-626,-785,-198,-923,-867,-154,-1517,731,-1105,-258,373,471,728,421,316,-619,-672,-29,1832,-1370}
     },
     {
      32,
      365,
      {341,-2236,308,-673,13,433,-672,741,-480,141,-910,835,-1079,1144,-592,-1632,589,1064,-119,-577,456,-275,-450,-2270,1627,2489,-322,1248,-721,-715,450,-852}
     },
     {
      64,
      454,
      {-58,666,-9,-451,-737,111,-187,-352,-89,45,263,-535,-375,697,547,-407,442,680,2,-221,594,-700,-608,619,-519,-70,-591,158,-378,-1012,-617,53}
     },
     {
      96,
      -1188,
      {-878,-547,918,-870,789,459,429,-560,441,1965,-365,-628,879,-298,164,711,297,-459,-402,-689,463,21,-330,123,-1205,997,-1450,-683,967,389,-437,925}
     },
     {
      0,
      -1193,
      {739,214,1335,1086,363,1056,653,-249,-13,-1513,-185,-36,-1273,189,-1073,79,-1375,-502,867,940,42,-685,9,1673,-501,-1185,590,-228,699,94,-63,658}
     },
     {
      32,
      703,
      {-475,367,1021,151,-1554,-669,933,378,-1033,237,-352,220,-405,442,399,-350,-516,81,-1613,-140,594,-400,-355,-1716,1459,393,-591,-1213,-987,828,526,1178}
     },
     {
      64,
      176,
      {-209,-40,-463,-188,402,187,20,-233,186,698,-177,-41,128,99,397,-235,-838,-578,-898,-393,-533,-635,-484,-1524,-15,519,-92,-456,-270,-180,-449,-52}
     },
     {
      96,
      504,
      {852,913,-155,171,558,-22,-1110,312,140,809,-308,34,337,-342,-325,-593,-381,757,-257,-205,-180,-509,-514,-253,666,569,166,-190,336,-566,-290,-987}
     },
     {
      0,
      -67,
      {-606,-408,-1795,-215,198,587,694,103,-1291,-1128,1059,-812,372,-736,364,-614,-670,-759,739,556,-420,-1057,319,-183,-774,348,-1334,990,312,984,518,28}
     },
     {
      32,
      493,
      {151,390,151,502,-230,575,-22,61,-910,55,117,284,-472,822,-623,-176,-749,603,1224,-242,369,-1042,863,-818,-1228,-374,732,0,881,-131,80,-92}
     },
     {
      64,
      486,
      {-45,122,-241,288,-83,-50,-252,-442,229,198,-104,338,237,203,67,320,465,-1404,-152,-258,-582,215,194,-717,22,301,614,-113,-72,-16,260,-339}
     },
     {
      96,
      -195,
      {-587,-563,-303,51,-694,-611,-242,-659,-1137,-1452,410,-8,363,-600,-560,825,721,-144,-631,49,-40,-592,432,1017,1677,-505,1008,-56,127,183,1110,882}
     },
     {
      0,
      932,
      {-188,880,-293,-548,-136,-527,334,-473,-60,-763,-498,-889,1091,-592,-273,-639,560,-431,-17,288,439,-795,-419,-668,-869,564,569,-544,-396,1106,-945,49}
     },
     {
      32,
      141,
      {1731,-92,-452,-367,-248,114,-1164,67,-238,-351,-351,327,-109,-178,-1039,317,683,-372,-427,-276,-316,-165,46,-573,-1082,-419,-552,-389,-508,-604,4,-729}
     },
// *********** Cells of layer 3 *********************************************

     {
      128,
      -3013,
      {-1653,-1894,55,286,2204,-573,-251,-34,-257,193,-481,215,-966,-2048,-1109,-1377,669,610,-53,-199,584,856,1299,-78,-213,-214,1606,283,-2730,-404,-552,-91}
     },
     {
      130,
      -500,
      {-459,-343,-1863,2381,-550,89,515,432,-534,-65,420,128,-671,-305,-625,233,282,-783,89,620,516,-732,-530,-580,280,-206,-945,2476,38,-1293,34,-1795}
     },
     {
      132,
      -6513,
      {3917,-211,440,-261,684,1041,295,47,-577,1441,-236,34,958,-235,-380,150,980,-834,-254,29,1457,-281,-423,-157,-2215,395,-1031,2,-1128,1756,-52,148}
     },
     {
      134,
      409,
      {-31,786,-1617,1314,636,-400,-1212,1113,-870,-312,359,-343,-97,-758,-172,-141,320,-716,-1147,93,-632,-426,-139,-97,0,-913,598,1525,-661,-193,2669,-1909}
     },
     {
      136,
      -915,
      {780,1018,209,63,-486,532,438,235,-336,-227,-154,59,765,-599,-506,106,659,-273,-972,145,-2450,242,-157,185,-902,966,-12,9,-335,-203,-449,5}
     },
     {
      138,
      -1210,
      {-2102,-664,659,1537,-1073,-2088,-1295,-176,-229,64,1623,-2148,478,-395,-158,-282,-831,335,1460,2799,-1345,-1260,-625,-1872,412,-863,274,166,-1953,-363,-1448,1841}
     },
     {
      140,
      -2319,
      {171,1203,-263,-59,280,294,1251,-239,1052,1133,131,100,1213,-1262,432,397,656,1058,-645,-374,-44,-444,-580,-353,-515,-1119,-741,-235,51,-619,-956,79}
     },
     {
      142,
      -2441,
      {1780,-689,-73,1073,-348,-262,-781,1036,-553,-190,-20,-589,-565,351,-500,1236,-276,-610,-815,-2304,-410,-120,-1060,776,-161,212,-565,1981,15,37,-83,-239}
     },
     {
      144,
      1027,
      {530,-1225,-277,93,65,-607,304,50,770,-1521,179,-81,379,-451,568,-167,-1743,28,-360,43,-515,124,81,-3,-659,1480,-63,4,-776,356,-1511,65}
     },
     {
      146,
      -193,
      {1932,-717,1348,-825,412,-223,267,-560,21,-222,1841,-1037,-1414,-1172,434,-118,-2453,-388,1133,-1390,-297,-316,-3408,356,-1560,256,-160,1055,-362,508,-1348,600}
     },
     {
      148,
      -2848,
      {-937,-340,0,-250,-112,3026,-887,476,727,288,-556,-1347,-2066,681,-569,-299,-1772,-781,-650,230,-549,1689,-1224,-1172,-247,-1089,104,213,-100,-734,796,49}
     },
     {
      150,
      -1180,
      {178,-222,1743,-1116,-295,-7,-789,1624,84,-350,-1744,186,504,-113,-1031,601,-653,178,-2187,1220,951,-237,551,-495,-134,-181,-840,728,306,75,-419,-163}
     },
     {
      152,
      55,
      {-1188,-1131,175,-59,-2092,956,1252,357,-208,370,-984,133,-180,-2001,107,-108,-945,943,-18,-6,-1806,-567,-190,-162,695,656,216,-39,-862,1804,380,-2492}
     },
     {
      154,
      -524,
      {697,10,-251,-794,248,226,434,-745,-127,93,257,-27,11,-74,-1815,592,128,99,-1212,-1,-555,14,-147,861,190,-68,-824,-1285,307,-621,559,1121}
     },
     {
      156,
      -1767,
      {-3737,631,-908,90,-1126,610,-31,-62,1526,-110,236,-181,106,-780,-154,-61,60,-806,62,-442,-260,-1316,-154,-92,821,-928,-163,-225,2330,-491,-308,133}
     },
     {
      158,
      -493,
      {-611,-899,-698,-2933,-714,-779,179,2298,305,-555,-1780,-416,141,138,295,451,-749,156,-817,-1261,209,127,-1609,-2458,-99,-130,92,1747,-391,-264,-147,-787}
     },
     {
      160,
      -1124,
      {-655,-1467,-26,-353,320,1183,378,-910,-17,-544,-1913,429,464,-375,-128,229,88,706,108,-425,-195,316,-1011,-1779,784,381,-162,-301,-3598,-23,442,97}
     },
     {
      162,
      -744,
      {-350,36,1067,715,950,-1,1,-172,-284,-54,-870,277,-266,0,-444,-924,760,-56,46,-756,-550,-211,271,168,530,-30,-53,-659,80,-39,41,1018}
     },
     {
      164,
      -2329,
      {-302,-1643,-315,-23,508,1066,181,137,-500,978,-143,-107,-804,-1639,115,-32,289,-617,-813,-253,1389,16,-1063,-70,929,1359,-86,139,123,183,-529,138}
     },
     {
      166,
      -1532,
      {-971,168,-2058,1176,337,-695,25,1670,-274,-248,1843,-474,-348,-107,-1524,-1363,184,137,688,-305,-711,200,-829,-1176,63,88,-652,936,105,-340,361,-346}
     },
     {
      168,
      -1052,
      {-805,995,23,187,-1409,-669,0,-94,172,194,255,226,-26,-1855,-188,-580,1321,92,347,-64,-658,-834,-91,-180,-1001,170,151,15,1218,424,325,180}
     },
     {
      170,
      -1306,
      {131,-88,-1758,-309,560,84,1667,-774,874,92,-485,-2946,365,-2231,1367,115,1455,-81,-134,-1118,483,9,-1628,775,-348,155,835,586,817,7,1110,993}
     },
     {
      172,
      -4066,
      {-694,-2417,779,-471,2225,-1025,-305,350,-1317,632,41,-2648,380,2145,334,177,-1011,-946,218,805,-1091,-192,552,277,1077,-572,-27,233,1035,-360,1224,-1268}
     },
     {
      174,
      749,
      {410,-257,-1558,-1760,-725,451,-2009,197,685,-1208,1012,-1233,-11,-623,1732,17,-472,324,-1733,968,61,170,1266,-2503,-137,498,512,-2172,-125,392,-921,985}
     },
     {
      176,
      -1748,
      {24,1105,-105,53,-819,-123,-1315,1182,1215,882,-374,-194,-4626,383,-54,-599,-1583,-408,395,-1024,2058,-1312,-1806,-179,1394,-2746,-800,-2032,1050,-360,691,-181}
     },
     {
      178,
      -2070,
      {108,-65,-579,975,242,-9,366,-857,-188,-127,-631,-218,118,-399,420,1368,77,-448,-59,-2404,495,343,1583,780,-71,-717,88,1478,-512,-139,798,-1071}
     },
     {
      180,
      -1738,
      {-5359,-1157,-836,-1076,395,428,-320,467,1666,970,-485,569,487,-237,767,270,-644,848,-233,-791,158,-762,58,-738,-2129,679,-634,-46,-1433,-4113,663,-543}
     },
     {
      182,
      920,
      {-845,-1521,-1193,2020,-184,247,795,-187,84,7,-1760,-1784,-321,-709,497,725,-893,-546,-476,1029,37,-383,-1184,-906,-93,60,-2461,-2860,-1400,-986,-358,2276}
     },
     {
      184,
      -5247,
      {3302,1271,0,1,-911,-1489,-430,31,-1156,1127,-130,449,2152,89,-907,-407,-1187,549,-688,-407,-488,618,-966,-2,329,1138,-498,-555,857,-74,670,-280}
     },
     {
      186,
      253,
      {-254,62,183,1283,403,-362,684,-472,117,328,-2578,1506,-1042,279,1072,-3517,-1524,-1088,808,-1823,341,-328,-1428,-3412,-989,250,563,1753,415,-233,596,-262}
     },
     {
      188,
      1385,
      {632,-2952,-206,-286,-215,780,-198,-113,3,-459,-524,-514,-996,4443,-340,-1995,624,366,-930,36,1792,146,-854,-660,-1739,-2673,85,396,-5494,-1199,-730,-65}
     },
     {
      190,
      1707,
      {-1032,175,-166,1042,-746,196,-1210,-4016,-647,-281,-990,-720,-818,-682,-1423,809,-1719,311,569,-1428,509,7,-862,-3439,-115,12,-1545,-6005,-777,-462,-1245,-969}
     },
     {
      192,
      -3714,
      {-196,1373,-590,-78,1406,1356,-928,-729,-3363,-824,401,-1288,-214,2255,-213,36,1592,1115,-620,-616,-354,2572,228,462,1796,-842,91,360,-974,-3690,497,-754}
     },
     {
      194,
      1772,
      {829,515,519,-1709,-371,-336,2449,-449,866,-762,-920,-183,-33,-528,-1348,1507,-1016,164,-601,-1062,928,-402,-4603,238,155,-203,-365,-4127,975,-900,-2523,-1399}
     },
     {
      196,
      -671,
      {-242,-1312,614,253,-460,-629,1426,-1400,1532,533,0,-309,62,1018,33,-82,913,-1667,-527,-269,-1477,-5669,-28,-453,1556,-3,513,14,-227,1521,145,271}
     },
     {
      198,
      -1388,
      {-131,471,639,-31,-419,-1099,998,-1369,-218,-272,840,-2033,-279,254,196,-579,-352,-321,721,-2295,-16,-389,898,1119,606,-550,-1403,1508,-315,-1729,-191,240}
     },
     {
      200,
      204,
      {-258,-5012,-432,476,-1770,-116,-910,-784,-656,1896,551,105,-3248,403,654,-1149,-2182,-1521,598,-56,-2721,-944,1127,907,-1300,602,-434,-415,191,-1397,1067,-394}
     },
     {
      202,
      -2850,
      {-32,-695,944,1313,-986,-179,707,-831,-626,-27,257,-1226,-445,-800,-1483,-271,572,-13,-1199,-1345,119,169,-580,2023,-589,-755,-1404,1596,268,136,2310,-1724}
     },
     {
      204,
      1371,
      {-1034,-11,1485,-388,-3923,-109,61,1183,-2492,-1460,27,-1463,-1085,-1429,-536,-301,-1140,-560,-191,530,-789,-9,178,-42,-1454,1611,570,-1545,-812,619,-624,-423}
     },
     {
      206,
      84,
      {-177,-1217,33,-1938,-302,224,-310,422,1333,-444,-162,-315,452,-243,1458,-2398,947,-717,-1418,-112,95,784,-2757,1383,85,-280,-1173,-1511,549,305,-623,634}
     },
     {
      208,
      -1586,
      {175,-37,646,75,-71,-321,-83,-51,637,-2612,-525,-33,-68,-321,-300,-822,-89,-302,-59,-290,-20,97,643,-240,2716,-1804,-651,-516,-1453,410,-273,-1780}
     },
     {
      210,
      -727,
      {-771,125,302,-1372,-851,-1133,2991,-2510,-718,-902,-2140,-2987,-470,-919,-1420,471,887,-528,-2362,151,201,-905,664,-330,445,-428,416,325,-29,784,-528,2105}
     },
     {
      212,
      -1290,
      {-287,-1854,340,-302,-2275,-206,-144,-1166,-2826,-92,279,-576,-830,-107,733,-1367,-1453,139,-597,-704,3675,-1020,855,-1470,-1924,-804,440,-483,-2054,937,5,-804}
     },
     {
      214,
      240,
      {-490,-652,-760,-552,702,-433,-1961,-618,384,-685,-660,636,220,-229,-1289,425,1293,-983,-1957,-2910,-501,-316,-675,-520,1004,115,1150,1797,-1185,108,-1421,82}
     },
     {
      216,
      -3426,
      {-145,-349,280,-93,475,-267,250,-1994,-272,422,-284,244,606,-1150,-478,173,393,-563,-669,285,-1118,-2125,832,-277,-1353,1462,-483,93,-28,2903,-1011,-980}
     },
     {
      218,
      847,
      {-846,-71,1104,-1392,190,-80,-1746,397,554,174,-3005,519,193,91,1314,-145,12,210,-598,-1473,-836,204,-1410,-947,-499,-799,534,-1466,-235,-212,401,967}
     },
     {
      220,
      -2700,
      {1397,-1707,-451,-1412,-666,-169,431,506,-386,-137,1678,-74,647,-2145,-300,165,-1493,1178,864,597,-767,-461,629,-1916,2818,310,864,-2197,-1836,-744,63,-143}
     },
     {
      222,
      -1612,
      {-597,38,-32,1831,36,-414,-1100,-931,1370,-360,-703,-2104,-713,69,-527,-459,465,511,401,-2525,818,-186,907,1344,1237,-1383,-1055,-224,233,-651,1186,-585}
     },
     {
      224,
      -3333,
      {-2757,-2991,290,-908,-697,1046,-21,33,-451,-1116,-550,580,-1654,-33,256,-1069,-1838,117,1100,-300,3367,568,755,-356,947,-1979,429,225,2029,-3438,-164,-353}
     },
     {
      226,
      -640,
      {147,1604,238,1535,-863,-489,1364,-2201,-1058,1175,543,798,-413,-936,-64,405,-234,68,670,-2960,316,-44,-239,-1210,-1151,-2086,-4454,-3280,-1125,1087,-814,-680}
     },
     {
      228,
      -2305,
      {-1329,1516,-1630,-974,1737,-977,269,366,-665,-156,-655,970,-290,-600,-102,-1914,642,95,-820,785,-3153,-1250,-587,-2188,525,138,-983,-79,1338,-759,475,-1858}
     },
     {
      230,
      -4650,
      {391,387,1445,-1179,113,332,-16,-2675,-116,116,-1362,-1859,-234,-576,975,-769,255,-1023,-1439,2934,-1166,-259,762,1678,324,546,2233,3403,-711,-1413,661,-1097}
     },
     {
      232,
      -467,
      {1766,-684,-1410,-282,-2564,-1135,651,-1469,112,-91,532,-2,-338,-179,45,-389,-133,-525,380,197,166,-2521,-122,167,1249,-575,1069,1236,-1527,1103,1359,-657}
     },
     {
      234,
      -723,
      {598,226,396,391,-182,174,-1586,-550,-210,-96,1118,-1041,424,-446,-436,-2860,-464,54,-436,-680,-35,-239,-766,65,-674,39,-2001,1802,279,0,1522,2278}
     },
     {
      236,
      -4451,
      {2429,320,81,246,-277,-1597,512,-714,376,1000,354,-616,-319,852,100,-91,213,5261,-458,300,127,762,676,-136,-1821,-3065,-1379,-250,1198,2501,270,-103}
     },
     {
      238,
      -3435,
      {692,368,-2688,-364,4,-1274,385,-2184,553,-120,34,-1407,-102,442,451,-47,746,-121,2336,3724,-636,-66,732,-737,-509,-81,2447,-1267,44,-316,433,-469}
     },
     {
      240,
      -2294,
      {-933,41,-211,-1458,2360,-1046,-637,463,-2854,-340,-861,166,-2286,-372,-228,-13,-958,856,-1085,-625,1383,112,340,380,802,145,-525,-63,-230,-3520,1537,-410}
     },
     {
      242,
      -3181,
      {-858,892,142,-2886,-1082,-181,2049,-1902,298,-175,-2939,-1246,-602,39,-1492,2528,1215,-1479,717,-2587,68,237,-2196,-558,33,-46,3285,1445,1470,55,1469,-1043}
     },
     {
      244,
      -1776,
      {96,-2381,-740,-864,192,-1927,-933,-499,-2335,-1728,-1971,-530,-4127,3000,1776,-663,125,-2007,1149,-77,834,-2444,200,-39,431,-5475,2098,608,84,1791,991,-463}
     },
     {
      246,
      -2597,
      {-155,-804,-1404,-376,-1195,-653,848,1434,160,-242,1347,-550,-1342,290,5,-513,541,-1287,1383,1089,34,-807,-285,-538,222,-584,1379,-2859,1054,600,-222,2603}
     },
     {
      248,
      -1773,
      {-1723,-2159,-287,-1767,2879,-2039,-559,470,-299,852,-420,-1668,-1683,-543,-877,-291,-837,-3327,688,-491,-2029,-3226,191,-162,2914,-2379,-115,-409,2839,1030,-1779,-687}
     },
     {
      250,
      -5204,
      {-1118,277,-860,-1357,-1589,-385,-2043,1143,650,83,491,1269,601,-1237,-1226,-1139,227,-601,2271,-195,109,171,1456,608,-762,-1,1971,-545,1081,-977,1603,2223}
     },
     {
      252,
      182,
      {1571,1857,-362,404,-3094,-746,336,-839,-1010,-553,-706,-850,-499,-2187,-511,163,-675,-1822,779,-277,233,1886,-621,128,1399,-4142,-646,-1167,-1220,-1478,-2400,67}
     },
     {
      254,
      1686,
      {-395,227,899,-716,-291,211,-1272,235,732,-477,-114,-161,-427,115,-1602,-532,-758,-710,-2003,-2058,-467,337,-76,-1040,-996,-312,-1498,-793,-625,-46,89,-403}
     },
     {
      256,
      1900,
      {-818,-491,-59,-387,-1845,-2017,653,130,-15,-2477,144,308,-22,-2854,1010,-222,-239,-1818,-337,-811,246,-2318,-1049,-1504,-3257,67,-1502,-1694,-217,-1181,-476,-24}
     },
     {
      258,
      -1524,
      {136,-1466,-65,1283,565,69,1016,-586,6,322,2596,-1066,883,304,391,1019,1503,-310,724,-1856,695,-1798,904,-1146,-1325,-1287,-2100,-1860,-697,-156,-603,-485}
     },
     {
      260,
      1620,
      {-1314,237,-762,-1022,-2030,1796,-126,280,-1497,-33,-590,-27,-171,1154,-508,-961,-2397,-54,-1230,-886,-597,-527,-382,-809,-1543,-1917,-1729,-798,-2168,-1271,672,-495}
     },
     {
      262,
      1303,
      {-115,793,1319,91,39,728,90,-2230,-938,-1053,-580,1382,-832,-683,1573,-994,-585,20,328,-1480,-828,283,-1039,-2408,502,186,-2617,2761,-212,516,644,1165}
     },
     {
      264,
      261,
      {3002,83,-209,-730,-990,-292,1190,-416,172,-1395,-509,942,509,-830,-768,1032,-142,-2158,-7,1218,-2270,382,872,857,-1933,-151,-614,855,568,-3099,3,-1398}
     },
     {
      266,
      373,
      {-479,1025,-355,-1086,-192,-130,-651,479,-453,695,-87,-955,-791,-1262,-2050,-1087,-1586,-878,109,-798,-784,266,267,-240,-148,-648,-1584,-411,1352,411,-695,-779}
     },
     {
      268,
      -2525,
      {-727,197,-491,330,-1801,1453,-428,-263,815,379,-375,872,-77,-570,-371,-1165,-197,479,56,-1336,-1495,476,-764,288,1338,54,-2144,274,1918,2046,-1025,-247}
     },
     {
      270,
      -748,
      {185,-1079,-773,-3642,266,674,-760,590,207,-1293,-917,248,-2099,170,316,168,-1056,1326,124,296,417,138,-3281,-71,32,-3,-1696,-1195,-372,92,1596,197}
     },
     {
      272,
      -2595,
      {1932,-186,185,321,-643,-1964,107,-888,1367,-2615,538,811,1244,206,-857,-402,-1800,-549,-1278,-678,-163,-976,594,275,-2024,2151,-2495,361,-1465,-530,294,82}
     },
     {
      274,
      -2113,
      {-309,436,1885,-860,-311,394,114,-1220,367,322,169,-1578,-229,295,-1625,-2812,-73,440,1518,-2165,-30,-133,-354,2321,-100,20,656,521,-99,159,1215,2071}
     },
     {
      276,
      -2953,
      {816,785,445,594,-742,183,-27,-234,-763,-561,261,286,-2079,1107,344,-79,1217,2270,-717,399,319,493,-324,-1259,-2378,998,-490,-1053,837,1784,-601,-589}
     },
     {
      278,
      -5193,
      {-98,794,24,-347,-723,273,-99,-1148,342,-187,358,-608,114,302,1235,827,-979,-69,2201,1073,-640,-737,2015,-367,-97,479,260,-1684,-1401,1169,441,-601}
     },
     {
      280,
      -2905,
      {-647,1276,-505,-2008,-695,1105,144,-772,-4892,1378,275,-83,-1122,1603,-694,-1441,348,430,-270,-1172,1375,585,182,-357,1767,1027,-1297,-524,1066,-786,809,-31}
     },
     {
      282,
      -2516,
      {-489,-278,-87,1539,-324,-628,1557,2739,250,-531,-822,2341,-1255,-1999,1692,-830,-545,-1759,1492,-1318,-1518,-28,-649,-1365,-7,-355,1572,1354,689,26,-1612,-1490}
     },
     {
      284,
      -1935,
      {-785,1907,188,258,-288,1247,-346,-534,-1138,-147,-1149,-731,-501,1370,-65,-414,-1087,-363,296,-2369,2051,509,232,-642,2986,-24,-1371,2345,-1666,-4910,-407,-1001}
     },
     {
      286,
      -2085,
      {783,-1498,2270,-800,35,-791,1059,-175,-518,-776,3399,-45,-306,-436,-1270,-469,-972,-585,-203,129,-1066,128,-209,-1837,640,499,1017,-326,-278,-164,-2788,-3052}
     },
     {
      288,
      623,
      {4,565,-661,476,807,135,-590,-41,505,-346,-74,320,-711,-1554,-144,587,-1676,-261,562,-202,-117,-372,-298,-181,1728,-1404,-863,182,719,-1920,-859,412}
     },
     {
      290,
      -1269,
      {-303,729,1388,-1132,-1409,1169,-590,-736,-1254,-911,144,1060,1178,173,-536,338,-113,-478,-321,1424,420,-796,2049,1290,-40,-1097,711,-1691,634,1664,-1334,927}
     },
     {
      292,
      -4223,
      {2113,1190,3,358,-269,-1525,-533,-395,1182,-1475,-625,1174,2157,-2698,-135,401,2423,2935,-1219,-1284,374,68,-279,-1083,-1282,-1292,-96,367,-900,1127,181,1619}
     },
     {
      294,
      -2276,
      {-993,-118,889,886,-287,391,62,891,-413,776,-79,-676,-101,-1528,1296,-452,-251,-1020,-1065,-600,622,-38,106,-2094,913,-1145,-1154,1172,582,-944,-389,980}
     },
     {
      296,
      -2296,
      {-283,2046,-120,-657,-1713,3674,63,-435,-1989,2192,-666,-883,1577,-1976,-601,-492,-512,-740,526,-163,-1311,-785,737,-1186,-601,1761,354,-259,-522,-993,282,-259}
     },
     {
      298,
      -1958,
      {-554,-500,2279,-1169,-1134,-264,-1144,-1526,-720,691,1569,-1463,-279,-704,-1400,-783,-684,-525,1306,-790,-355,-1025,-409,-1399,-316,-839,475,1543,-128,364,-658,1423}
     },
     {
      300,
      -1119,
      {263,447,-1098,394,-1608,3174,-56,-23,2447,-510,154,31,-2308,546,290,-261,-2866,-3560,214,-793,-2569,185,602,352,-679,1258,-829,114,-611,1714,607,140}
     },
     {
      302,
      -795,
      {491,-11,-549,-764,-1791,1367,1798,1570,412,-843,-351,202,-1289,762,1697,-2594,-542,-1556,-705,-1245,-1013,1291,361,-17,-363,-282,-1860,-1189,-619,-1179,-778,-480}
     },
     {
      304,
      -2521,
      {-949,-781,-2426,88,-2297,-579,-307,-308,-1036,1413,-68,-402,1768,963,-401,-989,865,745,886,345,-497,-1751,-1540,-168,952,-1834,470,645,440,-1386,229,-751}
     },
     {
      306,
      572,
      {-1629,-767,-910,-612,-949,-6,-833,1414,-1173,220,-1307,1090,-158,5,-555,-49,85,-1008,67,-583,223,1090,-1061,-1011,-915,-1177,-768,-1108,-948,-544,765,-1274}
     },
     {
      308,
      -968,
      {249,-142,-483,-339,120,-462,-215,-545,-687,-917,-146,-37,-437,-604,-962,-407,308,-200,-631,-525,200,980,-66,-597,-61,-569,403,-1098,525,-1115,-1104,-411}
     },
     {
      310,
      -370,
      {-7,-278,-7,-150,-128,0,-108,-116,-40,-86,-315,-184,-70,-281,32,-220,-166,-194,-203,-45,-390,-288,-128,-121,-264,100,-193,11,-168,-65,-319,-208}
     },
     {
      312,
      -1309,
      {-2908,1280,-1050,8,714,564,514,-102,750,1440,250,-427,154,-32,-615,463,-7,-1658,370,217,213,-1633,721,182,558,-1808,-673,-733,1791,-1210,286,-206}
     },
     {
      314,
      -570,
      {-1040,87,955,1376,752,-389,1980,2687,708,605,1068,-2349,-878,-706,-919,-3151,-746,-562,-1005,76,441,-603,-345,-2702,-201,-558,773,-1975,334,403,-555,-1741}
     },
     {
      316,
      -1010,
      {705,570,180,-863,1794,1610,114,-285,-4156,173,-20,-156,-35,-714,-872,212,1267,-1787,-21,84,-350,-1255,-405,-981,116,-575,-309,-85,-858,403,-1392,108}
     },
     {
      318,
      -2069,
      {143,-32,1964,836,382,25,-1356,-253,-236,-108,1510,-308,423,102,1315,-803,45,187,-1518,-484,323,-181,507,319,-625,150,908,-642,-126,-229,-1589,-558}
     },
     {
      320,
      -603,
      {2515,2380,460,930,-224,160,291,-1042,-2,-833,-685,-685,714,-2421,-23,603,-4112,-1019,-187,-269,-813,-853,-53,391,-1970,398,-41,-693,-482,-1438,-194,336}
     },
     {
      322,
      1835,
      {303,-627,-2333,-302,113,-128,508,-3018,225,-6,-678,-2668,110,37,-1882,-1292,-264,-283,-1840,-485,-155,-61,574,683,506,-1154,-737,-1171,-111,45,-662,-1209}
     },
     {
      324,
      30,
      {967,3055,-275,-808,-389,-2053,444,735,-666,-790,-315,1167,-991,-1625,-440,-1992,-545,-916,-597,1013,-210,-1689,373,-1254,-2111,37,-154,-758,862,398,-884,494}
     },
     {
      326,
      1715,
      {460,-325,-472,-48,987,-952,-1639,-2504,973,193,-1484,-676,-107,-17,75,-330,602,-229,-1008,-263,-650,-232,-1460,451,-75,771,-533,-1598,730,-635,-938,-200}
     },
     {
      328,
      -960,
      {-31,-2607,-193,-351,804,533,335,-834,231,884,-574,-1112,-1312,1289,1109,124,-221,-1688,-328,430,-545,-544,156,-44,-1270,2585,1543,-133,1335,-2317,1214,-1903}
     },
     {
      330,
      -99,
      {-88,-314,-199,-1891,1678,-458,127,-303,-1059,-1472,268,-1095,15,-304,263,-1058,582,932,-1037,-495,-437,327,562,-298,767,219,387,-1627,785,-273,-1991,1922}
     },
     {
      332,
      133,
      {305,-706,944,-651,-932,2395,-390,682,-518,-254,803,-203,-930,-580,299,-52,321,-39,-349,33,717,-488,559,-290,947,-2646,1271,-1282,-551,-1801,-460,52}
     },
     {
      334,
      -2994,
      {-178,-805,-1277,304,-260,13,1960,1452,722,274,-879,-154,224,-800,-1599,1939,301,220,195,1765,-72,-2653,-29,287,-465,1035,-2765,-2635,-482,-1193,1278,-3546}
     },
     {
      336,
      1001,
      {429,624,176,-732,-1451,654,-456,-52,-839,1042,-736,-350,33,-1849,862,-496,-574,-648,-311,-208,-1666,-800,-735,1436,-1513,-914,-1145,-2018,1603,129,-1305,-1109}
     },
     {
      338,
      -477,
      {350,-639,-1196,-250,-422,-133,-155,893,-564,293,36,-2078,-352,-422,947,-2140,-451,-50,-257,-248,-291,-909,-1297,-304,-421,-1304,1337,-1069,479,-341,1474,-1738}
     },
     {
      340,
      2335,
      {-735,-64,319,-114,-1462,58,-144,-444,-2262,-895,-744,-952,-1230,-903,75,450,-1809,106,-7,-126,-2066,261,-1146,-1113,-1509,1111,371,108,-272,-2129,373,-459}
     },
     {
      342,
      2585,
      {715,114,-982,46,-3,-1408,-2447,-881,-732,-571,-1088,-519,498,-214,-43,402,-134,-10,-2359,-1240,-287,-469,-1791,0,-358,-1590,-1914,939,413,895,-372,-2147}
     },
     {
      344,
      1911,
      {-14,-68,-513,-409,-2542,233,-549,-234,-316,-1581,-34,-408,-1338,459,-396,-799,-1603,-1095,-961,-1,-1110,-946,-366,-217,-125,-1164,-720,-594,1401,-2403,-813,-1019}
     },
     {
      346,
      1260,
      {-1010,-259,-916,-591,-577,-504,-389,-1463,112,-299,-1252,224,-634,726,-375,-195,-455,-620,-1015,-1396,-772,1021,-2426,-1399,-647,-510,632,-284,533,-388,-54,-1789}
     },
     {
      348,
      -1498,
      {-2114,-1934,913,-644,263,-166,-109,-113,-658,308,-190,-201,2287,748,-617,287,-327,1169,389,-676,20,-963,-158,-743,2692,-2252,-806,-694,2995,-3604,487,625}
     },
     {
      350,
      1859,
      {13,-2013,-42,-899,-212,-437,426,-1121,-1019,1281,-127,1008,146,-1003,-1121,220,-1293,-1727,-2085,1457,-204,2445,1437,-8,-84,-678,2303,-2471,979,-1847,-1176,-3226}
     },
     {
      352,
      -146,
      {-286,812,729,-783,1038,-943,868,-1100,-505,-1538,100,-1650,215,381,245,-1216,906,-1182,-298,278,-850,-1134,516,-438,-219,-553,-1,134,-2228,-1378,431,-661}
     },
     {
      354,
      -1053,
      {1107,-39,-1369,-1311,167,-1250,-2662,304,-385,537,-1388,-512,-76,-830,-575,-714,766,-78,470,-421,787,-1081,-702,-1569,-83,189,1151,-849,883,-1684,3112,-49}
     },
     {
      356,
      537,
      {-124,-12,701,-974,605,-1859,33,124,-1498,-2286,276,478,-674,-1722,-25,77,-533,-1769,393,-1091,634,1760,39,-559,1152,-1627,579,-1544,953,-2650,611,-2018}
     },
     {
      358,
      -895,
      {86,-966,-22,-1711,-676,-1163,-1455,-2252,-270,-91,84,-547,-274,-422,-1169,-573,-451,-239,155,292,-599,519,-160,-1139,-1257,-165,1617,-294,-263,-1433,2431,2332}
     }
   }

 };
#endif /* MLP_PRELOAD_MODE */  

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\prep.cpp ===
/* *************************************************************************** */
/* *     Get bitmap given trace and XrData Range                             * */
/* *************************************************************************** */

#include "ams_mg.h"
#include "hwr_sys.h"

#include "xr_names.h"
#include "bitmapco.h"
#include "precutil.h"

#if PG_DEBUG
//#include <stdio.h>
#include "pg_debug.h"
#endif

// ---------------------- Defines ----------------------------------------------

#define PREP_DESLOPE 1

#define GBM_ONESHIFT           10
#define GBM_ONESIZE    (1 << GBM_ONESHIFT)

#define ABS(x) (((x) < 0) ? (-(x)) : (x))

// --------------------- Types -------------------------------------------------

// -------------------- Proto --------------------------------------------------

_INT  GetTraceSlopeAndBox(p_rc_type rc);
_INT  DeslopeTrajectory(p_rc_type rc);
                                                                                  /* ************************************************************************* */
/* *************************************************************************** */
/* *     Deslope trajectory                                                  * */
/* *************************************************************************** */
_INT PreprocessTrajectory(p_rc_type rc)
 {

  DeslopeTrajectory(rc);

  return 0;
 }
/* *************************************************************************** */
/* *     Deslope trajectory                                                  * */
/* *************************************************************************** */
_INT DeslopeTrajectory(p_rc_type rc)
 {
  _INT i;
  _INT base_line, slope, slant;
  _INT   y, dy;
  _INT   dslant,slant_sh;
  _TRACE trace = rc->trace;
  p_ws_word_info_type wswi = (p_ws_word_info_type)rc->p_ws_wi;

  slope = slant = GetTraceSlopeAndBox(rc);

  if (wswi && wswi->slant) slant = (slope+wswi->slant)/2; // Take share from segmentation slope

#if PG_DEBUG
  if (wswi) printw("\nSlants: GetTraceSlopeAndBox: %d, WSWI: %d, resulting: %d ", slope, wswi->slant, slant);
   else  printw("\nSlants: GetTraceSlopeAndBox: %d, resulting: %d ", slope, slant);
#endif

  dslant    = (slant << GBM_ONESHIFT)/100;
  base_line = rc->trace_rect.bottom;
  slant_sh  = dslant*(rc->trace_rect.bottom - rc->trace_rect.top);
  if (slant_sh < 0) slant_sh = -slant_sh;

#if PREP_DESLOPE
  for (i = 0; i < rc->ii; i ++)
   {
    if ((y = trace[i].y) < 0) continue;

    dy = base_line - y;

    trace[i].x += (_SHORT)((slant_sh - dslant*dy) >> GBM_ONESHIFT);
   }

  rc->slope = (_SHORT)0; // From now on there is no slope!
#else
  rc->slope = (_SHORT)slope;
#endif

  return 0;
 }

/* *************************************************************************** */
/* *    Get right extrema presize X                                        * */
/* ************************************************************************* */
_INT  GetTraceSlopeAndBox(p_rc_type rc)
 {
  _INT   i, j;
  _INT   x, y;
  _INT   dx, dy;
  _INT   adx, ady;
  _LONG  dx_sum, dy_sum;
  _INT   slope;
  _INT   num_points = rc->ii;
  _TRACE trace = rc->trace;
  p_RECT rect = &rc->trace_rect;


  if (num_points < 10) goto err;

  rect->top = rect->left = 32767;
  rect->bottom = rect->right = 0;

  dx_sum       = 0;
  dy_sum       = 300;  // Stabilize to vert on small traces
  for (i = 0, j = 0; i < num_points; i ++)
   {
    x = trace[i].x;
    y = trace[i].y;

    if (y < 0) {j = i+1; continue;}

    if (x > rect->right)  rect->right  = (_SHORT)x;
    if (x < rect->left)   rect->left   = (_SHORT)x;
    if (y > rect->bottom) rect->bottom = (_SHORT)y;
    if (x < rect->top)    rect->top    = (_SHORT)y;

    dx  = (x - trace[j].x);
    adx = HWRAbs(dx);
    dy  = -(y - trace[j].y);
    ady = HWRAbs(dy);

    if (ady+adx > 10) // if too close, skip
     {
      j = i;

      if (dy != 0 && (100*adx)/ady <= 200) // if too horizontal -- skip
       {
        if (dy < 0)  // going  down the trace, notice more
         {
          dy = -(dy*8);
          dx = -(dx*8);
         }

        dx_sum += dx;
        dy_sum += dy;
       }
     }
   }

  slope = (100*dx_sum)/dy_sum;

  if (slope < -100) slope = -100;
  if (slope >  100) slope =  100;

  if (rect->right-rect->left < (rect->bottom-rect->top)*2) slope = 0; // Do not deslope short words/single symbols
//  if (num_points < 100) slope /= 4; // To few points
  if (num_points < 100) slope /= 2; // To few points

  return slope;
err:
  return 0;
 }

/* *************************************************************************** */
/* *            End Of Alll                                                  * */
/* *************************************************************************** */
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\snnimgef.cpp ===
// **************************************************************************
// *   NNET file as Cpp file                                                *
// **************************************************************************

#include "snn.h"  

#if MLP_PRELOAD_MODE  

#include "mlp.h"  

#if MLP_CELL_MAXINPUTS != 32 || MLP_NET_NUMSIGNALS != 904 
 #error Wrong NET configuration!
#endif

// ****   NET body   ********************************************************

ROM_DATA mlp_net_type img_snet_body = 
 {
   {"j"},
   4,
   288,
   92,
   {2057,2073,2089,2105,2121,2137,2153,2169,2185,2201,2217,2233,2248,2264,2280,2296,2312,2327,2343,2359,2374
    ,2390,2405,2421,2436,2452,2467,2482,2498,2513,2528,2543,2558,2573,2588,2603,2618,2632,2647,2662,2676
    ,2691,2705,2719,2734,2748,2762,2776,2790,2804,2817,2831,2845,2858,2872,2885,2898,2912,2925,2938,2951
    ,2963,2976,2989,3001,3014,3026,3039,3051,3063,3075,3087,3099,3110,3122,3134,3145,3156,3168,3179,3190
    ,3201,3212,3223,3233,3244,3254,3265,3275,3285,3295,3305,3315,3325,3335,3344,3354,3363,3373,3382,3391
    ,3400,3409,3418,3427,3436,3444,3453,3461,3469,3478,3486,3494,3502,3510,3518,3525,3533,3540,3548,3555
    ,3563,3570,3577,3584,3591,3598,3605,3611,3618,3624,3631,3637,3644,3650,3656,3662,3668,3674,3680,3686
    ,3691,3697,3703,3708,3714,3719,3724,3730,3735,3740,3745,3750,3755,3760,3764,3769,3774,3778,3783,3787
    ,3792,3796,3801,3805,3809,3813,3817,3821,3825,3829,3833,3837,3841,3844,3848,3852,3855,3859,3862,3865
    ,3869,3872,3875,3879,3882,3885,3888,3891,3894,3897,3900,3903,3906,3909,3911,3914,3917,3919,3922,3925
    ,3927,3930,3932,3935,3937,3939,3942,3944,3946,3948,3951,3953,3955,3957,3959,3961,3963,3965,3967,3969
    ,3971,3973,3975,3977,3978,3980,3982,3984,3985,3987,3989,3990,3992,3993,3995,3996,3998,3999,4001,4002
    ,4004,4005,4006,4008,4009,4010,4012,4013,4014,4015,4017,4018,4019,4020,4021,4023,4024,4025,4026,4027
    ,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4038,4039,4040,4041,4042,4043,4043,4044,4045
    ,4046,4047,4047,4048,4049,4050,4050,4051,4052,4052,4053,4054,4054,4055,4055,4056,4057,4057,4058,4058
    ,4059,4060,4060,4061,4061,4062,4062,4063,4063,4064,4064,4065,4065,4066,4066,4067,4067,4067,4068,4068
    ,4069,4069,4070,4070,4070,4071,4071,4072,4072,4072,4073,4073,4073,4074,4074,4074,4075,4075,4075,4076
    ,4076,4076,4077,4077,4077,4077,4078,4078,4078,4078,4079,4079,4079,4079,4080,4080,4080,4080,4081,4081
    ,4081,4081,4082,4082,4082,4082,4082,4083,4083,4083,4083,4083,4084,4084,4084,4084,4084,4084,4085,4085
    ,4085,4085,4085,4085,4086,4086,4086,4086,4086,4086,4087,4087,4087,4087,4087,4087,4087,4087,4088,4088
    ,4088,4088,4088,4088,4088,4088,4088,4089,4089,4089,4089,4089,4089,4089,4089,4089,4090,4090,4090,4090
    ,4090,4090,4090,4090,4090,4090,4090,4090,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091
    ,4091,4091,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092
    ,4092,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093
    ,4093,4093,4093,4093,4093,4093,4093,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094
    ,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094   },

   {
// *********** Cells of layer 1 *********************************************

     {
      616,
      1703,
      {3013,667,821,-1516,-1067,-1178,-807,154,6119,251,1005,-349,-1188,1364,-358,-6079,1594,-2195,-2620,1740,-73,670,1619,-182,-740,-568,-1214,-1997,-450,102,-817,3175}
     },
     {
      616,
      -60,
      {830,1331,1341,-880,-838,-67,-349,804,1197,117,1979,-1123,-2362,-156,4420,750,1808,-3230,7204,-560,-2719,27,-301,-7426,927,-153,1090,-2255,-681,-4164,1515,5231}
     },
     {
      616,
      916,
      {80,366,-747,1280,-1710,-2052,-3871,-1236,-905,5070,1235,-1191,-1225,-843,-3,-540,-486,-883,-450,-1872,347,1198,1804,-3083,1365,-944,1010,2168,2167,535,-1934,6302}
     },
     {
      616,
      310,
      {-378,1,489,1605,1202,-1586,-3436,-1670,-470,1146,-1380,4076,-1775,-1901,2198,-2982,380,-2667,-1900,1679,-1262,-1837,-231,-497,486,403,1006,2638,135,504,-359,-3786}
     },
     {
      616,
      -2631,
      {-2971,423,1107,-462,-2014,-345,-417,770,3402,-161,-4254,1585,4330,1349,-2957,1980,2827,-413,-2121,-189,-2604,-1820,-756,1604,-2691,1315,938,714,-1266,2228,1333,3444}
     },
     {
      616,
      1285,
      {-472,646,739,-1617,425,-73,701,494,-932,464,1353,-5035,-4495,-216,2961,725,763,3172,852,-1416,-1038,-372,-801,-945,-1973,303,926,1113,2957,541,-4720,-4315}
     },
     {
      616,
      -1230,
      {529,-48,-2002,-114,-2788,-1652,389,1133,4468,843,-521,-3246,-1247,-1224,-1442,2022,-852,1328,-1888,-426,-2143,-792,1256,3732,2291,-420,-274,612,238,1742,-249,-4400}
     },
     {
      616,
      1968,
      {-284,104,-1799,-50,1085,-1253,-120,-3060,3152,-3107,-484,2561,-1201,-832,-3537,-1460,229,-1028,2659,685,2007,-370,16,-1153,554,-445,649,-1223,1709,-1758,198,-2431}
     },
     {
      616,
      -919,
      {-320,953,-2255,2885,-678,-4005,-3933,441,3148,1136,2069,-5129,400,-2421,1782,-839,943,-199,2180,2743,18,727,-2346,-1950,2063,-222,993,866,-1210,-3289,911,-1465}
     },
     {
      616,
      307,
      {520,-475,-805,437,5208,-4053,-639,-1295,557,2016,-565,-3755,2858,941,-1135,-2117,-1701,944,-996,3609,-882,1272,-1503,-108,1720,133,-1985,-1292,485,1287,-1514,-173}
     },
     {
      616,
      -1843,
      {-618,441,755,461,-737,565,-327,281,1923,343,-140,168,-1668,-162,2807,7863,1507,-511,-7828,-2729,-900,3261,-633,435,-185,-775,-468,1479,-849,-283,-2080,-1604}
     },
     {
      616,
      -660,
      {324,919,-1434,-1353,2398,-3495,3960,-1311,1780,-2008,-1017,-231,-693,596,860,4126,-2427,-2320,2287,-1390,225,1451,79,238,-2735,1264,-1151,245,656,-897,-1000,1289}
     },
     {
      616,
      -1197,
      {384,18,2271,597,-802,-3719,-2659,-809,2283,4489,338,932,-4356,-2265,-3776,3557,-1310,1767,2533,1610,-850,-1016,-1282,-1185,-654,-724,-1436,1358,-517,59,1574,-7935}
     },
     {
      616,
      2487,
      {457,331,4071,-1315,-3111,-2576,45,1503,-3253,-1215,3867,-3010,-2943,923,793,-4189,492,85,-3048,-251,2264,-3919,553,1260,-405,2329,2724,-2254,1364,1099,-1146,-1785}
     },
     {
      616,
      -343,
      {-981,-1374,3353,515,4307,-3032,-972,-2574,1115,-968,-1687,-2094,-1548,-580,2870,1723,-1769,-2040,-1034,-458,1324,-2436,-1171,1461,146,-73,359,1003,-368,1827,-99,113}
     },
     {
      616,
      28,
      {183,-565,5126,-238,-1386,1944,-3362,-633,675,-1402,-181,2690,-2097,-937,-2864,-1149,1105,-134,-1434,635,1047,-2115,1057,812,1798,-198,1974,855,-1333,-1749,-69,99}
     },
     {
      616,
      -587,
      {-1042,349,3328,1266,-710,-1228,-1294,-1928,-1390,-2015,-1201,-3419,-753,-2878,-5202,1772,-1047,-4848,6050,-1566,-1350,5576,1665,-1287,2934,-1123,1635,2597,511,2077,806,-763}
     },
     {
      616,
      -1596,
      {-415,-404,1172,3417,-257,-1666,-1543,-297,928,1440,141,-1401,3452,1755,1999,4200,-2146,1485,2878,-1068,363,-6897,767,-1905,-920,-1870,224,-882,-1902,-333,37,2216}
     },
     {
      616,
      -286,
      {-637,-781,2174,188,1275,-4919,1014,622,2660,-1114,188,1624,887,-1464,-946,-860,-445,-1238,2582,-441,993,-289,-385,1359,-283,1746,617,-2619,-868,591,-1984,1132}
     },
     {
      616,
      -201,
      {1714,1076,-151,-1987,-1193,-3680,248,-2684,-3874,4530,-185,-1918,5512,-1601,653,4412,-1085,588,-1286,1620,-1410,-478,-614,-765,3650,-264,-3217,-1265,1082,-1890,1668,-422}
     },
     {
      616,
      -1052,
      {-2,446,1646,1892,701,792,-2504,1696,948,4266,-1875,-4489,-3038,-1204,1058,-2366,1341,-60,1760,240,1235,1129,-225,-2045,-300,-707,-486,175,-393,763,-1963,-1495}
     },
     {
      616,
      -2349,
      {-670,283,1799,1843,-96,-1079,-66,1630,-1163,84,-518,1945,-1185,-1445,1366,7976,965,-6243,-1322,3654,-1081,-3608,-2186,588,197,-581,-190,-2618,-1776,2282,2014,7059}
     },
     {
      616,
      -3225,
      {-1169,240,-134,938,2257,-1753,-2460,-2033,606,-3702,-2951,1774,-3120,915,4956,1660,-1229,2691,5126,-691,-709,1361,-3128,944,396,-2263,-879,2355,-732,-1048,3168,-4423}
     },
     {
      616,
      -5212,
      {4898,66,3414,1019,-1698,2522,1633,-710,376,287,-1983,2715,1974,1438,2221,4360,-2621,-2570,1962,1624,-1915,3110,-2609,-1700,-347,-5009,323,-179,-295,202,96,-2573}
     },
     {
      616,
      -136,
      {-1913,-802,-3348,2550,517,-3495,1755,2294,1651,-3976,232,-2418,-1756,1919,-442,3444,-2518,1111,-1792,-1756,-2221,1429,979,2924,169,588,-1465,-1376,-176,115,2597,-2732}
     },
     {
      616,
      2895,
      {1236,1506,-311,412,2139,-5472,-2939,-1792,-773,-4506,2818,-2017,-3442,-1834,-54,3200,1129,-2309,-3021,942,818,3467,-875,-1417,-225,400,-581,1980,2620,-3899,2547,4425}
     },
     {
      616,
      -398,
      {-2117,-653,-1022,1720,2682,-2111,-1216,-1067,5026,1818,190,-1902,-4448,998,1136,-1069,-2545,2255,1098,1218,370,365,173,93,-2649,-1159,-1262,-531,-768,1578,-628,-1120}
     },
     {
      616,
      -931,
      {-298,1139,2735,288,27,-2509,656,2323,1470,5463,-436,-606,-6230,-1488,41,2098,443,653,1058,-1627,-204,-632,-1003,-1017,-1972,1229,-1631,3218,603,-1938,-2655,-1744}
     },
     {
      616,
      -1222,
      {-2192,85,602,3343,-261,-1723,-790,1112,2279,-780,-4087,-2145,5285,1093,1130,-3151,1350,490,-448,1200,-157,1651,-588,728,311,-1943,-520,-220,-804,1205,-58,6555}
     },
     {
      616,
      1519,
      {-4995,5053,-1121,1268,4760,-1520,-1845,2938,-2390,-2278,-3121,-6566,1119,-970,1070,-224,-215,-1220,-1750,840,-1007,-2897,1053,981,-542,393,1836,-2366,898,1549,-1186,-1910}
     },
     {
      616,
      566,
      {1108,25,-1213,-705,-1333,-607,-1213,0,2295,731,1866,2104,2106,-26,-3606,-777,139,-4774,4073,181,233,-2424,2449,-3546,-1506,1833,495,1869,-731,1170,-2946,1335}
     },
     {
      616,
      825,
      {-604,678,-3442,1161,1021,1516,-866,-1693,4748,-1728,2835,-3630,-2621,-2273,1756,5843,3106,1573,-1569,-513,-1912,1266,-567,-766,-2089,-3812,89,-1240,-2910,-2657,3343,-2482}
     },
     {
      616,
      1302,
      {770,536,247,-2780,-1177,-244,-4057,-1496,-3045,-929,1846,-1848,2456,-219,3852,1823,1141,-1499,-2101,-3148,-526,1658,1027,-790,-496,779,-132,-600,1304,1372,-263,232}
     },
     {
      616,
      2386,
      {1673,319,1088,-3601,810,-1102,-3817,-2794,3066,-2975,2067,761,3748,-2391,-6175,-965,1672,-2558,-3875,-1290,4374,-1266,1413,-2727,2101,1471,3877,-2941,259,-726,2591,863}
     },
     {
      616,
      1723,
      {6024,-232,-1964,-337,904,1321,932,-221,-2154,-1786,267,-448,-1647,1976,2787,-4614,-1906,-2286,3554,2090,-3125,-5688,2976,-2027,846,783,-2235,973,1145,-162,2791,459}
     },
     {
      616,
      -480,
      {1185,637,3275,-2272,1570,815,2406,-917,-1607,-2297,-190,-1075,-1687,-1876,199,-1326,1065,-1994,-1407,3142,-540,2316,373,728,1841,-214,-1335,2254,-2929,-921,1218,1695}
     },
     {
      616,
      -2273,
      {-4105,214,-348,2438,27,1715,-237,-1238,-1970,827,-2985,-3181,-648,2220,-672,4513,-1197,1012,3587,398,225,-1135,-1964,-808,-583,-1258,789,284,-148,619,3058,-4457}
     },
     {
      616,
      2810,
      {3270,1023,-976,-937,2035,2275,-2313,-3746,-2812,-2534,331,-1083,-3023,-1481,-2713,-2905,2590,-2621,-624,212,-2053,3744,1574,-534,999,799,-847,1132,1626,-479,378,308}
     },
     {
      616,
      229,
      {-1255,-73,-255,-1355,1757,4792,-753,1496,880,-1390,808,-936,1126,1775,-742,-1496,157,-2379,293,520,-52,-590,-176,1,-2720,-135,1318,1098,-1512,47,-1998,580}
     },
     {
      616,
      -463,
      {1241,137,365,381,1055,-3450,-606,-16,3999,2375,-662,-3661,-1247,-11,3569,-1619,-1991,-5155,1334,-220,1847,1083,101,-231,1770,-1224,-1172,1464,664,-1759,1290,3142}
     },
     {
      616,
      301,
      {2142,-799,-2178,-463,-1892,1329,400,-2405,723,-1258,1768,-3322,-1353,1749,-1332,3869,2175,-773,4144,-889,-1261,748,1393,-2878,-2772,40,2755,-148,-834,-1053,-323,125}
     },
     {
      616,
      -388,
      {653,247,3516,-1188,1576,-324,-1528,-1057,-1906,1119,622,-4046,-1155,715,4403,-5906,-1600,832,-88,1148,1408,3819,-1816,-601,-1654,672,443,529,1786,-1605,-2150,-55}
     },
     {
      616,
      -731,
      {133,1144,412,-276,-1820,1200,-531,-251,1848,1141,635,-1711,-2598,2912,2704,1493,-366,4993,104,-2598,-2198,-129,-130,-1887,-2378,-939,3263,-142,-845,-1847,-1376,3297}
     },
     {
      616,
      -1706,
      {-229,1441,-3517,1119,613,1381,-76,-4350,639,-2228,-1282,-4644,3289,2879,-1412,-549,-599,2311,1833,-891,2719,2297,-938,1689,1626,-2908,2056,1114,-1153,-2705,371,13}
     },
     {
      616,
      1053,
      {2249,441,928,-13,1624,356,265,-724,2227,-224,1982,1811,-1656,813,1764,-5755,-1054,-2139,-5368,1244,1124,-3066,34,-1081,-1444,3225,647,-1035,-565,79,1382,-157}
     },
     {
      616,
      880,
      {-1234,14814,-4002,-890,539,-189,626,330,-1177,-1129,171,-617,1490,1698,744,-1118,735,1392,-674,-1087,-3758,-5120,282,-3805,-1623,1432,-2413,353,-142,-3692,-311,-75}
     },
     {
      616,
      -2278,
      {236,338,342,165,458,-820,-549,300,1661,-2724,-1749,-1359,4917,651,-1317,-7176,-1663,1919,3158,2563,-64,-637,-1636,1653,1636,2419,-204,-953,283,832,1409,-2156}
     },
     {
      616,
      -955,
      {1568,333,-542,1900,-1751,-601,-3877,1500,2025,-879,439,-7304,1631,-1985,2597,3585,-1007,1128,3175,-1077,-1861,1092,388,-2239,3644,-699,1087,-1157,-1270,1817,-37,1775}
     },
     {
      616,
      3157,
      {-1939,-511,1268,-433,3144,75,1496,-1421,-2149,1049,-1833,-4552,1674,1689,-5396,-1303,1965,-4134,-3042,1860,-757,-2445,1865,-1347,-246,612,1702,-3045,2195,1603,1225,-214}
     },
     {
      616,
      2252,
      {1290,435,1682,-1930,3976,373,-2713,436,693,-2462,-2080,-3994,-209,1091,-2888,-277,580,-5981,-7856,1010,7027,-3112,1962,3878,696,70,-1365,1300,1701,-1976,-817,4013}
     },
     {
      616,
      101,
      {10,442,-630,-2085,1614,1308,-5020,96,444,3064,-1216,-924,1066,1406,-4277,-268,-643,1355,-1664,2099,-1131,1292,586,-1293,1340,943,-1263,-447,-277,407,-599,947}
     },
     {
      616,
      -3028,
      {641,123,-2014,-1265,-3304,-1523,11,-2900,-1235,3685,254,-40,5844,707,232,3514,774,-771,138,1691,-127,1993,-2128,-923,674,-741,1087,1456,-2840,1666,-263,-3164}
     },
     {
      616,
      496,
      {-1716,1899,-1142,-1828,469,-1422,671,455,-1207,-2068,443,-2100,565,4687,306,-7432,20,-5162,7223,-405,476,-1946,-149,-23,3310,-776,-2681,807,-630,1692,968,1044}
     },
     {
      616,
      1180,
      {657,-539,2497,-815,1087,1953,-2700,-3162,1532,-1574,192,1145,5752,-2238,-1348,-4919,-701,2434,3109,478,-1762,235,-985,-777,-2539,-1180,-470,626,1301,1450,-926,871}
     },
     {
      616,
      411,
      {-610,1902,-4266,-949,-2114,-280,-837,-3237,2109,-887,2087,-2192,1004,255,3596,657,108,-4762,2675,-997,-680,-1041,915,-1620,388,-619,2752,2184,-585,1139,-1282,-630}
     },
     {
      616,
      538,
      {334,-256,-1674,-770,-2691,2883,-2142,-1833,2711,5272,2925,-4893,137,-1287,-2267,-3554,1107,3204,-2213,-960,-446,79,-1660,1155,202,3671,-594,-184,960,-2726,845,-2123}
     },
     {
      616,
      -524,
      {-347,475,1181,1016,411,-1517,1371,-1348,3017,-1878,-1120,-4341,3698,-1754,4561,-1618,376,-1580,-1545,296,3222,5285,-1210,-1315,-3485,-734,-2153,1847,-315,-1940,-1444,-2118}
     },
     {
      616,
      2049,
      {-541,214,1070,-2296,-1206,-2158,-3597,747,94,1474,2789,-532,-1152,-1411,932,-1157,2895,-588,-541,-58,2007,-1795,1919,-292,1653,-48,967,-295,-889,-2092,-3127,4114}
     },
     {
      616,
      -3899,
      {345,3843,114,610,171,785,1215,-1831,736,412,-2588,-3177,3983,2162,-1489,432,-3489,2056,1605,400,-1790,-2204,-3393,252,5958,2088,-1605,-761,-1344,417,2457,-1713}
     },
     {
      616,
      -398,
      {2879,-760,3109,-1243,2463,2481,-1221,-5217,1210,6079,-3886,-1242,2431,441,150,149,-257,-4665,-1268,1376,-407,-12,-173,-2841,2849,-1248,264,-2144,-62,-89,-843,722}
     },
     {
      616,
      375,
      {2506,-12646,3213,157,-1288,303,1434,834,2642,329,-1036,115,258,-561,453,-1324,1185,-1595,-1818,-253,2,-1921,1518,-680,-889,362,-89,242,-23,511,-1596,2116}
     },
     {
      616,
      972,
      {-1048,705,-297,712,-491,-1289,-709,-570,304,-2487,359,-6837,2181,923,-2201,2048,551,3223,-3463,1268,164,1898,2767,-937,-2589,926,2554,-1839,-222,-2981,273,-448}
     },
     {
      616,
      37,
      {1033,934,-1282,1397,-401,-1470,1251,-2121,1752,2134,-678,-461,-3146,884,-2663,-1475,-679,3224,861,-712,-2936,-149,-718,108,-760,2202,-529,631,682,-46,1318,-3132}
     },
     {
      616,
      -146,
      {1267,1683,996,3245,-853,2163,-1433,1037,-2895,723,-1657,2574,-332,-555,-2035,-1290,-92,1492,1175,-2231,-1781,-66,1213,-648,305,-99,641,-466,1003,-718,-3282,-1013}
     },
     {
      616,
      -4373,
      {907,573,4167,2153,-1650,-2989,783,1955,1891,-896,-2161,2760,-2760,938,1232,286,-2398,4261,1530,-532,3538,1453,-897,-203,-2070,-2256,1029,716,-685,-1758,-727,512}
     },
     {
      616,
      315,
      {19,795,-4514,1423,-1447,-319,4177,375,-2095,-336,52,332,-6417,1794,1919,4982,3533,1831,-1084,691,-548,-1924,904,-1555,-1765,703,-879,-861,-1239,-698,-888,-126}
     },
     {
      616,
      1076,
      {-4757,1133,-167,3370,-1871,-2073,-1635,-2897,-1290,-927,5994,-833,-113,1640,-3803,3075,-912,-2268,-4522,368,1520,-4467,1047,1414,511,1023,1660,-2146,-5,1187,174,-1287}
     },
     {
      616,
      -936,
      {1463,2067,2412,1132,-1328,2149,1694,-2792,938,2014,1536,2850,959,-327,-3065,1872,-1113,1218,-4113,-2400,-2352,-3989,-1277,263,-1997,3303,152,-1707,-87,179,-408,562}
     },
     {
      616,
      1454,
      {2394,-366,-1831,-625,1718,-1401,-434,-1800,-1535,-1918,-2456,1993,956,-3758,-6148,12,2698,-1751,3548,786,8188,-1324,-384,2259,-672,217,-2085,-297,427,-1209,1431,6880}
     },
     {
      616,
      -2220,
      {1221,-841,762,2089,-2003,578,320,387,-709,1169,188,-1444,-377,1500,7050,-132,-2537,-3561,-1759,-2910,-1831,6155,-2486,1799,94,-582,-259,3668,-914,-531,-379,-674}
     },
     {
      616,
      -667,
      {3513,2434,-1236,403,-1008,-502,3147,206,-474,23,-242,-1951,4001,-2964,-1908,4376,-19,211,-1260,1287,1185,1208,-1733,-3266,-493,-97,-345,-922,1828,-4161,-223,964}
     },
     {
      616,
      -705,
      {358,-2530,411,783,1502,-2190,-2052,-4342,705,406,-2080,2986,-1354,-57,649,250,-824,1463,821,1162,-385,2820,517,63,4287,-797,-1567,1766,-163,-2244,-1358,-301}
     },
     {
      616,
      -14,
      {154,-18,1097,-1276,-2225,-519,973,-1295,-309,-935,3143,-2495,587,1529,-1999,-4940,-1277,1931,-5222,-893,2758,2954,588,811,-175,1959,2052,-2007,-481,964,2850,2802}
     },
     {
      616,
      -3462,
      {-182,553,2590,-1840,-1660,1810,5546,1872,2301,3801,-825,150,3143,1507,-1355,-575,-280,-1145,-610,1049,1834,-6771,-1195,1599,3231,-1021,295,-5345,-1543,2076,432,-999}
     },
     {
      616,
      15,
      {4621,-2151,1601,1376,-971,-2283,1091,-1245,753,-3253,963,601,1943,536,-1397,1265,-1312,-222,2167,1869,-392,-2221,584,-1758,-215,-1254,292,1973,-1846,259,-441,517}
     },
     {
      616,
      6,
      {4178,-565,-962,1635,-1705,2102,1093,-275,1406,-2836,1334,-1820,-783,-3623,-1782,240,1501,784,-2780,-1495,-72,6684,-844,-1013,2641,478,35,2410,107,-1013,-2348,973}
     },
     {
      616,
      1617,
      {4,51,-1755,-1823,91,-546,-731,748,1191,-1030,3546,-1560,120,2351,-3913,5136,2306,8217,-2445,1610,-4248,-4721,-1668,-1252,900,-913,-704,-4425,1055,-1048,-116,1545}
     },
     {
      616,
      -4623,
      {711,7333,869,1224,-2517,203,302,-2098,396,-536,865,17,1451,525,1811,1731,-724,435,-3946,-973,989,2245,-2375,1890,2029,-3765,1672,2841,-3089,1772,-3869,-2338}
     },
     {
      616,
      3350,
      {974,-20,1905,499,-557,-2278,2569,-1699,-2256,-1929,3616,-1407,-2032,2041,-3739,-1309,2978,-1309,-93,1412,-2129,-5010,1490,431,-2780,2288,2114,-3156,1833,-1030,-238,-64}
     },
     {
      616,
      1694,
      {1616,1784,-2498,2990,260,-4441,1681,-3853,919,-1837,727,-1059,-4571,218,1071,-2072,1354,-1089,173,874,-703,1283,717,935,802,-342,618,-633,-50,-2919,2980,545}
     },
     {
      616,
      2386,
      {1209,72,-4183,751,1097,-2204,-127,-4494,-668,3035,2540,4094,-2817,346,-6604,-794,266,1583,877,-440,744,484,510,208,-2054,678,-930,-1570,2061,-847,159,-773}
     },
     {
      616,
      1020,
      {423,-351,-6201,3892,-1275,1799,3864,-3163,298,-1117,1373,-1690,-184,-132,-1855,2924,-2573,4830,954,3211,-3407,-7038,2875,-3313,228,-1073,1856,2543,1626,-1528,652,-1426}
     },
     {
      616,
      574,
      {3913,259,-2203,-642,-374,-1016,-3091,-943,4917,-2290,1517,580,3105,2331,-349,2064,-1785,-134,-1471,1114,-1339,-2870,377,-3685,1035,679,-17,-774,370,-509,-313,4580}
     },
     {
      616,
      541,
      {2864,681,798,-317,621,-863,849,-4308,1374,-5844,87,-1196,-5041,-1013,-4300,-1937,346,1750,5274,229,3595,3994,1607,2038,-1565,-425,345,856,-1432,-51,626,-68}
     },
     {
      616,
      222,
      {3045,216,2117,-1251,-482,-3185,1290,-1053,-2648,-1140,490,40,3701,831,-122,772,890,870,-2490,-171,-978,259,-1613,1078,-2352,737,-209,457,-1905,115,2616,-1310}
     },
     {
      616,
      196,
      {3994,302,1274,-2169,3270,-2253,721,-5591,-572,-1776,-1070,1897,-2252,2078,3368,1912,-376,1348,3332,1896,-3515,-835,-1032,989,-1625,-62,1285,725,345,-2131,-2741,-278}
     },
     {
      616,
      -380,
      {-492,1181,-1630,-513,260,-1642,2026,1352,1171,3996,-684,1595,-772,897,649,3146,-2050,-4310,-5057,579,-1121,-897,577,297,166,629,-1963,3332,847,-461,-2330,-336}
     },
     {
      616,
      1489,
      {6029,-208,-339,51,1035,1934,1291,-264,-5391,892,1186,-703,-1794,693,-2308,1544,83,2939,-4172,-646,2399,1767,1891,-668,-112,-1337,-279,-17,-644,-2142,-1972,2928}
     },
     {
      616,
      -1079,
      {2737,1222,2286,844,-722,-3635,-1568,-97,3263,1685,-530,-3298,547,-838,3140,2246,318,-1800,-255,-955,562,-91,-761,65,2233,67,-594,-288,-1428,-797,-2624,2790}
     },
     {
      616,
      -1293,
      {970,86,1334,405,-1177,-1357,643,898,211,6487,1878,-193,-3822,-168,412,-4540,-2049,1123,3975,761,-545,-1430,-2001,820,-1300,871,-1489,729,710,-1350,18,46}
     },
     {
      616,
      -1055,
      {924,261,2840,403,334,-1569,2926,289,451,-1487,2030,3468,858,1347,1341,-1266,-542,-4426,-1834,-188,-740,3901,-2753,-1410,1003,-1397,-2442,2149,-2174,-1121,-1356,2895}
     },
     {
      616,
      -1985,
      {-1120,2948,-975,761,-1821,-2346,230,-305,-3419,-1386,-1392,1874,-1603,-935,-1957,-621,688,2884,1942,252,495,2531,-2091,659,-888,-466,-245,3778,-205,-405,2573,-886}
     },
     {
      616,
      -704,
      {3198,-617,-1745,-563,992,-1990,4298,-2842,-574,1006,-2348,1358,-3416,1192,-532,4005,1516,-945,-1466,-383,-1661,5322,-753,100,-3295,1980,-330,-1442,643,779,-895,852}
     },
     {
      616,
      -2337,
      {5475,-1263,-4842,1067,-1885,-1550,2061,-5765,-3452,1558,-4100,-1505,5163,-163,-940,5310,358,110,5214,-1152,-1208,1523,2143,3142,-299,65,2075,1190,-1721,-1070,691,-3143}
     },
     {
      616,
      252,
      {3602,1298,-3967,205,565,-3764,1356,-2591,2169,-999,840,-658,2196,89,665,2090,-1934,-364,-1585,-286,-1319,159,238,967,-3078,3091,-2325,1340,1786,-269,-782,-1471}
     },
     {
      616,
      -366,
      {4789,2600,3012,-610,-857,-3937,739,413,-611,-977,4577,-4309,-5783,-925,-1572,584,1390,795,-3549,1056,1453,1115,-2926,1587,-1256,-561,1716,2028,62,-1417,387,150}
     },
     {
      648,
      -1288,
      {-1634,-825,-1488,398,776,-1727,469,-518,914,-286,1029,370,-1335,290,522,73,558,-629,-1127,-1389,-329,204,386,270,947,-114,-155,-451,802,-110,20,-63}
     },
     {
      680,
      -2514,
      {1110,-1461,-906,-356,574,1220,295,624,-417,31,302,-423,250,565,559,1199,-223,-298,-727,-511,1241,465,-490,-456,-311,-1045,146,329,894,567,1361,-216}
     },
     {
      712,
      -1992,
      {337,-17,316,371,129,-101,397,98,-414,529,-62,657,-1543,-38,595,-198,862,570,776,395,-558,485,348,740,498,129,145,456,-33,-425,-746,-610}
     },
     {
      744,
      -1704,
      {544,204,-119,339,-224,154,443,51,180,58,130,542,-648,-159,-299,126,157,-173,339,799,627,82,-632,325,266,1567,1086,232,656,-330,1209,502}
     },
     {
      776,
      3187,
      {1334,-1109,-26,-2133,2006,-711,105,-676,1623,-618,-767,-701,2689,20,169,-443,645,198,-29,-550,651,-285,751,-351,-600,464,-462,3,105,-469,340,-490}
     },
     {
      808,
      -918,
      {-52,-155,-607,-589,47,673,-274,290,409,460,311,-115,675,-18,364,848,-171,-864,-145,594,-628,242,-465,-187,371,-94,-610,56,-49,528,-382,-39}
     },
     {
      840,
      -1133,
      {-1325,924,632,713,-2483,406,-109,98,360,-168,-430,597,1186,-3674,-499,177,733,-302,-273,-237,-15,763,-60,346,-125,258,-545,-299,-4,1182,-420,414}
     },
     {
      872,
      -706,
      {343,418,-61,471,-99,289,345,-189,769,300,24,338,-58,77,49,-162,-43,62,-573,198,13,302,-698,983,113,206,-521,312,-210,284,122,429}
     },
     {
      648,
      -1523,
      {508,341,-781,-1052,754,-235,-432,1098,374,-270,-1501,-891,396,25,365,287,200,-1384,-129,1490,615,689,1072,1077,-857,-28,-417,-221,734,715,1070,1206}
     },
     {
      680,
      371,
      {3831,1947,3460,-372,1267,2778,1456,2872,-1083,-1478,-3677,-1005,-48,3,602,51,760,1850,938,557,191,1261,598,2050,-927,368,-1927,314,-703,342,-610,1297}
     },
     {
      712,
      -2601,
      {190,222,532,156,-592,-120,38,-95,-147,-63,354,10,-640,520,300,388,237,-199,181,-21,376,-216,-151,-155,279,647,178,37,211,637,447,1336}
     },
     {
      744,
      -691,
      {391,-456,-838,376,899,951,3422,1542,920,-563,445,295,199,222,-846,-473,187,147,743,-76,1903,1425,499,2385,117,-720,348,1355,746,-238,-132,-354}
     },
     {
      776,
      922,
      {-75,12,24,-85,-227,180,-68,-208,-205,233,-76,35,226,-156,-307,-141,21,-317,-35,-88,-236,-22,-343,-332,-167,-258,-56,-247,-43,-204,-76,-291}
     },
     {
      808,
      -1328,
      {-170,155,320,-149,-799,16,-37,577,573,430,1494,1740,123,521,386,-184,5,728,-366,290,157,541,349,1037,261,1640,345,606,-72,-452,28,-516}
     },
     {
      840,
      126,
      {-211,-691,-143,-263,382,1164,73,544,-249,-73,-1242,-731,-1750,2705,284,1497,-767,607,1155,726,-128,-744,1073,-228,-571,-738,3483,591,841,-3378,528,3344}
     },
     {
      872,
      -3595,
      {-433,-652,607,377,981,446,711,1301,-177,1272,-133,351,1363,427,198,512,469,675,1957,-246,-133,651,21,-1600,-478,773,855,-220,70,-1521,-184,-1662}
     },
     {
      648,
      -791,
      {347,516,879,-367,-157,-1745,-815,-623,1024,-414,77,1219,-665,362,1514,194,1,594,1091,1304,-1446,1235,988,211,12,360,-19,270,1224,366,766,375}
     },
     {
      680,
      -1008,
      {-570,-336,-2227,-25,114,1161,388,281,-933,-190,-59,86,38,423,270,739,-682,-360,-948,-1740,886,169,1751,-1018,318,-473,648,-762,302,467,1592,-853}
     },
     {
      712,
      758,
      {10,-603,-226,370,539,-1115,1273,435,190,-2302,-1076,-1082,1555,-412,661,-257,-877,245,-288,191,-369,-178,-354,-290,-2612,-1170,-169,-392,389,-299,-437,-145}
     },
     {
      744,
      -1450,
      {115,12,119,234,298,34,200,217,422,75,188,197,268,181,149,208,25,151,367,-217,-76,134,-154,-66,78,415,-74,-29,161,9,193,49}
     },
     {
      776,
      -17,
      {-411,-673,-1378,467,1241,-1081,793,72,2807,-2024,-1381,-1733,-133,-463,-46,-849,566,1016,465,423,-227,484,-906,30,-2613,-748,-110,-1061,-496,-1363,-1207,-558}
     },
     {
      808,
      144,
      {-70,433,306,245,-113,17,51,193,170,-24,199,127,-453,-34,-404,-403,240,207,-107,250,-105,10,-588,150,-253,175,-306,38,-301,-410,-228,-504}
     },
     {
      840,
      -108,
      {1741,3991,876,704,477,1454,2283,-30,-354,232,784,721,673,2924,2503,1545,338,21,-234,15,-192,46,-177,-39,-324,567,93,-169,183,693,-580,298}
     },
     {
      872,
      -272,
      {155,337,-263,422,54,363,408,-210,279,-286,-519,-216,66,378,518,703,-294,-117,-1234,-2344,-27,599,-1820,-1596,-799,469,-601,-1592,-562,-1317,-1454,-574}
     },
     {
      648,
      -1457,
      {875,1606,182,2077,532,18,433,-413,-1880,1107,489,832,-1193,4224,1254,337,4858,-149,3256,3191,-533,775,949,886,288,-582,-392,-765,850,57,465,716}
     },
     {
      680,
      -1949,
      {-1657,937,-312,1265,1287,182,543,718,478,-579,19,-418,1628,1085,747,-282,350,855,464,-567,-642,727,-900,1003,-168,1251,-1369,620,-388,-517,-515,397}
     },
     {
      712,
      -533,
      {-2164,432,-176,-1389,1238,170,-857,-535,-40,446,-932,292,-824,-234,-1090,229,-673,-598,-707,261,-106,378,-201,386,6,-38,370,-218,207,749,639,128}
     },
     {
      744,
      -509,
      {-29,176,77,-147,180,-334,50,181,-3,289,264,175,451,0,645,186,-161,332,-545,-545,-798,-606,-650,-500,95,-1295,-1353,-1158,-23,-243,192,-2140}
     },
     {
      776,
      348,
      {-1899,-457,94,-270,-420,-318,63,-349,-469,-275,227,-249,-1685,-14,-101,219,-267,-153,205,227,166,-249,244,230,-397,150,-179,192,-49,172,-69,289}
     },
     {
      808,
      -1637,
      {407,408,400,338,139,19,443,121,124,-1,-60,112,-222,169,-52,-268,238,438,165,35,139,81,42,309,150,-93,3,425,26,52,44,227}
     },
     {
      840,
      -1499,
      {1599,-935,-106,-602,1443,-279,126,-404,-15,1004,761,44,-315,664,140,-121,-216,707,297,533,705,-511,476,-53,626,288,645,187,-171,-881,235,-300}
     },
     {
      872,
      -1474,
      {-771,-527,226,-171,284,122,216,1107,37,455,747,422,307,-401,-311,-231,492,398,1298,-535,-129,381,946,-778,338,718,580,-637,84,-1206,356,-1292}
     },
// *********** Cells of layer 2 *********************************************

     {
      0,
      -73,
      {-14,1062,-1409,2529,1109,1226,-548,-270,323,737,476,-761,919,-1347,-437,-620,-700,-996,125,-1034,-417,3055,343,174,310,-32,-767,321,-267,26,410,-244}
     },
     {
      32,
      -2176,
      {-147,-727,2414,-1396,-386,-1534,-554,864,-358,635,-155,479,-1764,505,-1065,584,406,2223,-58,-1820,870,1127,510,-486,514,1851,-520,1230,-275,-301,-154,-170}
     },
     {
      64,
      -2038,
      {775,2389,350,213,-559,-791,3823,-158,2215,24,2966,-1708,-1038,-410,-658,-1268,-2080,-1214,-741,-1345,-474,1242,-113,681,808,1334,-142,-509,405,-34,-3211,-88}
     },
     {
      96,
      -2256,
      {-261,556,77,789,662,-1594,75,-1347,-880,26,-1834,421,471,-251,285,-1005,1470,1473,-733,730,1637,1177,673,-1441,102,1609,410,1439,291,-993,-375,-764}
     },
     {
      0,
      -1899,
      {2744,38,-1062,1573,880,-574,-86,2618,-476,1020,-487,544,-2708,1003,-492,-1817,2190,891,339,1134,312,447,-280,-1101,-1138,1981,-1130,1065,-1943,-849,-3460,-1068}
     },
     {
      32,
      -2111,
      {-999,-114,1376,-562,-1368,-2649,-889,517,601,505,334,339,-980,419,1174,41,1077,-421,-528,-1917,-85,299,-109,-64,-1769,1454,1426,2459,-1246,476,-2722,-3190}
     },
     {
      64,
      72,
      {-28,-2056,-196,-2426,-296,73,-1235,-388,-389,-922,-1429,632,978,-1243,-544,-231,452,-34,-583,893,2667,344,67,502,-1120,681,56,-237,305,-1697,-880,-70}
     },
     {
      96,
      1899,
      {1424,373,-1054,-155,-436,1085,4084,1014,644,1111,615,-26,-2608,2782,1111,-1797,-2025,-870,2051,645,-2486,-1610,-1943,-70,-190,-2479,-1087,905,-2566,625,1036,1513}
     },
     {
      0,
      2938,
      {-2652,199,-1545,-141,-1937,-3464,2164,-27,-1618,1701,344,-385,-3666,363,-3321,-2698,-1721,401,-1228,-515,-33,267,-943,-2005,-1253,747,-67,-309,-1127,1053,4201,-75}
     },
     {
      32,
      2491,
      {2020,-667,475,-1316,-1887,-1298,633,580,-1719,1247,-89,2351,-2454,-60,-1277,-24,280,-564,-439,-516,-1467,114,-1536,-585,975,-234,-374,-623,-131,-364,-932,1110}
     },
     {
      64,
      -567,
      {1143,-973,222,-1834,-2514,247,-1116,456,-332,2343,1093,-1001,-124,-20,-486,990,374,-692,440,262,-938,-812,-437,386,375,-3571,-122,1126,1395,475,-54,-983}
     },
     {
      96,
      -1548,
      {616,-156,747,-95,-1152,785,-91,576,1522,-354,1567,-400,-976,-194,-331,-1310,-943,-855,-1818,173,1147,688,-245,142,-445,883,1306,538,503,1185,-71,1542}
     },
     {
      0,
      1140,
      {-275,-1563,-366,-3841,1514,601,-331,-490,-1004,-1033,-1071,-1705,-659,449,30,-413,-565,-2147,-1902,1501,981,-1235,123,-234,1591,406,72,-586,111,-131,161,-837}
     },
     {
      32,
      -87,
      {236,-1499,358,468,-918,-2680,-451,243,40,557,-953,750,146,-19,-2859,569,384,396,1721,716,-925,565,-480,-1036,622,210,-512,-920,99,71,1941,-33}
     },
     {
      64,
      -914,
      {312,-606,-815,-326,256,457,1122,-269,-217,786,-361,-65,-151,-401,1804,667,-517,-291,-2036,-1176,-175,347,-194,986,80,-1617,-919,237,-1224,-925,-805,69}
     },
     {
      96,
      -3482,
      {280,564,572,-505,267,121,324,852,1245,-160,688,-1217,-755,384,1033,226,-768,-141,-301,1108,792,234,-525,60,-160,716,744,50,481,1307,-224,-63}
     },
     {
      0,
      -1727,
      {-169,545,-1364,2399,884,517,-2126,-205,-2286,734,1292,-2311,-1346,855,-5,-664,-646,-647,376,-762,178,741,1749,-332,-673,2246,539,1290,-45,-551,1979,-2380}
     },
     {
      32,
      -2129,
      {1655,-500,-1107,-427,-754,1275,391,-63,1067,-557,-282,877,1350,572,-948,-45,-706,-598,767,573,-998,876,-950,-1601,-250,889,-1470,-1352,-186,858,1763,-725}
     },
     {
      64,
      -219,
      {-1016,-2636,-482,435,90,1560,-593,-1125,-69,780,64,-937,591,187,-2486,152,-338,510,308,1686,-716,-795,-1627,-1002,1147,310,1850,16,374,-653,-1071,-585}
     },
     {
      96,
      1390,
      {-1107,1965,1079,1304,170,-715,503,-1686,315,1116,-578,748,553,280,-284,-337,-302,611,-623,182,1457,-779,-1923,1004,2124,1307,-1229,4,-401,-1574,-703,699}
     },
     {
      0,
      -1715,
      {-803,-498,627,-1919,1693,1934,-566,-61,1598,-215,612,229,1064,200,10,609,226,-133,185,-499,1148,1054,617,1044,977,243,-1268,-1073,929,445,133,-1848}
     },
     {
      32,
      -47,
      {1745,-83,1236,1470,-205,2353,-1236,168,-1283,-2868,2369,924,149,-401,81,-424,-1895,-2604,75,-1292,1063,565,2864,-1589,224,385,-3145,1658,1232,-1029,-419,80}
     },
     {
      64,
      -1110,
      {-539,499,1766,965,-1458,-2474,556,570,368,-717,95,-739,-1024,-636,-423,-197,1496,38,-1082,573,1565,-392,818,-1059,927,965,-5316,296,325,100,-411,-411}
     },
     {
      96,
      -1973,
      {-592,137,-1307,-1364,1360,-510,-179,-194,-1977,-341,248,1260,2109,-388,-945,-2034,2194,-767,-656,-159,-637,756,166,-118,356,-738,-1548,-809,1273,-205,-75,1958}
     },
     {
      0,
      1351,
      {472,606,-235,-4425,3217,945,-614,-3505,228,-824,-557,-10,-224,-1852,947,-1861,980,795,1194,382,-732,492,1816,376,423,-268,-1309,-777,-1841,-772,-54,-2610}
     },
     {
      32,
      382,
      {330,-1072,-3779,-493,-645,130,-1538,-464,566,370,830,-1942,-310,180,2550,563,-392,2105,-605,12,2935,-1266,-14,-1127,460,-174,-21,1410,44,11,-337,-930}
     },
     {
      64,
      1599,
      {-547,-920,1268,2155,-1145,647,800,-1171,-4469,-571,724,-1916,-95,-443,2428,-386,258,176,1297,829,-1807,901,-1133,-1787,-1447,-1143,567,-685,108,-2844,-481,994}
     },
     {
      96,
      132,
      {136,1248,-647,859,1426,126,-785,-2709,-88,386,-236,441,1507,1173,-146,72,-494,-1579,-579,-834,-390,-1411,-165,475,-32,-787,-568,524,-682,252,-1630,-2019}
     },
     {
      0,
      -1370,
      {-239,962,569,-82,921,1461,-5560,1541,858,81,842,-1294,-3221,758,-142,417,-480,-778,122,-426,-1254,1448,-95,-382,-1169,600,379,1241,-175,-733,-339,-357}
     },
     {
      32,
      -415,
      {-349,-482,324,-93,-49,2737,-444,-390,511,1146,-1301,-1513,-1716,391,930,462,747,1139,1093,94,-2131,-997,319,598,83,286,958,-663,-337,120,-2010,-1975}
     },
     {
      64,
      -190,
      {217,-642,760,2458,970,1080,-56,-137,-1192,-1688,75,-1609,-108,-158,1059,-1323,838,279,1345,-2710,-3706,647,24,257,-1468,-1715,-2531,1384,1269,293,301,-2206}
     },
     {
      96,
      -1903,
      {900,-825,-518,367,-567,-221,-200,8,709,-584,525,1609,884,736,364,-2277,-1144,97,98,285,-3867,14,392,-225,-716,-225,-625,504,89,-256,-459,2278}
     },
     {
      0,
      -1203,
      {646,644,-1106,-1242,336,749,1794,-1841,-824,203,746,315,990,234,299,43,-156,-670,-1,-983,455,-706,1063,812,83,486,-609,53,267,-73,-961,-161}
     },
     {
      32,
      1215,
      {46,129,-1007,432,-278,834,-2687,-683,-965,-1120,719,-1040,-687,-219,1136,-620,645,-1498,-5467,-734,-901,-610,1979,685,-939,-706,159,332,5,-800,-612,777}
     },
     {
      64,
      -384,
      {234,243,-681,782,-287,916,-463,-78,392,-311,171,-1455,180,-327,-693,-343,-248,696,338,681,-99,294,-1154,-333,961,344,278,-4,-1074,470,-521,603}
     },
     {
      96,
      970,
      {-1429,-1345,332,27,-427,-298,-299,-266,-924,663,-893,-602,732,-509,76,-315,293,968,532,-796,192,950,179,1,427,-412,485,-127,235,-1105,-444,462}
     },
     {
      0,
      910,
      {-1056,270,-807,-2908,299,-1021,-351,-5913,91,-610,-613,1966,-531,763,-251,-1713,-1143,-3631,-1394,-400,-147,-169,-1243,848,-518,-686,-1453,-147,-583,214,1085,146}
     },
     {
      32,
      -619,
      {750,522,-1394,499,1965,2441,303,1081,-399,-91,-96,1036,1086,33,-1611,-456,-1407,-398,-303,682,1696,-318,-3347,-763,-983,-981,-498,-716,-350,-816,126,-1295}
     },
     {
      64,
      367,
      {532,-151,-1176,3629,-300,172,2041,109,614,-627,767,-1296,461,-335,-62,-203,-1992,-1116,-327,186,-550,190,801,-2784,-104,-409,351,-303,-315,756,-539,1330}
     },
     {
      96,
      -1226,
      {908,1764,236,-60,197,-89,605,-8,759,166,-1055,-56,742,266,180,1153,-237,-1349,47,-30,709,-315,-512,-13,-336,213,139,-290,637,-456,128,-1060}
     },
     {
      0,
      1463,
      {1112,469,-670,-709,943,-1981,-682,-1160,-695,-511,-2874,-1474,780,-1897,-1203,-992,-1037,218,225,1416,-973,786,71,-1132,208,679,342,-195,-1812,180,673,-1040}
     },
     {
      32,
      1053,
      {-1329,-456,-1123,-860,-308,-241,-574,881,-1013,1121,693,1169,-1707,1051,246,-2117,1264,-234,-585,-1461,986,-677,-2711,-192,-3059,-1978,-640,-2,-256,128,16,-890}
     },
     {
      64,
      238,
      {-498,219,5,612,1276,-845,5,-761,927,-502,2529,-770,244,1532,1065,214,-804,-2128,797,-635,-796,182,-709,-545,-255,-3306,877,95,410,-698,-446,-2371}
     },
     {
      96,
      -13,
      {1183,-527,-357,-953,1139,-229,-1414,838,-60,-195,24,-876,141,-805,-1315,800,526,721,269,161,964,-361,1132,-1098,-789,-22,453,-305,477,209,572,-1063}
     },
     {
      0,
      199,
      {340,351,1249,-1530,617,-515,-879,-788,607,1276,298,-295,-154,-2450,-2350,-1093,1026,-616,584,488,-897,2162,-171,-88,69,-1353,535,-1421,-819,257,604,904}
     },
     {
      32,
      -133,
      {998,714,159,120,1334,-833,660,242,-904,-1060,195,2261,731,-420,-236,-110,-1824,-1057,-750,-125,-208,1213,-1331,-1081,-516,-259,-637,1018,182,-1250,-443,603}
     },
     {
      64,
      161,
      {-332,-260,-21,-1284,-787,-578,-264,716,-1207,162,-1243,993,-732,268,1784,566,480,672,10,-1215,-923,-63,-563,306,33,-1078,-1442,1407,-1902,424,20,-761}
     },
     {
      96,
      2284,
      {-169,-1077,-755,-608,799,30,-664,372,-1129,-148,-230,-347,178,53,-1007,-158,1096,-86,-310,283,188,-466,396,-586,-112,-408,-320,-638,169,252,253,-356}
     },
     {
      0,
      -445,
      {482,-360,-878,-681,-26,723,-206,-885,538,-732,1378,482,1772,68,1472,-1066,223,-818,301,400,272,-877,1130,1170,-1280,-1358,-1081,-473,-103,100,1619,-545}
     },
     {
      32,
      -114,
      {779,-1096,-779,708,2464,208,661,-1060,194,-481,-1545,-1109,976,219,-2249,241,-1819,-387,-681,1912,-2521,-110,-261,972,1841,-1343,538,-725,-635,-442,386,638}
     },
     {
      64,
      654,
      {-1239,-3326,22,1014,-636,-192,2081,-393,-367,764,2193,-750,-390,-1203,2436,-1494,-1845,1272,-2852,-369,-1642,-185,2575,-2319,385,-1401,-2686,1696,500,-3404,-1133,862}
     },
     {
      96,
      -2418,
      {-167,12,299,172,-252,372,1076,1614,189,-480,1026,-305,-1315,393,265,-147,195,-510,-135,914,-362,-584,70,33,0,42,214,174,-391,812,1287,836}
     },
     {
      0,
      -955,
      {-537,1168,-889,732,-1564,872,-1627,296,-625,-1911,1601,-83,-2305,2872,1543,-1224,-95,-297,-1407,-1713,-1490,1062,1999,-70,-1483,-307,1285,1404,1281,-870,2166,-1640}
     },
     {
      32,
      -1964,
      {450,-701,-555,2061,1471,-1666,-510,-257,-20,-936,1131,-57,-240,-1393,1451,1197,-1404,-1568,-402,-1467,2146,-2076,285,2080,-630,882,1526,436,703,-35,-25,1331}
     },
     {
      64,
      -212,
      {-163,-20,342,-2042,173,-5267,-1617,-1120,932,-401,-3453,-250,-220,103,-227,1744,-2641,1497,-222,830,68,-1237,609,-594,-2498,399,-3199,1356,-204,1028,-1421,173}
     },
     {
      96,
      3246,
      {229,-316,458,997,-250,1717,-814,-2310,624,109,32,114,-1597,1226,-1024,-299,-1452,-273,-621,-1015,-515,-23,191,-402,411,-110,-837,892,-23,-607,-1120,162}
     },
     {
      0,
      586,
      {-1578,-1248,-1383,-3009,-1983,-553,-1097,1001,2273,-750,-2352,-1093,-861,832,-1588,359,-1468,-1073,-1320,-2287,-3197,-373,2847,-145,-778,49,104,-3958,-392,451,1676,874}
     },
     {
      32,
      712,
      {215,-2598,-246,-455,-866,3159,-1798,-1612,-2488,-1910,-14,512,-455,-246,2418,747,37,-1055,-2514,-954,716,274,2114,1025,-1093,11,1230,366,-315,-655,-882,-3073}
     },
     {
      64,
      -339,
      {5,3392,-1547,307,413,153,-513,583,1081,-1350,-668,-1991,-1117,-140,-940,-1139,-204,-90,2192,1065,301,-326,159,91,-683,-23,2335,1201,-1840,1308,-1814,860}
     },
     {
      96,
      -1269,
      {1474,-396,819,26,68,-441,-529,-851,263,327,976,-489,726,-457,-476,908,18,1001,296,1578,541,487,-1194,703,-63,11,577,-293,387,625,-734,-1058}
     },
     {
      0,
      524,
      {1224,1012,-450,-861,-90,-3401,-1447,137,-2266,57,140,-954,-1269,10,168,30,-195,289,891,-888,2203,-1581,-1459,-754,-578,842,-652,-946,284,724,-477,-658}
     },
     {
      32,
      -1335,
      {25,-1746,-54,1935,-1220,-3281,769,-1248,986,-1926,-1015,1294,293,-224,489,651,425,-1206,473,1382,-1433,-400,-1901,-481,-510,-849,390,-1153,591,-454,2692,2091}
     },
     {
      64,
      -839,
      {1328,-787,921,2031,684,-450,490,-196,1700,-504,13,355,560,-340,2046,-4663,151,-1902,660,-2905,-4983,661,-91,1252,345,-832,-4196,1579,1171,516,-1748,2802}
     },
     {
      96,
      -596,
      {-399,-780,-72,-745,118,985,255,1304,-317,-492,169,-125,-1127,131,154,-143,-182,-130,223,689,595,23,780,-822,-105,-512,-448,-204,120,810,591,456}
     },
     {
      0,
      -2779,
      {410,-2499,-1221,112,-640,1280,-749,-728,-480,1726,342,1,-275,1586,-60,2206,-127,698,1206,-915,-609,443,3328,-1703,484,31,-149,753,-394,-224,-266,196}
     },
     {
      32,
      418,
      {-29,-298,-899,2295,-1238,-87,1059,-1254,-1678,133,-485,-1602,694,-314,113,467,285,455,-1377,1107,1596,-1733,-73,1517,-1274,-522,-2794,621,423,-160,416,335}
     },
     {
      64,
      516,
      {133,-320,-154,1446,-113,-299,-137,-1061,507,662,1122,154,-1456,-289,-676,-831,-252,-162,-1452,-217,-641,599,-2301,490,103,-572,-772,1264,-1430,-629,1900,-554}
     },
     {
      96,
      -626,
      {25,-268,13,469,-518,-530,-124,1320,-678,340,-170,-127,843,424,858,42,548,-110,447,-867,-590,-291,1565,-1349,-2,-618,239,899,357,-148,-348,-175}
     },
     {
      0,
      100,
      {-985,635,-1284,1200,186,1118,-2459,1083,933,-44,163,-652,-1178,-391,-519,618,1154,19,-885,432,-2124,155,-260,-200,-448,298,308,-538,1650,-244,-36,-563}
     },
     {
      32,
      -1101,
      {167,-942,-2563,2506,1714,139,276,79,1453,-3198,740,-1542,-342,602,-820,942,-1668,1375,235,592,1235,-788,56,-953,2754,500,-150,-1327,449,-1057,1066,231}
     },
     {
      64,
      2186,
      {272,541,785,-804,-1590,-1947,351,-593,428,164,-300,294,-1759,14,-834,171,-326,-1567,466,263,780,938,297,888,-2275,-64,430,-1326,-480,-83,-293,-1406}
     },
     {
      96,
      -381,
      {502,-668,-180,-419,-139,802,-218,-297,-239,-348,634,-230,-1026,-377,-281,25,260,32,167,479,1188,854,379,-655,-301,-1605,202,-21,-149,-203,-62,-912}
     },
     {
      0,
      -1304,
      {433,-988,99,1838,-1191,234,735,477,-1220,-778,785,-194,1776,-62,638,-781,950,482,-647,652,-2538,-1754,-530,-173,30,-548,-955,-55,1385,363,-226,325}
     },
     {
      32,
      -558,
      {-66,145,2097,-1905,219,1341,-507,-247,-2203,189,-954,1325,75,85,1444,-43,166,-172,-1462,348,1129,307,44,16,-1768,-557,568,-588,-222,-153,1029,-2049}
     },
     {
      64,
      236,
      {-87,269,27,1295,-1352,-659,-449,-932,-18,321,-1158,303,-488,-1415,-1011,0,41,334,-67,-45,158,-503,-1202,1042,633,1328,957,-496,-509,-205,1127,-191}
     },
     {
      96,
      -2435,
      {-280,1289,861,647,411,-197,-726,-408,37,34,440,-528,2672,-654,-514,487,72,-16,673,7,575,1628,144,-1273,322,525,367,1011,416,-1838,-499,-713}
     },
     {
      0,
      -696,
      {879,-963,-345,517,1101,-125,190,-233,-475,600,1257,-1912,421,388,-45,-516,416,-650,-7,67,1285,178,295,443,210,-1222,-1423,-95,-1046,222,-65,-137}
     },
     {
      32,
      82,
      {-160,654,-1465,-1408,1048,394,-376,-355,1495,-255,-1505,-2258,-140,665,1554,-808,-378,-1893,855,57,-1454,479,266,119,-339,-1179,-672,570,364,475,-64,76}
     },
     {
      64,
      549,
      {-1196,-648,-880,337,1626,1233,-428,331,-82,-267,-23,-1609,379,234,196,283,84,717,21,161,-890,-356,-1478,468,1209,-848,-1111,1066,-211,-1357,647,161}
     },
     {
      96,
      3729,
      {1203,-927,-588,-224,-234,-999,-1176,-1334,-589,6,-119,690,594,299,-898,-817,1185,-13,-490,-829,-2714,-894,720,-767,-1145,-437,86,48,-997,-2925,-911,-801}
     },
     {
      0,
      250,
      {-837,-631,-571,1297,-3343,181,-1251,1837,-59,-743,1679,-1245,-392,-410,-2104,-285,2033,1091,-502,-356,593,-1026,-1617,-903,967,-790,263,343,-882,-239,262,-278}
     },
     {
      32,
      -54,
      {-371,-1818,1698,-714,-832,-907,-840,-613,-1435,0,-1793,1626,107,-198,1075,69,-959,2356,-795,938,469,852,-429,-773,-250,-1292,915,-2093,206,-668,1449,-101}
     },
     {
      64,
      608,
      {-193,851,69,415,-2091,1689,-267,-1354,-1112,417,568,169,1705,-231,-957,-1181,2120,314,-606,126,-3007,-694,-1618,-917,646,-1543,916,-1011,-326,-1348,2869,1013}
     },
     {
      96,
      3190,
      {403,-1662,110,-1083,914,-633,-1875,700,-1195,-182,-324,-51,2187,-370,-1032,-386,316,343,390,-669,-675,315,1505,-1369,-928,-290,-175,-612,-388,-3193,-267,-561}
     },
     {
      0,
      -1681,
      {1132,-850,-274,91,-1455,795,-882,1951,-2441,-1653,835,-835,92,67,-1426,-152,82,286,1108,419,1414,902,-643,1140,645,417,14,958,-925,-1059,-1660,-306}
     },
     {
      32,
      -1720,
      {518,369,-436,1598,335,-1460,-27,-45,789,-3413,1104,542,1067,-768,1015,1208,-905,-2325,-929,2243,-152,-1459,-923,105,-745,462,2142,458,-208,-704,-1986,190}
     },
     {
      64,
      -399,
      {-5267,-307,67,1294,-765,-287,-872,-1063,382,-140,1507,397,82,-15,-689,935,-562,-437,-1530,147,-706,-158,-2367,502,400,-540,-732,-926,-307,-559,1513,-299}
     },
     {
      96,
      135,
      {-158,-983,-1364,636,-262,766,86,1550,-606,3,-1171,-220,-844,-602,84,-402,642,1090,-871,-1853,326,683,232,-422,-189,-210,-459,101,463,1845,565,378}
     },
     {
      0,
      1151,
      {-1205,1118,-376,-43,539,-386,1209,-40,314,-1345,-711,-1336,498,51,-1199,-2162,-1945,-1167,-1094,-291,518,792,-1111,1372,907,558,-896,347,917,-664,2596,-2511}
     },
     {
      32,
      -1341,
      {1126,145,-2469,42,1123,-3255,37,-325,-1298,-1864,-937,738,-576,-339,1195,-481,-21,-2233,-967,-317,-1,608,-304,764,762,1637,-1476,218,-349,-486,1421,-299}
     },
     {
      64,
      1028,
      {-853,-475,140,292,-318,-665,180,669,434,-1055,682,-1310,-376,784,332,215,347,-800,317,414,-1344,82,-609,2,1274,-1234,-477,-143,-759,-284,-787,-412}
     },
     {
      96,
      -487,
      {877,-151,-322,-136,638,796,597,140,963,-507,34,-825,-165,-473,-100,-413,-990,551,-117,-770,1048,496,-645,470,-356,425,-493,-149,-206,-412,764,1441}
     },
     {
      0,
      1514,
      {-246,3,-842,-1193,-1116,356,-317,-1099,-555,-207,-1343,385,-1275,-2019,914,-165,-424,-316,-699,850,358,-1153,-838,-1857,-1015,11,405,-415,-721,822,209,227}
     },
     {
      32,
      423,
      {-1094,1198,209,-30,2172,-1213,48,-209,-1903,-1380,26,1659,1346,-144,1039,-277,558,802,-2614,-1499,1048,-1823,-1050,1511,-1177,-876,-1795,-841,-55,-1890,-67,-1554}
     },
     {
      64,
      3,
      {-779,-816,-1827,-1222,1369,1772,201,-616,-466,-779,-1992,-2700,1426,473,-553,-764,1233,1153,-1050,852,-986,-2344,-1783,-644,2270,-1315,3,-2728,-874,-496,1449,-368}
     },
     {
      96,
      589,
      {-2511,-1041,120,1003,184,-524,-69,-1412,-1094,-1498,771,30,-1197,867,966,919,1440,-665,336,1054,267,-1037,-103,630,-189,-899,-354,503,-1101,1264,-184,-546}
     },
     {
      0,
      -361,
      {377,863,819,-3684,-897,-135,-437,-3489,400,226,-1286,-2286,-1157,-2103,956,767,-251,-536,-252,-939,-148,2571,-520,-1608,-1185,-519,123,-470,1146,927,329,-1002}
     },
     {
      32,
      -503,
      {-258,-3861,-451,1515,-538,-2964,1142,-1465,-3334,1856,-253,733,-1058,-779,-747,-61,-797,-434,-792,-821,-1690,-1105,2846,36,755,1082,-54,1380,452,-39,1607,2220}
     },
     {
      64,
      -2125,
      {-21,-242,-1981,1706,222,-66,-1052,736,515,174,-903,-664,1140,-158,33,-278,15,2730,-2011,1223,-1107,-2654,667,-641,1832,1607,2078,2429,-1045,467,1625,1196}
     },
     {
      96,
      -1363,
      {486,-555,-242,-361,-272,112,1461,1387,-80,-15,-808,13,341,559,79,-247,-60,175,-277,234,-564,-303,-661,-479,-425,234,-176,-343,318,-727,1313,662}
     },
     {
      0,
      -803,
      {864,244,10,763,-1142,-573,2205,943,-1344,1710,-1114,478,-1941,63,-1451,154,816,1284,1104,-349,-215,-1248,-452,253,-1626,366,1358,196,-469,1246,765,107}
     },
     {
      32,
      -1087,
      {633,-2348,-1022,-634,281,1071,-956,-68,-1370,-1119,-1879,1139,-832,-603,-109,752,-373,1040,-746,940,-274,277,-607,-320,-830,9,484,-161,-17,-246,1454,2533}
     },
     {
      64,
      -1186,
      {-989,-2109,-906,2697,-2971,2079,2020,485,-1652,-843,-3208,-1912,2622,878,466,-789,-3078,89,-2536,1133,-2195,-1273,1981,2406,1250,-1041,-59,-143,-62,-199,1416,-999}
     },
     {
      96,
      921,
      {271,1218,506,403,-1103,-301,-305,-1089,212,397,180,251,163,468,27,264,-263,-918,-82,-65,-467,-598,332,290,242,-233,589,402,-338,-155,-733,-643}
     },
     {
      0,
      -1,
      {2058,2339,1845,-2183,2754,-425,-1382,-2143,-3186,1681,164,52,-542,-2298,-1167,-961,151,1451,787,31,-237,1113,491,-877,-29,-47,-685,-3036,-1751,1470,265,-104}
     },
     {
      32,
      -1018,
      {1130,-656,-619,-1004,2062,2007,-1376,503,-1362,-2060,-407,475,-551,974,-321,273,1146,-1610,-15,842,-1906,103,688,1177,108,725,-1356,258,-346,-1151,340,-900}
     },
     {
      64,
      358,
      {332,-1039,608,845,-3039,-2794,853,165,982,115,-59,-1396,-2385,-898,1251,-285,-1633,-1084,1232,111,-173,779,508,80,741,-699,-1723,920,1532,453,690,-140}
     },
     {
      96,
      -1046,
      {-1994,-57,-177,-69,27,-1139,-226,242,-1262,-679,-844,393,2452,-22,1282,386,932,-283,-500,-405,-368,717,-207,-323,398,-484,-22,-65,-22,-2081,-1292,-1208}
     },
     {
      0,
      -2076,
      {-1185,55,106,-1190,1856,-57,1162,-657,633,-415,-155,1247,-353,-1293,-139,210,-1404,-824,-177,-450,1437,1351,1840,1321,-1027,-392,-71,-318,522,398,1969,2}
     },
     {
      32,
      -337,
      {218,1007,481,2331,-1028,-1430,204,-1211,-2636,393,605,44,1235,-2542,2206,-1418,911,-1399,-260,-3618,635,-2706,3449,43,1165,-597,15,-47,460,1088,1305,879}
     },
     {
      64,
      -676,
      {-2157,-121,-108,-45,529,490,794,-1127,-235,810,-1286,-26,912,-718,121,1028,-633,-600,-2616,-1168,-560,753,-5,847,978,445,-1488,-51,-2355,1372,-708,-554}
     },
     {
      96,
      -233,
      {-305,-1396,-1798,1529,-403,637,742,2428,-851,-1317,67,-935,-1597,-80,562,-68,1151,334,-270,-720,1347,-1083,-186,-960,-1104,-458,-372,894,-552,2201,896,318}
     },
     {
      0,
      -3048,
      {0,1578,360,-1953,1542,194,-1329,190,681,288,-67,1000,-24,-1235,331,-62,46,544,500,-611,1051,2570,531,-1312,-838,958,-35,-465,1107,-442,-221,567}
     },
     {
      32,
      -1395,
      {-917,445,1178,-1012,-141,310,-596,1115,575,497,723,-195,-1620,340,54,556,-1160,1509,882,-1127,574,390,1749,419,717,442,-658,1203,770,-130,727,-3491}
     },
     {
      64,
      -950,
      {189,917,-461,-1129,-166,449,-402,830,-220,459,1214,-45,-101,1281,-804,-1162,637,-569,-723,650,1091,46,-558,304,-26,1606,-907,373,-967,949,-620,1255}
     },
     {
      96,
      3585,
      {1038,-1054,414,901,-1592,638,-1925,203,-2032,-316,-815,70,-904,229,-624,-2615,988,-260,-1234,-3696,-442,1313,2097,944,-949,-1485,-660,-242,270,-1360,172,1684}
     },
     {
      0,
      610,
      {324,931,238,1350,-536,-1210,1111,-1042,-1333,927,1758,1170,-1771,-1114,2522,-1206,490,-874,-902,1654,-2083,-431,38,991,-1214,-1169,341,322,-297,-56,2914,203}
     },
     {
      32,
      -197,
      {923,-727,292,-681,-667,761,320,1096,-878,-558,-723,5,-3184,781,-688,-860,44,-1828,-341,-2329,-3840,1787,398,-594,-455,1711,-627,1227,-1797,910,710,726}
     },
     {
      64,
      448,
      {2490,-713,-87,-3921,-1126,-2154,576,-654,-138,793,-3122,-567,-992,-1098,947,150,-2118,-1006,-1679,116,73,1139,-1615,2723,977,-880,1440,-1455,-1197,-111,-1360,835}
     },
     {
      96,
      -1164,
      {1580,528,-1074,187,-1107,584,365,2402,1756,270,1128,-1214,-1442,355,214,-1892,-1867,12,1001,-1119,698,110,967,-1476,-530,1159,301,339,-78,1283,851,1694}
     },
     {
      0,
      -815,
      {-14,-712,2267,314,136,455,-1170,3227,742,-8,-1015,680,-2160,101,108,-964,-924,-908,-43,-427,1005,1700,-316,-723,434,520,-1610,337,-1114,-377,-965,751}
     },
     {
      32,
      -1349,
      {1576,-1930,-1376,-384,164,928,1408,-265,1402,-1257,86,-2241,-1363,634,-726,-280,48,1578,-1304,719,1375,736,-2117,72,-201,-912,527,88,-246,368,123,292}
     },
     {
      64,
      838,
      {-696,-2061,-1249,786,-216,-1090,-2702,-354,-462,408,-1770,-441,-859,-530,-2849,355,-2517,687,-4285,901,380,219,1197,2039,1085,-531,2072,-850,-3075,1004,-98,-2566}
     },
     {
      96,
      4687,
      {-347,-1852,-781,1298,-1371,409,1196,74,-1150,-786,-1955,1063,-612,1391,-1797,-1679,979,-295,-2429,-2062,-2566,-93,-765,-494,-607,-1679,-175,981,-246,-522,1809,1403}
     },
     {
      0,
      -907,
      {1459,-177,-843,2768,415,-437,-1550,144,450,-2061,1175,1169,4020,1436,2828,-645,840,1004,-961,-747,-3650,-1600,1014,-55,1396,-1043,-493,363,518,-438,-2557,181}
     },
     {
      32,
      180,
      {-222,-274,596,674,-19,-1844,-889,-493,-555,-1647,533,368,-1851,61,499,-1868,-659,-2288,-1048,-1080,159,1181,-258,1461,-834,-732,715,300,2178,1140,-629,558}
     },
     {
      64,
      -579,
      {642,764,511,351,-806,1197,-408,-669,1361,862,225,397,733,524,2469,-1609,520,-1150,169,-3669,972,-2111,-942,-1073,-2418,-1274,-482,707,1855,-554,-1151,-832}
     },
     {
      96,
      4371,
      {-838,922,-1122,479,-1294,-332,-1353,551,-250,677,-2515,-124,2631,-170,-596,-950,-497,-1155,419,-3553,-1542,-206,530,-1084,-456,-509,-463,372,-1595,-1360,-899,-73}
     },
     {
      0,
      1347,
      {-279,-1237,-1403,382,-710,-418,1804,807,-1566,-636,-468,-1539,2787,-1451,-847,-99,-209,473,-1050,377,1517,-773,-1929,721,17,-208,-1431,-256,-653,-71,218,100}
     },
     {
      32,
      1882,
      {-1613,-1273,-939,-14,-1669,-4207,-2998,262,2254,256,632,724,411,714,376,-754,718,-560,-605,-3198,-832,-536,-116,1114,-467,-698,-40,1872,1531,-1978,-2690,700}
     },
     {
      64,
      -519,
      {-1861,131,372,-508,-526,99,2592,-764,-277,-1219,1010,-200,822,-264,1269,1257,616,-584,-1929,-541,-894,398,205,1378,177,-2179,-1898,-544,323,-87,136,-982}
     },
     {
      96,
      52,
      {-1166,306,60,-1664,-533,-844,-1839,-2605,36,-1158,708,220,1489,-288,-218,136,1034,-256,289,2273,-1004,360,-119,1355,109,-15,598,-955,1011,1339,-2264,-20}
     },
     {
      0,
      -1058,
      {512,-448,-628,-284,-1306,-2740,1532,-806,-1933,51,270,832,2502,1833,1491,-803,256,-5,1341,1452,233,-3337,1642,-48,396,138,-210,1164,325,294,428,1133}
     },
     {
      32,
      -1156,
      {-621,-520,-687,-793,1187,-82,-139,-204,306,-1604,286,-436,2135,24,408,282,-315,-447,-1280,1515,772,-762,-1008,-45,891,328,-425,-370,1133,-526,476,-596}
     },
     {
      64,
      -2117,
      {-986,-58,67,-406,1921,3443,-519,-479,388,-94,-772,3178,4828,106,-553,305,1378,873,2442,67,961,-1225,-472,-260,552,971,399,-1670,481,-306,-1500,906}
     },
     {
      96,
      -2377,
      {-347,1937,354,612,1754,-1005,-366,-966,90,456,37,686,843,597,379,1237,-331,-2082,1752,-1931,2022,-346,508,445,538,-500,-791,735,368,-1980,19,-1044}
     },
     {
      0,
      -666,
      {128,375,-363,-4495,2309,795,-723,-1554,-851,539,-132,382,-1791,-1574,873,1107,1262,-438,1660,1795,8,12,652,1500,-1314,-11,768,-58,-472,1138,-1839,-1578}
     },
     {
      32,
      -566,
      {1697,816,447,291,-1527,-78,122,570,1078,1505,-119,148,-113,869,1795,-1335,563,-1719,585,-3105,410,195,1015,379,-1798,414,-818,995,-2154,456,-1647,-1272}
     },
     {
      64,
      -414,
      {-1840,-290,-316,-892,-1411,1898,3346,-2068,-1120,-978,-738,395,2339,572,1176,-1436,-1932,-1634,-1629,1713,690,448,-441,-1395,-653,79,-1000,-4083,-143,-404,1142,-797}
     },
     {
      96,
      4312,
      {-1271,63,-50,285,-17,-555,-981,-1226,3,702,-112,943,1455,-2894,-1077,-550,-510,-98,-505,-729,-1827,845,724,239,934,-47,-403,36,-360,-1394,-208,380}
     },
     {
      0,
      -1338,
      {1288,361,1696,-785,651,-95,244,-961,-125,979,654,-1012,2271,-2700,-59,398,959,-561,725,-245,-879,1221,-2328,-1210,1934,64,-126,-391,-956,-712,-1088,-1723}
     },
     {
      32,
      -1634,
      {-1032,136,1865,-480,321,-2896,383,17,1414,-188,74,-167,411,-1276,1041,-1420,379,-1117,1728,1123,-76,-1313,-369,-438,1141,175,1752,538,1027,1416,1873,-118}
     },
     {
      64,
      -762,
      {-2216,372,266,2244,138,-84,26,242,1557,-531,1047,1078,-532,-492,-1263,357,-2613,-342,-711,-515,217,320,1413,-3321,713,47,110,641,945,-114,2323,1414}
     },
     {
      96,
      -877,
      {-147,-270,-1211,-680,2835,1281,-913,-21,-1896,262,483,-2319,-3520,1704,-1159,-566,1936,1004,606,666,1403,928,826,-466,-1028,302,619,-1164,-641,-1114,1083,209}
     },
     {
      0,
      -616,
      {-129,223,-1076,-677,1748,170,1529,64,1341,-105,166,-1257,822,-888,1174,-1245,-1505,-886,763,545,1045,613,1044,647,-545,37,-469,-1225,-1110,-142,1108,-1184}
     },
     {
      32,
      -803,
      {130,-71,-1790,1143,-747,-393,-127,405,-657,404,524,176,1566,-776,-1100,1918,126,1883,173,2058,-454,161,183,-364,-1846,-509,-117,-269,1639,349,-346,1143}
     },
     {
      64,
      867,
      {-1708,-1207,-892,-2096,-440,355,964,-1121,-1563,-1210,-1224,-1645,249,-600,1109,513,2022,57,54,1682,2612,-1231,372,-655,442,-221,-1714,486,1518,-1112,-2126,-1189}
     },
     {
      96,
      1635,
      {-1283,902,97,-2387,-1887,-985,-168,-1781,-389,-1631,747,560,754,-104,-128,64,1500,-1363,-384,1350,-670,1527,-721,1983,493,-698,32,-1139,-221,1354,-1608,1199}
     },
     {
      0,
      -621,
      {958,-128,326,-1429,1877,-221,-215,-399,-1547,-2500,-184,-1314,-1613,1165,1270,-5,-1775,243,-1188,-3232,1602,-598,2066,2106,-1429,1603,1197,-1344,-483,717,516,-1134}
     },
     {
      32,
      474,
      {-15,-2059,-679,1165,2556,1269,-612,-894,-2484,-2024,-1152,1945,-553,-1848,-578,226,-2242,-1448,454,2505,783,-1103,491,477,482,541,1585,818,-2104,-810,360,1820}
     },
     {
      64,
      -1213,
      {1221,-812,-388,577,-1102,3250,-1170,-1478,148,-498,833,-929,2332,-214,818,-4106,348,241,-3781,979,-1452,687,117,-593,322,532,846,-230,-388,-8,-1089,15}
     },
     {
      96,
      -3992,
      {510,1040,431,699,-284,-329,138,1406,1421,420,-164,1313,-554,329,505,-461,-1359,-1070,-797,24,-690,-992,722,828,575,434,116,537,-377,267,-196,1437}
     },
     {
      0,
      -996,
      {-1264,-1168,876,848,-1049,1086,-2764,-139,476,784,-1125,982,-431,2460,-747,1216,-1350,-1136,836,-2113,-853,182,-405,61,-2583,979,1631,-3624,1600,339,1008,602}
     },
     {
      32,
      -35,
      {233,315,460,1362,625,-560,625,-569,-903,583,82,672,-1137,-151,2147,-1282,-315,-90,-270,683,-105,-421,-1188,495,-1064,-594,164,50,-490,-647,-211,673}
     },
     {
      64,
      -129,
      {868,1391,-724,117,634,-249,-358,633,-28,1477,-479,495,-1142,722,-1632,-909,-1200,207,144,-53,-842,-913,-571,-132,-2285,424,-773,-281,-491,-497,-195,1196}
     },
     {
      96,
      1149,
      {246,-178,541,-914,269,-149,580,-838,-157,-127,403,-690,-932,329,-1089,-366,514,373,-2914,-157,-357,1363,-760,-1090,-85,-43,434,-994,-924,-539,843,-531}
     },
     {
      0,
      1589,
      {881,173,-2950,-790,-1537,-675,364,2777,-1444,-386,1563,-582,-1723,1562,-2268,-1342,460,-1762,-1980,-246,82,-1306,189,993,-303,-1688,1795,1856,-710,-98,-2696,-1061}
     },
     {
      32,
      -169,
      {-2169,-746,-341,449,949,-1582,927,-1105,-2357,-52,-1038,51,-2740,752,-1529,382,-33,-1286,-556,-243,782,915,-521,712,-1428,303,310,-662,4338,-729,1495,42}
     },
     {
      64,
      1362,
      {-838,-325,-505,765,-82,-2095,-961,-764,541,-1045,-1496,-1292,-782,-2282,-1174,352,950,-165,1136,1225,463,-51,-534,858,1656,30,1262,-267,-2393,-537,-1470,373}
     },
     {
      96,
      -279,
      {412,2189,563,2364,131,-423,-1425,-1594,-976,1154,37,1198,14,-801,-220,-864,1137,-743,-414,-2367,1269,1286,-826,-88,13,-148,205,2043,-1112,-838,-914,-1575}
     },
     {
      0,
      854,
      {16,378,-325,81,812,915,-1233,609,-1049,-789,-210,-179,-2452,-2991,1207,-1559,1640,-370,267,2426,145,1435,-650,-3051,-2507,368,-425,-1651,-378,361,-233,299}
     },
     {
      32,
      15,
      {-1016,818,157,498,1347,-1400,-699,418,-10,-1159,-1536,-2067,-362,861,1134,746,652,-1762,893,-315,-448,-775,-404,-1761,-2087,-577,-1469,-1891,-3154,-2783,-737,-2427}
     },
     {
      64,
      -1128,
      {-432,-1635,-1915,994,836,-171,-2840,-515,-582,1482,-1397,-679,-183,2385,-2000,676,2887,-1389,-3275,-15,-282,1497,-802,531,-1791,-349,261,-2077,-1960,-568,-228,1439}
     },
     {
      96,
      -2736,
      {1260,-1213,685,2026,373,-779,-422,1202,-358,-722,-151,2047,-226,202,-128,-506,329,-97,-574,-987,-211,-1040,245,222,-1013,-205,-173,1343,636,631,-153,370}
     },
     {
      0,
      1149,
      {3099,-767,10,-134,-997,389,887,417,-1125,-531,1762,945,-158,-1375,-395,1194,509,2102,814,-847,599,-3010,1672,2483,-1411,622,-1540,-1028,-3114,644,-261,-1444}
     },
     {
      32,
      -944,
      {1107,-601,528,-509,1184,1023,-78,-48,509,1561,-1405,-435,390,-900,-1557,-1479,-1913,446,-1120,835,-442,934,-941,-1004,88,966,2445,433,1204,2917,1422,197}
     },
     {
      64,
      486,
      {-661,-960,-1509,447,360,-760,-1832,-1853,35,-64,419,182,-78,391,-505,901,-23,375,706,-597,-333,571,-664,-67,-1135,1451,-1615,-256,647,-722,-1282,-951}
     },
     {
      96,
      840,
      {-691,-517,-560,-1001,649,731,-77,124,-97,-376,445,-1983,-8,193,-231,-309,-372,195,-49,785,-208,325,-288,-439,718,-560,-416,-176,1067,-227,-232,245}
     },
     {
      0,
      1380,
      {-88,-567,63,1013,261,47,1573,755,-391,58,-345,-1587,-1849,-164,245,-405,-338,1149,-416,-245,437,1215,1282,2669,909,-498,-574,-170,-2542,-1177,-679,-1502}
     },
     {
      32,
      855,
      {-2239,1383,-615,-55,-2065,-360,-1367,-313,619,1496,-73,-1297,514,1483,536,824,-358,1356,281,1129,740,-212,-1219,927,-1068,-3546,-1505,-1521,5361,-600,866,-1984}
     },
     {
      64,
      352,
      {-394,-780,-91,-2584,-290,-1381,63,-1229,-672,423,524,-707,-414,90,109,875,-1564,1380,-3077,860,-104,1287,341,131,-2201,313,-798,-685,744,376,-2827,-519}
     },
     {
      96,
      -981,
      {-1964,114,-590,198,-351,16,-546,-446,-1865,122,627,740,-2823,-1446,382,154,1095,-59,-19,142,-127,-948,1699,543,780,532,-956,-233,-209,2426,-756,1068}
     },
     {
      0,
      813,
      {-1462,-302,478,-164,-100,-1152,-152,-2368,-632,-994,311,698,-1308,930,-286,542,353,-2589,-2747,-1196,246,1713,-640,2316,2126,-1610,-1757,287,440,-644,-1039,799}
     },
     {
      32,
      342,
      {-528,-1118,1399,948,1236,103,-1439,-848,262,213,-418,1079,-710,-949,-303,-499,-732,794,1278,725,1930,-222,-2134,-108,1119,-983,-960,-1948,3375,-551,1701,-33}
     },
     {
      64,
      -777,
      {913,2837,239,435,-1351,114,1069,-569,359,970,-838,515,-400,284,519,-774,-2156,-1205,635,64,-1332,-79,985,-862,-1010,2600,-717,-161,71,1347,-178,352}
     },
     {
      96,
      -234,
      {-625,-2284,-2232,2363,2054,157,-1054,26,-584,-1005,-140,-2127,-1526,1368,381,-121,625,894,622,-2216,-499,-943,838,143,60,-1389,-2374,2741,188,1537,-887,-4}
     },
     {
      0,
      -1769,
      {15,335,199,-1334,943,-493,327,-1634,-1012,1553,71,-923,-825,-1766,832,666,-1047,561,-432,694,-293,-368,2459,1222,-25,1593,-782,175,498,-618,2336,772}
     },
     {
      32,
      484,
      {-35,-1851,-1152,-52,1331,-2523,-1149,-615,713,-2535,-95,308,280,-741,1377,199,-262,519,-1035,947,1279,-1148,-454,-885,507,-264,1813,-122,-3297,-572,-769,349}
     },
     {
      64,
      2032,
      {1008,602,165,525,764,-1024,-95,-577,-111,-521,-718,-234,-1502,132,9,-816,-1556,-474,959,-945,1121,205,854,1643,-1512,522,368,-1523,-1531,85,-1165,-109}
     },
     {
      96,
      2578,
      {572,-68,-928,714,626,-1554,704,-2473,-796,738,-1517,1156,1036,129,-1246,-258,1359,-1143,-1523,-4056,-2292,236,0,-73,-1984,-59,-106,-589,-1630,-2749,626,669}
     },
     {
      0,
      -1474,
      {355,-2609,515,2002,1164,1963,-1586,104,1144,93,494,-1657,2742,-1032,1635,-2034,-175,800,-344,-1251,1471,561,303,651,2958,-17,1804,1090,-1360,-465,811,1488}
     },
     {
      32,
      -3940,
      {96,144,-1737,406,1979,2130,1518,1738,-18,-2658,950,298,1708,3066,-963,640,-1322,-76,268,-1543,2921,-296,-2254,-327,1512,-712,2974,173,519,-729,102,-2153}
     },
     {
      64,
      8,
      {2853,124,1520,660,-1203,-1178,1365,-2035,159,1070,-1043,-1170,-377,-1498,-2711,358,829,-109,-1767,350,-1162,1369,-1152,-1636,4,414,134,-922,469,48,-678,-1729}
     },
     {
      96,
      -180,
      {-1447,75,648,-2037,-142,929,-1789,-1372,-2767,424,218,819,349,-784,-1025,-1056,3607,996,450,755,432,893,1122,310,179,935,205,-1266,431,-503,-858,966}
     },
     {
      0,
      1704,
      {-1281,-2018,1242,317,-1540,-1172,-485,1126,-87,-1879,892,193,-728,-129,-1973,-2269,-1990,-455,-912,313,-520,-246,464,2,-283,-17,628,1018,-118,-478,290,-622}
     },
     {
      32,
      1705,
      {-1139,393,1475,-578,652,-1334,-1901,-638,-1497,-1847,1799,1265,-187,-754,2275,-34,838,1065,5,-1343,-2166,327,1333,-266,-283,-2374,-2956,469,1942,-352,-2500,-959}
     },
     {
      64,
      1669,
      {1305,422,1426,-2010,3647,2105,-349,-682,1390,-344,-2370,-1502,2750,458,-385,-63,464,-659,454,-917,895,-662,-2084,-3,-685,-2592,-533,-1242,929,-209,1703,-3250}
     },
     {
      96,
      1528,
      {329,106,-724,-3113,-458,1045,1393,160,-425,-11,-1891,679,-790,754,850,-877,-1006,-589,-11,-2234,1695,2354,-434,-612,-498,-359,-1159,-2408,-774,-2004,-133,812}
     },
     {
      0,
      44,
      {-2382,-682,-722,1128,-862,-116,-83,281,170,508,-251,-475,1045,833,-379,-1685,588,-960,-1685,246,-2217,303,196,-3449,83,-547,265,225,1441,-273,928,853}
     },
     {
      32,
      -992,
      {-525,-956,-119,-860,-36,1346,272,-68,-2073,920,1503,453,-1161,308,2000,-869,1208,-75,708,-1100,2049,-336,935,-1330,-1656,1222,-466,-65,-943,-787,266,-1218}
     },
     {
      64,
      383,
      {-591,-1692,-434,-473,-1245,2222,1095,-744,-2629,-501,-811,-646,1288,-301,-1755,-2510,-1964,-644,-208,1155,-1003,-1659,-2169,-360,1879,-2936,1147,-118,-188,1181,-1002,1654}
     },
     {
      96,
      1482,
      {516,-1786,-1914,-393,1181,-763,-761,-340,-341,1028,-70,-172,2336,-1551,-1334,-1142,-1283,1065,255,2599,1059,815,-1086,-44,1117,-311,-2612,428,715,-2961,-637,91}
     },
     {
      0,
      257,
      {-1603,65,362,-1410,2036,-2217,1241,711,-434,-1158,744,-919,-246,-1324,-228,-1606,-331,94,-2282,-1537,2001,144,-991,359,665,41,214,-371,1279,-1575,619,-1}
     },
     {
      32,
      -1713,
      {-545,977,56,-813,-246,2774,-1000,-379,322,-407,-596,-940,1597,316,2743,-1610,1240,1308,-262,-1714,-19,-69,1872,-5,-938,456,-915,447,1129,1153,1548,-291}
     },
     {
      64,
      591,
      {-979,-356,-98,735,600,18,-213,-650,-1080,-2173,938,-720,93,967,684,-632,47,-844,-486,-1238,1535,719,1268,684,2781,487,-554,-685,1,-66,-3327,-2260}
     },
     {
      96,
      1874,
      {-1761,-469,328,-408,300,-657,-499,-864,-1887,-201,103,-1866,227,-200,374,446,1916,-549,316,608,-886,12,1701,1505,502,-303,195,14,-1843,-673,555,459}
     },
     {
      0,
      -1600,
      {355,-1257,297,-1133,-2335,-1850,467,-980,-105,-173,26,1734,-1018,1369,-58,1499,-855,-1605,1007,1823,157,-572,1633,-799,-1017,-990,1529,1971,2359,-1542,459,-2279}
     },
     {
      32,
      762,
      {-2270,-816,-2374,-86,284,-1885,-615,-1017,-2116,-969,425,168,1748,527,2341,890,514,58,-808,1002,1029,1015,-1003,-1037,-1972,-2336,-209,-180,1120,-473,-339,-2569}
     },
     {
      64,
      -1269,
      {-1801,-1217,110,568,173,1676,362,1232,-368,156,-1214,788,1282,-158,-516,15,1342,314,-1904,-137,-1644,-15,-1164,-741,1418,-938,367,2234,-848,-573,1356,1118}
     },
     {
      96,
      -2868,
      {1852,1298,-1145,2359,171,-325,-143,-29,2147,12,382,1012,-498,43,-77,259,-1443,-1100,-455,576,-707,227,250,265,-339,804,-316,1501,604,1112,-738,-1115}
     },
     {
      0,
      840,
      {457,221,-2027,2894,191,-1688,-861,622,-813,83,-1465,-1432,1675,171,-837,-1521,91,1391,-635,-585,1747,-420,373,3577,-152,610,-314,-531,-974,150,1831,-1563}
     },
     {
      32,
      -675,
      {-766,172,-43,91,3028,-323,-429,763,1762,-1732,-753,-1156,795,493,999,-127,-3974,-3759,-1524,2624,-396,-135,-121,1907,-331,-1172,1785,-317,-629,-1319,-864,-2224}
     },
     {
      64,
      792,
      {-1858,-92,-920,783,1126,1443,-179,-218,384,-774,1461,-2128,2032,-276,-38,-532,-798,726,1284,1527,-456,-1866,743,-347,-349,947,-270,1649,-1388,676,930,1544}
     },
     {
      96,
      2461,
      {-2162,-1738,-1440,722,-830,481,1909,1669,637,-1034,-1171,894,-326,-610,889,-739,-1316,167,-2391,-2422,-1309,-447,-1022,-343,1601,-2111,-891,795,-865,-701,1522,1481}
     },
     {
      0,
      -811,
      {-700,84,95,2014,-1487,1005,-38,690,-963,-172,1053,-1048,1053,491,319,26,-118,-454,-1546,617,343,-292,-644,437,403,-286,-1003,989,129,-640,222,-1024}
     },
     {
      32,
      -1371,
      {-1301,816,241,449,758,1517,668,254,1145,760,-2414,1057,399,483,2555,789,-186,-716,-656,974,410,-80,-199,-923,-2224,-2088,-1685,-1821,-411,469,1332,-3162}
     },
     {
      64,
      -1116,
      {-782,-611,-320,20,-1926,1883,-720,1262,149,384,192,-1193,1298,481,638,-946,-3730,-944,-250,1617,-2610,864,-2052,1014,1439,-203,635,-499,449,-285,-513,-596}
     },
     {
      96,
      2095,
      {-1049,3034,239,-1077,-566,930,-667,-176,1484,1146,1058,-6,-225,-1760,24,-758,-1700,-1301,-146,-1582,1735,861,334,126,1237,2214,1118,-584,-2962,739,-378,772}
     },
     {
      0,
      -256,
      {250,-882,768,688,154,503,1913,-69,-345,-65,557,-186,1451,721,-145,321,913,419,-771,-456,-305,-563,315,1467,-656,-1523,-1071,753,673,-913,366,5}
     },
     {
      32,
      -1486,
      {-896,-962,-84,2645,-885,-138,-184,-1289,-1745,-829,1542,440,668,-2354,-94,1689,281,-770,96,121,1790,-504,1155,-483,1253,387,-89,-1427,5047,-187,-407,1860}
     },
     {
      64,
      602,
      {-545,-2791,605,-81,-410,-303,-3343,1359,5,-1208,-1556,-944,14,502,-615,121,-1408,2268,1669,881,1060,-26,2827,160,-2209,1017,-673,-183,329,-2504,2374,-673}
     },
     {
      96,
      -2011,
      {-547,-875,0,290,-1875,1982,652,1301,-493,-928,682,-903,-3088,1880,-209,31,1385,292,-116,-142,-867,-599,-279,37,-916,-2417,510,-895,585,2272,1526,1351}
     },
     {
      0,
      1043,
      {1262,1420,-829,259,-1842,-1169,-540,1035,-1071,-844,-1010,595,-1975,-1141,-644,0,284,-879,-1675,821,-190,-429,-4345,-1900,-667,-41,215,289,-683,-238,199,647}
     },
     {
      32,
      -696,
      {-1037,1086,-112,-737,651,1141,-695,1004,-715,543,1516,265,2149,-670,1344,53,991,285,822,540,1139,-1497,-24,261,1297,-65,1330,-875,1792,-1152,-1601,-1619}
     },
     {
      64,
      -522,
      {1531,814,-1654,-557,-869,292,-621,-1299,45,646,-1402,-1168,-1666,-1344,531,-1439,-1270,1112,-116,2416,1971,-1183,-2568,1066,-31,1762,881,-333,-941,-857,-633,483}
     },
     {
      96,
      -419,
      {-703,849,-162,-15,-393,1554,1319,1235,-735,103,-201,-197,-2588,789,231,-307,811,-165,-456,152,-1977,637,-374,-600,-97,273,-79,-30,-556,1097,761,752}
     },
     {
      0,
      244,
      {-92,-2709,-613,1366,-2866,-240,1825,403,135,844,-776,57,924,642,581,-992,1563,1176,-421,-2043,-691,-959,2504,-2786,151,387,-2691,-296,-1006,549,-996,1359}
     },
     {
      32,
      -1130,
      {-267,-1156,661,-210,-402,-1336,1569,-123,2328,-631,-747,-2516,1993,-137,-1584,461,-1263,-1104,24,559,114,-239,-80,-2065,822,-98,723,786,1694,1830,1047,166}
     },
     {
      64,
      -601,
      {384,-287,-600,-2807,-598,367,-279,-99,-857,1507,-866,-1302,-1672,416,-298,1100,2465,2581,2601,-2352,2828,-490,-973,30,614,-1129,-1187,199,-2360,-1103,-2604,20}
     },
     {
      96,
      858,
      {-1053,-224,347,383,-809,-1209,399,1219,2110,2145,-729,-873,31,441,310,-223,-3892,192,509,217,-265,-1306,16,398,1767,-184,-302,-127,113,-2322,1796,503}
     },
     {
      0,
      -1567,
      {1714,-608,-531,2606,271,1519,1423,630,968,496,1360,-659,-456,-2522,963,90,452,-1472,372,291,-3244,-419,-1066,1521,-479,-2199,-141,1143,1304,-1905,363,19}
     },
     {
      32,
      -595,
      {582,606,528,-526,2389,603,1317,2141,1379,-2214,-528,600,-1615,270,-1883,-858,-1201,195,1086,-1093,1058,296,-1200,893,96,158,-2836,-501,-1470,31,154,350}
     },
     {
      64,
      -956,
      {844,-584,-1626,1583,-1046,1616,-828,-825,-62,323,-272,-725,592,-563,-522,430,667,1753,675,-2206,1563,-340,-330,-606,740,287,-954,375,-1689,424,-782,772}
     },
     {
      96,
      -2466,
      {-213,-201,-228,202,-847,-826,1768,1873,-2040,-2041,376,-291,-883,1829,1184,-631,2315,177,-2451,-851,-1406,-890,-1630,1171,-562,-911,-289,2167,-1277,2036,1286,1801}
     },
     {
      0,
      1882,
      {1290,-613,328,1117,-767,-1271,-893,1337,-196,-693,-1360,-41,-4076,-1873,16,-1968,911,-900,-1277,1337,554,179,-649,-117,-870,645,564,20,-1459,1378,1568,-1406}
     },
     {
      32,
      1405,
      {-271,293,-84,-53,-387,2915,-1525,-332,426,74,236,-1478,-1891,275,-32,-1551,671,162,-395,-321,-744,1961,694,18,-815,760,1315,-1076,1739,-237,14,465}
     },
     {
      64,
      -277,
      {1446,-235,-1058,-1076,960,2159,12,-1714,-469,-445,882,1585,1125,115,-1672,-1673,-2839,-2045,48,192,2481,178,-514,-668,94,-619,805,69,-178,741,-2025,-185}
     },
     {
      96,
      1752,
      {-625,-2840,-962,-467,-1836,1497,277,-722,1525,-340,-20,-56,1562,-809,191,-439,-549,1532,-990,-1059,1621,2503,-145,-361,-1061,-1918,843,-515,-1149,-1870,871,-71}
     },
     {
      0,
      -1661,
      {2807,574,528,971,-115,-505,-736,-168,-622,564,1014,214,-539,-954,373,-423,-157,-3673,1299,-225,427,-1488,1003,-1818,-459,-229,539,87,693,1611,-2208,-2871}
     },
     {
      32,
      -2020,
      {-896,206,1041,-1129,-253,779,-383,883,49,128,1231,202,-286,-675,1002,308,-666,502,564,-232,1342,1026,411,511,-605,47,656,998,-623,-619,712,-1329}
     },
     {
      64,
      -1710,
      {-1018,833,-757,-1489,1202,-644,1281,1793,1562,1165,-134,-905,287,476,1277,442,153,816,-25,-69,87,-1749,221,-1525,-389,-578,252,596,-520,160,691,837}
     },
     {
      96,
      -403,
      {-658,-414,-291,-1141,903,619,1034,1682,-796,-970,-167,735,-1398,151,452,-1321,995,-376,-653,-354,-89,895,117,-492,-1111,-357,603,-724,-810,1328,1304,658}
     },
     {
      0,
      -763,
      {533,1189,-746,1250,-771,-1085,-1585,360,283,-16,-601,220,-486,-450,-1005,-556,447,-1243,-1545,1746,-53,-1246,1402,-313,-561,763,1865,-4353,751,-220,425,-1314}
     },
     {
      32,
      -916,
      {-1710,729,-803,758,2654,-1048,-681,-2314,1477,-2114,211,475,874,-1742,1175,1924,-2100,655,71,1610,569,-2035,-3245,-678,629,392,1253,-255,1969,292,-369,2398}
     },
     {
      64,
      -2066,
      {1317,-909,1204,1352,-1042,705,340,685,-1565,625,1654,2358,961,-743,473,-144,163,-1298,2517,2348,340,87,-359,370,-201,-3701,-821,-237,31,-537,258,-692}
     },
     {
      96,
      -478,
      {-482,1462,-647,641,1168,622,-85,-1522,-25,-1502,-1239,1183,-67,-556,-551,-387,-394,-1108,-176,674,-328,1860,153,-631,703,931,-764,-255,-84,-306,-1904,-70}
     },
     {
      0,
      -82,
      {-373,810,860,-1448,-926,-522,-495,-597,719,-285,-1713,734,129,2863,-10,594,-3299,-1937,-1414,-1149,-860,-1141,-510,-2390,410,-104,-943,-709,1445,662,46,-1736}
     },
     {
      32,
      -1572,
      {505,-1951,460,38,132,1117,-1215,-80,1721,-228,-103,1355,-1264,-1235,-1016,-68,578,2506,760,-3708,2306,550,415,716,793,1728,338,629,989,3045,179,373}
     },
     {
      64,
      -1811,
      {-71,967,218,2000,153,-1870,-108,63,1000,-501,1705,996,2161,107,108,1129,-1721,-849,-1110,-1892,2324,445,205,-516,-931,-412,-1155,-1342,604,-1074,395,661}
     },
     {
      96,
      237,
      {-1,-1609,-566,-287,973,2301,-1227,113,177,338,-1349,-2,2278,-1136,-1231,-152,-609,2656,-250,-1514,-636,863,139,-412,461,-319,-862,-441,861,-1073,-1249,154}
     },
     {
      0,
      -843,
      {72,-1485,-736,55,-2150,569,825,379,-625,-905,1217,-67,2401,1207,-548,867,157,-1321,154,-1395,623,-44,429,483,847,-1000,-472,-1402,997,29,355,-97}
     },
     {
      32,
      875,
      {1626,1139,-1590,0,-998,31,-721,-1462,1166,-1421,-669,-2000,453,990,313,129,1027,2491,243,974,-1576,35,-1090,-3168,850,-2476,-348,222,2201,-623,-1161,-1714}
     },
     {
      64,
      -311,
      {-538,1822,-639,-826,23,1017,1408,681,74,-1196,-1286,-931,-488,-119,-703,1049,-478,-375,2020,-756,-588,-725,-586,-1087,66,-381,-937,2156,-1108,-923,381,-510}
     },
     {
      96,
      -396,
      {-924,6,511,1022,-383,-563,-4250,-2208,-458,449,560,1802,806,1177,-102,-1875,841,-639,301,-1999,-1948,1710,329,1132,1097,366,1054,40,-210,-316,-2036,-325}
     },
     {
      0,
      -3101,
      {580,1569,-411,1974,-696,-1790,-2051,962,1956,373,-933,992,-1122,746,-2730,-183,585,246,959,1285,-2653,-1505,-692,-671,-647,966,425,-670,1929,226,-1280,-1221}
     },
     {
      32,
      -3918,
      {545,126,364,2126,-395,1764,-801,673,-715,976,326,1430,2719,-878,950,1204,-1258,1386,721,985,172,1513,825,474,-782,-620,-863,588,-357,1278,86,1746}
     },
     {
      64,
      -1039,
      {508,502,-396,-763,1401,914,1547,522,-313,-832,1740,-3626,1477,-221,-678,-477,-3083,-1373,1439,-389,-32,-309,-279,-413,243,-267,-269,1945,1282,-313,-906,534}
     },
     {
      96,
      -3152,
      {1577,352,408,841,-264,342,1419,2484,478,131,884,-353,-1227,-598,-532,-1330,1833,301,6,-1471,-1209,788,-216,-1149,-1122,755,1053,437,-1815,-632,1959,1793}
     },
     {
      0,
      -2852,
      {636,1399,-510,237,2813,-624,-489,-2247,1980,92,-1005,1542,-195,481,-2761,711,-202,38,699,-437,759,-1254,1694,-2183,80,716,1869,853,178,1068,-243,-2713}
     },
     {
      32,
      716,
      {-1496,1376,-1181,1035,425,195,905,-159,-716,210,-1271,1015,80,-489,76,-2228,-509,-2033,-1218,-1384,104,-1508,-766,856,1610,55,1600,-164,-2444,190,969,96}
     },
     {
      64,
      -2158,
      {287,1370,-469,1198,438,145,-262,1386,-710,-1647,-58,-3114,649,1265,1471,-62,-441,-1474,933,18,-197,571,838,1252,-853,233,1500,7,-845,1109,296,1312}
     },
     {
      96,
      3271,
      {-532,-25,-578,-619,452,-475,1615,-1159,1040,-1290,-745,576,1258,140,164,901,-2595,-416,1152,1407,298,-401,-1705,108,-415,-1014,-935,-645,639,61,1121,-1402}
     },
     {
      0,
      756,
      {-3136,-34,651,-1264,-535,-954,-890,852,168,-1764,-1200,-1311,1144,645,-565,2312,-1118,-265,-2453,-113,416,-1860,-598,671,-749,21,-11,-278,-1559,486,-1351,-344}
     },
     {
      32,
      1503,
      {-1670,-846,65,-515,-628,-830,82,-104,-417,1163,88,-970,-480,-1244,-2201,-20,-987,529,-1207,-1636,19,779,-455,535,-761,1250,-3679,-266,-120,979,-636,251}
     },
     {
      64,
      337,
      {1576,-159,-930,289,-66,825,1025,885,515,2153,-176,-1141,-753,-333,371,-1421,-1938,44,-1082,-71,-2460,-1611,-462,-61,1658,-703,-638,2211,1196,537,-1596,-661}
     },
     {
      96,
      -818,
      {-358,-1638,379,-554,766,1241,-442,870,224,442,-263,-821,511,-355,-991,-511,-539,1590,858,2051,1592,-999,332,-850,487,-225,-214,-557,1162,1240,-643,257}
     },
     {
      0,
      2233,
      {-514,829,909,-703,-1157,198,-1684,-369,233,-607,-750,435,-1185,-1340,-604,-1226,-1251,-1056,376,57,-808,2031,-150,-3138,-904,357,-48,-1065,924,-900,-1413,472}
     },
     {
      32,
      -1526,
      {1060,-763,-218,869,134,-89,14,-465,-1374,-1221,515,2160,2170,-1121,-955,539,-2961,579,-968,-339,-955,1076,-105,-734,1006,1237,-69,914,-1254,829,-496,-677}
     },
     {
      64,
      -524,
      {457,476,321,-73,1525,-763,15,485,796,-188,1225,-1109,270,-290,-1437,-601,-754,-879,248,-1522,877,803,-2087,958,-740,159,-1147,563,139,203,-121,-1383}
     },
     {
      96,
      -278,
      {1798,-436,-1894,1688,-77,-469,67,646,-1576,1334,-1540,220,52,239,-435,-690,1855,329,507,-4403,-1388,1150,711,-1825,-961,-727,-8,1805,-574,115,791,-858}
     },
     {
      0,
      218,
      {647,143,-694,691,1056,-3643,2785,-628,611,738,1376,-910,291,-206,588,-1002,-853,-174,633,-543,-1691,-720,780,996,-91,-737,-1563,-17,-1125,-1438,714,-986}
     },
     {
      32,
      386,
      {855,-699,-1059,-17,-160,-16,-674,407,-478,-652,-502,-1720,-364,858,1769,-1030,-480,217,-843,-1673,1598,-639,-629,-2156,182,779,462,-743,-447,1347,1334,-1160}
     },
     {
      64,
      -104,
      {1550,1731,164,100,390,48,395,916,742,1032,-392,805,-989,-959,-2016,-807,-1300,-1287,-225,-708,-387,-154,-367,540,-7,-583,-1015,493,-901,305,-347,-1049}
     },
     {
      96,
      936,
      {-408,-2140,-1283,-530,-381,140,385,2001,-657,408,270,-965,-1505,282,-189,-865,45,426,299,-1850,-1561,-1444,402,-703,-140,-1369,30,-179,1011,1424,1290,1034}
     },
     {
      0,
      728,
      {601,2372,1020,555,625,-1569,-611,-1656,35,36,1056,1047,-851,2332,-1518,424,-940,-405,20,1987,60,877,1798,-731,-993,248,-98,-285,-2117,1252,-1324,-1521}
     },
     {
      32,
      -601,
      {-1255,-691,-936,-1813,727,-435,-423,-130,761,-2194,986,-644,1152,-165,537,1279,-1036,-1457,-237,1199,769,-566,368,-298,-2695,494,1446,-620,220,-1032,-147,561}
     },
     {
      64,
      814,
      {-666,-643,344,-404,-902,-1127,-1008,684,-1035,-1322,-164,761,-1421,-2187,1346,-5,-2255,58,-708,694,-2132,-278,390,300,474,1814,-731,1817,156,-1672,-332,-346}
     },
     {
      96,
      2167,
      {-1079,-259,1305,-815,-1405,-581,320,-3904,-1065,1698,1255,-1200,232,1768,291,-1047,-863,-61,245,2543,-56,-1824,-1008,3808,1318,648,601,116,986,126,-1403,314}
     },
     {
      0,
      913,
      {-74,-2180,846,-300,-125,49,-1517,-326,924,1305,51,702,-763,-2653,-934,-1882,-953,-81,602,1846,-220,3250,639,325,-1927,168,-1650,-475,231,421,-410,615}
     },
     {
      32,
      1833,
      {709,-2032,485,-265,220,-2921,-515,-252,148,-925,-2683,227,650,6,-840,-263,-403,-650,-229,2424,-597,264,-1137,-452,798,125,1258,-1570,-1269,-114,-262,1688}
     },
     {
      64,
      -1574,
      {1210,700,-383,-321,1860,747,-798,117,-847,258,-892,1158,-368,-284,605,292,-1485,711,84,283,2043,-414,-624,1479,-791,1186,-1053,-479,184,-407,-968,-964}
     },
     {
      96,
      1207,
      {45,-114,868,806,-420,-1828,-774,-464,-1391,-728,-720,-715,1439,-601,1089,971,933,1066,-1046,-3077,-165,102,977,17,88,658,1128,-4,-1447,-1698,-949,457}
     },
     {
      0,
      -1422,
      {1317,599,-314,-32,387,-820,648,-1315,-1117,-1347,-879,900,659,668,362,-17,-1969,-1388,710,-381,942,-2047,1265,221,366,1776,-105,101,260,1454,-510,914}
     },
     {
      32,
      323,
      {-37,-1844,-392,345,-846,-1029,-806,-572,-2344,604,844,1595,1391,-437,-178,1539,396,485,1294,46,-2237,-1806,1060,12,1703,-366,-863,302,-1863,390,-586,665}
     },
     {
      64,
      -202,
      {1736,-582,-261,-614,-251,-237,370,353,931,324,955,-97,44,-1325,752,-159,-664,983,-866,-348,-2422,-494,-2415,2278,-525,1311,24,-44,1115,-53,1038,122}
     },
     {
      96,
      1596,
      {-1342,-2525,-1080,-1394,-1409,754,128,1958,778,-1007,357,-740,-1816,-527,-20,60,-664,1545,740,235,-156,-1912,590,1,157,-1217,-607,-303,912,2145,832,625}
     },
     {
      0,
      -223,
      {1709,279,1537,669,-377,-105,-1136,383,482,1238,-571,-370,-1759,631,207,710,752,1630,1784,-169,-1518,632,-1231,-2221,-189,987,522,-494,-1532,-870,-660,-248}
     },
     {
      32,
      583,
      {109,236,483,27,23,382,316,-224,-679,-630,463,11,-714,-1250,-793,666,-597,-1146,-1055,453,-653,439,-574,-1095,-575,802,822,996,-1127,-636,259,-88}
     },
     {
      64,
      -1446,
      {604,-1345,-1219,1023,525,330,576,-1245,57,1491,679,658,663,-405,-806,-791,-1082,204,400,1286,-777,-236,140,1013,-896,-851,814,433,-19,273,-618,357}
     },
     {
      96,
      519,
      {277,0,56,304,-547,-889,743,-1182,-842,217,143,351,-293,397,-1249,91,696,1071,673,1046,446,-1887,1034,-34,-747,665,178,-50,-1393,648,1833,-431}
     },
     {
      0,
      1443,
      {-965,-728,-698,-314,-1070,1306,-1648,-75,227,412,875,497,1391,-990,525,1368,1848,-600,335,246,344,-954,-890,937,134,-1025,858,-430,-428,-563,-2196,-758}
     },
     {
      32,
      -680,
      {-117,-279,105,-446,-279,76,246,-1339,-137,1215,-104,959,-229,-353,907,793,378,-39,252,-771,-406,1337,-81,200,-1514,1035,-151,1089,-353,65,-446,-521}
     },
     {
      64,
      1991,
      {932,213,2235,-1408,14,-530,-20,954,879,-1326,735,-441,1099,-364,531,-648,840,-232,1005,361,-1016,307,378,-131,-984,-1102,-1799,552,-584,-245,-456,1286}
     },
     {
      96,
      1726,
      {-595,-811,145,1318,-862,0,520,1197,-1309,258,-1398,-442,-1004,924,161,-671,-728,968,1197,-614,587,782,-775,-437,260,-453,-66,-1334,95,1537,76,413}
     },
     {
      0,
      1359,
      {1112,-1404,-199,-1550,-1389,-403,33,691,-169,-635,766,532,-1019,-909,57,578,-1483,-1582,-1334,741,-1560,-129,-891,187,217,-47,116,698,-2184,-1262,-371,659}
     },
     {
      32,
      1096,
      {723,-1274,-412,976,783,399,-845,-489,1014,-236,-409,71,-1922,885,-256,-961,1223,450,1698,-1597,-1078,-30,-46,1102,-36,774,-717,-1074,397,514,1028,930}
     },
     {
      64,
      2131,
      {-155,662,-237,-646,-249,-624,-1241,-136,-738,-824,132,658,565,-664,-562,-685,-2350,-316,144,-758,314,165,-339,580,1779,-1559,772,-1734,-1100,-399,-916,408}
     },
     {
      96,
      1532,
      {921,2505,-755,671,-1729,-1867,1527,154,1582,677,-135,-1192,840,-336,453,-289,-535,-260,-726,-30,1110,385,675,-934,-514,1182,998,-419,-771,-1769,-750,947}
     },
     {
      0,
      1087,
      {280,-728,-1056,-407,266,532,68,589,279,812,535,289,-1064,-1577,-483,-278,939,-333,-673,1402,-1644,164,339,-848,169,-1846,-302,-1142,-909,426,1146,-853}
     },
     {
      32,
      1800,
      {-682,-156,-856,1146,440,-197,-876,-1466,-327,-413,-559,-342,-710,-1058,-207,-842,-149,-165,61,1252,-581,-718,-437,-135,767,-493,-336,-1011,669,1140,-60,224}
     },
     {
      64,
      1958,
      {-475,-1110,-1260,-879,-309,1910,-472,172,-497,299,-56,526,758,-778,-345,-501,-924,429,302,-222,139,484,970,-900,-176,-62,1343,1047,75,1397,-599,-208}
     },
     {
      96,
      2953,
      {-163,-326,-1039,664,824,55,-1412,-1415,332,-451,-431,-558,506,-515,-999,-1240,497,-650,-177,-151,-532,-192,137,1477,-1110,-503,-743,-59,150,-1035,-271,156}
     },
     {
      0,
      -216,
      {-578,-759,-690,454,-1001,1856,-216,-166,558,1699,-349,-466,-1162,1002,200,-1084,-719,265,-1365,1054,-543,621,282,-1663,79,-805,243,-558,72,1059,-1664,-603}
     },
     {
      32,
      324,
      {165,1398,1514,427,-934,1368,-388,-795,287,942,-1012,-52,230,462,-1837,273,-1675,-67,-294,-105,734,-21,88,973,-1105,-338,-1018,1202,86,-544,188,-1362}
     },
     {
      64,
      440,
      {23,-820,572,-278,352,-421,688,915,358,-1616,93,521,-257,244,-1154,67,67,122,339,2015,118,-1231,360,-1224,57,-382,881,1270,167,-750,-576,-1420}
     },
     {
      96,
      674,
      {-2249,-90,452,106,1237,-207,-2102,57,186,1414,-60,-1801,2689,1337,-1185,-691,-781,149,1824,-1372,-1051,366,-233,1455,175,-1242,281,-1162,1426,-3449,294,-217}
     },
     {
      0,
      286,
      {-876,537,-1146,-288,-1228,415,-616,-126,468,-951,-1870,-1036,744,2749,430,-1042,720,-618,1040,-1277,-15,752,6,1643,-465,132,-862,-2153,299,731,-73,-1105}
     },
     {
      32,
      928,
      {-263,-599,424,373,-756,-554,90,-487,220,-330,-660,-845,296,-524,-2483,-213,215,-54,-503,491,-159,210,-79,-639,-173,311,-1038,-211,703,-158,-253,-115}
     },
     {
      64,
      2390,
      {-118,1037,2,-184,691,1390,85,-953,-1253,1021,97,452,372,-261,-1484,-904,92,766,875,-101,-180,-120,-2391,422,-395,362,-644,-331,-621,-408,95,-467}
     },
     {
      96,
      512,
      {-623,-591,-1114,-557,-1576,-303,722,196,106,140,977,148,-395,-1157,358,-757,-1218,-738,660,1502,539,817,-1758,-803,-2424,-475,301,179,842,1751,-978,687}
     },
     {
      0,
      -1277,
      {196,1970,-202,1750,-1027,3777,1260,256,-827,-565,258,-1518,610,-379,1555,191,879,-566,602,-378,1018,1225,641,-1688,1554,-143,1479,92,-743,-1183,-648,906}
     },
     {
      32,
      349,
      {284,916,200,-273,-293,-401,-782,741,710,-189,-322,-99,118,-1347,689,1657,907,985,90,-1359,-422,-981,-96,368,321,-78,-962,196,762,459,-1356,-454}
     },
     {
      64,
      2452,
      {200,-491,-155,-341,-1105,984,-563,129,364,748,52,-20,-907,61,-432,-491,-911,-631,525,994,-313,-41,-285,465,-1131,-1607,-1118,-133,-925,1737,-1420,-286}
     },
     {
      96,
      2077,
      {-351,-1720,1339,1941,45,-923,-1668,-1212,-1025,2291,1528,547,-2392,65,-64,-669,-1020,965,-2448,1545,348,1133,-292,745,-286,907,223,421,-1055,188,-1518,1503}
     },
     {
      0,
      706,
      {-770,1368,485,15,-76,-397,200,288,1078,-221,-175,-206,-1053,357,-390,689,582,2258,-1220,36,1924,1154,-6,17,685,-833,-1281,-999,-793,1060,1440,125}
     },
     {
      32,
      516,
      {-532,-791,-347,87,-1584,-397,-1094,-2277,98,-944,-261,-24,119,413,589,-948,-658,-306,157,-674,-958,730,-505,-902,643,743,-185,-551,1312,-1029,-885,223}
     },
     {
      64,
      465,
      {404,135,-509,-740,1018,-220,147,-282,-284,-571,427,-194,1190,983,-801,-289,-946,-340,1154,-146,360,-64,359,-320,647,-1217,172,347,-225,-52,53,264}
     },
     {
      96,
      1936,
      {-268,-12,-1852,-1182,-320,-27,-72,1578,-476,-1625,-940,883,-61,-782,805,-1558,702,-2366,-1529,2724,-119,-1382,3606,-722,-1075,-459,-1617,-823,-1306,-65,2601,1999}
     },
     {
      0,
      2808,
      {1448,1126,671,-59,1372,942,1257,615,-1530,-844,1059,-1068,1687,40,378,1318,141,-129,-1175,1380,1185,1882,-339,1186,-728,-771,-534,-2940,-822,-51,1165,2339}
     },
     {
      32,
      140,
      {-251,274,-207,35,-680,-297,-307,-600,8,-162,-425,-321,156,-196,540,-218,-224,9,98,-488,-24,54,-105,-202,110,-431,172,-78,609,-144,89,-99}
     },
     {
      64,
      -1662,
      {-573,58,134,-247,795,1870,446,-676,550,385,1077,536,2490,284,17,-1036,678,-575,948,411,-618,-1258,799,1151,709,2010,-220,-1242,-1063,1183,18,916}
     },
     {
      96,
      2766,
      {567,509,-1319,656,641,-1565,227,-1025,-466,-760,-3782,-280,1844,316,-1190,422,1527,726,330,-2644,1243,-623,368,-594,-730,-971,-618,-260,365,-2439,541,-1091}
     },
     {
      0,
      2332,
      {408,63,-973,143,-418,227,-327,-386,-230,-587,1331,-891,-2420,1608,267,-446,-557,732,-316,-2050,358,590,401,1305,75,814,-1238,-1590,84,831,565,-909}
     },
     {
      32,
      1036,
      {-806,-149,-434,465,-117,-466,-126,16,-592,504,-6,-555,624,-701,-673,-883,497,-688,-187,-427,327,784,-904,597,-185,259,-587,17,-250,198,802,-49}
     },
     {
      64,
      -1030,
      {474,-97,225,528,1546,87,222,-409,1010,1174,1949,488,919,78,-1740,-63,1668,-1544,-1275,-788,-473,-532,452,1135,-990,1732,538,670,-391,-594,53,-1525}
     },
     {
      96,
      1102,
      {605,-641,-625,-1317,1015,-728,-1236,-578,-771,2391,1486,-665,726,-248,-1277,-454,-438,-491,-139,156,-1579,-83,1507,-823,-385,-49,-694,-1257,422,-1131,112,219}
     },
     {
      0,
      38,
      {-649,331,183,354,-305,708,-88,-526,-612,479,-226,-1044,168,-1624,145,851,-573,-157,-622,-1438,-21,155,-158,-83,-688,-1188,-1101,-1282,-48,887,351,-843}
     },
     {
      32,
      -960,
      {-355,775,367,-333,-1094,415,774,1498,759,671,938,-177,1900,-993,-1639,-4,524,989,490,1283,85,550,644,562,503,127,651,1306,1028,-4,1112,-241}
     },
     {
      64,
      -1307,
      {-1023,605,-39,11,436,2223,152,108,836,452,435,1089,1301,62,-419,389,605,872,-211,709,-341,198,336,788,-95,175,-130,375,571,662,842,1261}
     },
     {
      96,
      1060,
      {990,357,-808,-1089,-1242,-183,-1239,-2826,1349,377,-101,-28,-990,-429,-9,-947,-98,-1285,413,-724,827,1009,804,2959,60,459,-1277,89,157,-3174,432,-197}
     },
     {
      0,
      69,
      {687,-446,-244,821,179,-1347,286,-669,-74,270,-534,1002,141,-2819,-214,-275,-131,309,17,-267,-197,912,-488,901,661,1574,-435,167,-440,-1537,805,-1213}
     },
     {
      32,
      -1449,
      {547,245,-434,473,-438,1079,175,228,48,898,488,-285,-1522,203,-409,1272,-535,-337,754,1150,444,-257,-1139,-715,210,537,79,-861,-368,1069,168,-224}
     },
     {
      64,
      -4,
      {-1088,-257,1660,509,600,-677,-164,-1884,-675,-994,-1085,-282,136,-471,2042,176,-1439,-291,-1328,-1370,-88,1287,1250,1461,2342,-639,-417,1333,-31,970,798,1308}
     },
     {
      96,
      -1800,
      {313,1160,-753,928,97,593,-1607,-1750,-851,-2041,2635,1327,-406,-1737,276,-622,37,603,-227,3266,4548,834,1224,299,243,62,-1008,1541,-916,269,-601,1529}
     },
     {
      0,
      771,
      {-448,-887,24,121,-1824,851,-445,277,-671,94,-1456,-420,323,144,649,501,-251,-42,-446,-214,60,-976,526,-1127,-10,-1444,893,-104,455,-1152,-1366,-1007}
     },
     {
      32,
      -353,
      {1313,768,-672,774,-482,-686,-14,-440,-499,725,453,-1194,-643,467,-3356,558,247,350,749,1773,-398,-464,33,191,-858,1808,-166,-774,-495,-86,325,-490}
     },
     {
      64,
      529,
      {1124,866,-80,-415,-216,1194,935,-601,212,1122,600,1842,838,816,87,-371,-817,-249,-1042,690,-614,-550,-159,-660,-195,-165,-326,-603,-210,42,-524,1490}
     },
     {
      96,
      853,
      {-1723,744,2086,1820,-1389,1327,2399,-1512,-736,-412,1822,399,-811,1272,-637,-121,-133,-2363,1011,1922,-506,451,731,-2285,-259,-954,-1421,2419,-1686,1980,834,1070}
     },
     {
      0,
      168,
      {-450,-495,323,-114,-1062,333,-130,244,-484,207,-172,-500,185,-57,405,403,-795,178,-568,-121,393,-716,291,-306,97,-988,551,-205,399,-1070,-767,380}
     },
     {
      32,
      395,
      {296,303,306,-765,700,217,-15,-710,93,-158,-803,-232,-565,-140,608,-222,147,92,-849,-328,-16,-133,-124,-1108,-547,11,292,-784,-9,104,-1061,684}
     },
     {
      64,
      91,
      {456,1196,-275,-170,51,-512,75,-296,451,-113,-261,349,1359,168,-460,-845,254,73,532,-251,364,31,-32,151,46,1251,-796,332,-174,-848,-653,1511}
     },
     {
      96,
      85,
      {598,343,3063,-1095,88,-3108,-1110,301,1039,1325,1950,-238,-2609,-619,1384,-988,-673,1038,-334,2419,1516,-1459,3,-625,1305,2397,298,-1001,1672,172,-632,-1571}
     },
     {
      0,
      679,
      {-496,-719,-33,-387,101,-1153,-870,548,-786,-381,258,767,424,-169,-527,347,-343,66,909,-1302,-112,1009,650,1159,-158,848,284,444,-656,-2172,256,736}
     },
     {
      32,
      1174,
      {-990,-584,6,687,1938,-1642,-127,-449,-828,-161,34,-365,-2212,-1214,1787,-298,-718,-203,-665,-469,-247,881,-955,771,-625,-9,1630,-1241,-766,250,-998,1063}
     },
     {
      64,
      -204,
      {-331,1357,136,319,197,461,737,-102,19,134,565,510,491,22,-44,-627,979,916,-176,470,-344,78,54,-271,-185,565,-223,-982,154,92,151,-393}
     },
     {
      96,
      -1166,
      {1524,1490,330,-21,-766,611,-1756,2482,662,-738,1133,1355,-654,-1155,1195,-777,-727,118,-1387,1332,160,46,1371,-2136,334,-196,1148,-205,-1111,735,-209,1309}
     },
     {
      0,
      1343,
      {-618,-409,415,119,-1241,936,-34,198,-976,-1045,1126,-498,-344,561,1029,877,681,-425,-176,-23,-708,-153,177,615,892,1155,790,-673,-38,-2039,-1751,-492}
     },
     {
      32,
      -199,
      {385,-244,44,-505,185,536,246,-519,-63,-204,225,858,-502,157,1153,580,119,137,370,-1863,-91,-20,194,-426,-220,147,-72,-339,-463,509,-591,93}
     },
     {
      64,
      -351,
      {666,280,54,-159,477,-513,826,-660,-11,-1176,-235,871,1585,1319,197,265,-86,542,31,755,-7,-570,-150,-1278,-318,-1518,-638,810,-1211,-1342,421,-648}
     },
     {
      96,
      561,
      {-910,-474,-1143,140,336,-823,799,134,849,1216,-634,-413,-38,1415,-210,-105,-1043,247,-588,2025,-1131,121,-324,-1357,186,1612,-378,813,455,2097,-281,-2097}
     },
     {
      0,
      1266,
      {-577,-1158,57,-706,609,1125,288,-559,-1224,306,817,-872,-1190,-782,-292,357,803,770,-28,720,195,788,-1748,742,788,-797,-114,272,119,-1757,-563,783}
     },
     {
      32,
      273,
      {-101,441,-419,-569,459,-509,377,621,-217,253,-79,233,245,-143,312,-297,326,202,385,-2094,-343,-178,133,89,357,-658,-1378,-688,-78,821,172,129}
     },
     {
      64,
      -118,
      {-65,296,155,-443,-685,473,658,-422,-137,-594,-983,15,-203,781,-400,-154,-951,940,-62,102,-592,-381,670,-287,-683,-481,-460,810,-189,3,-469,-49}
     },
     {
      96,
      1254,
      {911,1,1515,-1019,-738,993,-1508,1776,100,-99,1311,-173,-322,5,-644,-1057,-2353,815,177,454,377,-25,-428,529,-257,-802,944,-1069,-974,2569,-1342,2490}
     },
     {
      0,
      131,
      {386,-423,122,-623,302,-1484,374,135,-146,-220,1123,503,-1332,-1944,-488,-1174,-1445,-112,-820,502,743,332,0,1845,-310,705,-39,-1889,46,-399,618,557}
     },
     {
      32,
      109,
      {-964,43,701,1005,30,-910,288,296,-890,584,1480,1001,1640,-415,872,1132,-237,-320,-1715,-982,-903,-991,205,-910,332,-1015,30,117,-600,-495,310,-1883}
     },
     {
      64,
      283,
      {-555,-322,-498,-56,-690,-897,-293,369,-676,-416,-870,-840,110,757,-537,183,-738,-796,1572,-691,-471,40,-232,717,-192,-879,-392,169,0,-128,-44,-253}
     },
     {
      96,
      647,
      {133,1687,1272,662,572,-313,-1,-972,124,1611,-15,526,-3463,-1087,1257,333,-2255,913,-1566,475,65,302,-60,-202,529,3047,1073,1439,-886,-1342,754,766}
     },
     {
      0,
      1176,
      {243,-312,-242,644,-390,1902,538,633,-877,-879,1788,-1274,1216,1960,1398,679,-608,-90,-532,-932,180,215,1480,1375,998,-446,190,-809,-1152,-2428,-275,116}
     },
     {
      32,
      319,
      {846,-154,-445,-400,37,-634,133,238,-468,-521,-579,-716,12,184,-484,-361,-68,-127,41,127,-319,-439,-350,-631,-126,-599,279,-1258,-381,15,1436,376}
     },
     {
      64,
      1228,
      {-585,722,-141,-573,425,2128,913,-1071,120,-1949,199,798,910,-920,769,215,-598,-1024,754,347,-1045,-149,48,363,396,-226,287,-1303,1978,-244,-1427,817}
     },
     {
      96,
      1009,
      {-135,290,129,1200,-494,-596,-893,13,922,547,-327,-624,127,700,225,-454,-2104,-471,842,777,1458,942,7,513,-2567,1126,727,-284,-146,-3804,-859,6}
     },
     {
      0,
      -217,
      {-762,538,-1069,-1262,286,642,656,308,605,234,268,480,-1071,-194,66,-1650,1886,1151,-873,1015,502,-88,-424,-93,-44,-744,-326,-1979,394,1744,-448,601}
     },
     {
      32,
      1077,
      {-612,-1013,-754,-282,-1705,-858,-453,-613,-668,-372,247,-694,80,841,1389,-898,-1579,-235,-388,-918,-769,643,-426,-809,454,-76,-242,760,-926,-1495,-511,-449}
     },
     {
      64,
      1601,
      {-633,-146,16,26,191,1323,-443,-990,-202,1521,46,-196,-155,-787,-365,425,762,-80,-402,-1436,602,-1074,287,-232,-208,1487,-301,-12,-214,603,567,-999}
     },
     {
      96,
      175,
      {-675,-64,1233,502,-1276,-423,-1147,541,-244,1016,2336,-340,-139,1472,-1624,143,-1842,1621,-1003,-267,-302,2484,-1147,-178,1730,-2197,840,2563,-1938,34,-863,-1795}
     },
     {
      0,
      -1047,
      {-691,590,69,-6,-487,545,181,117,633,690,-363,-302,982,-94,256,630,76,1166,608,785,426,-143,-732,62,-309,-399,203,994,-844,154,665,1467}
     },
     {
      32,
      138,
      {-359,165,-185,687,-109,142,278,-358,-136,181,-255,-213,245,-15,33,-805,135,353,-219,-176,-175,460,-439,113,437,-676,71,-53,175,160,-636,146}
     },
     {
      64,
      903,
      {819,290,212,-87,-93,-562,-779,726,-511,-842,-528,-379,713,-613,578,68,712,-51,271,689,-102,1254,170,-257,-893,-1816,1107,294,-287,-188,903,91}
     },
     {
      96,
      -403,
      {881,43,-779,-767,599,-147,681,-297,1346,-1394,980,-1879,-134,829,-2478,-86,1073,976,-503,955,-689,1804,-126,1944,-152,-4,-1428,562,910,567,568,1556}
     },
     {
      0,
      -1191,
      {-545,646,328,-189,-804,1121,551,27,864,-120,-803,-450,185,1004,290,339,383,59,-120,-106,611,-596,-180,-577,-711,708,637,289,347,592,-482,1235}
     },
     {
      32,
      -230,
      {354,107,-159,506,-95,25,70,206,331,75,178,148,-84,-20,-586,-183,104,-194,-119,273,16,-285,319,-14,165,-356,-153,427,-23,193,128,-979}
     },
     {
      64,
      -1865,
      {-220,398,603,524,-578,-599,581,-449,565,645,71,52,-416,213,673,373,-79,149,-661,-410,114,0,758,-302,115,-64,192,111,584,-36,289,796}
     },
     {
      96,
      -1088,
      {-989,675,152,-382,-1421,1469,318,1577,1223,-1514,-957,-32,784,483,917,670,-709,788,1074,-516,2829,300,-307,-2216,496,-559,-454,-1068,2220,312,-109,567}
     },
     {
      0,
      -219,
      {-440,532,-255,-99,176,160,-39,-423,-238,-107,775,323,-158,-482,437,-52,230,19,375,202,-700,131,11,122,-79,428,152,-246,-104,120,-25,105}
     },
     {
      32,
      134,
      {-755,447,407,302,51,307,452,785,-87,851,518,781,1514,261,-418,-1049,230,357,-195,-1070,77,-181,775,519,888,330,-642,492,190,711,-1522,-720}
     },
     {
      64,
      -127,
      {-6,776,-393,-122,103,367,342,-253,-175,-265,217,201,495,-168,-136,-423,-579,-79,365,-128,265,213,95,-111,84,141,284,28,251,51,115,322}
     },
     {
      96,
      -216,
      {134,418,1560,1300,-482,-1060,-1483,-2534,-1077,-1536,361,-99,878,439,153,2198,749,237,-879,-930,2138,628,-721,1764,-669,579,811,-77,138,1431,1589,-960}
     },
     {
      0,
      -324,
      {-190,-85,-148,-103,-33,190,108,-559,-345,-491,439,265,-55,-6,126,220,800,-426,-107,344,-128,508,-85,75,-431,329,-232,-164,55,576,-556,-41}
     },
     {
      32,
      34,
      {393,-256,-84,304,209,-119,26,-463,142,7,-94,-133,-278,10,99,460,-19,-38,107,288,154,-65,-274,-61,351,-372,-7,-47,85,217,63,-359}
     },
     {
      64,
      -1178,
      {13,147,539,219,-369,-191,457,-139,344,438,324,346,296,37,138,-113,41,373,-328,71,151,-126,579,-444,337,221,212,75,207,-49,268,399}
     },
     {
      96,
      -590,
      {-446,279,-617,-741,-480,2613,900,2209,58,1467,665,1382,-848,-2674,-1304,-109,-1496,112,-642,1420,22,-1513,-1332,187,-3181,161,566,698,433,-737,66,485}
     },
     {
      0,
      -136,
      {6,71,138,77,223,205,7,-70,27,-148,7,-93,28,161,-28,-15,6,94,95,170,64,75,-34,-152,151,17,58,-173,-36,-31,-151,4}
     },
     {
      32,
      -212,
      {318,286,-8,-525,17,47,58,450,105,164,298,449,593,8,-793,-507,112,275,173,107,-27,-86,666,-64,333,405,-277,83,221,170,-432,88}
     },
     {
      64,
      -748,
      {2,207,609,14,-396,100,-52,-168,244,-104,115,282,35,447,97,-147,125,105,-612,501,-46,111,360,-266,203,135,93,332,238,-138,-111,549}
     },
     {
      96,
      -1113,
      {-272,-563,-421,938,-1439,-1349,1104,658,725,851,710,-455,-1700,967,1966,-223,-688,-1734,525,570,934,438,1938,-406,561,497,-375,-499,-1201,185,251,577}
     },
     {
      0,
      -107,
      {-24,142,-20,-31,-87,-106,-117,-106,-214,-114,261,-186,93,26,-33,-53,287,-139,-273,76,-19,3,-39,47,-82,207,34,-71,32,-28,-360,28}
     },
     {
      32,
      -276,
      {103,359,-5,-303,108,139,100,336,16,388,255,547,589,117,-334,-536,237,411,103,-357,175,144,397,178,243,389,-167,278,140,230,-217,146}
     },
     {
      64,
      -1005,
      {-297,391,-132,82,112,322,458,-149,57,-382,209,279,-331,305,-286,-51,-194,148,-248,-158,145,-179,-162,82,-93,-244,-7,191,321,227,-75,249}
     },
     {
      96,
      1873,
      {432,-229,-400,-100,-408,-1814,717,-1465,-441,1089,-365,-566,1157,491,1693,-5,1154,-101,-76,-73,-2379,-608,736,-1131,1492,-915,-741,45,-1377,-528,-1231,375}
     },
     {
      0,
      -276,
      {-104,-187,12,218,306,190,164,-462,282,185,134,-65,22,186,55,210,384,329,396,126,52,263,101,-125,92,162,180,-334,264,204,-361,259}
     },
     {
      32,
      192,
      {46,82,-78,48,51,-78,-6,43,22,-19,10,131,-35,-94,-12,-36,173,168,21,95,-64,90,250,216,221,73,-82,131,46,157,231,-118}
     },
     {
      64,
      922,
      {-34,-329,380,172,-43,-198,-396,261,135,263,-287,-349,135,-270,348,230,-184,-26,17,241,-673,113,515,52,-106,-125,-11,-222,-70,-31,-53,-199}
     },
     {
      96,
      976,
      {-804,48,-887,66,-664,-28,-184,90,-624,-31,-419,-413,1246,-447,-122,202,-548,171,576,-477,-1202,-124,1545,868,118,409,30,45,-544,382,-658,489}
     },
     {
      0,
      -27,
      {35,-106,-7,102,273,48,44,-492,101,-68,296,-137,114,108,56,5,513,339,116,74,0,350,285,244,58,389,164,-173,289,80,-478,239}
     },
     {
      32,
      90,
      {80,16,-84,47,179,-22,161,166,116,4,15,190,-171,-191,122,30,198,-62,15,162,68,-252,135,12,206,-86,48,-32,-135,93,-128,-452}
     },
     {
      64,
      -460,
      {202,230,-190,-178,68,269,51,-217,-77,-279,204,123,95,154,-262,-91,-25,73,317,-348,239,-28,-200,-264,349,561,171,222,-49,-41,244,-16}
     },
     {
      96,
      368,
      {-446,800,-103,572,-2,-484,-135,42,621,626,-24,-575,515,63,541,-429,-947,127,143,-871,-199,-148,426,-196,419,17,472,-569,-264,304,546,781}
     },
     {
      0,
      23,
      {0,-25,-120,238,134,212,80,82,291,2,263,167,1,-70,0,-48,-110,175,322,115,-85,195,70,-26,1,168,132,149,158,364,-18,8}
     },
     {
      32,
      -15,
      {175,-34,29,-93,75,-104,48,153,25,68,32,102,135,27,-139,385,64,-61,-21,153,126,74,150,213,172,14,-42,-143,44,87,-27,-29}
     },
     {
      64,
      -91,
      {57,115,168,-66,140,121,-14,24,-50,162,4,76,151,-38,29,275,179,113,26,46,-135,43,-20,218,57,150,3,38,94,-86,-39,-23}
     },
     {
      96,
      352,
      {-21,-548,78,-408,-87,-649,-237,-273,-599,40,322,206,556,-445,38,83,133,85,287,-54,186,716,151,-178,130,-436,-32,554,446,847,226,610}
     },
     {
      0,
      38,
      {34,-70,16,37,49,131,66,66,-49,110,121,0,33,214,121,164,8,107,-128,118,157,170,23,77,95,-96,2,87,134,-24,145,95}
     },
     {
      32,
      -74,
      {48,139,0,78,71,113,89,-94,91,146,181,-64,102,46,132,0,45,-118,20,120,15,49,1,-8,30,32,-29,137,-63,-17,123,39}
     },
     {
      64,
      87,
      {7,111,137,117,-24,42,61,144,25,199,-41,140,158,81,180,74,-9,-55,-55,86,97,25,6,119,163,122,25,-63,28,52,193,11}
     },
     {
      96,
      3,
      {89,-81,238,29,-11,198,119,303,160,64,-39,-42,168,-50,32,171,14,-10,165,-38,28,90,66,92,95,-67,173,0,263,-104,9,44}
     },
// *********** Cells of layer 3 *********************************************

     {
      128,
      -890,
      {-1791,-3455,-3935,625,-3800,1745,-819,764,-518,334,-1345,837,-1221,1798,1375,-1108,1575,-1378,922,317,181,430,-1271,-561,313,227,300,90,-105,231,-1040,-330}
     },
     {
      132,
      -88,
      {-369,3000,1526,109,-1308,228,-100,-417,209,-461,1290,229,256,1420,-159,-643,-1237,164,-1812,-213,658,912,1437,-444,-52,855,-1392,-389,-966,-754,-1633,-592}
     },
     {
      136,
      -2942,
      {-954,3306,-75,161,-227,616,1489,-163,-111,1282,-986,95,-1449,-160,410,-526,31,561,1470,300,-1936,67,-3121,240,1083,-594,-707,533,923,-585,-1077,-106}
     },
     {
      140,
      316,
      {-2743,1038,4300,-2193,1003,-1595,1874,-1391,1236,-816,502,-505,-75,-1001,-903,184,-2108,-3299,-2065,-364,1056,809,394,-223,-253,-151,-387,740,1325,-813,283,-941}
     },
     {
      144,
      140,
      {-269,1145,380,202,-480,544,1029,-127,1219,654,747,255,-941,671,-1896,-332,749,-814,-1718,-48,-1484,17,-55,-944,-541,-923,-826,83,-982,833,-21,-731}
     },
     {
      148,
      1971,
      {-2194,-786,-2082,-1327,368,899,672,-3004,-400,979,-3363,-920,-2066,1991,-1194,-2356,-2157,184,-1060,-1406,-2160,-1947,-344,-1085,-1480,898,-79,2097,2290,622,323,-2244}
     },
     {
      152,
      -1003,
      {818,1704,-1117,-1025,1276,138,280,-1051,-928,-114,-1238,14,3881,-873,-1915,-122,-1119,309,-426,-1509,925,1846,-800,149,-4727,330,-255,-3,-748,1472,-2401,34}
     },
     {
      156,
      -2304,
      {424,1335,-838,24,-1816,1215,525,214,1023,1333,197,-332,-2000,-373,-711,-102,187,968,768,1306,76,-1553,-921,529,445,-261,585,210,-558,-712,-1801,-348}
     },
     {
      160,
      -383,
      {-201,628,-1290,486,-278,-1768,704,258,-682,487,-859,-105,-554,1259,1049,459,622,44,-1424,-325,-1318,-130,-964,-185,1448,-337,135,-599,-1070,-336,-1485,-52}
     },
     {
      164,
      -3669,
      {2611,-2475,-545,-29,-800,1996,364,-2373,158,1621,597,859,-11,2043,-2732,-2363,678,430,-3229,-2037,1650,1612,-373,177,1221,196,3002,1815,1280,-99,-2713,-933}
     },
     {
      168,
      -784,
      {-1020,-2619,-2023,-210,630,-55,-2628,1060,-399,-1172,-743,-29,479,-650,-2525,-395,1558,-1600,-643,-838,-60,-2430,925,228,375,-692,538,-348,1086,693,404,1325}
     },
     {
      172,
      -602,
      {-2235,945,1136,562,10,-102,707,-393,-850,-2195,473,-349,-1517,1260,-1055,-1460,-847,-350,-2319,718,-639,-257,-1372,-150,-117,704,848,-844,-107,-965,964,-33}
     },
     {
      176,
      -4004,
      {706,-957,1021,-33,154,-981,705,809,704,1398,-554,1069,667,1796,755,613,-121,-220,-1713,467,255,113,1401,-565,-5980,-2572,650,-871,-2207,-1492,1911,358}
     },
     {
      180,
      -530,
      {547,282,-809,495,-49,-137,-806,-415,-895,1209,94,-832,-180,-350,-170,153,-327,-1336,1216,624,-2753,-768,-1119,-407,-1113,275,1540,-282,-1143,-226,478,412}
     },
     {
      184,
      -2422,
      {538,-564,-397,-397,293,651,-1228,-1102,1202,999,-1451,716,-1036,-227,1557,1966,2041,-244,765,-837,-959,874,1681,-767,1322,622,394,79,-971,719,577,-501}
     },
     {
      188,
      -84,
      {-745,185,659,-340,867,316,-236,-1772,219,-648,2075,825,-1855,1444,-390,684,205,-498,956,-71,-920,-1570,824,-274,-3066,-156,172,723,309,-129,-2462,-2512}
     },
     {
      192,
      -30,
      {-226,1088,-1729,-1528,-926,586,-330,-2542,186,-735,-589,-506,-5910,-156,1603,-1654,1376,927,179,23,-1229,591,-1856,-96,519,1417,162,-126,625,-713,-819,-189}
     },
     {
      196,
      266,
      {-462,-219,97,-680,-1559,-2029,-427,-147,591,-497,-268,14,-519,759,705,223,-1220,-209,103,-24,-43,1602,802,21,1656,124,-1126,-214,-1087,546,-459,-630}
     },
     {
      200,
      -931,
      {-4187,784,1780,-308,-89,1411,-1012,-465,-1062,332,-782,477,-854,1817,943,244,-1709,161,609,649,-343,901,119,184,-83,1587,-442,-139,-1236,-1091,-1355,1189}
     },
     {
      204,
      -1029,
      {1939,-54,116,-386,1450,1184,823,955,-212,543,-4718,350,114,331,-1031,-775,127,-114,-3564,368,913,-65,-1384,-391,436,-3359,-1071,-346,-1664,1266,427,-825}
     },
     {
      208,
      -2442,
      {-832,-1735,622,397,-936,-991,2126,1323,637,251,-14,387,836,294,1269,926,-989,-526,-1443,580,928,1986,588,774,-756,416,-435,55,-1852,-106,-2167,-838}
     },
     {
      212,
      -1856,
      {-2624,-1705,4350,880,-109,1424,856,-589,2130,1152,324,518,-2433,1360,-1868,408,993,1097,950,-50,-416,1838,-238,-189,920,-2448,-3289,-770,-2661,505,-1156,260}
     },
     {
      216,
      -841,
      {-655,-1426,402,-504,421,-2242,487,722,559,213,-322,1397,556,-993,-734,504,-213,959,-1955,-4821,-2478,-980,-1607,186,-2239,-1093,-2361,435,825,1559,279,-252}
     },
     {
      220,
      49,
      {-59,-3309,-2020,-624,-775,-407,-796,-801,-641,1612,281,-492,-1183,1127,1750,-1346,779,3045,3057,-53,-3907,1853,-762,-640,-1388,63,-1835,-1202,-1670,-647,-2233,2545}
     },
     {
      224,
      1949,
      {-1303,131,-180,-1792,-1823,-485,-702,-1732,53,-993,465,1186,-2990,662,1982,-35,1088,461,-1934,51,82,1771,-78,-930,748,-2365,-1937,241,-2972,1989,-1343,-1587}
     },
     {
      228,
      -227,
      {-373,-1354,-3329,146,-246,106,1316,120,-238,119,-605,-508,141,-226,180,-427,-1031,924,-1471,-137,-707,786,1666,132,-726,-442,471,-1800,-1800,1202,2081,-333}
     },
     {
      232,
      259,
      {-200,2281,-4463,534,1483,-323,-319,-1570,-445,-3325,-96,-701,-602,-2063,-321,1100,-4724,-2568,819,2606,-2093,-1564,-2445,-687,-2728,1719,-892,-186,178,-1902,547,-469}
     },
     {
      236,
      -614,
      {-384,-65,1555,-862,671,44,-2279,-1820,558,637,2662,-619,-2076,2813,-2327,-556,-705,-1306,-928,215,-835,1676,-5030,-490,571,-3950,718,-3314,2177,1823,-3593,-1529}
     },
     {
      240,
      -1739,
      {-1338,429,-501,-768,2070,2017,-2466,-459,-1287,2307,-607,415,46,-4894,-2293,617,-1130,50,716,-1043,2240,-1032,-643,-1066,-562,-3498,-2140,273,-397,204,-687,298}
     },
     {
      244,
      -801,
      {839,-275,1023,-25,-1326,4919,1074,1133,-1899,-1072,776,-796,-4447,1504,-2944,358,-1099,-4304,1210,1094,-261,35,2239,-1158,2097,1095,-1492,-925,1351,-2329,-3439,-1423}
     },
     {
      248,
      -5644,
      {-3394,2515,-906,-772,-1267,-3568,-2707,-4249,1190,1203,2372,-2780,4487,2892,2247,-2247,1121,1974,-714,-250,1406,-3467,1260,-1219,-3255,-1626,41,188,1980,2153,-2318,-987}
     },
     {
      252,
      1737,
      {-1842,-2863,1066,-913,372,2042,-634,2144,826,25,1136,-812,-2450,-1447,1762,-1665,-4911,-2338,-143,-1172,-110,-890,-6793,-2381,111,210,-2243,-93,-1256,3291,-2216,3454}
     },
     {
      256,
      -1729,
      {-2286,1001,1164,1154,-100,2542,1601,-2056,3040,-33,-2467,-1456,-1380,-1264,-2823,-658,-3829,-1036,1847,-568,553,1373,-3901,216,-797,-1001,2254,-129,-3039,-3557,-768,-1194}
     },
     {
      260,
      -65,
      {-3869,-4554,1011,-837,339,-706,-1474,-848,-1120,159,7,-123,-2791,449,-461,627,-1561,-2715,98,-1267,-1531,2949,-1574,1196,-3197,-4206,-3680,-944,-1627,-1194,1449,3066}
     },
     {
      264,
      937,
      {603,-2527,1934,-383,-3796,-1191,689,-1350,2933,-1361,1647,-1306,-3419,-500,-62,-1505,-8,738,1417,-3617,-283,-2861,-1182,-1820,-3594,3572,-2983,-771,1767,1368,2865,-225}
     },
     {
      268,
      506,
      {-1556,378,-3165,-720,3760,-758,-1591,87,-2979,1801,-1340,-2290,1278,478,-1671,-169,1399,1063,-4087,-1747,-1199,1755,-622,-27,975,-3227,2381,-2062,-142,-603,-3104,-1942}
     },
     {
      272,
      -1220,
      {-5027,3591,-1890,-129,-900,-2316,61,-3257,-1258,-508,-2296,886,-140,-111,-1710,-3110,-74,-958,-831,1941,623,742,-3795,1159,-2301,-1086,1053,76,1013,-2302,-2676,-1626}
     },
     {
      276,
      141,
      {-1910,1387,-2823,-1535,-2119,-229,-823,-1659,-59,-484,-1463,-4485,-2305,2359,-2032,1295,-393,-293,1470,2440,958,896,1045,862,-1910,-3321,-1191,-1013,-4413,-2363,1640,1434}
     },
     {
      280,
      -1015,
      {-694,-4802,2133,1202,-745,-1298,-321,-999,-1003,-3254,805,2311,-1741,-3288,-1403,1325,-507,-3657,2711,318,-1162,412,-2354,-301,479,-879,2797,-694,-1230,1315,-334,270}
     },
     {
      284,
      -1728,
      {-385,29,-1355,-1402,-621,-591,2547,1535,-3062,-1703,1943,-79,4202,-2062,-1272,-2289,-1166,-3987,-1181,598,349,-3340,-1508,598,551,-1108,-1340,702,-1769,-1991,3886,-2014}
     },
     {
      288,
      -1883,
      {-952,1379,229,-94,2368,-1914,2449,313,-155,514,1382,-1089,-1846,-1038,-587,-1052,416,2392,480,175,570,-599,-331,-1436,252,-2065,-321,-704,3948,-3241,1501,-381}
     },
     {
      292,
      -2040,
      {-1295,-894,1689,-186,3941,1278,2099,-71,-2563,-3646,2239,338,-753,-1394,-430,469,-2119,444,-1657,178,-2449,115,1615,-1476,1705,924,-536,223,619,-1178,-1241,-2024}
     },
     {
      296,
      418,
      {-853,1545,708,-345,-4588,-3768,-638,-1538,-630,2067,1488,-1811,975,-976,-635,-793,-645,-1665,-2608,26,1519,598,-542,-1056,264,644,-1593,-788,-528,-2262,2489,562}
     },
     {
      300,
      102,
      {-3055,-2990,2255,-1352,1675,-3514,1896,-1234,1841,822,-2257,718,-1635,1612,613,-2005,-1332,-1620,-1400,-1031,-824,-1794,-1564,-1776,-419,-3449,698,120,475,-978,-2462,152}
     },
     {
      304,
      -353,
      {321,-362,3494,-2756,-490,-701,763,-1056,-2235,-888,281,-39,-5224,-510,-860,-717,-1164,-879,29,-688,-280,1308,1361,-1205,-2830,1397,-1432,-959,1962,2766,-1825,-510}
     },
     {
      308,
      333,
      {886,2058,-2635,-1706,1219,2144,1003,-4660,-1805,1563,3861,576,1114,-2245,-1953,-1129,2209,-2631,-2462,-1852,896,40,-2170,-805,2120,2523,-5369,351,-1458,-511,564,97}
     },
     {
      312,
      -5841,
      {1095,459,1453,1,303,-490,2608,-3633,-3861,-3163,-122,-388,689,-1901,645,-342,727,-2917,817,2315,-2225,1916,-351,-2080,897,-4257,2762,-1266,1979,1989,-679,-871}
     },
     {
      316,
      -3295,
      {382,-1303,204,199,-1241,1284,302,-1068,-655,-1427,777,-804,886,-754,0,123,518,941,1293,-1018,1571,-3328,2722,-1188,223,-2080,-503,1311,559,-3120,856,-484}
     },
     {
      320,
      -6160,
      {-2057,45,1500,-765,433,599,3433,775,-604,-1735,-1349,-646,-1660,-624,-1578,-2134,3767,-4079,1746,456,4428,-2620,-840,4046,-2359,-868,-2270,654,-2026,-1010,2009,665}
     },
     {
      324,
      1594,
      {608,-1508,-3168,-830,112,-1072,-348,955,1319,982,-240,-973,2657,2739,-824,-2066,2151,-1111,-3704,1435,477,-1932,-2909,-1078,-171,-1800,742,-885,-749,-4500,-4198,46}
     },
     {
      328,
      680,
      {788,-1277,-799,1256,2879,221,2072,-2451,-4975,-2337,1851,632,1816,-1800,-1404,-2423,46,-2636,-1922,-2526,1741,186,2243,-1019,-10,59,-1515,-1732,-1633,769,1800,2491}
     },
     {
      332,
      -1420,
      {3629,-2256,-1040,-318,-1698,-2084,-361,-2316,-1972,-1644,-2378,591,-2142,1676,1738,-855,-2359,1151,-1816,-1599,-2597,296,-883,-3741,2625,947,1743,-116,2134,-846,1998,-1041}
     },
     {
      336,
      -320,
      {541,-2076,1168,-1389,2010,-2290,778,872,2919,-199,459,574,920,-1885,-610,642,-613,-2608,-280,472,-225,-223,906,-681,2005,1585,-743,45,81,-978,-2013,-1410}
     },
     {
      340,
      2198,
      {-1178,-346,-570,-831,-2074,-2767,644,837,-354,-3060,-2276,387,-2188,-1781,-424,-88,524,-385,-971,1664,-313,-2898,-481,522,-545,-5243,665,771,64,-1302,-1077,3}
     },
     {
      344,
      -745,
      {1389,-2670,-446,537,-1623,431,-339,-776,-2214,1179,-3777,-1023,1579,-207,-402,638,411,-2066,897,334,1420,-1466,-1021,97,-2441,221,-375,-211,-3038,-515,1633,28}
     },
     {
      348,
      242,
      {-3631,722,-3211,-423,-2990,-215,-361,629,2340,4685,-506,-593,362,-530,-1258,332,1189,-1807,3513,-2057,-1841,1282,3049,-1446,1599,-1993,-796,-1329,-2285,837,-1071,-423}
     },
     {
      352,
      517,
      {-2155,218,-2679,878,-2137,-3795,-2889,1572,3401,-1692,849,736,-2554,1317,610,-739,-3383,-3247,-2018,208,1064,1312,-1118,-1535,674,2176,-4339,-1268,-3967,-12,-249,536}
     },
     {
      356,
      -3097,
      {-40,2625,382,160,-4598,304,-1663,-877,-2169,-2000,707,123,1439,1297,-1223,-332,1694,2036,3797,-542,45,108,-1609,-1001,3789,405,-1855,-172,2686,-3313,-2695,-948}
     },
     {
      360,
      -1957,
      {-723,1842,-2097,618,425,700,-1832,630,-1978,620,1344,-81,3316,29,194,-869,-4152,326,-2107,-303,2360,-1236,-2056,-2529,-2161,1429,-1913,-933,-1272,3845,2886,2745}
     },
     {
      364,
      -385,
      {1003,-2716,2207,-229,-286,-1921,2898,2124,-130,-466,-37,-1202,910,45,1381,-423,565,-234,-1644,775,1604,-507,-2045,424,17,-1239,-2270,-1609,-2755,-2405,-1874,-1318}
     },
     {
      368,
      -2166,
      {841,-689,-673,-1782,-2058,1356,-789,-2341,-1357,2817,1221,-2473,-3426,-6881,-1227,-2200,3383,-1896,2162,-1014,2607,-860,2253,-1214,778,2016,4095,-1349,-2340,4106,-569,-2142}
     },
     {
      372,
      -828,
      {1075,568,-118,-2061,1824,317,-778,-987,4,-1697,375,-690,690,283,-114,-3722,180,-343,-2050,2975,-1593,1201,1860,-1351,-1416,1627,3958,-946,-2508,2645,-3476,-3929}
     },
     {
      376,
      -2833,
      {47,1100,-453,-188,534,-1089,-249,-2760,396,-113,-214,-2720,-2078,1235,1257,-1938,-1561,1089,-372,-407,-1760,2471,-644,-1723,1516,-116,-649,2113,-3690,1405,-148,1753}
     },
     {
      380,
      -771,
      {-1003,-2064,-1451,-135,-29,-96,-255,-1493,-1611,-797,-762,-350,731,232,-473,763,-1681,-1509,-1580,-2114,-149,-850,1420,296,-869,267,1698,-400,880,-2251,-1914,1239}
     },
     {
      384,
      -390,
      {1585,-1748,123,-1146,548,-1639,-928,-548,1350,-258,-198,145,1043,-1582,798,-2100,-1731,567,500,746,193,-1022,1801,-935,-303,-1120,-2151,357,-970,-3796,-1210,-959}
     },
     {
      388,
      -1089,
      {-474,-1119,-2424,35,350,-1194,139,-1028,1954,1415,-681,584,-156,-705,1516,-286,-1448,2796,-1589,-6,-3265,1889,251,-2227,-846,1330,-3165,-3052,-1415,-2890,1778,-1114}
     },
     {
      392,
      509,
      {1411,-842,-332,1216,496,212,-527,-1134,-2028,376,340,569,-3709,-591,2803,-2868,-3132,-2767,3676,-20,-3277,-627,-2633,1058,-3826,-533,1582,-78,-847,-2599,-2464,-11}
     },
     {
      396,
      201,
      {822,84,533,532,-1600,479,-149,-2152,-1051,2197,-704,-117,3155,-266,-2075,-310,-1906,-2862,413,-1834,-1287,499,-512,2017,-2591,-165,-1121,1157,1144,-502,-3775,-1557}
     },
     {
      400,
      140,
      {705,1083,627,-2343,-28,2201,1330,-1342,-977,687,-1169,-180,-709,-1269,1589,1662,-261,192,-3096,2607,-727,-2277,110,-1470,2070,448,-47,2111,-271,161,-2754,-1874}
     },
     {
      404,
      -160,
      {-1321,304,1882,-288,-759,576,-1602,698,663,-444,-982,-2004,896,878,-2055,1029,-825,625,-2254,-1668,-275,-476,-1680,-213,-1075,-1686,-3302,2787,751,-199,-1258,1220}
     },
     {
      408,
      -2341,
      {-616,-116,-143,1710,2931,1442,2070,-348,1151,-569,-1059,1858,118,-2230,-1054,-1324,-1582,-1059,-1014,-1114,-2035,594,868,-135,-1769,-267,-225,3351,-1994,-402,-3491,-156}
     },
     {
      412,
      -674,
      {2185,-1618,-818,901,953,-516,-1350,2874,-720,-2048,-1996,2309,-514,-1139,-1806,3340,951,-888,1584,1252,-245,-867,-263,-445,-1771,-1014,-1055,-1497,248,-1765,-508,-2795}
     },
     {
      416,
      -1028,
      {504,-2766,-2809,-937,-529,2123,-818,1936,-1152,-279,-1248,2957,497,-134,-1542,900,-322,-667,-1367,1636,566,-129,-2950,1581,122,670,-1497,694,1940,774,-1216,982}
     },
     {
      420,
      -874,
      {-2697,844,-1021,3299,-1706,-1899,-544,1368,-2605,-2427,555,2953,-205,-2944,-1955,89,779,-513,-1427,1068,-209,2255,-1935,1379,-2387,-2703,-1411,-1404,-2963,2504,-1662,344}
     },
     {
      424,
      653,
      {-3405,-1386,1341,2952,-768,-380,-349,1589,-2997,-1374,-362,1242,-1011,-239,-1109,1719,-2392,-1187,-924,-2108,1354,1665,-2485,-1214,-2049,-289,1857,-1697,-179,1288,-520,-208}
     },
     {
      428,
      -388,
      {-2243,762,1248,1892,86,-719,-2315,2274,-3574,-191,-606,487,2110,-394,-3189,-1458,10,-1011,-1081,2014,770,-1414,1929,-1495,-1051,-496,-229,-426,-278,77,-1382,-1386}
     },
     {
      432,
      -64,
      {-2069,-1090,362,2287,-2254,-178,656,-1574,-2866,-614,-1171,-1278,-161,644,153,-2258,-989,1891,506,-467,-611,1027,-137,-2075,-637,-342,416,765,-1553,468,-1835,-2062}
     },
     {
      436,
      130,
      {-2905,401,-1097,-4200,292,-828,-704,-1047,-246,-1358,678,1578,-1067,-666,1387,404,-760,-1298,-599,-381,-355,1472,-222,-1565,-675,1222,-233,204,-1328,1407,332,-469}
     },
     {
      440,
      -876,
      {-2708,-604,-1400,-1533,1141,-37,-1893,-2831,689,702,2503,-2672,1351,-348,-1467,-2851,313,-208,715,978,3120,-243,-544,-585,321,-31,1015,-1499,2158,-965,349,-2121}
     },
     {
      444,
      -446,
      {-568,-902,-1599,-2466,-1159,-1038,1712,1350,-561,-592,-1364,-2207,-736,254,-2705,-2453,490,68,-870,3250,270,194,-1328,1358,-807,867,-94,-2748,-387,1159,-172,538}
     },
     {
      448,
      2358,
      {-41,-286,561,904,146,-1539,-3567,-3884,879,-2028,289,-2876,635,2999,29,-4189,1473,-1617,230,1736,-1853,-1685,-928,-575,2162,982,865,1645,-1353,-1450,-2430,-1113}
     },
     {
      452,
      -194,
      {-2454,2089,-1302,134,-1535,-442,-618,307,-1693,2883,1181,-1666,2886,1182,-2395,-2838,1301,1847,2433,-1637,2962,3335,462,181,-3839,475,-3519,1413,-3113,-1138,-2892,1706}
     },
     {
      456,
      -1406,
      {712,-365,12,200,380,325,-1754,-2746,331,551,-565,12,-617,-666,595,-2899,499,-1247,2960,-2253,1475,-199,-1236,828,-2153,2314,-1367,3755,-1205,-807,479,-2025}
     },
     {
      460,
      19,
      {-915,-581,-477,-31,-1038,47,227,-118,-1540,-294,-167,3108,-548,-498,155,-4119,-1632,367,-400,-2364,-1549,-93,174,-1328,1257,-37,500,-1405,1005,445,1612,-1827}
     },
     {
      464,
      -404,
      {-1111,5,-478,-2670,-1148,-562,328,-1164,-898,-1568,155,945,-1387,1960,-857,4384,-2192,-1754,-287,686,422,-1022,-1789,378,1835,-639,669,1071,-1269,-1652,-710,-2418}
     },
     {
      468,
      -480,
      {-1904,131,-438,-2551,-1376,1003,451,-2711,-2077,-443,708,-661,-41,737,-3182,-103,-1452,866,-229,-1079,-67,215,268,-962,693,141,985,2434,1260,277,220,-370}
     },
     {
      472,
      -1082,
      {52,1891,1294,-274,-854,-374,-199,1512,-1185,-935,470,-1697,1237,-683,323,769,1749,-679,-1795,-2316,154,549,-263,-2402,-371,-990,-1519,-1606,-253,-352,-1468,-2923}
     },
     {
      476,
      196,
      {-1938,-1383,-1968,376,212,-1256,110,-466,-29,-497,1662,-3832,614,925,1512,-2993,382,1638,-837,-3464,521,-477,867,-4573,10,1117,1030,-3147,390,739,-28,-3879}
     },
     {
      480,
      -319,
      {1576,-721,-1773,-1474,-2429,-495,-3051,1456,-1215,361,1597,818,-172,-2477,112,-718,327,752,1339,1978,-171,-1219,655,2033,545,-1181,1155,-2862,-487,-199,-568,-2648}
     },
     {
      484,
      -484,
      {-361,-474,-1964,678,12,-653,1286,-1074,-326,216,688,1490,-652,-527,1071,-1070,-5,281,1233,-1468,-200,196,1321,-775,-475,-279,-1646,-1533,-654,-559,1162,-2367}
     },
     {
      488,
      172,
      {-689,-265,283,1204,-537,-930,-368,634,-880,-213,-35,1571,-383,-729,-145,1698,-223,-188,156,362,-947,-24,202,-2101,-949,-426,-508,-69,-7,-314,458,-1960}
     },
     {
      492,
      -253,
      {-55,-200,-63,-45,-103,120,-198,0,-36,-35,-119,-84,-105,-36,-142,-72,-49,-46,-49,-410,-170,-128,-150,-205,-103,-34,-246,-69,-146,-49,-68,13}
     }
   }

 };
#endif /* MLP_PRELOAD_MODE */  

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\sketch.cpp ===
/**************************************************************************/
#include <common.h>

#ifndef LSTRIP

  #include  "hwr_sys.h"
  #include  "ams_mg.h"

#if /* GIT - defined( FOR_GERMAN) ||  */ defined (FOR_FRENCH) || defined(FOR_INTERNATIONAL)

  #include  "lowlevel.h"
  #include  "def.h"
  #include  "calcmacr.h"
  #include  "arcs.h"
  #include  "low_dbg.h"
  #include  "sketch.h"
  #include  "bit_mark.h"
  #include  "lk_code.h"


	 #if PG_DEBUG
		  #include "pg_debug.h"
	 #endif

 /*------------------------------------------------------------------------*/

  #define    UPPER_UM_LIMIT                8
  #define    LOWER_UM_LIMIT                2

  #define    F_MAX_MARK                    10
  #define    NUM_UML_MIN                   2

  #define    FIRST_STRK                    0
  #define    NEXT_STRK                     1

  #define    END_POS                       3
  #define    COMMON_POS                    4
  #define    SHIFT_LEFT                    5

 /*------------------------------------------------------------------------*/


  #define    F_CONJUN( b , e )            ( ( ( b + e ) > F_MAX_MARK ) ?  \
                                          ( b + e - F_MAX_MARK )   : 0  )

  #define    F_MULTIP( b , e )     (_CHAR)( (_SHORT)b * e / F_MAX_MARK )


  /**************************************************************************/

  ROM_DATA_EXTERNAL _UCHAR     BoxScale[MAX_BOX_SCALE] ;
  ROM_DATA_EXTERNAL _UCHAR     NumExtScale[SCALE_EXT_DIMENSION] ;
  ROM_DATA_EXTERNAL _CHAR      IntScale[SCALE_INT_DIMENSION] ;

 /*------------------------------------------------------------------------*/

  ROM_DATA_EXTERNAL BIT_MARK   Int_Um_Com_Marks[SCALE_INT_DIMENSION] ;
  ROM_DATA_EXTERNAL BIT_MARK   Int_Com_Um_Marks[SCALE_INT_DIMENSION] ;
  ROM_DATA_EXTERNAL BIT_MARK   Pos_Cd_Com_Marks[SCALE_POS_DIMENSION] ;
  ROM_DATA_EXTERNAL BIT_MARK   Pos_Com_Cd_Marks[SCALE_POS_DIMENSION] ;

														/*  END_LAST  MID_LAST  COMMON   */


 /*------------------------------------------------------------------------*/

	ROM_DATA_EXTERNAL BIT_MARK   CdElsMarks[SCALE_Y_ELS_DIMENSION][SCALE_X_ELS_DIMENSION];
	ROM_DATA_EXTERNAL BIT_MARK   Pos_Cd_Els_Marks[SCALE_POS_DIMENSION];
	ROM_DATA_EXTERNAL BIT_MARK   Pos_Els_Cd_Marks[SCALE_POS_DIMENSION];

														/*  END_LAST  MID_LAST  COMMON   */


	ROM_DATA_EXTERNAL BIT_MARK   Int_Cd_Els_Marks[SCALE_INT_DIMENSION];
	ROM_DATA_EXTERNAL BIT_MARK   Int_Els_Cd_Marks[SCALE_INT_DIMENSION];

														/*  ISOLATE   INTERSECTED        */

 /*------------------------------------------------------------------------*/

	ROM_DATA_EXTERNAL BIT_MARK   CdDotMarks[SCALE_Y_DOT_DIMENSION][SCALE_X_DOT_DIMENSION];
	ROM_DATA_EXTERNAL BIT_MARK   Int_Cd_Dot_Marks[SCALE_INT_DIMENSION];
	ROM_DATA_EXTERNAL BIT_MARK   Int_Dot_Cd_Marks[SCALE_INT_DIMENSION];

														/*  ISOLATE   INTERSECTED        */

 /*------------------------------------------------------------------------*/

	ROM_DATA_EXTERNAL BIT_MARK   CdStrMarks[SCALE_Y_STR_DIMENSION][SCALE_X_STR_DIMENSION];
  ROM_DATA_EXTERNAL _SHORT     nbcut0 ;

 /**************************************************************************/

 /*------------------------------------------------------------------------*/

  _SHORT  CreateUmlData ( p_UM_MARKS_CONTROL  pUmMarksControl ,
								  _SHORT              nElements         )
    {
      if  ( ( pUmMarksControl->pUmMarks =
             (p_UM_MARKS)HWRMemoryAlloc( (_ULONG)sizeof(_UM_MARKS) *
              nElements ) ) == _NULL )
          {
            pUmMarksControl->Um_buf_Len   = UNDEF     ;
            pUmMarksControl->tmpUMnumber  = UNDEF     ;

	           return  UNSUCCESS ;
          }
      else
	       {
	         pUmMarksControl->Um_buf_Len   = nElements ;
	         pUmMarksControl->tmpUMnumber  = 0         ;
           HWRMemSet( (p_CHAR)(pUmMarksControl->pUmMarks) , 0 ,
                      (_WORD)sizeof(_UM_MARKS) * nElements     ) ;

             return  SUCCESS   ;
         }

    } /* CreateUmlData */

 /*------------------------------------------------------------------------*/


  _SHORT  WriteUmlData ( p_UM_MARKS_CONTROL pUmMarksControl ,
                         p_UM_MARKS         pUmTmpMarks       )
    {
      if  (    ( pUmMarksControl->tmpUMnumber >=
                 pUmMarksControl->Um_buf_Len      )
            || ( pUmMarksControl->tmpUMnumber == UNDEF ) )
          {
            pUmMarksControl->Um_buf_Len = UNDEF ;
              return  UNSUCCESS ;
          }
      else
          {
            *(pUmMarksControl->pUmMarks + pUmMarksControl->tmpUMnumber )
            = *pUmTmpMarks     ;

            ( pUmMarksControl->tmpUMnumber )++  ;
              return  SUCCESS   ;
          }
    }

 /*------------------------------------------------------------------------*/

  _VOID   DestroyUmlData ( p_UM_MARKS_CONTROL pUmMarksControl )
    {
        if  ( pUmMarksControl->pUmMarks  != _NULL )
            {
              HWRMemoryFree( pUmMarksControl->pUmMarks ) ;
              pUmMarksControl->pUmMarks   = _NULL        ;
            }

      pUmMarksControl->Um_buf_Len  = 0     ;
      pUmMarksControl->tmpUMnumber = UNDEF ;

    } /* DestroyUmlData */


 /*------------------------------------------------------------------------*/


  _SHORT  Sketch( low_type _PTR  pLowData )
    {
      p_POINTS_GROUP          pGroupsBorder     = pLowData->pGroupsBorder   ;
      _SHORT                  lenGrBord         = pLowData->lenGrBord       ;
      _SHORT                  iBegBlankGroups   = pLowData->iBegBlankGroups ;

      _SHORT                  flSketch          = SUCCESS ;
      _SHORT                  dX , dY           ;
      _UM_MARKS               UmTmpMarks        ;

      _RECT                   TmpBox            ;
      _SHORT                  il , iBegSpeclTmp ;

        for  ( il = 1  ;  il < lenGrBord   ; il++ )
          {              /* First group cannot be something .....*/

             TmpBox = (pGroupsBorder + il)->GrBox ;

             UmTmpMarks.tH = HeightInLine( TmpBox.top    , pLowData ) ;
             UmTmpMarks.bH = HeightInLine( TmpBox.bottom , pLowData ) ;

               if   ( UmTmpMarks.tH < (_SHORT)_MD_ )
                      continue ;

             dX = TmpBox.right  - TmpBox.left  ;
             dY = TmpBox.bottom - TmpBox.top   ;

             GetBoxMarks( &UmTmpMarks , dX , dY )  ;
             UmTmpMarks.UmCom = (_CHAR)MAX_MARK ;
             UmTmpMarks.ComUm = (_CHAR)MAX_MARK ;

               if   ( iBegBlankGroups  >  il )
                  {
                    iBegSpeclTmp = GroupsSpeclBegProect( pLowData , il ) ;

                      if   ( iBegSpeclTmp == UNDEF )
                         {
                           flSketch = UNSUCCESS  ;
                             goto   QUIT ;
                         }
                  }

             UmTmpMarks.GroupNum      = il            ;
             UmTmpMarks.CrossFeature  = (_CHAR)UNDEF  ;

             WriteUmlData ( pLowData->pUmMarksControl , &UmTmpMarks ) ;

          }

    QUIT:
      return( flSketch ) ;
    }


 /*------------------------------------------------------------------------*/


  _SHORT  GroupsSpeclBegProect( low_type _PTR  pLowData , _SHORT  numGroup )
    {
      _SHORT   iBeg     = ( (pLowData->pGroupsBorder) + numGroup )->iBeg ;
     p_SPECL   pSpecl   = pLowData->specl             ;
      _SHORT   lenSpecl = pLowData->len_specl         ;

      _SHORT   il  ;

        for  ( il = 0  ;  il < lenSpecl ;  il++ )
             {
               if   (     (  ( pSpecl + il )->mark == BEG  )
                      &&  (  ( pSpecl + il )->ibeg == iBeg ) )
                      break ;
             }

        if   ( il == lenSpecl - 1 )
             {
               err_msg( " GSBProect : Specl and GrBorder - no correspondence ." ) ;
               il = UNDEF ;
             }

          return( il ) ;
          }

 /*------------------------------------------------------------------------*/

  _SHORT   MarkPCounter( low_type _PTR  pLowData , p_SPECL  pSpecl ,
                        _UCHAR   MarkName )
    {
      _SHORT   Counter = 0               ;

        while   ( pSpecl->mark != END    )
          {
            if  ( pSpecl->mark == MarkName )
                {
                  if  (    ( MarkName == MINW )
                        && ( (pSpecl->prev)->mark == MAXW  )
                        && ( ((pSpecl->prev)->prev)->mark == MINW  ) )
                      {
                        if ( ShapeFilter( pLowData , pSpecl->ipoint0 ,
                                        (pSpecl->prev)->ipoint0 ,
                                        ((pSpecl->prev)->prev)->ipoint0 )
                                        == _TRUE )
                           {
                             Counter++ ;
                           }
                      }
                  else
                      {
                        Counter++ ;
                      }
                 }

            pSpecl = pSpecl->next ;
          }

    return( Counter ) ;
    }

 /*------------------------------------------------------------------------*/

  #define     ANGLE_LIMIT        90


  _BOOL   ShapeFilter ( low_type _PTR  pLowData ,
                        _SHORT   iMin0 , _SHORT  iMax , _SHORT iMin1 )
    {
     p_SHORT  xArr = pLowData->x       ;
     p_SHORT  yArr = pLowData->y       ;
      _LONG   s1   , s2  , sCos        ;
      _SHORT  dXl  , dYl , dXr , dYr   ;
      _SHORT  Cos  ;

        dXl = xArr[iMax] - xArr[iMin0] ;    dYl = yArr[iMax] - yArr[iMin0] ;
        dXr = xArr[iMax] - xArr[iMin1] ;    dYr = yArr[iMax] - yArr[iMin1] ;

          if  (   ( (dXl == 0) && (dYl == 0) )
               || ( (dXr == 0) && (dYr == 0) )  )
              {
                Cos = 0 ;
              }
          else
              {
                sCos = (_LONG)dXl * dXr + (_LONG)dYl * dYr ;

                  if   ( sCos <= 0L )
                         Cos = 0 ;
                  else
                    {
                      s1 = (_LONG)dXl * dXl + (_LONG)dYl * dYl ;
                      s2 = (_LONG)dXr * dXr + (_LONG)dYr * dYr ;

                        if   ( s1 >= s2 )
                               Cos = (_SHORT)( LONG_BASE * sCos / s2 *
                                       sCos / s1   ) ;
                        else
                               Cos = (_SHORT)( LONG_BASE * sCos / s1 *
                                       sCos / s2   ) ;
                    }
              }

          if   ( Cos < ANGLE_LIMIT )
               {
                 return( _TRUE  )  ;
               }
          else
               {
                 return( _FALSE )  ;
               }
    }

  #undef      ANGLE_LIMIT

 /*------------------------------------------------------------------------*/

  #define      REABILITATION_SIZE_LIMIT     18
  #define      REABILITATION_EXCT_LIMIT      9


  _VOID    DotPostcrossModify( low_type _PTR  pLowData )
    {
     p_POINTS_GROUP   pGroupsBorder = pLowData->pGroupsBorder ;
     p_SPECL          pSpecl        = pLowData->specl         ;
      _SHORT          termSpecl1    = pLowData->pUmMarksControl->termSpecl1 ;

     p_SPECL          pDotSpecl     ;
      _SHORT          il            ;
      _SHORT          dX , dY       ;
      _SHORT          DotNumGroup   ;
      _SHORT          bH            ;
      _SHORT          exc           ;
      _RECT           TmpBox        ;


       for ( il = 0 ;   il < termSpecl1 ;   il++ )
           {
             pDotSpecl = pSpecl + il ;

               if  ( (pDotSpecl->mark == DOT) && (pDotSpecl->other == 0) )
                   {
                     DotNumGroup = (_SHORT)GetGroupNumber( pLowData, pDotSpecl->ibeg ) ;
                     TmpBox      = (pGroupsBorder + DotNumGroup)->GrBox ;

                     bH  = HeightInLine( TmpBox.bottom , pLowData ) ;

                     dX  = TmpBox.right  - TmpBox.left  ;
                     dY  = TmpBox.bottom - TmpBox.top   ;

                       if  ( dY != 0 )
                           {
                             exc = ( SHORT_BASE * dX ) / dY ;
                           }
                       else
                           {
                             exc = TWO( REABILITATION_EXCT_LIMIT ) ;
                           }

                       if  (     ( bH  > (_SHORT)_MD_ )
                             ||  ( dX  < REABILITATION_SIZE_LIMIT )
                             ||  ( exc < REABILITATION_EXCT_LIMIT ) )
                           {
                             UmIntersectDestroy ( pLowData , DotNumGroup ) ;
                           }
                       else
                           {
                             if  ( IntersectContains( pLowData , DotNumGroup )
                                    == _TRUE )
                                 {
                                   pDotSpecl->mark  = STROKE     ;
                                   pDotSpecl->other = REANIMATED ;
                                 }
                             else
                                 {
                                   UmIntersectDestroy( pLowData, DotNumGroup ) ;
                                 }
                           }
                   }
           }

    return ;
    }

  #undef       REABILITATION_SIZE_LIMIT
  #undef       REABILITATION_EXCT_LIMIT


 /*------------------------------------------------------------------------*/

  _BOOL   IntersectContains( low_type _PTR  pLowData , _SHORT  NumGroup )
    {
     p_SPECL      pSpecl       = pLowData->specl                          ;
      _SHORT      termSpecl    = pLowData->pUmMarksControl->termSpecl     ;
      _SHORT      SpeclEnd     = pLowData->len_specl                      ;
      _SHORT      SpcNumGroup  ;
     p_SPECL      tmpSpecl     ;
      _SHORT      jl, kl       ;
      _BOOL       ContainFlag  ;

        ContainFlag = _FALSE   ;

          for  ( jl = termSpecl , kl = 1  ;  jl < SpeclEnd  ;  jl++ , kl++ )
            {
               tmpSpecl    = pSpecl + jl ;
               SpcNumGroup = (_SHORT)GetGroupNumber( pLowData, tmpSpecl->ibeg ) ;

                 if  ( NumGroup == SpcNumGroup )
                     {
                       if  ( ( (kl % 2) == 1 )  &&
                             ( NumGroup != GetGroupNumber( pLowData,
                                                 (tmpSpecl+1)->ibeg ) ) )
                           {
                             ContainFlag        = _TRUE ;
                             tmpSpecl->mark     = HATCH ;
                             (tmpSpecl+1)->mark = HATCH ;
                           }

                       if  ( ( (kl % 2) == 0 )  &&
                             ( NumGroup != GetGroupNumber( pLowData,
                                                 (tmpSpecl-1)->ibeg ) ) )
                           {
                             ContainFlag        = _TRUE ;
                             tmpSpecl->mark     = HATCH ;
                             (tmpSpecl-1)->mark = HATCH ;
                           }
                     }
            }

    return( ContainFlag );
    }

 /*------------------------------------------------------------------------*/


  _VOID   UmIntersectBuild ( low_type _PTR  pLowData )
    {
     p_UM_MARKS   pUmMarks     = pLowData->pUmMarksControl->pUmMarks      ;
     p_SPECL      pSpecl       = pLowData->specl                          ;
      _SHORT      tmpUMnumber  = pLowData->pUmMarksControl->tmpUMnumber   ;
      _SHORT      termSpecl    = pLowData->pUmMarksControl->termSpecl     ;
      _SHORT      SpeclEnd     = pLowData->len_specl                      ;
      _SHORT      UmNumGroup   , SpcNumGroup                              ;
     p_SPECL      tmpSpecl     ;
      _SHORT      il, jl, kl   ;

        for  ( il = 0  ;  il < tmpUMnumber ;  il++ )
          {
            UmNumGroup = ( pUmMarks + il )->GroupNum  ;
            ( pUmMarks + il )->CrossFeature = (_CHAR)ISOLATE ;

              for  ( jl = termSpecl , kl = 1  ;
                     jl < SpeclEnd  , jl < SpeclEnd  ;
                     jl++  , kl++   )
                   {
                     tmpSpecl    = pSpecl + jl ;
                     SpcNumGroup = (_SHORT)GetGroupNumber( pLowData, tmpSpecl->ibeg );

                       if  ( UmNumGroup == SpcNumGroup )
                           {
                             _SHORT  tmpGrNum0 , tmpGrNum1 ;

                               tmpGrNum0 = (_SHORT)GetGroupNumber( pLowData,
                                                       (tmpSpecl+1)->ibeg ) ;

                               tmpGrNum1 = (_SHORT)GetGroupNumber( pLowData,
                                                       (tmpSpecl-1)->ibeg ) ;


                                 if  (   (    ( (kl % 2)   == 1 )
                                           && ( UmNumGroup !=  tmpGrNum0 ) )
                                      ||
                                         (    ( (kl % 2)   == 0 )
                                           && ( UmNumGroup != tmpGrNum1 ) ) )


                                     {
                                       (pUmMarks + il)->CrossFeature =
                                                       (_CHAR)INTERSECTED  ;
                                          break ;
                                     }
                           }
                   }
          }

    return ;
    } /* UmIntersectBuild */


 /*------------------------------------------------------------------------*/


  _VOID   UmPostcrossModify( low_type _PTR  pLowData )
    {
      p_UM_MARKS      pUmMarks      = pLowData->pUmMarksControl->pUmMarks    ;
      _SHORT          tmpUMnumber   = pLowData->pUmMarksControl->tmpUMnumber ;

      _UM_MARKS       BoxMarks      ;
      _UM_MARKS       ExtMarks      ;
      _UM_MARKS       IntMarks      ;
      _UM_MARKS       TimMarks      ;

      p_UM_MARKS      pUmTmpMarks   ;
      _SHORT          tmpGroupNum   ;
      _SHORT          il            ;

         #if  PG_DEBUG
           #ifdef  FILE_TESTING

             FILE            *debUmInfo ;
            _SHORT            debFlag   ;

           #endif
         #endif

         HWRMemSet( (p_CHAR)(&BoxMarks) , 0 , (_WORD)sizeof(_UM_MARKS) ) ;
         HWRMemSet( (p_CHAR)(&ExtMarks) , 0 , (_WORD)sizeof(_UM_MARKS) ) ;
         HWRMemSet( (p_CHAR)(&IntMarks) , 0 , (_WORD)sizeof(_UM_MARKS) ) ;
         HWRMemSet( (p_CHAR)(&TimMarks) , 0 , (_WORD)sizeof(_UM_MARKS) ) ;

         UmIntersectBuild( pLowData ) ;

           #if  PG_DEBUG
              #ifdef  FILE_TESTING

                if   ( mpr == 3 )
                  {
                    if   ( ( debUmInfo = fopen( "Deb_Um_Info.txt" , "r" ) ) == _NULL )
                       {
                         if   ( ( debUmInfo = fopen( "Deb_Um_Info.txt" , "a" ) ) == _NULL )
                           {
                             debFlag = UNSUCCESS ;
                           }
                         else
                           {
                             fprintf( debUmInfo  ,  "\n M   bUE  bEU  bUD  bDU  bUS  bSU  eUE  eEU  eUD  eDU  eUS  eSU  iUE  iEU  iUD  iDU  iUS  iSU  rUE  rEU  rUD  rDU  rUS  rSU \n" ) ;
                             debFlag = SUCCESS   ;
                           }
                       }
                    else
                       {
                         fclose( debUmInfo );

                           if   ( ( debUmInfo = fopen( "Deb_Um_Info.txt" , "a" ) ) == _NULL )
                             {
                               debFlag = UNSUCCESS ;
                             }
                           else
                             {
                               debFlag = SUCCESS   ;
                             }

                         debFlag = SUCCESS ;
                       }
                  }
              #endif
           #endif

           for  ( il = 0  ;  il < tmpUMnumber ; il++ )
                {
                  pUmTmpMarks = pUmMarks + il ;
                  tmpGroupNum = pUmTmpMarks->GroupNum   ;
                  BoxMarks = ExtMarks = IntMarks = *pUmTmpMarks ;

                  ExtMarks.UmEls = IntMarks.UmEls =
                  ExtMarks.ElsUm = IntMarks.ElsUm =
                  ExtMarks.UmDot = IntMarks.UmDot =
                  ExtMarks.DotUm = IntMarks.DotUm =
                  ExtMarks.UmCom = IntMarks.UmCom =
                  ExtMarks.ComUm = IntMarks.ComUm =
                  ExtMarks.UmStr = IntMarks.UmStr =
                  ExtMarks.StrUm = IntMarks.StrUm = (_CHAR)UNDEF ;

                  IntMarks.UmCom = (_CHAR) InterMarks( pUmTmpMarks->CrossFeature ,
                                             (p_BIT_MARK)Int_Um_Com_Marks) ;

                  IntMarks.ComUm = (_CHAR) InterMarks( pUmTmpMarks->CrossFeature ,
                                             (p_BIT_MARK)Int_Com_Um_Marks) ;

                  IntMarks.ElsUm = Int_Els_Cd_Marks[pUmTmpMarks->CrossFeature].single_mark ;

                  IntMarks.UmEls = Int_Cd_Els_Marks[pUmTmpMarks->CrossFeature].single_mark ;

                  IntMarks.DotUm = Int_Cd_Dot_Marks[pUmTmpMarks->CrossFeature].single_mark ;

                  IntMarks.UmDot = Int_Dot_Cd_Marks[pUmTmpMarks->CrossFeature].single_mark ;

                  GetPositionMark( pLowData , tmpGroupNum , &ExtMarks  )  ;
                  pUmTmpMarks->PositionFeature = ExtMarks.PositionFeature ;

                    #if  PG_DEBUG
                      #ifndef  FILE_TESTING

                          if   ( mpr == 3 )
                         {
                           UmInfoTypePaint( pLowData    ,
                              #ifdef  FILE_TESTING
                                debUmInfo   ,
                              #endif
                                pUmTmpMarks , &BoxMarks ,
                                &ExtMarks   , &IntMarks   ) ;
                         }
                      #endif
                    #endif


                    if   (    ( pUmTmpMarks->UmDot < (_CHAR)UPPER_UM_LIMIT )
                           && ( pUmTmpMarks->UmDot > (_CHAR)LOWER_UM_LIMIT ) )
                         {
                           pUmTmpMarks->UmDot = F_CONJUN( pUmTmpMarks->UmDot ,
                                                          ExtMarks.UmDot   ) ;

                           pUmTmpMarks->DotUm = F_CONJUN( pUmTmpMarks->DotUm ,
                                                          ExtMarks.DotUm   ) ;

                           pUmTmpMarks->UmDot = F_CONJUN( pUmTmpMarks->UmDot ,
                                                          IntMarks.UmDot   ) ;

                           pUmTmpMarks->DotUm = F_CONJUN( pUmTmpMarks->DotUm ,
                                                          IntMarks.DotUm   ) ;

                         }

                  pUmTmpMarks->UmStr = F_CONJUN( pUmTmpMarks->UmStr ,
                                                 ExtMarks.UmStr   ) ;

                  pUmTmpMarks->StrUm = F_CONJUN( pUmTmpMarks->StrUm ,
                                                 ExtMarks.StrUm   ) ;

                  pUmTmpMarks->UmEls = F_CONJUN( pUmTmpMarks->UmEls ,
                                                 ExtMarks.UmEls   ) ;

                  pUmTmpMarks->ElsUm = F_CONJUN( pUmTmpMarks->ElsUm ,
                                                 ExtMarks.ElsUm   ) ;

                  pUmTmpMarks->ComUm = F_CONJUN( pUmTmpMarks->ComUm ,
                                                 ExtMarks.ComUm   ) ;

                  pUmTmpMarks->UmCom = F_CONJUN( pUmTmpMarks->UmCom ,
                                                 ExtMarks.UmCom   ) ;


                  pUmTmpMarks->UmEls = F_CONJUN( pUmTmpMarks->UmEls ,
                                                 IntMarks.UmEls   ) ;

                  pUmTmpMarks->ElsUm = F_CONJUN( pUmTmpMarks->ElsUm ,
                                                 IntMarks.ElsUm   ) ;

                  pUmTmpMarks->ComUm = F_CONJUN( pUmTmpMarks->ComUm ,
                                                 IntMarks.ComUm  )  ;

                  pUmTmpMarks->UmCom = F_CONJUN( pUmTmpMarks->UmCom ,
                                                 IntMarks.UmCom  )  ;


                    #if  PG_DEBUG
                          if  ( mpr == 3 )
                            {
                               UmInfoTypePaint( pLowData,
                                  #ifdef  FILE_TESTING
                                    debUmInfo   ,
                                  #endif
                                pUmTmpMarks , &BoxMarks ,
                                &ExtMarks   , &IntMarks   ) ;
                            }
                    #endif
                }

              #if defined(FILE_TESTING) && defined(PG_DEBUG)

                if   ( ( mpr == 3 ) && ( debFlag == SUCCESS ) )
                   {
                     fclose( debUmInfo );
                   }
              #endif

    return ;
    }


 /*------------------------------------------------------------------------*/

  _BOOL  CheckGroup( low_type _PTR  pLowData , _SHORT  GroupNumber )
    {
     p_POINTS_GROUP  pGroupsBorder = pLowData->pGroupsBorder ;
      _SHORT         lenGrBord     = pLowData->lenGrBord     ;
     p_SPECL         pSpecl        = pLowData->specl         ;
     p_SPECL         pTmpSpecl     ;
      _BOOL          flag          ;
      _SHORT         il            ;

        if  ( GroupNumber  <  lenGrBord - 1 )
            {
              for  ( il = GroupNumber ;  il < lenGrBord ;  il++ )
                {
                  flag      = _FALSE  ;
                  pTmpSpecl = pSpecl  ;

                    while (     pTmpSpecl != NULL &&
								( pTmpSpecl->mark != MAXW )
								&& ( pTmpSpecl->mark != MINW )  
							)
                      {
                        if  (   (    ( pTmpSpecl->mark == DOT    )
                                  || ( pTmpSpecl->mark == STROKE )  )
                             && ( (pGroupsBorder + il)->iBeg
                                          == pTmpSpecl->ibeg  ) )
                            {
                              flag = _TRUE ;
                                break ;
                            }
                        else
                            {
                              pTmpSpecl = pTmpSpecl->next ;
                            }
                      }

                    if  ( flag == _FALSE )
                          break  ;
                }
            }
        else
           {
             flag = _TRUE ;
           }

    return ( flag )  ;
    }

 /*------------------------------------------------------------------------*/

  _VOID  GetPositionMark( low_type _PTR  pLowData ,
                         _SHORT          GroupNumber ,
                          p_UM_MARKS     pCdPosMarks )
    {
      _BOOL    GroupFlag       ;
      _SHORT   PositionFlag    ;
      _SHORT   PositionFeature	=	END_LAST;

        GroupFlag    = CheckGroup( pLowData    , GroupNumber ) ;
        PositionFlag = CheckPosition( pLowData , GroupNumber ) ;

          if  (    ( GroupFlag  &&  ( PositionFlag != END_POS ) )
                || ( PositionFlag == SHIFT_LEFT ) )
              {
                PositionFeature  = MID_LAST ;
              }
          else  if  ( GroupFlag  &&  ( PositionFlag == END_POS ) )
                      PositionFeature  = END_LAST ;

          else  if  ( !GroupFlag &&  ( PositionFlag == END_POS ) )
                      PositionFeature  = END_LAST ;

          else  if  ( !GroupFlag &&  ( PositionFlag != END_POS )  )
                      PositionFeature  = COMMON   ;


        pCdPosMarks->PositionFeature   = (_CHAR)PositionFeature ;

        pCdPosMarks->UmEls = (_CHAR)Pos_Cd_Els_Marks[PositionFeature].single_mark ;
        pCdPosMarks->ElsUm = (_CHAR)Pos_Els_Cd_Marks[PositionFeature].single_mark ;
        pCdPosMarks->UmStr = (_CHAR)Pos_Cd_Els_Marks[PositionFeature].single_mark ;
        pCdPosMarks->StrUm = (_CHAR)Pos_Els_Cd_Marks[PositionFeature].single_mark ;

        pCdPosMarks->UmCom = (_CHAR)Pos_Cd_Com_Marks[PositionFeature].single_mark ;
        pCdPosMarks->ComUm = (_CHAR)Pos_Com_Cd_Marks[PositionFeature].single_mark ;
        pCdPosMarks->UmDot = (_CHAR)Pos_Cd_Com_Marks[PositionFeature].single_mark ;
        pCdPosMarks->DotUm = (_CHAR)Pos_Com_Cd_Marks[PositionFeature].single_mark ;

    return ;
    }

 /*------------------------------------------------------------------------*/

  _SHORT  CheckPosition( low_type _PTR  pLowData , _SHORT  GroupNumber )
    {
      p_POINTS_GROUP  pGroupsBorder = pLowData->pGroupsBorder              ;
      p_RECT          pWordbox      = &( pLowData->box )                   ;
       _RECT          GrBox         = (pGroupsBorder + GroupNumber)->GrBox ;
       _SHORT         flag    , il      ;
       _RECT          TmpBox  , PartBox ;

         flag = COMMON_POS ;


            if  ( pWordbox->right <=
                ( GrBox.right + THREE_HALF( STR_DOWN - STR_UP ) ) )
                {
                  flag = END_POS ;
                    goto  QUIT   ;
                }

          PartBox = pGroupsBorder->GrBox ;

           for  ( il = 1 ;  il < GroupNumber ; il++ )
                {
                  TmpBox = (pGroupsBorder + il)->GrBox ;
                  PartBox.right = HWRMax( TmpBox.right, PartBox.right ) ;
                  PartBox.left  = HWRMin( TmpBox.left , PartBox.left  ) ;

                    if  ( PartBox.right >
                        ( GrBox.right + THREE_HALF( STR_DOWN - STR_UP ) ) )
                        {
                          flag = SHIFT_LEFT ;
                        }
                }

    QUIT: return( flag ) ;
    }

 /*------------------------------------------------------------------------*/

  _VOID   UmIntersectDestroy ( low_type _PTR  pLowData , _SHORT  UmNumGroup )
    {
     p_SPECL      pSpecl        = pLowData->specl                        ;
      _SHORT      termSpecl     = pLowData->pUmMarksControl->termSpecl1  ;
      _SHORT      SpeclEnd      = pLowData->len_specl                    ;
      _SHORT      SpcNumGroup   ;
     p_SPECL      tmpSpecl      ;
      _SHORT      jl, kl        ;

         for  ( jl = termSpecl ,  kl = 1  ;  jl < SpeclEnd  ;  jl++   )
           {
             tmpSpecl    = pSpecl + jl   ;
             SpcNumGroup = (_SHORT)GetGroupNumber( pLowData, tmpSpecl->ibeg );

               if  ( tmpSpecl->mark == ANGLE )
                   {
                     if  ( UmNumGroup  ==  SpcNumGroup )
                         {
                           DestroySpeclElements( pLowData , jl , jl ) ;
                           jl-- ;
                         }
                   }
               else
                   {
                     if  ( UmNumGroup == SpcNumGroup )
                         {
                           if  ( ( kl % 2 )  ==  1   )
                               {
                                 DestroySpeclElements( pLowData , jl , jl+1 ) ;
                                 jl--    ;
                               }
                           else  if  ( ( kl % 2 )  ==  0 )
                               {
                                 DestroySpeclElements( pLowData , jl-1 , jl ) ;
                                 kl++    ;
                                 jl -= 2 ;
                               }
                         }
                     else  kl++ ;
                   }

             SpeclEnd = pLowData->len_specl ;
           }

    return ;
    } /* UmIntersectBuild */


 /*------------------------------------------------------------------------*/


  _VOID   UmResultMark( low_type _PTR  pLowData )
    {
     p_POINTS_GROUP  pGroupsBorder = pLowData->pGroupsBorder ;
     p_UM_MARKS      pUmMarks      = pLowData->pUmMarksControl->pUmMarks    ;
      _SHORT         tmpUMnumber   = pLowData->pUmMarksControl->tmpUMnumber ;
     p_SPECL         pSpecl        = pLowData->specl                        ;
      _SHORT         termSpecl     = pLowData->pUmMarksControl->termSpecl1  ;

     p_UM_MARKS      pUmTmpMarks   ;
     p_SPECL         pSpeclBeg     ;
     p_SPECL         pSpeclElem    ;
      _SHORT         il , jl       ;
      _SHORT         UmiBeg        ;
      _SHORT         UmSpBeg       ;

       for  ( il = 0 ;  il < tmpUMnumber ;  il++ )
         {
           pUmTmpMarks = pUmMarks + il ;

             if  (     ( pUmTmpMarks->UmEls > pUmTmpMarks->ElsUm )
                   &&  ( pUmTmpMarks->UmDot > pUmTmpMarks->DotUm )
                   &&  ( pUmTmpMarks->UmStr > pUmTmpMarks->StrUm ) )
                 {
                     #if PG_DEBUG
                     //  pLowData->rc->low_deb = LOW_DEB_ON ;
                     #endif

                   UmiBeg = (pGroupsBorder + pUmTmpMarks->GroupNum)->iBeg ;

                     for  ( jl = 0 ;  jl < termSpecl ;  jl++ )
                       {
                         pSpeclBeg = pSpecl + jl ;

                           if  ( pSpeclBeg->mark == SHELF  )
                               {
                                 if ( GetGroupNumber( pLowData,  pSpeclBeg->ibeg )
                                                      == pUmTmpMarks->GroupNum )
                                    {
                                      DestroySpeclElements( pLowData, jl, jl ) ;
                                      jl-- ;
                                    }
                               }


                           if  (     ( pSpeclBeg->mark == BEG    )
                                 &&  ( pSpeclBeg->ibeg == UmiBeg )
								 &&  jl < termSpecl-1 )
                               {
                                 UmSpBeg    = jl ;
                                 pSpeclElem = pSpeclBeg + 1 ;

                                   if  (   ( pSpeclElem->mark == STROKE )
                                        || ( pSpeclElem->mark == DOT )  )
                                       {
                                         pSpeclElem->mark    = DOT        ;
                                         pSpeclElem->other   = ST_CEDILLA ;
                                         pSpeclElem->ipoint0 = UNDEF      ;
                                         pSpeclElem->ipoint1 = UNDEF      ;

                                          /*
                                           if  ( pUmTmpMarks->PositionFeature
                                                           == SHIFTED_POSITION )
                                               {
                                                 pSpeclElem->other =
                                                         ST_CEDILLA | CEDILLA_END ;
                                               }
                                          */

                                           if  ( pUmTmpMarks->PositionFeature
                                                                  == MID_LAST  )
                                               {
                                                 pSpeclElem->other =
                                                      ST_CEDILLA | CEDILLA_END ;
                                               }

                                         jl += 2 ;
                                       }
                                   else
                                       {
                                         pSpeclElem->mark    = DOT        ;
                                         pSpeclElem->other   = ST_CEDILLA ;
                                         pSpeclElem->ipoint0 = UNDEF      ;
                                         pSpeclElem->ipoint1 = UNDEF      ;

                                       { // GIT - save cross point for future
                                         p_SPECL pCross;
                                         _INT UmiEnd=(pGroupsBorder+pUmTmpMarks->GroupNum)->iEnd;
                                         if(find_CROSS(pLowData,UmiBeg,(_SHORT)UmiEnd,&pCross))
                                          pSpeclElem->ipoint0=MID_POINT(pCross->next);
                                       }
                                         /*
                                           if  ( pUmTmpMarks->PositionFeature
                                                        == SHIFTED_POSITION   )
                                               {
                                                 pSpeclElem->other =
                                                     ST_CEDILLA | CEDILLA_END ;
                                               }

                                         */

                                           if  ( pUmTmpMarks->PositionFeature
                                                                  == MID_LAST )
                                               {
                                                 pSpeclElem->other =
                                                     ST_CEDILLA | CEDILLA_END ;
                                               }

                                           while( jl < termSpecl && ( pSpecl + jl++ )->mark != END ) ;


                                         pSpeclElem->iend =
                                                    (pSpecl + jl - 1)->iend ;



                                         DestroySpeclElements( pLowData    ,
                                                               UmSpBeg + 2 ,
                                                               jl - 2    ) ;

                                         UmIntersectDestroy( pLowData  ,
                                         pUmTmpMarks->GroupNum ) ;

                                       }
                               }
                       }

               break ;
           }
         }
    return ;
    }

 /*------------------------------------------------------------------------*/


  _VOID   DestroySpeclElements( low_type _PTR    pLowData ,
                               _SHORT   iBeg ,  _SHORT   iEnd )
    {
      _SHORT   termSpecl1  = pLowData->pUmMarksControl->termSpecl1 ;
      _SHORT   termSpecl   = pLowData->pUmMarksControl->termSpecl  ;
     p_SPECL   pSpecl      = pLowData->specl     ;
      _SHORT   numElements = iEnd - iBeg + 1     ;
      _SHORT   lenSpecl    = pLowData->len_specl ;
     p_SPECL   pTmpSpecl   ;
      _SHORT   il ;

		 ASSERT(lenSpecl >= iEnd && lenSpecl > iBeg);

		 if (iEnd >= lenSpecl || iBeg > lenSpecl)
		 {
			 return;
		 }

         HWRMemCpy( ( pSpecl + iBeg ) , ( pSpecl + iEnd + 1 ) ,
                    ( ( lenSpecl - iEnd ) * sizeof(SPECL) ) ) ;

         pLowData->len_specl = lenSpecl = pLowData->len_specl - numElements ;
         pLowData->LastSpeclIndex       = pLowData->len_specl - 1 ;

           if   ( termSpecl1 > iEnd )
                {
                  termSpecl1 -= numElements ;
                }
           else   if   ( termSpecl1 >= iBeg )
                {
                  termSpecl1 = iBeg ;
                }

         pLowData->pUmMarksControl->termSpecl1 = termSpecl1 ;


           if   ( termSpecl  > iEnd )
                {
                  termSpecl  -= numElements ;
                }
           else   if   ( termSpecl >= iBeg )
                {
                  termSpecl = iBeg  ;
                }

         pLowData->pUmMarksControl->termSpecl = termSpecl ;

           for  (  il = iBeg - 1  ; il < lenSpecl ;  il++ )
             {
               pTmpSpecl       = pSpecl + il ;
               pTmpSpecl->prev = pTmpSpecl - 1 ;
               pTmpSpecl->next = pTmpSpecl + 1 ;
             }

         pSpecl->prev    = _NULL ;
         pTmpSpecl->next = _NULL ;

    return ;
    }

 /*------------------------------------------------------------------------*/

  _VOID  GetBoxMarks(  p_UM_MARKS  pUmMarks , _SHORT dX , _SHORT dY  )
     {
      _USHORT  il , jl  ;

      il = FetchTableNumber( dY, (p_UCHAR)BoxScale , SCALE_Y_ELS_DIMENSION ) ;
      jl = FetchTableNumber( dX, (p_UCHAR)BoxScale , SCALE_X_ELS_DIMENSION ) ;
      pUmMarks->UmEls = (_CHAR)CdElsMarks[il][jl].single_mark ;
      pUmMarks->ElsUm = (_CHAR)( F_MAX_MARK - pUmMarks->UmEls ) ;

      il = FetchTableNumber( dY, (p_UCHAR)BoxScale , SCALE_Y_DOT_DIMENSION ) ;
      jl = FetchTableNumber( dX, (p_UCHAR)BoxScale , SCALE_X_DOT_DIMENSION ) ;
      pUmMarks->UmDot = (_CHAR)CdDotMarks[il][jl].single_mark ;
      pUmMarks->DotUm = (_CHAR)( F_MAX_MARK - pUmMarks->UmDot ) ;

      il = FetchTableNumber( dY, (p_UCHAR)BoxScale , SCALE_Y_STR_DIMENSION ) ;
      jl = FetchTableNumber( dX, (p_UCHAR)BoxScale , SCALE_X_STR_DIMENSION ) ;
      pUmMarks->UmStr = (_CHAR)CdStrMarks[il][jl].single_mark ;
      pUmMarks->StrUm = (_CHAR)( F_MAX_MARK - pUmMarks->UmStr ) ;

     return  ;
     }

 /*------------------------------------------------------------------------*/

  _SHORT  GetMarks( p_BIT_MARK_TABLE_CONTROL  pMarksTableControl ,
		     _SHORT dX ,  _SHORT dN    )
     {
       p_BIT_MARK  pMarksTable = pMarksTableControl->pBitMarkTable ;

       _SHORT      mColumns    = pMarksTableControl->mColumns      ;
       _SHORT      ExtrMark    ;
       _USHORT     il , jl     ;

          jl = FetchTableNumber( dN , pMarksTableControl->pXScale ,
                                 pMarksTableControl->mColumns     ) ;

            if  ( ( dX == UNDEF ) ||
                  ( pMarksTableControl->pYScale == (p_UCHAR)_NULL ) )
                {
                   ExtrMark = (_SHORT)( (pMarksTable + jl)->single_mark ) ;
                }
            else
                {
                  il = FetchTableNumber( dX , pMarksTableControl->pYScale ,
                                         pMarksTableControl->nLines    )  ;
                  ExtrMark = (_SHORT)
                      ( ( pMarksTable + il * mColumns + jl )->single_mark ) ;
                }

     return( ExtrMark )   ;
     }

 /*------------------------------------------------------------------------*/

  _SHORT  InterMarks( _CHAR dN , p_BIT_MARK  pInterTable )
     {
      _SHORT   InterMark ;
      _USHORT  il        ;

        for  ( il = 0  ;  il < SCALE_INT_DIMENSION  ; il++ )
          {
            if   (  IntScale[il] == dN  )
              break ;
          }

        if   ( il  ==  SCALE_INT_DIMENSION )
          {
            err_msg ( " InterMarks : Wrong intersections descriptions ..." ) ;
            InterMark = ONE_HALF( F_MAX_MARK ) ;
          }
        else
          {
            InterMark = (_SHORT)( (pInterTable + il)->single_mark ) ;
          }

     return( InterMark )   ;
     }

 /*------------------------------------------------------------------------*/

  _SHORT  FetchTableNumber( _SHORT dX, p_UCHAR Scale, _SHORT ScaleDimension )
     {
       _SHORT  iTab ;

         if  ( dX < (_SHORT)Scale[0] )
           {
             iTab = 0  ;
             err_msg ( " FetchTable : NumberWrong Scale index ... " ) ;
           }
         else  if   ( dX >= (_SHORT)Scale[ ScaleDimension - 1 ]  )
           {
             iTab = ScaleDimension - 1 ;
           }
	       else
           {
             for  ( iTab = 0 ; iTab < ScaleDimension ; iTab++ )
               {
                 if   (     ( dX >= (_SHORT)Scale[ iTab ]    )
                        &&  ( dX <  (_SHORT)Scale[ iTab + 1] ) )
                      {
                        break ;
                      }
               }
           }

     return( iTab ) ;
     }


 /*------------------------------------------------------------------------*/



 /**************************************************************************/

  #if PG_DEBUG

  _VOID   UmInfoTypePaint(  low_type _PTR  pLowData   ,
			      #ifdef  FILE_TESTING
				FILE       *debUmInfo ,
			      #endif
			    p_UM_MARKS     pUmTmpMarks, p_UM_MARKS  pBoxMarks ,
			    p_UM_MARKS     pExtMarks  , p_UM_MARKS  pIntMarks )
    {
      p_POINTS_GROUP   pGroupsBorder = pLowData->pGroupsBorder                ;
      p_SHORT          xArr          = pLowData->x                            ;
      p_SHORT          yArr          = pLowData->y                            ;
      _SHORT           GroupNum      ;

    #ifdef  FILE_TESTING
      _SHORT           KeyCode       ;
    #endif

	GroupNum    = pUmTmpMarks->GroupNum  ;

	draw_arc( EGA_MAGENTA , xArr , yArr  ,
		  ( pGroupsBorder + GroupNum )->iBeg ,
		  ( pGroupsBorder + GroupNum )->iEnd ) ;

	OpenTextWindow(11) ;

	printw( "\n bUmEls: %2d  bElsUm: %2d   bUmDot: %2d  bDotUm: %2d   "\
		  " bUmStr: %2d  bStrUm: %2d   bUmCom: %2d  bComUm: %2d"  ,
		    (_SHORT)pBoxMarks->UmEls , (_SHORT)pBoxMarks->ElsUm   ,
		    (_SHORT)pBoxMarks->UmDot , (_SHORT)pBoxMarks->DotUm   ,
		    (_SHORT)pBoxMarks->UmStr , (_SHORT)pBoxMarks->StrUm   ,
		    (_SHORT)pBoxMarks->UmCom , (_SHORT)pBoxMarks->ComUm ) ;

	printw( "\n eUmEls: %2d  eElsUm: %2d   eUmDot: %2d  eDotUm: %2d   "\
		  " eUmStr: %2d  eStrUm: %2d   eUmCom: %2d  eComUm: %2d"  ,
		    (_SHORT)pExtMarks->UmEls , (_SHORT)pExtMarks->ElsUm   ,
		    (_SHORT)pExtMarks->UmDot , (_SHORT)pExtMarks->DotUm   ,
		    (_SHORT)pExtMarks->UmStr , (_SHORT)pExtMarks->StrUm   ,
		    (_SHORT)pExtMarks->UmCom , (_SHORT)pExtMarks->ComUm ) ;

	printw( "\n iUmEls: %2d  iElsUm: %2d   iUmDot: %2d  iDotUm: %2d   "\
		  " iUmStr: %2d  iStrUm: %2d   iUmCom: %2d  iComUm: %2d"  ,
		    (_SHORT)pIntMarks->UmEls , (_SHORT)pIntMarks->ElsUm   ,
		    (_SHORT)pIntMarks->UmDot , (_SHORT)pIntMarks->DotUm   ,
		    (_SHORT)pIntMarks->UmStr , (_SHORT)pIntMarks->StrUm   ,
		    (_SHORT)pBoxMarks->UmCom , (_SHORT)pBoxMarks->ComUm ) ;

	printw( "\n rUmEls: %2d  rElsUm: %2d   rUmDot: %2d  rDotUm: %2d   "\
		  " rUmStr: %2d  rStrUm: %2d   rUmCom: %2d  rComUm: %2d"   ,
		     (_SHORT)pUmTmpMarks->UmEls , (_SHORT)pUmTmpMarks->ElsUm ,
		     (_SHORT)pUmTmpMarks->UmDot , (_SHORT)pUmTmpMarks->DotUm ,
		     (_SHORT)pUmTmpMarks->UmStr , (_SHORT)pUmTmpMarks->StrUm ,
		     (_SHORT)pUmTmpMarks->UmCom , (_SHORT)pUmTmpMarks->ComUm ) ;

  //      printw( "\n numMin  : %d " ,   pUmTmpMarks->numMin  ) ;

  /*
	  switch( (_SHORT)pUmTmpMarks->PositionFeature  )
	      {
	      case   (_SHORT)FIRST_POSITION   :  printw("\n   FIRST   ") ;
						   break ;

	      case   (_SHORT)MIDDLE_POSITION  :  printw("\n   MIDDLE  ") ;
						   break ;

	      case   (_SHORT)SHIFTED_POSITION :  printw("\n   SHIFTED ") ;
						   break ;

	      case   (_SHORT)END_POSITION     :  printw("\n   END     ") ;
						   break ;

	      default                         :  printw("\n   COMMON  ") ;
						   break ;
	      }
  */


	  if  ( pUmTmpMarks->CrossFeature  == (_CHAR)END_LAST )
	      {
          printw("\n   END_LAST " );
	      }
	  else  if  ( pUmTmpMarks->CrossFeature  == (_CHAR)MID_LAST )
	      {
          printw("\n   MID_LAST     " );
	      }
	  else
	      {
          printw("\n   COMMON     " );
	      }


	  if  ( pUmTmpMarks->CrossFeature  == (_CHAR)INTERSECTED )
	      {
          printw("   INTERSECTED " );
	      }
	  else
	      {
          printw("   ISOLATE     " );
	      }

 //     TypeCodedHeight(  (_UCHAR)pUmTmpMarks->bH ) ;

	TypeCodedHeight(  (_UCHAR)pUmTmpMarks->tH ) ;

    #ifdef  FILE_TESTING

	KeyCode = (_SHORT)((_UCHAR)brkeyw("\n Press key :  U-umlaut   E-element of letter   D-dot   S-stroke" )) ;

	  switch( KeyCode  )
	    {
	      case   (_SHORT)'u' :
	      case   (_SHORT)'U' :

	      case   (_SHORT)'e' :
	      case   (_SHORT)'E' :

	      case   (_SHORT)'d' :
	      case   (_SHORT)'D' :

	      case   (_SHORT)'s' :
	      case   (_SHORT)'S' :

		 fprintf( debUmInfo  , "\n %c   %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d, %3d," ,
			  (_UCHAR)KeyCode,
			  (_SHORT)pBoxMarks->UmEls, (_SHORT)pBoxMarks->ElsUm,
			  (_SHORT)pBoxMarks->UmDot, (_SHORT)pBoxMarks->DotUm,
			  (_SHORT)pBoxMarks->UmStr, (_SHORT)pBoxMarks->StrUm,
			  (_SHORT)pExtMarks->UmEls, (_SHORT)pExtMarks->ElsUm,
			  (_SHORT)pExtMarks->UmDot, (_SHORT)pExtMarks->DotUm,
			  (_SHORT)pExtMarks->UmStr, (_SHORT)pExtMarks->StrUm,
			  (_SHORT)pIntMarks->UmEls, (_SHORT)pIntMarks->ElsUm,
			  (_SHORT)pIntMarks->UmDot, (_SHORT)pIntMarks->DotUm,
			  (_SHORT)pIntMarks->UmStr, (_SHORT)pIntMarks->StrUm,

			  (_SHORT)pUmTmpMarks->UmEls, (_SHORT)pUmTmpMarks->ElsUm ,
			  (_SHORT)pUmTmpMarks->UmDot, (_SHORT)pUmTmpMarks->DotUm ,
			  (_SHORT)pUmTmpMarks->UmStr, (_SHORT)pUmTmpMarks->StrUm ) ;

	      default :  break ;
	    }

    #else
	bioskey(0) ;
    #endif

	draw_arc( EGA_LIGHTBLUE , xArr , yArr  ,
		  ( pGroupsBorder + GroupNum )->iBeg ,
		  ( pGroupsBorder + GroupNum )->iEnd ) ;

	CloseTextWindow() ;

    return ;
    }

 /*------------------------------------------------------------------------*/

  #define        CODE_STRING_LENTH          6


  _VOID  BoxOutline( p_RECT pBox )
    {
      draw_line( pBox->left  , pBox->top    ,
                 pBox->left  , pBox->bottom ,
                 COLORC, SOLID_LINE, NORM_WIDTH ) ;

      draw_line( pBox->right , pBox->top    ,
                 pBox->right , pBox->bottom ,
                 COLORC, SOLID_LINE, NORM_WIDTH ) ;

      draw_line( pBox->left  , pBox->top    ,
                 pBox->right , pBox->top    ,
                 COLORC, SOLID_LINE, NORM_WIDTH ) ;

      draw_line( pBox->left  , pBox->bottom ,
                 pBox->right , pBox->bottom ,
                 COLORC, SOLID_LINE, NORM_WIDTH ) ;
    return ;
    }


 /*------------------------------------------------------------------------*/

  _VOID  HeightEncode( _UCHAR  tmpHeight , p_STR  pCodedHeight )
    {
      if        ( tmpHeight ==  _US1_ )    *pCodedHeight =  "_US1_"  ;
      else  if  ( tmpHeight ==  _US2_ )    *pCodedHeight =  "_US2_"  ;
      else  if  ( tmpHeight ==  _UE1_ )    *pCodedHeight =  "_UE1_"  ;
      else  if  ( tmpHeight ==  _UE2_ )    *pCodedHeight =  "_UE2_"  ;
      else  if  ( tmpHeight ==  _UI1_ )    *pCodedHeight =  "_UI1_"  ;
      else  if  ( tmpHeight ==  _UI2_ )    *pCodedHeight =  "_UI2_"  ;
      else  if  ( tmpHeight ==  _MD_  )    *pCodedHeight =  "_MD_"   ;
      else  if  ( tmpHeight ==  _DI1_ )    *pCodedHeight =  "_DI1_"  ;
      else  if  ( tmpHeight ==  _DI2_ )    *pCodedHeight =  "_DI2_"  ;
      else  if  ( tmpHeight ==  _DE1_ )    *pCodedHeight =  "_DE1_"  ;
      else  if  ( tmpHeight ==  _DE2_ )    *pCodedHeight =  "_DE2_"  ;
      else  if  ( tmpHeight ==  _DS1_ )    *pCodedHeight =  "_DS1_"  ;
      else  if  ( tmpHeight ==  _DS2_ )    *pCodedHeight =  "_DS2_"  ;
      else
          err_msg( " HeightEncode : Illegal relative height ... "  ) ;

    return ;
    }

 /*------------------------------------------------------------------------*/


  _VOID  TypeCodedHeight( _UCHAR  tmpHeight )
    {
      p_STR  pCodedHeight ;

        pCodedHeight =
                       (p_STR)HWRMemoryAlloc(
                       (_ULONG)sizeof(_UCHAR) * CODE_STRING_LENTH   ) ;

          if  (  pCodedHeight == _NULL )
            {
             err_msg(" TypeCodedHeight : No memory for typing buffer ... " ) ;
               goto  QUIT ;
            }

        HeightEncode( tmpHeight , pCodedHeight ) ;
        printw( "\n   Relative Height :  %s " , *pCodedHeight ) ;

        HWRMemoryFree( pCodedHeight ) ;

    QUIT:  return  ;
    }

  #endif      /* PG_DEBUG */


 /*------------------------------------------------------------------------*/

  #undef     INTERSECTED
  #undef     ISOLATE

  #undef     UPPER_UM_LIMIT
  #undef     LOWER_UM_LIMIT
  #undef     F_MAX_MARK
  #undef     NUM_UML_MIN

  #undef     FIRST_STRK
  #undef     END_POS
  #undef     COMMON_POS

 /****************************************************************************/

#endif /* FOR_FRENCH || FOR_INTERNATIONAL */

#endif // #ifndef LSTRIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\sources.inc ===
INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\bear\inc; \
          $(_TPG_ROOT)\hwx\common\inc; \
          $(_TPG_ROOT)\hwx\inferno\src; \
          $(_TPG_ROOT)\hwx\holycow\src; \
          $(_TPG_ROOT)\hwx\wisp\inc; \
          $(_TPG_ROOT)\hwx\madcow\src; \
          $(_TPG_ROOT)\hwx\avalanche\src; \

SOURCES = \
        ..\Angle.cpp \
        ..\Arcs.cpp \
        ..\bear.c \
        ..\bearapi.c \
        ..\bearp.c \
        ..\BITMAPCO.cpp \
        ..\Breaks.cpp \
        ..\calccell.cpp \
        ..\Check.cpp \
        ..\Circle.cpp \
        ..\commondict.c \
        ..\Convert.cpp \
        ..\Countxr.cpp \
        ..\Cross.cpp \
        ..\Cross_g.cpp \
        ..\Dct.cpp \
        ..\Div_let.cpp \
        ..\Dscr.cpp \
        ..\Dti_img.cpp \
        ..\Dti_util.cpp \
        ..\El_aps.cpp \
        ..\Filter.cpp \
        ..\Frm_word.cpp \
        ..\Get_bord.cpp \
        ..\Hwr_math.cpp \
        ..\Hwr_mem.cpp \
        ..\Hwr_std.cpp \
        ..\Hwr_str.cpp \
        ..\Hwr_stri.cpp \
        ..\Ldbutil.cpp \
        ..\ligstate.cpp \
        ..\Links.cpp \
        ..\Lk_begin.cpp \
        ..\Lk_next.cpp \
        ..\Low_3.cpp \
        ..\Low_util.cpp \
        ..\Lu_specl.cpp \
        ..\Mlp.cpp \
        ..\Palk.cpp \
        ..\Parakern.cpp \
        ..\Paralibs.cpp \
        ..\Param.cpp \
        ..\Peg_util.cpp \
        ..\Pegrec.cpp \
        ..\Pict.cpp \
        ..\Polyco.cpp \
        ..\Precutil.cpp \
        ..\PREP.cpp \
        ..\Sketch.cpp \
        ..\Snn_img.cpp \
        ..\Specwin.cpp \
        ..\Stroka.cpp \
        ..\Stroka1.cpp \
        ..\Tr_util.cpp \
        ..\Trd_img.cpp \
        ..\Ws.cpp \
        ..\Xr_attr.cpp \
        ..\Xr_mc.cpp \
        ..\Xr_rwg.cpp \
        ..\Xrlv.cpp \
        ..\Xrw_util.cpp \
        ..\Xrwdictp.cpp \
        ..\Zctabs.cpp \
        ..\Zctype.cpp \
        ..\spcnet.c \
        ..\xrnet.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\snn_imge.cpp ===
// **************************************************************************
// *   NNET file as Cpp file                                                *
// **************************************************************************

#include "snn.h"  

#if MLP_PRELOAD_MODE  

#include "mlp.h"  

#if MLP_CELL_MAXINPUTS != 32 || MLP_NET_NUMSIGNALS != 722 
 #error Wrong NET configuration!
#endif

// ****   NET body   ********************************************************

ROM_DATA mlp_net_type img_snet_body = 
 {
   {"MLP.Network.V.4.12.e"},
   4,
   288,
   92,
   {2057,2073,2089,2105,2121,2137,2153,2169,2185,2201,2217,2233,2248,2264,2280,2296,2312,2327,2343,2359,2374
    ,2390,2405,2421,2436,2452,2467,2482,2498,2513,2528,2543,2558,2573,2588,2603,2618,2632,2647,2662,2676
    ,2691,2705,2719,2734,2748,2762,2776,2790,2804,2817,2831,2845,2858,2872,2885,2898,2912,2925,2938,2951
    ,2963,2976,2989,3001,3014,3026,3039,3051,3063,3075,3087,3099,3110,3122,3134,3145,3156,3168,3179,3190
    ,3201,3212,3223,3233,3244,3254,3265,3275,3285,3295,3305,3315,3325,3335,3344,3354,3363,3373,3382,3391
    ,3400,3409,3418,3427,3436,3444,3453,3461,3469,3478,3486,3494,3502,3510,3518,3525,3533,3540,3548,3555
    ,3563,3570,3577,3584,3591,3598,3605,3611,3618,3624,3631,3637,3644,3650,3656,3662,3668,3674,3680,3686
    ,3691,3697,3703,3708,3714,3719,3724,3730,3735,3740,3745,3750,3755,3760,3764,3769,3774,3778,3783,3787
    ,3792,3796,3801,3805,3809,3813,3817,3821,3825,3829,3833,3837,3841,3844,3848,3852,3855,3859,3862,3865
    ,3869,3872,3875,3879,3882,3885,3888,3891,3894,3897,3900,3903,3906,3909,3911,3914,3917,3919,3922,3925
    ,3927,3930,3932,3935,3937,3939,3942,3944,3946,3948,3951,3953,3955,3957,3959,3961,3963,3965,3967,3969
    ,3971,3973,3975,3977,3978,3980,3982,3984,3985,3987,3989,3990,3992,3993,3995,3996,3998,3999,4001,4002
    ,4004,4005,4006,4008,4009,4010,4012,4013,4014,4015,4017,4018,4019,4020,4021,4023,4024,4025,4026,4027
    ,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4038,4039,4040,4041,4042,4043,4043,4044,4045
    ,4046,4047,4047,4048,4049,4050,4050,4051,4052,4052,4053,4054,4054,4055,4055,4056,4057,4057,4058,4058
    ,4059,4060,4060,4061,4061,4062,4062,4063,4063,4064,4064,4065,4065,4066,4066,4067,4067,4067,4068,4068
    ,4069,4069,4070,4070,4070,4071,4071,4072,4072,4072,4073,4073,4073,4074,4074,4074,4075,4075,4075,4076
    ,4076,4076,4077,4077,4077,4077,4078,4078,4078,4078,4079,4079,4079,4079,4080,4080,4080,4080,4081,4081
    ,4081,4081,4082,4082,4082,4082,4082,4083,4083,4083,4083,4083,4084,4084,4084,4084,4084,4084,4085,4085
    ,4085,4085,4085,4085,4086,4086,4086,4086,4086,4086,4087,4087,4087,4087,4087,4087,4087,4087,4088,4088
    ,4088,4088,4088,4088,4088,4088,4088,4089,4089,4089,4089,4089,4089,4089,4089,4089,4090,4090,4090,4090
    ,4090,4090,4090,4090,4090,4090,4090,4090,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091
    ,4091,4091,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092
    ,4092,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093
    ,4093,4093,4093,4093,4093,4093,4093,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094
    ,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094   },

   {
// *********** Cells of layer 1 *********************************************

     {
      434,
      -296,
      {542,-195,7138,-1250,1656,-553,-3015,-3468,1497,-610,-3078,-1113,-1976,-485,4761,-3442,-995,-869,-649,-2093,6473,320,3671,-99,-1296,-1925,2199,376,762,389,-1715,-11409}
     },
     {
      434,
      1107,
      {806,2001,502,2196,-6449,1355,-5161,-805,320,-136,2532,-2192,-565,-1735,887,321,1257,-77,-153,222,471,856,1725,-6895,3341,-2224,-1385,196,233,-438,-1116,4994}
     },
     {
      434,
      1862,
      {293,1181,-576,457,1145,-5087,-1610,-3335,-252,-3024,-302,-1483,539,-2508,1727,-2009,673,-2082,1254,552,2026,574,845,208,1495,-137,-1824,757,1534,-1093,1742,-6611}
     },
     {
      434,
      2092,
      {-26,442,1647,-465,-600,-852,-450,1996,-1419,38,3610,-1720,-483,3654,-1965,1678,-869,-2905,1162,59,-120,-9618,775,58,-7812,1462,-203,-1414,1447,3685,649,2836}
     },
     {
      434,
      -2644,
      {-1357,10660,2933,-1605,-1742,-2231,797,441,588,-1763,-599,-526,-3233,-1069,2275,-2693,-1502,1470,2068,398,827,1590,1490,-2991,169,-1565,-616,-210,-2025,-1781,-2545,5303}
     },
     {
      434,
      1107,
      {-797,213,2872,424,3791,-226,668,546,328,-4776,-1037,997,-7743,1126,564,-8953,-62,-353,-2616,1129,1170,827,-274,2661,-2235,-1291,1195,906,-324,2333,2736,-2766}
     },
     {
      434,
      1400,
      {-1358,612,2984,-1265,5169,-4897,-499,-2543,-3513,413,-556,-1345,1920,-2973,-626,-256,-466,-1147,2021,-3744,452,2070,438,-1606,3300,850,1522,-2203,-1144,-580,804,62}
     },
     {
      434,
      -2357,
      {178,279,-70,41,-525,-2149,-1824,1472,3610,138,-569,368,3890,873,-406,-1247,-245,3117,1570,1899,-1561,1152,81,-537,-1010,-608,-386,2321,-2493,-2421,120,8899}
     },
     {
      434,
      -325,
      {1582,172,138,-1908,-4191,-2690,-818,-713,2669,4248,3435,-1999,-3234,-3476,-1183,-1209,-606,463,3708,-43,4115,-2646,-778,-1738,2293,-403,1763,1602,-262,-820,568,-1072}
     },
     {
      434,
      -3447,
      {254,8520,-608,160,1563,-1415,-1692,594,-57,828,-3058,-4167,5069,-1750,350,496,-3780,-193,1995,3305,3864,-2197,-915,-2351,1599,-2237,1032,-1890,-2618,-675,1736,-2377}
     },
     {
      434,
      1962,
      {-2460,1759,-85,75,-847,487,-2851,1754,-1542,399,470,-5717,-2478,104,538,471,3386,-2788,-2778,239,1704,-418,1074,-3078,1435,64,-50,292,1609,-2418,-222,-1552}
     },
     {
      434,
      -132,
      {1050,40,-372,2212,-153,-2777,-7633,-1591,-492,5755,1276,-1183,-1036,-431,1070,2184,-276,-2042,152,1608,-524,1679,-1362,-74,-636,-771,2470,325,153,-215,-2486,2544}
     },
     {
      434,
      4158,
      {554,1250,1214,-1137,2147,1629,-5872,-1873,-4148,-1365,3944,2400,-1715,1687,-7005,-843,3911,2932,-4444,-239,-4618,-525,357,1292,-4323,1494,608,1464,1984,-2682,-4552,2555}
     },
     {
      434,
      673,
      {2391,1234,938,-1123,-2821,5765,-1717,-2827,589,-1297,17,-3584,321,904,443,567,1198,-1482,-555,1211,134,-818,1009,-1969,-1065,-250,-1540,2063,2067,-2645,-2043,-3965}
     },
     {
      434,
      -836,
      {-760,-220,8797,-3882,-2198,-1068,2218,3718,-860,3145,-516,458,3713,-458,127,-6193,1301,-122,-4176,-802,1261,-91,1818,1785,1967,956,-1199,-6160,-1460,-1685,452,-4049}
     },
     {
      434,
      620,
      {-387,911,4085,-1412,1083,-1176,-167,-1128,881,-683,-2876,886,-86,1490,-10596,-1067,1494,4739,3539,1895,7039,-4871,-1070,969,-3372,-1340,-3411,-1992,1506,-2902,2288,4130}
     },
     {
      434,
      -3855,
      {2119,-274,5948,-2085,-3351,3353,1812,-940,1848,167,-532,4545,-966,-3954,1397,-2593,-2637,291,1581,-2092,-1157,-618,-427,102,4171,-1379,-98,574,-270,1233,2754,-2712}
     },
     {
      434,
      -3136,
      {734,698,816,909,359,-851,-218,1126,1075,-1155,-2934,-5703,-268,3830,3223,3032,-2899,1412,2027,409,-2550,-4814,-3036,2119,6846,-1140,-104,-2788,-865,3492,959,-3535}
     },
     {
      434,
      -2135,
      {1210,890,8031,-744,-866,-638,2032,-1715,1665,-4550,-93,-3989,-88,-2969,4034,3456,-27,-3215,3469,-101,2739,368,-2256,-67,373,342,1427,635,-1181,-1629,-452,911}
     },
     {
      434,
      154,
      {-3663,450,214,-1122,-2270,-1462,-1975,-4633,4509,-764,4759,49,136,-37,-3563,1799,-248,584,-930,4178,2420,515,-3363,-1352,102,-581,-1649,-838,1068,-773,25,-4829}
     },
     {
      434,
      119,
      {74,-522,544,-1823,-93,-1872,-7053,-405,4497,-1287,1164,-4390,546,801,2869,-1059,502,-2663,86,2605,3667,1850,-1430,-1025,-1684,-1115,-48,-1155,-669,2941,-1106,5014}
     },
     {
      434,
      198,
      {420,4148,-1665,-73,3312,227,-5866,-2391,1097,-1326,-3553,-737,247,-2363,3159,-211,629,-3301,-1284,-2205,567,2567,-916,251,102,-404,-447,3948,-502,1978,-2448,426}
     },
     {
      434,
      -990,
      {-984,796,1258,3745,-1479,906,-538,582,-4663,906,-2073,4395,1568,-1665,-1252,-1395,-179,-2882,4120,-3088,1524,2205,2647,391,-1202,-3198,441,-1180,-1345,1177,-1042,2346}
     },
     {
      434,
      1612,
      {546,-2643,-191,-3836,174,-497,-2677,-23,-107,-2615,-72,-3776,923,-180,2318,-1093,3269,-2254,454,-650,95,937,1958,2153,-1421,1206,-1980,347,1856,769,803,-2834}
     },
     {
      434,
      1035,
      {-893,-125,2929,-1719,-1540,294,125,851,-673,-27,-362,-2690,-994,-754,4460,-2950,-1257,-11374,95,1425,8508,-2251,2523,-658,-2854,1718,-1082,-832,576,1115,2649,8915}
     },
     {
      434,
      3754,
      {3001,-348,3066,-26,2148,39,-4058,-633,-1059,-1491,-314,-1911,1343,1511,-5065,308,639,-10365,-497,253,-375,-134,606,3512,-995,-247,588,-2231,2615,-1027,-486,11151}
     },
     {
      434,
      2483,
      {3164,-861,759,908,631,-2772,-1456,-2911,-559,-1361,2879,2254,-612,-2379,-1811,1893,585,4377,-346,-1604,3292,331,-1358,-906,-3167,2611,-963,-700,278,-1709,-3557,9790}
     },
     {
      434,
      3123,
      {-4222,-760,1251,-449,3678,1379,-1666,1999,1178,-2753,858,-361,-2216,-304,-3789,-2986,193,3288,-423,-3162,-2792,-1446,1161,1485,-696,1002,-1269,-359,1552,960,43,8401}
     },
     {
      434,
      2548,
      {-2660,664,-1791,-1570,-2824,-3381,-174,2400,834,751,1057,-641,-2731,194,-487,-373,4091,-3645,-3809,-702,8712,-2190,1998,-1922,3435,1061,-3507,3475,-145,-5252,-1868,9160}
     },
     {
      434,
      -502,
      {-167,325,2754,-572,-156,-1653,-2776,-454,-161,1223,1596,-4927,286,1156,1089,-6312,-2020,6779,841,-1084,-3241,2677,-217,591,-1133,0,433,97,1098,-1281,262,1196}
     },
     {
      434,
      3613,
      {281,388,-370,2834,606,-3000,697,-5026,1308,-1284,2918,-5098,547,1031,-2671,-554,868,-1748,-3092,206,-2895,191,3973,-5102,-1999,2732,4172,-197,4302,-7033,-361,-3240}
     },
     {
      434,
      1539,
      {1455,260,2602,-788,3860,-1039,439,-156,163,-1249,-2766,-75,-2842,604,2707,-1441,-738,-3639,2983,648,-8122,1507,-776,-1227,1532,-4,5977,-3077,751,163,-1502,8272}
     },
     {
      434,
      3225,
      {-2491,311,-202,-224,978,573,-200,3705,121,-278,2500,459,-122,-588,1538,-3908,2249,2710,-12560,-1978,1504,-2436,3240,1431,-2338,1373,-303,-3337,212,-2179,-883,6068}
     },
     {
      434,
      -2539,
      {1422,-94,-478,1659,-1565,59,-1912,-6246,3,-1524,-4751,765,5378,-171,571,11241,618,-2724,4604,-1630,-1252,898,825,1663,381,-2794,3578,-215,-1220,1522,-2990,8910}
     },
     {
      434,
      1076,
      {4301,352,-1449,-261,1913,188,-2086,250,2402,834,-1074,-4937,-667,545,-5497,-2892,-39,-17,1569,1785,-2462,2499,1645,348,130,1111,-1322,389,446,-863,3591,4034}
     },
     {
      434,
      -329,
      {2625,-433,-49,594,-2645,4141,-3497,-5606,2443,-841,-1434,-4363,2964,-1082,-1127,-2301,1817,1508,-871,-2911,1439,3116,1572,1087,-3572,-1911,2361,2132,1014,1337,-428,-2378}
     },
     {
      434,
      -3430,
      {-1682,411,1048,-800,-1977,-522,-1618,-1154,-1763,-2471,-1669,-3065,-404,-1697,-4223,3184,-1770,2519,8194,709,2783,5553,-255,963,273,-1654,1968,1709,-629,-165,-320,-1728}
     },
     {
      434,
      -1812,
      {-2010,-685,-199,-763,-4082,2398,853,-850,3582,-1372,273,-67,4770,-1082,2353,6454,-1660,2569,3402,-4336,-2877,-385,117,-3491,-1856,1418,37,-1641,-304,1514,-2240,1577}
     },
     {
      434,
      -1436,
      {-4402,171,-1363,686,-70,-1612,195,1868,3470,-167,-351,-1764,4256,2512,-2502,-7504,-120,2934,7364,-2228,-2632,-5292,-1237,1682,2375,-230,-3197,-265,143,573,2172,-847}
     },
     {
      434,
      1003,
      {94,-161,-629,-3222,4066,2043,1746,2150,7,2713,-2540,-1927,3007,2615,110,-1484,92,-6209,4095,1488,-1858,-7491,-229,582,-2061,67,-2346,-1277,651,2114,-255,4322}
     },
     {
      434,
      -969,
      {1822,67,-1668,384,740,4749,2358,-2118,635,2397,-2360,4606,1401,-862,635,153,-2567,-2488,264,-2374,-1808,-1736,554,-1495,1624,-1854,3338,-2202,1169,164,-2007,-1263}
     },
     {
      434,
      87,
      {1757,-804,-2151,-172,-1019,3824,-311,1948,4140,1589,-943,-269,1330,-495,3632,-767,228,586,-2606,-879,167,-2887,711,-3497,1461,1136,398,-2077,475,143,-335,848}
     },
     {
      434,
      2635,
      {1437,-34,-2566,-3026,1085,2322,-2142,-1561,-1650,-1993,3392,-4205,-1950,914,-1368,691,1021,-1784,-2053,1686,-1693,1354,-5,-1226,96,2821,-938,-3237,3089,3484,-293,2710}
     },
     {
      434,
      1092,
      {708,169,411,-3367,868,1107,1467,-1690,-2936,1205,2540,-1949,-4070,-452,3719,-981,-1256,-1675,5765,1594,-3091,-5065,105,1002,260,1983,629,634,151,-1579,-995,524}
     },
     {
      434,
      146,
      {3559,-413,4582,-721,-3293,4262,-2519,2330,-1019,2776,2258,-3578,-231,-4318,-2573,-5700,103,665,-3854,1592,-730,1958,-248,1718,907,-909,2384,-711,-593,-65,1254,-238}
     },
     {
      434,
      -1589,
      {1509,-142,4381,-1902,760,7489,-290,3728,1796,-3917,-518,3826,-490,-268,737,-2734,84,703,-2380,378,741,738,-1575,1495,-1572,-990,-192,1122,-2378,-1206,647,-423}
     },
     {
      434,
      1582,
      {-12,-402,1401,-795,1503,899,829,-162,-587,-2616,2583,4773,877,866,-1905,-68,1347,-7562,-928,0,1355,35,879,-2248,-573,-749,-220,-1410,-1539,270,-1423,1736}
     },
     {
      434,
      -200,
      {4001,263,-241,-2119,-3149,2187,1228,-7844,-636,-4011,96,-3437,1844,-1488,2966,2936,1541,566,265,-632,-1997,3730,1108,2835,-2571,-1669,622,1185,1606,-3641,1560,-266}
     },
     {
      434,
      -3254,
      {3495,383,-1250,-1649,211,620,1701,-1104,-861,5860,-8,-196,6158,-261,-1083,4175,-1173,-1070,1128,770,-716,1571,-4291,2,1146,-927,-2775,-1025,-196,3575,-1965,1623}
     },
     {
      434,
      1651,
      {-1357,130,-6826,376,-2416,2489,1026,-4395,-216,-2981,35,-2535,2774,169,-93,-4036,483,2996,1102,174,-2388,-937,2038,2626,1504,-264,195,533,2427,1369,-2653,-2680}
     },
     {
      434,
      3146,
      {1848,77,-4111,485,806,-432,-1043,-4597,1415,2797,2073,-3023,-678,776,446,-6302,34,2377,6596,-1353,-2697,-3950,1693,554,1996,382,-929,-1220,645,1431,1874,-2109}
     },
     {
      434,
      2287,
      {-1442,-216,1654,-3270,1997,2970,1816,-2324,-5066,833,875,-860,355,-3212,-3675,-1400,1029,-1106,-1906,-451,3916,-1435,4778,-708,1228,1448,-1414,-4866,2684,2156,-827,-185}
     },
     {
      434,
      -1439,
      {1145,754,5500,-2365,-3313,3486,-1458,1402,4567,187,182,-2161,3326,-817,285,-2541,-2797,-1557,0,-139,-2300,1684,1055,-1536,-324,-2100,708,1280,-778,900,-915,-888}
     },
     {
      434,
      -666,
      {-1321,36,-1962,-577,538,3186,-726,3382,-670,5890,152,-2699,-376,5031,-837,-2995,-2124,-1357,-1744,715,214,1025,-1425,233,1564,-1800,-2023,-493,-1129,2239,30,2551}
     },
     {
      434,
      3385,
      {6081,605,2633,-1012,-934,-2208,1622,804,-1300,-1261,1116,-4497,-980,-1746,-5087,-3522,3923,-1632,-10866,-1629,4988,-3497,3952,1884,2775,3108,-316,-1721,508,2041,1126,2737}
     },
     {
      434,
      882,
      {6115,-462,2074,1026,3097,2466,563,87,-4158,-2535,-852,4300,944,-193,2341,241,-808,-1182,-3125,-4031,1697,-575,563,-1156,-249,1211,1716,220,198,-3351,-56,11572}
     },
     {
      434,
      0,
      {-219,-38,973,-2346,3632,2208,-1623,3235,-3671,-1099,-2797,-802,2171,1811,3402,-3152,-469,175,-1870,1303,1055,3468,-50,-790,-4563,-617,375,1046,374,-1373,-1813,-5637}
     },
     {
      434,
      654,
      {591,-416,-1633,878,1919,286,-5975,-2203,224,-69,-299,2099,-188,590,-1119,240,-5,-1246,1689,-594,-1041,1608,-798,-741,912,-1496,490,-828,215,143,2127,-741}
     },
     {
      434,
      -2027,
      {334,1218,-3801,864,-154,3346,1855,-909,-1722,940,350,4302,1139,590,-3491,2225,-2001,62,2180,138,-3563,-1538,-2545,1152,3908,372,-2344,904,-2685,2226,-483,-2902}
     },
     {
      434,
      -1040,
      {886,106,-363,1250,-2357,4749,-128,2163,-1816,4343,1983,265,-7307,-874,2446,7456,-294,-1844,-1811,-3985,590,1941,-583,-655,1038,174,-3583,3081,-814,347,174,1111}
     },
     {
      434,
      -1097,
      {700,486,-1372,-2848,1032,-2090,-1818,-1474,-1715,-4274,28,498,-4525,2394,5929,-3770,-782,6539,5170,2488,607,7743,-1289,-2762,-605,-79,-1004,-996,-944,-3564,589,532}
     },
     {
      434,
      450,
      {-714,686,-4993,-4831,205,2293,-1809,1366,4013,4593,-2933,-2826,5819,632,-5545,-2077,1797,-1338,-1027,760,305,-787,802,1446,-370,1743,-5406,-1360,407,-106,1358,-389}
     },
     {
      434,
      -1222,
      {1764,-412,-3161,2178,-2313,3738,790,3253,-2180,1330,1429,-4438,-1110,-2486,3590,-2163,3297,1759,2008,-1597,206,3793,-3188,-482,236,-3501,772,4113,-274,-903,433,11124}
     },
     {
      434,
      848,
      {590,573,-1737,-946,102,686,-906,-1519,-934,-841,987,-95,-4565,-1382,-3282,-5741,182,-2775,-1268,-1160,-1936,3003,1671,-1124,6358,1113,-1074,5027,1848,1082,2550,-1052}
     },
     {
      434,
      -2,
      {32644,-32767,-32745,-32674,8678,29097,-32597,28298,32751,28644,-22378,-32765,-32601,-20250,32744,-32654,32676,31042,-32750,-32728,3592,-28486,-10593,2019,-32720,10718,-18592,-9041,1372,8254,-30005,5146}
     },
     {
      434,
      621,
      {23350,32767,-32745,-7607,32682,-32288,32717,-5408,32716,-32745,-32712,-32767,-32730,8192,-32751,32695,3508,-1604,-32618,27571,-2876,32700,927,-7487,-2469,-1985,-11790,12066,1678,-2361,1316,7310}
     },
     {
      434,
      -6900,
      {-6853,9000,-5792,29641,20497,-32716,32747,-15364,21670,-32708,-28221,-32736,5670,12982,-20134,32743,775,-718,11942,26945,-26520,11850,-10154,-4094,10638,-7337,-5592,-11007,-4165,-1718,6762,9459}
     },
     {
      434,
      -12934,
      {32079,32767,31690,-32694,-32689,-32672,32747,-32696,32751,32767,32726,-32719,-32678,-4732,32597,32755,-5537,-14915,-29756,1760,-4852,22292,-8952,-26333,-2685,1061,-3577,-3588,-6717,-10508,-2520,12191}
     },
     {
      434,
      -6338,
      {32732,32761,-32722,29248,-3813,-32647,32742,-32741,32739,-32744,-3047,-8313,-32720,-27363,12456,32736,289,4612,-32719,12702,-30120,32730,-6672,12394,-31186,1201,-10076,16764,-1397,-7266,-15334,3368}
     },
     {
      434,
      1133,
      {556,-32749,-28820,-4072,-29278,3675,-32698,32744,31548,522,24878,17436,-32716,-576,28985,-27203,21996,24053,-19907,-32700,19275,-32697,32,20590,-26608,4916,8437,-8130,-402,11259,-5776,-6131}
     },
     {
      434,
      -2215,
      {32211,-32742,-32728,23155,3733,-32741,32200,-32695,32732,-32732,-16261,5424,-32726,27443,25213,12536,10039,25487,-32722,-11157,24070,31707,-1590,7767,-17690,3397,1812,13739,-3598,-1685,-5801,6638}
     },
     {
      434,
      209,
      {22557,-32718,-5030,-32684,-32690,-12622,27030,-32709,26561,-5760,32766,32767,-32690,-21395,30149,-32662,-2370,23301,-29324,9161,26619,-5456,-6509,13659,-32675,1362,-10631,2886,1859,-7688,-9483,-5502}
     },
     {
      434,
      -2897,
      {32733,32705,-32738,18852,-32711,-32767,26228,-1910,32730,32676,32676,32705,-32723,-32724,-27732,-3591,-6727,-14297,-2150,2140,-2748,688,-5204,-3356,-7873,10233,-906,3141,-3084,-8558,2692,13245}
     },
     {
      434,
      -9296,
      {-17300,-28108,-32767,28075,32689,-11418,-9153,22956,32698,-32746,-32717,32704,-32752,3378,20599,-32721,-4579,15895,23029,12008,13486,-1577,-9096,4814,-3293,-7725,-8999,5511,-8235,874,1451,555}
     },
     {
      434,
      -3899,
      {32740,-32742,-32718,-9550,-32718,32742,32675,-24831,32727,-10723,20553,22204,-32720,-12173,-29150,-32702,32300,30640,-32685,-32704,22535,1633,-2595,12931,-32705,1663,8081,13371,-5781,-142,-9018,-1170}
     },
     {
      434,
      3205,
      {-26978,-14928,-32703,-32719,28726,-31784,-15860,14642,31950,32736,-29883,-32749,-32716,23991,32739,32746,19178,29298,-32704,-1655,-4373,27522,-7538,-7367,-13033,2656,-8689,-5393,859,13567,-5595,21502}
     },
     {
      434,
      -4362,
      {16861,32758,2760,5762,16161,-32765,32696,-4195,32720,-32738,-18138,-32767,-32736,2674,32701,32697,2461,19807,-32734,22398,-20642,24030,-2783,-16800,-8893,-3511,-8503,-10914,-2683,-7839,2550,11822}
     },
     {
      434,
      0,
      {-32739,-32767,-32727,-22497,-32755,18012,-32703,-22652,32703,31776,32722,-3207,-31480,12231,26393,-32753,19044,3403,-28373,-32750,11846,-32739,-10634,23700,8672,2509,-3125,-17802,-16502,4986,-751,-4921}
     },
     {
      434,
      -7059,
      {32725,-32765,-32741,27951,32700,-28852,30768,5080,32724,-32692,-32741,32763,-32748,-30916,-32755,-376,15675,3644,13350,31611,-13314,11872,-9270,24685,-9026,-3811,-7814,276,-4769,-2055,-3024,4264}
     },
     {
      434,
      -364,
      {32487,-32767,-32710,12142,872,-28014,32756,-32712,7393,-21652,1918,23799,-32733,3999,32760,-26583,3965,25062,-32724,4517,32746,12912,-6354,20083,-32707,5457,774,11934,-3214,-1647,-17641,3590}
     },
     {
      434,
      234,
      {32732,-32756,-32732,32680,19986,32701,32704,-32177,32682,-32758,-32685,-11885,-12924,-9339,-32767,-25361,14061,-21987,19926,12102,-23650,14247,-3148,13191,-5477,-2884,-6905,-1112,-1966,1965,3881,5548}
     },
     {
      434,
      -12844,
      {-32728,-32767,-32729,32717,27015,10534,1323,24956,25647,-32760,-30147,-32703,26478,32219,14242,-30159,-8485,28331,19173,-9919,-2162,-20855,-5215,19944,2566,-7070,-3717,-12697,-1442,5951,1401,-84}
     },
     {
      434,
      -4610,
      {32753,32717,-5963,32654,-32767,-32767,32703,-32767,32677,-32767,30907,19620,15786,-2865,6897,2540,-1621,-29879,10372,14239,-32732,-9612,-9812,-8356,9102,5215,-10362,-29816,-5226,-6231,12517,10047}
     },
     {
      434,
      -10175,
      {32710,32750,-4446,25899,19639,-32693,32740,-32742,-20601,32715,-10607,-32409,16629,30870,-20823,-7585,-13780,-23789,-12561,-2061,-2482,7512,-2174,-15273,7128,1573,1730,-10018,-6180,-2110,1435,10348}
     },
     {
      434,
      -7266,
      {-32749,-32764,-32762,32705,32694,-32411,2485,23320,25509,-32758,-31325,-32739,23515,17729,-26367,31987,24000,32718,25819,15174,-7889,-14159,-15978,10912,2826,-8307,-7748,-14812,-3017,4125,-894,4099}
     },
     {
      434,
      -7157,
      {-16799,-7272,-32737,-32733,32704,-32767,32724,27605,32703,32724,-32373,21185,-32738,19305,32702,-18292,-1037,1028,17907,-1585,3864,3634,-3609,-7016,609,-827,-4804,-7079,-3720,1557,-4929,7479}
     },
     {
      434,
      6507,
      {32381,-32767,-15014,-32737,-23660,-32767,32745,-32739,32723,32699,32697,32719,-32763,-7247,1255,-31626,-15679,32720,-16092,-3991,-10307,-8937,386,2092,-15074,14019,-1949,5742,4494,-2425,516,6615}
     },
     {
      434,
      -2745,
      {32745,32723,-32757,12402,-9058,-32748,32724,-28372,32734,29695,7523,32680,-32741,-7972,-30080,6586,11118,5366,-11229,-17567,-27170,10751,-4365,-2689,-6734,6888,-2770,200,-6015,-2564,10058,8578}
     },
     {
      434,
      -9923,
      {18983,32767,-32706,27919,28313,-32741,24843,22465,32721,-32759,-32571,-23248,31476,-18717,2371,32702,-3110,1525,-30146,16860,-11303,26694,-10495,-10124,2121,693,-12770,-6015,-5324,-10999,-5765,10033}
     },
     {
      434,
      -4955,
      {-1491,-32757,-32575,-32666,32731,-31132,-32720,32162,16778,32150,-31875,-32673,24572,-17771,32748,20300,8577,32737,-8858,3554,6598,17856,-15987,6594,-16738,5402,-16145,8177,-111,7950,-8735,8175}
     },
     {
      434,
      3,
      {-32767,-32767,-25226,-31331,-32715,-32767,-32767,32767,-32725,-3292,32721,-31448,-16188,14813,30530,-32767,32690,-1100,25332,-32640,31664,-32728,-8150,32635,-32720,1901,30807,-29730,-6780,17845,-19312,-7118}
     },
     {
      434,
      -1562,
      {32726,-32767,-32718,30876,-10964,32742,32739,-32713,13256,-32709,2574,28000,-32728,10930,32072,-30653,5820,31712,-31020,-18905,-3643,-3036,-898,19455,-30702,-1361,-6548,14209,-1586,-1908,-10699,-5965}
     },
     {
      434,
      116,
      {32732,-32767,-32744,-31675,-10482,-30378,-13988,-32725,32747,23639,14621,5014,-32738,15304,32714,20286,4767,-15978,-26952,17867,7479,21465,-6820,-2322,3409,-3611,-6124,-6531,-4939,-2003,2278,6237}
     },
     {
      434,
      -4554,
      {32753,32705,-4979,951,-32703,32721,32727,-32719,31961,32691,26588,32694,-32709,-32724,-30908,-32706,3755,-6535,-29786,-4145,8351,-8607,-3060,-5054,-7867,5829,-4825,2998,-5057,-13235,1506,1864}
     },
     {
      434,
      -7856,
      {26531,32685,-32767,32645,32680,32691,-22928,-32757,32672,-28371,-32767,32665,30475,715,-32767,-32764,4414,-7012,-1417,13418,-18450,-11915,-5348,18775,27643,-4125,-19058,-10039,-9136,-3900,6107,-3498}
     },
     {
      434,
      3635,
      {32733,-32722,-32696,16007,2327,14918,32747,-32699,32742,-32693,-12887,32755,-32681,13046,4371,-32704,18957,21353,-25767,2692,4219,2374,2179,13712,-17034,5858,4897,2290,-1573,336,-4121,1855}
     },
     {
      466,
      -32133,
      {-9640,-28356,-32722,-19374,-25166,-32727,-32725,-31356,-32724,-32722,-32639,559,-23731,-32718,-25521,32737,1969,10713,8492,5872,32721,32738,32740,32668,32758,32762,32753,24779,32751,32760,32741,32711}
     },
     {
      498,
      -32724,
      {-9280,-1674,7375,8689,28304,30803,29459,32743,8200,23156,32741,32765,10467,32696,30688,-5660,15044,10073,-784,3941,32746,29617,29278,23,32765,32753,32732,32727,32765,32762,32741,32733}
     },
     {
      530,
      30746,
      {-32730,-32751,-100,31275,-32733,-32763,-32758,-32767,-32747,-32754,-32767,-32767,-32747,-32767,-32765,-32767,-31015,-32767,-32767,-3049,-32767,-32767,-32767,-32756,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767}
     },
     {
      562,
      -32443,
      {12464,16244,20751,13432,26004,24289,29372,27615,29566,14758,6210,29507,19121,15258,-8156,9789,22161,31894,32732,32738,31588,32703,32725,32737,32445,32713,32725,32733,32465,32717,32736,32739}
     },
     {
      594,
      -1267,
      {-15218,1871,22853,27174,-20053,23018,5052,-23777,-16538,22664,24935,-15532,-18371,-978,27372,8870,-28855,-32719,-32767,-32767,-30718,-32767,-32767,-32767,-28635,-32767,-32767,-32767,-22764,-30206,-32763,-32767}
     },
     {
      626,
      -32693,
      {-32767,-32755,6223,32767,-32751,-32721,32731,32745,-32685,-24086,32750,32760,-32717,10938,32753,32744,32767,32767,32767,32762,32767,32767,32767,32767,32767,32767,32767,32767,32739,32767,32767,32767}
     },
     {
      658,
      -32717,
      {-30426,-32730,-32730,32743,-20785,-32730,25841,32722,-32314,23527,32706,32711,-26632,-20395,18674,32719,32747,32749,32686,28162,32741,32749,32761,32764,32730,32763,32767,32767,32713,32736,32767,32767}
     },
     {
      690,
      -32639,
      {31867,32701,32734,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32756,32746,32739,32767,32767,32740,32741,32767,32740,32725,32731,32727,32716,19712,32727}
     },
     {
      466,
      -14300,
      {12492,32491,32723,27082,27412,32730,32728,32507,32726,32739,32729,30109,32731,32742,32729,32724,17609,9572,1290,2993,14619,-6374,-32733,-32723,15940,-11237,-32731,-32739,8771,22205,-25898,-32767}
     },
     {
      498,
      -32735,
      {11320,8968,3817,6919,11476,32719,32728,32753,-32759,22967,32723,32756,-32760,9888,32713,32725,3701,-8097,-12854,5339,32747,32729,4745,-8019,32766,32755,32726,17643,32741,32747,32736,27609}
     },
     {
      530,
      20027,
      {-31204,-32731,-15049,17208,-10916,-20122,5616,-32756,-15360,-5480,-26488,-32740,-4084,29424,32738,32702,-32730,-32725,-32739,-21583,-32753,-32742,-32763,-32748,-32746,-32749,-32760,-32767,-29680,-32749,-32767,-32767}
     },
     {
      562,
      -32694,
      {30669,32759,29558,-1434,32753,32767,32764,24635,32767,32767,32767,32744,32767,32767,32767,12469,-24213,-19779,3736,9476,-12507,16834,-12,6040,32606,14525,10756,8735,13840,15893,17514,6057}
     },
     {
      594,
      -1466,
      {-12620,-32648,-32729,-32742,-7630,-31263,-32729,-32754,-27600,-32549,-32723,-32750,-30950,-32728,-32723,-32738,-32761,-32767,-32753,-32734,-32767,-32767,-32759,-32729,-32767,-32767,-32743,-32712,-32761,-32743,-32717,-32694}
     },
     {
      626,
      -32693,
      {-32745,-32744,-32737,-32749,24524,-27443,12194,17255,32767,32767,32765,32765,32767,32767,32761,32767,-32743,-32732,-32730,-32718,27570,32735,30208,14098,32767,32749,32751,32744,32767,32752,32758,32748}
     },
     {
      658,
      -32691,
      {32728,32747,32748,32729,32725,32737,32749,32731,32725,32727,32732,32722,23718,32726,32725,32727,29122,32728,31980,-32745,32728,32767,32753,28987,32755,32767,32767,32767,32728,32763,32767,32757}
     },
     {
      690,
      -32741,
      {-32767,-21697,25718,32749,32740,32751,32767,32767,32762,32762,32767,32767,32738,32764,32758,32740,32767,32767,32758,32736,32767,32767,32750,32733,32767,32742,32732,2582,32724,32050,12110,8693}
     },
     {
      466,
      -32737,
      {3964,3460,2476,17597,6882,21254,27313,15991,19695,32732,32725,32738,32725,32735,32725,32736,22863,27538,19967,11239,32732,32732,32720,18712,32743,32722,20480,-32727,32735,32730,32720,-26311}
     },
     {
      498,
      -32710,
      {-6306,3743,-3927,4347,-32767,-32767,-11699,21730,-32767,-32767,-32767,32283,-32767,-32767,-32748,27741,3831,-5859,-9911,-4017,20247,25241,30317,-16129,32708,32726,30574,21203,18472,30894,30139,-1011}
     },
     {
      530,
      17510,
      {-32720,-27762,6611,23562,-12992,-32706,6128,-17992,-32700,-32719,-28547,15891,-20248,-10477,-2407,29622,-29582,-20250,-24002,-32735,-14267,-5547,-31499,-32732,-906,-11138,-32714,-28190,-2247,-28094,-28856,-27868}
     },
     {
      562,
      -32693,
      {-32757,32675,32767,32767,-6676,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32745,32767,32767,32767,32762,32767,32767,32767,32749,32767,32755,32731,31567}
     },
     {
      594,
      5278,
      {-16784,-32767,-32767,-32767,-31218,-32100,-32767,-32767,-31314,-31679,-32745,-32767,-32718,-32742,-32713,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32765,-32767,-32767,-32714,-12547}
     },
     {
      626,
      -31013,
      {32767,32767,32767,32767,32767,32767,32767,32759,32767,32767,32767,29203,32766,32767,24712,-32754,-24854,-8469,-32738,-21925,-29212,-9348,-31209,-16613,-26350,-32705,-32720,32725,-32767,-32759,-32746,-374}
     },
     {
      658,
      -32664,
      {32736,32767,32767,32742,32728,32767,32767,32747,21003,32744,32762,32763,14256,29986,32737,32742,32725,32751,32741,-32712,32729,32767,13640,-32756,32730,31682,-32736,-32767,32742,22131,-27670,-32760}
     },
     {
      690,
      -24785,
      {-26449,-32747,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,8889,-32755,-24758,-32712,-8573,-32767,28795,32735,28125,25762,32767,32767,32741,32742,32737,32734,19118}
     },
     {
      466,
      -32707,
      {93,10037,9542,32726,19031,32726,17944,16730,32723,19065,-14843,-16156,32716,32723,5810,-11885,32723,32725,31419,9145,32721,26365,17804,32725,-6124,1433,22091,32729,-28421,-31525,18747,32767}
     },
     {
      498,
      -32683,
      {-30456,-32721,-22916,-16765,32767,32767,32742,32735,32767,32767,32767,32746,32767,32767,32747,32520,-12366,-21327,-5210,-494,32731,-7201,-1298,1381,32748,32729,-8068,29949,32741,18324,-19535,12522}
     },
     {
      530,
      -32688,
      {26956,32740,3357,25715,32724,32721,-5662,32723,32729,-4972,-13331,32733,-4000,-32733,-32735,32728,32741,32767,32767,32736,32761,32767,32767,32724,32767,32767,32767,32725,32747,32750,27783,-8078}
     },
     {
      562,
      -32700,
      {-32731,32734,32734,32741,32715,32756,32766,32767,32729,32765,32767,32767,32745,32767,32767,32767,32728,32765,32763,32752,32753,32753,32763,32767,32767,32746,32761,32760,32767,32761,32736,32741}
     },
     {
      594,
      574,
      {-21499,-32751,-32767,-32767,-29297,-32155,-32762,-32767,-30579,-32477,-32741,-32767,-32720,-32744,-32736,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32767,-32729,-32767,-32767,-32732,-21792}
     },
     {
      626,
      -32639,
      {-26497,-19935,-5027,32767,11630,29212,32767,32767,32764,32767,32767,32767,32760,32755,32767,32767,32767,32759,32688,32704,32767,32767,32762,32748,32767,32767,32767,32767,32764,32722,32764,32767}
     },
     {
      658,
      -10898,
      {32725,32732,32712,2284,19457,32724,32732,32734,15498,32731,32744,32751,14152,32726,32731,32718,12176,-15132,-19208,-24467,-32740,-32746,-32762,-32767,-32719,-32767,-32767,-32767,32725,-32765,-32767,-32767}
     },
     {
      690,
      -32585,
      {-32701,-32727,15612,32693,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32767,32720,32717,32757,32765,32767,32767,32762,32763,32767,32761,32757,32753,32743,32742,32745,32741}
     },
// *********** Cells of layer 2 *********************************************

     {
      0,
      811,
      {-964,-3526,305,2068,581,-1492,1086,-273,256,-165,-1021,-327,-1611,-723,-2806,-1108,-97,19,-86,821,-1071,863,143,-905,-731,-3027,-989,287,-394,-2706,-3559,-1511}
     },
     {
      32,
      68,
      {2,-778,1092,2503,-1230,-438,1541,-2317,-188,829,-4235,3015,-862,-765,-277,-2233,195,-373,-1625,-366,-419,488,-844,738,107,-607,-754,161,252,-2195,-1782,-427}
     },
     {
      64,
      -4507,
      {-895,619,495,-58,1136,-307,96,857,256,-113,-780,-1162,-32,-258,1094,542,713,294,1959,-1480,162,585,44,574,-317,-255,-227,-188,166,-225,200,422}
     },
     {
      96,
      2923,
      {-418,305,1120,-124,309,-193,-1121,-557,-51,215,1348,-13,389,-44,-709,-6,-22,-115,193,198,1531,112,314,2135,-231,188,211,97,1215,-268,658,67}
     },
     {
      0,
      -839,
      {285,-2559,1032,-3662,-666,1043,-1908,131,2767,271,-1350,35,-158,1457,1633,-931,-1943,2470,21,345,-1637,-842,1235,-284,-2131,-753,-705,123,-2147,-2374,6,-1417}
     },
     {
      32,
      -2343,
      {-1825,-2811,1284,-1116,414,846,-513,-863,-2332,-635,-1166,-2498,1793,-1146,325,-814,1062,-994,2280,-670,-2286,2058,78,876,1598,-216,-988,1269,1372,-2116,-714,-3606}
     },
     {
      64,
      -1717,
      {-673,-794,144,-56,-174,-1136,294,2087,-1102,-23,156,-21,293,-386,-493,1599,-1049,-66,-959,-840,-77,-322,278,-696,-2218,-436,533,493,-615,66,-1733,-282}
     },
     {
      96,
      -4657,
      {-1718,370,182,475,-820,-155,326,-11,-410,-84,90,967,27,498,39,-32,-21,-88,-73,115,-330,857,-62,-511,-3,389,-405,36,-421,-136,-66,873}
     },
     {
      0,
      -347,
      {-288,-519,-1925,1165,420,1051,405,1638,-32,214,-913,461,720,-151,-732,-1446,259,-986,-162,-728,-177,336,-514,-496,-1272,741,-119,511,500,-2664,-184,-614}
     },
     {
      32,
      -1823,
      {413,253,329,-190,2463,464,-1834,2046,661,1155,210,-269,-89,-49,-176,-1445,2073,695,946,-197,-1272,-526,-712,-631,435,264,-1636,581,-761,-850,33,2369}
     },
     {
      64,
      -2229,
      {1227,-1130,-1125,483,-971,468,368,1392,-245,-1122,1384,-195,-2242,362,110,311,549,1431,-907,-183,882,4,841,240,-252,1172,-157,811,1121,393,-988,821}
     },
     {
      96,
      -1351,
      {-90,889,92,-602,-434,233,389,-326,-291,582,162,-451,220,-760,486,470,615,150,603,-593,1128,293,-769,741,-57,7,-24,890,1541,-618,214,1549}
     },
     {
      0,
      -644,
      {-1665,-1085,183,-427,526,-1047,1241,1669,38,745,1230,990,1909,654,-1474,-1485,-2,-1994,-268,-1352,150,-144,-266,909,299,-171,101,-516,1837,238,1391,-483}
     },
     {
      32,
      -4915,
      {-11,726,393,1173,1043,87,1066,-1393,-1337,1422,-700,-549,-269,638,2006,-1752,2391,-1064,621,-473,600,691,-1593,393,-183,-1503,1475,268,-906,130,-58,-19}
     },
     {
      64,
      -1022,
      {-712,-418,10,250,-2013,-1514,-707,-733,-998,-966,-909,-28,458,168,-841,-247,756,229,277,454,-744,-86,-1318,-1221,131,235,-288,-70,-346,417,245,-74}
     },
     {
      96,
      -637,
      {-367,-489,579,-92,1913,-552,261,-293,425,-180,412,592,171,1033,-405,-78,-725,-73,-490,181,1221,-301,307,-1704,153,-759,-16,-304,593,-446,404,623}
     },
     {
      0,
      -808,
      {326,-627,750,250,1003,99,-1319,-671,-2092,356,-566,-371,1866,507,70,-1456,28,-332,569,120,1083,-732,6,137,-311,-446,431,-441,-316,177,-437,219}
     },
     {
      32,
      1540,
      {221,1,-510,-205,431,-887,976,-848,353,-42,-667,803,246,0,-247,-809,1101,1258,-1188,416,-507,-114,-969,706,-1469,396,-1421,230,-1127,-755,910,-194}
     },
     {
      64,
      156,
      {126,-115,-51,520,-169,978,262,-54,2090,-451,-25,554,1064,331,875,449,26,68,54,-648,83,764,952,1116,-338,313,389,-4,637,-148,-199,287}
     },
     {
      96,
      1113,
      {-295,-449,-102,-27,581,-880,-43,-268,136,204,117,-207,481,-544,-1399,-253,-101,-135,161,-220,580,-79,-308,956,232,812,-153,-26,518,-408,38,-1312}
     },
     {
      0,
      678,
      {-716,216,1155,625,33,-726,-589,-1613,-1265,-2113,322,-558,-2539,822,-26,841,-157,-2985,-240,-1521,-1924,987,-290,-744,-1016,108,728,-929,47,1616,-837,721}
     },
     {
      32,
      -2987,
      {1972,1405,-972,-852,2160,-1927,1496,-598,-639,734,780,-445,-1343,18,310,2071,1084,-3029,956,8,-355,194,-211,-57,-372,-1609,-816,612,-41,-386,215,1141}
     },
     {
      64,
      -917,
      {288,-669,-311,538,273,-1089,-269,-149,-335,-1220,-177,680,-387,-75,-1214,908,-501,-1344,438,274,-611,-290,125,-23,-1766,-233,56,-437,-1195,-135,0,-1386}
     },
     {
      96,
      -1286,
      {439,859,-481,-271,-354,221,-80,1170,-926,129,367,-60,-115,-1089,317,1610,422,168,-88,-226,-1259,-568,-340,-1969,-160,-197,-384,-170,-634,-1272,-421,462}
     },
     {
      0,
      784,
      {572,-2081,1750,1109,324,-1155,1101,-1697,1317,455,170,-1719,2649,716,122,144,-667,-1192,-432,-2427,-728,-665,-966,804,-1530,-264,-956,-575,-1965,-236,147,-1350}
     },
     {
      32,
      -2851,
      {75,-320,-166,180,383,279,-762,-104,-44,375,520,404,374,-952,526,-239,275,-1012,462,-2310,-1602,1194,746,-877,-317,-1448,535,2941,894,1240,583,1837}
     },
     {
      64,
      -2882,
      {278,447,11,-406,883,-80,852,448,-52,-28,-313,0,349,-109,46,376,-165,329,164,-139,487,98,-1,-63,272,189,-436,-11,77,-636,114,455}
     },
     {
      96,
      7,
      {-198,-310,-130,194,454,-406,27,-311,-116,62,-84,-158,25,-251,-415,-260,-171,-51,347,-30,207,94,-444,-85,148,825,-171,147,168,-274,-55,11}
     },
     {
      0,
      -955,
      {662,-593,-866,-531,-678,-2102,-881,100,-627,1064,-212,150,-127,9,-1537,601,-551,341,-1670,944,500,18,1433,-73,576,621,186,-26,138,1599,1411,862}
     },
     {
      32,
      1604,
      {656,-300,-700,769,1802,-309,-923,1617,-2180,1637,-1625,-401,-1417,840,3011,-105,793,-2203,-649,-373,1217,245,-394,-1017,-1422,-500,524,249,-908,-2168,-282,35}
     },
     {
      64,
      -1023,
      {-628,-1315,-1202,-2263,-379,-1071,-29,-567,-491,724,6,-2453,-604,-570,402,-484,114,-1452,-467,-173,-634,-862,-474,-733,-124,52,-676,35,353,387,853,-248}
     },
     {
      96,
      -5269,
      {-49,910,-206,-546,-745,-641,700,-401,641,1005,-410,1279,670,-782,130,-792,770,350,-51,502,577,634,145,1085,270,1094,197,104,585,-21,-58,505}
     },
     {
      0,
      2127,
      {-463,-336,-399,-556,-337,-276,767,-462,1069,191,-278,-392,-1752,265,-713,-491,-564,451,-799,173,-537,441,739,68,-694,-721,-46,-38,-411,-1164,-588,-314}
     },
     {
      32,
      -1312,
      {-352,211,-856,-530,204,529,-3695,1097,-787,-268,-1039,-1950,-482,364,-1702,1964,-878,-3101,1900,-91,1089,637,1502,-1291,923,434,23,1058,-304,-975,-1161,293}
     },
     {
      64,
      -2798,
      {-187,573,228,378,-263,-464,-384,-174,-53,-596,-234,267,1682,-426,-221,900,5,39,122,314,-239,132,-1194,-244,450,20,-873,-102,371,-7,-128,-308}
     },
     {
      96,
      1110,
      {128,565,-1046,542,-154,-428,-261,1562,97,-568,-726,485,551,-662,-423,384,-186,-828,-105,-2634,731,1793,-265,-304,-109,-6,564,-828,771,-1681,-918,366}
     },
     {
      0,
      -2,
      {-189,-890,-1478,-1877,112,261,-289,236,-1426,-105,1772,-197,-2600,-139,-121,534,683,-1631,-192,81,1806,-586,59,-73,-21,1559,1111,-1973,1498,-848,-556,451}
     },
     {
      32,
      1310,
      {442,1585,-2834,-1741,-1689,-802,-3656,2302,-744,-475,1802,1150,-1613,835,83,-532,-773,-87,-1358,2103,2952,-564,-988,-815,-2613,1483,-105,-914,1678,-534,297,-2734}
     },
     {
      64,
      -1530,
      {-669,-802,-1297,-252,-527,835,-756,360,-53,-318,204,-2028,-1104,134,-376,-702,-45,-969,188,-390,-2240,-1128,-910,23,-545,-1037,-339,-107,-671,1491,-236,-201}
     },
     {
      96,
      1109,
      {181,42,695,-193,378,-420,9,377,204,59,170,-36,431,373,336,323,153,479,-671,-1190,656,-154,846,113,-192,-286,23,-1606,211,-43,21,-17}
     },
     {
      0,
      3408,
      {-180,-476,-1687,3164,-2432,977,1161,1970,1264,-581,1088,-3334,973,-991,742,-2779,-1852,-1772,-1638,13,-2301,1078,-319,-289,-936,1257,290,-309,708,-766,-748,507}
     },
     {
      32,
      -2392,
      {2108,2275,-323,-1694,2053,-1106,2156,517,-1149,-555,-70,-2468,-380,-345,735,197,-348,-846,198,-612,595,2036,-899,1254,-445,-958,377,-600,-666,-871,479,710}
     },
     {
      64,
      -336,
      {-78,190,285,-176,-1394,-300,-48,-706,-1601,12,-220,-354,-232,2,-878,439,-442,338,-563,454,38,-190,-112,-1374,-201,-1,142,-276,-883,-136,258,-118}
     },
     {
      96,
      -2154,
      {-283,-233,-605,-372,-231,-586,-319,1283,-345,-364,128,883,31,285,-125,314,-727,-320,416,-43,-57,209,276,-439,-14,311,-634,169,284,-79,1065,645}
     },
     {
      0,
      490,
      {-783,-2076,777,1455,1021,2310,-1039,93,2242,824,-1988,-70,-4224,-336,984,266,-1125,2823,103,-508,-2056,-652,192,647,-96,-1645,-965,80,-3033,-2436,-654,-1545}
     },
     {
      32,
      3068,
      {-728,-418,-1044,2468,146,-987,684,-391,-2744,-68,-1609,1581,-849,-298,-997,944,-137,-2369,-2112,-937,41,-170,-709,-465,-248,1300,408,-792,-328,380,-529,356}
     },
     {
      64,
      -2753,
      {-452,289,275,-1222,-57,-984,90,-390,-1222,-37,-627,-1265,507,-96,-995,-902,61,279,1643,753,-670,-595,-445,-233,164,-1281,31,-425,-725,-1018,297,-271}
     },
     {
      96,
      -4518,
      {197,360,-176,292,-165,50,630,36,-83,165,-92,451,-257,-796,147,-18,146,195,575,1070,118,651,-400,-1112,-494,-51,-347,1041,155,-199,-538,926}
     },
     {
      0,
      -220,
      {472,895,360,-210,-1614,2941,769,1785,665,-1539,1804,-712,1159,166,796,1226,711,1148,-144,5686,-2490,1026,1457,1986,889,-771,372,-1745,-2953,2821,-17,-1064}
     },
     {
      32,
      833,
      {533,333,715,843,-441,-520,1709,1245,95,178,-905,2816,124,205,81,-652,469,-732,-2092,-1674,1052,767,410,477,-94,-334,1432,-812,-1589,1800,-828,-2479}
     },
     {
      64,
      -518,
      {464,-416,-674,111,-224,300,125,-136,576,279,-420,181,312,543,-920,31,-912,-42,148,-750,141,182,-744,-307,552,283,323,-664,57,-125,-1250,-244}
     },
     {
      96,
      -2079,
      {87,443,63,319,-351,937,-550,-1038,315,-210,288,-50,-419,715,-520,-3,-24,501,564,-8,-627,207,290,991,-860,-304,-27,408,-268,1639,523,165}
     },
     {
      0,
      -817,
      {724,-1268,-481,397,454,1006,-704,613,60,696,-965,-118,-487,9,791,145,948,863,562,-714,-815,-2121,-616,-359,-478,1616,-167,-1241,-16,481,-615,-343}
     },
     {
      32,
      -1627,
      {435,947,843,-1832,-139,-917,1291,-1094,-448,277,-2070,-921,962,-586,1946,1642,307,598,804,294,-944,327,39,449,-1579,38,-515,-270,1617,-285,1164,-2209}
     },
     {
      64,
      -749,
      {-311,-906,-365,-254,-804,-19,-21,-237,-1058,-465,-202,-129,-500,-249,420,-373,-437,-213,-2501,-60,-373,-367,-1358,-1970,-731,268,569,-442,-578,-668,324,-239}
     },
     {
      96,
      -1001,
      {-965,-402,-730,-37,514,1097,-1037,177,347,-476,-102,-438,-69,366,-391,-67,10,-1188,-136,-724,-62,-451,-208,-1319,173,584,850,-263,-202,126,-595,-129}
     },
     {
      0,
      1123,
      {991,-238,407,1298,-1216,1459,-40,-464,540,-61,-253,91,-1306,-205,991,-763,38,134,438,-592,-483,-982,-883,-495,-1514,193,-455,-250,-1440,-1667,-1280,-1180}
     },
     {
      32,
      15,
      {-483,-1010,1138,793,1481,-7,869,-2276,-3363,671,-1927,-170,-138,-388,440,608,1642,-1966,-1335,-64,-417,-518,-1642,1561,-1282,-521,-825,-320,-467,-4496,1292,1742}
     },
     {
      64,
      -370,
      {-1086,-446,204,24,-623,-223,-564,1472,-520,-528,-425,-171,-621,-821,-748,459,-829,-456,171,772,-966,-393,-296,-1121,-153,-53,-223,-425,-451,337,180,-417}
     },
     {
      96,
      -4961,
      {413,297,560,225,-541,1400,-123,-22,117,-326,53,538,308,327,-73,1219,270,-167,29,120,-867,-207,196,-128,-234,525,225,-222,-415,-352,-504,643}
     },
     {
      0,
      -874,
      {700,-1825,976,2378,-260,-1665,-56,-834,295,941,622,363,244,993,-376,-4724,243,-1477,-193,-1789,299,-82,932,683,-2146,-1538,-244,-160,215,-1764,950,-897}
     },
     {
      32,
      -2279,
      {-1395,-1111,-997,461,-3821,-1313,1294,-740,952,-1077,-152,-357,2260,-70,-522,869,-2525,880,-62,783,-1323,1544,949,-1473,398,-406,1054,5065,978,-1493,-1186,-1323}
     },
     {
      64,
      -2483,
      {-104,-142,530,-87,224,-919,-149,328,-439,-586,-1066,-237,408,255,-326,-1136,-468,-210,446,527,198,547,360,147,608,-82,-739,-712,52,325,-50,649}
     },
     {
      96,
      -785,
      {-387,-364,425,70,-82,82,-77,-170,-106,-610,161,271,-293,708,783,-64,-321,147,-1334,-458,-474,-25,805,-300,361,-711,-381,942,-260,420,442,231}
     },
     {
      0,
      322,
      {1847,-475,2247,3654,2485,-1327,198,-2675,-1523,-952,2040,-1580,-4218,806,-253,-3925,233,-1245,-286,-402,-19,1108,-163,1295,-4734,-871,124,-3058,409,1570,575,-380}
     },
     {
      32,
      4197,
      {-673,-1452,-1352,-596,-912,-1033,-393,-2867,640,-1587,24,1029,-2568,149,-258,152,-378,1930,-1087,-388,-785,274,-603,-1802,1266,1632,-424,-626,-872,-100,-1284,-7}
     },
     {
      64,
      -1380,
      {255,-845,280,134,-624,673,-44,-714,-1178,53,-1022,295,217,-41,-1603,-213,-1791,-210,-1402,24,-28,-42,-960,-554,-1244,322,-131,83,-213,-630,-271,-1270}
     },
     {
      96,
      -924,
      {61,219,-908,724,-634,-759,-334,-789,351,-302,-116,577,124,267,186,190,218,651,-466,14,972,124,475,2,-480,-980,264,230,536,11,535,307}
     },
     {
      0,
      825,
      {624,602,640,-1611,-1622,-704,-311,-1394,54,-408,2728,329,-698,-415,-126,1258,343,125,257,402,735,74,204,267,-122,-721,-1028,-891,-197,218,2238,-223}
     },
     {
      32,
      -1930,
      {337,-700,143,-826,-830,-376,-804,592,923,-1222,190,-1850,-1417,-759,698,567,108,-2364,2558,-175,612,99,942,68,-945,1284,-1597,662,358,42,88,-1303}
     },
     {
      64,
      -3447,
      {1078,-998,608,-1258,-539,739,862,315,-824,119,540,19,-1059,344,605,1210,1221,210,-1076,-1063,520,-2,1148,-865,-1363,1175,1914,1132,735,-1111,-1726,174}
     },
     {
      96,
      796,
      {-560,-666,484,312,-87,-260,319,-555,255,376,112,310,42,-558,363,105,78,-127,266,-995,-864,-481,205,1815,598,380,-375,-47,-510,-1170,552,-1125}
     },
     {
      0,
      -846,
      {-190,-673,975,-2082,-923,-470,-394,-706,-1358,226,-1674,1237,622,-416,-768,1249,1000,818,72,-1372,-1675,-531,197,152,761,125,428,1424,-444,242,-215,-647}
     },
     {
      32,
      -2600,
      {1058,826,-653,-630,1918,-2938,2006,-688,346,194,965,-871,-323,-660,2189,-1364,2517,1115,-988,-743,1077,1101,-2117,405,971,-246,-927,-209,-315,-861,1313,-238}
     },
     {
      64,
      -1238,
      {463,-63,-303,467,316,182,88,258,421,284,334,-495,-672,1823,115,149,262,40,140,-177,-163,-352,281,424,-174,-494,-210,14,817,267,221,850}
     },
     {
      96,
      3933,
      {-577,-221,419,46,390,-457,-366,-271,-34,-294,1051,-378,436,-160,-152,-624,-296,-1072,529,-739,2311,-565,-20,110,283,301,-994,-117,2002,-354,-292,490}
     },
     {
      0,
      3483,
      {-944,-1029,-1047,-1001,-277,-144,-662,-363,278,790,-936,-845,1542,361,-40,-116,-649,948,-478,-223,-1893,-458,2904,1281,-249,-1504,291,-235,-293,-1062,-777,-853}
     },
     {
      32,
      845,
      {1995,-179,-347,1019,-2,-352,1205,600,66,-1424,-1769,1274,-838,-320,-401,691,-154,-1389,-515,2312,-19,-611,-588,606,-2746,626,-2568,-110,-525,-3786,1646,2616}
     },
     {
      64,
      -1757,
      {-330,-243,1797,603,441,-470,-94,610,-844,-837,-541,359,841,-729,-2152,-901,-605,387,730,-394,255,-3583,-132,-501,467,628,1230,-73,-161,329,-1645,-59}
     },
     {
      96,
      1612,
      {-236,-167,-194,-499,660,-257,-353,-1042,848,558,-731,-530,912,220,-512,-66,419,475,300,426,637,4,-872,758,269,-399,-34,389,302,177,-266,-847}
     },
     {
      0,
      2060,
      {-230,-3863,2092,-3329,-752,751,-351,-1239,1608,416,-954,-1739,-4819,3259,761,-1095,-2167,-348,-535,2115,-387,318,463,627,-1869,-1839,-180,-672,-1879,194,-181,-660}
     },
     {
      32,
      1620,
      {121,-920,319,1485,-976,-450,1256,-146,903,-1862,-1901,3179,612,638,-388,-2227,-134,1475,-1552,864,-346,-433,89,57,-1291,595,-1628,-537,264,-2970,385,-630}
     },
     {
      64,
      -2672,
      {-895,-477,56,139,306,-802,-218,180,-283,708,-472,-1466,320,-44,136,-431,-161,-263,-394,570,144,-237,-1748,-388,1063,-1644,-262,-658,175,-14,1951,-42}
     },
     {
      96,
      1897,
      {-370,261,912,302,-588,-1941,-209,-799,22,285,244,452,-264,-609,-302,-25,217,-267,93,-162,-1463,814,426,832,-43,339,-1018,-276,-810,505,219,613}
     },
     {
      0,
      1012,
      {-673,-1615,3205,-896,-2690,1922,42,516,-1485,-66,622,-795,66,1682,-267,-584,221,-1662,-173,901,549,-1509,-1545,462,-620,-638,-264,-3055,-772,1261,89,-553}
     },
     {
      32,
      -1545,
      {40,-652,-326,2561,-189,-328,-645,-1381,936,1976,-77,1039,341,-946,-1093,-1322,85,1103,754,-286,-800,-812,-110,-2153,2017,-31,-55,2992,107,983,-2499,862}
     },
     {
      64,
      1286,
      {59,570,145,97,-641,-821,70,642,-49,45,-153,380,800,333,-1251,-933,-1547,-651,-656,-721,-332,204,-173,394,-519,38,480,-380,-1186,-488,-329,-1304}
     },
     {
      96,
      1986,
      {-399,54,717,-282,-54,-40,-491,-261,-129,-223,487,-96,451,-474,126,-117,-506,-96,-322,-680,-168,-330,173,872,105,102,-299,169,-85,-288,232,-308}
     },
     {
      0,
      -1045,
      {-684,-3541,796,-394,-5086,-591,-107,-1169,-243,-88,-2894,1088,1347,1130,482,1080,930,927,565,-737,15,-165,1006,33,584,-1062,-24,1337,-924,-356,-2274,-458}
     },
     {
      32,
      -1183,
      {152,1852,-739,247,2156,-1972,-1164,-2191,-1678,277,-174,-141,508,-1264,-799,801,360,376,783,733,-485,-748,-1807,-887,1042,338,-699,-515,-1958,-2683,1204,3452}
     },
     {
      64,
      -11,
      {673,-1066,-943,-677,-135,533,463,1340,448,1323,-9,172,37,1076,-791,-1268,706,2312,253,-370,1657,-559,-625,-631,178,51,1651,760,-402,-166,-2,165}
     },
     {
      96,
      -69,
      {-842,-87,147,-670,1104,-837,87,413,343,345,824,309,455,-465,-402,-247,732,-500,-267,856,435,-221,268,-745,1126,1098,-341,13,274,-1124,-513,-658}
     },
     {
      0,
      -61,
      {-1189,653,-412,179,10,702,2310,-74,466,332,-5886,-437,391,1601,68,1392,1143,3197,-1953,-948,-1476,214,58,1064,764,-3462,-1699,905,-51,-1364,1128,-757}
     },
     {
      32,
      3356,
      {-1863,-837,-843,-417,-516,-474,1025,-1038,-905,588,-523,979,538,511,-1931,104,-35,-2691,-2445,-1112,1143,228,-881,1234,120,-1322,-879,-833,-1788,902,-350,-1807}
     },
     {
      64,
      744,
      {-281,-883,312,21,-1175,101,-161,1248,-459,-419,-622,-643,-252,-157,-847,-1014,-762,-163,180,-22,-376,420,564,-187,-262,247,-115,-954,453,-361,-338,-883}
     },
     {
      96,
      -448,
      {-329,808,-1018,-756,306,-508,-278,116,1000,383,-436,-351,8,418,-349,597,912,792,280,750,-927,275,-264,-230,-491,-445,34,270,-414,-815,155,-602}
     },
     {
      0,
      2134,
      {-668,-3173,1021,-197,56,1551,-232,-209,414,777,-261,-1251,-3577,615,-41,-560,211,-139,-198,697,-857,-1221,-594,866,-1132,-405,-926,-1165,-1914,-465,-1686,-867}
     },
     {
      32,
      1808,
      {605,-1017,-264,-1379,-817,630,702,1737,-2286,-1240,481,911,-514,-265,47,-1374,-1320,-603,-1435,2100,562,-1252,-184,996,-790,2143,-385,-1637,87,1852,1698,-1267}
     },
     {
      64,
      -2808,
      {1247,665,-174,432,343,-111,331,-554,252,165,379,-435,-761,173,295,-410,401,-1731,432,-12,-899,-74,585,440,-168,-28,-389,30,147,632,358,504}
     },
     {
      96,
      -1393,
      {-86,70,-1884,1152,-95,429,1486,430,-971,-177,-674,79,151,273,406,419,-274,-1140,583,-1684,-947,-729,385,664,155,546,592,-1733,-1070,46,933,31}
     },
     {
      0,
      1414,
      {184,277,2526,-444,1786,-78,-858,16,-745,-1563,378,-66,1129,998,-1341,567,-619,789,-1510,-782,1434,-103,-217,-2518,-1261,594,-602,-691,-778,-538,-36,-1043}
     },
     {
      32,
      -3312,
      {41,-630,-667,2336,2483,-1043,-487,-3341,-2516,1814,539,-3963,-338,-310,278,406,1590,-583,2357,-350,-190,144,-507,-837,2361,-1916,618,2959,-1135,-2982,-1851,2379}
     },
     {
      64,
      -112,
      {-71,-460,-144,215,-283,-32,-192,246,29,-1606,-22,-533,-225,125,-310,-687,-394,511,160,-162,-619,-404,-1064,-430,7,540,289,-228,-937,112,-313,-565}
     },
     {
      96,
      3596,
      {744,-1236,311,525,631,345,139,-133,200,-493,-424,-406,-248,-137,1005,-595,150,-217,-176,-1484,271,-717,474,-291,-108,-325,-1040,-136,351,19,153,557}
     },
     {
      0,
      -218,
      {403,47,1233,-925,-1406,-840,-1540,-992,-1350,190,917,640,-273,-1407,349,2107,1290,1944,20,-703,113,-1243,417,364,334,1221,789,-596,-1622,400,-21,321}
     },
     {
      32,
      1750,
      {-667,-835,402,2339,1419,-1721,-70,-359,-2510,1283,-1601,1401,64,-1234,1222,2746,1291,-7797,-676,-106,555,-782,-545,206,48,396,-153,-580,-1172,-296,-1118,-528}
     },
     {
      64,
      801,
      {877,-49,-812,-346,42,839,-690,-710,203,-233,14,-60,-813,-319,-364,-1098,1360,749,-63,382,-542,-190,-395,-512,-478,639,-1111,727,-590,357,604,470}
     },
     {
      96,
      -1265,
      {-245,-17,925,-907,-134,939,-47,-334,-891,564,-656,507,732,117,-423,-283,-1151,348,124,403,261,5,-267,-102,-473,-827,-67,183,133,1560,-694,354}
     },
     {
      0,
      -950,
      {772,802,-109,-1366,345,-819,-1196,-1775,-805,-1957,-5562,458,337,-379,1538,-68,30,1255,-124,-1236,1058,-1343,-1699,-1475,-238,-371,2126,623,95,-112,947,597}
     },
     {
      32,
      653,
      {-886,383,-1411,-2391,-2853,1425,-1139,2615,-829,-1205,474,-2224,-650,1604,-2580,-282,-2023,-1356,1311,1303,1458,1870,586,-956,-947,-358,-943,-289,-123,-617,-1062,673}
     },
     {
      64,
      -677,
      {-1027,-1018,663,65,354,-1012,-694,-388,-470,-970,-2485,326,-565,-231,-720,-755,-723,-1186,-4,659,-945,5,-972,-654,131,34,429,-1014,-387,-2412,5,-202}
     },
     {
      96,
      -918,
      {3,-938,61,-599,-547,-496,-190,-1291,637,-214,-425,-312,175,-418,513,626,601,614,75,988,273,897,443,298,-827,110,-328,489,203,-74,426,287}
     },
     {
      0,
      894,
      {-221,-1999,101,-475,-1105,1098,164,-1128,-1197,699,1667,79,399,-807,-16,-5798,627,-2395,921,88,-1893,309,888,1774,-1255,-2027,51,-1199,-2563,-457,-847,-1614}
     },
     {
      32,
      319,
      {242,373,878,-1314,85,-611,5481,-763,190,-358,-1287,29,1755,-1115,7,537,-204,-1114,-503,329,426,-12,-1238,2156,-1257,359,3678,-598,226,-1059,684,1531}
     },
     {
      64,
      -1318,
      {-518,585,-649,-1123,-1113,-502,-140,-572,477,-253,-841,-766,-1196,-446,-337,-583,-763,-387,-176,-853,303,399,-283,272,649,-853,-40,-1086,-182,-789,419,-907}
     },
     {
      96,
      -162,
      {431,-12,723,-615,366,504,-904,-738,-182,444,-60,-377,-355,-459,-759,-171,-130,-80,-517,466,-103,-157,-479,440,314,82,-434,994,-224,519,1365,-1195}
     },
     {
      0,
      -2840,
      {2184,1126,-57,-1214,-82,448,1260,-669,587,-525,283,139,3672,700,-671,1151,2625,2320,215,-380,-1325,-1041,-608,-1170,-127,-1652,510,358,-1160,-971,-220,-482}
     },
     {
      32,
      2056,
      {-2851,-1812,373,-1159,-2866,-1187,-543,-616,113,-1127,-1499,178,188,14,493,931,-1031,-1157,137,313,-2159,1082,180,368,306,624,-1109,-27,-1304,-670,-1060,-4134}
     },
     {
      64,
      -1473,
      {268,-2160,-436,-973,-230,1036,-210,-298,-431,-403,466,-284,-1090,-178,483,1070,-66,450,-1784,-158,-28,880,1681,-840,-1645,1038,316,1078,183,-1363,388,432}
     },
     {
      96,
      1626,
      {-446,434,1729,725,410,-632,-634,-339,-233,-22,291,1266,520,-420,-752,-60,-357,-539,-676,57,1468,-254,126,734,1134,155,-667,-953,2158,-921,-660,-67}
     },
     {
      0,
      2388,
      {-21,-1268,111,429,-994,347,-214,-837,651,-1022,691,-120,720,783,-309,-493,-836,-1181,-1116,-398,-2243,-1147,-645,-482,37,-828,749,-695,321,-1633,-402,223}
     },
     {
      32,
      -846,
      {-534,-1132,-108,1017,-975,1688,96,-463,-544,102,-868,983,1965,-435,759,-1430,-144,-703,-899,-506,-3018,1091,291,-885,-15,806,-3944,2217,-344,3257,57,-2156}
     },
     {
      64,
      206,
      {-963,310,-107,-419,87,-541,-424,-1181,-1168,-723,-1051,438,-471,-720,-787,-1728,199,75,-264,-881,412,-469,-1502,-1342,272,628,-120,-451,-481,-1611,-109,-1913}
     },
     {
      96,
      -1794,
      {-424,-84,-561,-625,-506,763,-314,-1164,27,370,-196,-1218,-476,69,134,937,-458,319,141,202,-138,323,1279,-924,79,-327,-381,1016,79,1401,1548,-4}
     },
     {
      0,
      -1848,
      {-1746,-1613,-2556,1063,527,-1900,437,921,916,-124,-1052,66,514,1908,270,-673,-1210,99,-281,1507,-1558,1599,223,980,542,1875,1892,1230,-584,1270,-1288,1712}
     },
     {
      32,
      -1508,
      {235,484,1002,-1905,106,-269,174,1071,-1731,438,-1331,891,-2036,31,-100,156,333,-572,-663,-98,-2319,313,-355,1099,46,-326,1308,440,1457,-752,-1190,415}
     },
     {
      64,
      -486,
      {459,-709,-940,30,-906,356,-696,-682,-1711,832,-471,-50,-646,-143,-462,-416,-248,154,-408,-419,-133,130,7,242,-955,410,-120,278,243,182,587,322}
     },
     {
      96,
      -2054,
      {312,57,-1055,432,-238,2066,-579,592,-262,-803,-684,550,-109,-142,474,-85,162,-859,-449,138,-499,-1211,1121,-276,32,-6,-600,-1020,85,1425,373,287}
     },
     {
      0,
      -765,
      {-385,1070,1850,-1582,1592,-1668,-63,-796,-1814,-1341,-155,-580,2804,330,-1445,561,26,678,-990,1878,884,1687,102,-978,-780,-550,-25,1423,525,833,1657,638}
     },
     {
      32,
      -461,
      {-144,435,1314,337,-1553,596,2203,-216,-799,-1206,426,2455,686,-576,73,-1999,-712,-1555,-1886,-714,-1889,-1142,2101,1592,955,992,-646,572,2181,40,799,724}
     },
     {
      64,
      540,
      {663,150,-276,-199,-995,617,-178,983,-344,-66,366,523,-1063,132,153,-300,387,535,-608,655,227,682,193,-366,-867,808,366,340,940,-27,-935,695}
     },
     {
      96,
      -2146,
      {-1285,735,-146,-27,417,-1220,-377,57,364,103,-275,512,-176,177,-246,-273,-1609,-153,-95,631,431,432,-1226,1110,726,1590,-597,1137,216,318,-93,-666}
     },
     {
      0,
      -171,
      {-300,979,6,-2211,-1265,975,180,135,1436,-27,248,436,-3921,-1480,126,893,738,1463,669,-1813,-1055,-1711,1556,1078,529,1985,-572,600,-1007,-3167,3177,-1224}
     },
     {
      32,
      -584,
      {902,566,564,-68,63,-1322,-504,71,-702,-1776,-955,-89,-611,174,-1610,962,24,-6,-11,1319,-2117,-1217,-1188,749,955,-11,-1656,2306,-832,1783,269,-2741}
     },
     {
      64,
      -1014,
      {-331,-626,-1243,759,-7,-688,-134,74,-146,-226,25,158,-1065,1727,8,-742,-354,-960,-1694,-635,-1103,21,-1036,-815,-1068,377,-49,166,-628,1296,-416,-147}
     },
     {
      96,
      50,
      {10,361,-75,-168,174,-393,-650,391,-339,-1435,460,160,-435,-140,-512,-296,-25,683,-429,-710,-255,1931,778,183,828,-944,137,-1277,-17,-286,-239,560}
     },
     {
      0,
      -123,
      {-1561,-432,-2195,1146,637,-371,-1680,1123,-127,-1021,1008,-240,-324,844,-676,2893,2240,34,-2141,-1904,3044,-801,466,491,879,1655,562,199,333,216,1747,1663}
     },
     {
      32,
      739,
      {-1077,-54,-494,-214,-3427,322,-138,-1429,-3041,-1273,305,977,-538,1,1348,-1678,-1414,1021,708,39,667,-562,2138,-1030,-581,655,-132,106,722,-243,117,-1748}
     },
     {
      64,
      -2358,
      {-682,-25,-517,1275,-498,-533,-187,575,154,-190,99,-33,582,807,-174,-617,-1152,-585,-290,379,-925,-1109,-846,454,-427,-302,497,-456,-137,444,-1647,-489}
     },
     {
      96,
      -115,
      {-1487,-679,-654,-61,-6,355,1397,147,-654,-299,-1101,482,1103,771,599,821,-1657,-303,-584,132,370,-415,923,-479,-2,870,-523,23,92,-151,-1354,382}
     },
     {
      0,
      -4174,
      {1746,1521,-45,-460,-1475,375,-111,-319,-358,373,1302,-591,-2063,1632,1028,563,1887,-444,811,3047,443,-241,-523,40,-1580,994,640,-1162,-285,2515,863,1605}
     },
     {
      32,
      2413,
      {917,452,217,388,1555,-358,1784,347,327,-401,-289,558,207,-1094,-1139,-2669,-673,1143,-743,-499,1375,267,152,1324,-72,1077,927,-2486,-1068,-835,-386,473}
     },
     {
      64,
      512,
      {-506,78,120,123,-20,361,129,243,1067,-192,-1055,231,104,375,-296,415,-1000,135,831,918,311,446,1318,-277,579,101,153,-428,1736,165,-1283,-1457}
     },
     {
      96,
      3501,
      {146,309,619,-943,401,1114,726,-756,-321,-13,-409,-1022,271,-129,1004,1421,86,73,-336,-1638,-299,-664,2282,-991,-218,19,507,-2355,-178,-1056,1317,55}
     },
     {
      0,
      -214,
      {1811,1025,347,974,902,17,-3160,2324,-400,-933,2393,-662,-1992,-228,-1145,1348,-1308,1084,686,-158,-1758,1974,2853,-1784,-1539,-686,-1787,770,1266,-934,1025,7}
     },
     {
      32,
      2518,
      {-2472,82,631,2095,-713,-746,-217,2189,-1073,-492,-1169,392,-218,-649,1136,-132,-1206,2037,-1453,-745,-1699,1514,869,370,-1330,1833,-417,-1296,-625,570,-995,-1344}
     },
     {
      64,
      1411,
      {-343,271,394,223,215,174,-341,-641,-775,61,-610,408,-496,175,582,-603,447,-1716,-1314,-863,-5,126,-844,631,-244,28,365,-445,599,33,-523,-1282}
     },
     {
      96,
      2614,
      {-90,18,-851,511,20,1044,-533,-301,550,-212,895,-523,59,108,320,-649,397,948,517,-17,-19,-1186,-188,1869,-1175,-1303,1156,-439,116,-163,-260,150}
     },
     {
      0,
      -2737,
      {897,2084,-293,-1739,1079,-1736,786,529,1212,-933,-665,-554,21,160,-1120,1661,324,265,-368,-301,-36,-371,930,-2146,1812,-49,-506,2683,-759,2309,2935,807}
     },
     {
      32,
      1076,
      {2718,680,-1690,77,2661,-1822,-285,-1041,-792,-393,-983,-1792,-1901,-498,-989,1464,-296,-1982,-695,-1,1512,1,-2082,591,450,-530,317,2101,-2699,-1435,860,-1519}
     },
     {
      64,
      84,
      {1511,-106,-171,-440,1351,150,130,1417,-132,417,298,241,-560,1028,945,1878,408,1021,-8,-879,501,-422,601,-1159,-279,528,937,451,461,-83,479,1066}
     },
     {
      96,
      1508,
      {-504,-45,1178,245,299,-1100,-733,-483,314,20,205,284,146,-264,-16,-186,28,-988,-992,-672,254,-515,-1327,-1229,312,1735,-417,-725,130,-478,-930,-326}
     },
     {
      0,
      -883,
      {392,115,-425,1115,1115,-1278,-117,-759,248,723,1960,-967,213,-946,1170,-1393,223,0,362,-102,-788,1048,-25,3253,-93,391,76,1520,182,-914,503,-701}
     },
     {
      32,
      -336,
      {1903,-1975,-858,1014,489,273,-1016,-1034,-416,-50,1963,-3653,-2048,-17,439,1202,380,-607,446,17,-638,-936,-2083,-2166,1811,-873,-976,1963,192,-1463,1601,-1816}
     },
     {
      64,
      2643,
      {1137,-130,-169,-387,-59,139,-280,748,-705,-83,341,-236,-663,515,222,-504,1024,389,-521,-736,323,-1390,803,-1279,-1214,-257,-997,686,504,-835,1753,658}
     },
     {
      96,
      3190,
      {70,881,1090,-1324,346,317,-907,-158,-588,-147,-1054,-696,536,-312,-1189,-744,-222,318,377,212,512,-454,-1157,-440,-193,-636,607,85,318,96,235,53}
     },
     {
      0,
      -444,
      {1315,386,-75,-893,586,1301,628,-1711,-297,-500,965,1062,1908,424,-695,-1003,414,-115,-972,2365,2761,576,-3381,884,-232,619,-82,14,212,-3305,249,184}
     },
     {
      32,
      2729,
      {-2541,-2352,-508,144,-1535,280,-1738,-1787,1745,-615,-831,-2609,-22,61,-2579,-975,-246,-607,898,-548,-177,-792,-940,-819,991,1642,1350,-1287,225,-1450,790,208}
     },
     {
      64,
      99,
      {107,122,-528,-517,-379,-916,-293,-4,-359,25,-226,-856,154,-273,-824,-235,580,113,-440,-355,235,-382,-2798,-655,-85,444,-292,584,-393,76,834,840}
     },
     {
      96,
      2180,
      {-573,-881,-868,-767,266,117,1190,363,-1464,-458,-212,-636,-27,827,454,-68,-1612,1558,612,-812,-521,1250,-504,-104,301,-2661,424,-48,-426,-499,-366,-1201}
     },
     {
      0,
      1630,
      {-843,272,-946,-801,-511,2331,120,-1421,-2237,896,-1171,-706,1449,-511,-893,-638,480,-699,-305,-778,-592,-768,385,-382,-605,674,1938,-1255,640,-521,287,-533}
     },
     {
      32,
      1985,
      {-1146,-3294,-233,-61,-878,-1099,-1317,66,-278,-2404,-359,-282,-182,-435,29,-470,-1686,-257,-258,467,-485,-336,651,1314,104,-330,-638,-1213,79,35,-1112,-185}
     },
     {
      64,
      2880,
      {1860,-87,-1015,-185,-645,307,-611,699,-547,-322,820,487,-1251,611,-150,377,1219,-608,-208,-469,-919,48,-90,341,-504,-382,-961,1264,-518,472,252,974}
     },
     {
      96,
      -1292,
      {-163,540,1915,1173,569,-402,-978,-1351,141,390,-454,859,521,-1004,258,110,269,-1261,-13,684,2000,-145,-119,426,63,220,-1569,742,1421,-976,-1952,-576}
     },
     {
      0,
      540,
      {896,382,312,179,821,-282,602,-2486,179,-670,-1219,-1234,382,401,533,-1395,960,-3500,635,-955,-572,200,313,196,-6,-360,-423,99,-681,-1993,908,252}
     },
     {
      32,
      3762,
      {651,-80,-764,-300,-113,-1281,1430,-800,-937,-2004,-117,153,-695,-437,26,-1133,-252,-711,-1403,-478,437,-259,-1579,-888,827,56,-1325,-971,-541,32,252,-806}
     },
     {
      64,
      903,
      {526,321,390,1171,-31,-112,-690,1296,1042,-524,-1386,170,-158,99,-440,2180,637,-973,-422,787,-512,502,1244,90,-1009,827,496,675,639,-932,-803,1785}
     },
     {
      96,
      3823,
      {-806,311,872,207,167,-110,-433,-1900,-454,-836,-92,319,68,-257,-304,-1063,-557,328,-74,-231,447,486,-39,-278,-43,-351,4,-354,470,820,139,-275}
     },
     {
      0,
      786,
      {-935,150,650,-2484,538,802,-611,1616,-703,-2002,-994,1025,1294,551,-934,-1496,2339,-1247,-1400,-243,-529,83,-82,-946,-1772,-1961,2657,-701,555,-726,-1992,802}
     },
     {
      32,
      1710,
      {-154,-1815,-767,-270,-680,-784,-5208,-692,55,-556,-714,-839,-453,-1063,-2624,375,2253,-518,1445,206,-582,-1701,493,-2896,-303,-396,-256,2465,726,-762,-1763,-561}
     },
     {
      64,
      -1044,
      {22,-126,-808,-809,526,396,244,98,-942,184,-9,-177,99,0,-126,-722,817,1194,-739,-579,-1671,-674,-694,-540,-80,259,-839,309,-388,-280,794,461}
     },
     {
      96,
      538,
      {-56,327,848,-250,-622,-571,-162,124,1036,-26,-1007,-639,1520,1312,89,-214,289,864,856,-406,1486,618,1314,644,856,-169,-374,-62,1492,-465,748,-554}
     },
     {
      0,
      -95,
      {142,-275,986,1081,933,546,408,-1723,-319,-124,374,-554,-2449,980,-1017,-2801,1245,-777,185,1545,1051,624,2300,1647,1952,608,-1008,-772,536,2161,-369,1089}
     },
     {
      32,
      2028,
      {1,1691,-1728,-760,-113,-1693,1926,170,-541,-580,-418,1056,-246,-2544,-55,-509,-708,199,-1619,-306,527,1746,163,329,-224,618,200,-2193,-1333,153,1173,-771}
     },
     {
      64,
      -27,
      {53,-244,-401,-941,-1102,95,-679,448,-1040,128,-631,131,-1122,-139,-698,-51,-451,-309,-1160,-564,-44,-562,-177,-2009,-641,566,-59,-827,-205,-892,-328,-45}
     },
     {
      96,
      1292,
      {148,684,-633,-429,-92,12,-2262,-531,742,-1112,454,-14,9,-735,902,-926,220,452,-482,21,-1456,-237,1028,738,-1505,-1153,421,-24,-1326,358,-250,689}
     },
     {
      0,
      399,
      {-1155,-402,-734,732,-734,-874,-1472,472,-1633,-1303,1736,-564,1277,-1258,212,2819,1350,2019,-1658,958,-754,336,-166,-104,-1133,547,3381,169,766,-63,-43,1178}
     },
     {
      32,
      2326,
      {-98,573,432,-897,1507,-179,-183,-846,-1432,-1910,-186,-807,-473,-688,-194,-348,-2079,266,-1844,-1637,176,-1082,902,-797,1387,152,734,288,-456,-740,1777,856}
     },
     {
      64,
      -39,
      {482,-555,-362,-608,-1077,-256,87,-123,-635,-654,375,-257,-290,48,-311,-104,-235,-782,4,-484,-171,227,-543,-528,-825,-387,-534,121,-544,-19,-844,-363}
     },
     {
      96,
      871,
      {-78,-478,868,770,-854,-177,-1092,-63,652,-1222,17,1421,-345,-31,701,67,1184,-99,670,1,0,1106,2472,709,-2917,560,-440,-204,-82,-559,-118,-1632}
     },
     {
      0,
      632,
      {-970,562,-804,-130,623,1379,-279,739,1230,174,62,-217,-1926,-1060,1188,455,324,-701,-296,-864,-1113,-1717,575,335,-140,172,-74,-760,-389,1968,-856,-617}
     },
     {
      32,
      929,
      {-1071,472,-884,196,-2330,-478,-477,-738,-230,-459,-349,626,-678,-38,-2315,-797,-1674,-1150,1736,1744,-1658,-943,-506,3576,687,385,-271,-3271,-1299,-829,-1285,-1080}
     },
     {
      64,
      -529,
      {741,-616,-423,-271,-485,446,17,131,-84,-1272,113,480,-428,9,216,-60,-217,-1036,-812,-615,-201,467,1165,-20,-839,-456,1035,-394,7,-302,-1550,140}
     },
     {
      96,
      283,
      {-47,-511,749,275,26,385,-119,-212,-47,51,-341,793,859,-609,778,-108,98,-13,110,-331,1063,-824,1445,-560,-1419,819,-107,323,771,-154,1638,-12}
     },
     {
      0,
      -994,
      {-1448,300,185,250,-109,2192,1180,921,-1004,-969,724,-894,2275,-191,248,2367,1070,-885,912,339,-428,-830,-168,615,-136,1286,2091,302,-185,-180,-705,541}
     },
     {
      32,
      2632,
      {200,-1266,312,125,1486,1178,1197,269,-475,-663,1080,-254,-954,1063,1008,160,-718,-1039,-1239,-397,-531,-592,713,-78,482,-303,-855,413,-1259,-222,1036,3434}
     },
     {
      64,
      -269,
      {347,-553,-180,-549,-324,396,784,47,-112,268,573,-391,14,153,1348,1325,43,759,-549,-875,1175,-444,1161,-1141,-1295,105,689,429,555,-1146,-529,329}
     },
     {
      96,
      1457,
      {-1755,657,-608,169,-50,692,-1983,-611,-47,1641,317,-585,196,-421,298,-1060,-1089,523,-845,750,-225,1597,-10,759,219,-717,831,698,-195,-578,57,1656}
     },
     {
      0,
      227,
      {-713,-1005,506,-1262,-1053,251,1608,1065,150,1380,-430,-859,-1163,1549,1141,-63,-255,-114,56,-305,-510,-2710,-135,-969,-521,-843,-832,-1199,-1777,429,469,-1056}
     },
     {
      32,
      169,
      {-797,-1365,573,-164,32,210,-1280,-2394,-465,-1951,-92,-463,174,-84,-926,-35,703,176,1783,308,-631,-1789,1296,-366,-1003,358,-1702,-294,443,-165,-977,-737}
     },
     {
      64,
      -891,
      {1156,-283,1,-389,671,246,494,-404,-463,147,1091,-662,-163,156,1508,130,932,870,-39,-25,1259,-1290,165,-1747,697,477,-175,1138,868,-649,455,-475}
     },
     {
      96,
      1510,
      {-2480,108,-1609,258,-515,486,-65,-436,1529,-161,766,711,16,-1534,-243,-694,-666,-56,-337,87,486,-769,-850,-1815,-2364,2660,622,-215,500,-887,-150,-1284}
     },
     {
      0,
      -387,
      {-432,-411,185,-115,-3153,77,-762,-1413,-566,-538,-410,647,-464,-582,428,208,-46,-609,2348,-1747,431,-1619,20,-904,2407,234,-1257,1276,818,1181,-2280,839}
     },
     {
      32,
      2243,
      {551,1726,-455,1294,206,590,89,-437,340,-485,-1861,-684,-2546,-917,-2038,-284,1568,235,-761,382,1624,448,-2000,-1665,-673,-468,185,437,707,881,-1437,-1365}
     },
     {
      64,
      381,
      {-194,258,70,-151,-176,-159,-558,-223,56,-315,540,-85,3,-89,-390,-677,320,-123,-299,749,-360,-639,-341,-68,-384,-291,32,118,-155,806,-862,0}
     },
     {
      96,
      18,
      {-90,1115,-1385,168,276,27,288,508,-985,629,244,-66,-265,-81,654,2217,79,367,339,-418,-1466,-1404,-940,-151,-9,506,206,-324,-1697,-3001,-136,1173}
     },
     {
      0,
      72,
      {293,-157,-552,-182,168,103,-715,2038,-137,-527,163,-590,-408,28,-432,702,-606,632,87,-570,-527,-221,-306,-69,-405,-315,895,272,-733,708,-486,-924}
     },
     {
      32,
      367,
      {-226,-1419,323,997,-1380,266,-684,-623,-31,380,133,-112,610,-1353,-630,382,-1080,180,959,-1041,-62,-430,-168,-134,-187,1363,-52,775,-68,-885,-551,-111}
     },
     {
      64,
      -521,
      {-197,599,171,588,114,194,46,-133,-352,-290,-372,489,78,-132,742,-215,-32,173,355,-165,960,-646,-539,205,501,644,-492,-722,-274,-610,-130,-37}
     },
     {
      96,
      380,
      {-514,-194,-1356,-167,-1053,-747,-2282,590,-566,349,222,-408,72,935,536,-164,-189,-260,-152,316,-2270,109,1256,-354,-393,91,603,-122,-1220,-1178,-2458,994}
     },
     {
      0,
      -95,
      {-778,-324,-190,2,873,-54,63,1185,-155,1162,66,1142,-30,-275,199,779,-405,-56,-1472,-64,-374,100,888,-16,-116,417,-76,-712,-480,610,23,558}
     },
     {
      32,
      615,
      {258,-267,-6,-264,399,336,202,-354,-307,-371,359,-179,239,661,831,-795,-589,-367,-377,315,968,272,-337,462,344,489,203,-578,539,139,-67,-318}
     },
     {
      64,
      -206,
      {-125,492,382,731,307,315,-594,-51,-260,-1000,446,-181,143,-305,460,385,14,-7,675,694,20,-392,148,301,550,-327,-193,-193,-188,-724,-988,48}
     },
     {
      96,
      213,
      {-828,-1044,1006,430,63,1755,358,-1314,607,-366,270,-101,244,-914,851,-1277,1072,831,56,-15,1184,-129,-141,490,-690,-1085,559,511,1151,320,410,788}
     },
     {
      0,
      -169,
      {60,622,142,-1191,-404,-320,-337,948,635,-906,302,1162,726,-615,-629,416,1674,-87,-1163,954,256,423,652,311,327,146,-85,1027,509,291,605,91}
     },
     {
      32,
      348,
      {-2530,1625,-438,3,396,582,707,106,-1502,-868,705,-1086,658,1268,-320,-531,230,-1057,-909,-1664,554,-73,-838,462,-982,50,-49,-457,352,-366,920,800}
     },
     {
      64,
      -605,
      {160,357,362,169,-388,-212,-1160,-884,99,73,-573,216,-15,-111,621,-885,167,641,93,38,490,102,117,219,706,273,-202,-369,-152,-333,-152,-519}
     },
     {
      96,
      1496,
      {307,255,455,-456,244,437,-214,697,429,299,575,-240,46,-96,-301,300,-341,0,167,-429,-26,-247,-548,-87,738,162,-93,-528,-4,-549,734,-440}
     },
     {
      0,
      -314,
      {-432,328,-2,-251,825,-670,268,394,321,720,182,-273,-185,-171,10,-552,-1029,152,480,118,192,168,660,217,224,487,399,-753,479,455,-68,-67}
     },
     {
      32,
      -893,
      {-180,-647,-69,576,-221,-369,-677,167,-36,1084,-257,1193,0,-117,-256,796,540,829,-261,-546,-1031,177,408,-430,-212,-452,-442,-307,356,536,12,528}
     },
     {
      64,
      633,
      {132,-434,261,494,-195,120,-206,75,-55,248,112,102,-100,97,-748,397,-611,361,116,487,1,-156,320,43,310,333,-20,243,-43,-51,-298,-196}
     },
     {
      96,
      136,
      {-128,-114,164,140,18,-209,-15,-8,246,84,-62,64,66,39,-139,21,66,342,288,-56,64,247,-199,456,-180,38,0,14,40,181,-150,0}
     },
     {
      0,
      79,
      {157,-49,35,-5,170,87,-87,186,40,148,400,343,62,-79,139,184,226,-261,64,45,-187,265,91,-66,181,-74,-69,220,240,276,-96,-116}
     },
     {
      32,
      116,
      {-66,394,99,41,199,131,68,396,135,41,97,222,93,-38,66,124,75,-16,223,178,211,-27,-33,94,72,-21,287,156,-98,-187,117,255}
     },
// *********** Cells of layer 3 *********************************************

     {
      128,
      -1463,
      {-2934,-3899,-1475,770,-1203,562,-1268,-752,329,-740,-38,-132,-574,963,-262,-289,523,1574,-682,-438,-660,697,71,-158,-1695,682,585,-47,-419,369,-928,-119}
     },
     {
      130,
      1663,
      {-302,-579,-2038,314,120,-10,311,488,-159,45,-1226,-919,81,-267,-2186,-1344,312,-973,-2345,142,97,-189,-73,-1145,-900,-610,-786,540,-619,-315,-275,-1571}
     },
     {
      132,
      -4178,
      {-46,1400,-935,-14,1156,1549,-82,-141,-259,-336,-628,120,3112,273,-1461,-723,-28,-289,79,237,-1669,-454,1295,115,-1926,1121,-876,-153,2122,789,88,-48}
     },
     {
      134,
      -1433,
      {-2091,1546,-2066,-830,-321,-695,-1415,1182,273,-122,1065,1219,-240,-1038,-1748,-1106,227,362,-627,-264,-228,-171,0,1767,-827,66,645,1403,509,-16,-288,-744}
     },
     {
      136,
      -731,
      {1176,1258,-85,-274,-446,-515,87,-67,1394,-667,-338,-190,-270,618,69,327,-986,-494,-16,-199,-1918,114,-253,316,122,321,-22,45,-282,-515,90,30}
     },
     {
      138,
      -1024,
      {-243,96,-1109,-263,-296,-1176,-919,-1949,-127,-2678,-1939,884,1189,-554,748,-852,290,1182,-2321,258,-257,-159,2017,-2165,174,151,1713,-279,-293,-195,1424,-1163}
     },
     {
      140,
      -3285,
      {107,-826,1145,56,-2656,3630,-290,-979,2192,212,226,-248,-2085,-139,627,-429,-259,-170,155,184,1103,-2179,-282,274,-738,-169,-561,-62,-132,547,-1155,-574}
     },
     {
      142,
      57,
      {733,-339,-1349,1224,-231,-1258,911,333,-928,-270,-1053,-240,7,-285,-433,471,-1366,62,-1226,-233,-619,-23,-464,-130,-339,230,-143,-1151,-260,177,-701,-363}
     },
     {
      144,
      -689,
      {1161,1088,-838,-930,-101,-647,-640,64,-53,-1736,34,797,-1078,270,-157,5,1380,821,169,-87,-143,-706,-268,225,-329,-1176,-548,5,-334,191,-1240,-44}
     },
     {
      146,
      -5368,
      {186,-2380,1560,-2088,-108,-597,1063,-1292,393,-180,-575,17,627,-224,1144,-1157,262,205,-168,90,847,-242,2554,-187,-641,-2,373,214,284,936,1323,194}
     },
     {
      148,
      -363,
      {-2574,1448,-847,-244,-1660,-785,-190,-285,-221,274,-677,-41,-1153,-117,535,-23,-498,151,2105,165,529,-1549,100,126,-783,-1125,-550,183,312,-306,141,-33}
     },
     {
      150,
      -1652,
      {1449,-89,-37,-1327,419,-760,-1886,1730,549,165,308,289,-189,52,-1496,-1169,-216,-31,932,-1195,-25,421,-681,183,-344,148,-203,-332,126,0,1038,-834}
     },
     {
      152,
      1153,
      {-1666,-476,-851,-258,-245,-53,-59,-235,-649,268,-602,95,37,394,-62,-26,125,-635,290,-91,-412,-4559,-996,-738,-1136,91,-189,453,-1327,768,-836,-18}
     },
     {
      154,
      -695,
      {-695,196,303,794,251,-141,-105,-509,-721,-1,-881,88,-255,30,-678,-827,-578,-3,-1206,-303,-459,-414,847,317,43,386,-860,898,651,108,176,-997}
     },
     {
      156,
      -1610,
      {371,1463,396,-301,194,-1397,-635,-330,425,-594,118,56,344,210,-167,-172,878,147,524,28,327,-1077,-85,-256,-1489,-612,-64,188,1439,-696,-713,277}
     },
     {
      158,
      -516,
      {-623,333,628,-2331,-1249,78,-526,82,1532,-1108,471,-1189,1423,-245,-131,-332,-769,-288,247,185,888,71,264,61,623,-1048,-504,-703,-121,-424,-3191,-127}
     },
     {
      160,
      -1549,
      {1851,-624,348,270,110,-310,-1281,-650,473,340,-214,-53,-22,-818,-709,-497,230,-789,254,-222,-118,146,-770,-15,-1159,381,-267,99,-376,-1318,-642,-291}
     },
     {
      162,
      -601,
      {950,-4,176,189,-1361,-5,132,-1083,-65,78,-799,347,-1001,-114,564,118,157,-7,-1688,-43,-674,-9,999,-731,799,-132,521,-97,-354,-63,-769,19}
     },
     {
      164,
      -2488,
      {-748,313,498,-78,-139,-327,567,-77,-506,2250,-294,-254,-57,721,19,66,-422,836,1167,35,2243,258,-344,-283,-825,915,708,118,-686,-1495,-872,-91}
     },
     {
      166,
      -2893,
      {-642,-37,1949,-1176,154,150,-325,-1164,-250,137,-914,176,-243,30,-364,793,-1395,-317,1798,0,590,174,-1794,-1041,-611,177,602,1761,547,58,1090,-1556}
     },
     {
      168,
      -783,
      {-860,719,458,-154,-1688,-2040,71,-12,1627,-944,-325,313,-770,-319,-697,-207,777,-438,-731,-232,1141,-900,470,84,-2359,818,105,-128,-47,933,135,-362}
     },
     {
      170,
      -1947,
      {142,-127,-1576,95,1743,349,1814,-995,-656,70,-1480,-297,-601,-252,1139,-911,-1276,-325,1477,-557,-1079,28,-3568,882,943,52,868,-88,-13,-362,565,-141}
     },
     {
      172,
      312,
      {-1958,-2378,-778,-90,-216,-1534,59,161,-1074,-731,-401,-268,442,8,590,348,-2244,-1208,-279,186,-2840,-287,659,65,-553,74,-835,-564,1077,369,269,263}
     },
     {
      174,
      -3147,
      {352,-225,755,-443,-97,361,730,848,-136,753,237,-1594,-887,-809,681,-583,-449,-92,-2280,536,-162,335,1316,245,86,149,-776,-1774,-616,-539,1291,361}
     },
     {
      176,
      -2293,
      {-362,705,138,-353,-1754,1531,-1108,458,-379,494,949,173,-532,763,551,-581,-432,1938,-1509,512,1328,-1691,-250,507,418,-1799,383,-403,237,503,13,351}
     },
     {
      178,
      -604,
      {-29,-204,-1258,650,1149,744,84,-870,-1198,242,582,472,-573,-126,66,226,-2372,164,-989,-392,-314,252,-819,-319,-41,-85,61,1421,869,-83,-371,19}
     },
     {
      180,
      -2460,
      {-121,876,-954,798,639,196,-1034,27,-4016,287,-1750,680,846,-1995,608,-506,-186,250,-641,715,-807,845,-55,-518,1789,-403,90,-122,-1684,-236,670,416}
     },
     {
      182,
      1859,
      {1224,-698,1,-525,-1011,-201,-176,-2724,443,226,-2422,-1692,-267,-1246,-867,-13,-104,-3427,-1499,-1237,-2091,-577,403,-1183,-35,-74,-1581,1842,-44,155,-1831,-2716}
     },
     {
      184,
      -3522,
      {149,1510,75,-622,1418,218,78,-83,790,748,330,192,159,1525,-2084,-347,-2251,-1027,-1592,112,4156,-952,-2811,-509,-35,-2559,-2016,-429,-2284,-171,-820,471}
     },
     {
      186,
      -1052,
      {455,513,-111,-406,386,289,94,-1106,-58,-9,785,-3706,-808,-231,-530,428,-555,715,1550,-764,-7,-26,175,396,-370,-486,-6340,-2922,165,-1322,-613,-2853}
     },
     {
      188,
      805,
      {-3016,-1376,-296,-712,-202,-1617,-1376,154,-2249,1042,-753,-190,-4455,-1151,-455,-210,125,1296,-380,-1156,-1394,-1643,-491,213,1620,650,-336,-532,2440,1455,-167,93}
     },
     {
      190,
      -2101,
      {-783,-356,-504,-279,1065,-261,-1022,-151,-1708,503,-2428,-512,-302,-81,4249,-412,-717,135,365,841,-248,87,221,-696,-449,-75,160,-413,-340,-792,-3109,-732}
     },
     {
      192,
      -1552,
      {-2313,-730,-187,-286,-236,110,-1594,-1184,424,-122,-394,-540,259,2101,22,-235,-103,-1224,-313,45,-2381,-688,-296,573,-2140,1195,75,-145,273,1592,31,-76}
     },
     {
      194,
      1469,
      {-454,-275,300,-3132,-1657,846,1481,-140,-958,-215,76,-100,253,-471,-1301,-43,394,-129,55,-705,-318,-604,-2078,-2153,-262,-799,-1499,-1930,207,400,-638,-1366}
     },
     {
      196,
      -1926,
      {-56,1614,-1688,416,-757,-1489,-1264,596,1707,-857,372,-486,-617,1495,388,175,53,-1620,8,-933,1508,384,251,-372,-1338,1471,-316,91,841,-1857,954,-229}
     },
     {
      198,
      -2300,
      {-1123,-212,-679,-899,855,-101,2848,-1892,-1401,-603,767,2539,-393,-283,-298,-4721,-51,-114,-707,-961,168,32,351,1061,564,-373,-475,-1528,-2318,-765,1303,-47}
     },
     {
      200,
      25,
      {-1730,-1318,-1253,627,1029,-108,25,-168,471,-1623,5,228,847,-1548,-38,-773,-2844,-1129,-195,-640,-2505,-2493,-761,422,-3460,-1825,-575,11,-3241,1176,460,221}
     },
     {
      202,
      -1516,
      {-711,289,82,929,-625,-526,-649,1579,-8,-310,-448,-243,-7,765,-953,-353,2,-520,-2066,500,-313,864,-402,-830,-69,409,378,870,1712,-1042,-1494,1045}
     },
     {
      204,
      890,
      {-498,372,-662,-246,-18,-2364,-46,86,-2450,-1313,1223,-563,-2464,-1274,281,-1068,-714,-1314,60,84,-445,-235,-634,-194,-1512,-755,-139,-124,-703,-973,626,-11}
     },
     {
      206,
      1266,
      {-303,-57,-406,-905,-639,-353,376,547,271,-302,818,-3503,421,-1166,346,174,439,-111,-2444,-776,-1201,-248,75,-637,231,-416,252,-531,-145,-405,-4144,-1418}
     },
     {
      208,
      -1733,
      {-221,230,166,-755,-2452,-1610,531,-423,-298,199,101,412,-4,-182,1031,-204,1981,-141,2540,543,-92,1208,-703,-490,-141,-743,347,189,-1909,224,-2159,496}
     },
     {
      210,
      -567,
      {676,109,-1294,297,423,-314,-546,-2160,-83,-172,-494,-50,519,-310,1683,-82,630,19,-1482,-654,-207,-573,70,-1097,759,-22,-1340,-1083,-182,-44,-1692,241}
     },
     {
      212,
      1307,
      {-1304,-1014,183,-2883,-1094,895,-604,204,-1033,-1016,460,-1121,573,68,952,610,-2364,514,549,-991,-1046,-1063,-769,11,-831,-450,-2008,100,-2375,67,1681,309}
     },
     {
      214,
      3808,
      {199,-1463,743,-5152,32,-127,-3781,452,27,-884,-745,-1834,-86,0,-287,-1097,289,-1022,-1337,-615,-57,-376,-446,-1208,-1268,114,-1074,-1383,0,-593,83,-3584}
     },
     {
      216,
      -3279,
      {775,-112,44,-398,-42,1231,626,40,518,-171,-1915,8,-2129,-413,-985,252,-2242,799,433,660,346,-768,-1089,3,-766,2139,-2053,-406,1201,-1674,-245,21}
     },
     {
      218,
      -1192,
      {-163,-257,-1426,374,-33,582,838,-1059,-1513,146,435,-1156,-2320,146,-525,-981,652,544,1064,-823,387,-252,-607,1304,-395,-936,-1301,1153,-1580,327,235,-39}
     },
     {
      220,
      1144,
      {-56,-1066,383,-441,-3491,-603,-2027,-435,-2214,896,-598,-77,223,-1749,-148,-534,-1996,-688,-1217,-480,492,106,-693,-363,-291,1985,499,-1207,-97,-5002,510,223}
     },
     {
      222,
      945,
      {196,-347,-1907,-376,-52,-372,483,383,385,-450,-136,-1685,644,23,-5738,-580,-718,187,773,-1348,1042,-996,-377,1039,-116,-744,555,-829,-492,-30,265,582}
     },
     {
      224,
      -3318,
      {-2208,751,181,-51,-1330,1551,153,-178,398,-2160,223,315,-2017,-708,86,282,-1927,1576,-95,-109,1021,65,-386,-60,79,-776,305,-111,1536,1229,-62,437}
     },
     {
      226,
      554,
      {-571,-123,-892,-796,-1094,100,1500,206,407,-125,-54,-2332,33,630,-2295,-2207,147,352,583,-2075,-1489,-553,1608,-1591,-1649,348,-2041,-77,-897,-289,-625,-390}
     },
     {
      228,
      -276,
      {-2247,-609,-977,-523,494,-681,77,498,-1470,-1851,-753,913,-1082,-168,183,-239,-874,1155,-1785,-151,1795,-1699,-266,-991,-815,-434,142,346,2606,89,186,-425}
     },
     {
      230,
      -2300,
      {-307,-313,-302,294,-392,414,-286,1587,482,425,-409,253,341,-222,-3466,-563,-381,91,1449,-548,-487,-696,93,-1616,-209,395,-11,1797,168,-205,-1465,771}
     },
     {
      232,
      -1134,
      {-1439,-1653,-326,-89,-2116,-599,-588,-131,-324,-80,-93,-9,-124,786,-344,-330,310,-2576,353,-107,-81,459,721,848,-933,-928,-296,393,2048,616,-423,-530}
     },
     {
      234,
      -1060,
      {639,141,1543,10,-584,51,-1721,1395,-1218,-668,680,776,-522,80,-772,-743,-160,444,-46,603,-133,-226,-173,-1938,-749,349,-1080,342,1829,172,-3258,880}
     },
     {
      236,
      -3989,
      {-1729,1590,-359,12,-1398,1662,-38,-21,22,-750,-544,404,1137,1427,-194,230,1153,544,356,-46,-441,226,242,-167,-1466,801,1583,-45,-2627,1313,-1021,260}
     },
     {
      238,
      -3257,
      {-1790,-411,-1418,-175,-357,-1019,-590,-1285,-490,163,119,-1587,290,61,784,-376,-405,447,-1218,3932,150,388,-1070,-616,1372,-523,-1576,1152,-654,-344,-2908,1152}
     },
     {
      240,
      -736,
      {-2892,1607,-827,-415,-580,1256,-2361,-453,467,-1308,407,282,-1790,-3369,-3444,382,1296,-109,-497,444,562,776,159,422,515,-1870,-1762,-445,-367,-1395,-6,-234}
     },
     {
      242,
      962,
      {201,-151,997,-856,667,-244,966,-1836,591,-219,-1226,-456,183,25,-1191,1241,-746,95,-1055,-1958,892,-22,-960,-2078,-539,-62,-3265,486,-32,344,-1406,1501}
     },
     {
      244,
      -4576,
      {1151,1820,-1516,-542,-1009,-4969,-661,-165,-1417,-1312,367,118,-1162,889,355,769,711,1023,1235,-5,-57,-1975,-1150,-157,-35,2287,1194,421,30,-1241,789,-205}
     },
     {
      246,
      -303,
      {-91,99,544,-263,57,633,-739,-466,-650,92,2188,-554,-888,-454,103,1841,-1761,-301,362,848,186,-190,-1269,796,-356,-535,-127,-323,11,-205,-4016,-1680}
     },
     {
      248,
      -1576,
      {1968,-2750,1639,-796,127,1454,-768,70,-1317,175,-19,221,1353,553,382,-312,-136,-368,-1591,-370,-2878,1891,-1060,324,175,-2116,-957,-466,1024,-1263,-1327,-1798}
     },
     {
      250,
      793,
      {243,-454,-490,-2171,-2132,681,-187,339,446,574,278,127,226,-245,-847,-2154,483,-689,-3646,1021,-527,53,1081,-20,-635,-581,198,327,-656,-1124,-1668,98}
     },
     {
      252,
      -3880,
      {878,1256,-383,171,236,-108,-1857,-1274,2171,-255,577,-619,-668,-450,-655,192,-2362,-1272,-1419,431,1302,-1791,390,-533,1477,2100,835,-1020,146,-294,-1990,-1099}
     },
     {
      254,
      212,
      {-444,305,987,1306,-782,-174,-505,-2705,-235,-512,-1062,-2218,-1032,598,1706,-1495,-747,-365,-699,-1510,-2565,-90,22,-1789,-671,-311,-244,-725,-2037,408,-1911,384}
     },
     {
      256,
      15,
      {-1518,343,-744,-128,1456,-2801,-1303,134,-1414,-1779,-205,1360,-647,-2098,36,-562,-1813,1904,-680,-1078,1578,-145,-808,-1108,863,-2600,-316,335,-1796,-383,-596,-17}
     },
     {
      258,
      500,
      {-430,-156,-611,1859,-408,1282,399,968,211,635,690,-711,1424,-1351,-1101,439,-107,931,-1149,-1188,-952,-1391,-4685,-1905,791,-1030,-3084,1190,633,-1766,-2232,-412}
     },
     {
      260,
      811,
      {249,-25,515,1099,150,366,-1794,467,-1563,-2135,-399,-511,1420,-1507,-286,-76,16,1016,-1179,-125,92,-3374,483,337,-2186,-449,-1447,-426,-2365,-1241,-630,169}
     },
     {
      262,
      -2895,
      {-381,129,-788,261,1208,-675,2361,1019,197,-196,-1598,1560,186,237,-84,1387,-892,1258,-1972,1233,-121,-744,-146,2057,2002,290,-2092,-1793,-1288,-1029,3409,-1368}
     },
     {
      264,
      -1252,
      {-376,3303,102,-1467,710,1248,326,530,1725,-757,-262,-1188,-1778,1249,-529,-156,-924,-1251,-57,394,-2970,-156,1351,1464,-3705,-1772,-541,955,1105,-3272,-785,-839}
     },
     {
      266,
      -1405,
      {31,195,-566,-319,-714,-730,-3989,-980,-1883,584,2718,-1133,-334,-65,-534,-841,-2324,-906,48,-1244,-1895,-209,2518,-38,387,-1314,-1407,-500,488,234,1973,-2169}
     },
     {
      268,
      -2013,
      {-1292,915,-2209,-295,460,44,-143,303,-781,-137,-586,-463,556,-1021,-614,-813,273,2582,714,-432,-156,-1040,-524,-147,1233,117,-312,319,6,1595,-624,-114}
     },
     {
      270,
      -1982,
      {621,473,815,647,-454,-1277,-1032,-519,-30,-511,-2048,-946,-368,332,673,832,-726,322,1605,-559,803,232,-91,687,255,1900,-3746,196,-2001,-1609,-326,-866}
     },
     {
      272,
      -5356,
      {2396,-541,-1009,291,-1660,-259,-966,1016,-72,-3367,-224,-1446,3494,608,1228,1054,667,-981,-1040,283,1197,-712,461,-490,526,2053,719,-1259,-1172,-49,2784,832}
     },
     {
      274,
      -2471,
      {68,-14,-809,457,-365,-876,953,-1621,10,853,111,1521,725,382,729,-1013,11,888,1474,-898,414,-26,840,-312,659,-121,-2761,-1013,-206,627,-3067,1055}
     },
     {
      276,
      -693,
      {-1578,293,1670,-340,174,-982,-850,473,61,1988,-837,-479,346,-2295,-134,-329,-2005,1567,1421,-95,-794,-480,376,-733,-1568,-3662,-826,-1347,-2619,-1980,986,171}
     },
     {
      278,
      -3295,
      {-425,-221,-495,-1350,195,78,-552,2163,-462,439,101,501,-418,-661,1145,105,-157,115,239,-336,-893,-449,-955,864,-332,-377,-2559,553,-405,363,-2612,2906}
     },
     {
      280,
      -749,
      {-122,-1368,-670,-940,-787,2351,-408,-528,-1429,-546,-35,-1350,-2012,334,64,423,-1404,1888,-61,-661,-1112,33,-248,-845,-1997,898,-175,653,-282,-4329,-410,-1855}
     },
     {
      282,
      -1503,
      {-226,-738,-684,2741,-385,-999,-1133,1009,-505,-1323,-3324,300,117,242,-2703,-1479,-19,-608,-2105,873,-269,-794,565,742,-644,1321,-613,1116,112,-1586,-936,308}
     },
     {
      284,
      -1221,
      {-1247,-1160,-401,-1273,696,898,-22,-1937,-51,2428,-97,-2132,1607,1484,73,188,-1150,-919,1360,942,-1786,-2782,1262,-1960,-2380,-1287,-79,164,2330,-92,-1923,-880}
     },
     {
      286,
      -262,
      {204,-714,36,2527,-658,444,1219,-560,-803,-1982,1044,-1866,-456,-149,-266,1767,-506,-1154,-1681,-2341,-110,282,-1470,1756,177,-523,-1263,-460,-1450,122,-314,769}
     },
     {
      288,
      328,
      {-406,-12,-554,560,868,-728,60,525,920,-270,680,24,61,781,693,-848,-934,-785,540,383,-914,482,-1017,-1225,902,-3519,-950,-570,1758,724,-23,713}
     },
     {
      290,
      -3029,
      {-748,663,194,-2472,105,591,1455,-1318,750,329,-473,-1172,-578,847,-426,1450,1731,-920,423,992,-122,-249,-1230,-1149,-1282,-470,724,3050,358,753,1896,2452}
     },
     {
      292,
      -1339,
      {1038,-283,-256,1616,2917,-7,907,-1595,-1318,-628,242,397,-516,-469,650,-594,-1022,2594,-1258,-26,-3416,-413,251,-793,-573,-351,-1361,-1471,-1803,632,143,-2715}
     },
     {
      294,
      -1049,
      {-410,-2389,-1533,2187,-233,-891,-1121,104,-263,145,-1623,790,-95,-23,-1096,710,-503,-285,-604,461,371,1154,-231,504,-1297,-1574,-1527,1130,-380,-2420,-1280,1483}
     },
     {
      296,
      -2595,
      {-2007,1807,-101,-53,-1794,-1803,337,-671,-694,-1622,-154,-351,1064,-471,-162,-421,-1636,581,-464,51,1404,-276,-469,692,-661,339,1181,-78,-2077,-547,-500,1034}
     },
     {
      298,
      -2181,
      {-599,335,198,544,-526,-13,-1895,1154,-731,-5,-719,2491,-747,913,658,-817,-824,-729,-2752,641,235,662,-1848,-468,-710,-845,-725,-2252,927,-1587,-952,984}
     },
     {
      300,
      160,
      {-735,-18,-217,333,-2232,-348,837,140,-1647,-138,-576,-1407,-1408,-204,257,-348,-1460,836,137,744,-298,1693,-511,-284,-184,2449,-27,-622,-2271,425,-1024,-1226}
     },
     {
      302,
      -931,
      {-396,-2286,-2255,-392,-629,468,-967,901,-553,-398,-291,-192,-370,2169,798,688,-1070,-428,-1390,1023,-195,-82,-1189,311,-96,-2750,-1418,-1034,15,-1957,-257,-1418}
     },
     {
      304,
      -2727,
      {834,-661,-409,-359,2501,-1024,-271,-909,272,-334,-789,-106,408,-537,-619,122,1825,-2043,325,459,-395,-714,166,-393,-261,-691,855,-1227,-3699,3407,-1019,-1965}
     },
     {
      306,
      -549,
      {-612,3,1338,-1978,-595,-546,1226,-1188,-1551,-360,-425,-1024,-564,498,-759,-1626,-373,-69,666,-940,-700,-1403,513,-1585,707,-156,-602,-1878,-1363,-206,1526,2246}
     },
     {
      308,
      -682,
      {1948,-216,-341,-102,811,-604,-150,-664,254,-913,-661,-426,241,-42,-263,628,712,-1379,-281,-222,963,-1062,-310,-573,-217,-861,1424,-675,-1019,-992,-2180,-839}
     },
     {
      310,
      -328,
      {-4,-43,-64,-305,-88,-178,-132,-207,-40,-375,-228,-55,25,-112,-164,-96,-143,6,-4,15,-119,-74,-34,-45,-204,134,-309,-252,-50,-166,-143,-128}
     }
   }

 };
#endif /* MLP_PRELOAD_MODE */  

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\snn_imgg.cpp ===
// **************************************************************************
// *   NNET file as Cpp file                                                *
// **************************************************************************

#include "snn.h"  

#if MLP_PRELOAD_MODE  

#include "mlp.h"  

#if MLP_CELL_MAXINPUTS != 32 || MLP_NET_NUMSIGNALS != 746 
 #error Wrong NET configuration!
#endif

// ****   NET body   ********************************************************

ROM_DATA mlp_net_type img_snet_body = 
 {
   {"MLP.Network.V.4.12.g"},
   4,
   288,
   100,
   {2057,2073,2089,2105,2121,2137,2153,2169,2185,2201,2217,2233,2248,2264,2280,2296,2312,2327,2343,2359,2374
    ,2390,2405,2421,2436,2452,2467,2482,2498,2513,2528,2543,2558,2573,2588,2603,2618,2632,2647,2662,2676
    ,2691,2705,2719,2734,2748,2762,2776,2790,2804,2817,2831,2845,2858,2872,2885,2898,2912,2925,2938,2951
    ,2963,2976,2989,3001,3014,3026,3039,3051,3063,3075,3087,3099,3110,3122,3134,3145,3156,3168,3179,3190
    ,3201,3212,3223,3233,3244,3254,3265,3275,3285,3295,3305,3315,3325,3335,3344,3354,3363,3373,3382,3391
    ,3400,3409,3418,3427,3436,3444,3453,3461,3469,3478,3486,3494,3502,3510,3518,3525,3533,3540,3548,3555
    ,3563,3570,3577,3584,3591,3598,3605,3611,3618,3624,3631,3637,3644,3650,3656,3662,3668,3674,3680,3686
    ,3691,3697,3703,3708,3714,3719,3724,3730,3735,3740,3745,3750,3755,3760,3764,3769,3774,3778,3783,3787
    ,3792,3796,3801,3805,3809,3813,3817,3821,3825,3829,3833,3837,3841,3844,3848,3852,3855,3859,3862,3865
    ,3869,3872,3875,3879,3882,3885,3888,3891,3894,3897,3900,3903,3906,3909,3911,3914,3917,3919,3922,3925
    ,3927,3930,3932,3935,3937,3939,3942,3944,3946,3948,3951,3953,3955,3957,3959,3961,3963,3965,3967,3969
    ,3971,3973,3975,3977,3978,3980,3982,3984,3985,3987,3989,3990,3992,3993,3995,3996,3998,3999,4001,4002
    ,4004,4005,4006,4008,4009,4010,4012,4013,4014,4015,4017,4018,4019,4020,4021,4023,4024,4025,4026,4027
    ,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4038,4039,4040,4041,4042,4043,4043,4044,4045
    ,4046,4047,4047,4048,4049,4050,4050,4051,4052,4052,4053,4054,4054,4055,4055,4056,4057,4057,4058,4058
    ,4059,4060,4060,4061,4061,4062,4062,4063,4063,4064,4064,4065,4065,4066,4066,4067,4067,4067,4068,4068
    ,4069,4069,4070,4070,4070,4071,4071,4072,4072,4072,4073,4073,4073,4074,4074,4074,4075,4075,4075,4076
    ,4076,4076,4077,4077,4077,4077,4078,4078,4078,4078,4079,4079,4079,4079,4080,4080,4080,4080,4081,4081
    ,4081,4081,4082,4082,4082,4082,4082,4083,4083,4083,4083,4083,4084,4084,4084,4084,4084,4084,4085,4085
    ,4085,4085,4085,4085,4086,4086,4086,4086,4086,4086,4087,4087,4087,4087,4087,4087,4087,4087,4088,4088
    ,4088,4088,4088,4088,4088,4088,4088,4089,4089,4089,4089,4089,4089,4089,4089,4089,4090,4090,4090,4090
    ,4090,4090,4090,4090,4090,4090,4090,4090,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091,4091
    ,4091,4091,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092,4092
    ,4092,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093,4093
    ,4093,4093,4093,4093,4093,4093,4093,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094
    ,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094,4094   },

   {
// *********** Cells of layer 1 *********************************************

     {
      458,
      1039,
      {415,1647,1605,-2464,2888,632,-1265,1207,-1445,3349,-1472,1863,-593,559,-5367,-1394,323,-2625,72,106,-4734,1942,867,-2682,810,1554,-1423,267,767,-1336,335,181}
     },
     {
      458,
      -741,
      {379,-1176,-28,-793,1401,-4230,-4256,260,1536,-1518,-971,2655,2110,-1446,-2411,3352,-506,-612,730,49,304,726,-1062,1486,1879,-310,-1067,-466,-297,56,938,-858}
     },
     {
      458,
      -137,
      {57,325,902,1478,1635,-2734,441,-2102,2901,-2224,-827,-1698,3721,1797,-878,-7390,-1979,253,4060,-297,-1117,-5451,1317,1142,3289,24,-1339,-4469,50,431,5689,-1757}
     },
     {
      458,
      -4191,
      {-2014,-554,1446,2193,-2764,2154,655,-1522,3740,-460,-1556,1974,206,57,2914,599,-1094,3651,4154,-1621,-920,-317,-3716,-518,2937,-2155,665,-633,-1879,1291,698,-2029}
     },
     {
      458,
      49,
      {-1081,-1391,-1278,-49,726,-248,-2651,169,3991,1578,-448,-671,1804,-114,-1576,-2808,-1353,2014,731,1459,-2575,-2398,511,715,1743,-684,1045,-877,684,-390,755,832}
     },
     {
      458,
      -1170,
      {-15,5428,1118,-216,-675,-1326,473,-2147,2162,-898,653,-1259,-2898,1478,1697,-3465,-1608,1679,2103,-77,2805,-3932,-1256,-3088,1013,121,-1188,1371,-109,-569,489,-597}
     },
     {
      458,
      -1298,
      {349,741,-581,946,898,-535,-1861,-103,4546,2400,-2833,-5690,2420,-711,856,-3942,80,2800,2320,-1429,98,-1081,56,1485,1487,85,-81,-1710,-750,-407,-1002,109}
     },
     {
      458,
      -641,
      {3683,-485,1283,-152,-1191,1488,-950,-2896,1765,-1039,-1282,-365,704,-3963,4826,3118,927,-2335,2503,1147,3110,-2708,678,-2810,-299,-803,1993,-875,-148,-2427,-580,-77}
     },
     {
      458,
      1115,
      {1669,341,526,-3088,4048,-1408,-3324,1403,3596,-1449,-2939,-30,1005,-1826,-4960,3425,-238,88,-1811,1383,-269,-397,372,-683,-1176,757,-497,586,1111,927,735,941}
     },
     {
      458,
      -2704,
      {3242,-671,-1240,3205,-1136,507,-916,3404,3021,-886,-1574,4048,-396,-3553,1758,2925,-2009,2075,2725,82,-2243,2069,-877,538,-1730,-1565,-939,1470,-1072,1616,-33,3443}
     },
     {
      458,
      -355,
      {-1430,314,-7025,5709,168,-1924,-690,552,-868,-2858,-696,33,-2151,-1049,496,1419,798,-345,2585,793,1101,-439,-1104,830,993,-95,628,255,325,1608,711,-835}
     },
     {
      458,
      2143,
      {-227,-1273,1995,770,-584,-1212,-53,-3148,2627,-2031,197,1604,2355,1301,-2803,-3546,2047,-143,-3907,-475,-252,869,1151,-837,-175,1247,-300,200,472,-1179,820,-36}
     },
     {
      458,
      -680,
      {-1220,549,792,-991,-820,-1973,-1487,-269,1932,-3519,571,3103,3733,72,-1251,7599,-1162,-2459,-2143,-147,-722,985,499,-1266,-2301,220,825,-822,-151,-71,-1147,117}
     },
     {
      458,
      601,
      {-1629,960,710,-1635,1076,-2111,-566,171,-2180,-1292,2460,-2026,-6973,2278,2118,-5913,-2029,3769,3,-220,5458,-240,637,-3810,209,710,1362,-461,123,-15,2063,-530}
     },
     {
      458,
      -934,
      {386,192,1653,2224,-589,3169,2093,-475,339,-3208,-487,2114,3368,-336,478,1051,-173,995,-551,-1114,-719,-3332,-546,-1255,-134,-431,-323,-2613,227,-966,253,-586}
     },
     {
      458,
      -9,
      {571,-1459,1070,-1899,-1985,2133,129,1369,2683,2790,2390,-1522,-2384,-967,1923,-1947,-1038,-3446,315,-227,-236,-542,197,-1125,1344,-393,-865,629,213,1078,1546,1480}
     },
     {
      458,
      -857,
      {-3618,1817,-1389,-2540,-1531,-5,1631,535,4775,-192,1055,816,2500,-2647,-1982,-132,222,-1569,1597,1075,568,721,-1296,-2144,-1147,297,1008,368,-702,17,-1440,-1192}
     },
     {
      458,
      -918,
      {-1630,182,-230,701,1425,-2514,-2558,-2062,-2086,2145,-2301,-82,4282,1459,1603,-2614,211,3443,-803,-175,2024,-716,-1213,-641,613,148,330,-884,-205,-573,-391,61}
     },
     {
      458,
      -1037,
      {-101,-780,2205,-69,654,394,1666,1611,3309,-577,-2002,-4152,-479,-246,578,2591,366,172,-111,-800,521,504,-650,-865,-556,-478,1135,453,-932,442,-1077,554}
     },
     {
      458,
      171,
      {-817,23,-466,-270,-2184,2730,-2543,-961,2249,1664,2802,-416,4414,-2443,-1882,-790,-363,-1385,-329,866,-307,-920,345,-1020,-892,-1417,81,-1324,498,-867,1085,-3126}
     },
     {
      458,
      747,
      {928,-720,2050,-375,-2575,-1644,-2353,-1576,104,-1775,3277,-2947,2247,712,1673,1912,146,-7210,1943,-38,832,-1325,-801,-544,207,130,2359,308,903,-937,473,2460}
     },
     {
      458,
      1181,
      {-265,308,-1097,-391,-278,-158,-1640,1020,-354,-774,537,-1366,3083,-546,-8494,-2523,1763,-3770,-2356,982,4311,-2127,569,3791,-3655,2286,1949,2659,392,371,-921,3201}
     },
     {
      458,
      349,
      {-589,836,79,733,1948,-2229,3067,-1806,2909,-2994,275,-5747,2315,2702,2446,-1906,-1835,-2701,-5081,-214,3282,-1135,899,-3170,-907,405,1749,1493,316,-113,-746,210}
     },
     {
      458,
      -692,
      {2881,-183,4483,-1212,1076,1103,-1403,3470,4779,-3591,-377,-1111,-5100,-89,470,4008,-960,1056,-545,-504,198,-1928,-391,-357,-929,-400,-129,-931,-338,367,102,2832}
     },
     {
      458,
      144,
      {1765,491,-4448,3078,-515,60,1491,342,2791,-140,1213,-240,1472,477,-4839,-889,803,3151,253,86,-4025,-941,-148,-1075,-278,-187,-3041,1888,-438,-564,1222,2121}
     },
     {
      458,
      -739,
      {1726,1871,-1123,292,-1653,1646,-2336,1038,642,1394,1115,-360,5618,843,-2287,-1280,-750,2250,-3174,507,-5192,3043,-1024,1074,-1113,-751,-276,2624,-703,-70,-2360,1863}
     },
     {
      458,
      -815,
      {2197,224,-1415,-367,-1852,805,-409,1376,1834,-1931,1764,4191,-2037,-2006,5452,271,313,-5195,1594,1470,1529,218,-213,-2570,-2885,-254,400,947,-1497,194,-1686,2685}
     },
     {
      458,
      -63,
      {794,614,-2188,548,2190,1550,-209,250,124,-1047,-3065,1967,815,-34,1975,4151,-616,-4376,-1526,-695,-2851,46,1543,14,-1309,799,749,-1394,658,-11,-335,1863}
     },
     {
      458,
      -1343,
      {-2475,1371,879,2535,1182,-2843,-432,1303,4460,3535,-833,-4651,-1289,18,1397,1796,-642,-4130,-946,-993,4234,375,-1667,-667,-1505,-477,987,979,-1059,57,-2536,333}
     },
     {
      458,
      -607,
      {577,466,-529,-1030,369,1382,-3273,-2818,-2000,-4493,-694,-4370,14,405,-82,5693,-259,3296,2988,281,591,-12,-1160,450,-572,184,430,1282,-450,287,-613,-1324}
     },
     {
      458,
      596,
      {1544,2266,-78,-487,71,-1937,-4709,-1388,1204,283,927,-1418,230,1605,2515,1099,90,-3846,-311,-893,295,-1437,486,-422,-615,154,223,-1051,191,-968,1352,23}
     },
     {
      458,
      859,
      {400,-10840,-160,571,-393,-199,-801,-1694,2063,-829,-334,-599,-163,1666,1615,-1463,1270,-554,113,246,1360,74,377,56,85,139,473,745,1119,269,206,518}
     },
     {
      458,
      1401,
      {-648,480,2161,915,347,1577,-1347,-1004,-3858,-489,85,3988,1487,1175,-2378,-3142,182,-1455,2050,-652,921,-2352,500,-845,-1691,-16,1126,-3011,1025,145,-28,-2221}
     },
     {
      458,
      1710,
      {-419,756,-1923,-656,-846,98,-2947,420,-833,661,3253,-100,-2217,1131,-3362,-1824,-356,1693,140,761,-2196,708,937,-1248,940,150,-20,477,890,-856,486,-1376}
     },
     {
      458,
      -1159,
      {1060,-350,-3065,423,-869,3477,2207,-567,447,2092,-15,4892,2928,1704,2191,-2810,-1165,20,-97,-864,-963,-1239,493,-1137,617,-384,-51,-1271,-441,-3062,157,3924}
     },
     {
      458,
      702,
      {827,-343,-739,2809,-1265,2692,-1486,2071,-1958,-293,1669,-113,-442,-289,-1603,1253,1652,-1609,-3183,1147,850,1981,-397,-1104,-3421,313,1455,2469,-138,-1467,-1123,640}
     },
     {
      458,
      324,
      {202,140,379,-89,304,866,-2039,-645,-43,3,-244,-1411,-233,280,301,-718,424,-357,-124,417,568,25,173,208,-370,149,69,7,402,-181,-211,-33}
     },
     {
      458,
      -622,
      {-577,290,1041,1711,-693,4653,-156,-1537,-75,-1470,-996,1707,-2625,2079,-864,1978,-754,-1654,777,-466,165,-2153,838,231,-279,-433,-99,-873,-400,-283,-1029,-299}
     },
     {
      458,
      -2832,
      {-1303,187,1303,-408,434,1147,-285,-723,-1025,-1271,-1660,-3045,-1580,-1230,-5622,718,-1005,-3969,6505,1020,444,2928,-1114,-243,7434,-634,-165,2424,-1250,1253,2721,4641}
     },
     {
      458,
      -392,
      {-3123,1727,-1908,-307,-1296,3344,-1966,-119,-263,-901,382,-2494,-744,1173,3174,-510,648,613,-927,-1555,-358,622,15,-143,-864,571,-37,648,-654,275,-240,49}
     },
     {
      458,
      805,
      {-14,-1218,-829,-186,-1009,1087,-3237,195,-255,-2273,1491,-911,656,960,1842,558,-768,-1667,-335,1378,399,-646,1253,481,-611,-269,-145,-136,180,25,-492,428}
     },
     {
      458,
      -2221,
      {-1107,108,3711,1612,-1854,2240,-1396,1749,-2615,-735,-540,1649,1137,379,4083,2053,-1652,-107,-2273,-2227,748,2836,-1321,-1558,-2012,-224,1682,1144,782,-606,-1512,3803}
     },
     {
      458,
      798,
      {765,72,-2079,14,1636,2896,2141,-1469,-1199,2273,-91,-1340,790,-482,-3695,-434,-41,-455,2331,-883,-1416,-2291,-349,1793,-1928,268,-192,-526,1575,14,-674,-1360}
     },
     {
      458,
      -45,
      {440,516,334,-2452,871,5446,-3389,-32,1964,-2274,-2233,-2112,-391,40,-1266,-1786,1328,-968,923,36,713,-1075,345,-495,-1397,-210,3,2137,-185,-199,458,15}
     },
     {
      458,
      3622,
      {-410,-279,3348,1875,3031,155,-1638,392,-2059,-6047,-1290,959,328,2093,393,-5392,840,-1365,-1280,2379,224,-2768,2780,-2212,421,528,3473,-4685,1594,-1418,-72,488}
     },
     {
      458,
      204,
      {-917,-507,-1040,-1393,453,1105,-2581,1500,-647,1211,-414,-3490,2167,-201,5197,-1438,-550,538,-1057,494,-628,-953,715,1075,-1400,-180,-379,-1401,-219,-288,-275,426}
     },
     {
      458,
      -1822,
      {-2855,430,-4552,-466,-654,4565,-2609,2608,-374,3396,-61,-970,3,266,2194,2515,-515,-517,2767,84,-441,-593,-1655,-628,2090,-640,-531,-1840,-1134,175,1373,3036}
     },
     {
      458,
      972,
      {-4902,-424,1408,230,-202,1187,2110,1427,-567,-1736,1150,-605,-4643,1331,245,-2850,-159,745,-1488,-117,-211,-2347,727,1641,639,14,-714,-781,557,-170,618,-2375}
     },
     {
      458,
      242,
      {-1741,352,-2617,-259,-1833,383,-249,1539,2435,-3738,2302,-2500,-22,618,-1878,2746,-741,1337,-119,-416,-272,162,471,326,-817,171,351,172,-463,279,-1136,-1584}
     },
     {
      458,
      1154,
      {-177,686,-5254,-1391,1396,-1276,-3881,-715,-1348,-38,-244,-1759,1987,234,-184,-4441,901,251,1819,3174,1596,-1610,1200,2858,964,696,-622,-382,-85,-233,-5,-1093}
     },
     {
      458,
      -791,
      {2897,138,-2256,-436,3190,-397,371,387,-1694,7375,-1138,-1115,468,-222,-1838,-1071,-3774,-2562,1149,668,-1053,-456,-1485,-801,2355,1386,242,405,1166,-359,587,3692}
     },
     {
      458,
      296,
      {1108,337,5387,-2747,-964,464,-1674,-3036,-1080,-2604,-132,-2490,-271,457,-2279,-1510,258,-655,3070,817,692,-552,786,888,1377,1642,-548,120,1071,-3,1196,720}
     },
     {
      458,
      369,
      {1548,864,891,-1224,-1185,2759,-3201,807,-2372,-2011,723,3231,-1731,-672,109,-823,1154,-214,-750,1359,-1145,1833,-209,-1528,-325,769,75,-492,-403,-548,-841,1416}
     },
     {
      458,
      -256,
      {642,-114,-1091,1341,1005,1526,-2627,551,-864,-4936,-3850,-255,6000,483,-1290,2211,1630,1560,-328,-1075,-693,-602,557,997,937,769,1068,-1253,212,-870,609,2296}
     },
     {
      458,
      -2101,
      {-4763,1447,2059,-4143,191,1307,3723,1110,463,-1051,-4619,1996,6009,198,-2490,-4179,168,-709,2404,-266,-2224,-3501,-615,1280,5734,-283,-1064,-3342,-648,1900,2711,-492}
     },
     {
      458,
      -225,
      {220,403,2106,-1066,-2611,2229,-1081,298,-1817,2425,1910,-3011,877,-1601,164,-4164,1251,2429,1751,-98,-697,-491,-168,2341,11,-1325,-1357,-615,-143,-35,-868,-1710}
     },
     {
      458,
      2457,
      {-567,194,3078,-1427,1401,-1595,-1406,702,-3176,322,570,-3026,1594,254,-4056,-1953,1882,-3080,653,1108,-767,-1382,1708,-1468,1284,910,-852,-1000,962,-1173,1019,-1133}
     },
     {
      458,
      286,
      {1219,1091,-2958,478,-2332,856,-459,535,4176,-487,3605,-2533,-818,-806,1489,-3200,-923,-2883,858,-276,-396,2164,-194,-651,-1075,485,-371,704,626,-602,-354,-17}
     },
     {
      458,
      200,
      {1450,483,-1642,-1529,97,3260,403,-5091,-1996,-3672,-1108,4443,-2726,-368,667,777,1249,1927,291,2377,-50,-113,-371,-532,1483,84,1506,-630,-764,-635,-1521,-532}
     },
     {
      458,
      -786,
      {-3954,-1039,-2547,-826,728,3062,1143,1846,-3691,745,-2513,-2146,-389,445,-1411,958,1302,-102,2334,-269,1776,720,-265,1805,-648,-946,937,575,-357,-265,-107,965}
     },
     {
      458,
      -764,
      {-3550,-395,-1593,-1501,-976,2452,-3663,1224,1919,164,553,2821,-156,-1618,2501,436,30,620,1835,571,-352,120,-662,-306,249,-863,-1473,-341,-349,-667,-981,-1938}
     },
     {
      458,
      -710,
      {-3405,-663,-176,-211,293,3733,-502,1803,2661,1439,-1921,3844,613,-1230,-3609,-1864,-924,1977,1333,-1922,-1304,-35,654,2490,89,-639,-1407,-1968,134,2174,-251,-1014}
     },
     {
      458,
      -2872,
      {-2313,-14,-1859,-428,-1741,-3324,-346,-599,-2658,298,-1371,-1361,6972,-162,1489,6239,-1268,416,3242,-1300,297,-1392,-775,-1617,4049,-1126,1527,-929,-1126,-30,-43,1203}
     },
     {
      458,
      174,
      {2017,-1151,-297,978,1362,2054,-103,1020,-3627,-1185,-90,-2479,4189,575,1585,25,166,-1784,-3184,645,-765,1387,-622,92,-2000,-193,804,-359,-910,1964,-389,1184}
     },
     {
      458,
      -3170,
      {16051,-18324,-5261,12164,-14119,32715,-6336,833,3434,-19649,6222,20407,-3980,-8177,13788,-9256,4552,4104,-14368,-5159,-8974,8307,836,-4554,-8498,-1509,-5622,3510,-4016,-2541,-3000,867}
     },
     {
      458,
      -6067,
      {-22888,-32718,-8484,3981,-601,27447,-32725,12420,6909,13152,-13878,32712,-15412,12319,10795,-25783,5068,15923,-9960,-11827,5795,2082,-332,-68,-4320,-5766,-4705,-4406,-2468,-3577,-4031,-6185}
     },
     {
      458,
      -9212,
      {-26333,-32726,-10681,10785,-10346,32713,-5231,18832,29165,-10993,-1405,32710,-17419,-7651,11018,-25550,-845,30596,-18446,-8538,-6134,-1014,-4526,930,-7519,-4913,-1552,-489,-4449,-3461,-7958,-7231}
     },
     {
      458,
      1832,
      {4001,-17510,-4373,1363,-24454,32707,-21406,-7275,-32732,-7768,24029,6332,-17586,23,17581,-8060,-3416,-3294,-6384,-4163,-4169,1588,4909,-1809,548,-4286,-871,-209,1151,-987,220,-1591}
     },
     {
      458,
      -153,
      {32720,15361,-8445,5420,-15178,32713,-9386,-32730,-12089,-404,2734,8408,-15078,-9512,16181,-32726,12745,-15577,-10321,-50,-5168,4358,708,-2319,-6036,-1120,-123,2850,-1451,-5583,-2761,-1198}
     },
     {
      458,
      8158,
      {31281,11532,-32699,-2175,7275,20051,31709,-28620,-32709,20972,-240,-27940,-3254,-22827,-214,11764,7817,-19073,-18341,25113,-3513,24643,780,2571,-4897,9735,1567,13800,1636,-1908,-2792,3565}
     },
     {
      458,
      -5361,
      {32723,32708,-23399,32690,-6052,32729,32526,-32719,15533,-10125,-17696,10112,10815,-24831,-16983,-32712,10777,-32716,12509,-7254,1693,3254,140,-7200,-4997,1398,-9816,1231,-2803,-7464,-1675,502}
     },
     {
      458,
      -1817,
      {-7693,-19094,5035,26310,-8126,32726,4612,3145,3030,-17087,987,8887,-27064,-347,11754,-12224,2155,15714,-10781,-4759,-6812,5056,2663,1484,-1911,-2449,-5567,5375,-2950,1499,-2122,-3023}
     },
     {
      458,
      0,
      {23088,4590,-10176,-17915,-15755,32767,4999,-32725,-32696,1302,15470,-17417,-8162,-6094,4172,7192,-3334,-9427,-9356,4597,1623,7765,1033,380,-4496,-299,-260,99,474,-1990,-1800,-1264}
     },
     {
      458,
      526,
      {32718,-12080,-7188,-3989,-15793,32729,631,-32716,-32714,6443,14696,-6235,-10941,-16142,171,837,627,-13452,-4175,12059,-1651,7736,-1073,-804,-3265,522,2055,1193,435,-2418,-2211,1002}
     },
     {
      458,
      -3800,
      {27612,-2106,-11222,579,-127,32707,-4577,-19599,-2607,-900,-16777,21143,-9020,-15789,11713,-15558,6961,-3172,-8082,239,-190,7396,1018,-8789,-7997,-1386,-4250,1710,-4370,-4779,-4409,-3098}
     },
     {
      458,
      2109,
      {32721,13717,-29054,1761,2627,28888,28338,-32721,-28857,10390,-13066,-3998,5003,-14057,-10361,-16313,11625,-32716,-2305,6387,13515,16394,1842,-5612,-7509,6449,890,6368,-298,-1044,-2561,5095}
     },
     {
      458,
      9656,
      {30349,-28302,-5934,-11762,-19593,7443,4083,-28806,-32725,32423,28303,-31734,-2100,-12654,19124,3249,4789,-30538,-2748,14308,2970,18017,934,5362,-8216,6825,6834,3271,6439,-1444,-1596,4098}
     },
     {
      458,
      2327,
      {32717,-25197,-14578,3941,-13192,32721,5384,-29166,-10970,9542,5456,16410,-6868,-17303,-893,-4728,12227,-16550,-12960,6646,-5088,9231,-2207,-4687,-5746,3593,1330,5197,-875,-3653,-3872,1756}
     },
     {
      458,
      -3226,
      {32717,7405,-14943,-24896,-8724,32717,7540,-20530,-15829,28241,-3285,13699,-20985,-10481,-1022,-2941,7346,-17521,-6236,-3102,-3407,7335,174,-7221,-5164,349,-2041,6808,-4573,-4641,-6640,-1420}
     },
     {
      458,
      3,
      {12775,-919,-15126,-14409,-12769,32746,11150,-18998,-32727,-4739,10384,-23230,-22295,-9126,-1879,6534,-2392,-1414,-18211,3915,-7839,9769,2440,-6902,-8652,-841,-3388,2498,-294,-2329,-4652,-1020}
     },
     {
      458,
      2465,
      {32715,-11572,-8825,-7612,-14871,32729,3926,-31008,-32721,19054,19246,-16829,-8337,-15106,3928,-8162,4103,-18677,-3263,13339,4535,8468,588,-2966,-5098,228,823,1293,1464,-4484,-1538,1300}
     },
     {
      458,
      2845,
      {-32585,-32513,8967,-14485,-3088,22129,-24321,18325,-32723,32714,10781,24097,-13250,-2781,11409,-8122,-2255,20824,-16797,11279,-3663,5825,-2590,9057,579,-3775,-94,-2750,3506,1086,-1728,-6090}
     },
     {
      458,
      -943,
      {32005,18259,-22913,-10907,-12953,32726,10008,-32721,-23914,3111,7846,-11585,-6989,-8500,2391,-776,2072,-12431,-10859,9512,-1046,7447,-1419,-2953,-6319,960,-3429,1242,-280,-7724,-2583,1164}
     },
     {
      458,
      639,
      {32715,-15709,-14585,-13278,-5928,32714,5255,-21424,-32727,12266,5796,136,-7899,-15477,8877,1732,2394,-6555,-20028,8336,-3757,6616,-567,-2355,-9087,865,-1980,7826,-1338,-2669,-4666,526}
     },
     {
      458,
      3127,
      {-13354,-32704,6804,23817,-22949,14301,-32726,-295,-32727,-10510,32717,13077,-17910,2387,15248,-10034,-2666,1371,-9084,3532,1370,3744,2780,2262,-1388,-3464,1567,-4167,4387,-1100,3273,-852}
     },
     {
      458,
      8093,
      {32718,-28860,-28595,-8376,-4129,5684,32722,-32719,-28553,32712,10127,-13049,-6347,-5473,15547,2120,17168,-13108,-16675,16340,5434,23371,-3315,7936,-11942,5338,8031,8011,1197,5,-1014,2529}
     },
     {
      458,
      -4979,
      {21780,9089,-7724,-1232,-20158,32712,11479,-5343,-15747,-8834,16228,32705,-23570,-14858,17413,-14107,-919,-1363,-19662,-8957,-6779,-3356,-3744,-2821,-1056,-2240,-2235,6454,-4599,-3821,-5450,-4495}
     },
     {
      458,
      6293,
      {32028,-32166,-833,-5737,-14629,21959,16706,-29660,-32731,23579,24980,-32725,-2366,-13298,17300,-10443,4925,-21901,-5181,26576,5164,22199,-503,5231,-5246,3732,3881,4033,2475,-3909,-656,724}
     },
     {
      458,
      8938,
      {-6728,-21056,9451,-19869,-13957,32721,-22882,-22885,-32728,32308,32708,-11769,-11566,1794,5616,444,-4557,-16647,-19536,17447,-6912,24212,2893,969,-4974,-1694,1977,6239,4506,-2442,-7938,-3481}
     },
     {
      458,
      1730,
      {32719,-24368,-2604,10015,-23105,32450,-11117,-32721,-32227,14238,17776,-8417,-8304,-6366,2554,-15935,3182,-16811,-5868,10467,501,14811,1308,-128,-5396,-1091,278,1595,485,-3108,-1720,955}
     },
     {
      458,
      1620,
      {32720,4359,-21925,-11739,-5447,32724,24536,-21780,-15421,18828,7584,-11047,-4046,-12291,20839,3951,3770,-2279,-21029,2256,-4784,5399,-1111,2489,-9931,2968,399,3293,-701,-5048,-5944,101}
     },
     {
      458,
      4391,
      {32711,-32727,9734,513,-14490,23343,-7174,-29140,-32740,32540,18116,2110,-9544,-13249,12475,-12355,7953,-5134,-5986,15766,-18,16636,-2074,6930,-10891,499,3547,3754,1113,126,-1550,1124}
     },
     {
      458,
      4157,
      {12870,-32719,-1487,-3105,3428,30554,-2977,-5159,-17570,26837,-5778,32711,-29658,-8415,5010,-10657,6796,258,-9452,8779,-1431,11095,-625,2926,-6764,-784,-1195,3229,491,-4179,-5010,-4649}
     },
     {
      458,
      1246,
      {-4655,-32714,-4522,256,2456,6771,-12921,-1423,-17239,25433,-4623,796,-1136,-353,-5063,426,4629,-1219,-1116,8440,2904,18942,-1159,9455,-1992,-2574,2791,-676,2919,2521,-2592,-1675}
     },
     {
      458,
      -1,
      {31684,27149,-3990,-4616,11368,29934,27910,-2879,32704,-13071,-15569,30168,-965,-4502,19162,-18548,6658,10897,-17548,-7318,-2772,8277,-439,2529,751,1714,-6703,4933,-1527,-2668,-4476,-4863}
     },
     {
      458,
      -726,
      {28360,-11890,2342,-16443,-19854,32367,-30490,-32727,-32730,32500,8916,10381,-12973,-13010,7602,-25198,4880,-19148,-16701,12664,8803,15103,1534,-902,-8566,-4671,-1491,6104,-1808,-3702,-3821,-4908}
     },
     {
      490,
      -32728,
      {-4122,-11338,-11338,-21377,-5604,-13708,-24311,-20890,-10527,-19434,-25257,-31986,-13047,-27699,-32712,-32017,-9590,-7815,-6724,-4087,-16147,27822,32728,32723,23776,32728,32729,32733,32723,32721,32726,32731}
     },
     {
      522,
      -28547,
      {-12176,-6736,-4952,-3275,32721,32727,27604,13870,32730,32730,32721,24486,32731,32418,29992,14332,-1970,-3255,-1353,-2364,14805,-10291,-21170,3450,-29320,-31823,-32711,-14120,-32722,-32721,-32721,-32715}
     },
     {
      554,
      -14190,
      {-32723,-32740,-32751,-32755,-32727,-32749,-32767,-32767,-31804,-32756,-32767,-32767,-11147,-32754,-32767,-32751,-32748,-32728,7181,-2738,-32754,-32737,-32730,-27709,-32740,-4422,14146,31281,10585,32715,32728,32742}
     },
     {
      586,
      -32689,
      {32719,26955,32734,32752,32717,32724,32749,32757,15815,26705,32739,32759,-32741,-32748,19942,32741,32744,32729,32732,32733,32755,32742,32741,32739,32767,32755,32744,32727,32758,32747,32737,32728}
     },
     {
      618,
      -903,
      {-31012,-32729,-32729,-32733,-28585,-32729,-32733,-32735,-22651,-32728,-32731,-32732,-32721,-32727,-32725,-32722,-32731,-32742,-32745,-32738,-32741,-32746,-32752,-32736,-32740,-32742,-32747,-32731,-32719,-32730,-32730,-32726}
     },
     {
      650,
      11316,
      {-21168,-28133,-32732,-32738,-23764,-32733,-32746,-32745,-32716,-32740,-32746,-32743,-32730,-32717,-32728,-32730,-32744,-32754,-32739,-32737,-32741,-32760,-32744,-32742,-32752,-32737,-32743,-32735,-32730,-32739,-32741,-32747}
     },
     {
      682,
      -14094,
      {-32740,-32757,-32766,-32763,-32741,-32757,-32763,-32766,-32733,-32750,-32755,-32757,-32728,-32743,-32742,-32743,-32756,-32715,32722,18776,-32767,-32753,-23603,9120,-32767,-32767,-32736,769,-32740,-32755,-32759,8152}
     },
     {
      714,
      -32606,
      {-20855,-32458,-28517,32738,-32719,6606,30661,32732,-31893,12079,32722,32730,-3160,23373,31035,32734,32737,32734,32736,32734,32747,32743,32741,32737,32748,32740,32740,32734,32729,32733,32728,32723}
     },
     {
      490,
      -29965,
      {8603,14515,16159,12343,12535,31141,32723,32725,25292,32723,32727,32731,32720,32727,32735,32730,12708,4157,8289,12484,32725,32725,31892,32720,32729,26369,32714,-6119,32721,17455,-3807,-16263}
     },
     {
      522,
      -32694,
      {-6614,-8354,-3045,-8163,-5658,24242,32727,32731,-2988,9633,32732,32734,-26810,26326,32731,32742,-11421,-14782,-13617,-13467,32724,17963,2395,-21802,32741,32733,32727,3688,32740,32739,32727,27248}
     },
     {
      554,
      5724,
      {-22645,-32717,-32712,-31280,-28593,-30378,-28364,-32713,-1014,-17999,-30099,-32718,9314,-24215,-30001,-32720,-32712,-32708,-32671,-14768,-32724,-32730,-32726,-15764,-32726,-32729,-32724,-11948,-32725,-32718,-27796,26685}
     },
     {
      586,
      -30672,
      {32733,32737,32735,32724,32739,32738,32725,26307,32735,32732,30182,22316,32740,32729,9525,-4949,20557,-7290,11775,25640,4225,-5744,3558,17044,-5538,-11709,-23899,1212,-13407,-31357,-27550,-19219}
     },
     {
      618,
      17,
      {-21667,-32728,-32725,-32732,-20607,-32729,-32729,-32733,-17435,-32725,-32727,-32731,-32644,-32725,-32719,-32718,-32733,-32746,-32747,-32744,-32743,-32750,-32759,-32743,-32744,-32748,-32755,-32735,-32718,-32735,-32736,-32730}
     },
     {
      650,
      -11880,
      {-32639,-30885,-32260,-25836,-7334,-30629,-5987,29857,32035,28474,32719,32729,32718,31903,32731,32729,32720,32736,32749,32744,32721,32746,32748,32743,32740,32745,32747,32741,32737,32744,32738,32742}
     },
     {
      682,
      491,
      {-32730,-32742,-32749,-32734,-32730,-32745,-32745,-32735,-32728,-32744,-32747,-32734,-32723,-32736,-32738,-32735,-32728,-32652,-32730,11926,-32735,-32734,-32723,-32715,-32745,-32744,-30621,-18142,-32732,-32732,-32736,-26908}
     },
     {
      714,
      -32710,
      {-18817,32737,32732,32716,32722,32731,32726,32708,32696,32714,32720,32682,30377,4752,20746,32680,32722,32726,32728,32733,32675,29770,32718,32731,28624,31795,32717,32725,32701,32707,32715,32721}
     },
     {
      490,
      -32720,
      {3415,5258,7614,-761,4882,14098,12941,26328,10608,21760,32719,32718,11354,28018,32720,32723,680,-5688,-3654,-37,32719,32719,16598,22730,32722,32718,32213,-5260,32724,32716,26956,-8205}
     },
     {
      522,
      -18772,
      {2200,9740,6281,3142,32731,32735,32723,-15075,32736,32737,32729,4731,32735,32729,32724,24111,1331,1504,7017,13973,4187,3964,-3366,19108,-32720,-15634,-13225,10202,-3331,-4268,-21301,7390}
     },
     {
      554,
      -31152,
      {32724,32740,32740,32741,32726,32739,32746,32747,21966,32743,32749,32748,7581,32741,32745,32736,32729,32721,32712,32713,32737,32728,32736,32719,32736,32727,32733,29675,32730,32733,32725,-10382}
     },
     {
      586,
      -32679,
      {32729,32719,32638,24605,32729,32726,32726,31866,32732,32731,29416,32721,32732,32723,26260,18541,14178,9952,29497,32733,26793,4969,18875,32729,26191,6063,-12741,5825,14576,-14409,-20058,-10740}
     },
     {
      618,
      113,
      {-28033,-32738,-32739,-32741,-21825,-32736,-32742,-32746,-10839,-32728,-32737,-32745,-31378,-32734,-32725,-32725,-32745,-32754,-32748,-32751,-32754,-32762,-32767,-32745,-32760,-32756,-32755,-32725,-32725,-32740,-32728,-32724}
     },
     {
      650,
      17195,
      {-32725,-32730,-32727,-32429,-28584,-32748,-32748,-32727,-32719,-32741,-32740,-32735,-28007,-32721,-32739,-32733,-30675,-32740,-32743,-32734,-25484,-32747,-32738,-32728,-32730,-32734,-32726,-32722,-32722,-32733,-32733,-32727}
     },
     {
      682,
      426,
      {-26835,-32726,-32727,-32732,-26086,-32725,-32729,-32735,-28382,-32721,-32729,-32731,-13817,-32720,-32720,-32723,-32737,-32725,-25216,-15127,-32736,-32730,-21727,1907,-32732,-32724,-24429,2380,-32725,-22541,-30771,-12591}
     },
     {
      714,
      -32714,
      {-10500,-32714,-21890,9653,18905,29255,10055,27278,32724,32725,32729,32726,2560,24305,32725,32724,32712,32720,32722,32723,32722,32724,32721,32723,32721,32722,32721,32720,32094,32716,32717,30889}
     },
     {
      490,
      -32721,
      {2621,133,1598,-4765,442,2771,1508,8886,1279,6635,25497,32724,13413,17244,32729,26801,-6295,-3151,-1516,2372,21852,23157,32729,32733,32727,32724,32731,32737,28671,32381,32722,32732}
     },
     {
      522,
      -32721,
      {-4354,-10265,-9647,-8549,32721,31095,24266,24730,32728,32717,17143,32723,5690,3726,-3808,32723,3446,-1529,2446,2936,32717,32720,32718,6076,32718,32718,32723,32721,32716,32720,32721,32718}
     },
     {
      554,
      6954,
      {-32720,-32728,-32737,-32746,-32725,-32732,-32740,-32748,-18955,-32735,-32745,-32752,2837,-32733,-32737,-32733,-32731,-32729,-32740,-32731,-32751,-32754,-32761,-32735,-32753,-32759,-32752,-30666,-32735,-32747,-32734,21849}
     },
     {
      586,
      -32708,
      {31669,32714,32708,16324,32714,32717,32712,20163,32722,32719,31991,30636,32720,32721,32722,32718,-21089,-32727,-32725,655,-26162,-32733,-32733,-9111,-10032,-32732,-32735,-28132,7317,-32728,-32734,-32727}
     },
     {
      618,
      -1063,
      {-26306,-32726,-32726,-32736,-22404,-32728,-32729,-32736,-14168,-32725,-32727,-32733,-32051,-32724,-30704,-32722,-32740,-32749,-32748,-32747,-32748,-32752,-32757,-32747,-32746,-32744,-32747,-32733,-32722,-32733,-32727,-32724}
     },
     {
      650,
      -10174,
      {32729,7109,-31571,-32719,32730,17519,546,2113,32733,32733,-2725,-1488,32729,32730,32729,10769,-485,6787,3970,18273,3297,1405,25008,24267,12083,-4584,19649,17267,-3687,-24378,-22577,-3287}
     },
     {
      682,
      -25563,
      {32724,32730,32732,32734,32727,32737,32739,32754,32724,32733,32744,32749,24167,32730,32728,32736,32740,32713,32733,32736,32760,32747,32748,32739,32764,32761,32745,32743,32733,32739,32739,32720}
     },
     {
      714,
      -32714,
      {32729,22965,31752,32723,32728,22646,14596,25000,17833,-11874,-13811,-597,-28180,-29438,3959,18993,32721,32725,32728,32725,32706,32722,32726,32719,30357,32725,32724,32724,32709,32720,32721,32717}
     },
// *********** Cells of layer 2 *********************************************

     {
      0,
      -1297,
      {1392,-613,-186,1529,130,-433,1376,1245,-227,-2125,-1595,-865,2223,2035,-1192,524,-614,-352,-77,986,242,1581,211,836,476,-526,-732,1844,-216,-935,801,48}
     },
     {
      32,
      136,
      {-1109,-154,-535,-1234,84,-396,192,-188,-215,-1011,-200,261,-163,-231,-532,-926,-702,278,533,-1165,-61,-834,-342,300,1099,72,-391,-180,655,1248,281,-25}
     },
     {
      64,
      -3316,
      {538,579,59,1057,518,30,749,832,571,476,605,136,-85,40,572,670,-228,845,68,344,406,-106,637,-229,-33,515,1031,-321,232,-137,-344,647}
     },
     {
      96,
      -1578,
      {1786,-4,-1866,1579,-153,217,-185,2075,-229,-893,-297,-349,-155,-1713,-660,-288,275,671,-931,583,-266,-178,-546,153,-275,-381,-515,35,-12,-438,-230,317}
     },
     {
      0,
      1639,
      {-967,1384,-2194,686,-665,-799,-801,524,640,-625,1991,-1343,-1298,-1626,-513,-3,655,-347,-705,-41,1284,-324,490,-850,1168,570,-1873,1686,-198,752,-213,289}
     },
     {
      32,
      1446,
      {318,-47,-403,1283,279,-822,558,310,-176,243,597,534,-2161,-319,483,1733,-25,-577,1028,-1629,-868,-158,-829,-1052,154,685,2204,205,108,-195,1131,421}
     },
     {
      64,
      1237,
      {-900,-266,-87,-1094,314,487,-22,-213,-1213,-962,-1017,-491,-384,191,-347,-1658,-782,-476,-351,-21,-36,-235,193,348,175,-456,-840,-78,-118,216,203,-456}
     },
     {
      96,
      275,
      {-1192,-1192,-561,-204,125,446,-772,330,-169,-597,191,-100,211,1015,-170,329,250,-529,306,93,290,828,88,-260,-893,-979,-157,225,25,-162,-503,452}
     },
     {
      0,
      3558,
      {-1556,-139,1649,-1240,-218,410,-163,430,319,-1734,1181,-163,-143,-1043,-503,198,991,-106,-1594,-238,-486,392,-1579,48,-814,318,-353,534,-1120,128,-498,333}
     },
     {
      32,
      -1284,
      {-540,939,-855,384,113,890,-1015,273,770,-446,1997,-201,199,-900,-60,927,-555,1280,1138,-1297,369,602,1603,-1467,-1142,567,1147,1072,27,271,103,-81}
     },
     {
      64,
      1924,
      {-88,240,466,-569,-1183,-169,-1261,589,-1037,-363,-525,180,251,-9,48,-933,-344,1101,-751,-314,-204,501,620,-507,-554,-1088,-544,529,388,-492,-769,-670}
     },
     {
      96,
      -1364,
      {463,241,-138,-241,1032,781,673,154,234,-621,-19,-351,1082,-31,1332,-639,-230,-164,-864,677,993,143,182,-41,-154,576,441,631,799,-67,272,-157}
     },
     {
      0,
      889,
      {89,65,123,-92,-735,-74,-1005,958,-401,46,-909,94,400,946,-543,-293,-1018,-2226,253,-1063,-137,-33,-2739,-764,870,372,-1571,-826,-2395,-327,-1638,-441}
     },
     {
      32,
      -1829,
      {2166,1371,-1175,240,86,1685,-1776,-624,989,-1519,-1315,1,-1221,-433,-225,1164,3475,-73,-813,-1539,598,-2105,237,-45,-56,-1056,-1714,-2133,387,2960,-1246,-529}
     },
     {
      64,
      795,
      {-92,1210,1317,-184,-54,-319,-1173,463,-302,-364,237,-578,480,286,-762,-264,436,78,-786,-82,1551,4,-352,-49,430,70,-715,108,748,-204,-118,-109}
     },
     {
      96,
      -1617,
      {131,432,851,-264,-65,170,-651,491,-176,-670,45,-28,-385,891,-1523,1045,35,-452,-1277,-487,-496,936,-487,404,97,-14,226,101,-290,-380,741,455}
     },
     {
      0,
      -2608,
      {216,290,914,-864,-678,212,1123,-793,-475,2637,212,-241,442,-4342,24,654,-974,472,751,-1813,221,767,-1085,-1394,1830,-25,556,-1465,217,-233,550,-203}
     },
     {
      32,
      -105,
      {31,420,-582,-257,-360,-1805,69,917,-1031,1580,837,382,-394,-234,-1401,160,490,-2355,-249,-385,-1512,-14,271,691,-61,1520,867,520,427,-644,421,-623}
     },
     {
      64,
      1263,
      {-428,38,-523,-220,-416,459,-1234,-43,-148,-106,279,-44,-288,374,-275,-188,-251,-194,-49,-22,113,-123,-659,-547,-464,85,-293,-1022,258,720,325,-167}
     },
     {
      96,
      -182,
      {586,89,-1296,36,-150,105,951,1166,-471,567,-821,-195,-286,-1531,-998,500,484,217,-290,-332,-208,472,-126,233,-291,84,-1174,-140,-652,-2076,-164,-185}
     },
     {
      0,
      157,
      {-687,3,-710,-551,-413,-19,-1065,-766,-359,416,-133,-1264,2141,704,-471,317,-1222,-511,-269,2503,-45,107,416,714,98,-451,-1621,-261,-769,-2155,-296,26}
     },
     {
      32,
      1145,
      {1302,1952,-1488,-1015,117,-410,-1937,123,752,-1058,-1706,-279,-1348,-63,77,1253,1267,-642,482,77,-843,-378,-246,-879,-200,-1334,270,-1632,220,-302,-1795,1955}
     },
     {
      64,
      -351,
      {284,-547,52,-277,-195,-1425,-347,-43,-382,-466,-204,-249,-237,-175,-487,-220,-173,-1057,-193,-175,108,-412,-647,-53,-676,-267,-180,-482,312,1057,238,-337}
     },
     {
      96,
      1137,
      {1,-237,-251,-76,-35,885,13,-534,-76,-278,58,351,-204,621,726,-811,-364,-761,-136,671,-738,-93,345,-318,-737,237,468,617,-367,-676,0,128}
     },
     {
      0,
      -133,
      {1064,139,-1495,-1593,315,-2190,-1459,-1757,742,727,-725,-1601,-518,356,981,232,-689,-427,-955,-812,-1607,-1270,-985,-562,-1050,153,1435,-569,-40,-1875,-963,-1919}
     },
     {
      32,
      357,
      {285,-1245,-1471,-28,-404,-610,-2045,-33,-1480,-495,2033,170,8,-1400,-638,156,621,697,49,-18,37,-694,379,-486,574,-154,-530,-758,2329,-536,231,437}
     },
     {
      64,
      -1021,
      {300,604,944,-54,-401,-306,-173,262,-203,-843,304,-851,-323,-680,-747,-120,-592,71,-226,-198,-56,-222,-1106,237,405,-84,-216,89,-578,113,1440,-242}
     },
     {
      96,
      -221,
      {75,-261,-97,-420,-688,-565,-2059,1306,-601,-599,-904,133,-509,-919,-278,123,311,415,380,784,-1034,-610,370,-290,-317,-1413,198,633,-756,1026,424,-491}
     },
     {
      0,
      1959,
      {-1325,24,2875,-110,-1929,1572,2167,-1597,1011,-1460,1062,-1737,936,-339,-1174,218,448,-1317,-775,-950,-511,-97,-855,246,534,40,298,789,-3356,-28,-1166,813}
     },
     {
      32,
      1883,
      {969,1560,-1209,-518,-485,359,-967,-918,862,-200,-1035,1528,-1366,298,-780,1227,-613,-1045,-114,-259,-24,61,-156,-344,218,629,-300,-475,-297,76,-1025,-733}
     },
     {
      64,
      -526,
      {-503,-364,-267,-166,-350,179,-627,1,-161,-765,-578,-353,-275,-1149,-364,-178,-336,96,-316,-626,-833,208,-76,472,-646,-518,-990,-370,-999,393,-426,-397}
     },
     {
      96,
      -990,
      {285,-189,-1165,-182,-188,740,-73,78,-102,19,-581,-132,-112,-17,294,-1462,278,106,669,486,95,-134,342,-98,180,-346,-1528,1345,-443,-142,-138,414}
     },
     {
      0,
      -103,
      {-43,262,-898,-265,-252,529,-4994,-627,191,1192,-1334,-268,-787,-750,-642,-142,-517,191,596,997,219,-2889,876,-632,-1873,-16,398,-1077,-763,726,-151,-347}
     },
     {
      32,
      1496,
      {-688,-151,-249,435,574,1409,476,254,-506,110,644,-128,-843,-536,-2020,-212,117,-237,291,-457,-530,-587,1052,22,-233,-441,-1879,-1335,851,-28,694,562}
     },
     {
      64,
      -394,
      {-170,-226,-418,-268,-237,-36,-330,192,-498,-466,-315,-311,-479,-482,-268,-260,-409,-56,-232,-575,-387,-1501,-1043,-633,88,-140,-304,-480,-565,-422,-396,-475}
     },
     {
      96,
      -1157,
      {-263,-818,-389,129,697,-777,362,416,-348,239,-206,260,731,-116,-594,-1294,259,-681,146,447,863,-214,444,112,802,215,473,-337,823,-39,-152,423}
     },
     {
      0,
      896,
      {-1186,662,1128,-362,-589,-467,14,-48,572,404,841,89,76,-1680,375,377,-187,-785,-578,2110,-1336,-1985,153,-740,192,-956,-1207,123,-450,320,36,6}
     },
     {
      32,
      2784,
      {-428,717,-701,-2031,-1300,47,-1315,-1450,-541,-227,-371,1117,1089,-410,438,-653,867,-416,-700,-267,-29,51,-2033,1891,1401,-177,259,-36,1284,-1158,-2120,332}
     },
     {
      64,
      -1,
      {-56,-164,-459,725,-90,-356,-388,-488,-56,33,-106,-518,43,444,-20,886,258,-699,-502,207,510,-26,-257,261,-188,573,67,698,167,-387,-222,148}
     },
     {
      96,
      -1257,
      {528,-335,-37,-890,979,219,-379,187,-22,2934,186,-589,968,-174,-358,99,399,-116,-859,-114,659,-475,35,-102,44,605,14,-555,737,-495,-609,1089}
     },
     {
      0,
      -355,
      {175,1064,1154,-1530,-1168,-349,69,-675,-657,244,810,-842,1694,1277,1212,149,76,-2749,-336,-385,-1278,-735,990,692,-1040,1734,-1452,-519,-955,-1403,-2427,347}
     },
     {
      32,
      1546,
      {-109,-379,1158,690,-377,-1684,2176,1028,-889,153,-969,-212,-1243,1521,792,568,1841,705,295,-1231,-1346,-1819,1126,-904,2,-1335,149,-2493,-653,122,2327,2213}
     },
     {
      64,
      -1250,
      {-360,-221,228,-993,24,180,139,-293,-849,-746,275,385,-386,149,-291,-177,-1095,-670,-224,-231,-1334,639,64,-138,-1287,-356,317,-401,-46,122,254,-480}
     },
     {
      96,
      -1184,
      {-617,0,280,540,236,-851,1359,-56,-665,73,-17,719,231,321,482,-725,-46,-417,74,1070,246,-357,-258,222,557,497,-404,-547,698,-148,-863,-410}
     },
     {
      0,
      2432,
      {-991,740,-643,166,-745,-336,1437,377,-429,-1932,1111,-661,628,31,-360,255,-988,-1097,-1003,1162,-568,-2261,-520,166,25,-1351,-1066,178,-991,-475,872,-265}
     },
     {
      32,
      159,
      {753,-686,1049,1659,-100,-2183,1212,629,-1793,1121,1123,-319,-2095,-203,-201,-62,-644,-1866,-1474,-509,-2512,131,1266,209,-1781,397,-1997,-240,-1437,760,914,1717}
     },
     {
      64,
      -1222,
      {143,-766,-1238,181,830,-373,-164,-773,-655,771,548,1206,1036,583,915,-130,-57,-1138,302,564,-380,-1014,-189,38,-829,638,353,141,142,-505,138,-134}
     },
     {
      96,
      2633,
      {-530,-134,-1912,-397,15,-1608,-293,75,-54,-258,-168,-228,-50,1561,-1112,-771,544,268,-120,-277,-353,-1260,572,-707,-31,-578,-664,-858,-112,299,-510,-121}
     },
     {
      0,
      777,
      {418,555,-2219,-499,38,-298,-90,-219,-1165,642,-154,278,-418,-1631,-482,416,-660,-175,437,-883,-461,-403,1616,75,1143,-625,1037,-345,-87,1155,435,-683}
     },
     {
      32,
      -246,
      {-388,-1570,289,861,22,-1720,2367,-261,-120,1080,-2354,-291,-2007,-811,-766,-2326,-2042,1021,1059,-536,-1123,1286,-537,-1103,-671,869,-845,-1378,1394,-49,1765,-1460}
     },
     {
      64,
      -844,
      {-154,560,849,-217,-268,-943,-633,357,-134,309,88,-325,-275,109,37,-519,-37,-29,-6,-85,-272,-892,104,-118,274,53,-911,498,113,777,-193,-34}
     },
     {
      96,
      120,
      {-692,-468,125,165,-565,-371,-877,163,-200,-764,-393,344,-291,1040,-497,234,-105,-75,350,-716,-443,-175,-742,220,-74,-389,27,-272,-139,5,1160,130}
     },
     {
      0,
      660,
      {-128,1575,258,-249,76,-922,691,-1532,-2428,-106,-835,524,65,-983,-1544,195,-145,1217,2265,1394,-1454,-688,-242,-35,-213,920,3065,-3111,-1018,1859,1272,-712}
     },
     {
      32,
      -714,
      {-1036,127,716,-353,230,-1850,1360,-796,845,1067,162,-1278,-13,-722,-793,1993,438,567,249,-566,291,-1033,1191,1552,879,32,814,-237,577,-668,1320,-503}
     },
     {
      64,
      -2724,
      {220,340,-1046,-22,1519,185,1164,-163,177,411,1696,934,-151,-60,799,-251,1116,431,157,277,-504,-361,-483,-215,707,465,-107,570,128,-120,-7,1526}
     },
     {
      96,
      625,
      {-736,-121,425,909,-486,248,-338,418,528,-1117,210,-4,-386,196,744,-712,13,-18,170,30,-1165,332,-240,1,-1375,-1487,608,163,-477,-417,-1589,322}
     },
     {
      0,
      -532,
      {399,-575,675,-235,14,204,-1370,83,-196,-1084,467,-194,-588,514,245,-818,-1282,1059,-196,1536,64,-307,332,1114,-680,798,-801,-11,479,-27,-1637,82}
     },
     {
      32,
      -452,
      {770,1333,-75,-540,160,537,-2194,420,264,-961,-435,1657,462,-952,-835,1572,1715,50,1042,268,295,-2004,719,36,-352,-421,-1837,-1639,548,-332,-3499,2503}
     },
     {
      64,
      -291,
      {1272,283,-201,934,-190,-581,-223,352,-781,-907,-199,-217,-244,4,-645,61,-990,-711,-312,-37,941,-735,149,-434,-583,-591,571,62,-578,-659,-114,-771}
     },
     {
      96,
      1531,
      {121,829,-482,-1395,170,1623,-176,771,-267,-377,473,-254,161,-159,497,-794,-455,462,-1091,-439,85,1232,-17,338,-846,-171,1506,1135,-182,319,471,-123}
     },
     {
      0,
      142,
      {707,-671,590,1404,-230,2622,1174,2037,995,-2623,594,-983,2582,1473,-2899,-844,60,-753,864,522,-1216,2244,-102,-2519,284,293,-1113,-690,-2168,238,-976,828}
     },
     {
      32,
      2648,
      {628,1314,-653,-327,282,708,-1968,-891,151,-307,917,1669,-1088,-1326,-1240,1267,68,-405,-348,-1045,-895,-427,-1188,993,1143,257,1758,757,2059,-1134,-950,719}
     },
     {
      64,
      -93,
      {460,-1657,-1209,-4,322,-245,372,-323,901,1098,434,1386,551,654,447,864,1039,-1015,930,181,104,-1187,528,1,529,155,103,-721,424,-544,-333,-876}
     },
     {
      96,
      -1193,
      {-523,-1316,-389,-114,-41,737,-572,91,167,1522,-1240,143,-84,-423,-639,-208,-45,-669,792,-33,-164,115,44,-504,959,94,-813,-398,259,1126,142,-556}
     },
     {
      0,
      -1419,
      {-1034,-1035,-1782,1150,1608,1133,-2584,251,-180,-1349,-710,241,-2318,-274,-1822,-2875,146,3833,-433,-606,162,1288,270,1290,249,-88,2884,-1458,1486,1176,503,592}
     },
     {
      32,
      -1059,
      {-1479,-569,351,794,84,133,638,-1246,-1242,1998,-533,-129,223,-1653,201,-451,-1007,-2190,645,781,255,298,-119,1330,-1359,-847,-277,-643,-525,-767,1454,-944}
     },
     {
      64,
      -1514,
      {-551,518,176,-49,2,553,761,971,354,775,634,1406,-207,761,83,44,821,-768,313,357,640,249,-109,-162,522,605,108,553,1070,136,-643,510}
     },
     {
      96,
      -652,
      {249,366,494,821,346,364,-265,-660,-503,-415,-116,-810,572,-138,113,85,-122,-211,509,454,99,-456,1158,-70,-389,310,328,-318,488,-417,-279,981}
     },
     {
      0,
      -1219,
      {-922,-1490,-54,1479,-266,1172,-560,-793,43,1231,-88,-1658,718,-262,440,520,22,2201,-603,279,937,-479,-16,737,-1893,1420,-1621,-236,1129,554,1145,1327}
     },
     {
      32,
      4120,
      {-913,-227,538,-1330,407,249,447,-516,97,360,-525,-94,840,-487,-1210,-1047,551,-236,-720,-264,124,-1323,-1312,356,1339,-883,-1352,-597,581,-895,541,446}
     },
     {
      64,
      -1848,
      {551,305,790,308,162,-281,-516,405,510,458,808,20,576,96,1122,1200,394,356,161,638,-292,-277,156,-341,-323,-504,963,86,915,-599,388,566}
     },
     {
      96,
      1432,
      {-588,199,-1600,2854,-280,712,-302,-980,993,-596,-1095,-193,-218,-304,111,-531,515,334,794,-443,-127,1621,558,-455,-673,-620,-631,-65,-120,-1346,-504,239}
     },
     {
      0,
      -1992,
      {-1066,-396,56,499,1959,-395,-779,2926,-2,-1103,-45,1515,-210,391,-843,2093,107,237,-311,-1814,307,144,1291,-240,-457,-244,-1704,-806,1272,263,2488,-1477}
     },
     {
      32,
      599,
      {-448,-1080,-1826,309,-1,-250,-1068,-467,-747,1323,1494,-2822,13,-1347,479,-201,168,270,541,-812,-1264,73,727,675,-36,64,1056,-756,-462,-336,-1973,-102}
     },
     {
      64,
      -1512,
      {-165,646,1446,-520,640,-265,336,1074,739,1046,389,1517,-71,1200,756,1114,1533,-491,533,156,-198,-467,242,-125,428,1083,-110,95,26,224,313,173}
     },
     {
      96,
      397,
      {-769,-358,60,1386,-22,-1332,-531,250,-421,-245,-251,-78,-167,256,-298,-253,-1351,-518,165,656,44,831,160,-245,-1003,-253,-573,40,29,-47,-1252,-603}
     },
     {
      0,
      1258,
      {-873,-518,-254,-261,381,-97,272,192,92,918,683,-760,108,-2539,-3015,-685,-357,318,-1134,-2488,510,222,285,-1003,588,-577,-1417,332,-1049,1302,-625,-291}
     },
     {
      32,
      1453,
      {387,-779,-36,-1563,-411,-1019,1372,-272,-707,546,-1213,-1266,-1173,-3234,517,-1036,216,-216,1,445,-1154,90,867,471,-1515,-2,-2201,-1010,-871,-865,863,228}
     },
     {
      64,
      -2811,
      {187,493,670,1086,-114,-39,-227,1188,1210,746,-46,983,282,-156,279,1737,1254,555,785,391,-257,-212,172,145,1428,365,610,324,43,-577,-1140,129}
     },
     {
      96,
      -1134,
      {1201,235,387,401,-292,-86,365,-547,840,-198,145,-184,-221,-1129,-242,-1304,113,675,-286,1470,-5,-797,-517,-476,1928,-1103,-28,101,-250,107,-100,-756}
     },
     {
      0,
      -3328,
      {249,657,-3352,2150,-571,224,740,90,777,425,-4,313,-1510,-519,1667,-261,2270,2043,-457,-865,847,430,-41,-61,-321,262,581,523,1059,868,89,603}
     },
     {
      32,
      1237,
      {-85,-406,-723,1105,291,-1012,525,-617,1110,1543,-1137,-407,2228,1961,-50,-941,30,600,-2134,-173,-965,-438,-2171,260,-464,-878,898,312,-1125,-1969,-984,-872}
     },
     {
      64,
      -579,
      {-852,-1071,-1129,74,-1518,192,811,-1076,-674,-319,-494,-115,130,-717,-67,-135,-203,27,-266,-423,-1147,408,-1363,39,-568,90,-2134,320,-219,489,-626,58}
     },
     {
      96,
      2880,
      {-1315,-11,-440,-1862,96,2209,-1270,428,628,-1032,204,-95,-47,-636,-305,153,-210,57,129,-18,305,1587,470,590,-346,74,-233,211,75,179,-301,-1197}
     },
     {
      0,
      161,
      {633,920,-201,341,586,-952,-2043,-2366,-469,1111,-708,-863,-1104,-288,2470,-808,437,26,-589,-62,601,-1094,687,-327,-2358,414,-1113,661,1512,1560,-1843,-109}
     },
     {
      32,
      2579,
      {-2456,-994,119,182,181,-484,-431,-836,-51,-736,1132,33,-1276,44,-1339,-2014,258,1183,-1288,-225,-806,175,277,1008,-740,895,-531,-1612,-385,-1103,-750,-579}
     },
     {
      64,
      -2369,
      {1153,1579,371,1255,1287,-1198,-262,1255,120,-49,901,-325,-636,185,273,-207,340,533,440,-93,742,-275,692,303,459,936,95,1278,871,-250,-292,384}
     },
     {
      96,
      2251,
      {452,117,674,-187,1085,1538,343,-639,-590,-727,1840,20,1511,-318,-1946,-267,-161,-831,-3098,-307,2418,-28,65,-314,76,-358,1423,94,1486,1293,56,353}
     },
     {
      0,
      1606,
      {-1858,748,1485,-237,842,-991,-178,783,-614,-451,121,598,-191,980,24,-204,-429,-952,202,-384,-1487,204,312,-1,-1444,-1308,-930,200,-1546,-1921,809,-1704}
     },
     {
      32,
      917,
      {-525,665,1535,-267,37,1,-753,662,-599,-714,-88,982,-1383,884,-2704,-1232,891,-371,-1519,397,-916,411,-284,2045,1026,-46,441,-1617,-773,-1549,2058,984}
     },
     {
      64,
      -3,
      {-234,-619,-1061,-382,-681,-1017,568,-940,-509,-412,-384,-408,-754,-454,-328,-441,-693,-668,-517,-441,-670,-962,-414,-852,-761,-550,-213,-688,-182,-295,54,-476}
     },
     {
      96,
      2486,
      {300,-593,616,-791,-15,1128,-973,587,99,293,664,446,65,-680,-379,-393,249,-270,698,563,-289,712,-991,-141,-262,-378,326,-465,82,-232,690,-1162}
     },
     {
      0,
      -1814,
      {-59,1342,185,1621,630,-980,-2270,-845,-526,-325,-1803,2340,-1514,3373,-140,300,-2767,-115,2213,-581,1407,1023,2131,2091,-1698,349,2659,-1433,-278,-1342,614,-3013}
     },
     {
      32,
      1871,
      {1064,40,-1199,-983,-428,-1292,-1435,-2126,1355,-1816,-1243,-862,350,431,-189,1310,-973,-1437,405,480,132,577,-927,1897,-712,-117,-3049,662,1487,169,-1525,-1762}
     },
     {
      64,
      -1612,
      {-88,-922,-357,-94,-433,535,-189,421,1455,778,-737,77,491,-32,944,1327,1792,639,462,743,-1502,-264,715,577,330,510,670,-251,328,-630,-545,34}
     },
     {
      96,
      1347,
      {58,-7,-265,105,170,399,1318,-1418,187,137,-288,429,405,-142,998,185,-381,-70,-204,201,152,225,-418,-860,-72,-589,466,82,292,444,-1600,-985}
     },
     {
      0,
      800,
      {398,464,1240,600,-1484,-958,320,240,-479,-567,460,-861,-529,-1144,789,418,356,618,-1253,1475,-721,-3082,769,-389,-1914,-263,453,-892,-1214,353,1143,956}
     },
     {
      32,
      -716,
      {-1949,34,1376,715,269,889,1369,-88,231,1973,-848,459,21,-1464,-1473,-1252,-3019,313,-118,547,1384,-1442,989,-317,-394,-845,-1128,-462,108,-997,2363,-1231}
     },
     {
      64,
      -1677,
      {1123,1346,514,-488,1147,605,1041,-162,512,115,1428,605,-207,719,698,123,443,-1045,-144,290,730,377,-710,77,141,-19,485,-16,141,390,433,111}
     },
     {
      96,
      239,
      {33,-469,-148,-1500,-474,-231,-470,622,41,342,445,86,-712,-460,-830,-115,164,350,393,-969,-1276,-206,-883,277,466,784,-249,-1013,-512,-4,484,714}
     },
     {
      0,
      -1530,
      {-922,200,1950,700,1913,-582,-899,-240,-252,827,896,-566,-1117,-363,2183,1229,-430,-43,120,-34,922,-1707,-1115,656,-1464,-210,-1974,-1026,665,-748,431,-1842}
     },
     {
      32,
      317,
      {-1046,-803,715,1533,24,-55,-1021,-288,-1244,666,606,665,-759,215,-1365,326,2047,-61,-1217,1526,-1982,-1066,603,1584,118,-912,1604,-1813,-580,238,967,1337}
     },
     {
      64,
      -1032,
      {-817,-360,-152,407,452,35,-1029,20,420,81,-110,224,-229,-1065,-3,-211,522,-1531,-301,51,-18,474,-414,1085,88,-107,-995,806,-693,-1375,-511,249}
     },
     {
      96,
      -260,
      {-342,35,-749,631,-245,-1193,-1414,-46,-36,606,26,-376,-420,-335,-1234,544,-205,520,971,-81,-1082,-95,-231,-214,-526,648,-204,-212,-404,-873,-21,383}
     },
     {
      0,
      647,
      {-381,2127,276,-122,-55,-260,-1124,-1251,-20,1033,837,348,-2017,-1655,77,44,-329,241,102,360,773,-843,524,453,273,3,-138,-1341,-1488,798,-839,-1558}
     },
     {
      32,
      -632,
      {1381,1618,-215,393,614,-192,-1487,-755,-260,1238,76,1568,1430,1726,-577,-1029,-114,-1035,-1970,638,2200,-1642,-4981,357,1887,409,-705,-1490,-275,1024,-1552,-10}
     },
     {
      64,
      -652,
      {975,1026,630,690,517,24,-1163,786,170,618,407,-105,50,487,-259,693,711,66,277,278,778,95,-278,-70,121,442,66,106,431,-470,158,511}
     },
     {
      96,
      -351,
      {-1271,-1169,-1103,-1210,172,-673,3,1010,223,-331,-210,-456,-13,-359,-892,1650,301,-1746,262,-315,307,-66,14,336,876,1262,-765,-48,104,-640,-253,479}
     },
     {
      0,
      2688,
      {-356,445,-917,244,-1199,629,523,-95,819,-375,-374,-761,400,-466,-205,333,724,-266,-1211,598,-187,-32,-251,-1049,1392,-76,-530,391,-2845,425,-1183,142}
     },
     {
      32,
      -929,
      {109,919,-1739,-1211,-259,472,-584,-325,382,-116,1324,-1199,2331,545,1246,161,1113,-211,1327,-330,1694,1040,-1222,846,576,-992,514,-1687,713,-1210,-2436,-872}
     },
     {
      64,
      1280,
      {601,971,-55,641,564,-196,48,-244,123,257,852,139,-134,1073,831,771,634,-394,327,346,-42,-211,-242,-47,58,76,-527,73,63,418,-534,161}
     },
     {
      96,
      -427,
      {732,-671,493,-1251,-203,777,-1549,-38,-434,-17,45,652,-119,174,-574,769,-657,-541,499,-524,-546,369,232,163,-920,832,1216,375,-425,-365,-1394,487}
     },
     {
      0,
      840,
      {1192,-61,-628,1450,-943,-117,-1994,-325,-281,-1252,0,-862,-900,519,-347,-804,-1315,606,-467,-1018,840,-177,1639,830,258,595,687,199,1281,-143,-88,649}
     },
     {
      32,
      1699,
      {1341,493,-1148,574,-391,-703,-653,-552,-19,2227,-145,-674,-583,-1247,618,461,-1619,-792,1122,-1507,-925,1568,1006,-491,-256,-501,1738,-1641,830,-370,-1637,-876}
     },
     {
      64,
      522,
      {372,51,166,582,275,723,299,-101,326,323,356,446,717,528,569,406,431,765,537,429,443,200,902,1063,1404,570,535,644,1024,992,-104,571}
     },
     {
      96,
      1003,
      {-62,-437,107,407,52,166,2007,-144,191,-287,-119,375,135,-134,950,423,424,-491,482,337,195,6,311,-302,-334,-1672,88,405,107,44,-2529,460}
     },
     {
      0,
      -652,
      {1528,-54,1828,-847,1153,1074,-137,809,214,51,120,1945,-394,-560,1933,-742,-453,-201,-1656,1998,-972,-361,-569,-740,-288,-2501,982,-497,88,1254,-159,-1416}
     },
     {
      32,
      2118,
      {126,-277,-2266,-640,-415,1826,-3985,221,-518,-318,-147,1203,284,-1521,100,-2345,409,-263,-1476,-338,143,-430,-652,135,991,1673,-1697,593,1070,-1868,-2463,-1142}
     },
     {
      64,
      1306,
      {242,1071,1321,345,235,430,186,102,201,313,254,478,478,355,299,322,481,1052,310,352,301,805,-181,576,735,559,657,476,453,434,40,223}
     },
     {
      96,
      1254,
      {-85,897,-631,728,306,2151,-253,-881,444,268,271,-198,748,-858,-151,-1532,-364,-220,181,-306,1813,-120,-385,-125,405,643,20,419,741,-18,-169,-370}
     },
     {
      0,
      332,
      {-2511,293,-812,2308,255,710,-986,-978,-143,-1548,266,561,-3,1215,-634,-1922,-837,977,341,-484,-618,1248,1267,-611,-1828,-728,640,-576,-553,-1195,551,-1625}
     },
     {
      32,
      107,
      {248,638,-1698,202,-306,369,-1377,47,-530,317,2246,1891,-132,-1244,732,-286,-113,1131,238,-748,-510,-1133,-3377,-8,810,-1107,1358,-196,992,-382,-2705,1034}
     },
     {
      64,
      -299,
      {307,598,783,488,-328,-894,-1810,586,-466,0,-185,-1652,-329,-662,-301,-361,-268,-151,-786,-81,1853,-578,-651,-57,-16,-107,-273,647,313,-958,-411,618}
     },
     {
      96,
      2425,
      {309,-767,114,-894,-206,536,-446,210,-24,-102,-769,-1266,-533,387,183,-424,349,-394,930,-1512,-375,905,-102,376,289,-716,-198,-628,-120,-282,603,339}
     },
     {
      0,
      1040,
      {-1342,1090,3196,-1822,952,85,3135,-633,-460,-621,775,776,1363,-173,-399,856,-799,-1545,9,640,-1095,-368,-1610,-578,-1766,-2115,-468,-932,-2558,283,-1160,-938}
     },
     {
      32,
      1530,
      {1202,238,-910,850,-148,772,-1417,-1112,917,-113,-884,-761,-573,252,-2107,-513,1430,-1821,-897,-1559,324,-285,-1922,451,-250,-518,-842,-82,740,325,-1827,418}
     },
     {
      64,
      -1344,
      {833,-296,1362,-289,-303,295,792,592,-255,-292,-367,-472,-676,-211,-129,-217,-66,-22,-208,-206,148,-663,38,-1130,-935,-280,-759,-706,-828,23,221,-285}
     },
     {
      96,
      2477,
      {-521,202,717,-1809,33,1551,553,-866,-848,-483,-341,-304,111,335,134,323,-370,456,93,-1036,347,-490,37,-378,362,-158,173,-155,394,349,-167,342}
     },
     {
      0,
      -99,
      {-998,1028,1570,-116,381,290,403,233,-748,671,1861,-205,1564,1428,-1088,-488,87,-1381,-1372,-725,-400,-1849,1137,-1681,334,-505,-662,-1418,237,414,869,-191}
     },
     {
      32,
      100,
      {1040,42,-1444,-718,-191,-418,-2016,-987,1298,-275,1092,542,620,-1875,-191,938,-410,-456,696,-952,-222,1118,-449,1090,223,-704,-739,-639,646,-508,-3518,-330}
     },
     {
      64,
      -1739,
      {1359,968,219,1480,-49,-470,107,669,-265,878,580,-641,236,1465,112,450,802,274,-320,638,1249,-145,973,622,273,948,101,-218,539,471,259,73}
     },
     {
      96,
      758,
      {-41,136,555,-746,-137,502,-631,-1652,-581,-227,456,-726,-475,136,-663,751,-138,27,1012,-752,-404,258,-194,-486,68,630,-325,-25,-221,194,148,113}
     },
     {
      0,
      1454,
      {-1222,-1902,-1163,-399,69,-302,312,-838,293,-960,1464,-410,1389,449,-1465,163,-523,-738,-622,1565,-2011,-1004,-723,-757,-522,1096,405,430,-3242,-38,408,285}
     },
     {
      32,
      -645,
      {-264,757,1022,-349,76,-604,973,-661,112,1816,553,677,-790,563,459,1430,-12,440,577,-776,-890,-863,-2553,2057,-792,654,1275,2030,-72,790,414,-427}
     },
     {
      64,
      -1555,
      {-344,73,-441,458,164,-825,-1471,-119,985,254,-610,-194,417,-83,40,909,963,134,340,224,348,-231,355,252,523,344,-7,-387,375,-766,234,413}
     },
     {
      96,
      1070,
      {464,-239,591,225,522,1071,1467,-343,463,190,57,-80,256,-1492,1251,-257,68,-243,-1232,-42,835,1447,178,-177,1108,1040,-96,37,281,277,-825,-492}
     },
     {
      0,
      2116,
      {2127,269,-104,-108,-1311,1300,-1407,-1279,-353,-962,-503,-914,465,-144,238,-1109,472,-126,-1234,1477,1070,-2345,-653,38,-1614,-546,-1245,664,247,1251,-2,-398}
     },
     {
      32,
      488,
      {214,122,-709,22,602,-345,-1205,-652,-65,100,772,-471,357,445,546,-149,36,-239,316,-71,-1697,391,-1443,-967,928,756,9,721,2521,-3036,-1382,-1522}
     },
     {
      64,
      -225,
      {204,585,942,337,343,495,1240,482,-107,204,226,489,904,344,71,288,79,331,-40,381,213,80,189,736,425,176,658,812,332,541,482,404}
     },
     {
      96,
      -165,
      {323,607,-460,828,52,-1751,1084,-1004,516,-148,-209,-127,113,-466,709,-39,1289,-32,-773,92,133,114,-55,-23,-39,182,516,258,302,-408,-761,-1136}
     },
     {
      0,
      -33,
      {-243,523,-919,2547,25,-649,-68,-1439,-960,-53,322,-379,713,527,-1092,260,-1803,1360,-275,614,-1853,53,475,-95,-331,-257,-1019,171,491,965,-1046,648}
     },
     {
      32,
      477,
      {-1531,839,1316,188,105,-982,-1470,-1093,453,-60,-527,1947,137,-98,124,217,-414,397,1460,162,1249,-575,418,-170,-201,-587,-224,-1201,1036,-2183,1211,866}
     },
     {
      64,
      492,
      {285,95,326,481,559,147,320,952,337,205,497,-381,204,-399,-192,122,23,-172,27,-2,532,554,-776,751,726,464,-27,629,262,1019,-304,255}
     },
     {
      96,
      481,
      {-329,-675,-117,714,141,677,651,1974,-349,-1036,-70,505,417,526,-982,139,-114,-264,322,951,681,-393,-1209,18,-1456,181,354,-188,404,-642,827,-71}
     },
     {
      0,
      141,
      {-671,-769,1206,-221,-832,800,-1016,-1325,-23,-1011,-2051,2198,261,1777,-813,-472,-300,122,387,1943,-262,166,401,1507,-1301,452,-590,654,-603,-812,2838,1423}
     },
     {
      32,
      686,
      {96,-1112,-77,-796,6,629,-1242,-98,-664,127,551,60,1197,-1358,1613,1128,268,-458,452,550,-1082,-927,-1985,-260,726,-823,722,-1160,-453,-984,-408,-88}
     },
     {
      64,
      416,
      {105,-356,-729,93,-330,665,-671,336,15,-543,-127,-684,-791,-1171,-408,-359,-260,82,-585,-182,-522,488,206,-306,-883,-188,-1154,-671,-133,-606,812,-238}
     },
     {
      96,
      8,
      {1111,-246,179,135,564,1077,991,661,101,-301,-95,-552,818,-453,865,380,843,187,-204,-120,1248,-282,-13,-417,-263,138,141,-537,971,-279,-316,75}
     },
     {
      0,
      789,
      {-102,-2239,519,-657,-1157,1042,-1040,-488,891,-314,-251,-1290,809,700,644,-59,-1881,-779,-691,-152,-471,1957,1126,828,600,-107,-263,263,328,1002,-1696,-984}
     },
     {
      32,
      262,
      {-1501,1034,-1442,549,58,643,236,889,627,-929,-190,-498,1162,-526,-472,-349,128,714,-1240,-416,2389,66,842,660,562,-829,76,-305,1022,-936,1285,-92}
     },
     {
      64,
      -516,
      {-1,-309,-266,-232,-74,-329,-606,194,-94,-211,-146,-500,-543,-291,-71,-86,-235,-954,-116,66,-363,-815,-192,-560,-391,-251,-407,-206,-491,-330,164,-338}
     },
     {
      96,
      1287,
      {59,-133,844,-1113,636,1894,325,545,-391,785,404,-589,1190,-438,627,135,-389,130,-230,-327,1486,1102,576,197,92,-612,1300,323,657,29,155,-113}
     },
     {
      0,
      381,
      {510,-740,-1410,96,237,147,1648,-361,-1681,-340,-747,958,519,1910,-802,1411,-713,85,-517,-2023,623,2435,-332,302,-390,-612,1116,442,22,584,188,-1024}
     },
     {
      32,
      562,
      {-769,-465,-612,-369,140,-1383,-565,-1218,174,559,-1596,374,-327,-797,-354,-371,-917,-401,-575,898,28,1087,1577,-757,-8,570,-2044,-1160,-1230,-1282,-32,-267}
     },
     {
      64,
      878,
      {-825,342,122,523,-590,-179,-76,-268,525,409,-678,-218,-225,574,-392,-155,613,-426,-17,-297,576,267,-439,-131,-429,529,-160,-589,-252,-94,107,-144}
     },
     {
      96,
      -479,
      {-592,757,279,447,-463,-319,62,-939,-788,-160,51,25,-509,99,-40,-1048,-492,673,-78,772,-492,-382,228,-614,-1335,-319,364,182,-645,-40,-1207,-2094}
     },
     {
      0,
      302,
      {-225,-919,-1713,979,-899,606,-912,-979,-1008,1083,-746,-1076,1284,-359,-685,109,277,-1216,-860,158,1474,-312,-46,243,-409,-53,-1080,-462,2523,-54,926,703}
     },
     {
      32,
      2060,
      {-595,384,-1498,3,-1,-434,-1434,-553,-85,-1556,-424,-117,142,-229,-574,-577,-421,-881,-150,498,-701,-1651,3,-388,444,-1069,-1132,-267,-462,-827,-678,-688}
     },
     {
      64,
      -323,
      {-23,286,-69,-365,-521,-415,-311,-646,-164,188,178,-372,-63,207,-134,-180,-62,-695,-209,63,254,-305,-724,-75,688,206,-103,-130,-462,44,-335,47}
     },
     {
      96,
      -638,
      {44,308,-322,-121,425,783,-686,452,683,172,154,408,367,447,-851,11,73,-145,-573,547,895,259,-307,-859,438,540,-399,-377,375,236,-107,-190}
     },
     {
      0,
      261,
      {184,-801,895,-698,447,660,-599,-246,317,-735,966,684,-776,-2236,-577,531,-483,-625,537,10,-1095,166,-256,-1367,-924,-1098,262,-137,1274,-512,52,433}
     },
     {
      32,
      1303,
      {655,352,522,-1644,622,529,1103,-289,84,-318,317,-1034,-1771,-159,-1052,-529,-933,-894,-923,740,-935,-421,-1251,7,694,726,-776,80,463,222,114,628}
     },
     {
      64,
      1544,
      {-353,393,550,-288,31,14,-553,-520,-884,29,-1162,-511,741,-563,-529,-378,-486,293,-305,161,911,-252,-444,129,-445,539,-739,161,-253,303,-533,261}
     },
     {
      96,
      -1234,
      {356,-563,619,-175,295,-437,472,882,-599,730,387,-197,431,-437,-1072,1154,-164,83,-443,430,796,739,220,499,-327,-551,289,143,484,-798,937,278}
     },
     {
      0,
      752,
      {-80,321,842,527,-362,187,-1246,-110,-276,-549,626,-933,349,124,6,-1373,-550,586,-442,-193,-453,266,-618,-703,-844,-700,340,-338,189,743,441,374}
     },
     {
      32,
      522,
      {-404,-862,-241,-1821,-51,-611,-138,-831,-506,-2296,-882,-336,1128,-320,-789,123,-1585,-835,-219,1359,-353,-500,-1438,-241,660,-1925,709,-598,-219,-1780,-376,-722}
     },
     {
      64,
      -2181,
      {949,806,376,963,712,-35,609,622,-21,-311,814,147,-389,-38,584,-38,197,348,599,112,283,-745,408,-482,566,538,522,210,1145,71,341,140}
     },
     {
      96,
      225,
      {-1813,175,542,-212,-148,-1075,-519,869,1378,-885,-809,-203,-53,106,-274,538,-356,-782,705,84,-400,-753,361,-337,-1248,-432,-58,283,-347,331,-668,782}
     },
     {
      0,
      -389,
      {-927,1052,-1179,-197,-37,-842,-398,-431,812,418,1703,-1340,-736,-1561,-1162,-130,769,1042,-290,-1080,-1037,-99,-436,-1596,-522,-884,-252,-510,1345,-444,-38,-1184}
     },
     {
      32,
      944,
      {-733,-322,494,575,97,43,-130,-75,-325,-1099,247,301,-444,-125,-956,-502,-283,-676,51,-533,-204,-187,32,-577,-605,209,388,-295,-225,-1187,-1214,-578}
     },
     {
      64,
      946,
      {45,666,99,360,181,237,97,79,96,131,38,316,441,89,-6,214,140,576,281,159,258,569,145,252,758,343,107,290,254,243,330,160}
     },
     {
      96,
      429,
      {36,-111,-568,677,-392,-101,478,-1072,-461,-227,224,472,-882,-372,385,-68,-297,44,322,-370,-1604,378,87,-736,-880,-231,175,-117,-1079,-229,470,-365}
     },
     {
      0,
      147,
      {952,782,-2482,-1162,144,-102,608,709,238,-402,-1755,-485,-101,-164,773,1445,202,-618,441,-794,613,1065,145,-1075,628,283,1445,-161,3181,820,-1415,-572}
     },
     {
      32,
      -895,
      {659,-1076,1660,1414,97,388,354,-1231,274,632,476,-784,-781,178,-213,-129,1113,-1054,-251,-777,-323,541,165,440,-117,-76,877,220,-1559,1001,2116,927}
     },
     {
      64,
      1099,
      {14,667,382,300,125,714,373,500,118,162,-150,321,638,234,126,163,211,859,-51,60,367,841,13,288,379,314,323,477,518,335,288,340}
     },
     {
      96,
      333,
      {71,-846,173,325,-536,781,1087,-392,-1357,668,-17,-327,-769,538,630,-554,-874,-486,127,-74,-806,-325,-307,568,-995,-145,182,-72,-485,65,993,-575}
     },
     {
      0,
      707,
      {640,-413,-155,-844,-882,445,-1805,-410,70,-1017,188,-549,-773,469,960,-827,-1253,798,312,-124,-406,-213,562,-895,-573,-275,-873,-286,2127,-464,819,-776}
     },
     {
      32,
      591,
      {-1319,-558,-1280,644,46,44,913,244,21,563,75,72,1774,105,-236,757,1153,-1889,-1278,-381,190,104,-2390,-122,-398,720,495,564,-319,-1814,-662,111}
     },
     {
      64,
      109,
      {117,380,312,30,19,435,515,255,170,6,241,347,218,63,75,36,146,447,203,-33,319,421,240,262,392,205,432,308,261,359,393,87}
     },
     {
      96,
      1042,
      {763,99,-753,111,341,-578,-1305,-759,567,-222,-479,-95,332,-476,-1014,-373,-287,794,-225,-24,513,-27,-104,-361,40,-457,56,540,62,413,-255,-34}
     },
     {
      0,
      -171,
      {-269,-909,-138,159,54,342,488,607,-126,-788,-225,562,-1322,926,163,655,-892,1322,-334,222,199,-43,367,-729,114,363,719,-317,223,-810,374,289}
     },
     {
      32,
      506,
      {457,-1227,2486,-443,-88,825,-24,-558,-214,362,500,-110,-102,-580,-1014,111,655,-1371,-386,440,-666,-606,1300,13,-21,188,957,-387,-762,575,-183,131}
     },
     {
      64,
      -508,
      {89,359,255,379,125,-21,443,511,607,-132,160,-4,164,478,178,275,78,-348,322,196,481,323,122,681,-281,250,-210,302,237,285,134,99}
     },
     {
      96,
      -1471,
      {253,451,75,99,-977,646,-632,-138,-28,98,368,-61,-1292,-666,-1355,617,182,323,465,-117,-1526,-963,-541,120,327,463,-434,-678,-1082,-499,-336,363}
     },
     {
      0,
      -483,
      {-1044,568,-188,906,-280,-1149,-112,326,-396,644,875,619,980,-1647,1030,-1495,18,262,-625,50,-80,-1257,-188,-1026,-1180,514,-584,242,363,161,424,-1364}
     },
     {
      32,
      406,
      {-248,-316,1047,-803,162,-171,-838,129,44,-253,-71,-314,217,-230,-300,-10,-314,-42,646,213,-609,-602,387,-305,134,-20,175,-280,-364,-742,-543,-405}
     },
     {
      64,
      946,
      {720,521,560,321,-99,-55,-589,-194,-711,-809,151,-774,-423,181,85,-347,-1121,-20,-812,30,292,763,-20,-293,-640,-948,376,-372,309,-251,340,-29}
     },
     {
      96,
      172,
      {-677,-187,1149,854,464,203,-526,-218,185,525,817,294,347,-445,-994,794,-189,-78,-843,337,145,-1242,-552,-326,284,635,897,424,402,807,993,219}
     },
     {
      0,
      83,
      {124,-595,-423,-721,-153,196,669,-919,-586,-1397,147,-1452,-1139,55,-588,851,23,688,526,-39,-120,506,391,-7,-10,632,-271,-244,1490,-206,819,-82}
     },
     {
      32,
      430,
      {-832,-141,838,114,-93,40,165,20,-90,-89,4,-36,-1294,-257,44,-699,-327,-646,196,-241,-210,-55,195,-530,-299,998,-670,235,511,-1194,-217,170}
     },
     {
      64,
      83,
      {495,1472,1053,623,525,-850,431,716,741,188,263,242,162,326,18,480,467,392,607,-156,766,-103,498,-562,527,66,66,-550,-87,32,387,219}
     },
     {
      96,
      -625,
      {-413,890,-620,439,-297,-541,-699,370,376,-263,-97,87,-248,643,1318,-1301,437,464,854,56,-269,-68,80,108,658,-808,18,-197,-240,364,457,-182}
     },
     {
      0,
      -410,
      {259,-371,486,-164,-466,666,1067,443,-283,1326,-191,-17,-620,-1247,-45,-99,16,773,-478,379,-299,-971,-51,-2215,270,1584,-762,247,-478,-954,-463,158}
     },
     {
      32,
      -829,
      {-1006,-966,186,1708,-276,-191,3625,-258,522,287,-63,306,51,1065,736,-303,-758,1380,-303,-513,-174,1145,916,-981,-398,-156,-1284,484,-886,-1601,1375,-377}
     },
     {
      64,
      -145,
      {176,18,563,-175,-584,-355,239,186,72,-255,-237,-669,-436,-667,-318,-72,-128,-397,-461,-86,-228,-64,-395,-551,-773,-244,103,-578,-330,-609,730,-243}
     },
     {
      96,
      480,
      {-322,-455,-311,-90,-587,394,-313,864,-35,293,-484,-734,-674,-206,-87,230,56,-967,1170,-778,-1008,1116,-239,544,-767,-504,-658,351,-660,217,-83,416}
     },
     {
      0,
      126,
      {1314,-103,-1514,859,727,-1060,-1664,-96,4,1989,259,-217,-330,-103,-166,-1270,-654,386,-731,-539,-862,1178,-565,9,-165,-1088,-1025,-660,900,1047,-262,727}
     },
     {
      32,
      1035,
      {-1611,-69,272,562,-177,-1439,-649,-321,-180,1130,-530,-450,-544,-591,-785,371,-172,-9,-683,-784,295,479,354,1190,-200,-1012,-256,-848,-487,-1897,-557,315}
     },
     {
      64,
      -871,
      {1324,526,983,60,-413,-671,-260,989,34,-88,201,-1078,-414,-24,-305,187,-233,-247,-458,-20,105,-291,119,-447,-139,-127,207,-864,269,126,835,-134}
     },
     {
      96,
      743,
      {624,56,100,276,312,315,448,-1371,953,585,351,-150,384,-998,420,-840,1103,-1047,-222,-60,411,752,443,-181,565,-49,247,11,334,-386,-1115,-411}
     },
     {
      0,
      864,
      {1148,-193,689,-116,19,-199,231,-1549,-64,585,35,-43,275,1007,1867,-619,-445,-1421,-449,-846,-898,434,99,1463,1373,255,819,1065,-2337,496,-183,-814}
     },
     {
      32,
      475,
      {-58,87,365,-303,52,51,171,-379,-488,-52,613,78,464,-539,-155,-457,-1021,-907,144,619,286,363,-1423,1065,384,-2824,1029,200,-331,-2128,-777,-227}
     },
     {
      64,
      -133,
      {-516,568,-301,164,290,-288,-434,-222,421,260,-60,9,429,-141,0,-236,732,669,30,738,279,559,43,-649,884,884,-39,451,-9,887,-151,809}
     },
     {
      96,
      47,
      {646,337,196,17,6,295,-175,990,750,-908,-180,-613,-279,710,-466,103,-148,298,-412,-955,-611,367,-517,70,1171,258,35,-847,-359,25,-301,-212}
     },
     {
      0,
      1230,
      {787,-437,-748,-149,-337,-406,-1003,-846,-507,1551,-437,-1856,-270,-830,-110,977,273,-500,-289,-137,-354,132,-1681,-720,-762,900,-1521,-374,-317,1605,-960,245}
     },
     {
      32,
      -58,
      {-1070,-24,1602,489,-40,-903,78,689,-539,-255,-309,302,77,284,1722,-1757,-540,-446,321,-610,786,-220,-1918,709,138,-88,447,-731,-939,-1356,-33,533}
     },
     {
      64,
      -929,
      {-45,1164,523,196,-484,-238,-350,79,419,-37,280,-147,-549,77,-540,276,546,696,-257,176,726,-211,-389,-1079,739,275,-106,113,1525,588,-368,186}
     },
     {
      96,
      148,
      {57,-65,-16,349,88,-104,-163,-538,539,11,862,568,194,345,774,-392,-394,-89,-732,500,-186,-291,181,-1208,238,1122,560,437,2,-195,-1286,-159}
     },
     {
      0,
      522,
      {2148,360,1101,-485,316,-402,-439,1702,470,-314,-893,709,-344,1211,-1219,-120,1292,-2063,-309,1480,325,531,804,-2166,179,-971,-1915,323,920,75,-42,389}
     },
     {
      32,
      -309,
      {-189,-1402,1258,314,-331,-34,111,417,-333,-68,-972,-312,-1048,-890,111,-114,-96,-866,-658,363,-724,1431,-1221,869,-995,-1085,906,-514,-1738,-586,-1215,13}
     },
     {
      64,
      521,
      {-1139,552,418,-415,-291,192,-1504,-1317,-363,-556,37,-183,-277,-684,-4,-475,-642,-119,-860,482,-40,291,-580,115,-51,-75,463,351,333,98,-794,399}
     },
     {
      96,
      167,
      {-190,256,94,203,72,265,958,-881,-525,-267,579,474,310,-225,-118,-1018,-522,320,1182,-33,217,160,-163,-1118,-13,393,63,426,244,-424,373,-217}
     },
     {
      0,
      750,
      {180,-271,674,-526,408,1460,282,138,-526,-804,-142,921,-275,948,-217,-17,58,-154,-712,674,-157,506,67,-1363,-191,-74,-767,-663,-371,-611,-918,293}
     },
     {
      32,
      -433,
      {1218,1104,-868,58,322,696,-958,1318,-26,-2131,1015,53,1694,-440,-471,805,553,453,-2398,-653,-72,540,-2473,306,1308,-22,1208,-1189,-268,-620,269,-812}
     },
     {
      64,
      93,
      {-744,-459,-255,-919,-241,-271,-206,-951,-54,-334,-878,70,-17,-736,78,-57,148,-323,617,-12,-1150,404,-869,665,-8,167,-151,-55,-421,77,-520,-222}
     },
     {
      96,
      183,
      {-912,-101,128,326,261,1162,970,248,179,-302,-129,-235,458,-275,-234,-351,336,-327,129,301,767,1172,-541,-125,-483,220,45,-459,553,-200,25,159}
     },
     {
      0,
      358,
      {-113,-81,45,55,644,406,145,28,663,-75,-52,-444,64,624,-825,-292,-62,312,-1127,154,-146,160,-1004,143,166,-930,352,-108,47,-105,451,-6}
     },
     {
      32,
      -812,
      {-613,-112,70,806,-134,693,-689,-286,335,52,229,-8,-763,119,521,-533,140,-707,-507,-229,-447,-801,-1250,-427,-421,574,1604,-521,-2352,419,1237,808}
     },
     {
      64,
      572,
      {73,6,-692,-6,-272,313,615,-151,-99,-210,386,582,-84,62,618,-251,0,538,337,367,-202,446,127,428,338,-64,199,436,466,626,-225,-214}
     },
     {
      96,
      132,
      {-191,-904,-1225,-774,176,-187,237,724,-349,-249,149,-16,49,137,-206,25,-497,73,-273,5,102,219,14,149,119,272,398,-24,-111,246,-305,165}
     },
     {
      0,
      -608,
      {119,-486,-1193,-307,-307,170,302,466,462,211,1138,-1058,-1188,-100,276,725,-437,-470,-350,-1014,147,-246,151,829,-535,-1157,73,624,784,-246,898,76}
     },
     {
      32,
      506,
      {-300,-463,31,1409,27,-798,-1017,371,634,1006,-18,-416,-357,-48,-1772,-457,708,446,-478,-496,359,154,628,-506,34,304,-118,-1601,-1354,929,89,-32}
     },
     {
      64,
      -382,
      {-132,313,-114,-319,-397,-271,-45,338,286,-263,-61,340,113,467,-365,-59,177,41,283,-634,1073,-384,-339,351,177,-8,17,-285,-132,-321,718,16}
     },
     {
      96,
      371,
      {-720,768,-366,-813,44,596,-467,-675,421,79,170,571,23,-308,161,-364,204,209,82,-763,125,180,-249,326,967,-548,292,-650,217,209,116,-49}
     },
     {
      0,
      58,
      {281,-194,-318,-1230,-540,-58,-181,208,-520,-608,545,393,-538,-229,-207,266,-684,-469,-506,137,569,-327,-320,-819,681,92,171,555,-674,719,45,-655}
     },
     {
      32,
      -83,
      {-234,592,-77,274,-99,-509,220,-510,224,-172,514,-419,-566,174,675,-1031,-235,545,239,-343,-275,392,-29,2,695,1006,-441,174,-218,209,568,-49}
     },
     {
      64,
      -12,
      {186,50,271,76,260,-206,-207,330,341,320,39,-32,-217,473,414,271,-96,-20,430,-12,138,523,-124,-17,397,38,274,-21,-18,165,-251,26}
     },
     {
      96,
      -187,
      {-31,58,754,-394,40,90,296,533,-572,695,-118,103,55,-126,-944,-134,-334,-61,-247,-222,95,-100,-499,274,-550,-203,282,-192,266,431,1071,-69}
     },
     {
      0,
      -37,
      {25,125,-22,-68,-46,-45,49,-27,-19,42,107,-162,-33,110,124,52,-26,-116,-257,11,-91,85,59,-50,44,-62,115,-28,-57,82,105,-170}
     },
     {
      32,
      21,
      {82,-66,-121,-229,220,78,-410,123,5,190,16,-77,134,169,195,-142,-23,-48,8,-236,-105,-223,121,129,-171,-32,-7,-120,77,202,-135,129}
     },
// *********** Cells of layer 3 *********************************************

     {
      128,
      -1710,
      {-2917,-1402,-798,313,-223,2626,437,190,66,-888,169,-650,-1231,-936,120,-204,214,-1962,-99,-544,-472,-139,-81,64,-1742,-785,-11,-209,-1080,912,53,250}
     },
     {
      130,
      -663,
      {-454,-25,-920,-586,-413,-269,1980,-1149,-777,-781,-505,2859,-18,397,-83,-909,202,-506,1539,-1877,114,180,-886,-158,352,74,-301,-521,666,175,1500,524}
     },
     {
      132,
      -3284,
      {1592,461,182,-480,-624,18,856,-543,-273,-279,-523,-62,-321,-1975,336,295,-428,886,278,292,240,-17,307,1,-1050,1367,-506,-258,2161,228,-737,182}
     },
     {
      134,
      1414,
      {667,-1076,-2117,-2708,552,-585,-2182,-174,-744,28,-479,148,-817,45,735,108,97,1365,-41,143,-215,698,-199,436,459,-995,950,-945,-13,262,1094,-941}
     },
     {
      136,
      -1749,
      {-678,-30,1811,-332,-553,1113,-881,-265,-419,89,-40,311,-1403,1364,68,-124,656,-1228,238,22,-738,-559,-389,-21,1428,169,305,181,1317,365,542,-189}
     },
     {
      138,
      -3046,
      {-190,-1827,2583,-574,-442,-59,-1274,946,850,-452,958,-2008,54,260,850,-1164,310,-559,536,1318,-708,185,-563,67,-424,-847,1401,743,-347,-410,-4672,1469}
     },
     {
      140,
      -3638,
      {1341,355,1034,-365,1948,-116,296,-199,877,-2259,-383,-353,1851,-982,254,-492,-39,1311,-185,460,-819,-34,129,202,1462,319,578,-421,-67,196,852,-343}
     },
     {
      142,
      -1908,
      {263,208,545,-2119,-282,-160,-681,-2486,115,-36,-1771,385,-256,133,-1408,1299,-99,-79,653,200,466,-174,-874,2169,-444,123,-176,378,26,-174,782,19}
     },
     {
      144,
      28,
      {-1072,-1439,-726,58,-2102,-456,-19,-123,2133,1895,-295,-189,-1503,868,113,-286,653,-445,1211,608,1635,96,243,-349,602,-796,-333,-135,852,422,-631,-83}
     },
     {
      146,
      -1887,
      {-1350,-2394,679,-299,1750,-83,1784,2452,-542,-106,-208,737,-64,-131,-1192,-782,79,-277,1406,996,-536,-168,71,-504,-1783,748,135,2209,668,-23,-851,-1641}
     },
     {
      148,
      -1945,
      {1305,-1688,-244,-324,366,-1356,307,23,-1036,278,478,38,-421,1018,-673,756,-431,1831,85,-93,-1695,-145,-89,-212,-472,-240,594,-223,303,51,-267,280}
     },
     {
      150,
      -2206,
      {314,-41,1134,1519,718,121,-895,781,-1100,101,1421,-809,-44,423,712,1707,-762,58,-2343,227,13,-267,-2573,741,122,-118,451,-1410,-747,300,-1320,-86}
     },
     {
      152,
      19,
      {-1505,-1762,351,161,-1736,80,-58,152,453,-2098,7,-387,-1302,462,84,95,-1024,-531,-1183,494,-53,-521,1279,269,613,856,226,9,-979,-128,-1519,-204}
     },
     {
      154,
      -457,
      {-433,-11,-1112,339,-46,-60,-470,-424,188,-167,-275,749,97,48,255,640,31,143,689,-1694,120,326,10,-658,470,12,737,-1496,-572,90,-1235,-1106}
     },
     {
      156,
      -1996,
      {-78,1787,45,437,589,-1756,-645,-753,1894,-1192,-342,180,-440,719,-824,93,-1572,52,188,31,953,-373,223,391,-105,93,-2874,-139,1644,102,843,-399}
     },
     {
      158,
      -371,
      {-131,298,-3379,-1016,150,-914,716,67,708,-658,-1745,588,-922,232,843,426,293,337,-832,-2410,-308,-748,398,-38,-137,-2588,-1574,-9,-845,-448,798,448}
     },
     {
      160,
      -1897,
      {1017,-1201,-137,-247,354,677,561,-429,561,1226,-371,-235,-887,-272,868,-58,691,1503,-299,-1885,-192,221,-1593,-1279,-180,-229,-310,-1053,491,444,-246,-756}
     },
     {
      162,
      -1290,
      {-320,233,-91,-51,-105,-183,-112,158,-732,-158,462,-122,667,39,57,72,93,-57,516,-396,-536,-51,424,-1254,399,-78,-380,1882,-319,59,-742,-1882}
     },
     {
      164,
      -1641,
      {1564,80,88,13,645,-1204,353,102,609,-17,-461,240,-1997,614,22,222,1011,1639,-6,-76,-2272,497,463,178,-1470,-76,36,133,-22,525,102,294}
     },
     {
      166,
      -1999,
      {-382,-178,-2101,680,-402,-323,399,326,-369,-70,-820,-1368,312,345,147,632,-1164,-192,1024,-1841,-133,158,-255,2086,349,101,-2404,412,105,95,-906,721}
     },
     {
      168,
      -2046,
      {800,198,-455,-51,-769,-1816,-1285,139,953,-722,164,152,739,-1478,-316,29,1225,-900,-283,-114,-1959,-139,838,29,-45,-531,-103,151,48,1502,419,-7}
     },
     {
      170,
      -3512,
      {1155,666,773,-1486,-492,-59,1113,411,-228,490,1058,-1683,56,-476,1215,-775,-70,241,-921,824,369,36,-334,-2947,106,2,695,1251,-551,319,-1983,-119}
     },
     {
      172,
      -363,
      {-1710,-1962,1002,1240,975,-666,23,-226,-1400,-849,-978,-175,-874,-1088,-777,-495,1175,-374,-1436,-668,1399,-629,45,-270,988,794,280,-385,-2139,-776,-250,263}
     },
     {
      174,
      -2817,
      {147,102,390,-1869,232,387,628,-1363,-745,217,2015,-2276,-1164,-180,-831,681,-647,784,-1081,-1468,933,-770,-1065,1160,-306,-77,499,2163,-260,567,-2741,1896}
     },
     {
      176,
      -2239,
      {725,-2571,1103,-626,-1384,-19,44,-1229,-1952,-2286,154,-574,-128,-225,867,586,-1142,-836,175,-181,-899,1695,302,372,921,895,-1443,-43,1285,691,1246,-259}
     },
     {
      178,
      -2419,
      {681,-87,105,-1326,-701,426,635,631,-675,-86,-1104,1045,-49,15,-495,-245,-81,-238,558,1052,-470,106,-668,1687,-223,-390,-531,-862,522,119,-288,60}
     },
     {
      180,
      -1497,
      {-658,541,-368,-1120,-2793,-3484,310,120,1305,-182,-14,-350,1049,1421,-898,-399,1011,3058,-901,-152,-1757,-695,773,587,-1441,-3382,-305,-281,369,-1159,-112,-833}
     },
     {
      182,
      584,
      {-1527,-1204,2453,-3339,476,-417,-1567,-956,501,-1759,-943,-754,204,-752,127,2372,-745,-233,136,769,-241,-195,-2053,434,1233,-83,-1921,-1255,-14,-346,-3506,-1422}
     },
     {
      184,
      -3178,
      {-2063,-159,-649,0,-430,309,-569,360,-229,-1091,-1909,646,1177,1168,-815,-1,-1567,1312,-1243,-1317,315,666,-499,-762,685,-126,-1118,157,612,-203,285,-2198}
     },
     {
      186,
      -1279,
      {1363,-909,1228,-2689,308,-601,-2491,653,877,-187,1287,1188,1237,-100,-895,545,-1666,-922,-4051,-2064,-556,78,-852,-428,667,461,2014,2658,-1663,530,-240,-2788}
     },
     {
      188,
      -1359,
      {-1610,2296,-34,-313,821,1140,-708,-423,-2138,1203,13,-350,391,-2881,550,-158,651,681,465,118,-1437,-250,156,-136,1961,902,-66,-2065,-3740,-103,1170,-100}
     },
     {
      190,
      418,
      {-336,35,919,677,620,-760,-1036,316,36,-258,-1283,-368,-823,249,223,-1658,1482,-39,1386,-692,-797,-175,-281,2310,-2341,-432,1300,-87,-188,-929,-1364,-2201}
     },
     {
      192,
      -2921,
      {1856,1694,-465,309,226,4346,-42,-591,-87,-1631,672,624,1723,257,656,273,-1948,-145,-892,167,-1826,-162,-962,-292,-1784,-1241,-325,-805,-1318,964,-445,-767}
     },
     {
      194,
      -986,
      {74,-55,-143,3349,-794,-282,-1361,958,362,-528,-760,-2562,-722,-101,-1620,1196,406,-670,-2338,-74,-465,-609,-2591,-1722,-96,-735,413,-1859,204,-750,685,-1701}
     },
     {
      196,
      -1703,
      {-549,-308,-84,-447,-92,374,-272,-1075,-2120,-278,473,-5,104,925,-1370,88,-336,-106,-1266,-203,535,779,195,125,-2350,3089,1027,-706,649,684,1339,-473}
     },
     {
      198,
      -1468,
      {-1544,-343,-882,2066,-637,-833,-427,-1193,1349,205,467,-22,-614,-450,-1818,-687,-598,-17,1405,1175,-143,-53,-2569,1336,554,-590,21,324,424,-901,949,27}
     },
     {
      200,
      -1710,
      {1031,-248,-364,217,-1687,-1076,344,-285,-1156,2319,392,198,600,1194,-849,-1088,-2656,-198,-1137,309,-277,-542,-634,-879,1207,-423,-201,-53,-3245,741,288,-635}
     },
     {
      202,
      -2156,
      {-811,444,-1743,1794,1046,-880,-1016,1613,-637,-260,409,-958,-1380,195,-2174,-2586,554,125,-625,2470,660,-1235,835,-210,-1200,-150,-2069,1142,2516,-200,284,96}
     },
     {
      204,
      498,
      {-2107,-1905,-1213,-652,1162,424,298,-384,-1239,350,78,-642,-673,939,177,1351,852,-765,291,-409,-663,-502,156,-353,-638,-3288,-257,-686,-1389,-1159,625,-52}
     },
     {
      206,
      -295,
      {-1346,-552,1562,-1531,-881,-1568,-742,608,304,-53,-3372,-275,-932,-889,1187,-716,-576,-1946,236,-536,-1356,-779,-144,-1443,293,-331,-520,-948,-105,-217,2148,3191}
     },
     {
      208,
      -2196,
      {-412,-329,-385,-1968,375,478,-580,-288,-1840,-874,-816,-351,666,266,-932,-1925,1068,-2740,-1244,-537,-278,387,308,706,3541,-353,-261,-165,900,-1368,-1138,-516}
     },
     {
      210,
      682,
      {-1400,-464,-3945,-1021,-1057,-320,-131,-2081,-92,-354,270,102,-144,-152,895,-259,-728,602,1244,713,1010,-260,-1751,-1921,-914,-1069,2732,-101,-437,271,249,-1348}
     },
     {
      212,
      -1055,
      {-1620,1744,-1176,-1513,-3532,-707,-1028,-539,-575,-1370,-478,-761,177,1775,-933,130,-1422,42,-333,333,2442,354,422,-302,-788,-896,-480,-843,380,-905,651,312}
     },
     {
      214,
      1232,
      {-1274,-540,605,-2647,104,-418,403,-378,438,-187,1630,555,1034,666,-2913,880,-84,-422,-1607,-514,354,-1244,-1980,-588,-872,-720,-2114,576,413,209,-2992,2480}
     },
     {
      216,
      -1225,
      {160,-657,0,-244,-1338,1304,1860,-1231,502,3184,-278,-305,310,1725,-72,220,1889,-639,-2682,-96,-1021,1662,777,570,-1997,-470,-309,115,-702,-2623,-1123,-757}
     },
     {
      218,
      -1141,
      {-638,-635,-1668,-275,594,626,-1389,-909,999,244,-424,732,-136,500,430,-2078,-216,-24,-115,-1635,-1348,-639,1548,872,-488,60,2315,2276,-972,-710,1044,2313}
     },
     {
      220,
      775,
      {-550,-621,154,-414,2032,-578,-221,-615,-1681,-414,-22,-549,1528,1405,-1066,135,-2455,1442,-458,-1065,6,-1293,956,-1083,-2383,-338,-351,-32,-750,-2401,716,194}
     },
     {
      222,
      -762,
      {-880,-1679,2286,-1792,-1027,-117,-1182,-369,-330,-696,695,1864,176,148,542,289,-913,-464,-361,-2891,1230,-319,-249,-465,516,-274,826,536,-787,-931,-1506,-1608}
     },
     {
      224,
      -1195,
      {-3262,-2101,-52,-57,-277,-1160,-189,37,836,1325,-534,182,2375,-362,-285,-852,2482,327,-30,-60,-304,-653,-1550,-707,972,-1725,778,-654,-1947,-2157,484,-81}
     },
     {
      226,
      -1923,
      {299,-311,-1297,1901,640,160,-902,-792,-89,218,-2513,-697,-1699,-571,3053,432,-477,-414,2921,-989,-815,-86,-651,1556,-1770,456,1802,-189,-1129,-1036,-687,-1200}
     },
     {
      228,
      -302,
      {-1055,917,-849,-1333,41,-193,-987,687,-85,859,20,-1407,-681,-1637,-357,-55,2021,411,-541,404,-3931,636,594,18,-980,-406,-587,-994,1439,854,-67,1107}
     },
     {
      230,
      -1879,
      {-57,-467,-45,-124,-419,-1147,538,61,-648,100,1879,467,-385,-377,73,-567,-5,-500,-2015,2076,-390,307,-910,3049,12,-1439,633,1298,-1149,30,-331,-1947}
     },
     {
      232,
      -1534,
      {5303,-816,-776,-251,-313,-569,-567,-554,138,-1217,-892,-75,1287,1768,-1463,35,-161,-842,933,81,-1017,-547,483,-635,-1185,1746,-51,501,1437,1159,-1900,-700}
     },
     {
      234,
      -317,
      {640,373,-994,654,-1026,533,-987,2587,-1183,-242,472,2729,-898,-267,-921,-181,-1697,-483,-2491,-738,1368,-34,656,-578,-639,155,1228,-259,1024,67,90,-1311}
     },
     {
      236,
      -1583,
      {481,930,-1244,-253,-1519,940,-717,-71,-1652,2133,-1079,350,1276,22,-69,258,-2116,-928,-596,-12,32,3699,561,-481,-1223,1423,-565,-75,2139,-1230,-415,322}
     },
     {
      238,
      -1123,
      {-396,972,-313,1061,-1040,-208,489,2530,-1287,-322,2737,2372,-882,94,607,-2277,-25,-1023,1289,818,362,439,1655,152,-731,-187,-1783,-2494,-412,-138,-2123,284}
     },
     {
      240,
      -504,
      {1250,95,392,61,1018,-644,-464,-657,-1605,-185,-983,203,-3770,-818,-831,-607,1777,-1318,1478,1142,895,-1208,-397,-297,-41,1395,-1452,1418,-1684,-965,-392,428}
     },
     {
      242,
      -962,
      {-337,176,463,-530,-357,157,-2227,1084,-1914,253,875,-2941,-169,-98,1791,497,63,-584,1671,-228,899,-511,56,-3129,95,-1172,-1221,2005,-1516,-1097,1087,1145}
     },
     {
      244,
      -384,
      {-498,-399,-1052,-600,241,-1011,-1610,0,-1648,-588,-638,-308,201,-1662,288,166,-1009,-2584,-535,1033,2769,-2845,378,-836,2102,-758,-28,-123,978,1141,-150,-552}
     },
     {
      246,
      -1465,
      {-553,-883,1448,1181,-943,9,204,674,-816,-1103,1462,1392,-54,142,1280,897,-701,699,-288,669,-1078,233,-2860,412,262,-16,364,-516,-355,-1037,-36,-292}
     },
     {
      248,
      -312,
      {-656,-1432,-559,-644,-791,-2444,-382,-1489,2460,-505,-1000,741,2571,486,-894,-114,-967,-883,-911,-1247,731,-1244,-713,-104,1348,-702,87,764,1587,-2580,-33,112}
     },
     {
      250,
      -852,
      {-223,-831,-257,-1573,1646,-191,2177,-947,-573,-56,-265,1845,-407,-542,-2458,87,-737,-422,-311,-1633,-570,-240,-1537,1875,762,742,-1206,-717,-275,-384,-217,2626}
     },
     {
      252,
      -253,
      {-401,1038,425,-629,-1359,-71,-422,-97,-173,349,-81,-1401,-1386,-236,-1290,316,-170,-216,-164,-726,-1489,1085,608,351,2050,-559,728,-955,-1909,2039,405,-319}
     },
     {
      254,
      -405,
      {-746,295,-506,524,-116,-69,-341,-196,-947,-992,-747,814,204,701,-292,1014,-792,13,-857,-1110,-1142,-438,1415,-1473,-394,-652,148,1303,-1010,-116,-573,445}
     },
     {
      256,
      -101,
      {1899,-1494,-1428,723,-1648,-2393,-321,152,-588,-426,1146,-669,-1343,1056,-1497,89,-411,96,-1572,-345,1130,-3063,-869,-292,1753,-1482,494,57,429,-828,-191,-268}
     },
     {
      258,
      -834,
      {-1626,-359,820,-599,773,-690,741,732,-483,38,-245,1007,-114,-310,-2172,2880,-304,0,-2352,760,247,17,-324,-1086,95,750,-2209,-481,-242,1154,-3295,3144}
     },
     {
      260,
      -633,
      {-51,-1275,-98,-708,-12,252,-1021,-801,-102,-174,-197,-416,-653,1315,1132,-390,328,-2973,623,-37,-1320,-346,660,-374,2571,-850,339,198,-4333,554,275,221}
     },
     {
      262,
      -152,
      {1096,850,1096,839,-862,-683,-249,-1342,879,556,-1508,-41,551,-551,-1208,-1723,328,1143,-130,1903,-1133,-1066,-614,946,-601,-605,-712,581,837,-2077,-1263,2390}
     },
     {
      264,
      -1221,
      {585,99,574,232,-802,-74,375,-1331,-435,700,1335,483,-1299,-843,583,-922,614,732,230,-770,638,2968,-54,-552,-2563,-2108,-1171,848,-1471,-322,-819,68}
     },
     {
      266,
      -739,
      {-319,-925,1244,554,-1892,204,-88,709,-478,-432,2929,-889,-50,-683,391,-724,-494,-122,-2089,-600,-317,278,-1514,844,-517,-276,-374,-491,-1881,576,-809,997}
     },
     {
      268,
      -1042,
      {-499,-611,-746,410,205,-1001,1350,-2090,-365,1188,-307,-801,-1780,902,-1430,-437,1642,1612,-582,257,940,-1304,-2049,449,-282,1597,2506,-417,823,443,-844,32}
     },
     {
      270,
      -1577,
      {-941,272,1204,1120,-17,29,1761,479,-583,864,130,-592,-447,-1777,-768,304,-493,-1590,1054,1282,-719,-1239,168,-1101,-2230,-527,1720,729,-1513,1246,-499,959}
     },
     {
      272,
      -817,
      {826,551,-782,503,436,-1694,-361,-978,679,-1058,278,1155,-38,1567,-904,722,-1341,-966,-1285,712,-951,1674,60,327,-387,428,-477,-386,-2685,59,6,594}
     },
     {
      274,
      -909,
      {345,767,217,-1379,-583,1570,-3667,-210,-185,573,1549,-456,343,1488,-196,-710,-57,126,-945,-534,75,1987,-1297,-794,-1130,1320,-1662,-1493,-1076,900,1909,-1053}
     },
     {
      276,
      -818,
      {-1303,-143,-15,-708,-1651,1180,-231,654,-193,1292,-552,-405,-741,1017,-517,197,-193,-56,-39,-422,1577,1241,-688,-1229,1822,-2149,-393,571,828,-858,-196,-636}
     },
     {
      278,
      -954,
      {221,-845,-1358,963,50,-252,-783,162,-277,-459,2273,-477,-626,143,482,178,-290,123,-357,-902,-1141,432,-2872,-660,-681,196,1648,2396,-665,835,-1635,-1672}
     },
     {
      280,
      -524,
      {-303,-67,-75,-243,-1573,1140,-75,181,163,1804,-211,-222,-1416,-55,176,-1096,1672,888,-629,-1060,2047,-1273,-419,-115,636,159,-264,-991,-451,-1506,188,-879}
     },
     {
      282,
      -639,
      {-148,-209,-1469,465,-112,-116,1399,560,-289,162,938,889,-112,773,498,-342,-1150,-570,-1840,-992,-590,-448,1883,76,-1021,667,-991,-66,-676,1493,-724,-232}
     },
     {
      284,
      -668,
      {463,638,-968,350,-1403,675,-1671,-1025,1044,-826,-1064,-962,1231,1112,-340,-950,1048,-1173,-232,-1120,585,745,47,-1303,-1893,721,188,2167,1081,-549,-1403,-86}
     },
     {
      286,
      -1609,
      {-551,449,2056,-694,-673,1243,1023,-578,-71,-1433,-579,-902,-1341,-1069,-802,-19,-1021,-482,423,1461,-819,217,-144,374,-735,1136,896,667,-587,-268,-106,342}
     },
     {
      288,
      -146,
      {2068,6,-1020,-1748,-619,936,-214,417,-598,472,-355,695,854,-428,-462,-1056,1002,-650,-165,186,955,320,460,-791,2471,37,-1227,608,-818,-301,80,-2298}
     },
     {
      290,
      465,
      {-988,799,-283,2843,-461,15,-2198,717,-867,986,905,-929,-515,-774,281,-699,-468,1239,-563,178,-173,-1059,2257,-639,1139,-1691,838,696,-573,-770,1482,-928}
     },
     {
      292,
      -368,
      {226,-509,-251,1435,-296,-315,-662,720,-1182,-1067,-618,294,702,-1515,-845,497,-729,-1268,-803,-1190,1511,-375,82,99,-144,-547,100,13,946,-3560,17,595}
     },
     {
      294,
      -437,
      {6,924,958,42,-458,-673,-424,-841,-540,-513,1259,218,-456,-947,-645,-459,-397,-853,-32,-157,-207,-384,-571,-304,-270,-529,-481,677,47,1093,-188,131}
     },
     {
      296,
      -865,
      {2462,1396,-1169,55,1678,-1525,-588,189,1111,-1240,-880,-694,655,-937,-658,-677,-1084,6,-409,-544,1836,415,-690,-645,1066,-2091,-89,59,843,-1034,218,-1414}
     },
     {
      298,
      -974,
      {-854,346,-2234,-1477,-1043,-481,-413,562,-861,731,-823,-791,-639,-1147,128,456,-380,972,-793,63,-881,-193,-1151,1883,261,-91,-1720,2177,350,442,2043,-723}
     },
     {
      300,
      276,
      {666,-1499,-773,577,-50,634,-137,-766,-529,-1671,-295,-592,118,-266,144,-641,-1619,-214,96,1318,-523,-1067,626,-725,-1721,357,819,-299,-1082,328,791,1095}
     },
     {
      302,
      -9,
      {-790,-1083,1516,1259,-567,-848,-441,568,194,521,-63,1328,160,-228,-823,535,-253,270,268,-732,111,-2572,-342,-453,360,-1120,-2290,875,-428,-1020,-1693,119}
     },
     {
      304,
      -2272,
      {-1677,621,-2340,528,-263,1721,-1776,-71,-222,-826,355,-859,-373,791,-2223,-1066,760,1879,-503,-353,-427,609,-691,-435,1215,1396,-578,-699,2587,1033,383,-1272}
     },
     {
      306,
      -1288,
      {-881,51,491,192,-686,77,-651,1111,-1891,-101,-281,1212,-1099,-262,729,143,-1026,-832,-440,1601,-1229,1238,-412,584,-1006,-289,375,891,-721,-541,-212,1042}
     },
     {
      308,
      -404,
      {-41,-56,-314,1,-78,-219,-181,-178,-17,-52,-147,-45,-154,-94,-76,-91,-16,-34,-38,-139,-2,-261,-208,-201,-145,-18,-94,-177,-74,-189,-142,-101}
     },
     {
      310,
      -413,
      {-88,-15,-31,41,-140,-167,-283,-62,-115,-360,0,-166,-103,-274,-66,-30,-211,40,-202,-184,-171,54,60,-29,-28,112,-239,-39,-77,-143,-38,-75}
     },
     {
      312,
      -793,
      {959,572,83,-1458,699,36,-328,481,602,1424,-501,-1050,-553,-2137,-641,-430,-122,1378,156,-778,46,1119,-93,-867,-3734,2210,-526,-1587,-1506,-1334,-921,-302}
     },
     {
      314,
      -547,
      {-102,328,-1385,-1617,-1021,-43,552,238,-529,96,176,-1601,-1431,-821,1310,-1597,729,-428,-700,264,337,5,-1776,506,-1017,-883,1271,-2201,-308,-1297,-711,2084}
     },
     {
      316,
      249,
      {229,-653,-16,-257,-1243,-911,-982,259,-1737,-1055,-1356,696,-428,492,-766,-217,878,2475,348,-122,-2098,-569,-325,-206,-1093,1479,-351,-580,-1201,203,-444,-548}
     },
     {
      318,
      561,
      {500,1283,-1478,103,357,-408,-2676,1033,339,-897,728,327,-117,-567,-1290,931,-368,343,-865,-1038,320,577,-1160,-1698,131,-1068,926,-1559,-71,-775,-2802,-2863}
     },
     {
      320,
      -1438,
      {421,-1281,-89,-1342,-372,743,239,-848,-455,-649,260,-500,1293,788,-1351,-505,-1662,2550,-1839,-499,77,-293,-1154,-578,-206,-486,194,53,452,624,-926,-711}
     },
     {
      322,
      -42,
      {-950,-401,-24,-959,-1005,-896,154,-1440,-690,-94,158,-318,-370,-267,-1293,88,-109,-598,133,-720,-666,-1168,724,1553,-678,-681,-9,24,129,-1711,2041,1135}
     },
     {
      324,
      -472,
      {-1587,-990,-702,236,-1213,1508,-295,-70,333,713,-930,-1125,-1952,-851,-205,525,-957,1379,-895,-1387,-574,705,-1344,-1112,130,702,164,-499,1523,1209,109,-50}
     },
     {
      326,
      -47,
      {48,290,-2302,-54,709,294,-1218,1935,296,-960,575,-565,-131,1496,-1511,1782,568,-411,-951,-182,-972,1815,-698,-793,-1356,-1050,1604,-681,233,-1698,59,602}
     }
   }

 };
#endif /* MLP_PRELOAD_MODE */  

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\spcnet.c ===
#include "common.h"
#include "runnet.h"
#include "resource.h"

static int			s_iSpcNetSize	=	0;
static LOCAL_NET	s_SpcNet;

// this array of scale factors were determined emperically by looking at the 
// ranges of the bear GAP features. The main objective is to scale all features
// to be roughly in the same range
static int	s_aScale[11]	=	{10, 15, 2, 50, 5, 15, 8, 15, 1, 1, 1};

BOOL LoadSpcNet(HINSTANCE hInst)
{
	void		*pRet = NULL;
	int			iResSize;
	
	// was it loaded before
	if (s_iSpcNetSize > 0)
	{
		return TRUE;
	}

	s_iSpcNetSize	=	0;

	pRet = loadNetFromResource(hInst, RESID_BEAR_SPCNET, &iResSize);

	if ( !pRet || !restoreLocalConnectNet(pRet, 0, &s_SpcNet))
	{
		return FALSE;
	}

	s_iSpcNetSize = getRunTimeNetMemoryRequirements(pRet);

	if (s_iSpcNetSize <= 0)
	{
		return FALSE;
	}

	return TRUE;
}

void UnLoadSpcNet()
{

}

int RunSpcNet (int *pFeat)
{
	RREAL		*pNetMem,
				*pNetOut;

	int			i, 
				iWinner, 
				iRetVal, 
				cOut;

	if (!s_iSpcNetSize)
	{			
		return 0;
	}

	pNetMem	=	(RREAL *) ExternAlloc (s_iSpcNetSize * sizeof(*pNetMem));
	if (!pNetMem)
	{
		return 0;
	}

	for (i = 0; i < 11; i++)
	{
		pNetMem[i]	=	128 * pFeat[i] * s_aScale[i];
	}

	pNetOut	=	runLocalConnectNet(&s_SpcNet, pNetMem, &iWinner, &cOut);

	// Prefix bug fix; added by JAD; Feb 18, 2002
	// if the returned buffer with the net outputs is null, declare a failure to find a word break
	if (pNetOut == NULL)
	{
		ExternFree (pNetMem);
		return 0;  // 0 means failure to find a word break
	}

	iRetVal	=	(65535 * pNetOut[1] / SOFT_MAX_UNITY);
	//iRetVal	=	(200 * pNetOut[1] / SOFT_MAX_UNITY) - 100;

	// free up the net memory
	ExternFree (pNetMem);

	return iRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\trd_img.cpp ===
// **************************************************************************
// *    TRD file as C file                                                  *
// **************************************************************************

#include "ams_mg.h"  

#ifdef FOR_FRENCH
 #include "trd_imgf.cpp"
#elif defined(FOR_GERMAN)
 #include "trd_imgg.cpp"
#else
 #include "trd_imge.cpp"
#endif


// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\stroka1.cpp ===
#include <common.h>
#include "ams_mg.h"
#include "stroka1.h"


#ifndef NULL
 #define NULL _NULL
#endif


#ifndef LSTRIP

#ifndef __JUST_FIRST_PART
/***************************************************************************/
_VOID glitch_to_super_min(p_EXTR line_min, _INT n_line_min,p_SHORT bord_d,
                     _INT max_height,p_SHORT x,p_SHORT y,_BOOL gl_up_left)
{
   _INT i;
   _LONG  P=55;//50;   //55;    //60;  //50
   _BOOL non_super(p_EXTR line_min, _INT i,p_SHORT x,p_SHORT y,p_SHORT bord_d);

   for (i=0; i<n_line_min; i++)
   {
    if (line_min[i].susp==GLITCH_UP)
      {
      if ((line_min[i].pspecl->attr==NORM
//#ifdef FOR_GERMAN
          || line_min[i].pspecl->attr==I_MIN
//#endif
          )&&
          (gl_up_left==_TRUE
           ||
           non_super(line_min,i,x,y,bord_d)==_FALSE &&
           100L*(bord_d[line_min[i].i]-line_min[i].y) >= P*max_height
          )
         )
         line_min[i].susp = SUPER_SCRIPT ;
      else
            line_min[i].susp = 0;
      }
    if (line_min[i].susp==DBL_GLITCH_UP
       && i<n_line_min-1
      )
      {
       if ((line_min[i].pspecl->attr==NORM
//#ifdef FOR_GERMAN
            || line_min[i].pspecl->attr==I_MIN
//#endif
           )&&
           (line_min[i+1].pspecl->attr==NORM
//#ifdef FOR_GERMAN
            || line_min[i+1].pspecl->attr==I_MIN
//#endif
           )&&
           (gl_up_left==_TRUE
            ||
            non_super(line_min,i,x,y,bord_d)==_FALSE &&
            non_super(line_min,i+1,x,y,bord_d)==_FALSE &&
            100L*(bord_d[line_min[i].i]-line_min[i].y) >= P*max_height &&
            100L*(bord_d[line_min[i+1].i]-line_min[i+1].y) >= P*max_height
           )
          )
         line_min[i].susp = line_min[i+1].susp = SUPER_SCRIPT ;
          else
             line_min[i].susp = line_min[i+1].susp = 0;
          i++;
      }
    if (line_min[i].susp==TRP_GLITCH_UP
       && i<n_line_min-2
      )
      {
       if ((line_min[i].pspecl->attr==NORM
//#ifdef FOR_GERMAN
            || line_min[i].pspecl->attr==I_MIN
//#endif
           )&&
           (line_min[i+1].pspecl->attr==NORM
//#ifdef FOR_GERMAN
            || line_min[i+1].pspecl->attr==I_MIN
//#endif
           )&&
           (line_min[i+2].pspecl->attr==NORM
//#ifdef FOR_GERMAN
            || line_min[i+2].pspecl->attr==I_MIN
//#endif
           )&&
           (gl_up_left==_TRUE
            ||
            non_super(line_min,i,x,y,bord_d)==_FALSE &&
            non_super(line_min,i+1,x,y,bord_d)==_FALSE &&
            non_super(line_min,i+2,x,y,bord_d)==_FALSE &&
            100L*(bord_d[line_min[i].i]-line_min[i].y) >= P*max_height &&
            100L*(bord_d[line_min[i+1].i]-line_min[i+1].y) >= P*max_height &&
            100L*(bord_d[line_min[i+2].i]-line_min[i+2].y) >= P*max_height
           )
          )
             line_min[i].susp = line_min[i+1].susp = line_min[i+2].susp =
         SUPER_SCRIPT ;
       else
             line_min[i].susp = line_min[i+1].susp = line_min[i+2].susp = 0;
          i+=2;
    }
   }
   return;
}

/***************************************************************************/
_BOOL non_super(p_EXTR line_min, _INT i,p_SHORT x,p_SHORT y,p_SHORT bord_d)
{
#ifndef FOR_GERMAN
  p_SPECL cur=line_min[i].pspecl, nxt=cur->next, prv=cur->prev;

   if (cur->code==RET_ON_LINE)
      return(_TRUE);
   if (i>3 && prv->mark==MAXW && nxt->mark==MAXW &&
       x[cur->iend]-x[cur->ibeg] >
        THREE(HWRMax(y[cur->ibeg],y[cur->iend])-y[cur->ipoint0]) &&
       y[nxt->ipoint0]>ONE_THIRD(line_min[i].y)+TWO_THIRD(bord_d[line_min[i].i]) &&
       y[prv->ipoint0]>ONE_THIRD(line_min[i].y)+TWO_THIRD(bord_d[line_min[i].i])
      )
      return(_TRUE);
#endif
/*
   wrk=cur->next;
  while (wrk!=_NULL && wrk->mark!=MINW)             //04_14
      wrk=wrk->next;
  if (wrk!=_NULL && wrk->code==SUPER_SCRIPT)
    return(_TRUE);
   wrk=cur->prev;
   while (wrk!=_NULL && wrk->mark!=MINW)
      wrk=wrk->prev;
  if (wrk!=_NULL && wrk->code==SUPER_SCRIPT)
    return(_TRUE);
*/
   return(_FALSE);
}

/***************************************************************************/

_BOOL sub_max_to_line(low_type _PTR D,p_EXTR line_max,p_INT pn_line_max,
                      p_SHORT bord_d,_INT max_dist)
{
   p_SPECL cur=D->specl;
   p_SHORT y=D->buffers[1].ptr,
        i_back=D->buffers[2].ptr;
  _INT dist;
   _BOOL ins=_FALSE;
   _LONG P=35; //40;

   while (cur!=_NULL)
   {
      if (cur->mark==MAXW && cur->code==SUB_SCRIPT)
      {
         dist=y[cur->ipoint0]-bord_d[i_back[cur->ipoint0]];
         if (100L*dist<P*max_dist)
         {
            ins=insert_line_extr(D,cur,line_max,pn_line_max);
            cur->code=RET_ON_LINE;
         }
      }
      cur=cur->next;
   }
#if PG_DEBUG
   if (ins==_TRUE)
      DBG_picture2(line_max,*pn_line_max,RET_ON_LINE);
#endif
  return(ins);
}

/***************************************************************************/
_VOID super_min_to_line(p_EXTR line_min, _INT n_line_min, p_SHORT bord_d,
            _INT max_line_height,_INT mid_line_height, p_INT pn_super)
{
   _INT i;
   for (i=0; i<n_line_min; i++)
   {
      if (line_min[i].susp==SUPER_SCRIPT &&
          bord_d[line_min[i].i] - line_min[i].y <=
          THREE_FOURTH(max_line_height)+ONE_FOURTH(mid_line_height)
         )
      {
         line_min[i].susp=RET_ON_LINE;
         (*pn_super)--;
      }
   }
   return;
}
/***************************************************************************/
_VOID spec_neibour_extr(p_EXTR extr,_INT n_extr,_UCHAR type,_INT LINE_POS)
{
   _INT i,OUTSIDE_LINE;

	ASSERT((type == MINW) || (type == MAXW));  // JPittman

   if (type ==MAXW) OUTSIDE_LINE = SUB_SCRIPT;
   if (type==MINW) OUTSIDE_LINE = SUPER_SCRIPT;
   for (i=1; i<n_extr; i++)
   {
      if (extr[i].susp==OUTSIDE_LINE && extr[i-1].susp==INSIDE_LINE)
      {
         if (LINE_POS==STR_TOO_NARROW)
            ret_to_line(extr,n_extr,i,i);
         else
            ret_to_line(extr,n_extr,i,i-1);
      }
      if (extr[i].susp==INSIDE_LINE && extr[i-1].susp==OUTSIDE_LINE)
      {
         if (LINE_POS==TOO_WIDE)
            ret_to_line(extr,n_extr,i,i);
         else
        ret_to_line(extr,n_extr,i,i-1);
    }
   }
  return;
}
/***************************************************************************/
_INT neibour_susp_extr(p_EXTR extr,_INT n_extr,_UCHAR type,p_SHORT bord_d,
                         _INT ft_height)
{
   _INT i, n_unsusp=0, mid_height=0, cur_height, prv_height;
   _INT OUTSIDE_LINE;
   _LONG sum_height=0L;
   EXTR cur_extr,prv_extr;

	ASSERT((type == MINW) || (type == MAXW));  // JPittman

   if (type==MAXW) OUTSIDE_LINE = SUB_SCRIPT;
   if (type==MINW) OUTSIDE_LINE = SUPER_SCRIPT;
   for (i=0; i<n_extr; i++)
      if (extr[i].susp!=OUTSIDE_LINE && extr[i].susp!=INSIDE_LINE) n_unsusp++;
   if (n_unsusp>1)
   {
      for (i=0; i<n_extr; i++)
      {
         if (extr[i].susp!=OUTSIDE_LINE && extr[i].susp!=INSIDE_LINE)
      {
            if (type==MAXW) cur_height=extr[i].y;
            if (type==MINW) cur_height=bord_d[extr[i].i]-extr[i].y;
        sum_height+=(_LONG)cur_height;
         }
      }
      mid_height = (_INT)(sum_height/n_unsusp);
   }
   if (n_unsusp<=1) return(UNSUCCESS);

   for (i=1; i<n_extr; i++)
   {
      if (extr[i].susp==OUTSIDE_LINE && extr[i-1].susp==INSIDE_LINE
          ||
          extr[i].susp==INSIDE_LINE && extr[i-1].susp==OUTSIDE_LINE
         )
      {
         cur_extr=extr[i];
         prv_extr=extr[i-1];
  /*
         if (mid_height==0 && n_extr>2)
      {
            for (j=0; j<n_extr; j++)
            {
               if (j==i-1 || j==i) continue;
          if (type==MAXW) cur_height=extr[j].y;
               if (type==MINW) cur_height=bord_d[extr[j].i]-extr[j].y;
               sum_height+=(_LONG)cur_height;
            }
            mid_height = sum_height/(n_extr-2);
         }
  */
         if (type==MAXW)
         {
            cur_height=cur_extr.y;
            prv_height=prv_extr.y;
         }
         if (type==MINW)
         {
            cur_height=bord_d[cur_extr.i]-cur_extr.y;
            prv_height=bord_d[prv_extr.i]-prv_extr.y;
            if (ft_height>0 && cur_extr.susp==OUTSIDE_LINE &&
           cur_height>=ft_height)
            { ret_to_line(extr,n_extr,i,i-1); continue; }
            if (ft_height>0 && prv_extr.susp==OUTSIDE_LINE &&
                prv_height>=ft_height)
            { ret_to_line(extr,n_extr,i,i); continue; }
      }
         if (HWRAbs(cur_height-mid_height) <
             HWRAbs(prv_height-mid_height)
            )
         ret_to_line(extr,n_extr,i,i);
         else
      ret_to_line(extr,n_extr,i,i-1);
      }
   }
   return(SUCCESS);
}
/***************************************************************************/
_VOID all_susp_extr(p_EXTR extr,_INT n_extr,_INT n_allextr,_UCHAR type,p_SHORT y,
          _INT base_ampl,_INT base_ampl_sure,_INT max_ampl,p_SHORT bord_d,
          _INT ft_height)
{
//  _UCHAR opp_type;
  _INT i,ind_wrk,ind_ret,OUTSIDE_LINE,ampl_l,ampl,ret_ampl;
   p_SPECL wrk;

  _LONG CONST_NARROW=
#ifdef FOR_GERMAN
                10;
#else
                8;
#endif

	ASSERT((type == MINW) || (type == MAXW));  // JPittman

   if (type==MINW) { OUTSIDE_LINE=SUPER_SCRIPT; }//sign=-1; opp_type=MAXW;}
   if (type==MAXW) { OUTSIDE_LINE=SUB_SCRIPT; }//sign=1; opp_type=MINW;}
   for (i=1,ampl=0; i<n_extr; i++)
   {
      if (extr[i].susp==OUTSIDE_LINE && extr[i-1].susp==INSIDE_LINE
          ||
          extr[i].susp==INSIDE_LINE && extr[i-1].susp==OUTSIDE_LINE
         )
      {
         if (extr[i].susp==INSIDE_LINE) { ind_wrk=i; ind_ret=i-1; }
      else { ind_wrk=i-1; ind_ret=i; }
      wrk=extr[ind_wrk].pspecl;
         if (type==MAXW && wrk->prev->mark==BEG
//             || type==MINW && wrk->next->mark==END
            )
         {
        ret_ampl=calc_ampl(extr[ind_ret],y,type);
        if (ret_ampl<THREE_HALF(base_ampl))
        {
            ret_to_line(extr,n_extr,i,ind_ret);
            continue;
         }

      }
         if (type==MAXW)
         {
            if (ampl!=0) ampl_l=ampl;
            else ampl_l=calc_ampl(extr[i-1],y,type);
            ampl=calc_ampl(extr[i],y,type);
         }
         if (type==MINW)
         {
        ampl_l=bord_d[extr[i-1].i]-extr[i-1].y;
        ampl=bord_d[extr[i].i]-extr[i].y;
        if (ft_height>0 && extr[i].susp==OUTSIDE_LINE &&
           ampl>=ft_height)
            { ret_to_line(extr,n_extr,i,i-1); continue; }
        if (ft_height>0 && extr[i-1].susp==OUTSIDE_LINE &&
           ampl_l>=ft_height)
            { ret_to_line(extr,n_extr,i,i); continue; }
      }
      if (CONST_NARROW*ampl_l<=max_ampl)
         {
            ret_to_line(extr,n_extr,i,i);
            continue;
         }
      if (CONST_NARROW*ampl<=max_ampl)
         {
            ret_to_line(extr,n_extr,i,i-1);
            continue;
         }
/*
        if (n_allextr ==2
             &&
             (base_ampl_sure<75 || type==MINW || extr[1].y-extr[0].y>0)
            )
         {
            if (sign*(extr[1].y-extr[0].y) > 0)
            {
               ret_to_line(extr,n_extr,1,0);
               continue;
            }
            else
            {
               ret_to_line(extr,n_extr,1,1);
               continue;
            }
         }
         if (n_extr==3 && n_allextr==3)
         {
            if (i==2 && sign*(extr[2].y-extr[1].y) > 0 &&
                extr[0].susp==INSIDE_LINE)
            {
               ret_to_line(extr,n_extr,2,1);
               continue;
            }
            if (i==1 && sign*(extr[1].y-extr[0].y) < 0 &&
                extr[2].susp==INSIDE_LINE)
            {
               ret_to_line(extr,n_extr,1,1);
               continue;
            }
         }
*/
#ifndef FOR_GERMAN
         if (HWRAbs(ampl-base_ampl) < HWRAbs(ampl_l-base_ampl))
#else
         if (base_ampl*base_ampl<ampl*ampl_l && ampl<ampl_l ||
             base_ampl*base_ampl>=ampl*ampl_l && ampl>=ampl_l
            )
#endif /* !FOR_GERMAN */
               ret_to_line(extr,n_extr,i,i);
         else
            ret_to_line(extr,n_extr,i,i-1);
      }

      else ampl=0;

   }
   return;
}

/**************************************************************************/

_INT calc_ampl(EXTR extr, p_SHORT y, _UCHAR type)
{
      _INT ampl, sign = (type==MINW)? -1 : 1,
           opp_type = (type==MINW) ? MAXW : MINW;
      p_SPECL prv=extr.pspecl->prev;
    p_SPECL nxt=extr.pspecl->next;
      _INT prv_ampl =
        (prv->mark==opp_type && (prv->attr==NORM /*|| prv->attr==NON_SUPER*/ ||
                                 prv->attr==I_MIN)) ?
                        sign*(extr.y-y[prv->ipoint0]) : 0;
      _INT nxt_ampl =
        (nxt->mark==opp_type && (nxt->attr==NORM /*|| nxt->attr==NON_SUPER*/ ||
                                 nxt->attr==I_MIN)) ?
                        sign*(extr.y-y[nxt->ipoint0]) : 0;
      if (prv_ampl!=0 && nxt_ampl!=0)
      {
        if (nxt->next->mark!=END && prv->prev->mark!=BEG)
          ampl=MEAN_OF(prv_ampl,nxt_ampl);
        else
          ampl=HWRMax(prv_ampl,nxt_ampl);
      }
      else
            ampl=HWRMax(prv_ampl,nxt_ampl);
         if (ampl==0)
         {
            prv_ampl=(prv->mark==opp_type) ? sign*(extr.y-y[prv->ipoint0]) : 0;
        nxt_ampl=(nxt->mark==opp_type) ? sign*(extr.y-y[nxt->ipoint0]) : 0;
            ampl=THREE_FOURTH(HWRMax(prv_ampl,nxt_ampl));
      }
      return(ampl);
}

/***************************************************************************/
_VOID ret_to_line(p_EXTR extr,_INT n_extr,_INT i,_INT ind)
{
   if (ind==i)
   {
      extr[i].susp=(_SHORT)(-extr[i].susp);
    if (i+1<n_extr && extr[i+1].susp==-extr[i].susp)
      {
         extr[i+1].susp=extr[i].susp;
         if (i+2<n_extr && extr[i+2].susp==-extr[i].susp)
            extr[i+2].susp=extr[i].susp;
      }
   }
   if (ind==i-1)
   {
    extr[i-1].susp=(_SHORT)(-extr[i-1].susp);
      if (i-2>=0 && extr[i-2].susp==-extr[i-1].susp)
      {
         extr[i-2].susp=extr[i-1].susp;
         if (i-3>=0 && extr[i-3].susp==-extr[i-1].susp)
            extr[i-3].susp=extr[i-1].susp;
      }
   }
   return;
}
/***************************************************************************/

_BOOL delete_line_extr(p_EXTR line_extr, p_INT pn_extr, _INT MARK)
{
   _INT i,j,n_extr=*pn_extr;
   for (i=0; i<n_extr; i++)
   {
       if (line_extr[i].susp==MARK)
       {
          for (j=i; j<n_extr; j++)
             line_extr[j]=line_extr[j+1];
       n_extr--;
          i--;
       }
   }
   *pn_extr=n_extr;
   return(_TRUE);
}
/***************************************************************************/
_BOOL insert_line_extr(low_type _PTR D, p_SPECL cur, p_EXTR extr,
                                                           p_INT pn_extr)
{
   p_SHORT x=D->buffers[0].ptr,
           y=D->buffers[1].ptr,
           i_back=D->buffers[2].ptr;
  _INT i=0, j, i_extr, n_extr=*pn_extr, shift;
  p_SPECL wrk;

   wrk=cur->next;
   while (wrk->mark!=END)
      wrk=wrk->next;
  shift=wrk->attr;

   while (i<n_extr && extr[i].x < x[cur->ipoint0]) i++;
   for (j=n_extr-1; j>=i; j--)
      extr[j+1]=extr[j];
   i_extr=cur->ipoint0;
   extr[i].x=x[i_extr];
   extr[i].y=y[i_extr];
   extr[i].i=i_back[i_extr];
   extr[i].susp=RET_ON_LINE;
  extr[i].shift=(_SHORT)shift;
   extr[i].pspecl=cur;
   (*pn_extr)++;
   return(_TRUE);
}
/***************************************************************************/

_INT calc_average(p_SHORT array, _INT N)
{
   _INT i, aver;
   _LONG sum=0;
   if (N<=0) return(UNSUCCESS);
  for (i=0; i<N; i++)
      sum+=array[i];
   aver=(_INT)(sum/N);
   return(aver);
}
/***************************************************************************/
_INT mid_other(p_EXTR extr,_INT n_extr,_INT i)
{
   _INT j;
   _LONG sum_other=0L;
   if (n_extr<=2) return (UNSUCCESS);
   for (j=0; j<n_extr; j++)
   {
      if (j==i-1 || j==i) continue;
      sum_other+=extr[j].y;
   }
  return (sum_other/(n_extr-2));
}

/***************************************************************************/

_SHORT point_of_smooth_bord(_INT cur_point,_INT n_extr,p_EXTR extr,
                            low_type _PTR D,_INT should)
{
    _INT  jl,jr,j,k,i,max_ind,mid_y,dx;
    _INT  x_left  = D->x[cur_point] - should,
            x_right = D->x[cur_point] + should;
    _INT  wextr_x[NUM_EXTR_IN_SHOULD], wextr_y[NUM_EXTR_IN_SHOULD];
    _LONG   dy, integ;

    j=0;
    while (j<n_extr && extr[j].x <= x_left)   j++;
    jl=j-1;
    while (j<n_extr && extr[j].x < x_right)   j++;
    jr=j;
   max_ind=jr-jl;

   if (max_ind+1 > NUM_EXTR_IN_SHOULD)
   {
     max_ind=NUM_EXTR_IN_SHOULD-1;
     DBG_err_msg("Stroka: Too many extrs in should");
   }

   wextr_x[0]=HWRMax(D->box.left, x_left);

    if (jl==-1)
       wextr_y[0]=extr[0].y;
    if (jl==n_extr-1)
       wextr_y[0]=extr[n_extr-1].y;
     if (jl!=-1 && jl!=n_extr-1)
     {
        dy=(_LONG)(extr[jl+1].y-extr[jl].y);
      dx=HWRMax(1,(extr[jl+1].x-extr[jl].x));
        wextr_y[0] =
            extr[jl].y + (_SHORT) (dy * (x_left-extr[jl].x) / dx);
     }

    for (k=1; k<max_ind; k++)
    {
       wextr_x[k]=extr[jl+k].x;
     wextr_y[k]=extr[jl+k].y;
    }

   wextr_x[max_ind]=HWRMin(D->box.right,x_right);

    if (jr==0)
       wextr_y[max_ind]=extr[0].y;
    if (jr==n_extr)
       wextr_y[max_ind]=extr[n_extr-1].y;
    if (jr!=0 && jr!=n_extr)
    {
       dy=(_LONG)(extr[jr].y-extr[jr-1].y);
     dx=HWRMax(1,(extr[jr].x-extr[jr-1].x));
       wextr_y[max_ind] =
           extr[jr-1].y + (_SHORT) (dy * (x_right-extr[jr-1].x) / dx);
    }


    for (i=0; i<max_ind; i++)
    {
       k=i;
       while (k+1<=max_ind && wextr_x[k+1]==wextr_x[i]) k++;
     if (k>i)
       {
       for (j=0, mid_y=0; j<=k-i; j++)
             mid_y+=wextr_y[i+j];
          mid_y/=k-i+1;
          wextr_y[i]=wextr_y[k]=mid_y;
          i=k;
       }
    }




    integ=0;

    if (wextr_x[max_ind]-wextr_x[0] == 0)
        integ=wextr_y[0];
    else
    {
       for (k=1; k<=max_ind; k++)
          integ += (_LONG)(wextr_y[k]+wextr_y[k-1])*
                      (_LONG)(wextr_x[k]-wextr_x[k-1]);
     integ = ONE_HALF(integ);

    }


   return( (_SHORT)( integ/HWRMax(1,(wextr_x[max_ind]-wextr_x[0])) ) );

}
/***************************************************************************/

_VOID smooth_d_bord(p_EXTR line_max,_INT n_line_max,low_type _PTR D,
                    _INT should,p_SHORT bord_d)
{
   _INT i;
//   _INT prev_mid =(D->yu_beg+D->yu_end+D->yd_beg+D->yd_end)/4;
   if (n_line_max>0)
      for (i=0; i<D->ii; i++)
      {
         if (D->y[i] == BREAK)
      {  bord_d[i]=0;  continue;  }
            bord_d[i]=point_of_smooth_bord(i,n_line_max,line_max,D,should);
      }
   else
    for (i=0; i<D->ii; i++)
      {
         if (D->y[i] == BREAK)
         {   bord_d[i]=0;  continue;  }
/*
         if (prev_mid!=0 && D->box.top<prev_mid && D->box.bottom>prev_mid)
            bord_d[i]=D->yd_beg;
         else
*/
#ifdef USE_WORDSPLIT_PARMS
            if (/*D->rc->stroka.size_sure_in >=50 && */D->rc->stroka.pos_sure_in >=50)
               bord_d[i]=D->rc->stroka.dn_pos_in;
            else
#endif /* USE_WORDSPLIT_PARMS */
            bord_d[i]=D->box.bottom;
      }
   return;
}

/***************************************************************************/

_VOID smooth_u_bord(p_EXTR line_min,_INT n_line_min,low_type _PTR D,
                    _INT should,p_SHORT bord_u,p_SHORT bord_d)
{
   _INT i, min_bord_d;
//   _INT prev_mid =(D->yu_beg+D->yu_end+D->yd_beg+D->yd_end)/4;
   if (n_line_min>1)
      for (i=0; i<D->ii; i++)
      {
         if (D->y[i] == BREAK)
      { bord_u[i]=0;  continue;  }
        bord_u[i]=point_of_smooth_bord(i,n_line_min,line_min,D,should);
    }
   if (n_line_min==1)
      for (i=0; i<D->ii; i++)
      {
         if (D->y[i] == BREAK)
            bord_u[i]=0;
         else
        bord_u[i]=(_SHORT)(bord_d[i]-(bord_d[line_min[0].i]-line_min[0].y));
      }
   if (n_line_min==0)
   {
      if (D->rc->lmod_border_used==LMOD_BORDER_TEXT)
      {
         for (i=0,min_bord_d=ALEF; i<D->ii; i++)
            if (D->y[i] != BREAK && bord_d[i] < min_bord_d)
               min_bord_d = bord_d[i];

         for (i=0; i<D->ii; i++)
         {
            if (D->y[i] == BREAK)
                      {  bord_u[i]=0;  continue;  }
/*
            if (prev_mid!=0 && D->box.top<prev_mid && D->box.bottom>prev_mid)
               bord_u[i]=D->yu_beg;
            else
*/
#ifdef USE_WORDSPLIT_PARMS
              if (D->rc->stroka.size_sure_in >=50 && D->rc->stroka.pos_sure_in>=50)
                 bord_u[i]=
                 (_SHORT)(D->rc->stroka.dn_pos_in - D->rc->stroka.size_in);
              else
#endif /* USE_WORDSPLIT_PARMS */
          bord_u[i]=(_SHORT)(TWO_THIRD(D->box.top)+ONE_THIRD(min_bord_d));
         }
      }
      else
      {
         for (i=0; i<D->ii; i++)
         {
            if (D->y[i] == BREAK)
               bord_u[i]=0;
            else
               bord_u[i]=D->box.top;
         }
      }
   }
   return;
}

/***************************************************************************/

_INT sign(_INT a, _INT b)
{
  _INT ret=0;

  if (a>b) ret=1;
  if (a<b) ret=-1;
  return(ret);
}
/***************************************************************************/
#pragma optimize( "g", off )
_INT fill_i_point(p_SHORT i_point, low_type _PTR D)
{
      /*   The "i_point"                                        */
      /*  array must always be filled with legal values for     */
      /*  Pashintsev's function "FillRCNB" at the very end of   */
      /*  transform (see comments at the call to it).           */
	_INT i,j,k,n_x=0,last_x=-1;
                                 /* i_point[i] is number of one of those */
                                 /* points of trajectory, which have i-th */
	for (i=0; i<D->ii; i++)          /* from left value of x-coordinate;   */
	{
		if (D->y[i]==BREAK) continue;
		
		if (D->x[i]>last_x)
		{
			i_point[n_x++]=(_SHORT)i;
			last_x=D->x[i];
			continue;
		}

		for (j=n_x-1; j>=0; j--)
		{
			if (D->x[i]==D->x[i_point[j]]) 
				break;
         
			if (D->x[i]>D->x[i_point[j]])
			{
				for (k=n_x++; k>j+1; k--) 
					i_point[k]=i_point[k-1];

				i_point[j+1]=(_SHORT)i;
            
				break;
			}
		}
      
		if (D->x[i]<D->x[i_point[0]])
		{
			for (k=n_x++; k>0; k--) 
				i_point[k]=i_point[k-1];

			i_point[0]=(_SHORT)i;
		}
	}
   
	return(n_x);
}
#pragma optimize( "", on )

/* ************************************************************************* */
_BOOL num_bord_correction(p_EXTR extr,p_INT pn_extr,_INT n_allextr,
                          _UCHAR type,_INT med_ampl,p_SHORT bord_d,p_SHORT y)
{
   _INT i,j;
   _UCHAR OUTSIDE_LINE,opp_type;
   _BOOL del=_FALSE;
   p_SPECL cur;

	ASSERT((type == MINW) || (type == MAXW));  // JPittman

   if (type==MAXW)
   {
      OUTSIDE_LINE=SUB_SCRIPT;
      opp_type=MINW;
  }
   if (type==MINW)
   {
      OUTSIDE_LINE=SUPER_SCRIPT;
      opp_type=MAXW;
  }
   for (i=0; i<*pn_extr; i++)
      if (extr[i].pspecl->attr==SLASH)
         extr[i].susp=OUTSIDE_LINE;
      else
         extr[i].susp=0;
  delete_line_extr(extr,pn_extr,OUTSIDE_LINE);

  find_gaps_in_line(extr,*pn_extr,n_allextr,med_ampl,type,0,ALEF,bord_d,y,
                    _TRUE,_FALSE);
  find_glitches_in_line(extr,*pn_extr,med_ampl,type,0,ALEF,bord_d,0,0,1,
                                                              _TRUE,_FALSE);

   for (i=0; i<*pn_extr; i++)
   {
      if ((type==MAXW && extr[i].susp==GLITCH_DOWN ||
           type==MINW && extr[i].susp==GLITCH_UP
          ) &&
          extr[i].pspecl->attr==STRT
      )
      {
         extr[i].susp=OUTSIDE_LINE;
         cur=extr[i].pspecl;
      if (cur->prev->mark==opp_type) cur->prev->attr=SLASH;
         if (cur->next->mark==opp_type) cur->next->attr=SLASH;
      }
      if ((type==MAXW && extr[i].susp==DBL_GLITCH_DOWN ||
        type==MINW && extr[i].susp==DBL_GLITCH_UP)
       && i<*pn_extr-1
         )
    {
      if (extr[i].pspecl->attr==STRT && extr[i+1].pspecl->attr==STRT)
         for (j=i; j<=i+1;j++)
         {
            extr[j].susp=OUTSIDE_LINE;
            cur=extr[j].pspecl;
            if (cur->prev->mark==opp_type) cur->prev->attr=SLASH;
            if (cur->next->mark==opp_type) cur->next->attr=SLASH;
         }
         i++;
      }
  }
   del=delete_line_extr(extr,pn_extr,OUTSIDE_LINE);

  for (i=0; i<*pn_extr; i++)
      extr[i].susp=0;
  find_gaps_in_line(extr,*pn_extr,n_allextr,med_ampl,type,0,ALEF,bord_d,y,
                    _FALSE,_FALSE);
  find_glitches_in_line(extr,*pn_extr,med_ampl,type,0,ALEF,bord_d,0,0,1,
                                                              _FALSE,_FALSE);
   for (i=0; i<*pn_extr; i++)
   {
    if (type==MAXW && (extr[i].susp==GLITCH_UP) //|| extr[i].susp==DBL_GLITCH_UP)
       ||
       type==MINW && (extr[i].susp==GLITCH_DOWN) //|| extr[i].susp==DBL_GLITCH_DOWN)
         )
         extr[i].susp=INSIDE_LINE;
   }
   delete_line_extr(extr,pn_extr,INSIDE_LINE);
   return(del);
}


/* ************************************************************************* */

_BOOL bord_correction(low_type _PTR D,p_EXTR extr,p_INT pn_extr,_INT n_allextr,
               _UCHAR type,_INT step,_INT med_ampl,_INT mid_ampl,
               _INT max_ampl,_INT x_left,_INT x_right,_INT LINE_POS,_UCHAR pass,
               p_SHORT bord_d,_INT max_height,_INT ft_height,
               _BOOL gl_up_left,_BOOL gl_down_left
#if PG_DEBUG
           ,p_UCHAR pn_call1
#endif
                     )
{
   _BOOL del=_FALSE;
   p_SHORT x=D->buffers[0].ptr,
        y=D->buffers[1].ptr;
  _INT i,n_out,n_inside,max_line_height,mid_line_height,base_ampl;
   _INT n_extr=*pn_extr,SHIFT;
   _INT thresh=D->rc->stroka.extr_depth;
   _INT base_ampl_sure=D->rc->stroka.size_sure_in;
   _UCHAR MARK;

	ASSERT((type == MINW) || (type == MAXW));  // JPittman

   if (type==MAXW)  { MARK=SUB_SCRIPT; SHIFT=1; }
   if (type==MINW)  { MARK=SUPER_SCRIPT; SHIFT=2; }
   for (i=0; i<n_extr; i++)
      extr[i].susp=0;
   if (n_extr<2) return(_FALSE);
  find_gaps_in_line(extr,n_extr,n_allextr,med_ampl,type,x_left,x_right,
                    bord_d,y,_FALSE,_FALSE);
  find_glitches_in_line(extr,n_extr,med_ampl,type,x_left,x_right,
                                            bord_d,x,y,SHIFT,_FALSE,_FALSE);
   if (type==MAXW)
      glitch_to_sub_max(D,extr,n_extr,mid_ampl,gl_down_left);
   if (type==MINW)
   {
      glitch_to_super_min(extr,n_extr,bord_d,max_height,x,y,gl_up_left);
      for (i=0,n_out=0,max_line_height=0,mid_line_height=0; i<n_extr; i++)
         if (extr[i].susp==MARK)
            n_out++;
         else
      {
        max_line_height=
                     HWRMax(max_line_height,bord_d[extr[i].i]-extr[i].y);
        mid_line_height+=bord_d[extr[i].i]-extr[i].y;
         }
      if (n_out<n_extr) mid_line_height/=(n_extr-n_out);
   #if PG_DEBUG
      if (n_out>0)
         DBG_picture2(extr,n_extr,MARK);
   #endif
      if (n_out>0)
    {
         super_min_to_line(extr,n_extr,bord_d,max_line_height,mid_line_height,
                           &n_out);
   #if PG_DEBUG
            DBG_picture2(extr,n_extr,RET_ON_LINE);
   #endif
      }
   }
   glitch_to_inside(extr,n_extr,type,y,mid_ampl,x_left,x_right);
   if (pass==1 && LINE_POS!=0)
      spec_neibour_extr(extr,n_extr,type,LINE_POS);
  else
    if (neibour_susp_extr(extr,n_extr,type,bord_d,ft_height-thresh)==UNSUCCESS)
      {
//         if (n_allextr<=4)
            base_ampl=step;
//         else           base_ampl=med_ampl;
         all_susp_extr(extr,n_extr,n_allextr,type,y,base_ampl,base_ampl_sure,
                       max_ampl,bord_d,ft_height-thresh);
      }
   for (i=0,n_out=0; i<n_extr; i++)
    if (extr[i].susp==MARK)
      n_out++;
#if PG_DEBUG
      DBG_picture2(extr,n_extr,MARK);
#endif
   if (n_out>0 /*&& (type==MINW || n_out<=ONE_HALF(n_extr))*/)
   {
      for (i=0; i<n_extr; i++)
      {
         if (extr[i].susp==MARK)
            extr[i].pspecl->code=MARK;
         else
        extr[i].susp=0;
      }
      del=delete_line_extr(extr, pn_extr, MARK);
      n_extr=*pn_extr;

    find_gaps_in_line(extr,n_extr,n_allextr,med_ampl,type,x_left,x_right,
                      bord_d,y,_FALSE,_FALSE);
    find_glitches_in_line(extr,n_extr,med_ampl,type,x_left,x_right,
                                            bord_d,x,y,SHIFT,_FALSE,_FALSE);
      if (type==MAXW)
      glitch_to_sub_max(D,extr,n_extr,mid_ampl,gl_down_left);
      if (type==MINW)
    {
         glitch_to_super_min(extr,n_extr,bord_d,max_height,x,y,gl_up_left);
         for (i=0,n_out=0,max_line_height=0,mid_line_height=0; i<n_extr; i++)
            if (extr[i].susp==MARK)
               n_out++;
            else
            {
               max_line_height=
                HWRMax(max_line_height,bord_d[extr[i].i]-extr[i].y);
               mid_line_height+=bord_d[extr[i].i]-extr[i].y;
            }
      if (n_out<n_extr) mid_line_height/=(n_extr-n_out);
         if (n_out>0)
            super_min_to_line(extr,n_extr,bord_d,max_line_height,
                              mid_line_height,&n_out);
      }
      glitch_to_inside(extr,n_extr,type,y,mid_ampl,x_left,x_right);
      if (pass==1 && LINE_POS!=0)
         spec_neibour_extr(extr,n_extr,type,LINE_POS);
    else
         if (neibour_susp_extr(extr,n_extr,type,bord_d,ft_height-thresh)==UNSUCCESS)
         {
//            if (n_allextr<=4)
               base_ampl=step;
//            else           base_ampl=med_ampl;
            all_susp_extr(extr,n_extr,n_allextr,type,y,base_ampl,base_ampl_sure,
                          max_ampl,bord_d,ft_height-thresh);
   }
   }
   for (i=0,n_inside=0; i<n_extr; i++)
      if (extr[i].susp==INSIDE_LINE)
         n_inside++;
#if PG_DEBUG
  if (n_inside>0)
      DBG_picture2(extr,n_extr,INSIDE_LINE);
#endif

   if (n_inside>0 /*&& n_inside<=ONE_HALF(n_extr)*/)
   {
      for (i=0; i<n_extr; i++)
    {
         if (extr[i].susp==INSIDE_LINE)
            extr[i].pspecl->code=INSIDE_LINE;
         else
        extr[i].susp=0;
      }
      del=delete_line_extr(extr, pn_extr, INSIDE_LINE);
      n_extr=*pn_extr;
   }
#if PG_DEBUG
   if (del==_TRUE)
      DBG_picture1(extr,n_extr,D->box,0,0,pn_call1);
#endif
   return(del);
}

/***************************************************************************/

_VOID del_tail_min(p_EXTR line_min,p_INT pn_line_min,p_SHORT y,
                   p_SHORT bord_d,_UCHAR pass)
{
   p_SPECL cur,nxt,prv;
  _INT i,n_line_min=*pn_line_min;
  _LONG Q = 2,
        P = (pass==0) ? 5 : 10;

   for (i=0; i<n_line_min; i++)
   {
      cur=line_min[i].pspecl;
      nxt=cur->next;
      prv=cur->prev;

      if ((prv->mark==BEG || prv->mark==MAXW && P*(y[prv->ipoint0]-line_min[i].y)<
           Q*(bord_d[line_min[i].i]-line_min[i].y))
          &&
          (nxt->mark==END || nxt->mark==MAXW && P*(y[nxt->ipoint0]-line_min[i].y)<
           Q*(bord_d[line_min[i].i]-line_min[i].y))
         )
      {
         line_min[i].susp=TAIL_MIN;
         cur->code=TAIL_MIN;
      }
   }
   delete_line_extr(line_min,pn_line_min,TAIL_MIN);
  return;
}

/***************************************************************************/

_INT line_pos_mist(low_type _PTR D,_INT med_u_bord,_INT med_d_bord,
                     _INT med_height,_INT n_line_min,_INT n_line_max,
                     p_EXTR line_max,p_INT pUP_LINE_POS,p_INT pDOWN_LINE_POS,
                     p_SHORT bord_u,p_SHORT bord_d,_UCHAR pass
                    )
{
//  _BOOL  prv_min_inside; //prv_max_inside;
  _UCHAR prv_min_inside, prv_max_inside;
   _INT all_min_inside,all_max_inside,n_sub=0,n_inmin=0,n_inmax=0,n_super=0,
          min_y,max_y,n_str=0,n_allmin=0,n_allmax=0;
   p_SHORT x=D->buffers[0].ptr,
        y=D->buffers[1].ptr,
        i_back=D->buffers[2].ptr;
  _INT thresh=D->rc->stroka.extr_depth,
         dn_pos=D->rc->stroka.dn_pos_in,
         dn_pos_sure=D->rc->stroka.pos_sure_in,
         size=D->rc->stroka.size_in,
         size_sure=D->rc->stroka.size_sure_in;
  _INT ibeg_str,iend_str, i_stroke=0, cur_y,cur_i, min_to_ret, max_to_ret;
  _INT  shtraf=0;
  _INT i, max_height;
  _RECT stroke_box;
  _LONG P_MIN=4, Q_MIN=5,
#ifdef FOR_GERMAN
      P_MAX=4, Q_MAX=5, CONST_NARROW=10, CONST_INSIDE=3;
#else
      P_MAX=3, Q_MAX=4,  CONST_NARROW=8, CONST_INSIDE=2;
#endif
   p_SPECL cur=D->specl,wrk;
   _BOOL apostroph=_FALSE;

   // Init vars
	all_min_inside = all_max_inside=0;
	min_y=ALEF;
	max_y=0;
	prv_min_inside=0;
	prv_max_inside=0;

	if (cur)
		ibeg_str=cur->ibeg;

   for (i=0, max_height=0; i<D->ii; i++)
   {
       if (bord_d[i]-D->y[i] > max_height)
          max_height=bord_d[i]-D->y[i];
       if (D->y[i]-bord_u[i] > max_height)
          max_height=D->y[i]-bord_u[i];
   }

   if (CONST_NARROW*med_height<=max_height) shtraf+=5;

   while (cur!=_NULL)
   {
      if (cur->mark==BEG)
      {
         i_stroke++;
         ibeg_str=cur->ibeg;
         all_min_inside=all_max_inside=0;
         min_y=ALEF;
         max_y=0;
         n_str++;
         prv_min_inside=0;
         prv_max_inside=0;
      }
     if (cur->mark==MINW)
     {
        n_allmin++;
        cur_y=y[cur->ipoint0];
        cur_i=i_back[cur->ipoint0];
        if (cur->attr==NORM || cur->attr==I_MIN)
          min_y=HWRMin(min_y,cur_y);
        if (cur->code==RET_ON_LINE) cur->code=ON_LINE;
        if (cur->code==NOT_ON_LINE && cur_y > bord_u[cur_i])
           cur->code=INSIDE_LINE;
        if (cur->code==NOT_ON_LINE && cur_y < bord_u[cur_i])
           cur->code=SUPER_SCRIPT;
        if (cur->code==SUPER_SCRIPT || cur->code==INSIDE_LINE ||
            cur->attr==T_MIN)
        {
          if (cur_y < bord_u[cur_i])
            n_super++;
          if (cur_y > bord_u[cur_i])
            n_inmin++;
        }
        if (cur->code==INSIDE_LINE)
        {
           if (cur_y<bord_d[cur_i])
           {
             if (prv_min_inside>0 &&
                extrs_open(D,cur,MINW,2)==_TRUE)
             {
               cur->code=RET_ON_LINE;
               wrk=cur->prev;
               while (wrk->mark!=BEG &&
                    (wrk->mark!=MINW || wrk->code==0)
                   )   wrk=wrk->prev;
               wrk->code=RET_ON_LINE;
               shtraf+=1;
               cur=cur->next;
               continue;
             }
             prv_min_inside++;
           }
           if (all_min_inside>=0)
           {
                 all_min_inside++;
           }
        }
        if (cur->code==ON_LINE || cur->code==SUPER_SCRIPT ||
             cur->code==RET_ON_LINE ||
             cur->code==0 && cur_y<=med_u_bord
            )
        {
              prv_min_inside=0;
              all_min_inside=-1;
        }

        if (D->rc->low_mode & LMOD_SMALL_CAPS && cur->code==SUPER_SCRIPT &&
            i_stroke >2
           )
        {
           wrk=cur;
           while (wrk->mark!=END)   wrk=wrk->next;
           iend_str=wrk->iend;
           GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);
           if (stroke_box.right<D->box.right-thresh)
           {
              shtraf+=1;
              cur->code=RET_ON_LINE;
           }
        }

        if (cur->code==ON_LINE || cur->code==RET_ON_LINE)
        {
          if (cur_y > bord_d[cur_i])
          {
             cur->code=NOT_ON_LINE;
             shtraf+=4;
             cur=cur->next;
             continue;
          }
/*
          if ( CONST_NARROW*(bord_d[cur_i]-cur_y) < max_height )
          {
             cur->code=NOT_ON_LINE;
             shtraf+=1;
             cur=cur->next;
             continue;
          }
*/
          if ( CONST_NARROW*(bord_d[cur_i]-cur_y) < max_height ||
               CONST_INSIDE*(bord_d[cur_i]-cur_y) < med_height
                 && cur->attr!=I_MIN)
          {
             _INT dyl = 0;
             _INT dyr = 0;

             wrk=cur->prev;
             while(wrk!=NULL)
             {
                if (wrk->mark==MINW && wrk->code==ON_LINE)
                {
                   dyl=cur_y-y[wrk->ipoint0];
                   break;
                }
                wrk=wrk->prev;
             }

             wrk=cur->next;
             while(wrk!=NULL)
             {
                if (wrk->mark==MINW && wrk->code==ON_LINE)
                {
                   dyr=cur_y-y[wrk->ipoint0];
                   break;
                }
                wrk=wrk->next;
             }

             if (100L*dyl>=10L*med_height || 100L*dyr>=10L*med_height)
             {
               cur->code=NOT_ON_LINE;
               shtraf+=1;
               cur=cur->next;
               continue;
             }
          }
        }
    }

    if (cur->mark==MAXW)
    {
      n_allmax++;
      cur_y=y[cur->ipoint0];
      cur_i=i_back[cur->ipoint0];
      if (cur->attr==NORM)
        max_y=HWRMax(max_y,cur_y);
      if (cur->code==RET_ON_LINE) cur->code=ON_LINE;
      if (cur->code==NOT_ON_LINE && cur_y < bord_d[cur_i])
         cur->code=INSIDE_LINE;
      if (cur->code==NOT_ON_LINE && cur_y > bord_d[cur_i])
         cur->code=SUB_SCRIPT;
      if (cur->code==SUB_SCRIPT || cur->code==INSIDE_LINE)
          {
        if (cur_y > bord_d[cur_i])
          n_sub++;
        if (cur_y < bord_d[cur_i])
          n_inmax++;
      }
      if (cur->code==INSIDE_LINE)
      {

        if (cur_y>bord_u[cur_i])
        {
          if (prv_max_inside>1 &&
             extrs_open(D,cur,MAXW,2)==_TRUE)
          {
             cur->code=RET_ON_LINE;
             wrk=cur->prev;
             while (wrk->mark!=BEG &&
                  (wrk->mark!=MAXW || wrk->code==0)
                 )   wrk=wrk->prev;
             wrk->code=RET_ON_LINE;
             shtraf++;
             if (prv_max_inside==2)  shtraf++;
             cur=cur->next;
             continue;
          }
          prv_max_inside++;
        }

        if (all_max_inside>=0)
                all_max_inside++;
      }
      if (cur->code==ON_LINE || cur->code==SUB_SCRIPT ||
          cur->code==RET_ON_LINE ||
          cur->code==0 && cur_y>=med_d_bord
         )
      {
             prv_max_inside=0;
             all_max_inside=-1;
      }

      if (cur->code==ON_LINE || cur->code==RET_ON_LINE)
      {
        if (cur_y < bord_u[cur_i])
        {
             cur->code=NOT_ON_LINE;
             shtraf+=4;
             cur=cur->next;
             continue;
        }
/*
        if ( CONST_NARROW*(cur_y-bord_u[cur_i]) < max_height )
        {
             cur->code=NOT_ON_LINE;
             shtraf+=1;
             cur=cur->next;
             continue;
        }
*/
        if ( CONST_NARROW*(cur_y-bord_u[cur_i]) < max_height ||
             CONST_INSIDE*(cur_y-bord_u[cur_i]) < med_height
           )
        {
           _INT dyl = 0;
           _INT dyr = 0;

           wrk=cur->prev;
           while(wrk!=NULL)
           {
              if (wrk->mark==MAXW && wrk->code==ON_LINE)
              {
                 dyl=y[wrk->ipoint0]-cur_y;
                 break;
              }
              wrk=wrk->prev;
           }

           wrk=cur->next;
           while(wrk!=NULL)
           {
              if (wrk->mark==MAXW && wrk->code==ON_LINE)
              {
                 dyr=y[wrk->ipoint0]-cur_y;
                 break;
              }
              wrk=wrk->next;
           }

           if (100L*dyl>=10L*med_height || 100L*dyr>=10L*med_height)
           {
             cur->code=NOT_ON_LINE;
             shtraf+=1;
             cur=cur->next;
             continue;
           }
        }
      }
    }

    if (cur->mark==END && cur->prev->mark!=BEG &&
       (all_min_inside>0 || all_max_inside>0)
      )

     {
//         shtraf+=1;
         iend_str=cur->iend;
         GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);
         if (stroke_box.right>D->box.right-thresh &&
             stroke_box.bottom-stroke_box.top<ONE_HALF(med_height) &&
             stroke_box.right-stroke_box.left<
             THREE_HALF(stroke_box.bottom-stroke_box.top)
            )
         {   cur=cur->next; continue;   }

         if (straight_stroke(ibeg_str,iend_str,x,y,5)==_TRUE
             || curve_com_or_brkt(D,cur,ibeg_str,iend_str,5,
                                            LMOD_BORDER_TEXT)!=0
            )
         {
            if (all_max_inside>0 && stroke_box.right-stroke_box.left<=
                stroke_box.bottom-stroke_box.top && cur->prev->mark==MAXW
               )
            {
               cur_y=y[cur->prev->ipoint0];
               cur_i=i_back[cur->prev->ipoint0];
               if (bord_d[cur_i]-cur_y>ONE_FOURTH(med_height))
                  apostroph=_TRUE;
            }
            cur=cur->next;
            continue;
         }

         wrk=cur->prev;
         min_to_ret=max_to_ret=0;
         while (wrk->mark!=BEG)
         {
            if (all_min_inside>0 && wrk->mark==MINW &&
           y[wrk->ipoint0]==min_y &&
                (all_min_inside>2 ||
                 pass>0 && max_y-min_y>ONE_FOURTH(med_d_bord-med_u_bord) ||
                 min_y<P_MIN*med_d_bord/Q_MIN + med_u_bord/Q_MIN
                )
               )
            {
               wrk->code=RET_ON_LINE;
               min_to_ret+=1;
            }
        if (all_max_inside>0 && wrk->mark==MAXW && y[wrk->ipoint0]==max_y &&
                (all_max_inside>2 ||
                 pass>0 && max_y-min_y>ONE_FOURTH(med_d_bord-med_u_bord) ||
                 max_y>P_MAX*med_u_bord/Q_MAX + med_d_bord/Q_MAX &&
                 min_y>med_u_bord//-ONE_FIFTH(med_d_bord-med_u_bord)
                )
               )
            {
               wrk->code=RET_ON_LINE;
               max_to_ret+=1;
            }
            wrk=wrk->prev;
         }

         shtraf+=min_to_ret+max_to_ret;//+1;
      }

      cur=cur->next;
   }

#ifdef FOR_GERMAN
  if (n_super>5 && n_line_min<5)
#else
  if (n_super>5 && n_super>n_line_min+1)
#endif
  {  *pUP_LINE_POS=STR_TOO_NARROW; shtraf+=n_super-n_line_min-1;  }
  if (D->box.right-D->box.left > D->box.bottom-D->box.top || n_str>1)
  {
    if (n_inmax>n_line_max && n_sub<=n_line_max+1)
    {  *pDOWN_LINE_POS=TOO_WIDE; shtraf+=n_inmax-n_line_max;  }
    if (n_inmin>n_line_min && n_super<=n_line_min+1)
    {  *pUP_LINE_POS=TOO_WIDE; shtraf+=n_inmin-n_line_min;  }
        if (n_sub>n_line_max+1 && n_inmax<=n_line_max)
    {  *pDOWN_LINE_POS=STR_TOO_NARROW; shtraf+=n_sub-n_line_max-1;  }
    if (n_allmax>=5 && n_allmin>=5 && n_inmax>=2 &&
        D->box.right-line_max[n_line_max-1].x > ONE_HALF(DX_RECT(D->box))
       )
    {  shtraf+=2;  }
  }

  if ( med_d_bord<dn_pos-size &&
       (dn_pos_sure>=90 && size_sure>=90 && n_line_max<=3 ||
        dn_pos_sure>=75 && size_sure>=75 && n_line_max<=2 ||
        dn_pos_sure>=55 && size_sure>=55 && n_line_max<=1
       )
     )
  {   *pDOWN_LINE_POS=STR_TOO_NARROW;  shtraf+=3;   }

  if ( med_height<TWO_FIFTH(size) && *pDOWN_LINE_POS!=STR_TOO_NARROW &&
       (dn_pos_sure>=90 && size_sure>=90 && n_line_min<=3 ||
        dn_pos_sure>=75 && size_sure>=75 && n_line_min<=2 ||
        dn_pos_sure>=55 && size_sure>=55 && n_line_min<=1
       )
     )
  {   *pUP_LINE_POS=STR_TOO_NARROW;  shtraf+=3;   }

  if ( med_d_bord>dn_pos+size &&
       (dn_pos_sure>=90 && size_sure>=90 && n_line_max<=3 ||
        dn_pos_sure>=75 && size_sure>=75 && n_line_max<=2 ||
        dn_pos_sure>=55 && size_sure>=55 && n_line_max<=1
       )
     )
  {   *pDOWN_LINE_POS=TOO_WIDE;    shtraf+=3;   }

  if ( med_height>size+THREE_HALF(size) &&
       (dn_pos_sure>=90 && size_sure>=90 && n_line_max<=3 ||
        dn_pos_sure>=75 && size_sure>=75 && n_line_max<=2 ||
        dn_pos_sure>=55 && size_sure>=55 && n_line_max<=1
       )
     )
  {   *pUP_LINE_POS=TOO_WIDE;    shtraf+=3;   }

  if ( med_u_bord > dn_pos &&
       (dn_pos_sure>=90 && (n_line_max<=3 || n_line_min<=3) ||
        dn_pos_sure>=75 && (n_line_max<=2 || n_line_min<=2) ||
        dn_pos_sure>=55 && (n_line_max<=1 || n_line_min<=1)
       )
     )
  {   *pUP_LINE_POS=STR_TOO_NARROW;    shtraf+=5;   }

  if (apostroph==_TRUE && n_line_min<6 && n_line_max<6 && n_super==0 && n_sub==0)
      shtraf+=100;

   return(shtraf);
}
/***************************************************************************/

_BOOL extrs_open(low_type _PTR D,p_SPECL cur,_UCHAR type,_INT num)
{
  p_SPECL wrk,prv;
  _INT  i,ibeg,iend,thresh=D->rc->stroka.extr_depth,
        cur_x,cur_y,prv_x,prv_y,sign;
  p_SHORT x=D->buffers[0].ptr,
        y=D->buffers[1].ptr;

  wrk=cur->next;
  while (wrk->mark!=END && wrk->mark!=type)
    wrk=wrk->next;
  if (wrk->mark!=END)
    wrk=wrk->next;
  iend=wrk->iend;
  wrk=cur->prev;
  prv=cur;
  if (num>1)
  {
    while (wrk->mark!=BEG && (wrk->mark!=type || wrk->code==0))
      wrk=wrk->prev;
    prv=wrk;
    wrk=prv->prev;
  }
  while (wrk->mark!=BEG && wrk->mark!=type)
    wrk=wrk->prev;
  if (wrk->mark!=BEG)
    wrk=wrk->prev;
  ibeg=wrk->ibeg;

  cur_y=y[cur->ipoint0];
  cur_x=x[cur->ipoint0];
  prv_y=y[prv->ipoint0];
  prv_x=x[prv->ipoint0];
  sign = (type==MINW) ? 1 : -1;

  for (i=ibeg; i<iend; i++)
  {
    if ((i<cur->ibeg || i>cur->iend) &&
       sign*(cur_y-y[i])>0 && HWRAbs(cur_x-x[i])<ONE_HALF(thresh)
       ||
       (i<prv->ibeg || i>prv->iend) &&
       sign*(prv_y-y[i])>0 && HWRAbs(prv_x-x[i])<ONE_HALF(thresh)
      )
      return(_FALSE);
  }

  return(_TRUE);
}
/***************************************************************************/
_INT calc_med_heights(low_type _PTR D,p_EXTR line_min,p_EXTR line_max,
                       p_SHORT bord_u,p_SHORT bord_d,p_SHORT i_point,
                _INT n_line_min,_INT n_line_max,_INT n_x,
                 p_INT pmed_height,p_INT pmed_u_bord,p_INT pmed_d_bord)
{
   _INT i,j,xl,xr,il,ir,n_height;
   _INT ipnt,x_lim;
//   _INT old_med_height;
   p_SHORT height=_NULL;
   p_SHORT x=D->x;
   if (n_line_min<2 || n_line_max<2)  
  {
      il=0;
      ir=n_x-1;
      n_height=n_x;
   }
   else
   {
//      xl=HWRMax(line_min[0].x,line_max[0].x);
//      xr=HWRMin(line_min[n_line_min-1].x,line_max[n_line_max-1].x);
      xl=HWRMin(line_min[0].x,line_max[0].x);
      xr=HWRMax(line_min[n_line_min-1].x,line_max[n_line_max-1].x);
      i=0;
      while (x[i_point[i]]<xl) i++;
      il=i;
      while (x[i_point[i]]<xr) i++;
      ir=i;
      n_height=ir-il+1;
   }

   xl=x[i_point[il]];   xr=x[i_point[ir]];

   height=(p_SHORT)HWRMemoryAlloc(sizeof(_SHORT)*HWRMax(n_height,50));
   if (height==_NULL)
      return(UNSUCCESS);
/*
   for (j=0; j<n_height; j++)
      height[j] =(_SHORT)(bord_d[i_point[il+j]]-bord_u[i_point[il+j]]);
   old_med_height=calc_mediana(height,n_height);
*/

   if (n_height<50)
      for (j=0; j<n_height; j++)
         height[j] =(_SHORT)(bord_d[i_point[il+j]]-bord_u[i_point[il+j]]);

   else
      for (j=0,ipnt=il; j<50; j++)
      {
         x_lim=xl+(_INT)((_LONG)(xr-xl)*(_LONG)j/50L);
         for (i=ipnt; i<=ir; i++)
            if (x[i_point[i]]>=x_lim)   break;
         if (i>il && x[i_point[i]]-x_lim > x_lim - x[i_point[i-1]])
            ipnt=i-1;
         else
            ipnt=i;
         height[j] = (_SHORT)(bord_d[i_point[ipnt]]-bord_u[i_point[ipnt]]);
      }

   *pmed_height=calc_mediana(height,HWRMin(50,n_height));     //HWRMin(50,n_height)

//   if (old_med_height < (_INT)((_LONG)(*pmed_height)*9L/10L))
//      SetTesterMark;

    if (n_height<50)
      for (i=il,j=0; i<=ir; i++)
         height[j++] = bord_d[i_point[i]];

   else
      for (j=0,ipnt=il; j<50; j++)
      {
         x_lim=xl+(_INT)((_LONG)(xr-xl)*(_LONG)j/50L);
         for (i=ipnt; i<=ir; i++)
            if (x[i_point[i]]>=x_lim)   break;
         if (i>il && x[i_point[i]]-x_lim > x_lim - x[i_point[i-1]])
            ipnt=i-1;
         else
            ipnt=i;
         height[j] =  bord_d[i_point[ipnt]];
      }

   *pmed_d_bord=calc_mediana(height,HWRMin(50,n_height));         //HWRMin(50,n_height)

   if (n_height<50)
      for (i=il,j=0; i<=ir; i++)
         height[j++] = bord_u[i_point[i]];

   else
      for (j=0,ipnt=il; j<50; j++)
      {
         x_lim=xl+(_INT)((_LONG)(xr-xl)*(_LONG)j/50L);
         for (i=ipnt; i<=ir; i++)
            if (x[i_point[i]]>=x_lim)   break;
         if (i>il && x[i_point[i]]-x_lim > x_lim - x[i_point[i-1]])
            ipnt=i-1;
         else
            ipnt=i;
         height[j] =  bord_u[i_point[ipnt]];
      }

  *pmed_u_bord=calc_mediana(height,HWRMin(50,n_height));         //HWRMin(50,n_height)

   if (height!=_NULL) HWRMemoryFree(height);
  return(SUCCESS);
}

/***************************************************************************/
_BOOL correct_narrow_segments(p_EXTR extr,p_INT pn_extr,p_SHORT bord_opp,
                              _UCHAR type,_INT med_height,_INT max_height)
{
   _BOOL del=_FALSE;
  _INT n_extr=*pn_extr;
   _INT i,sign, n_inside, n_narrow;
#ifdef FOR_GERMAN
  _LONG  CONST_NARROW=10, CONST_INSIDE=3;
#else
  _LONG  CONST_NARROW=8, CONST_INSIDE=2;
#endif

	ASSERT((type == MINW) || (type == MAXW));  // JPittman

   if (type==MINW) sign=1;
   if (type==MAXW) sign=-1;

   for (i=0,n_inside=0,n_narrow=0; i<n_extr; i++)
  {
      extr[i].susp=0;
    if (sign*(bord_opp[extr[i].i] - extr[i].y) < 0)
      {
      extr[i].susp=NARROW_LINE;
         n_narrow++;
         continue;
      }
    if ( sign*CONST_NARROW*(bord_opp[extr[i].i] - extr[i].y) < max_height )
      {
            extr[i].susp=NARROW_LINE;
        n_narrow++;
        continue;
      }
    if ( sign*CONST_INSIDE*(bord_opp[extr[i].i] - extr[i].y) < med_height
           && extr[i].pspecl->attr!=I_MIN)
      {
         _INT dyl = (i>0) ? sign*(extr[i].y-extr[i-1].y) : 0;
         _INT dyr = (i+1<n_extr) ? -sign*(extr[i+1].y-extr[i].y) : 0;

         if (100L*dyl>=10L*med_height || 100L*dyr>=10L*med_height)
         {
            extr[i].susp=INSIDE_LINE;
            n_inside++;
         }
      }
  }

#if PG_DEBUG
   if (n_narrow>0)
      DBG_picture2(extr,n_extr,NARROW_LINE);
#endif
   if (n_narrow>0)
   {
      for (i=0; i<n_extr; i++)
         if (extr[i].susp==NARROW_LINE)
            (extr[i].pspecl)->code=INSIDE_LINE;
    delete_line_extr(extr,pn_extr,NARROW_LINE);
      del=_TRUE;
   }


#if PG_DEBUG
   if (n_inside>0)
      DBG_picture2(extr,n_extr,INSIDE_LINE);
#endif
   if (n_inside>0 /*&& n_inside<=ONE_HALF(n_extr)*/)
  {
    for (i=0; i<n_extr; i++)
      if (extr[i].susp==INSIDE_LINE)
            (extr[i].pspecl)->code=INSIDE_LINE;
      delete_line_extr(extr,pn_extr,INSIDE_LINE);
      del=_TRUE;
   }

   return(del);
}

/***************************************************************************/

_BOOL correct_narrow_ends(p_EXTR extr,p_INT pn_extr,p_EXTR extr_opp,
                          _INT n_extr_opp,_INT height,_UCHAR type)
{
   _INT i, j, n_ins=0;
   if (type==BEG)
   {
      while (n_ins<n_extr_opp && extr_opp[n_ins].x < extr[0].x) n_ins++;
      for (j=n_ins-1; j>=0; j--)
    {
         for (i=(*pn_extr); i>0; i--)
        extr[i]=extr[i-1];

         extr[0].x=extr_opp[j].x;
         extr[0].y=(_SHORT)(extr_opp[j].y + height);
         extr[0].i=extr_opp[j].i;
         extr[0].susp=RET_ON_LINE;
         extr[0].pspecl=_NULL;
         (*pn_extr)++;
      }
   }
   if (type==END)
  {
      _INT n_extr=*pn_extr;
      while (n_ins<n_extr_opp && extr_opp[n_extr_opp-1-n_ins].x > extr[n_extr-1].x) n_ins++;
      for (j=n_extr_opp-n_ins; j<n_extr_opp; j++)
      {
         extr[n_extr].x=extr_opp[j].x;
         extr[n_extr].y=(_SHORT)(extr_opp[j].y + height);
         extr[n_extr].i=extr_opp[j].i;
      extr[n_extr].susp=RET_ON_LINE;
         extr[n_extr].pspecl=_NULL;
      n_extr++;
    }
      *pn_extr=n_extr;
   }
#if PG_DEBUG
   DBG_picture2(extr,*pn_extr,RET_ON_LINE);
#endif
   return(_TRUE);
}
/***************************************************************************/

_BOOL numbers_in_text(low_type _PTR D, p_SHORT bord_u, p_SHORT bord_d)
{
   p_SPECL cur,wrk,pend;
  _BOOL sub_in_stroke, super_in_stroke, all_sub, all_super, covered_max;
  _INT n_str=0, n_norm_str=0,/*n_hor=0,*/ n_pnt=0,
       x1line,x2line,x1sub,x2sub,
       ibeg_str,iend_str,ibeg_neib_str,iend_neib_str,
       iLeft,iRight,height,dy_cur,dy_max=0,dy_min=ALEF;
  p_SHORT x=D->buffers[0].ptr,
          y=D->buffers[1].ptr,
          i_back=D->buffers[2].ptr;
  _RECT stroke_box, neib_stroke_box;

  classify_num_strokes(D,_NULL);
  all_sub=all_super=_TRUE;
  cur=D->specl;
  while (cur!=_NULL)
 {
    if (cur->mark==BEG)
       ibeg_str=cur->ibeg;

    if (cur->mark==END)
    {
       n_str++;
       iend_str=cur->iend;
      if (cur->attr==PNT)
        n_pnt++;
  //      if (cur->attr==HOR)
  //        n_hor++;
      if (cur->attr==OPER)
      {
        GetTraceBox ( x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);   /* if it is "t"*/
        if (stroke_box.top==D->box.top)
          return(_FALSE);
      }
      if (cur->attr==L_BRKT || cur->attr==R_BRKT)
      {
        GetTraceBox ( x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);
        if (5L*stroke_box.bottom<4L*D->box.bottom + 1L*D->box.top)
          return(_FALSE);
      }
      if (cur->attr==NORM || cur->attr==STRT || cur->attr==L_BRKT)
      {
        n_norm_str++;
        GetTraceBox ( x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);
        dy_cur=stroke_box.bottom-stroke_box.top;

        if (10L*(stroke_box.right-stroke_box.left)>
            14L*(stroke_box.bottom-stroke_box.top)       /*12*/
           )
          return(_FALSE);
/*
        if (10L*(stroke_box.right-stroke_box.left)>
            20L*step_of_wr
           )
          return(_FALSE);
*/
        iLeft=ixMin((_SHORT)ibeg_str,(_SHORT)iend_str,x,y);
        iRight=ixMax((_SHORT)ibeg_str,(_SHORT)iend_str,x,y);
        iLeft=i_back[iLeft];
        iRight=i_back[iRight];
        height=HWRMax(bord_d[iLeft]-bord_u[iLeft],
                      bord_d[iRight]-bord_u[iRight]);
        if (10L*(stroke_box.bottom-stroke_box.top)<        /*12*/
            11L*height
           )
          return(_FALSE);
        sub_in_stroke=super_in_stroke=_FALSE;
        wrk=cur->prev;
        while (wrk->mark!=BEG)
        {
          if (wrk->mark==MAXW && wrk->code==SUB_SCRIPT)
            sub_in_stroke=_TRUE;
          if (wrk->mark==MINW &&
              (wrk->code==SUPER_SCRIPT ||
               (wrk->attr==T_MIN || wrk->code==TAIL_MIN ||
                wrk->code==RET_ON_LINE) &&
               y[wrk->iend]<bord_u[i_back[wrk->iend]]
              )
             )
            super_in_stroke=_TRUE;
          wrk=wrk->prev;
        }
        if (all_sub ==_TRUE && sub_in_stroke==_FALSE ||
            all_super==_TRUE && super_in_stroke==_FALSE)
        {
                                      //isn't it a snowman
          wrk=cur->next;
          if (wrk!=_NULL)
          {
             ibeg_neib_str=wrk->ibeg;
             while (wrk->mark!=END)  wrk=wrk->next;
             iend_neib_str=wrk->iend;
             GetTraceBox ( x,y,(_SHORT)ibeg_neib_str,(_SHORT)iend_neib_str,&neib_stroke_box);
             if (neib_stroke_box.top > stroke_box.bottom &&
                 neib_stroke_box.left > stroke_box.right
                )
             {
                sub_in_stroke=_TRUE;
                dy_cur=neib_stroke_box.bottom-stroke_box.top;
             }

             if (neib_stroke_box.bottom < stroke_box.top &&
                 neib_stroke_box.left > stroke_box.right
                )
             {
                super_in_stroke=_TRUE;
                dy_cur=stroke_box.bottom-neib_stroke_box.top;
             }
          }
          wrk=cur->prev;
          if (wrk!=_NULL)
          {
             iend_neib_str=wrk->iend;
             while (wrk->mark!=BEG)  wrk=wrk->prev;
             ibeg_neib_str=wrk->ibeg;
             GetTraceBox ( x,y,(_SHORT)ibeg_neib_str,(_SHORT)iend_neib_str,&neib_stroke_box);
             if (neib_stroke_box.top > stroke_box.bottom &&
                 neib_stroke_box.right > stroke_box.left
                )
             {
                sub_in_stroke=_TRUE;
                dy_cur=neib_stroke_box.bottom-stroke_box.top;
             }
             if (neib_stroke_box.bottom < stroke_box.top &&
                 neib_stroke_box.right > stroke_box.left
                )
             {
                super_in_stroke=_TRUE;
                dy_cur=stroke_box.bottom-neib_stroke_box.top;
             }
           }
        }
        if (sub_in_stroke==_FALSE) all_sub=_FALSE;
        if (super_in_stroke==_FALSE) all_super=_FALSE;

//        if (n_norm_str>1 && all_sub==_FALSE && all_super==_FALSE)
//          return(_FALSE);
        dy_max=HWRMax(dy_max,dy_cur);
        dy_min=HWRMin(dy_min,dy_cur);
      }
    }
    if (cur->next==_NULL) break;
    cur=cur->next;
  }

  if (n_norm_str>1 && all_sub==_FALSE && all_super==_FALSE)
     return(_FALSE);

  if (10L*dy_max>15L*dy_min)
     return(_FALSE);

  if (n_norm_str==0 || n_norm_str==1 && n_str>3)
    return(_FALSE);

  if (n_str==2 && n_pnt==1)                   /* if it is "i"*/
    return(_FALSE);

  if (n_norm_str==1)
  {                                          // of or 5 ,
    if (all_sub==_FALSE) return(_FALSE);
    while (cur->attr!=NORM && cur->attr!=STRT)
      cur=cur->prev;
    if (cur->attr==STRT) return(_FALSE);
    pend=cur;
    while (cur->mark!=BEG)
    {
      if (cur->mark==MAXW && cur->code==ON_LINE)
      {
        x1line=x[cur->ibeg];
        x2line=x[cur->iend];
        covered_max=_FALSE;
        for (wrk=pend; wrk->mark!=BEG; wrk=wrk->prev)
        {
          if (wrk->mark==MAXW && wrk->code==SUB_SCRIPT)
          {
            x1sub=x[wrk->ibeg];
            x2sub=x[wrk->iend];
            if (HWRMax(x1line,x2line) >= HWRMin(x1sub,x2sub) &&
               HWRMax(x1sub,x2sub) >= HWRMin(x1line,x2line)
              )
            {  covered_max=_TRUE; break;  }
          }
        }
        if (covered_max==_FALSE)
          return(_FALSE);
      }
      cur=cur->prev;
    }
  }

  return(_TRUE);
}

/***************************************************************************/

#if PG_DEBUG
_VOID DBG_picture1(p_EXTR line_extr, _INT n_line_extr, _RECT box,
                   _INT step, _INT yd, p_UCHAR pn_call)
{
        _INT i, x0, yu;
        _SHORT color_POLYGON_BORD=15;

      if (*pn_call==1) color_POLYGON_BORD=1;
      if (*pn_call==2) color_POLYGON_BORD=8;

    if (mpr>0)
    {
    if (mpr==21)
      {
        for (i=0; i<n_line_extr-1; i++)
          draw_line(line_extr[i].x,line_extr[i].y,
                    line_extr[i+1].x,line_extr[i+1].y,
                    color_POLYGON_BORD,SOLID_LINE,NORM_WIDTH
                   );
      }
        if (yd!=0 && step!=0)
        {
          yu=yd-step;
        x0=box.left-5;
      draw_line((_SHORT)(x0-15),(_SHORT)yd,(_SHORT)(x0+15),(_SHORT)yd,(_SHORT)4,SOLID_LINE,THICK_WIDTH);
      draw_line((_SHORT)(x0-15),(_SHORT)yu,(_SHORT)(x0+15),(_SHORT)yu,(_SHORT)4,SOLID_LINE,THICK_WIDTH);
        }
      if (mpr==21)
      bioskey(0);
      }
    (*pn_call)++;
      return;
}
#endif

/***************************************************************************/

#if PG_DEBUG
_VOID save_par(p_EXTR extr,_INT n_extr,_UCHAR type,_INT med_ampl,
                                         p_SHORT bord_d)
{
  _INT i,j,dxl,dxr,dyl,dyr,sgnl,sgnr,ampl_l,ampl_r,coss,tgl,tgr,hl,hr,
       last_extr=n_extr-1,shift;
  char *pmin="MIN", *pmax="MAX", *pleft="LEFT", *pmid="MID",
       *pright="RIGHT", *p_on_line="ON LINE", *p_out="OUT", *p_in="IN",
      *ptype,*ppos,*pglitch_type;
  p_SPECL cur[3],prv,nxt;
  _BOOL same_code;

  if (type==MAXW)
  {
    ptype=pmax;
    ampl_l=ampl_r=med_ampl;
  }
  else
    ptype=pmin;

  for (shift=0; shift<=2; shift++)
  {
    for (i=shift; i<n_extr; i++)
    {
      for (j=0; j<=shift; j++)
        cur[j]=extr[i-j].pspecl;
      same_code=_TRUE;
      for (j=1; j<=shift; j++)
        if (cur[j]->code!=cur[0]->code)
          same_code=_FALSE;
      if (same_code==_FALSE)
        continue;
      nxt = (i<last_extr) ? extr[i+1].pspecl : _NULL;
      prv = (i>shift) ? extr[i-shift-1].pspecl : _NULL;
      if (nxt!=_NULL && nxt->code!=ON_LINE ||
         prv!=_NULL && prv->code!=ON_LINE
        )
        continue;

      tgl=tgr=hl=hr=coss=10000;
      sgnl=sgnr=0;
      if (type==MINW)
      {
        ampl_l=bord_d[extr[i-shift].i]-extr[i-shift].y;
        ampl_r=bord_d[extr[i].i]-extr[i].y;
        if (i>shift) ampl_l=HWRMin(ampl_l,
                      bord_d[extr[i-shift-1].i]-extr[i-shift-1].y);
        if (i<last_extr) ampl_r=HWRMin(ampl_r,
                      bord_d[extr[i+1].i]-extr[i+1].y);
        ampl_l=HWRMin(ampl_l,med_ampl);
        ampl_r=HWRMin(ampl_r,med_ampl);
      }
      if (i>shift)
      {
        dxl=extr[i-shift].x-extr[i-shift-1].x;
        if (dxl==0) dxl=1;
        dyl=extr[i-shift].y-extr[i-shift-1].y;
        sgnl = sign(dyl,0);
        dyl=HWRAbs(dyl);
        tgl=100L*dyl/dxl;
        hl=(ampl_l!=0) ? 100L*dyl/ampl_l : 200;
      }
      if (i<last_extr)
      {
        dxr=extr[i+1].x-extr[i].x;
        if (dxr==0) dxl=1;
        dyr=extr[i+1].y-extr[i].y;
        sgnr=sign(dyr,0);
        dyr=HWRAbs(dyr);
        tgr=100L*dyr/dxr;
        hr=(ampl_r!=0) ? 100L*dyr/ampl_r : 200;
      }
      if (sgnl*sgnr<0)   continue;
      if (shift==0 && i>0 && i<last_extr)
        coss=cos_pointvect(extr[i].x,extr[i].y,extr[i-1].x,extr[i-1].y,
                     extr[i].x,extr[i].y,extr[i+1].x,extr[i+1].y);
      ppos=pmid;
      if (i==shift) ppos=pleft;
      if (i==last_extr) ppos=pright;
    /*
      hline=7;
      draw_line(extr[i].x,extr[i].y-hline,extr[i].x,extr[i].y+hline,
                  1,SOLID_LINE,THICK_WIDTH);
      bioskey(0);
    */
      switch(cur[0]->code)
      {
        case ON_LINE:
                  pglitch_type=p_on_line;
                  break;
        case SUB_SCRIPT:
                  pglitch_type=p_out;
                  break;
        case SUPER_SCRIPT:
                  pglitch_type=p_out;
                  break;
        case INSIDE_LINE:
                  pglitch_type=p_in;
                  break;
        default:
                  continue;
      }

      printw("\n$ %s, %s, %s, %d, %d, %d, N of extr=%d, shift=%d",
           pglitch_type,ptype,ppos,HWRMin(hl,hr),HWRMin(tgl,tgr),coss,
           i,shift);

    }
  }
}
#endif

/***************************************************************************/
#if PG_DEBUG
_VOID DBG_picture2(p_EXTR extr, _INT n_extr, _INT MARK)
{
  _UCHAR indic=0;
  _INT i;
  _SHORT color_BAD_EXT=(_SHORT)0, color_REM_EXT=(_SHORT)14;
  if (MARK==SUB_SCRIPT || MARK==SUPER_SCRIPT)
       color_BAD_EXT=(_SHORT)4;
  if (MARK==INSIDE_LINE || MARK==NARROW_LINE)
       color_BAD_EXT=12;
  if (MARK==RET_ON_LINE) color_BAD_EXT=(_SHORT)14;

  if (mpr==21)
  {
    for (i=0; i<n_extr; i++)
      {
      if (extr[i].susp==MARK)
         {
            indic=1;
            draw_line(extr[i].x,(_SHORT)(extr[i].y-5),extr[i].x,(_SHORT)(extr[i].y+5),
                    color_BAD_EXT,SOLID_LINE,THICK_WIDTH);
         }
         if (extr[i].susp==-MARK)
         {
            indic=1;
            draw_line(extr[i].x,(_SHORT)(extr[i].y-5),extr[i].x,(_SHORT)(extr[i].y+5),
                    color_REM_EXT,SOLID_LINE,THICK_WIDTH);
         }
      }
      if (indic==1) bioskey(0);
   }
   return;
}
#endif
/***************************************************************************/
#if PG_DEBUG
_VOID DBG_picture3(low_type _PTR D, p_SHORT bord, p_UCHAR pn_call)
{
        _SHORT color_BORD=2;
        if (*pn_call==1) color_BORD=5;
        if (*pn_call==2) color_BORD=6;
      if (*pn_call==3) color_BORD=14;
        if (mpr>=1 && mpr!=2)
        {
          draw_arc( color_BORD, D->x, bord, (_SHORT)0,(_SHORT)(D->ii-1) );
          bioskey(0);
        }
        (*pn_call)++;
        return;
}
#endif

/***************************************************************************/
/* AVP: */
/* ************************************************************************* */
/* *               Fill RC field describing curved border                  * */
/* ************************************************************************* */
_INT FillRCNB(p_SHORT ip, _INT nip, low_type _PTR D,
                p_SHORT bord_u, p_SHORT bord_d)                       /* AVP */
 {
  _INT   i, j;
  _INT   xorg, yorg, xsize, ysize;
  _INT   cur_lim, jprev;
  _INT   xi;
  _INT   du, dd;
  cb_type _PTR cb;

  xorg  = D->box.left;
  yorg  = D->box.top;
  xsize = DX_RECT(D->box);
  if  ( xsize == 0 )
    xsize = 1;
  ysize = DY_RECT(D->box);
  if  ( ysize == 0 )
    ysize = 1;

  DBG_CHK_err_msg( xsize<0 || ysize<0,  "FillRCNB: BAD box" );

  cb    = &(D->rc->curv_bord);

//  if  ( D->bSpecBorder )  /*CHE: was: ip == _NULL */
//    return  FillRCSpec( cb, D ); /* Special treatment for SpecBorder */

  if  ( ip == _NULL  ||  nip <= 0 )  {
    DBG_err_msg( "FillRCNB: BAD (n)ip" );
    return  UNSUCCESS;
  }

  xi       = ip[0];
  du       = bord_u[xi]-yorg; if (du < 1) du = 1; if (du > ysize) du = ysize;
  dd       = bord_d[xi]-yorg; if (dd < 1) dd = 1; if (dd > ysize) dd = ysize;
  (*cb)[0] = (_UCHAR)(((_LONG)du * 255l)/(_LONG)ysize);
  (*cb)[1] = (_UCHAR)(((_LONG)dd * 255l)/(_LONG)ysize);

  for (i = 1, jprev = 0; i < CB_NUM_VERTEX; i ++)
   {
    cur_lim  = (_INT)(((_LONG)(xsize)*(_LONG)i)/(_LONG)(CB_NUM_VERTEX-1));
    cur_lim += xorg;

    for (j = jprev; j < nip; j ++)
     {
      xi = ip[j];

      if (D->p_trace[xi].y == BREAK)  continue;
      if (D->p_trace[xi].x < cur_lim) continue;
      if (bord_u[xi] == 0)      continue;      // Not defined here

      du           = bord_u[xi]-yorg; if (du < 1) du = 1; if (du > ysize) du = ysize;
      dd           = bord_d[xi]-yorg; if (dd < 1) dd = 1; if (dd > ysize) dd = ysize;
      (*cb)[2*i]   = (_UCHAR)(((_LONG)du * 255l)/(_LONG)ysize);
      (*cb)[2*i+1] = (_UCHAR)(((_LONG)dd * 255l)/(_LONG)ysize);

      jprev = j;
      break;
     }
   }

  return SUCCESS;
 }
/***************************************************************************/

#if 0

_INT  FillRCSpec( cb_type _PTR cb, low_type _PTR D )
{
  _INT                i;
  _INT              yorg, ysize, du, dd, ystepu, ystepd;


  if  ( !D->bSpecBorder )
   {
    err_msg( "FillRCNB: BAD SpecBord" );
    return  UNSUCCESS;
   }

  yorg  = D->box.top;
  ysize = DY_RECT(D->box);  if (ysize <= 0) ysize = 1;

//  ystepu   = ((D->yu_end - D->yu_beg)*10)/(CB_NUM_VERTEX-1);
//  ystepd   = ((D->yu_end - D->yu_beg)*10)/(CB_NUM_VERTEX-1);

  for (i = 0; i < CB_NUM_VERTEX; i ++)
   {
   du           = D->rc->stroka.dn_pos_out+D->rc->stroka.size_out
                  -yorg; if (du < 1) du = 1; if (du > ysize) du = ysize;
   dd           = D->rc->stroka.dn_pos_out-yorg; if (dd < 1) dd = 1; if (dd > ysize) dd = ysize;
    (*cb)[i*2]   = (_UCHAR)(((_LONG)du * 255l)/(_LONG)ysize);
    (*cb)[i*2+1] = (_UCHAR)(((_LONG)dd * 255l)/(_LONG)ysize);
   }

  return SUCCESS;
}

#endif /* if 0 */

/* ************************************************************************* */

_BOOL is_defis(low_type _PTR D,_INT n_str)
{
   p_SPECL cur;

   if (n_str>2 || n_str<=0)
      return(_FALSE);
   cur=D->specl;
   while(cur!=_NULL && cur->mark!=END) cur=cur->next;
   if (cur!=_NULL && cur->prev->attr!=HOR_STR)
      return(_FALSE);
   if (n_str==1)
      return(_TRUE);
   cur=cur->next;
   while (cur!=_NULL && cur->mark!=END)  cur=cur->next;
   if (cur!=_NULL && cur->prev->attr==HOR_STR)
      return(_TRUE);
   return(_FALSE);

}

/* ************************************************************************* */
_VOID SpecBord(low_type _PTR D,p_SHORT bord_d,p_SHORT bord_u,
           p_INT pmed_d_bord,p_INT pmed_u_bord,p_INT pmed_height,
#if PG_DEBUG
           p_UCHAR pn_call3_u,p_UCHAR pn_call3_d,
#endif
           p_INT pn_x,_BOOL defis,p_EXTR line_max,_INT n_line_max)
  {
      _INT i,bord_d_pos,bord_u_pos,box_height;//prev_mid;
      p_SHORT i_point=D->buffers[3].ptr;


/*
       prev_mid=(D->yu_beg+D->yu_end+D->yd_beg+D->yd_end)/4;

       if (prev_mid!=0 && D->box.top<prev_mid && D->box.bottom>prev_mid)
       {
          bord_d_pos=D->yd_beg;
          bord_u_pos=D->yu_beg;
       }
       else
*/
#ifdef USE_WORDSPLIT_PARMS
          if (D->rc->stroka.size_sure_in>=50 && D->rc->stroka.pos_sure_in>=50)
          {
             bord_d_pos=D->rc->stroka.dn_pos_in;
             bord_u_pos=D->rc->stroka.dn_pos_in - D->rc->stroka.size_in;
          }
          if (D->rc->stroka.size_sure_in>=50 && D->rc->stroka.pos_sure_in<50)
          {
             if (D->box.bottom-D->box.top < D->rc->stroka.size_in)
             {
                bord_d_pos=ONE_HALF(D->box.bottom)+ ONE_HALF(D->box.top)+
                           ONE_HALF(D->rc->stroka.size_in);
                bord_u_pos=ONE_HALF(D->box.bottom)+ ONE_HALF(D->box.top)-
                           ONE_HALF(D->rc->stroka.size_in);
             }
             if (D->box.bottom-D->box.top >= D->rc->stroka.size_in)
             {
                if (n_line_max>1)
                {
                   for (i=0; i<n_line_max; i++)
                      bord_d[i]=line_max[i].y;
                   bord_d_pos=calc_mediana(bord_d,n_line_max);
                }
                else
                   bord_d_pos=D->box.bottom;
                bord_u_pos=bord_d_pos-D->rc->stroka.size_in;
             }
          }
          if (D->rc->stroka.size_sure_in<50)
#endif /* USE_WORDSPLIT_PARMS */
          {
             if (defis==0)
             {
                if (n_line_max>1)
                {
                   for (i=0; i<n_line_max; i++)
                      bord_d[i]=line_max[i].y;
                   bord_d_pos=calc_mediana(bord_d,n_line_max);
                }
                else
                   bord_d_pos=D->box.bottom;
                bord_u_pos=HWRMax(D->box.top,
                          bord_d_pos-TWO_THIRD(D->box.bottom-D->box.top));
//             bord_u_pos=TWO_THIRD(D->box.top)+ONE_THIRD(D->box.bottom);
             }
             else
             {
               box_height=HWRMax(D->box.bottom-D->box.top,MIN_STR_HEIGHT);
               bord_d_pos=D->box.bottom+box_height;
               bord_u_pos=D->box.top-box_height;
             }
          }
      for (i=0; i<D->ii; i++)
      {
         bord_d[i] = (D->y[i] != BREAK) ?  (_SHORT)bord_d_pos : (_SHORT)0;
         bord_u[i] = (D->y[i] != BREAK) ?  (_SHORT)bord_u_pos : (_SHORT)0;
      }

      *pmed_u_bord=bord_u_pos;
      *pmed_d_bord=bord_d_pos;
      *pmed_height=bord_d_pos-bord_u_pos;
      *pn_x=fill_i_point(i_point,D);
#if PG_DEBUG
      DBG_picture3(D,bord_u,pn_call3_u);
            DBG_picture3(D,bord_d,pn_call3_d);
#endif
  }
#endif  /* __JUST_FIRST_PART */

#endif // #ifndef LSTRIP
/* ************************************************************************* */
/* *       END                                                             * */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\specwin.cpp ===
#ifndef LSTRIP   //for vertigon2


#include "hwr_sys.h"
#include "ams_mg.h"
#include "def.h"
#include "lowlevel.h"
#include "calcmacr.h"

#if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
   #include  "sketch.h"
#endif
#include "arcs.h"
#include "low_dbg.h"


#if PG_DEBUG
#include "pg_debug.h"
#include "wg_stuff.h"
#endif /* PG_DEBUG */



#ifdef VERTIGO
  #include "vxmain.h"
#endif

/*********************************************************************/

#if PG_DEBUG
#define WAIT                                                      \
  if (mpr > 0) \
    draw_wait(pLowData->specl, pLowData->x, pLowData->y, pLowData->ii, \
              _NULL, _NULL, DX_RECT(pLowData->box)/CELLSIZE);
#else
#define WAIT
#endif /* PG_DEBUG */

#if defined(ANDREI_DEB) && PG_DEBUG
#define WAIT_A  WAIT
#else
#define WAIT_A
#endif

#define      KOEFF_BASE            10
#define      MIN_FILTER_KOEFF      ((_SHORT)2)
#define      EPS_Y_BORDER_LIMIT    ((_SHORT)2)

ROM_DATA_EXTERNAL CONSTS const1;

/*******************************************************************/

/*******************************************************************/
/*    Auxiliary functions for filling various fields of "low_data":  */
/*******************************************************************/
_VOID FillLowDataTrace (low_type _PTR pLowData,
                        PS_point_type _PTR trace) {
_SHORT  nPoints;

  nPoints = pLowData->ii = pLowData->rc->ii;
  trace_to_xy (pLowData->x, pLowData->y, nPoints, trace);
  if (nPoints > 1) {
    if (pLowData->y[nPoints-1] != BREAK)
      pLowData->y[nPoints-1] = BREAK;
   }

  pLowData->p_trace = trace;
} /* end of FillLowDataTrace */

/*******************************************************************/
_VOID  GetLowDataRect (low_type _PTR pLowData) {
  size_cross (0, 
              pLowData->ii-1,
              pLowData->x,
              pLowData->y,
              &pLowData->box);
} /* end of GetLowDataRect */

/*******************************************************************/
_BOOL PrepareLowData (low_type _PTR pLowData,
                      PS_point_type _PTR trace,
                      rc_type _PTR rc,
                      p_SHORT _PTR pbuffer) {
_SHORT  len_buf, num_buffers;
_SHORT  len_xy;

  // empty low level work structure
  HWRMemSet((p_VOID)pLowData, 0, sizeof(low_type));
  pLowData->rc = rc;

  // allocate memory for specl
  if (!AllocSpecl (&pLowData->specl, SPECVAL)) {
    err_msg ("No memory for SPECL");
    goto ERR;
            }
  pLowData->nMaxLenSpecl = SPECVAL;

     /*  Define "len_xy" (it must be equal to "rc->ii" plus */
     /* probable addition in "ErrorProv"(for formulas) or   */
     /* other functions (as in Andrey's "FantomSt"):        */

      len_xy = MaxPointsGrown(
#ifdef  FORMULA
                                trace,
#endif  /*FORMULA*/
                                rc->ii);

  if (len_xy > LOWBUF) {
    err_msg ("Too many points !");
                return  _FALSE;
            }

  len_buf     = LOWBUF;
  num_buffers = NUM_BUF;  /* CHE: was "+2" - now lives in "len_xy" */
  
  // set required sizes of the data
  pLowData->nLenXYBuf = len_xy;
  pLowData->rmGrBord  = N_GR_BORD;
  pLowData->rmAbsnum  = N_ABSNUM;
  pLowData->iBegBlankGroups = ALEF;

  // allocate memory for data
  if (LowAlloc (pbuffer, 
                num_buffers, 
                len_buf, 
                pLowData) != SUCCESS)
    goto ERR;

  DBG_CHK_err_msg (len_buf < len_xy,
                   "PrepLD: BAD BufSize");

  return _TRUE;

ERR:
  low_dealloc (pbuffer);
  DeallocSpecl(&pLowData->specl);

  return _FALSE;

} /* end of PrepareLowData */

/*******************************************************************/
/*******************************************************************/
/*****  main program for low level processing                     ****/
/*******************************************************************/
/*******************************************************************/
_SHORT low_level (PS_point_type _PTR trace,
                  xrdata_type _PTR xrdata,
                  rc_type _PTR rc) {

low_type low_data;
_SHORT  retval = UNSUCCESS;
p_SHORT buffer = _NULL;
_SDS_CONTROL  cSDS ;


// scaling the trajectory depends on baseline
  if (rc->ii < 3) {
    // if input trace too short
     err_msg("SPECWIN: Not enough points for recognition");
     return UNSUCCESS;
   }

  // empty output structure
  xrdata->len = 0;

  // allocate low data buffers and initialize them,
  // copy trace to x and y arrays
  if (!PrepareLowData(&low_data, trace, rc, &buffer)) goto  err;

  low_data.slope  = low_data.rc->slope;

  // set work pointers for x and y arrays
  SetXYToInitial(&low_data);
  // copy trace to x and y arrays
  FillLowDataTrace(&low_data, trace);

  // calculate trace bounding rectangle
  GetLowDataRect (&low_data);

  if (BaselineAndScale(&low_data) != SUCCESS) goto err;
  if(rc->low_mode & LMOD_BORDER_ONLY) goto FILL_RC;

#ifndef _WSBDLL // AVP -- to allow removing of redundant code

#ifdef VERTIGO
  VxMonitor(&low_data, xrdata);
#else
  low_data.p_cSDS = &cSDS ;
    if  ( CreateSDS( &low_data , N_SDS ) == _FALSE )
          goto  err ;

  if  ( AnalyzeLowData(&low_data, trace) != SUCCESS )
      goto err;

  // at least fill output xrdata structure array from specl data
  if (exchange(&low_data, xrdata) != SUCCESS)
    goto err;
  DBG_ChkSPECL(&low_data);
//#else
//  form_pseudo_xr_data(&low_data, xrdata);
//#endif  // !LSTRIP

#endif  // !VERTIGO

#if  PG_DEBUG
  CloseTextWindow();
#endif
//  DBG_ChkSPECL(&low_data);

#endif // _WSBDLL

FILL_RC:

  retval = SUCCESS;

err:

#if  PG_DEBUG
  CloseTextWindow();
#endif

#ifndef _WSBDLL
  DestroySDS( &low_data )      ;
#endif

  low_dealloc(&buffer)         ;
  DeallocSpecl(&low_data.specl);

  return  retval;

} /*low_level*/

/* *************************************************************** */
/* * Performs baseline measurement and scales trace respectively * */
/* * This function assume that the LowData already initialized   * */
/* * and x, y arrays already filled with trace data              * */
/* *************************************************************** */
_INT BaselineAndScale(low_type _PTR pLowData) {
_SHORT koeff;

  pLowData->rc->lmod_border_used = LMOD_NO_BORDER_DECISION;

  // calculate ratio between trace amplitude and fixed baseline
  koeff = (_SHORT)((_LONG)DY_RECT(pLowData->box)*
                          KOEFF_BASE/(STR_DOWN-LIN_UP));
  if  ( koeff < MIN_FILTER_KOEFF )
    koeff = MIN_FILTER_KOEFF ;

  // remove some garbage from x and y arrays
  Errorprov(pLowData);

  // normalizing of the trace from x and y array to working buffers
  if (Filt(pLowData,
           koeff*const1.horda/KOEFF_BASE,
           NOABSENCE) !=  SUCCESS)
    goto err;

#if PG_DEBUG
  if (mpr > 0)  {
               draw_init(0,0,0,getmaxx(),getmaxy(),
              pLowData->x, pLowData->y, pLowData->ii);
    draw_arc(-COLOR,
             pLowData->x, pLowData->y, 0, pLowData->ii-1);
             }
#endif

  // level of the extremums determination
  pLowData->rc->stroka.extr_depth = const1.eps_y;

  // special baseline could be either passed from above
  // (in that case there'll be LMOD_BOX_EDIT)
  // or calculated for symbols: "+-=".
  // if exists than no casual baseline will produced
  if (pLowData->rc->low_mode & LMOD_BOX_EDIT)
   {
    pLowData->rc->stroka.size_sure_in=100;
    pLowData->rc->stroka.pos_sure_in=100;
   }

  if (!(pLowData->rc->low_mode & LMOD_BOX_EDIT))
     // casual baseline wil be calculated
   {
    _SHORT epsy_Tmp;

    epsy_Tmp = (_SHORT) (const1.eps_y*koeff/KOEFF_BASE);
#ifndef FOR_GERMAN
    /*CHE: for more rough Extrs for border*/
    epsy_Tmp = (_SHORT)THREE_HALF(epsy_Tmp);
#endif
    if  ( epsy_Tmp <  EPS_Y_BORDER_LIMIT )
      epsy_Tmp = EPS_Y_BORDER_LIMIT ;
    if (epsy_Tmp == const1.eps_y)
      epsy_Tmp = const1.eps_y-1;

    if  ( InitGroupsBorder( pLowData , NOINIT ) != SUCCESS )
      goto  err ;

    // specl initialization
    InitSpecl(pLowData, SPECVAL);

    // fill up specl with extremums
    if (Extr(pLowData,
              epsy_Tmp, UNDEF, UNDEF, UNDEF,
              NREDUCTION_FOR_BORDER, Y_DIR) != SUCCESS)
      goto err;

    pLowData->rc->stroka.extr_depth = epsy_Tmp;
   }

   WAIT

 // set x and y arrays work pointers to initial
  SetXYToInitial(pLowData);

  pLowData->ii = pLowData->rc->ii;

  // calculate baseline if required and scaling trace
  if (transfrmN(pLowData) != SUCCESS)
   goto  err;
  return SUCCESS;

err:
  return UNSUCCESS;
}

/**********************************************************************/
/*            measure_slope(x,y,specl)                                */
/* definition of letters` middle inclination                          */
/* inclination is beeing measured in tg angle *100                    */
/*                                                                    */
/* while vertical disposition = 0                                     */
/* while right inclination slope > 0                                  */
/**********************************************************************/
_SHORT measure_slope(low_type _PTR low_data)
 {
  p_SHORT x=low_data->x;            /* co-ordinates of word`s points */
  p_SHORT y=low_data->y;
  p_SPECL specl=low_data->specl;    /* the list of special points     */
  p_SPECL aspecl;                        /* current element       */
  p_SPECL nspecl;                        /*  next element         */
  _SHORT dx,dy;
  _SHORT slope;                                 /* letters`inclination*/
  _SHORT sum_dx,sum_dy;
  _SHORT coef;        /* coefficient of admittance of big inclinatons */
  _SHORT sum_dy_reset;                  /* the summ of deleted sticks */
/**********************************************************************/
  coef=2;                           /* at first delete inclinaton     */
rep:
  sum_dx=0;                     /* the summ of segments` lengths on  X*/
  sum_dy=0;                     /* the summ of segments` length on   Y*/
  sum_dy_reset=0;                        /* the summ of deleted sticks*/
  aspecl=(SPECL near *)&specl[0];       /* address of list max-min    */
  if((aspecl=aspecl->next)==_NULL) return 0; /*to the 1st unempty elem*/
  nspecl=aspecl->next;                       /* the second element    */
/* measuring of inclination must be done only in pairs:               */
/* upper-down element (MINW - MAXW) without break                       */
/* in the direction from the endof upper to the beginning of down     */
  while (nspecl != _NULL)                   /* go on the list         */
   {
    if ((aspecl->mark == MINW || aspecl->mark == MINN) &&
        (nspecl->mark == MAXW || nspecl->mark == MAXN))
     {                                      /* the pair of elem. suits*/
      dx=x[aspecl->iend]-x[nspecl->ibeg];
      dy=-y[aspecl->iend]+y[nspecl->ibeg];  /* "-" for sign slope     */
/* select segments directed verticaly and down                        */
      if (dy > 0 && coef*HWRAbs(dx) < dy)
       {
        sum_dy+=dy;                        /* common number of points */
        sum_dx+=dx;
       }
      else
       {
        sum_dy_reset+=dy;
       }
     }
#ifdef FORMULA
    if ((aspecl->mark == MAXW || aspecl->mark == MAXN) &&
        (nspecl->mark == MINW || nspecl->mark == MINN))
     {                                      /* pair of elem. suits    */
      dx=-x[aspecl->iend]+x[nspecl->ibeg];
      dy=y[aspecl->iend]-y[nspecl->ibeg];   /* "-" for sign  slope    */
/* select segments directed verticaly and down                        */
      if (dy > 0 && coef*HWRAbs(dx) < dy)
       {
        sum_dy+=(dy/COEF_UP_DOWN);         /* common number of points */
        sum_dx+=(dx/COEF_UP_DOWN);
       }
      else
       {
        sum_dy_reset+=dy;
       }
     }

#endif     /* FORMULA  */
    aspecl=nspecl;                        /* passage to the next elem */
    nspecl=nspecl->next;
   }
  if (coef > 0 && 4*sum_dy_reset > 3*sum_dy)/* a lot of refusals -    */
                                                 /* - big inclination */
   {
    coef-=1;                          /* weaken limits on inclination */
    goto rep;                              /* revise the account      */
   }
  if (sum_dy == 0)              /* there are no necessary elements    */
   {
    slope=0;
   }
  else
   {
    slope=(_SHORT)((long)100*sum_dx/sum_dy);
   }

#if PG_DEBUG
  if (mpr > 0)                  /* draw lines of letters` inclination */
   {
    dx=(_SHORT)((long)slope*(STR_DOWN - STR_UP + 20)/100);
#if !defined(FORMULA)
    draw_line (  SCR_MAXX/3, STR_UP-10,   SCR_MAXX/3-dx, STR_DOWN+10, 3,SOLID_LINE,NORM_WIDTH);
    draw_line (2*SCR_MAXX/3, STR_UP-10, 2*SCR_MAXX/3-dx, STR_DOWN+10, 3,SOLID_LINE,NORM_WIDTH);
    draw_line (4*SCR_MAXX/3, STR_UP-10, 4*SCR_MAXX/3-dx, STR_DOWN+10, 3,SOLID_LINE,NORM_WIDTH);
    draw_line (5*SCR_MAXX/3, STR_UP-10, 5*SCR_MAXX/3-dx, STR_DOWN+10, 3,SOLID_LINE,NORM_WIDTH);
    draw_line (7*SCR_MAXX/3, STR_UP-10, 7*SCR_MAXX/3-dx, STR_DOWN+10, 3,SOLID_LINE,NORM_WIDTH);
#endif
   }
#endif

  return (slope);                          /*  return                 */

 }                                             /*                     */


/* *************************************************************** */
/* *************************************************************** */
/* *************************************************************** */
/* *************************************************************** */
#ifndef VERTIGO
#ifndef _WSBDLL

_INT AnalyzeLowData(low_type _PTR pLowData,
                    PS_point_type _PTR trace) {
_INT retval = UNSUCCESS;

#ifdef  D_ARCS
  ARC_CONTROL   ArcControl;
  p_ARC_CONTROL pArcControl = &ArcControl;
#endif

#if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
  _UM_MARKS_CONTROL            UmMarksControl  ;
#endif  /*FOR_GERMAN... */


#if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
  UmMarksControl.pUmMarks=_NULL;
  pLowData->pUmMarksControl =  &UmMarksControl ;
#endif  /*FOR_GERMAN... */

  // calculate bounding box of the scaled trace
  GetLowDataRect(pLowData);

  // analysis of the scaled trajectory

#if PG_DEBUG
  if (mpr>0) {
   draw_init(1,0,0,getmaxx(),getmaxy(),
              pLowData->x, pLowData->y, pLowData->ii);
    draw_line(pLowData->box.left, LIN_UP,
              pLowData->box.right, LIN_UP,
              COLLIN, DASHED_LINE, NORM_WIDTH);
    draw_line(pLowData->box.left, LIN_DOWN,
              pLowData->box.right, LIN_DOWN,
              COLLIN, DASHED_LINE, NORM_WIDTH);
    draw_line(pLowData->box.left, STR_UP,
              pLowData->box.right, STR_UP,
              COLLIN, SOLID_LINE,  NORM_WIDTH);
    draw_line(pLowData->box.left, STR_DOWN,
              pLowData->box.right, STR_DOWN,
              COLLIN, SOLID_LINE,  NORM_WIDTH);
   }
#endif

  // remove some garbage from x and y arrays
  Errorprov(pLowData);

  // normalizing
  if (PreFilt(const1.horda, pLowData) != SUCCESS)
    goto err;

#if PG_DEBUG
  if  (mpr > 0)  {
    draw_arc(-COLOR,
             pLowData->x, pLowData->y, 0, pLowData->ii-1);
  }
#endif

    if  ( InitGroupsBorder( pLowData , INIT ) != SUCCESS )
          goto err ;

  DefLineThresholds ( pLowData ) ;
  InitSpecl( pLowData, SPECVAL ) ;
  WAIT_A
  Extr( pLowData    ,
        const1.eps_y , const1.eps_x , const1.eps_x , ONE_HALF(const1.eps_y) ,
        NREDUCTION_FOR_BORDER       , X_DIR|Y_DIR|XY_DIR  )  ;

 #if  defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
  CreateUmlData ( pLowData->pUmMarksControl , UMSPC ) ;
  Sketch( pLowData ) ;
 #endif /* FOR_FRENCH */
  OperateSpeclArray( pLowData ) ;
    if  ( Sort_specl( pLowData->specl, pLowData->len_specl ) != SUCCESS )
           goto  err ;
  WAIT

    if  ( InitGroupsBorder( pLowData , INIT ) != SUCCESS )
          goto err ;

 #ifdef  D_ARCS
    if  ( Prepare_Arcs_Data( pArcControl )            )
           goto  err ;
    if  ( Arcs( pLowData, pArcControl ) == ! SUCCESS  )
          goto err ;
 #endif   /* D_ARCS     */

  if  ( Pict( pLowData ) != SUCCESS )
        goto  err ;

  WAIT_A

  Surgeon( pLowData ) ;

  // normalizing of the trace from x and y array to working buffers
  //
  if ( Filt( pLowData, const1.horda, ABSENCE ) != SUCCESS )
       goto  err ;

    if ( InitGroupsBorder( pLowData , INIT) != SUCCESS )
         goto  err ;

       /*  Fill "xBuf", "yBuf" with the original trajectory: */

  trace_to_xy(pLowData->xBuf, pLowData->yBuf, pLowData->rc->ii, trace);

#if  PG_DEBUG
   draw_init(DI_CLEARCURVES, 0, 0, getmaxx(), getmaxy(),
             pLowData->x, pLowData->y, pLowData->ii);

  if (mpr>0)
      draw_arc(-COLOR,
               pLowData->x, pLowData->y, 0, pLowData->ii-1);
  if (mpr>15)
    draw_wait(pLowData->specl,
              pLowData->x, pLowData->y, pLowData->ii,
              _NULL, _NULL, 0);
#endif

  // ???? at last good extremum for common use
  if ( Extr( pLowData,
             const1.eps_y, UNDEF, UNDEF, UNDEF,
             NREDUCTION, Y_DIR) != SUCCESS)
             goto err ;
  /* measure_slope prohibits changing SPECL - only MIN and MAX required */
  // do not move call from here
  if ((pLowData->rc->low_mode & LMOD_BOX_EDIT) ||
      (pLowData->rc->rec_mode == RECM_FORMULA))
    pLowData->slope = 0;
  else
    pLowData->slope = measure_slope(pLowData);

 #if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
  UmMarksControl.termSpecl1 = pLowData->len_specl ;
 #endif              /* FOR_GERMAN... */

//  if (Circle(pLowData) != SUCCESS)
//           goto err;
  if (angl(pLowData) != SUCCESS)
    goto err;

  if (!FindSideExtr(pLowData))
    goto err;
   WAIT
/*
  if (Sort_specl(pLowData->specl, pLowData->len_specl) != SUCCESS)
           goto err;

  get_last_in_specl(pLowData);

  if (Circle(pLowData) != SUCCESS)
           goto err;
*/

#if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
   UmMarksControl.termSpecl = pLowData->len_specl ;
#endif              /* FOR_GERMAN... */

    if  ( Cross( pLowData ) != SUCCESS )
          goto err ;
   WAIT

#ifdef D_ARCS
  ArcRetrace(pLowData, pArcControl);
  Dealloc_Arcs_Data (pArcControl);
#endif /* D_ARCS */

#if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)

  UmPostcrossModify( pLowData ) ;

  UmResultMark( pLowData ) ;

  DestroyUmlData( pLowData->pUmMarksControl ) ;

  DotPostcrossModify( pLowData ) ;
#endif              /* FOR_GERMAN... */

  // remove
  if (Clear_specl(pLowData->specl, pLowData->len_specl) != SUCCESS)
                                goto err;
  /* preprosessing of elements*/
  if (lk_begin(pLowData) != SUCCESS)
                                goto err;
  DBG_ChkSPECL(pLowData);

  /* analyze crossings */
  lk_cross(pLowData);

  DBG_ChkSPECL(pLowData);

  /* analize arcs */
  lk_duga(pLowData);

  DBG_ChkSPECL(pLowData);
  
  Adjust_I_U(pLowData);  /*CHE*/
     
  DBG_ChkSPECL(pLowData);

  /* analyzing of break element */
  if (xt_st_zz (pLowData) != SUCCESS)  
                                goto err;
  DBG_ChkSPECL(pLowData);

#if 0  /* dead OVER */
  if ((pLowData->rc->low_mode & LMOD_FREE_TEXT) &&
      (pLowData->rc->rec_mode != RECM_FORMULA)) {

      def_over(pLowData);

      DBG_ChkSPECL(pLowData);
    }
#endif

  if (RestoreColons(pLowData) != SUCCESS)
     goto  err;
  if (!PostFindSideExtr(pLowData)) /*CHE*/
     goto  err;
  retval = SUCCESS;

err:
#if /* GIT - defined(FOR_GERMAN) ||  */ defined(FOR_FRENCH) || defined(FOR_INTERNATIONAL)
  DestroyUmlData( pLowData->pUmMarksControl ) ;
#endif              /* FOR_GERMAN... */

  return  retval;

}

#endif // _WSBDLL
#endif // VERTIGO

/* *************************************************************** */


/************************************************************************** */
/************************************************************************** *
#ifdef LSTRIP

     insert_pseudo_xr(xrd_el_type _PTR xrd_num_elem, xrinp_type _PTR pxr,
                      p_SPECL cur, PS_point_type _PTR trace, _SHORT _PTR pos)
     {
        _RECT box;

        HWRMemCpy(&(xrd_num_elem->xr),pxr,sizeof(xrinp_type));
        xrd_num_elem->hotpoint=pos[cur->ipoint0];
        xrd_num_elem->begpoint=pos[cur->ibeg];
        xrd_num_elem->endpoint=pos[cur->iend];
        GetBoxFromTrace( trace,
                         xrd_num_elem->begpoint, xrd_num_elem->endpoint,
                         &box );
        xrd_num_elem->box_left=box.left;
        xrd_num_elem->box_up=box.top;
        xrd_num_elem->box_right=box.right;
        xrd_num_elem->box_down=box.bottom;
        xrd_num_elem->location=0;
     }

/************************************************************************** *

_SHORT form_pseudo_xr_data(low_type _PTR low_data, xrdata_type _PTR xrdata)
{
  p_SPECL            spec  = low_data->specl, cur;
  PS_point_type _PTR trace = low_data->p_trace;
  _SHORT _PTR pos=low_data->buffers[2].ptr;
  xrd_el_type _PTR xrd = &(*xrdata->xrd)[0];
  xrd_el_type _PTR xrd_num_elem;
  xrinp_type  pseudo_xr, FF_xr;
  _INT num_elem;


  pseudo_xr.type=0;
  pseudo_xr.attrib=0;
  pseudo_xr.penalty=0;
  pseudo_xr.height=0;
  pseudo_xr.shift=0;
  pseudo_xr.orient=0;
  pseudo_xr.depth=0;
  pseudo_xr.emp=0;

  FF_xr.type=X_FF;
  FF_xr.attrib=END_LETTER_FLAG;
  FF_xr.penalty=0;
  FF_xr.height=0;
  FF_xr.shift=0;
  FF_xr.orient=0;
  FF_xr.depth=0;
  FF_xr.emp=0;

  insert_pseudo_xr(&xrd[0],&FF_xr,cur,trace,pos);
  num_elem=1;

  for (cur=spec; cur!=NULL; cur=cur->next)
  {
     if (cur->attr==PSEUDO_XR_MIN || cur->attr==PSEUDO_XR_MAX || cur->attr==PSEUDO_XR_DEF)
     {
        pseudo_xr.type=cur->attr;
        insert_pseudo_xr(&xrd[num_elem],&pseudo_xr,cur,trace,pos);
        num_elem++;
     }
     if (cur->mark==END)
     {
        insert_pseudo_xr(&xrd[num_elem],&FF_xr,cur,trace,pos);
        num_elem++;
     }

  }
  xrdata->len=num_elem;
  HWRMemSet(&xrd[num_elem],0,sizeof(xrd[0]));
  return (SUCCESS);
}

#endif  //#ifdef LSTRIP



/* *************************************************************** */
/* *************************************************************** */
/* *************************************************************** */

#endif //#ifndef LSTRIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\stroka.cpp ===
#include <common.h>
#include "ams_mg.h"
#include "stroka1.h"


#ifndef NULL
 #define NULL _NULL
#endif

#ifndef LSTRIP

/***********************************************************************/

#ifndef __JUST_SECOND_PART
    /*  mbo I need to split this file
        Symantec C++ version 7.0 generates more than 32k code for it, so
        that does not fit to one MAC segment.
    */
#ifdef __cplusplus
extern "C"
{
extern int getCyBase(p_VOID pvXrc, p_SHORT u, p_SHORT d);
}
#endif

_SHORT transfrmN(low_type _PTR D)
{
	p_VOID mem_segm=_NULL;
	_SHORT retval=UNSUCCESS;
	_SHORT shift;
	_INT should, width, step_of_wr=-1,apr_height,shtraf,shtraf0;
	_INT unsureness=0;
	_INT i,n,cur_i,cur_y,np;
	_INT med_ampl,mid_ampl,max_ampl,max_dist,max_up_height=0,mid_dev;
	_LONG dev_abs_sum;
	_INT med_height,med_u_bord,med_d_bord,t_height=0,ft_height=0;
	_INT n_allmax,n_allmin,n_ampl,n_line_max,n_line_min,
		n_line_max0,n_line_min0,n_x,n_strokes=0;
	_INT dyAll = D->box.bottom-D->box.top;
	_INT  UP_LINE_POS=0, DOWN_LINE_POS=0;
	_INT x_left_max,x_right_max,x_left_min,x_right_min;
	_INT CONSTT;
	p_SHORT ampl=_NULL, bord_u, bord_d;
	p_SHORT x=D->buffers[0].ptr,
		y=D->buffers[1].ptr,
		i_back=D->buffers[2].ptr,
		i_point=D->buffers[3].ptr;
	p_EXTR line_max=_NULL,line_min,line_max1,line_min1,line_max0,line_min0;
	p_SPECL cur;
	_BOOL del=_FALSE, ins=_FALSE, change_min=_FALSE, change_max=_FALSE, defis,
		sep_let, nonpos_height, gl_down_left=_FALSE, gl_up_left=_FALSE;
	_UCHAR pass=0;
	_BOOL		bGuide = 0;
	_SHORT		upLine, midLine;

#if PG_DEBUG
	_UCHAR n_call3_d=0, n_call3_u=0;
	_UCHAR n_call1_d=0, n_call1_u=0;
	_INT bord_d_pos;
#endif
	
	
	if (D->rc->rec_mode!=RECM_FORMULA  &&
		(D->rc->low_mode & LMOD_BORDER_TEXT)
		)
		D->rc->lmod_border_used=LMOD_BORDER_TEXT;
	else
		D->rc->lmod_border_used=LMOD_BORDER_NUMBER;
	
		/*  if (D->rc->stroka.pos_sure_in<100 && D->rc->stroka.pos_sure_in>0  &&
		D->rc->stroka.size_sure_in>0)
		{
		if (D->box.top>D->rc->stroka.dn_pos_in)
		D->rc->stroka.pos_sure_in=0;
} */
	
	
	if (!(D->rc->stroka.size_sure_in==100&&D->rc->stroka.pos_sure_in==100)
		&& D->rc->lmod_border_used==LMOD_BORDER_TEXT)
	{
		ampl=(p_SHORT)HWRMemoryAlloc(2L*MAX_NUM_EXTR*sizeof(_SHORT));
		if (ampl==_NULL) 
			goto EXIT_FREE;
		
		cur=D->specl;
		while (cur!=_NULL)
		{
			if (cur->mark==MAXW || cur->mark==MINW)
			{
				cur->attr=NORM;
				cur->code=0;
			}
			cur=cur->next;
		}

		if (extract_ampl(D,ampl,&n_ampl)==UNSUCCESS)
			goto EXIT_FREE;;

		if (n_ampl > 0)
			med_ampl=calc_mediana (ampl, n_ampl);

		else med_ampl=dyAll;

		for (i=0,max_ampl=0; i<n_ampl; i++)
		{
			if (max_ampl<ampl[i])  
				max_ampl=ampl[i];
		}
			
		n_strokes=
			classify_strokes(D,med_ampl,max_ampl,n_ampl,&t_height,&ft_height,&sep_let);
		
		if (extract_ampl(D,ampl,&n_ampl)==UNSUCCESS)
			goto EXIT_FREE;;

		if (n_ampl>0) 
			med_ampl=calc_mediana(ampl,n_ampl);
		else 
			med_ampl=dyAll;

		if (n_ampl>0) 
			mid_ampl=calc_average(ampl,n_ampl);
		else 
			mid_ampl=dyAll;

		if (ampl!=_NULL) 
		{
			HWRMemoryFree(ampl);
			ampl	=	NULL;
		}
	}
	
	
	DBG_CHK_err_msg( 2L*sizeof(_SHORT)*D->ii +
		4L*sizeof(EXTR)*MAX_NUM_EXTR > 65000L,
		"transN: Too big mem. request" );
	mem_segm = HWRMemoryAlloc(4L*MAX_NUM_EXTR*sizeof(EXTR) +
		2L*D->ii*sizeof(_SHORT));
	if (mem_segm==_NULL) goto 
		EXIT_FREE;
	line_max=(p_EXTR)mem_segm;
	line_min=line_max+MAX_NUM_EXTR;
	line_max1=line_min+MAX_NUM_EXTR;
	line_min1=line_max1+MAX_NUM_EXTR;
	bord_d=(p_SHORT)(line_min1+MAX_NUM_EXTR);
	bord_u=bord_d+D->ii;
	
	if (D->rc->stroka.pos_sure_in==100 && D->rc->stroka.size_sure_in==100)
	{
		unsureness+=100;
		SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
			&n_call3_u,&n_call3_d,
#endif
			&n_x,0,line_max,0);
		goto TRANSFORM;
	}
	
BEGIN:
	
	HWRMemSet(line_max,0,2*sizeof(EXTR)*MAX_NUM_EXTR);
	HWRMemSet(bord_d,0,2*sizeof(_SHORT)*D->ii);
	
	if (D->rc->lmod_border_used==LMOD_BORDER_NUMBER)
	{
		n_strokes=classify_num_strokes(D,&med_ampl);

		if (extract_num_extr(D,MAXW,line_max,&n_allmax)==UNSUCCESS)
			goto EXIT_FREE;

		n_line_max=n_allmax;

		if (extract_num_extr(D,MINW,line_min,&n_allmin)==UNSUCCESS)
			goto EXIT_FREE;

		n_line_min=n_allmin;

		if (n_line_min==0 || n_line_max==0)
		{
			unsureness+=100;
			defis=is_defis(D,n_strokes);
			SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
				&n_call3_u,&n_call3_d,
#endif
				&n_x,defis,line_max,0);
			goto TRANSFORM;
		}
		sort_extr(line_max,n_line_max);
		sort_extr(line_min,n_line_min);
#if PG_DEBUG
		DBG_picture1(line_max,n_line_max,D->box,0,0,&n_call1_d);
		DBG_picture1(line_min,n_line_min,D->box,0,0,&n_call1_u);
#endif
		num_bord_correction(line_max,&n_line_max,n_allmax,MAXW,med_ampl,bord_d,y);
		goto BORD_D;
	}
	
	if (extract_all_extr(D,MAXW,line_max,&n_allmax,&n_line_max,&shift)
		==UNSUCCESS)
		goto EXIT_FREE;
	//  n_line_max=n_allmax;
	if (extract_all_extr(D,MINW,line_min,&n_allmin,&n_line_min,&shift)
		==UNSUCCESS)
		goto EXIT_FREE;
	//  n_line_min=n_allmin;
	if (n_line_min==0 || n_line_max==0)
	{
		unsureness+=100;
		defis=is_defis(D,n_strokes);
		SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
			&n_call3_u,&n_call3_d,
#endif
			&n_x,defis,line_max,0);
		goto TRANSFORM;
	}
	sort_extr(line_max,n_line_max);
	x_left_max=line_max[0].x;
	x_right_max=line_max[n_line_max-1].x;
	sort_extr(line_min,n_line_min);
	
	x_left_min=line_min[0].x;
	x_right_min=line_min[n_line_min-1].x;
	
	n=n_line_max;
	if (n==0) n=1;
	
	if (n_strokes>3 && sep_let==_TRUE)
		ft_height=t_height=0;
	
	width = (n>1) ? line_max[n-1].x-line_max[0].x : D->box.right-D->box.left;
	
	step_of_wr =(_INT)((14L*width/*-shift*/) /(10*n));         //04_14
	
	if (width<dyAll)//ONE_HALF(dyAll))                           //12_29
	{
#ifdef USE_WORDSPLIT_PARMS
		if (D->rc->stroka.size_sure_in >=50)
			step_of_wr=D->rc->stroka.size_in;
		else
#endif /* USE_WORDSPLIT_PARMS */
		{
			width=D->box.right-D->box.left;
			step_of_wr = (_INT)((14L*width/*-shift*/) /(10*n));         //04_14
		}
	}
	
	
#ifdef USE_WORDSPLIT_PARMS
	if (D->rc->stroka.size_sure_in >= 90)
	{
		step_of_wr = D->rc->stroka.size_in;
	}
	
#endif /* USE_WORDSPLIT_PARMS */
#if PG_DEBUG
	bord_d_pos = THREE_FOURTH(D->box.bottom) + ONE_FOURTH(D->box.top);
	
	if (D->rc->stroka.pos_sure_in >= 50)
		bord_d_pos = D->rc->stroka.dn_pos_in;
	
	DBG_picture1(line_max,n_line_max,D->box,step_of_wr,bord_d_pos,&n_call1_d);
	DBG_picture1(line_min,n_line_min,D->box,step_of_wr,bord_d_pos,&n_call1_u);
#endif
	
	
	del=bord_correction(D,line_max,&n_line_max,n_allmax,MAXW,step_of_wr,
		med_ampl,mid_ampl,max_ampl,x_left_max,x_right_max,
		DOWN_LINE_POS,pass,bord_d,max_up_height,ft_height,
		gl_up_left,gl_down_left
#if PG_DEBUG
		,&n_call1_d
#endif
		);
	
	/***************************************************************************/
	
BORD_D:
	
	n=HWRMax(n_allmax, n_allmin);
	if (n==0) n=1;
	should = (D->box.right-D->box.left) / (2*n);
	
	smooth_d_bord(line_max,n_line_max,D,should,bord_d);
#if PG_DEBUG
	DBG_picture3(D,bord_d,&n_call3_d);
#endif
	if (D->rc->lmod_border_used==LMOD_BORDER_NUMBER)
	{
		del=num_bord_correction(line_min,&n_line_min,n_allmin,MINW,med_ampl,bord_d,y);
		if (del==_TRUE)
		{
			del=num_bord_correction(line_max,&n_line_max,n_allmax,MAXW,med_ampl,bord_d,y);
			if (del==_TRUE)
			{
				smooth_d_bord(line_max,n_line_max,D,should,bord_d);
#if PG_DEBUG
				DBG_picture3(D,bord_d,&n_call3_d);
#endif
			}
		}
		goto BORD_U;
	}
	
	if (del==_TRUE)
	{
		max_dist=0;
		cur=D->specl;
		while (cur!=_NULL)
		{
			if (cur->mark==MAXW && cur->code==SUB_SCRIPT)
			{
				_INT dist=y[cur->ipoint0]-bord_d[i_back[cur->ipoint0]];
				if (dist>max_dist) max_dist=dist;
			}
			cur=cur->next;
		}
		
		ins=sub_max_to_line(D,line_max,&n_line_max,bord_d,max_dist);
		
		del=bord_correction(D,line_max,&n_line_max,n_allmax,MAXW,step_of_wr,
			med_ampl,mid_ampl,max_ampl,x_left_max,x_right_max,
			DOWN_LINE_POS,pass,bord_d,max_up_height,ft_height,
			gl_up_left,gl_down_left
#if PG_DEBUG
			,&n_call1_d
#endif
			);
		
		if (del==_TRUE || ins==_TRUE)
		{
			smooth_d_bord(line_max,n_line_max,D,should,bord_d);
			
#if PG_DEBUG
			DBG_picture3(D,bord_d,&n_call3_d);
#endif
		}
		
		if (del==_TRUE)
		{
			max_dist=0;
			cur=D->specl;
			while (cur!=_NULL)
			{
				if (cur->mark==MAXW && cur->code==SUB_SCRIPT)
				{
					_INT dist=y[cur->ipoint0]-bord_d[i_back[cur->ipoint0]];
					if (dist>max_dist) max_dist=dist;
				}
				cur=cur->next;
			}
			
			ins=sub_max_to_line(D,line_max,&n_line_max,bord_d,max_dist);
			
			if (ins==_TRUE)
			{
				smooth_d_bord(line_max,n_line_max,D,should,bord_d);
				
#if PG_DEBUG
				DBG_picture3(D,bord_d,&n_call3_d);
#endif
			}
		}
	}
	
	/***************************************************************************/
	/*
	for (i=0, max_up_height=0; i<D->ii; i++)
	if (max_up_height < bord_d[i] - D->y[i])
	max_up_height = bord_d[i] - D->y[i];
	*/
	for (i=0,max_up_height=0; i<n_line_min; i++)
	{
		cur_i=line_min[i].i;
		cur_y=line_min[i].y;
		if (max_up_height < bord_d[cur_i]-cur_y)
			max_up_height = bord_d[cur_i]-cur_y;
	}
	//  max_up_height=HWRMax(max_up_height,t_height);        // 04_14
	
	del_tail_min(line_min,&n_line_min,y,bord_d,pass);
	
	del=bord_correction(D,line_min,&n_line_min,n_allmin,MINW,step_of_wr,
		med_ampl,mid_ampl,max_ampl,x_left_min,x_right_min,
		UP_LINE_POS,pass,bord_d,max_up_height,ft_height,
		gl_up_left,gl_down_left
#if PG_DEBUG
		,&n_call1_d
#endif
		);
	
	if (del==_TRUE) bord_correction(D,line_min,&n_line_min,n_allmin,MINW,
		step_of_wr,med_ampl,mid_ampl,max_ampl,
		x_left_min,x_right_min,UP_LINE_POS,pass,
		bord_d,max_up_height,ft_height,
		gl_up_left,gl_down_left
#if PG_DEBUG
		,&n_call1_d
#endif
		);
	
BORD_U:
	smooth_u_bord(line_min,n_line_min,D,should,bord_u,bord_d);
	
#if PG_DEBUG
	DBG_picture3(D,bord_u,&n_call3_u);
#endif
	
	n_x=fill_i_point(i_point,D);
	
	if (calc_med_heights(D,line_min,line_max,bord_u,bord_d,i_point,n_line_min,
		n_line_max,n_x,&med_height,&med_u_bord,&med_d_bord)
		!= SUCCESS)
		goto EXIT_FREE;
	if (D->rc->lmod_border_used==LMOD_BORDER_NUMBER)
		goto TRANSFORM;
	
	
	shtraf=line_pos_mist(D,med_u_bord,med_d_bord,med_height,n_line_min,
		n_line_max,line_max,&UP_LINE_POS,&DOWN_LINE_POS,bord_u,bord_d,pass);
	
	if (shtraf>=100)
	{
		unsureness+=100;                           /*apostroph*/
		SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
			&n_call3_u,&n_call3_d,
#endif
			&n_x,0,line_max,n_line_max);
		goto TRANSFORM;
	}
	
	gl_up_left=gl_down_left=_FALSE;
	for (i=0; i<n_line_min; i++)
		line_min[i].susp=0;
	for (i=0; i<n_line_max; i++)
		line_max[i].susp=0;
	find_gaps_in_line(line_max,n_line_max,n_allmax,med_ampl,MAXW,
		x_left_max,x_right_max,bord_d,y,0,1);
	find_glitches_in_line(line_max,n_line_max,med_ampl,MAXW,
		x_left_max,x_right_max,bord_d,x,y,2,0,1);
	find_gaps_in_line(line_min,n_line_min,n_allmin,med_ampl,MINW,
		x_left_min,x_right_min,bord_d,y,0,1);
	find_glitches_in_line(line_min,n_line_min,med_ampl,MINW,
		x_left_min,x_right_min,bord_d,x,y,2,0,1);
	for (i=0; i<n_line_min; i++)
	{
		if (line_min[i].susp==GLITCH_UP || line_min[i].susp==DBL_GLITCH_UP ||
			line_min[i].susp==TRP_GLITCH_UP
			)
			gl_up_left=_TRUE;
	}
	
	for (i=0; i<n_line_max; i++)
	{
		if (line_max[i].susp==GLITCH_DOWN || line_max[i].susp==DBL_GLITCH_DOWN)
			gl_down_left=_TRUE;
	}
	
	if (gl_up_left==_TRUE || gl_down_left==_TRUE)
		shtraf++;
	
	if (pass==0 && shtraf>0)
	{
		shtraf0=shtraf;
		line_min0=line_min;
		line_max0=line_max;
		n_line_min0=n_line_min;
		n_line_max0=n_line_max;
		line_min=line_min1;
		line_max=line_max1;
		cur=D->specl;
		while (cur!=NULL)
		{
			if (cur->mark==MINW || cur->mark==MAXW)
				cur->other=cur->code;
			cur=cur->next;
		}
		pass++;
		goto BEGIN;
	}
	if (pass==1 && shtraf>=3 && shtraf0>=3 &&
		(n_line_min<=1||n_line_max<=1) && (n_line_min0<=1||n_line_max0<=1)
		)
	{
		unsureness+=100;
		SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
			&n_call3_u,&n_call3_d,
#endif
			&n_x,0,line_max,n_line_max);
		goto TRANSFORM;
	}
	if (pass==1 && shtraf>=shtraf0)
	{
		if (shtraf==shtraf0)
			unsureness+=10;
		line_min=line_min0;
		line_max=line_max0;
		n_line_min=n_line_min0;
		n_line_max=n_line_max0;
		cur=D->specl;
		while (cur!=NULL)
		{
			if (cur->mark==MINW || cur->mark==MAXW)
				cur->code=cur->other;
			cur=cur->next;
		}
		smooth_u_bord(line_min,n_line_min,D,should,bord_u,bord_d);
		smooth_d_bord(line_max,n_line_max,D,should,bord_d);
#if PG_DEBUG
		DBG_picture3(D,bord_u,&n_call3_u);
		DBG_picture3(D,bord_d,&n_call3_d);
#endif
		if (calc_med_heights(D,line_min,line_max,bord_u,bord_d,i_point,n_line_min,
			n_line_max,n_x,&med_height,&med_u_bord,&med_d_bord)
			!= SUCCESS)
			goto EXIT_FREE;
	}
	
	
	
	if (
#if USE_CHUNK_PROCESSOR
		D->rc->fl_chunk==0 &&
#endif /* USE_CHUNK_PROCESSOR */
		D->rc->lmod_border_used==LMOD_BORDER_TEXT &&
		sep_let==_TRUE ||
		D->rc->low_mode & LMOD_SMALL_CAPS
		)
	{
		if (numbers_in_text(D,bord_u,bord_d)==_TRUE)
		{
			unsureness+=10;
			if (D->rc->stroka.size_sure_in>=90 &&
				D->rc->stroka.pos_sure_in>=90)
			{
				unsureness+=90;
				SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
					&n_call3_u,&n_call3_d,
#endif
					&n_x,0,line_max,0);
				goto TRANSFORM;
			}
			else
			{
				D->rc->lmod_border_used=LMOD_BORDER_NUMBER;
				goto BEGIN;
			}
		}
	}
	
	/*
	for (i=0,max_up_height=0; i<D->ii; i++)
	if (max_up_height < bord_d[i]-D->y[i])
	max_up_height = bord_d[i]-D->y[i];
	
	  change_min=correct_narrow_segments(line_min,&n_line_min,bord_d,MINW,
	  med_height,max_up_height);
	  
		if (change_min==_TRUE)
		{
		smooth_u_bord(line_min,n_line_min,D,should,bord_u,bord_d) ;
		#if PG_DEBUG
		DBG_picture3(D,bord_u,&n_call3_u);
		#endif
		}
		
		  for (i=0,max_down_height=0; i<D->ii; i++)
		  if (max_down_height < D->y[i]-bord_u[i])
		  max_down_height = D->y[i]-bord_u[i];
		  
			change_max=correct_narrow_segments(line_max,&n_line_max,bord_u,MAXW,
			med_height,max_down_height);
			
			  if (change_max==_TRUE)
			  {
			  smooth_d_bord(line_max,n_line_max,D,should,bord_d);
			  #if PG_DEBUG
			  DBG_picture3(D,bord_d,&n_call3_d);
			  #endif
			  }
			  
				if (change_min==_TRUE || change_max==_TRUE)
				{
				if (calc_med_heights(D,line_min,line_max,bord_u,bord_d,i_point,n_line_min,
				n_line_max,n_x,&med_height,&med_u_bord,&med_d_bord)
				!= SUCCESS)
				goto EXIT_FREE;
				}
	*/
	
	change_min=change_max=_FALSE;
#ifdef FOR_GERMAN
	CONSTT=3;
#else
	CONSTT=2;
#endif
	if (CONSTT*(bord_d[i_point[0]]-bord_u[i_point[0]])<=med_height
		//       || bord_d[i_point[0]]-bord_u[i_point[0]]>=CONSTT*med_height
		)
	{
		unsureness+=5;
		if (n_line_min<1 || n_line_max<1) goto TRANSFORM;
		if (line_min[0].x > line_max[0].x)
		{
			_INT height=line_min[0].y-bord_d[line_min[0].i];
			change_min=correct_narrow_ends(line_min,&n_line_min,line_max,
				n_line_max,height,BEG);
		}
		else
		{
			_INT height=line_max[0].y-bord_u[line_max[0].i];
			change_max=correct_narrow_ends(line_max,&n_line_max,line_min,
				n_line_min,height,BEG);
		}
	}
	
	if (CONSTT*(bord_d[i_point[n_x-1]]-bord_u[i_point[n_x-1]])<=med_height
		//       || bord_d[i_point[n_x-1]]-bord_u[i_point[n_x-1]]>=CONSTT*med_height
		)
	{
		unsureness+=5;
		if (n_line_min<1 || n_line_max<1) goto TRANSFORM;
		if (line_min[n_line_min-1].x <= line_max[n_line_max-1].x)
		{
			_INT height =
				line_min[n_line_min-1].y-bord_d[line_min[n_line_min-1].i];
			change_min=correct_narrow_ends(line_min,&n_line_min,line_max,
				n_line_max,height,END);
		}
		else
		{
			_INT height =
				line_max[n_line_max-1].y-bord_u[line_max[n_line_max-1].i];
			change_max=correct_narrow_ends(line_max,&n_line_max,line_min,
				n_line_min,height,END);
		}
	}
	if (change_min==_TRUE)
	{
		smooth_u_bord(line_min,n_line_min,D,should,bord_u,bord_d) ;
#if PG_DEBUG
		DBG_picture3(D,bord_u,&n_call3_u);
#endif
	}
	if (change_max==_TRUE)
	{
		smooth_d_bord(line_max,n_line_max,D,should,bord_d);
#if PG_DEBUG
		DBG_picture3(D,bord_d,&n_call3_d);
#endif
	}
	
	
	if (change_min==_TRUE || change_max==_TRUE)
	{
		if (calc_med_heights(D,line_min,line_max,bord_u,bord_d,i_point,n_line_min,
			n_line_max,n_x,&med_height,&med_u_bord,&med_d_bord)
			!= SUCCESS)
			goto EXIT_FREE;
	}
	
	
	for (i=0, nonpos_height=_FALSE; i<D->ii; i++)
	{
		if (D->y[i]!=BREAK && bord_d[i]-bord_u[i]<=0)
			nonpos_height=_TRUE;
	}
	
	if (nonpos_height==_TRUE)
	{
		unsureness+=100;
		SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
			&n_call3_u,&n_call3_d,
#endif
			&n_x,0,line_max,n_line_max);
		goto TRANSFORM;
		
	}
#ifdef USE_WORDSPLIT_PARMS
	apr_height=D->rc->stroka.size_in;
	
	if (med_height<MIN_STR_HEIGHT
		||
		med_height>THREE(apr_height) && D->rc->stroka.size_sure_in >=75
		||
		med_height<ONE_THIRD(apr_height) &&
		(D->rc->stroka.size_sure_in >=90 && (n_line_max<=3 || n_line_min<=3) ||
		D->rc->stroka.size_sure_in >=75 && (n_line_max<=2 || n_line_min<=2)
		)
		||
		med_height<ONE_HALF(apr_height) &&
		D->rc->stroka.size_sure_in >=55 && (n_line_max<=1 || n_line_min<=1)
		)
		
	{
		unsureness+=100;
		SpecBord(D,bord_d,bord_u,&med_d_bord,&med_u_bord,&med_height,
#if PG_DEBUG
			&n_call3_u,&n_call3_d,
#endif
			&n_x,0,line_max,n_line_max);
		goto TRANSFORM;
		
	}
#else
	apr_height=0;
#endif /* USE_WORDSPLIT_PARMS */
	/***************************************************************************/
TRANSFORM:
	
	//CHE: experiment with narrowing of box-sized stroka:
	
	if  (   (n_allmax+n_allmin) <= 6
		&& med_height > THREE_FOURTH(dyAll)
		&& dyAll > 0
		)  
	{
		_INT dyChg = (med_height+3)/6;
		_INT dyBord, dyLocal;
		
		med_height -= 2*dyChg;
		med_u_bord += dyChg;
		med_d_bord -= dyChg;
		
		for (i=0; i<D->ii; i++)  
		{
			if (D->y[i] != BREAK)  
			{
				dyBord = bord_d[i] - bord_u[i];
				
				dyLocal = (_INT)( ((_LONG)dyChg * dyBord  +  (dyAll/2) ) / dyAll );
				if  ( dyLocal > dyChg )
					dyLocal = dyChg;
				
				bord_d[i]=(_SHORT)( bord_d[i] - dyLocal );
				bord_u[i]=(_SHORT)( bord_u[i] + dyLocal );
			}
		}
	}
	
	if (med_height<MIN_STR_HEIGHT)
	{
		{
			unsureness+=20;
			for (i=0; i<D->ii; i++)
			{
				if (D->y[i] != BREAK)
				{
					bord_d[i]=(_SHORT)(bord_d[i]+ONE_HALF(MIN_STR_HEIGHT));
					bord_u[i]=(_SHORT)(bord_u[i]-ONE_HALF(MIN_STR_HEIGHT));
				}
			}
				
				
			med_height+=MIN_STR_HEIGHT;
			med_u_bord-=ONE_HALF(MIN_STR_HEIGHT);
			med_d_bord+=ONE_HALF(MIN_STR_HEIGHT);
		}
#if PG_DEBUG
		DBG_picture3(D,bord_u,&n_call3_u);
		DBG_picture3(D,bord_d,&n_call3_d);
#endif
	}
#if 0
	//CHE experiment with shaking:
	if  ( D->rc->fl_fil )  
	{
		for (i=0; i<D->ii; i++)  
		{
			if  ( (bord_d[i] - bord_u[i]) > ONE_FOURTH(med_height) )
				bord_u[i] += ONE_EIGHTTH(med_height);
		}
#if  PG_DEBUG
		DBG_picture3(D,bord_u,&n_call3_u);
#endif
	}
#endif
	
#if 0
	if (D->ii > 0)
	{
		_INT   i, n, sum, valu, vald;
		_LONG  SXY=0, SY=0;
		_INT   nu, nd;
		_INT   a, b, A, B;
		_INT   Dx = (D->rc->stroka.box.right - D->rc->stroka.box.left);
		_INT   Dy = (D->rc->stroka.box.bottom - D->rc->stroka.box.top);
		
		if  ( FillRCNB(i_point, n_x, D, bord_u, bord_d)    /* AVP */
			== UNSUCCESS )
			goto  EXIT_FREE;   /*CHE*/
		
		for(i = 0, sum = 0, n = 0; i < D->ii; i ++) if (D->y[i] != BREAK) {sum += bord_u[i]; n ++;}
		valu = sum/n;
		// for(i = 0, sum = 0; i < D->ii; i ++) if (D->y[i] != BREAK) bord_u[i] = valu;
		
		for(i = 0, sum = 0, n = 0; i < D->ii; i ++) if (D->y[i] != BREAK) {sum += bord_d[i]; n ++;}
		vald = sum/n;
		// for(i = 0, sum = 0; i < D->ii; i ++) if (D->y[i] != BREAK) bord_d[i] = vald;
		
		for(i = 0; i < CB_NUM_VERTEX; i ++)
		{
			SXY += i*(_LONG)(((_INT)D->rc->curv_bord[2*i]+(_INT)D->rc->curv_bord[2*i+1])/2);
			SY  += (_LONG)((((_INT)D->rc->curv_bord[2*i]+(_INT)D->rc->curv_bord[2*i+1])/2));
		}
		
		b = (_INT)( 2*(2*(CB_NUM_VERTEX-1)+1)*SY - 6*SXY ) / (((CB_NUM_VERTEX-1)+1)*((CB_NUM_VERTEX-1)+2));
		a = (_INT)( 6*(2*SXY - (CB_NUM_VERTEX-1)*SY)) / ((CB_NUM_VERTEX-1)*((CB_NUM_VERTEX-1)+1)*((CB_NUM_VERTEX-1)+2));
		
		//  for(i=0; i < CB_NUM_VERTEX; i++)
		//   {
		//    rc->curv_bord[2*i+1] = (_UCHAR)(a*i+b);
		//   }
		
		if(Dx != 0)
		{
			A = (_INT)((((CB_NUM_VERTEX-1)*a*Dy) * 100) / (255L*Dx));
			B = (_INT)((D->rc->stroka.box.top + b*Dy/255L)*100 - A*D->rc->stroka.box.left);
		}
		else {A = 0; B = 100*(D->rc->stroka.box.top + D->rc->stroka.box.bottom)/2;}
		
		// n = med_height/2;
		n = vald - valu;
		if (n < Dy/4)   n = Dy/4;
		nu = nd = (n+1)/2;
		if (nu > Dy/4)  nu = Dy/4;
		
		for(i = 0; i < D->ii; i ++) if (D->y[i] != BREAK) bord_u[i] = (A*D->x[i] + B)/100 - nu;
		for(i = 0; i < D->ii; i ++) if (D->y[i] != BREAK) bord_d[i] = (A*D->x[i] + B)/100 + nd;
		
	}
#endif //0
	/***************************************************************************/
	/*  Fill RC field describing curved border: */
	if  ( FillRCNB(i_point, n_x, D, bord_u, bord_d)    /* AVP */
		== UNSUCCESS )
		goto  EXIT_FREE;   /*CHE*/
	
	/***************************************************************************/
	
	
	/*BEGINNING OF TRANSFORMATION*/
	if (n_ampl < 3)
	{
		bGuide = getCyBase(D->rc->pXrc, &upLine, &midLine);
	}

	if (D->rc->lmod_border_used==LMOD_BORDER_NUMBER)
	{
		for (i=0; i<D->ii; i++)
		{
			if (D->y[i] == BREAK) continue;
			D->y[i]=(_SHORT)(STR_UP+
				(_LONG)(STR_DOWN-STR_UP)*
				(D->y[i]-bord_u[i])/
				HWRMax(1,bord_d[i]-bord_u[i]));
		}
	}
	else
	{
		for (i=0; i<D->ii; i++)
		{
			if (D->y[i] == BREAK) continue;

			if (bGuide)
			{
				bord_d[i] = midLine;
				bord_u[i] = upLine;
				med_height = bord_d[i] - bord_u[i];
			}

			if (D->y[i]<=bord_d[i] && D->y[i]>=bord_u[i])
			{
				D->y[i]=(_SHORT)(STR_UP+
					(_LONG)(STR_DOWN-STR_UP)*
					(D->y[i]-bord_u[i])/
					HWRMax(1,bord_d[i]-bord_u[i]));
				continue;
			}
			if (D->y[i]>bord_d[i])
			{
				D->y[i]=(_SHORT)(STR_DOWN+
					(_LONG)(STR_DOWN-STR_UP)*
					(D->y[i]-bord_d[i])/
					HWRMax(1,med_height));
				continue;
			}
			if (D->y[i]<bord_u[i])
				D->y[i]=(_SHORT)(STR_UP+
				(_LONG)(STR_DOWN-STR_UP)*
				(D->y[i]-bord_u[i])/
				HWRMax(1,med_height));
		}
	}
	
	for (i=0; i<D->ii; i++)
	{
		if (D->y[i] != BREAK)
		{
			D->x[i]=(_SHORT)((STR_DOWN-STR_UP)+
				(_LONG)(STR_DOWN-STR_UP)*
				(D->x[i]-D->box.left)/
				HWRMax(1,med_height));
		}
	}
	
	D->rc->stroka.size_out =(_SHORT)med_height;
	D->rc->stroka.dn_pos_out =(_SHORT)med_d_bord;
	D->rc->stroka.size_sure_out=D->rc->stroka.pos_sure_out=0;
	
	if (unsureness<100 && n_line_min>=1 && n_line_max>=1)
		D->rc->stroka.size_sure_out=45;
	if (unsureness<100 && n_line_min>=2 && n_line_max>=2)
		D->rc->stroka.size_sure_out=50;
	if (unsureness<10 && n_line_min>=3 && n_line_max>=3)
		D->rc->stroka.size_sure_out=55;
	if (unsureness<10 && n_line_min>=4 && n_line_max>=4)
		D->rc->stroka.size_sure_out=75;
	if (unsureness==0 && n_line_min>=5 && n_line_max>=5)
		D->rc->stroka.size_sure_out=90;
	
	if (unsureness<100 && n_line_max>=1)
		D->rc->stroka.pos_sure_out=45;
	if (unsureness<100 && n_line_max>=2)
		D->rc->stroka.pos_sure_out=50;
	if (unsureness<10 && n_line_max>=3)
		D->rc->stroka.pos_sure_out=55;
	if (unsureness<10 && n_line_max>=4)
		D->rc->stroka.pos_sure_out=75;
	if (unsureness==0 && n_line_max>=5)
		D->rc->stroka.pos_sure_out=90;
	
	
	for (i=0,dev_abs_sum=0,np=0; i<D->ii; i++)
	{
		if (D->y[i] != BREAK)
		{
			dev_abs_sum+=HWRAbs(bord_d[i]-med_d_bord);
			np++;
		}
	}

	if (np > 0)
		mid_dev=(_INT)(dev_abs_sum/np);
	else
		mid_dev=(_INT)(dev_abs_sum);

	if (mid_dev>=TWO_FIFTH(med_height))
	{
		//       SetTesterMark();
		if (D->rc->stroka.pos_sure_out>=50)
			D->rc->stroka.pos_sure_out=50;
	}
	
	/*case of LMOD_BOX_EDIT*/
	if (D->rc->stroka.pos_sure_in==100 && D->rc->stroka.size_sure_in==100)
		D->rc->stroka.size_sure_out=D->rc->stroka.pos_sure_out=0;
	
	
	/***************************************************************************/
	/*  Fill RC field describing curved border: */
	if  ( FillRCNB(i_point, n_x, D, bord_u, bord_d)    /* AVP */
		== UNSUCCESS )
		goto  EXIT_FREE;   /*CHE*/
	
	/***************************************************************************/
	
#if  PG_DEBUG
	if  ( mpr>0 || mpr==-15 )  
	{
		printw( "\nStroka: Size=%d(%d); Dn_pos=%d(%d)",
			(int)D->rc->stroka.size_out, (int)D->rc->stroka.size_sure_out,
			(int)D->rc->stroka.dn_pos_out, (int)D->rc->stroka.pos_sure_out );
	}
#endif
	
	retval = SUCCESS;
	
EXIT_FREE:;
	if (retval == UNSUCCESS)
		err_msg("No mem for TRANSN or some error occured.");
		  
	if (mem_segm!=_NULL)
		HWRMemoryFree(mem_segm);

	if (ampl!=_NULL) 
		HWRMemoryFree(ampl);

	return(retval);
}

/***************************************************************************/



_INT extract_all_extr(low_type _PTR D, _UCHAR TYPE, p_EXTR line_extr,
       p_INT pn_all_extr, p_INT pn_line_extr, p_SHORT pshift)
{
	p_SPECL	cur=D->specl,wrk;
	_INT	i=0,j,i_extr,ibeg_str = UNDEF,iend_str,shift = 0,dshift = 0;
	p_SHORT	x=D->buffers[0].ptr,
			y=D->buffers[1].ptr,
			i_back=D->buffers[2].ptr;
	_RECT stroke_box, prv_stroke_box;
	
	stroke_box.top=0;
	stroke_box.bottom=0;
	stroke_box.left=0;
	stroke_box.right=0;
	*pn_all_extr=0;
	
	while (cur != _NULL)
	{
		if (cur->mark==BEG)
		{
			ibeg_str=cur->ibeg;
			prv_stroke_box=stroke_box;
		}
		
		if (cur->mark == TYPE &&
			(cur->attr==NORM || cur->attr==I_MIN || cur->attr==T_MIN ||
			cur->attr==PUNC)
			)
			(*pn_all_extr)++;
		
		if (cur->mark == TYPE && cur->code!=NOT_ON_LINE &&
			(cur->attr==NORM || cur->attr==I_MIN ||
			cur->code==RET_ON_LINE)
			)
		{
			if (i>=MAX_NUM_EXTR)
			{
				err_msg("Too many extrs");
				return(UNSUCCESS);
			}
			
			i_extr=cur->ipoint0;
			line_extr[i].x=x[i_extr];
			line_extr[i].y=y[i_extr];
			line_extr[i].i=i_back[i_extr];
			line_extr[i].susp=0;
			line_extr[i].pspecl=cur;
			
			if (cur->code!=RET_ON_LINE) 
				cur->code=ON_LINE;
			
			i++;
		}
		
		if (cur->mark==END && cur->attr!=PUNC && ibeg_str != UNDEF)
		{
			iend_str=cur->iend;
			GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str, &stroke_box);
			
			if (prv_stroke_box.right != 0)
				dshift=TWO_THIRD(stroke_box.left - prv_stroke_box.right);
			
			if (dshift>0)
				shift+=dshift;
			
			cur->attr=(_UCHAR)shift;
			wrk=cur->prev;
			j=i;
			
			while (wrk->mark!=BEG)
			{
				if (wrk->mark == TYPE &&
					(wrk->attr==NORM || wrk->attr==I_MIN ||
					wrk->code==RET_ON_LINE)
					)
			
					line_extr[--j].shift=(_SHORT)shift;
				
				wrk=wrk->prev;
			}
		}
		
		if (cur->next==_NULL) 
			*pn_line_extr=i;
		
		cur=cur->next;
	}
	
	*pshift=(_SHORT)shift;
	
	return(SUCCESS);
}

/***************************************************************************/

_INT extract_num_extr(low_type _PTR D, _UCHAR TYPE, p_EXTR line_extr,
					  p_INT p_all_extr)
{
	p_SPECL cur=D->specl,wrk;
	_INT i, i_extr,ibeg_str = UNDEF,iend_str,extr_height;
	p_SHORT x=D->buffers[0].ptr,
		y=D->buffers[1].ptr,
		i_back=D->buffers[2].ptr;
	_RECT stroke_box;
	
	*p_all_extr = i = 0;

	while (cur != _NULL)
	{
		if (cur->mark==BEG)
			ibeg_str=cur->ibeg;
		
		if (cur->mark==END &&
			ibeg_str != UNDEF && 
			(cur->attr==NORM || cur->attr==STRT ||
			cur->attr==FOUR_TYPE && TYPE==MINW)
			)
		{
			iend_str=cur->iend;
			GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);
			
			extr_height = (TYPE==MINW) ? stroke_box.top : stroke_box.bottom;
			
			wrk=cur;
			
			while (wrk->mark!=BEG)
			{
				if (wrk->mark==TYPE && y[wrk->ipoint0]==extr_height)
				{
					if (i>=MAX_NUM_EXTR)
					{
						err_msg("Too many extrs");
						return(UNSUCCESS);
					}
					wrk->attr=cur->attr;
					i_extr=wrk->ipoint0;
					line_extr[i].x=x[i_extr];
					line_extr[i].y=y[i_extr];
					line_extr[i].i=i_back[i_extr];
					line_extr[i].susp=0;
					line_extr[i].pspecl=wrk;
					wrk->code=ON_LINE;
					i++;
					break;
				}
				wrk=wrk->prev;
			}
		}
		
		if (cur->next==_NULL) *p_all_extr=i;
		cur=cur->next;
	}
	return(SUCCESS);
}

/***************************************************************************/


_INT classify_strokes(low_type _PTR D,_INT med_ampl,_INT max_ampl,
					  _INT n_ampl,p_INT pt_height,p_INT pft_height,p_BOOL psep_let)
{
	p_SHORT x=D->buffers[0].ptr,
		y=D->buffers[1].ptr;
	p_SPECL cur=D->specl, wrk,prv,nxt,beg;
	_INT  ibeg_str=0, iend_str=0, prv_ibeg_str, prv_iend_str, n_str=0,
		thresh=D->rc->stroka.extr_depth,n_min = 0,n_max = 0,height,tmin;
	_RECT stroke_box, prv_stroke_box;
	_UCHAR prv_attr=0,epunct=0, lpunct=0;
	
	_BOOL is_t_min(p_SPECL min,p_SHORT x,p_SHORT y,_RECT stroke_box,_INT thresh,
		_INT ibeg_str,_INT iend_str, _UCHAR pass,p_INT pheight);
	
	
	prv_stroke_box.top      = 0;
	prv_stroke_box.bottom   = 0;
	prv_stroke_box.left     = 0;
	prv_stroke_box.right    = 0;
	
	*psep_let=_TRUE;

	while (cur!=_NULL)
	{
		if (cur->mark==BEG) 
			n_min = n_max = 0;
		else
		if (cur->mark==MINW) 
			n_min++;
		else
		if (cur->mark==MAXW) 
			n_max++;
		else
		if (cur->mark==END)
		{
			n_str++;
			if (n_min>3 || n_max>3) *psep_let=_FALSE;
		}

		cur=cur->next;
	}
	
	cur=D->specl;
	while (cur!=_NULL)
	{
		prv=cur->prev;
		nxt=cur->next;
		
		if (cur->mark == BEG)
		{
			prv_ibeg_str=ibeg_str;
			prv_iend_str=iend_str;
			ibeg_str=cur->ibeg;
			cur=cur->next;
			continue;
		}
		
		//      if (cur->mark==MINW) n_min++;
		
		if (cur->mark==MINW || cur->mark==MAXW)
		{
			cur->attr=NORM;
			cur->code=0;
		}
		
		/*      if (cur->mark==MINW && n_min>3 &&
		x[cur->iend]-x[cur->ibeg]>HWRMax(y[cur->ibeg],y[cur->iend])-y[cur->ipoint0])
		cur->attr=NON_SUPER;
		*/
		if (!(D->rc->low_mode & LMOD_SMALL_CAPS) && cur->mark==MINW &&
			nxt->mark==MAXW && prv_attr==HOR_STR &&
			is_t_min(cur,x,y,prv_stroke_box,thresh,prv_ibeg_str,prv_iend_str,0,
			&height)==_TRUE
			)
		{
			cur->attr=T_MIN;
			*pft_height=HWRMax(*pft_height,height);
			if (x[cur->iend]-x[cur->ibeg]>-thresh)
				*pt_height=HWRMax(*pt_height,height);
		}
		
		if (cur->mark==MAXW && prv != _NULL && prv->mark==BEG)
		{
			if (prv->prev != _NULL && prv->prev->prev==_NULL && n_ampl>5
				
#ifndef FOR_GERMAN
				&& nxt != NULL && nxt->next != NULL 
				&& nxt->next->mark==MAXW && y[nxt->next->ipoint0]>y[cur->ipoint0]
#endif
				||
				nxt != _NULL && nxt->mark==MINW && y[cur->ipoint0]-y[nxt->ipoint0] <
				HWRMax(med_ampl,MIN_STR_HEIGHT)
				)
				cur->attr=BEG_MAX;
		}
		
		if (cur->mark==MAXW && nxt->mark==END)
		{
			if (prv->mark==MINW &&
#ifdef FOR_GERMAN
				(y[cur->ipoint0]-y[prv->ipoint0]<MIN_STR_HEIGHT
				||
				10L*(y[cur->ipoint0]-y[prv->ipoint0]) <= max_ampl
				||
				8L*(y[cur->ipoint0]-y[prv->ipoint0]) <= max_ampl &&
				HWRAbs(x[cur->iend]-x[cur->ibeg]) < THREE_FOURTH(med_ampl)
				//          y[cur->ipoint0]-y[prv->ipoint0]
				)
#else
				y[cur->ipoint0]-y[prv->ipoint0] <=
				HWRMax(ONE_EIGHTTH(max_ampl),MIN_STR_HEIGHT)
#endif
				)
				cur->attr=END_MAX;
		}
		
		if (cur->mark==MINW && nxt->mark==END)
		{
			if ( prv->mark==MAXW &&
				y[prv->ipoint0]-y[cur->ipoint0] < HWRMax(med_ampl,MIN_STR_HEIGHT)
#ifdef FOR_GERMAN
				&& x[cur->iend]-x[cur->ibeg] < THREE_FOURTH(med_ampl)
#endif
				)
				cur->attr=END_MIN;
			if (nxt->next==_NULL || x[cur->iend]<=D->box.left+thresh ||
				x[cur->iend]>=D->box.right-thresh)
			{
				_INT begLocal=prv->ipoint0, end=cur->iend;
				_INT iMostFar=iMostFarFromChord(x,y,(_SHORT)begLocal,(_SHORT)end);
				/*04_14*/   _LONG MaxScal=(x[iMostFar]-x[begLocal])*(_LONG)(y[begLocal]-y[end])+
				(y[iMostFar]-y[begLocal])*(_LONG)(x[end]-x[begLocal]);
				if (MaxScal>0)
					cur->attr=END_MIN;
			}
			
			if ( prv->mark==MAXW && x[prv->ipoint0] > x[cur->ipoint0] &&
				x[prv->ibeg]>x[prv->iend]
				)
				cur->attr=S_MIN;
		}
		if (cur->mark==MINW && prv->mark==BEG)
		{
			if (nxt->mark==MAXW &&
				(y[nxt->ipoint0]-y[cur->ipoint0] <= ONE_EIGHTTH(max_ampl) &&
				y[nxt->ipoint0]-y[cur->ipoint0] <=ONE_HALF(med_ampl))
				||
				y[nxt->ipoint0]-y[cur->ipoint0] <= MIN_STR_HEIGHT
				)
				cur->attr=BEG_MIN;
		}
		
		if (cur->mark==MINW && prv->mark==MAXW && x[prv->ipoint0]>=x[cur->ipoint0]
			&& x[prv->iend]<x[prv->ibeg] &&
			nxt->mark==MAXW && x[nxt->ipoint0]>=x[cur->ipoint0] &&
			x[nxt->iend]>x[nxt->ibeg] &&
			HWRMax(y[nxt->ipoint0],y[prv->ipoint0])-y[cur->ipoint0] <
			ONE_THIRD(max_ampl) && prv->prev->mark==MINW
			//          && (prv->prev->prev->mark==MAXW || prv->prev->prev->prev==_NULL) //03_21
			)
			cur->attr=S_MIN;
		
		
		if (cur->mark==MAXW && prv->mark==MINW && prv->prev->mark==MAXW )
		{
			p_SPECL pmax=prv->prev;
			if (4L*y[pmax->ipoint0]>5L*(y[cur->ipoint0])-(y[prv->ipoint0])
				&& x[pmax->ibeg]<x[pmax->iend]
				&& x[prv->ibeg]>x[prv->iend]
				&& x[pmax->ibeg]<x[cur->ipoint0]
				&& x[pmax->iend]+thresh>x[cur->ibeg]
				&& x[prv->ibeg]+thresh>x[cur->ibeg]
				)
				cur->attr=O_MAX;
		}
		
		if (cur->mark==MAXW && nxt->mark==MINW && nxt->next->mark==MAXW)
		{
			p_SPECL pmax=nxt->next;
			if (y[pmax->ipoint0]>y[cur->ipoint0] &&
				x[pmax->ibeg]<x[cur->ipoint0] && x[pmax->iend]>x[cur->ipoint0] &&
				x[nxt->ibeg]>x[cur->ipoint0] && x[nxt->iend]<x[cur->ipoint0]
				)
			{
				cur->attr=E_MAX;
#ifdef FOR_GERMAN
				if (prv->mark==MINW && prv->prev->mark==BEG &&
					y[prv->ipoint0]>y[nxt->ipoint0] &&
					x[prv->ipoint0]<x[cur->ipoint0] &&
					x[prv->ipoint0]>HWRMin(x[nxt->iend],x[pmax->ibeg])
					)
					prv->attr=E_MIN;
#endif
			}
		}
		if (cur->mark==END)
		{
			//         n_str++;
			prv_attr=0;
			cur->attr=0;
			iend_str=cur->iend;
			GetTraceBox ( x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&stroke_box);
			
			/*
			punct=is_punct();
			if (punct!=0)
			{
			wrk=cur;
			while (wrk->mark!=BEG)
			{
			if (wrk->mark==MINW || wrk->mark==MAXW)
			{
			wrk->attr=punct;
			}
			wrk=wrk->prev;
			}
			}
			*/
			
			if (is_umlyut(cur,stroke_box,ibeg_str,iend_str,x,y,med_ampl)==_TRUE)
			{
				cur->attr=UML;
				wrk=cur;
				while (wrk->mark!=BEG)
				{
					if (wrk->mark==MINW || wrk->mark==MAXW)
						wrk->attr=UML;
					wrk=wrk->prev;
				}
			}
			
			if (hor_stroke(cur,x,y,n_str)==_TRUE)
			{
				cur->attr=HOR_STR;
				prv_attr=HOR_STR;
				wrk=cur;
				while (wrk->mark!=BEG)
				{
					if (wrk->mark==MINW || wrk->mark==MAXW)
						wrk->attr=HOR_STR;
					wrk=wrk->prev;
				}
				if (!(D->rc->low_mode & LMOD_SMALL_CAPS))
				{
					beg=wrk;
					wrk=wrk->prev;
					tmin=0;
					while (wrk!=_NULL /*&& wrk->mark!=BEG*/)
					{
						if (wrk->mark==MINW &&
							is_t_min(wrk,x,y,stroke_box,thresh,ibeg_str,iend_str,0,&height)==_TRUE)
						{
							wrk->attr=T_MIN;
							tmin++;
							*pft_height=HWRMax(*pft_height,height);
							if (x[wrk->iend]-x[wrk->ibeg]>-thresh)
								*pt_height=HWRMax(*pt_height,height);
						}
						wrk=wrk->prev;
					}
					if (tmin==0)
					{
						wrk=beg;
						while (wrk!=_NULL /*&& wrk->mark!=BEG*/)
						{
							if (wrk->mark==MINW &&
								is_t_min(wrk,x,y,stroke_box,thresh,ibeg_str,iend_str,1,&height)==_TRUE)
							{
								wrk->attr=T_MIN;
								*pft_height=HWRMax(*pft_height,height);
								if (x[wrk->iend]-x[wrk->ibeg]>-thresh)
									*pt_height=HWRMax(*pt_height,height);
							}
							wrk=wrk->prev;
						}
					}
				}
			}
			
			if (is_i_point(D,cur,stroke_box,med_ampl)==_TRUE)
			{
				cur->attr=PNT;
				wrk=cur;
				while (wrk->mark!=BEG)
				{
					if (wrk->mark==MINW || wrk->mark==MAXW)
						wrk->attr=PNT;
					wrk=wrk->prev;
				}
			}
			
			if (cur->prev->mark==BEG &&
				stroke_box.right-stroke_box.left<thresh
				)
				cur->attr=PNT;
			
			prv_stroke_box = stroke_box;
		}
		
		if (cur->next==_NULL) 
			break;

		cur=cur->next;
	}

	epunct=0;
	if (n_str>1)  epunct=end_punct(D,cur,med_ampl);
	if (epunct!=0)
	{
		wrk=cur;
		wrk->attr=PUNC;
		while (wrk->mark!=BEG)
		{
			if (wrk->mark==MINW || wrk->mark==MAXW)
			{
				wrk->attr=PUNC;
			}
			wrk=wrk->prev;
		}
		if (n_str>2 && epunct==2)
		{
			wrk=wrk->prev;
			wrk->attr=PUNC;
			while (wrk->mark!=BEG)
			{
				if (wrk->mark==MINW || wrk->mark==MAXW)
				{
					wrk->attr=PUNC;
				}
				wrk=wrk->prev;
			}
		}
	}
	lpunct=0;
	if (n_str-epunct>1) lpunct=lead_punct(D);
	if (lpunct!=0)
	{
		wrk=D->specl;
		while (wrk->mark!=END)
		{
			if (wrk->mark==MINW || wrk->mark==MAXW)
			{
				wrk->attr=PUNC;
			}
			wrk=wrk->next;
		}
		wrk->attr=PUNC;
		if (n_str-epunct>2 && lpunct==2)
		{
			wrk=wrk->next;
			while (wrk->mark!=END)
			{
				if (wrk->mark==MINW || wrk->mark==MAXW)
				{
					wrk->attr=PUNC;
				}
				wrk=wrk->next;
			}
			wrk->attr=PUNC;
		}
	}


	return(n_str);
}

/***************************************************************************/

_BOOL is_t_min(p_SPECL min,p_SHORT x,p_SHORT y,_RECT stroke_box,_INT thresh,
               _INT ibeg_str,_INT iend_str, _UCHAR pass,p_INT pheight)
{
  _INT min_pnt=min->ipoint0;
  p_SPECL max = (min->next->mark==MAXW) ?
                   min->next : min->prev;
  _INT max_pnt=max->ipoint0;
  _SHORT x1=x[min->iend], y1=y[min->ipoint0], x2=x[max->ibeg],
         y2=y[max->ipoint0], x3=x[ibeg_str], y3=y[ibeg_str],
         x4=x[iend_str], y4=y[iend_str];
  if (HWRAbs(x[min->iend]-x[min->ibeg])</*2**/thresh
//      && THREE_FOURTH(y[max_pnt])+ONE_FOURTH(y[min_pnt])>
//      ONE_HALF(stroke_box.bottom+stroke_box.top)
      &&                                                     /*case of "t"*/
      (is_cross(x1,y1,x2,y2,x3,y3,x4,y4)==_TRUE
       ||
       pass==1 &&
       y[min_pnt] < stroke_box.bottom &&
       y[max_pnt] > stroke_box.bottom &&
       x[min_pnt]<stroke_box.right+thresh &&
       x[min_pnt]>stroke_box.left-thresh
      )
     )
  {
     *pheight=y2-y1;
     return(_TRUE);
  }
  else
     if (x[min->iend]-x[min->ibeg]<0 &&                     /*case of "f"*/
         THREE_FOURTH(y[min_pnt])+ONE_FOURTH(y[max_pnt])<
         ONE_HALF(stroke_box.bottom+stroke_box.top) &&
         is_cross(x1,y1,x2,y2,x3,y3,x4,y4)==_TRUE
        )
	 {
		 // Comment by Ahmad abulKader 04/25/00
		 // The following line of code was added to set the value
		 // of *pheight. Not setting its value and returning TRUE was causing an 
		 // inconsistent behaviour and differences between debug and release. 
		 // I just copied the value used to set *pheight from the prev. if statment. 
		 // TBD: We should try to understand the real use of the function.
		*pheight=y2-y1;
        return(_TRUE);
	 }
  return(_FALSE);      
}


/***************************************************************************/

_INT classify_num_strokes(low_type _PTR D, p_INT pmed_ampl)
{
	p_SPECL cur=D->specl,wrk,prv_end;
	_INT ibeg_str=0,iend_str=0,ibeg_prv,iend_prv,
		dx,dy,iLeft,y_up,y_down,
		com_or_brkt,num_of_str=0,num_of_line_str=0,n_ext,
		thresh=D->rc->stroka.extr_depth;
	_SHORT  x_cross,y_cross,x1,y1,x2,y2,x3,y3,x4,y4;
	p_SHORT x=D->buffers[0].ptr,
		y=D->buffers[1].ptr;
	_UCHAR attr=0,prev_attr;
	_LONG  sum_height=0, sum_line_height=0;
	_RECT  box, prv_box;
	_BOOL straight;
	
	box.bottom   = 0;
	box.top      = 0;
	box.left     = 0;
	box.right    = 0;

	ibeg_prv	=	ibeg_str;
	iend_prv	=	iend_str;
	x1			=	x[ibeg_str];
	y1			=	y[ibeg_str];
	prev_attr	=	attr;
	
	while (cur!=_NULL)
	{
		if (cur->mark==BEG)
		{
			ibeg_prv=ibeg_str;
			iend_prv=iend_str;
			if (iend_prv!=0) prv_box=box;
			prv_end=cur->prev;
			ibeg_str=cur->ibeg;
			x1=x[ibeg_str];
			y1=y[ibeg_str];
			prev_attr=attr;
			attr=NORM;
			cur=cur->next;
			continue;
		}
		
		if (cur->mark==END)
		{
			iend_str=cur->iend;
			GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&box);
			num_of_str++;
			sum_height+=box.bottom-box.top;
			if (cur->prev->mark==BEG && box.right-box.left < thresh
				//              || 10L*(box.bottom-box.top)<D->box.bottom-D->box.top
				)
			{
				attr=cur->attr=PNT;
				cur=cur->next;
				continue;
			}
			x2=x[iend_str];
			y2=y[iend_str];
			straight=straight_stroke(ibeg_str,iend_str,x,y,7);
			if (straight==_TRUE || hor_stroke(cur,x,y,1)==_TRUE)
			{
				attr=STRT;
				dx=x2-x1;
				dy=y2-y1;
				if (HWRAbs(dy)<=HWRAbs(dx)) attr=HOR;
				if (prev_attr==STRT || prev_attr==HOR)
				{
					x3=x[ibeg_prv];
					y3=y[ibeg_prv];
					x4=x[iend_prv];
					y4=y[iend_prv];
					if (is_cross(x1,y1,x2,y2,x3,y3,x4,y4)==_TRUE)
						attr=OPER;
				}
				if (attr==STRT && (prev_attr==NORM || prev_attr==L_BRKT))
				{
					iLeft =(_SHORT)ixMin((_SHORT)ibeg_prv,(_SHORT)iend_prv,x,y);
					x3=x[iLeft];
					y3=y[iLeft];
					x4=x[iend_prv];
					y4=y[iend_prv];
					
					y_down=HWRMax(y1,y2);
					y_up=HWRMin(y1,y2);
					if (FindCrossPoint(x1,y1,x2,y2,x3,y3,x4,y4,&x_cross,&y_cross)
						==_TRUE)
					{
						if (y_cross <= THREE_FOURTH(y_down)+ONE_FOURTH(y_up) &&
							y_cross >= THREE_FOURTH(y_up)+ONE_FOURTH(y_down)
							)
							attr=FOUR_TYPE;
					}
					else
					{
						_LONG threshLocal=(_LONG)(D->rc->stroka.extr_depth);
						if (
							QDistFromChord(x1,y1,x2,y2,x4,y4) <= THREE(threshLocal*threshLocal)
							)
						{
							wrk=prv_end;
							n_ext=0;
							while (wrk->prev->mark!=BEG)
							{
								if (wrk->mark==MINW || wrk->mark==MAXW)
									n_ext++;
								wrk=wrk->prev;
							}
							if (++n_ext<=3 && wrk->mark==MINW &&
								HWRAbs(x[wrk->ibeg]-x[wrk->iend])<=
								HWRAbs(y[wrk->ibeg]-y[wrk->iend]) &&
								y4 <= THREE_FOURTH(y_down)+ONE_FOURTH(y_up) &&
								y4 >= THREE_FOURTH(y_up)+ONE_FOURTH(y_down)
								)
								attr=FOUR_TYPE;
						}
					}
				}
			}
			
			if (straight==_FALSE)
			{
				com_or_brkt=
					curve_com_or_brkt(D,cur,ibeg_str,iend_str,7,LMOD_BORDER_NUMBER);
				if (com_or_brkt==1)
					attr=L_BRKT;
				if (com_or_brkt==-1)
					attr=R_BRKT;
				if (com_or_brkt<0 && prev_attr!=0 &&
					y1>TWO_THIRD(prv_box.top)+ONE_THIRD(prv_box.bottom)
					)
					attr=COM;
			}
			
			
			if (attr==FOUR_TYPE) cur->attr=NORM;
			else                 cur->attr=attr;
			/*          wrk=cur;
			while (wrk->mark!=BEG)
			{
			if (wrk->mark==MINW || wrk->mark==MAXW)
			wrk->attr=cur->attr;
			wrk=wrk->prev;
			}
			*/
			if (attr==OPER || attr==FOUR_TYPE)
			{
				wrk=cur->prev;
				while (wrk->mark!=END)
					wrk=wrk->prev;
				wrk->attr=attr;
				/*           while (wrk->mark!=BEG)
				{
				if (wrk->mark==MINW || wrk->mark==MAXW)
				wrk->attr=attr;
				wrk=wrk->prev;
				}
				*/
			}
			if (cur->attr==NORM || cur->attr==STRT)
			{
				num_of_line_str++;
				sum_line_height+=box.bottom-box.top;
			}
		}	
	
		cur=cur->next;
	}

	if (pmed_ampl!=_NULL)
	{
		if (num_of_line_str!=0)
			*pmed_ampl=(_INT)(sum_line_height/num_of_line_str);
		else
		if (num_of_str!=0)
			*pmed_ampl=(_INT)(sum_height/num_of_str);
	}

	return(num_of_str);
}


/***************************************************************************/
_INT extract_ampl(low_type _PTR D,p_SHORT ampl,p_INT pn_ampl)
{
   p_SPECL cur=D->specl, prv, nxt;
  _INT i, y_MIN, y_MAX;
   p_SHORT y=D->buffers[1].ptr;

   *pn_ampl = i = 0;

   while (cur != _NULL)
   {
      if (cur->mark==MINW && (cur->attr==NORM || cur->attr==I_MIN ||
                             cur->attr==STRT)
         )
      {
         y_MIN = y[cur->ipoint0];
         prv=cur->prev;
         nxt=cur->next;
         if (prv->mark==MAXW)
         {
            if (i>=2*MAX_NUM_EXTR)
            {
               err_msg("Too many ampl");
               return(UNSUCCESS);
            }

            y_MAX = y[prv->ipoint0];
            ampl[i++]=(_SHORT)(y_MAX-y_MIN);
         }
         if (nxt->mark==MAXW)
         {
            if (i>=2*MAX_NUM_EXTR)
            {
               err_msg("Too many ampl");
               return(UNSUCCESS);
            }
            y_MAX = y[nxt->ipoint0];
            ampl[i++]=(_SHORT)(y_MAX-y_MIN);
         }
      }

      if (cur->next==_NULL) 
		  *pn_ampl=i;

      cur=cur->next;
   }

   return(SUCCESS);
}

#pragma optimize( "g", off )
/***************************************************************************/
_INT calc_mediana(p_SHORT array, _INT n_arg)
{
	_INT	i, k, mediana, sign, vol_med_level, 
			vol_medNew_level = 0, wdif = ALEF, wdifNew,
			n_lower, n_greater;
	
	if (n_arg <= 0)
		return (UNSUCCESS);
	
	mediana = calc_average(array,n_arg);
	
	for (i=0,n_lower=0,n_greater=0; i<n_arg; i++)
	{
		if (array[i] < mediana)
			n_lower++;
		
		if (array[i] > mediana)
			n_greater++;
	}
	
	if (n_greater==n_lower) 
		return(mediana);

	if (n_greater>n_lower)  
		sign=1;
	else                    
		sign=-1;

	while (sign*(n_greater-n_lower)>0)
	{
		vol_med_level=0;
		wdif=ALEF;

		for (k=0; k<n_arg; k++)
		{
			wdifNew = sign*(array[k]-mediana);

			if ( wdifNew == wdif )
				vol_medNew_level++;

			if ( wdifNew>0  &&  wdifNew < wdif )
			{
				vol_medNew_level=1;
				wdif = wdifNew;
			}

			if (wdifNew == 0)
				vol_med_level++;
		}

		if (wdif == ALEF) 
			return(mediana);

		mediana += sign*wdif;

		if (sign==1)
		{
			n_lower+=vol_med_level;
			n_greater-=vol_medNew_level;
		}
		else
		{
			n_greater+=vol_med_level;
			n_lower-=vol_medNew_level;
		}
	}

	if (wdif == ALEF) 
		return(mediana);
	
	if (sign*(n_lower-n_greater) < vol_medNew_level) 
		return(mediana);

	if (sign*(n_lower-n_greater) > vol_medNew_level) 
		mediana-=sign*wdif;

	if (sign*(n_lower-n_greater) == vol_medNew_level) 
		mediana-=ONE_HALF(sign*wdif);
	
	return(mediana);
}
/***************************************************************************/
#pragma optimize( "", on )

_UCHAR end_punct(low_type _PTR D,p_SPECL cur,_INT med_ampl)
{
	_INT ibeg_str,iend_str,ibeg_prv_str,iend_prv_str;
	_INT thresh=D->rc->stroka.extr_depth;
	p_SHORT  x=D->buffers[0].ptr,
		y=D->buffers[1].ptr;
	_RECT lst_box ,prv_box;
	p_SPECL wrk, prv_end;
	iend_str=cur->iend;
	wrk=cur->prev;

	while (wrk->mark!=BEG) wrk=wrk->prev;

	ibeg_str=wrk->ibeg;

	GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&lst_box);

	wrk=wrk->prev;
	prv_end=wrk;
	iend_prv_str=wrk->iend;
	while (wrk->mark!=BEG) wrk=wrk->prev;
	ibeg_prv_str=wrk->ibeg;

	GetTraceBox(x,y,(_SHORT)ibeg_prv_str,(_SHORT)iend_prv_str,&prv_box);

	if (pnt(lst_box,med_ampl)==_TRUE)
	{
		if (pnt(prv_box,med_ampl)==_TRUE && HWRAbs(lst_box.left-prv_box.left)<
			D->rc->stroka.extr_depth && (lst_box.top>prv_box.bottom ||
			lst_box.bottom<prv_box.top)               /*double points*/
			)
			return (2);
		if (str_com(ibeg_prv_str,iend_prv_str,x,y,5)==_TRUE &&      /*excl. mark*/
			lst_box.top>prv_box.bottom &&
			(HWRAbs(lst_box.right-prv_box.left)<D->rc->stroka.extr_depth ||
			HWRAbs(lst_box.left-prv_box.right)<D->rc->stroka.extr_depth)
			)
			return(2);
		if (lst_box.top>prv_box.bottom &&                   /*quest. mark*/
			lst_box.right<prv_box.right &&
			lst_box.left>prv_box.left
			)
			return(2);
		
		return(1);
	}
	if (com(D,cur,ibeg_str,iend_str,5)==_TRUE
		//       && lst_box.top>TWO_THIRD(D->box.top)+ONE_THIRD(D->box.bottom)
		)
	{
		if (pnt(prv_box,med_ampl)==_TRUE &&               /*pnt-comma*/
			lst_box.top>prv_box.bottom &&
			prv_box.right<lst_box.right+thresh &&
			prv_box.right>lst_box.left-thresh
			)
			return(2);
		if (pnt(prv_box,med_ampl)==_TRUE &&
			prv_box.top>lst_box.bottom &&                   /*quest. mark*/
			prv_box.right<lst_box.right+thresh &&
			prv_box.right>lst_box.left-thresh
			)
			return(2);
	}
	
	if (com(D,cur,ibeg_str,iend_str,5)==_TRUE &&
		lst_box.bottom<ONE_HALF(D->box.top)+ONE_HALF(D->box.bottom)
		)
	{
		if (com(D,prv_end,ibeg_prv_str,iend_prv_str,5)==_TRUE &&
			prv_box.bottom<ONE_HALF(D->box.top)+ONE_HALF(D->box.bottom)
			)
			return(2);
		else
			return(1);
	}
	
	if (com(D,cur,ibeg_str,iend_str,5)==_TRUE &&
		lst_box.top>TWO_THIRD(D->box.top)+ONE_THIRD(D->box.bottom)
		)
		return(1);
	
	return(0);
}
/***************************************************************************/
_BOOL com(low_type _PTR D,p_SPECL pend,_INT ibeg_str,_INT iend_str,
          _INT C_str)
{
   p_SHORT  x=D->buffers[0].ptr,
            y=D->buffers[1].ptr;

   if (str_com(ibeg_str,iend_str,x,y,C_str)==_TRUE ||
       curve_com_or_brkt(D,pend,ibeg_str,iend_str,C_str,LMOD_BORDER_TEXT)!=0)
      return(_TRUE);

   return(_FALSE);
}
/***************************************************************************/
_INT curve_com_or_brkt(low_type _PTR D,p_SPECL pend,_INT ibeg_str,
                        _INT iend_str, _INT C_str, _USHORT lmod)
{
	p_SHORT  x=D->buffers[0].ptr, y=D->buffers[1].ptr;
	_INT i,dx,dy,pnt1,pnt2,iMostFar,sign = 0,n_segm;
	_LONG MaxScal,ChordLenSq;
	p_SPECL wrk;
	_INT brkt=1, thresh=D->rc->stroka.extr_depth;
	
	_LONG P1=2, P2=2, Q=1;
	//  _USHORT lmod=D->rc->lmod_border_used;
	
	if (lmod==LMOD_BORDER_NUMBER)
	{   
		P1=8; P2=5; Q=2;  
	}

	dx = x[iend_str]-x[ibeg_str];
	dy = y[iend_str]-y[ibeg_str];

	if (HWRAbs(dy)<THREE_FOURTH(HWRAbs(dx))) 
		return(0);
	
	wrk=pend->prev;
	if	(	wrk->mark==BEG ||
			HWRAbs(x[wrk->iend]-x[wrk->ibeg])>TWO_THIRD(HWRAbs(dy))
		)
		return(0);

	if (wrk->mark==MINW)
	{
		if (lmod==LMOD_BORDER_TEXT)
			brkt=NOT_BRKT;

		if (lmod==LMOD_BORDER_NUMBER)
		{
			if (wrk->ibeg-wrk->prev->iend>1)
				return(0);

			wrk=wrk->prev;                                 //wrk->mark==MAXW
		}
	}

	if (Q*HWRAbs(x[wrk->ibeg]-x[wrk->iend])>P1*thresh)
		brkt=NOT_BRKT;

	wrk=wrk->prev;

	if (wrk->mark==BEG) 
		return(0);

	if	(	Q*(x[wrk->ibeg]-x[wrk->iend])>P1*thresh ||
			Q*(x[wrk->iend]-x[wrk->ibeg])>P2*thresh
		)
		return(0);

	//   if (wrk->mark!=MINW)
	//      brkt=NOT_BRKT;

	wrk=wrk->prev;

	if (wrk->mark!=BEG)
	{
		if (lmod==LMOD_BORDER_TEXT) brkt=NOT_BRKT;

		if (wrk->prev->mark!=BEG ||
			HWRAbs(x[wrk->ibeg]-x[wrk->iend])>THREE_HALF(thresh) ||
			HWRAbs(x[wrk->iend]-x[wrk->next->ibeg])>thresh ||
			HWRAbs(y[wrk->iend]-y[wrk->next->ibeg])>thresh ||
			lmod==LMOD_BORDER_NUMBER && wrk->next->ibeg-wrk->iend>1
			)
			return (0);
		
	}
	/*   while (wrk->mark!=BEG)
	{
	if (wrk->mark==MINW || wrk->mark==MAXW) n_ext++;
	wrk=wrk->prev;
	}
	if (n_ext>3 || pend->prev->mark==MINW) return(_FALSE);
	*/
	
	ChordLenSq	=	dx*(_LONG)dx+dy*(_LONG)dy;
	iMostFar	=	iMostFarFromChord(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str);
	MaxScal		=	(x[iMostFar]-x[ibeg_str])*(_LONG)(-dy)+
		(y[iMostFar]-y[ibeg_str])*(_LONG)dx;

	if (C_str*HWRLAbs(MaxScal) <= ChordLenSq) 
		return 0;
	
	if (MaxScal > 0) 
		sign = 1;
	else
	if (MaxScal < 0) 
		sign = -1;
	
	for (n_segm=3; n_segm<=5; n_segm++)
	{
		for (i=1,pnt2=ibeg_str; i<=n_segm; i++)
		{
			pnt1=pnt2;
			pnt2=ibeg_str + (_INT)((_LONG)i*(iend_str-ibeg_str)/n_segm);
			iMostFar=iMostFarFromChord(x,y,(_SHORT)pnt1,(_SHORT)pnt2);
			dx=x[pnt2]-x[pnt1];
			dy=y[pnt2]-y[pnt1];
			MaxScal=(x[iMostFar]-x[pnt1])*(_LONG)(-dy)+
				(y[iMostFar]-y[pnt1])*(_LONG)dx;
			ChordLenSq=dx*(_LONG)dx+dy*(_LONG)dy;

			if (5*HWRLAbs(MaxScal) < ChordLenSq) 
				continue;

			if (MaxScal>0 && sign<0 || MaxScal<0 && sign>0)
				return 0;
		}
	}

	return(brkt*sign);
}

/***************************************************************************/

_BOOL str_com(_INT ibeg_str,_INT iend_str,p_SHORT x,p_SHORT y,_INT C_str)
{
   _INT dx=HWRAbs(x[iend_str]-x[ibeg_str]);
   _INT dy=HWRAbs(y[iend_str]-y[ibeg_str]);

   if (straight_stroke(ibeg_str,iend_str,x,y,C_str)==_TRUE &&
       dy >= THREE_FOURTH(dx)
      )
      return(_TRUE);
   else
      return(_FALSE);
}


_BOOL pnt(_RECT box,_INT med_ampl)
{
   if (box.right-box.left<ONE_THIRD(med_ampl) &&
       box.bottom-box.top<ONE_THIRD(med_ampl)
      )
      return(_TRUE);
   else
      return(_FALSE);
}
/***************************************************************************/
_UCHAR lead_punct(low_type _PTR D)
{
   p_SPECL wrk, fst_end;
   _INT ibeg_str,iend_str,ibeg_nxt_str,iend_nxt_str;
   _RECT fst_box,nxt_box;
   p_SHORT  x=D->buffers[0].ptr,
            y=D->buffers[1].ptr;

   wrk=D->specl->next;
   ibeg_str=wrk->ibeg;
   while (wrk->mark!=END) wrk=wrk->next;
   fst_end=wrk;
   iend_str=wrk->iend;
   GetTraceBox(x,y,(_SHORT)ibeg_str,(_SHORT)iend_str,&fst_box);

   wrk=wrk->next;
   ibeg_nxt_str=wrk->ibeg;
   while (wrk->mark!=END) wrk=wrk->next;
   iend_nxt_str=wrk->iend;
   GetTraceBox(x,y,(_SHORT)ibeg_nxt_str,(_SHORT)iend_nxt_str,&nxt_box);

   if (com(D,fst_end,ibeg_str,iend_str,5)==_TRUE &&
       fst_box.bottom<ONE_HALF(D->box.top)+ONE_HALF(D->box.bottom)
      )
   {
      if (com(D,wrk,ibeg_nxt_str,iend_nxt_str,5)==_TRUE &&
          nxt_box.bottom<ONE_HALF(D->box.top)+ONE_HALF(D->box.bottom)
         )
         return(2);
      else
         return(1);
   }
   return(0);
}

/***************************************************************************/

_BOOL hor_stroke(p_SPECL cur, p_SHORT x, p_SHORT y, _INT n_str)

{
   _INT ibeg_str,iend_str,dx,dy,n_ext=0,imid,ibeg1,iend1,dx1,dy1,
          dx_beg,dy_beg,dx_end,dy_end,dx_beg1end,dy_beg1end,
          dx_begend1,dy_begend1;

   iend_str=cur->iend;
   cur=cur->prev;
   while (cur->mark!=BEG) { n_ext++; cur=cur->prev; }
   if (n_str>1 && n_ext>3) return(_FALSE);
   if (n_str==1 && n_ext>5) return(_FALSE);
    ibeg_str=cur->ibeg;
    dx=HWRAbs(x[iend_str]-x[ibeg_str]);
    dy=HWRAbs(y[iend_str]-y[ibeg_str]);
    if ( straight_stroke(ibeg_str,iend_str,x,y,5)==_TRUE && 18L*dy < 10L*dx
        ||
         straight_stroke(ibeg_str,iend_str,x,y,4)==_TRUE && 30L*dy < 10L*dx
       )
       return(_TRUE);
//    if (n_str==1)
//    {
        imid=ONE_HALF(ibeg_str+iend_str);
        ibeg1=iMostFarFromChord(x,y,(_SHORT)ibeg_str,(_SHORT)imid);
        iend1=iMostFarFromChord(x,y,(_SHORT)imid,(_SHORT)iend_str);
        dx1=HWRAbs(x[iend1]-x[ibeg1]);
        dy1=HWRAbs(y[iend1]-y[ibeg1]);
        dx_beg=HWRAbs(x[ibeg_str]-x[ibeg1]);
        dy_beg=HWRAbs(y[ibeg_str]-y[ibeg1]);
        dx_end=HWRAbs(x[iend_str]-x[iend1]);
        dy_end=HWRAbs(y[iend_str]-y[iend1]);
        dx_beg1end=HWRAbs(x[ibeg1]-x[iend_str]);
        dy_beg1end=HWRAbs(y[ibeg1]-y[iend_str]);
        dx_begend1=HWRAbs(x[ibeg_str]-x[iend1]);
        dy_begend1=HWRAbs(y[ibeg_str]-y[iend1]);

        if (straight_stroke(ibeg1,iend1,x,y,5)==_TRUE && 20L*dy1 < 10L*dx1 &&
            dx_beg<ONE_FOURTH(dx1) && dy_beg<ONE_FOURTH(dx1) &&
            dx_end<ONE_FOURTH(dx1) && dy_end<ONE_FOURTH(dx1)
            ||
            straight_stroke(ibeg1,iend_str,x,y,5)==_TRUE &&
            20L*dy_beg1end < 10L*dx_beg1end &&
            dx_beg<ONE_FOURTH(dx_beg1end) &&
            dy_beg<ONE_FOURTH(dx_beg1end)
            ||
            straight_stroke(ibeg_str,iend1,x,y,5)==_TRUE &&
            20L*dy_begend1 < 10L*dx_begend1 &&
            dx_end<ONE_FOURTH(dx_begend1) &&
            dy_end<ONE_FOURTH(dx_begend1)
           )
           return(_TRUE);
//    }
    return(_FALSE);

}
/***************************************************************************/

_BOOL straight_stroke(_INT ibeg, _INT iend, p_SHORT x, p_SHORT y,_INT C)
{
   _INT iMostFar=iMostFarFromChord(x,y,(_SHORT)ibeg,(_SHORT)iend);
  _INT dxNormal=y[ibeg]-y[iend];
  _INT dyNormal=x[iend]-x[ibeg];
   _LONG ChordLenSq=dxNormal*(_LONG)dxNormal+dyNormal*(_LONG)dyNormal;
   _LONG MaxScal=(x[iMostFar]-x[ibeg])*(_LONG)dxNormal+
                 (y[iMostFar]-y[ibeg])*(_LONG)dyNormal;
   TO_ABS_VALUE(MaxScal);
   if (C*MaxScal > ChordLenSq || ChordLenSq==0)
      return(_FALSE);
   else
      return(_TRUE);
}

/***************************************************************************/

_BOOL is_i_point(low_type _PTR D,p_SPECL cur,_RECT stroke_box,_INT med_ampl)
{
   _INT dist, min_dist=ALEF,
       x_mid=ONE_HALF(stroke_box.left)+ONE_HALF(stroke_box.right);
   p_SHORT x=D->buffers[0].ptr,
           y=D->buffers[1].ptr;
   p_SPECL clst_min=_NULL;
   if (stroke_box.bottom < TWO_THIRD(D->box.bottom)+      /*point*/
       ONE_THIRD(D->box.top) &&
       stroke_box.bottom-stroke_box.top<ONE_THIRD(med_ampl) &&
       stroke_box.right-stroke_box.left<ONE_THIRD(med_ampl)
      )
   {
    _INT MIN_DST=HWRMax(2*D->rc->stroka.extr_depth,
                 ONE_HALF(stroke_box.right-stroke_box.left));
      while (cur->mark!=BEG) cur=cur->prev;
      while(cur!=_NULL)
      {
         if (cur->mark==MINW && cur->next->mark!=END)
         {
            if (y[cur->ipoint0] <= stroke_box.bottom || cur->attr==T_MIN ||
                cur->attr==S_MIN || cur->attr==E_MIN  ||
                !extrs_open(D,cur,MINW,1)
               )
            {
               cur=cur->prev;
               continue;
            }
            dist=HWRAbs(x[cur->ipoint0] - x_mid);
            if (dist<min_dist)
            {
               min_dist=dist;
               clst_min=cur;
            }
         }
         cur=cur->prev;
      }

      if (clst_min!=_NULL && min_dist <= MIN_DST)
      {
          clst_min->attr=I_MIN;
          return (_TRUE);
      }
   }
   return(_FALSE);
}
/***************************************************************************/
_BOOL is_umlyut(p_SPECL cur, _RECT stroke_box, _INT ibeg_str, _INT iend_str,
                 p_SHORT x, p_SHORT y,_INT med_ampl)
{
      _INT n_min=0, n_max=0;
      p_SPECL left_min=_NULL, prv_left_min=_NULL, nxt_left_min=_NULL;

    _INT  x_left;
      while (cur->mark!=BEG)
      {
         if (cur->mark==MINW) n_min++;
         if (cur->mark==MAXW) n_max++;
         cur=cur->prev;
      }
      if (n_min>2 || n_max>2) return(_FALSE);
      if (cur->prev->prev==_NULL) return(_FALSE);
      while (cur!=_NULL)
      {
      if (cur->mark==MINW && (cur->attr==NORM || cur->attr==I_MIN))
//          cur->attr!=UML && cur->attr!=PNT && cur->attr!=HOR_STR)
         {
            if (x[cur->ipoint0] > stroke_box.right)
            {
               cur=cur->prev;
               continue;
            }
            if (stroke_box.left <= x[cur->ipoint0] &&
                y[cur->ipoint0]>stroke_box.bottom && cur->next->mark!=END)
               return(_TRUE);

            if (stroke_box.left > x[cur->ipoint0])
            {
               left_min=cur;
               cur=cur->prev;
               while (cur!=_NULL && cur->mark!=MINW) cur=cur->prev;
               prv_left_min=cur;
               cur=left_min->next;
               while (cur!=_NULL && cur->mark!=MINW) cur=cur->next;
               nxt_left_min=cur;
               break;
            }
         }
      if (cur->prev==_NULL)  break;
         cur=cur->prev;
      }
      if (left_min!=_NULL && y[left_min->ipoint0]>stroke_box.bottom &&
          left_min->next->mark!=END && nxt_left_min!=_NULL &&
          y[nxt_left_min->ipoint0]>stroke_box.bottom
#ifndef FOR_GERMAN
          && x[nxt_left_min->ipoint0]>stroke_box.right
#endif
         )
         return(_TRUE);
      if (left_min!=_NULL && y[left_min->ipoint0]>stroke_box.bottom &&
          prv_left_min!=_NULL && y[prv_left_min->ipoint0]>stroke_box.bottom &&
          prv_left_min->next->mark!=END
#ifndef FOR_GERMAN
          &&
          (straight_stroke(ibeg_str,iend_str,x,y,5)==_TRUE/*apostrof*/ ||
           stroke_box.bottom-stroke_box.top<ONE_HALF(med_ampl)
          )
#endif
         )
         return(_TRUE);
/*      if (left_min!=_NULL && y[left_min->ipoint0]>stroke_box.bottom &&
          prv_left_min!=_NULL && y[prv_left_min->ipoint0]>stroke_box.bottom &&
          (nxt_left_min==_NULL || y[nxt_left_min->ipoint0]>stroke_box.bottom)
         )
         return(_TRUE);
*/
    if (left_min==_NULL && cur != NULL)
    {
      while (cur->mark!=END && cur->mark!=MINW)  cur=cur->next;
      x_left=HWRMin(x[cur->ibeg],x[cur->iend]);
      if (cur->mark==MINW && cur->attr==NORM &&
         y[cur->ipoint0]>stroke_box.bottom &&
         x_left < stroke_box.right &&
         stroke_box.right-stroke_box.left < TWO(x[cur->ipoint0]-x_left)
        )
      return(_TRUE);
    }
      return(_FALSE);
}

/***************************************************************************/

_VOID sort_extr(p_EXTR extr,_INT n_extr)
{
  _INT i,j,wx,wi;
  EXTR wextr;

  j=0;
  while (j<n_extr-1)
  {
      wx=extr[j].x;
      wi=j;
      for (i=j+1; i<n_extr; i++)
          if (extr[i].x<wx)
          {
                 wx=extr[i].x;
                 wi=i;
          }
      wextr=extr[j];
      extr[j]=extr[wi];
      extr[wi]=wextr;
      j++;
  }
  return;
}

/***************************************************************************/
/*
static _VOID sort_height(p_SHORT height,_SHORT n_height)
{
  _SHORT i,j,wh,wi;

  j=0;
  while (j<n_height-1)
  {
      wh=height[j];
      wi=j;
      for (i=j+1; i<n_height; i++)
          if (height[i]>wh)
          {
                 wh=height[i];
                 wi=i;
          }
      height[wi]=height[j];
      height[j]=wh;
      j++;
  }
  return;
}

*/
/***************************************************************************/
_VOID find_gaps_in_line(p_EXTR extr,_INT n_extr,_INT n_allextr,
                        _INT med_ampl,_UCHAR type,_INT x_left,_INT x_right,
                        p_SHORT bord_d,p_SHORT y,_BOOL sl,_BOOL strict)
{
   _INT i,coss,dyl,dyr,dxl,dxr,last_extr=n_extr-1,
        linetype,dir,pos;
   _LONG  tg,h;
    _INT ampl_l=med_ampl,ampl_r=med_ampl;


    if (n_extr<2) return;
   linetype = (type==MINW) ? 0 : 1;

   dxr=(extr[1].x-extr[1].shift)-(extr[0].x-extr[0].shift);
    dyr=extr[0].y-extr[1].y;
   dir = (dyr<0) ? UP : DOWN;
   pos = (extr[0].x>x_left) ? 1 : 0;

   tg=TG1[pos][linetype][dir];
   h=H1[pos][linetype][dir];
   if (n_extr==2)
   {  tg=35;  h=40;  }
   if (n_allextr==2 && type==MAXW && dir==UP)
   {  tg=30; h=10;  }
   if (sl==_TRUE)
   {  tg=30; h=20;  }
   if (strict==_TRUE)
      h=h*3/2;
    if (type==MINW)
    {
     ampl_r=HWRMin(bord_d[extr[0].i]-extr[0].y, bord_d[extr[1].i]-extr[1].y);
     ampl_r=HWRMin(ampl_r,med_ampl);
    }
    else
    {
     ampl_r=HWRMin(calc_ampl(extr[0],y,MAXW), calc_ampl(extr[1],y,MAXW));
     ampl_r=HWRMin(ampl_r,med_ampl);
    }
   if (100L*dyr>=tg*dxr && 100L*dyr>=h*ampl_r)
      extr[0].susp=GLITCH_DOWN;
   if (100L*dyr<=-tg*dxr && 100L*dyr<=-h*ampl_r)
      extr[0].susp=GLITCH_UP;
#ifndef FOR_GERMAN
   if (100L*dyr>=ONE_HALF(tg*dxr) && 100L*dyr>=TWO(h*ampl_r) && type==MINW)
      extr[0].susp=GLITCH_DOWN;
   if (100L*dyr<=-ONE_HALF(tg*dxr) && 100L*dyr<=-TWO(h*ampl_r))
      extr[0].susp=GLITCH_UP;
#endif
   for (i=1; i<last_extr; i++)
   {
     coss=(_INT)cos_pointvect((_SHORT)(extr[i].x-extr[i].shift),extr[i].y,
                  (_SHORT)(extr[i-1].x-extr[i-1].shift),extr[i-1].y,
                  (_SHORT)(extr[i].x-extr[i].shift),extr[i].y,
                  (_SHORT)(extr[i+1].x-extr[i+1].shift),extr[i+1].y);
       dyl=extr[i].y-extr[i-1].y;
       dyr=extr[i].y-extr[i+1].y;
     if (dyl>=0 && dyr<=0 || dyl<=0 && dyr>=0)
       continue;
     dir = (dyl<0) ? UP : DOWN;
     if (sl==_FALSE)
       h=H1[1][linetype][dir];
     else
       h=20;
     if (strict==_TRUE)
        h=h*3/2;
     if (type==MINW)
     {
       ampl_l=ampl_r=bord_d[extr[i].i]-extr[i].y;
       ampl_l=HWRMin(ampl_l,bord_d[extr[i-1].i]-extr[i-1].y);
       ampl_l=HWRMin(ampl_l,med_ampl);
       ampl_r=HWRMin(ampl_r,bord_d[extr[i+1].i]-extr[i+1].y);
       ampl_r=HWRMin(ampl_r,med_ampl);
     }
     else
     {
       ampl_l=ampl_r=calc_ampl(extr[i],y,MAXW);
       ampl_l=HWRMin(ampl_l,calc_ampl(extr[i-1],y,MAXW));
       ampl_l=HWRMin(ampl_l,med_ampl);
       ampl_r=HWRMin(ampl_r,calc_ampl(extr[i+1],y,MAXW));
       ampl_r=HWRMin(ampl_r,med_ampl);
     }

     if (coss>=-CS)
     {
        if (100L*dyl>=h*ampl_l && 100L*dyr>=h*ampl_r)
           extr[i].susp=GLITCH_DOWN;
        if (100L*dyl<=-h*ampl_l && 100L*dyr<=-h*ampl_r)
           extr[i].susp=GLITCH_UP;
     }
   }

   dyl=extr[last_extr].y-extr[last_extr-1].y;
   dxl=(extr[last_extr].x-extr[last_extr].shift)-
      (extr[last_extr-1].x-extr[last_extr-1].shift);
   dir = (dyl<0) ? UP : DOWN;
   pos = (extr[last_extr].x<x_right) ? 1 : 2;

   tg=TG1[pos][linetype][dir];
   h=H1[pos][linetype][dir];
   if (n_extr==2)
   {  tg=35;  h=40;  }
   if (sl==_TRUE)
   {  tg=30; h=20;  }
   if (strict==_TRUE)
      h=h*3/2;
    if (type==MINW)
    {
     ampl_l=HWRMin(bord_d[extr[last_extr].i]-extr[last_extr].y,
                             bord_d[extr[last_extr-1].i]-extr[last_extr-1].y);
     ampl_l=HWRMin(ampl_l,med_ampl);
    }
    else
    {
     ampl_l=HWRMin(calc_ampl(extr[last_extr],y,MAXW),
                   calc_ampl(extr[last_extr-1],y,MAXW));
     ampl_l=HWRMin(ampl_l,med_ampl);
    }
   if (100L*dyl>=tg*dxl && 100L*dyl>=h*ampl_l)
     extr[last_extr].susp=GLITCH_DOWN;
   if (100L*dyl<=-tg*dxl && 100L*dyl<=-h*ampl_l)
     extr[last_extr].susp=GLITCH_UP;
#ifndef FOR_GERMAN
   if (100L*dyl>=ONE_HALF(tg*dxl) && 100L*dyl>=TWO(h*ampl_l))
     extr[last_extr].susp=GLITCH_DOWN;
   if (100L*dyl<=-ONE_HALF(tg*dxl) && 100L*dyl<=-TWO(h*ampl_l))
     extr[last_extr].susp=GLITCH_UP;
#endif
    return;
}
/***************************************************************************/
_VOID find_glitches_in_line(p_EXTR extr, _INT n_extr, _INT med_ampl,
              _UCHAR type,_INT x_left,_INT x_right,
              p_SHORT bord_d,p_SHORT x,p_SHORT y,_INT MAX_SHIFT,_BOOL sl,
                                                              _BOOL strict)
{
   _INT i, j, dxl, dxr, dyl, dyr, dy_out, dy_in, in_max, in_min, sgnl, sgnr,
       shift, ampl_l=med_ampl,ampl_r=med_ampl, linetype,dir,pos;
  _LONG  tg, h, d;
  _BOOL  prev_glitch;
  _INT dx_sl, dy_sl;
  p_SPECL cur,nxt;

  linetype = (type==MINW) ? 0 : 1;
   for (shift=1; shift<=MAX_SHIFT; shift++)
   {
      if (shift>=n_extr-1) break;
      for (i=shift; i<n_extr; i++)
      {
         for (j=0,prev_glitch=_FALSE; j<=shift; j++)
        if (extr[i-j].susp==GLITCH_UP ||
           extr[i-j].susp==DBL_GLITCH_UP ||
           extr[i-j].susp==TRP_GLITCH_UP ||
           extr[i-j].susp==GLITCH_DOWN ||
           extr[i-j].susp==DBL_GLITCH_DOWN ||
           extr[i-j].susp==TRP_GLITCH_DOWN
           )
          prev_glitch=_TRUE;
      if ((i>shift || type==MAXW) && prev_glitch==_TRUE) continue;
      dxl = (i>shift) ? (extr[i-shift].x-extr[i-shift].shift)-
                  (extr[i-shift-1].x-extr[i-shift-1].shift) : 0;
      dyl = (i>shift) ? extr[i-shift].y-extr[i-shift-1].y : 2*med_ampl;
      sgnl= (i>shift) ? sign(dyl,0) : 0;
      dyl = HWRAbs(dyl);
      dxr = (i<n_extr-1) ? (extr[i+1].x-extr[i+1].shift)-
                    (extr[i].x-extr[i].shift) : 0;
      dyr = (i<n_extr-1) ? extr[i].y-extr[i+1].y : 2*med_ampl;
      sgnr= (i<n_extr-1) ? sign(dyr,0) : 0;
      dyr = HWRAbs(dyr);
      if (sgnl*sgnr<0)
        continue;
      dir = (sgnl<0 || sgnr<0) ? UP : DOWN;
        dy_out = HWRMin(dyl,dyr);
      for (j=0,in_max=0,in_min=ALEF; j<=shift; j++)
      {
          in_max = HWRMax(in_max, extr[i-j].y);
          in_min = HWRMin(in_min, extr[i-j].y);
         }
         dy_in=in_max-in_min;
         if (type==MINW)
         {
        ampl_l=bord_d[extr[i-shift].i]-extr[i-shift].y;
        ampl_r=bord_d[extr[i].i]-extr[i].y;
        if (i>shift) ampl_l=HWRMin(ampl_l,
                      bord_d[extr[i-shift-1].i]-extr[i-shift-1].y);
        if (i<n_extr-1) ampl_r=HWRMin(ampl_r,
                      bord_d[extr[i+1].i]-extr[i+1].y);
        ampl_l=HWRMin(ampl_l,med_ampl);
        ampl_r=HWRMin(ampl_r,med_ampl);
      }
      pos=1;
      if (i==shift && extr[0].x<=x_left)   pos=0;
      if (i==n_extr-1 && extr[n_extr-1].x>=x_right)  pos=2;
      tg=TG2[pos][linetype][dir];

      if (i==shift) pos=0;
      if (i==n_extr-1) pos=2;
      h=H2[pos][linetype][dir];
      d=100;

/*#ifdef FOR_GERMAN
      if (shift>1)
      {  tg=58;  h=49;  }
#endif*/

      if (prev_glitch==_TRUE)
        d=55;

      if (sl==_TRUE)
      {  tg=40;  h=30; d=57;}

      if (strict==_TRUE)
         h=h*3/2;

      if (x!=0 && y!=0 && type==MINW && dir==UP && pos>0 && shift==1)
      {
         cur=extr[i-shift].pspecl;
         nxt=cur->next;
         if (nxt->mark==MAXW && (nxt->code==ON_LINE || nxt->code==SUB_SCRIPT))
         {
           dy_sl=y[nxt->ipoint0]-y[cur->ipoint0];
           dx_sl=x[cur->ipoint0]-x[nxt->ipoint0];
           if (dx_sl>0)
              dxl=HWRAbs(dxl-(_INT)((_LONG)dyl*(_LONG)dx_sl/dy_sl));
         }
      }


      if ( 100L*dyl>=tg*dxl && 100L*dyl>=h*ampl_l
              &&
          100L*dyr>=tg*dxr && 100L*dyr>=h*ampl_r
          &&
          100L*dy_in < d*dy_out
            )
         {
        if (dir==DOWN)
            {
               switch (shift)
               {
                  case 0:
                  extr[i].susp=GLITCH_DOWN;
                          break;
                  case 1:
                            extr[i].susp=extr[i-1].susp=DBL_GLITCH_DOWN;
                          break;
                  default:
                            for (j=0; j<=shift; j++)
                               extr[i-j].susp=TRP_GLITCH_DOWN;
               }
            }
        if (dir==UP)
            {
          switch (shift)
               {
                  case 0:
                          extr[i].susp=GLITCH_UP;
                          break;
            case 1:
                            extr[i].susp=extr[i-1].susp=DBL_GLITCH_UP;
                          break;
                  default:
                            for (j=0; j<=shift; j++)
                               extr[i-j].susp=TRP_GLITCH_UP;
               }
            }
         }
      }
   }
   return;
}
/***************************************************************************/
_VOID glitch_to_sub_max(low_type _PTR D,p_EXTR line_max, _INT n_line_max,
                        _INT mid_ampl,_BOOL gl_down_left)
{
   p_SHORT x=D->buffers[0].ptr,
           y=D->buffers[1].ptr;
   _INT thresh=D->rc->stroka.extr_depth;
   p_SPECL cur,prv,nxt,wrk,wprv,wnxt;
   _INT i;

   _BOOL non_sub(p_SPECL cur,p_SHORT x,p_SHORT y,_INT thresh);

   for (i=0; i<n_line_max; i++)
   {
      if (line_max[i].susp==GLITCH_DOWN
          && (line_max[i].pspecl)->code!=RET_ON_LINE
         )
      {
         cur=line_max[i].pspecl;
         prv=cur->prev;
         nxt=cur->next;
         if ( non_sub(cur,x,y,thresh)==_FALSE &&
              (prv->mark==MINW && y[cur->ipoint0]-y[prv->ipoint0] > mid_ampl ||
               nxt->mark==MINW && y[cur->ipoint0]-y[nxt->ipoint0] > mid_ampl ||
               i>0 && line_max[i].y-line_max[i-1].y > mid_ampl ||
               i+1<n_line_max && line_max[i].y-line_max[i+1].y > mid_ampl
              )
            )

            line_max[i].susp=SUB_SCRIPT;
         else
            if (gl_down_left==_TRUE)
               line_max[i].susp=SUB_SCRIPT;
            else
               line_max[i].susp=0;
    }
      if (line_max[i].susp==DBL_GLITCH_DOWN
       && i<n_line_max-1
//           && line_max[i+1].susp==DBL_GLITCH_DOWN
         )
      {
         cur=line_max[i].pspecl;
         prv=cur->prev;
         nxt=cur->next;
         wrk=line_max[i+1].pspecl,
         wprv=wrk->prev;
         wnxt=wrk->next;
         if (non_sub(cur,x,y,thresh)==_FALSE &&
             cur->code!=RET_ON_LINE &&
             (prv->mark==MINW && y[cur->ipoint0]-y[prv->ipoint0]>mid_ampl ||
              nxt->mark==MINW && y[cur->ipoint0]-y[nxt->ipoint0]>mid_ampl ||
              i>0 && line_max[i].y-line_max[i-1].y > mid_ampl
             )
             &&
             non_sub(wrk,x,y,thresh)==_FALSE &&
             wrk->code!=RET_ON_LINE &&
             (wprv->mark==MINW && y[wrk->ipoint0]-y[wprv->ipoint0]>mid_ampl ||
              wnxt->mark==MINW && y[wrk->ipoint0]-y[wnxt->ipoint0]>mid_ampl ||
              i+2<n_line_max && line_max[i+1].y-line_max[i+2].y > mid_ampl
             )
            )
             line_max[i].susp=line_max[i+1].susp=SUB_SCRIPT;
         else
            if (gl_down_left==_TRUE)
               line_max[i].susp=line_max[i+1].susp=SUB_SCRIPT;
            else
               line_max[i].susp=line_max[i+1].susp=0;
         i++;
      }
   }
   return;
}

/***************************************************************************/
_BOOL non_sub(p_SPECL cur,p_SHORT x,p_SHORT y,_INT thresh)
{
   p_SPECL prv,nxt;
   _INT iLeft,i,y1,x1;

   if (2*(x[cur->iend]-x[cur->ibeg]) <
     5*(y[cur->ipoint0]-HWRMin(y[cur->ibeg],y[cur->iend]))
      )
    return(_FALSE);
   prv=cur->prev;
   nxt=cur->next;
   if (prv->mark!=MINW || nxt->mark!=MINW)
      return(_FALSE);
//   if (prv->prev->mark==BEG)
//      return(_TRUE);
   if(x[nxt->ipoint0]<x[nxt->ibeg] && y[prv->ipoint0]<y[nxt->ipoint0])
      return(_FALSE);
   iLeft=ixMin(cur->iend,nxt->iend,x,y);
   y1=y[cur->iend]-thresh;
   x1=x[cur->iend]+thresh;
   if (y[iLeft]<y1 && x[iLeft]<x1)
      return(_FALSE);
   if (y[iLeft]>=y1)
   {
      for (i=cur->iend; i<nxt->iend; i++)
         if (y[i]<y1 || x[i]>x1)
         {
            iLeft=ixMin((_SHORT)i,(_SHORT)nxt->iend,x,y);
            if (x[iLeft]<x1)   return(_FALSE);
            break;
         }
   }
  return(_TRUE);
}
/***************************************************************************/
_VOID glitch_to_inside(p_EXTR extr, _INT n_extr, _UCHAR type, p_SHORT y,
                    _INT mid_ampl,_INT x_left,_INT x_right)
{
	p_SPECL cur,nxt,prv,wrk,wnxt,wprv;
	_INT	i;
	_UCHAR	MARK, DBL_MARK, opp_type;

	ASSERT (type == MAXW || type == MINW);

	if (type==MAXW)
	{ 
		MARK=GLITCH_UP; 
		DBL_MARK=DBL_GLITCH_UP; 
		opp_type=MINW; 
	}
	else
	if (type==MINW)
	{ 
		MARK=GLITCH_DOWN; 
		DBL_MARK=DBL_GLITCH_DOWN; 
		opp_type=MAXW; 
	}
	
	for (i=0; i<n_extr; i++)
	{
		if (extr[i].susp==MARK &&
			(extr[i].pspecl)->code!=RET_ON_LINE
			)
		{
			cur=extr[i].pspecl;
			prv=cur->prev;
			nxt=cur->next;

			if (cur->attr==I_MIN
#ifdef FOR_GERMAN
				|| type==MINW && i==n_extr-1 && nxt->mark==MAXW &&
				extr[i].x>=x_right &&
				prv->mark==MAXW && y[prv->ipoint0]-y[cur->ipoint0]>ONE_HALF(mid_ampl)
#endif
				)
			{  
				extr[i].susp=0; 
				continue;  
			}

			if (prv->mark==opp_type && HWRAbs(y[cur->ipoint0]-y[prv->ipoint0]) < mid_ampl ||
				nxt->mark==opp_type && HWRAbs(y[cur->ipoint0]-y[nxt->ipoint0]) < mid_ampl ||
				prv->mark==BEG || nxt->mark==END ||
				i>0 && HWRAbs(extr[i].y-extr[i-1].y) > mid_ampl ||
				i+1<n_extr && HWRAbs(extr[i].y-extr[i+1].y) > mid_ampl
				)
			{
				extr[i].susp=INSIDE_LINE;
			}
			//         else  extr[i].susp=0;
		}
		if (extr[i].susp==DBL_MARK
			&& i<n_extr-1
			)
		{
			cur=extr[i].pspecl;
			wrk=extr[i+1].pspecl;
			prv=cur->prev;
			nxt=cur->next;
			wprv=wrk->prev;
			wnxt=wrk->next;
			if (cur->attr==I_MIN || wrk->attr==I_MIN ||
				cur->code==RET_ON_LINE || wrk->code==RET_ON_LINE ||
				type==MINW && i==n_extr-2 && wnxt->mark==MAXW &&
				extr[i+1].x>=x_right ||
				type==MINW && i==0 && extr[0].x<=x_left
				//             || type==MAXW && i==n_extr-2
				)
			{
				extr[i].susp=extr[i+1].susp=0;
				i++;
				continue;
			}

			if ( (prv->mark==opp_type && HWRAbs(y[cur->ipoint0]-y[prv->ipoint0])<mid_ampl ||
				nxt->mark==opp_type && HWRAbs(y[cur->ipoint0]-y[nxt->ipoint0])<mid_ampl ||
				nxt->mark==END || prv->mark==BEG ||
				i>0 && HWRAbs(extr[i].y-extr[i-1].y) > mid_ampl
				) &&
				(wprv->mark==opp_type && HWRAbs(y[wrk->ipoint0]-y[wprv->ipoint0])<mid_ampl ||
				wnxt->mark==opp_type && HWRAbs(y[wrk->ipoint0]-y[wnxt->ipoint0])<mid_ampl ||
				wnxt->mark==END || wprv->mark==BEG ||
				i+2<n_extr && HWRAbs(extr[i+1].y-extr[i+2].y) > mid_ampl
				)
				)
				extr[i].susp=extr[i+1].susp=INSIDE_LINE;
			//         else
			//            extr[i].susp=extr[i+1].susp=0;
			i++;
		}
	}

	/*  for (i=0; i<n_extr; i++)
	{
	if ((extr[i].susp==DBL_MARK || extr[i].susp==LEFT_MARK ||
	extr[i].susp==RIGHT_MARK)
	&&
	(extr[i].pspecl)->code!=RET_ON_LINE
	)
	{
	cur=extr[i].pspecl;     
	prv=cur->prev;
	nxt=cur->next;
	if ((prv->mark==BEG || HWRAbs(y[cur->ipoint0]-y[prv->ipoint0]) < mid_ampl)
	&&
	(nxt->mark==END || HWRAbs(y[cur->ipoint0]-y[nxt->ipoint0]) < mid_ampl)
	)
	extr[i].susp=INSIDE_LINE;
	}
	}
	
	*/                    
	/*
	for (i=0; i<n_extr; i++)
	{
	if (extr[i].susp==MARK || extr[i].susp==DBL_MARK ||
	extr[i].susp==LEFT_MARK || extr[i].susp==RIGHT_MARK)
	extr[i].susp=0;
	}
	*/
	return;
}
#endif /* __JUST_SECOND_PART */

#endif // #ifndef LSTRIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\trd_imge.cpp ===
// **************************************************************************
// *    TRD file as C file                                                  *
// **************************************************************************

#include "ams_mg.h"  
#include "triads.h"  

// ****   DTI body   ********************************************************
ROM_DATA _ULONG img_trd_body[4001] =  
 {  
0xFFFFFFFC, 0x003EFFFF, 0xF7F50000, 0xEFF73FDE, 0x0000003D, 0xD75E0C5C, 0x000C0C30, 0x0E1C0000, 
0x0D71D70F, 0x0000001C, 0xD41E0D5C, 0x001C5C31, 0xF6FCC000, 0x7EEB7F59, 0x0000001F, 0xC30C0D6C, 
0x00044D70, 0x0C0C0000, 0xCC30D30F, 0x00000004, 0xC10C4C0C, 0x00080C54, 0xB7FF0000, 0x73E1FE45, 
0xC0000024, 0xC00C0C0C, 0x00000C10, 0x4C0C0000, 0x8C30F30F, 0x0000000C, 0xC11C0C0C, 0x00080C50, 
0x0DDC4000, 0x0D71D50C, 0x0000000C, 0xC01D5C1C, 0x00040D00, 0x76BC0000, 0xFFF7779B, 0x80000025, 
0xD74F1D4C, 0x00040C70, 0x00040000, 0x0C000000, 0x00000000, 0xC00F1C4C, 0x000C0D00, 0x5DCC0000, 
0xDF2FEF8F, 0x0000002C, 0xC00F0D4C, 0x0018ECF0, 0x55500000, 0x07E33601, 0x00000000, 0xC50C4C4C, 
0x00040410, 0x4C0C0000, 0x0470C40F, 0x0000000C, 0x00040404, 0x00040401, 0x0C080000, 0x1C00D004, 
0x00000000, 0xC00D0D1C, 0x00044C40, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x11530000, 0x05F01340, 
0x00000000, 0xD3191B6E, 0x000C0CE0, 0x5DCB0000, 0x0F7996CB, 0x0000003C, 0xBA5D7F5B, 0x001C7DF5, 
0xD3030000, 0x07503605, 0x00000004, 0x414C280D, 0x00040330, 0x8E1E0000, 0x4861E71F, 0x00000004, 
0x7B0D091F, 0x00040560, 0x8F570000, 0x53B03B54, 0x00000010, 0xC4080C4D, 0x00000440, 0x1D0F0000, 
0x0590914E, 0x00000004, 0xDFCD7EBB, 0x0038FFF3, 0x0C2F0000, 0x1D92F95C, 0x0000000C, 0xF7FFFFFF, 
0x003E5BD5, 0x0003C000, 0x0D600540, 0x00000000, 0x974A0D4B, 0x000007F3, 0x00010000, 0x0C000004, 
0x00000000, 0xFFFDFFEF, 0x002CABF6, 0x4D9B0000, 0x5BD6FFCF, 0x0000003C, 0xDE9F1CDB, 0x001C4FA1, 
0xEEB24000, 0x53F12E51, 0x00000017, 0x830C0C09, 0x00081420, 0x3C5F0000, 0x01D06645, 0x0000000C, 
0x00040407, 0x00044141, 0x5B6F0000, 0x55F0EF0D, 0x00000000, 0x4508090F, 0x00140440, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x9FE70000, 0x4EB176DF, 0x0000001C, 0x4208084F, 0x000C0450, 0x01010000, 
0x04404001, 0x00000010, 0x40000004, 0x00000400, 0xFFDF0000, 0x77F527CF, 0x00000018, 0x00000000, 
0x00000400, 0x00010000, 0x00000000, 0x00000000, 0x40000008, 0x00000400, 0xCBDE0000, 0x03E56351, 
0x00000010, 0x40000800, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0xC00C0D0D, 0x000C0C00, 
0x04020000, 0x40000004, 0x00000000, 0x40000C01, 0x00000010, 0x4FED0000, 0xBFB1AE4D, 0x0000001A, 
0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC00C0C0C, 0x000C0800, 0x0CC20000, 
0x0600C105, 0x00000000, 0x02041406, 0x00000450, 0x56D10000, 0x03E0664D, 0x00000019, 0x00080400, 
0x00000000, 0x04040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x44470000, 0x51511144, 
0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0xD6720000, 0x7FF33F5D, 
0x00000014, 0x00000401, 0x00000050, 0x0C090000, 0x0810C30B, 0x00000000, 0xC0040406, 0x00000400, 
0x3F5F0000, 0x51F37FCC, 0x0000000C, 0x00000004, 0x00000000, 0x04040000, 0x04104004, 0x00000000, 
0xFF8F1D5F, 0x0008DB60, 0x7F9F0000, 0x37B2A6C4, 0x00000010, 0x00000000, 0x00000000, 0x5E5F0000, 
0x55E57A09, 0x00000008, 0xC0080C0C, 0x00040C00, 0x04040000, 0x04000004, 0x00000000, 0x10040804, 
0x00000000, 0xD6AF0000, 0xBFB7BF45, 0x00000015, 0x00010005, 0x00000000, 0x00000000, 0x08000000, 
0x00000000, 0xC00C0C0D, 0x000C0C00, 0x04060000, 0x05504005, 0x00000000, 0xD60C1C0F, 0x00000CB0, 
0x15550000, 0x07F35F08, 0x00000010, 0x00040400, 0x00000000, 0x00040000, 0x00000005, 0x00000000, 
0x00000000, 0x00000000, 0x00530000, 0x01113104, 0x00000000, 0x04400C0E, 0x00080400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xD7E30000, 0x7FB16F5B, 0x0000001C, 0x41040C05, 0x00040440, 0x00050000, 
0x04004101, 0x00000000, 0xC3090C1E, 0x000C0060, 0xBFEF0000, 0xE6F7FF46, 0x00000015, 0xC0040404, 
0x00000810, 0x0C050000, 0x04500544, 0x00000004, 0x400C040C, 0x00040410, 0xBFFF0000, 0x3FF3BA41, 
0x00000011, 0x40040405, 0x00000400, 0x04040000, 0x00004004, 0x00000000, 0x400C0C05, 0x000C0400, 
0x04090000, 0x14404008, 0x00000001, 0x00040804, 0x00000000, 0xDF97C000, 0xFDF2FE4D, 0x00000035, 
0x50010004, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x800C0C0E, 0x00080800, 0x0C570000, 
0x67018507, 0x00000000, 0x40010003, 0x00000000, 0x6DFD0000, 0x43E37EC4, 0x00000004, 0x400C080C, 
0x00000000, 0x04080000, 0x0010400C, 0x00000004, 0x00000000, 0x00000000, 0x445B0000, 0x114015C4, 
0x00000000, 0x40080004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00080000, 0x00404004, 0x00000000, 0x00000003, 0x00000000, 0xB3F30000, 0x7FF23FC1, 
0x00000010, 0x91050C7B, 0x00040560, 0x0CCF0000, 0x0F70C3CF, 0x00000014, 0x9B4D9E5F, 0x000CDDF0, 
0x73D70000, 0x53B33FC9, 0x00000034, 0xC20C7C4E, 0x00040F70, 0x880E0000, 0x4DE0950D, 0x00000004, 
0xFB0C4D5B, 0x00000520, 0x9EA70000, 0x72F13ED0, 0x00000031, 0x4004040D, 0x00000440, 0x080E0000, 
0x0080D54C, 0x00000004, 0xDF9F7FBF, 0x003CE7D3, 0x0C7F0000, 0x04D3FD48, 0x00000004, 0xF7FFEFFF, 
0x003C5FE5, 0x53428000, 0x59632504, 0x00000000, 0xC78F0D4F, 0x00040BF2, 0x00010000, 0x0C000000, 
0x00000000, 0xBE9EFEEF, 0x002CB7F3, 0x5DDF0000, 0x6FD7AE9E, 0x00000014, 0x935F1D9B, 0x003CCFE0, 
0xD5538000, 0x51E12504, 0x00000001, 0x810C0C0B, 0x00041450, 0x195B0000, 0x0191510B, 0x00000004, 
0x410E08CF, 0x00040707, 0x0D5F0000, 0x61D1B505, 0x80000000, 0x51040D0F, 0x00140010, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02000000, 0x20A00200, 0x00000000, 
0x00000003, 0x00000000, 0x45F50000, 0x7BF02E4F, 0x00000015, 0x00080001, 0x00000000, 0x00440000, 
0x00010000, 0x00000000, 0x40000005, 0x00000000, 0x4FDF0000, 0xD7F02B4C, 0x0000000C, 0xD70C0C0F, 
0x00040470, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0xFFD60000, 0x22B47340, 
0x00000013, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 0xC0080809, 0x000C0C00, 
0x04080000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x45450000, 0x4DF0E304, 0x00000005, 
0x00000404, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC00C0C0C, 0x000C0C00, 0x00430000, 
0x01014001, 0x00000000, 0x520D0C03, 0x00088041, 0x45C10000, 0x02F03710, 0x00000010, 0x00000000, 
0x00000000, 0x00040000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00020000, 0x00000008, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0xD76F0000, 0x7FB17A1D, 
0x0000003C, 0x00000401, 0x00040000, 0x00000000, 0x00000001, 0x00000000, 0x40040404, 0x00000000, 
0x1F3B0000, 0x53F0BE0D, 0x00000004, 0x40040000, 0x00000410, 0x0C0F0000, 0x00D04308, 0x0000000C, 
0xD30C191F, 0x00004750, 0xFD9B0000, 0x36B1B701, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000004, 0x00000000, 0x80080C0D, 0x000C0400, 0x080D0000, 0x05404000, 0x00000000, 0x840C080B, 
0x00000781, 0x5E1B0000, 0x7FE1F64D, 0x00000014, 0x00040000, 0x00000000, 0x00000000, 0x04000000, 
0x00000000, 0xC0080C0C, 0x00180C00, 0x01170000, 0x13004105, 0x00000000, 0x90060001, 0x00000040, 
0x0D5D0000, 0x03E16E08, 0x0000001C, 0x00040004, 0x00000000, 0x0C040000, 0x00004000, 0x00000004, 
0x00000000, 0x00000000, 0x04020000, 0x04411404, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xFBEF0000, 0xFBF37F9F, 0x0000003D, 0x4000040C, 0x00040410, 0x00000000, 
0x00004001, 0x00000000, 0x40040405, 0x00000010, 0xAB9F0000, 0xDEF2BFCC, 0xC000001D, 0x40040004, 
0x00000800, 0x00040000, 0x00004000, 0x00000000, 0x40000404, 0x00000000, 0xFAFF0000, 0x16F67FD1, 
0x00000015, 0x00000000, 0x00000000, 0x0C040000, 0x00004000, 0x00000000, 0x484C080F, 0x000C0480, 
0x0C0D0000, 0x0440400C, 0x00000000, 0xD00C0C0A, 0x00000440, 0xFADF0000, 0xDFF7FF5E, 0x00000004, 
0x01040000, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0xC8080C0D, 0x000C0C00, 0x04070000, 
0x01004005, 0x00000000, 0xA60D1C07, 0x00084590, 0x9E770000, 0x06A17A8D, 0x00000004, 0x00040004, 
0x00000000, 0x040C0000, 0x00004005, 0x00000000, 0x00000000, 0x00000000, 0x051F0000, 0x05D12600, 
0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0xC5630000, 0x57E17B87, 
0x00000010, 0x9B08087F, 0x00040C50, 0x0C8F0000, 0x0FE093CF, 0x0000002C, 0xB7098E1B, 0x00044DD0, 
0xF7A70000, 0xBFF13BD7, 0x00000010, 0xC20C3C07, 0x00080B50, 0x991B0000, 0x0850B70B, 0x00000014, 
0x40040009, 0x00040400, 0x00070000, 0x01000004, 0x00000000, 0x50440405, 0x00000400, 0x0C0F0000, 
0x0550C1CD, 0x00000000, 0x9F9F5F7B, 0x001C6691, 0x0C6F0000, 0x0DD3D94D, 0x00000004, 0xB6FEFFDF, 
0x002C7FD9, 0x52560000, 0x5F613600, 0x00000000, 0x4B05080F, 0x000007D2, 0x00010000, 0x08000000, 
0x00000000, 0x9FC8DF9B, 0x00145FF2, 0xBFDB0000, 0x57D7BE8F, 0x00000034, 0xB6CF1CCF, 0x003C4FF0, 
0x0402C000, 0x00C01980, 0x00000010, 0x404C0C0D, 0x00041410, 0x040D0000, 0x00004000, 0x00000000, 
0x40040803, 0x00000240, 0x04080000, 0x04000000, 0x00000000, 0x440C0C1B, 0x00300400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02000000, 0x20000F00, 0x00000000, 
0x00000003, 0x00000000, 0xD5960000, 0x55B72D8D, 0x0000001C, 0x00000004, 0x00000000, 0x00000000, 
0x00000005, 0x00000000, 0x00000000, 0x00000000, 0x25CF0000, 0xD1B16541, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x44170000, 0x12103700, 
0x00000000, 0x00000004, 0x00000000, 0x04040000, 0x00004100, 0x00000000, 0x00000000, 0x00000000, 
0x00040000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x5D7F0000, 0x5DA073DE, 0x00000018, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 
0x00000040, 0x00000000, 0x00000000, 0x00000000, 0x46150000, 0x11F12B04, 0x00000001, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x57F70000, 0x9BB27F5A, 
0x0000003C, 0x40000004, 0x00000400, 0x00040000, 0x00000100, 0x00000000, 0x80000004, 0x00000010, 
0x5F5B0000, 0x56B37A0D, 0x00000008, 0x40040004, 0x00000400, 0x00100000, 0x04100000, 0x00000000, 
0xC004040D, 0x00000410, 0x4ED70000, 0x02B37F41, 0x00000014, 0x00000400, 0x00000000, 0x04040000, 
0x00004004, 0x00000004, 0x8408080C, 0x000C0400, 0x04080000, 0x00000000, 0x00000000, 0xC0080C04, 
0x00000400, 0x5DF70000, 0xE7F37F47, 0x00000030, 0x40040000, 0x00000000, 0x00000000, 0x04000000, 
0x00000000, 0x80080C0C, 0x001C0400, 0x48170000, 0x2500C405, 0x00000000, 0x40010004, 0x00000000, 
0x0DF00000, 0x43E16907, 0x00000010, 0x00080000, 0x00000000, 0x04040000, 0x00004004, 0x00000000, 
0x00000000, 0x00000000, 0x00060000, 0x40504110, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xAFEF0000, 0xEFF67A9F, 0x0000002D, 0x40040C0D, 0x00040460, 0x04050000, 
0x0C10814B, 0x00000014, 0xF60D185B, 0x000457A0, 0xFFFF0000, 0xAFF3FE9E, 0x0000001E, 0x800C1407, 
0x00044471, 0x04040000, 0x00104004, 0x00000004, 0x4000080C, 0x00000000, 0xFEEF0000, 0x77DEFFD1, 
0x00000035, 0x00440400, 0x00000000, 0x080B0000, 0x00C0D408, 0x00000004, 0xDC0E5D5F, 0x000C69D1, 
0x0C0E0000, 0x0444D104, 0x00000004, 0x40040C05, 0x00040000, 0x9BEB0000, 0xFFF6FD4F, 0x00000018, 
0x42071C07, 0x00040050, 0x00000000, 0x04000000, 0x00000000, 0x400C0C44, 0x00040000, 0x0DF70000, 
0x6641D489, 0x00000004, 0x8D0F080B, 0x003C48D0, 0x5A9F0000, 0x47B16984, 0x00000011, 0x000C0C0C, 
0x00040000, 0x0C0C0000, 0x00004004, 0x00000004, 0x00000001, 0x00000000, 0x454B0000, 0x41D1754C, 
0x00000010, 0x40040C05, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0xD7960000, 0x5FF177EF, 
0x4000003F, 0xC20C0C0B, 0x00000460, 0x9AD80000, 0x515D6A8D, 0x00000010, 0x00000004, 0x00000010, 
0xDB6F0000, 0xD7F0FF5F, 0x0000001D, 0xC0044000, 0x00000400, 0x00040000, 0x00000400, 0x00000000, 
0x40000004, 0x00000000, 0xDE8F0000, 0x47E077C1, 0x00000015, 0x00000000, 0x00000000, 0x0C000000, 
0x00000004, 0x00000000, 0x00040804, 0x000C0000, 0x0C090000, 0x0C408108, 0x0000000C, 0x41040C06, 
0x00000440, 0x5EDB0000, 0x7FF1BFD6, 0x00000019, 0xD74F1C1F, 0x00040FA1, 0x00000000, 0x04000000, 
0x00000000, 0x40040407, 0x00000080, 0x0D570000, 0x13004045, 0x00000004, 0x41010045, 0x00000000, 
0x5DC10000, 0x02E02645, 0x00000010, 0x00040405, 0x00000000, 0x04010000, 0x00000000, 0x00000000, 
0x00000000, 0x00000100, 0x04070000, 0x01F05140, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x87A30000, 0x7FA36FDA, 0x0000001C, 0xC0040C4C, 0x00000C10, 0x0C0D0000, 
0x072083CF, 0x0000001C, 0x964F5C5F, 0x000C5DF1, 0xDFDF0000, 0xFBF56BCB, 0x0000002F, 0xC2080C0C, 
0x00000C30, 0x1D7B0000, 0x5AE1D70F, 0x00000014, 0x4004040A, 0x00000400, 0xEFDB0000, 0x3FFDBFD1, 
0x00000036, 0xC0040408, 0x00000800, 0x180F0000, 0x01D0A209, 0x00000004, 0x4008080C, 0x000C0400, 
0x0C0C0000, 0x00004004, 0x00000000, 0xD40C0C0F, 0x00081440, 0x5FF70000, 0xEFB1EE5D, 0x00000015, 
0x41040405, 0x00000410, 0x00000000, 0x0C000000, 0x00000000, 0x400C0404, 0x000C0400, 0x3DFF0000, 
0xEF4385CD, 0x00000004, 0xD70E1D4F, 0x003C5DF1, 0x6D5B0000, 0x03917D48, 0x00000010, 0x80080C08, 
0x00040400, 0x040C0000, 0x00104005, 0x00000000, 0x00080401, 0x00000000, 0x056F0000, 0x4340C944, 
0x00000000, 0x804C0C0E, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x03000000, 0x00000000, 0x00000003, 0x00000000, 0x53C10000, 0x13F127C0, 
0x00000005, 0xD22C196B, 0x000465F0, 0x0CCD0000, 0x0F60D1CF, 0x00000010, 0xDD49DE1B, 0x001C4CB0, 
0xD1F20000, 0x55F226C7, 0x00000004, 0x540C3C47, 0x00040750, 0xC90F0000, 0x04B0750E, 0x00000008, 
0x6F04040B, 0x00040430, 0x46C50000, 0x01903300, 0x00000001, 0x40440C45, 0x00000000, 0x0C4B0000, 
0x0490C14D, 0x00000004, 0xDFCD7F5B, 0x00387F87, 0x2C2F0000, 0x05D39D0C, 0x00000004, 0xB7BDFFDF, 
0x003977D5, 0xF353C000, 0x13B33FC5, 0x00000014, 0x974E3C0F, 0x00080BF7, 0x00000000, 0x04000000, 
0x00000000, 0xFFCDEFEF, 0x001CD7F3, 0x4CAF0000, 0x47D7D7CF, 0x00000014, 0x910F4C5B, 0x00345FD1, 
0xDEB70000, 0x53F3375D, 0xC0000012, 0x400C0C0A, 0x000400C0, 0x1F1F0000, 0x15D1360D, 0x00000004, 
0x00040456, 0x00040000, 0x194B0000, 0x00C05708, 0x00000000, 0x550C080B, 0x00140440, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01D00000, 0x00501441, 0x00000000, 
0x00000003, 0x00000000, 0x97E70000, 0x5BF6765D, 0x0000001D, 0x40000401, 0x00000400, 0x00110000, 
0x00004005, 0x00000000, 0x40000404, 0x00000000, 0x5FDF0000, 0x52B3F6DC, 0x00000015, 0x02040C01, 
0x00000400, 0x00000000, 0x00100000, 0x00000000, 0xD108090B, 0x00080470, 0x5FC50000, 0x57B77644, 
0x00000015, 0x00000000, 0x00000000, 0x0C000000, 0x00000004, 0x00000000, 0xC00C0C0C, 0x000C0C40, 
0x081D0000, 0x00004000, 0x00000000, 0x40040401, 0x00000000, 0x55810000, 0xDBF2FFCD, 0x00000014, 
0xC3090C0B, 0x000C04E0, 0x00000000, 0x00100000, 0x00000000, 0xC00C0C09, 0x00140C40, 0x0C470000, 
0x05004045, 0x00000004, 0xD10D0C4F, 0x00040440, 0x55710000, 0x03F13704, 0x00000020, 0x00040000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00030000, 0x00200104, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x01010000, 0x00000004, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00010000, 0x00400000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000040, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x0C0C0000, 0x0000400D, 0x00000004, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xEFEF0000, 0xABE7FFFF, 0x00000039, 0xC1080809, 0x000C0450, 0x0C0D0000, 
0x0D50878B, 0x00000034, 0xD71D1C1B, 0x000C67D0, 0xFFEF0000, 0xFFEB7FDB, 0x0000002D, 0xC10C3D0F, 
0x00000840, 0x0C0B0000, 0x0870E50B, 0x0000000C, 0x80040C08, 0x00040400, 0xEFFF0000, 0x37C7FE91, 
0x00000025, 0x40040404, 0x00000400, 0x0C0F0000, 0x5490970B, 0x00000004, 0x80080F0F, 0x000C45C1, 
0x5C4F0000, 0x0DC1920D, 0x0000000C, 0x890F1D3B, 0x00045581, 0xEFFE0000, 0xFFF7FFB5, 0x0000003F, 
0xC3050C07, 0x00000170, 0x00000000, 0x04000000, 0x00000000, 0xC40D0C0B, 0x000C0C40, 0x0DFB0000, 
0x6F41CB8A, 0x00000014, 0xDE5F5C5F, 0x00385CF1, 0xDEA70000, 0x06D27A8D, 0x00000031, 0xC00C0C09, 
0x00040000, 0x04080000, 0x0000C009, 0x00000004, 0x00000000, 0x00000000, 0x0D7F0000, 0xE2C2F758, 
0x00000000, 0x40040809, 0x000C0400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0xE6F70000, 0xEBA33E8D, 
0x0000001D, 0x50040C0C, 0x000C0410, 0x0C0D0000, 0x0871C30F, 0x00000014, 0x4004040D, 0x00000010, 
0x7FDF0000, 0xF7FB7B59, 0x0000001E, 0x40040405, 0x00040800, 0x00040000, 0x0C104005, 0x00000000, 
0xFA4C1C5F, 0x000C5930, 0xFBFB0000, 0x37F7FF81, 0x00000022, 0x00000404, 0x00000000, 0x0C0F0000, 
0x0590810C, 0x00000008, 0x800C0809, 0x000C0400, 0x080E0000, 0x04408008, 0x00000004, 0xC00C080D, 
0x00040400, 0x35E7C000, 0x5F73FF55, 0x00000004, 0xC30E0C0D, 0x00040C60, 0x00000000, 0x0C000000, 
0x00000000, 0x40040405, 0x00000400, 0x2C0F0000, 0x5D119E0D, 0x0000000C, 0xDE1D1C5F, 0x00085DF1, 
0xFFFB0000, 0x42B36E8D, 0x00000034, 0x410C0404, 0x00000000, 0x0C080000, 0x04108008, 0x00000000, 
0x00000000, 0x00000000, 0x05570000, 0x00D01F44, 0x00000000, 0x40400C49, 0x00040501, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xB3F70000, 0x7FB23BCD, 0x0000001E, 0x00000404, 0x00040410, 0x00150000, 
0x00104103, 0x00000004, 0x40000005, 0x00000000, 0xEFDF0000, 0x67F27F5D, 0x00000006, 0x40040404, 
0x00000800, 0x0C040000, 0x04100000, 0x00000000, 0xD70D1D5F, 0x000C59F5, 0xFDFB0000, 0x37B5FF51, 
0x00000010, 0x00000C04, 0x00000000, 0x0C0C0000, 0x00008004, 0x00000000, 0x40080C09, 0x000C0000, 
0x08090000, 0x10004000, 0x00000000, 0x400C0805, 0x00040500, 0xD6B74000, 0xFAB3FF4D, 0x00000005, 
0x40010015, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 0xC00C0C0D, 0x000C0D00, 0x09D70000, 
0x2911C44D, 0x00000004, 0xBF0D4C4F, 0x000814F1, 0x67DD0000, 0x13B36F04, 0x00000000, 0x000C0006, 
0x00000000, 0x0C0C0000, 0x0000C00C, 0x00000004, 0x00000000, 0x00000000, 0x04570000, 0x00522544, 
0x00000000, 0x5FCC4C07, 0x00001401, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00C00100, 0x00000000, 0x00000003, 0x00000000, 0x52630000, 0x07702345, 
0x00000004, 0x472D0D6F, 0x000456B1, 0x088D0000, 0x065141CF, 0x00000014, 0xD309CF1E, 0x00185560, 
0x8EE70000, 0x17F12203, 0x00000014, 0x45043C05, 0x00000500, 0xC80F0000, 0x4C405507, 0x00000000, 
0x73040409, 0x00000030, 0xCED70000, 0x23A22740, 0x00000010, 0x40040004, 0x00000000, 0x080B0000, 
0x04408009, 0x00000000, 0xD7C95BDF, 0x001D5791, 0x0D3A0000, 0x14C35909, 0x00000000, 0x679DFBDB, 
0x00348F96, 0x00410000, 0x09502404, 0x00000004, 0xC30D5957, 0x000447B3, 0x00000000, 0x04000000, 
0x00000000, 0xBEDDAEAF, 0x000877F7, 0x0CFF0000, 0x4F8697CF, 0x0000002C, 0xD7CF5D9B, 0x001C4FD1, 
0x00410000, 0x00400440, 0x00000000, 0x00040404, 0x00004000, 0x04050000, 0x00000000, 0x00000000, 
0x40001003, 0x00000500, 0x04070000, 0x04805144, 0x00000000, 0x4004040D, 0x00340000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x20200200, 0x00000000, 
0x00000002, 0x00000000, 0xC3970000, 0x07A03359, 0x00000005, 0x00000000, 0x00000000, 0x00000000, 
0x00100000, 0x00000000, 0x00000000, 0x00000000, 0x4FCF0000, 0x52F03F4D, 0x00000019, 0x00000000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xDBDB0000, 0x26F0B7D0, 
0x00000010, 0x00000000, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00040405, 0x00000000, 
0x00410000, 0x00400000, 0x00000000, 0x00000004, 0x00000000, 0x41830000, 0x4EF1664C, 0x00000004, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040408, 0x00000000, 0x00010000, 
0x00000041, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00400100, 0x00000000, 0x00040000, 
0x00040000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00060000, 0x00401004, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x97530000, 0x37F1379F, 
0x0000000D, 0x40000404, 0x00000010, 0x00000000, 0x00004001, 0x00000010, 0x51040C07, 0x00000050, 
0x5F5F0000, 0x12B1334A, 0x8000000C, 0x01000004, 0x00000800, 0x00040000, 0x00000000, 0x00000000, 
0xC00C0C0C, 0x000C0000, 0xEF8D0000, 0x13F23740, 0x00000020, 0x00000000, 0x00000000, 0x04010000, 
0x40000004, 0x00000000, 0x40040805, 0x00080040, 0x04040000, 0x00000000, 0x00000000, 0x01051C07, 
0x000441C1, 0x14130000, 0x5C70BF50, 0x00000000, 0x40000004, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0xC00C0C0D, 0x00040400, 0x04130000, 0x054245C1, 0x00000004, 0x40010000, 0x00000000, 
0x00000000, 0x00011400, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x80000000, 0x00000000, 
0x00000000, 0x00040000, 0x0C450000, 0x00007500, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x40810000, 0x11403900, 0x00000000, 0x00000000, 0x00000000, 0x08040000, 
0x0800020A, 0x00000000, 0x00000000, 0x00000000, 0x02810000, 0x00601500, 0x00000000, 0x40000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040004, 0x00000000, 0x04550000, 0x01C09500, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01101400, 0x00000000, 
0x86040C04, 0x00000420, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000000, 0x04000000, 
0x00004000, 0x00000000, 0x40050C07, 0x00040460, 0x01140000, 0x00500100, 0x00000000, 0x00040000, 
0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40010000, 0x00000100, 
0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x41530000, 0x55A03A51, 
0x00000010, 0xC1040804, 0x00040410, 0x0C010000, 0x000041C3, 0x00000010, 0x50040805, 0x00000010, 
0x4F1E0000, 0x47E16301, 0x00000000, 0x41040004, 0x00000410, 0x04040000, 0x04104000, 0x00000000, 
0x40040004, 0x00000000, 0x04030000, 0x00413501, 0x00000000, 0x40000005, 0x00000000, 0x0C020000, 
0x00004000, 0x00000000, 0xC50C0C0F, 0x000C1400, 0x0C1D0000, 0x04415404, 0x00000000, 0xF0050F4F, 
0x00010380, 0x51010000, 0x0DB17540, 0x00000000, 0x50050C04, 0x00000250, 0x00000000, 0x00000000, 
0x00000000, 0xD1080D0D, 0x00000540, 0x085B0000, 0x27C0454E, 0x00000010, 0x80070401, 0x00000000, 
0x05010000, 0x00511581, 0x00000000, 0x40080400, 0x00000000, 0x04040000, 0x00004006, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040404, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x00200100, 0x00000000, 
0x00000003, 0x00000000, 0x52B30000, 0x576136C5, 0x00000004, 0x00040404, 0x00000400, 0x00000000, 
0x00000000, 0x00000010, 0x00000404, 0x00000000, 0x57570000, 0x816527D9, 0x00000004, 0x00000000, 
0x00000000, 0x04040000, 0x00000000, 0x00000000, 0x40040404, 0x00000000, 0x4C5B0000, 0x1141E540, 
0x00000010, 0x00000000, 0x00000000, 0x08040000, 0x0000C000, 0x00000004, 0x40040C04, 0x00040000, 
0x04080000, 0x00004004, 0x00000000, 0x00040404, 0x00040000, 0x54030000, 0x05316304, 0x00000000, 
0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000004, 0x00000000, 0x04040000, 
0x00000000, 0x00000000, 0x40000000, 0x00000000, 0x00510000, 0x00105541, 0x00000000, 0x00040000, 
0x00000000, 0x00040000, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x40530000, 0x000020C0, 
0x00000000, 0xC20C0405, 0x00040400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001400, 
0x00000000, 0x00000000, 0x00000010, 0x00000000, 0x00004200, 0x00000000, 0x40000006, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000404, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04000000, 
0x00000000, 0x00000000, 0x03000000, 0x00000000, 0x00030000, 0x00000000, 0x00000000, 0x00000400, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000C00, 0x00000000, 0x00030000, 0x00004001, 0x00000000, 0x00000003, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000C00, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
 }; 

// ****   TRD header   ******************************************************
             
ROM_DATA tr_descr_type img_trd_header =  
 { 
    {".\\data\\tfn05.trd"},    
    {'T','r','#',0x33},    
    {'E','n','g',0x00},    
    {'1','.','0',0x00},    
    0,                          // h_trd  
    0,                          // p_trd  
    0,                         // cheksum   
 }; 

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\trd_imgf.cpp ===
// **************************************************************************
// *    TRD file as C file                                                  *
// **************************************************************************

#include "ams_mg.h"  
#include "triads.h"  

// ****   DTI body   ********************************************************
ROM_DATA _ULONG img_trd_body[4001] =  
 {  
0xFFFFFFFC, 0x372EFFFF, 0xF7F30BA1, 0x7FF7BF6D, 0x04005029, 0xC20D0D5D, 0x20040D31, 0x6D5F1120, 
0x0D72D30F, 0x00522008, 0xC01D4C4F, 0x30084C30, 0xB69A2480, 0x1FE53F45, 0x10000017, 0xDA0C1D5E, 
0x20000C71, 0x0C0D1110, 0x0C30D20A, 0x01503004, 0xC10C0C4D, 0x20080F50, 0x97A50012, 0x12E17F48, 
0x00001011, 0xC0040C0E, 0x20001C10, 0x48090000, 0x4820950A, 0x00001004, 0xD10C0C4F, 0x22080D40, 
0x5D5F0050, 0x0E15D90C, 0x13903008, 0xD04D4D5F, 0x30040941, 0x79F50001, 0x1EB73A44, 0x000C0011, 
0xD74E5D4E, 0x30040DB6, 0x00040291, 0x0C000004, 0x00000000, 0xD40D5D4D, 0x30048D41, 0x1DCF0282, 
0x5F57D64E, 0x2040300C, 0xD00F5C9E, 0x30195870, 0x55550251, 0x02A13644, 0x00000010, 0xC11C0C0D, 
0x20000821, 0x08090100, 0x84108009, 0x00000004, 0x00080005, 0x10011000, 0x080B0000, 0x14008004, 
0x00001000, 0x80050818, 0x10001400, 0x00000000, 0x00000000, 0x00000000, 0x01000003, 0x00000000, 
0x00040000, 0x00000000, 0x00000000, 0x2B00C2D1, 0x0000332A, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x04008000, 0x00000001, 0x01400000, 
0x01100000, 0x00000000, 0x00000000, 0x00000300, 0x00000000, 0x00000200, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00410000, 0x01500500, 
0x00000000, 0xC34D0A59, 0x100448A0, 0x0DCA0440, 0x0B69828F, 0x00402004, 0x892E094A, 0x10142960, 
0x01410040, 0x11501100, 0x00000000, 0x41087409, 0x10000161, 0x8D090000, 0x0820B90E, 0x00402000, 
0x5509050A, 0x00000450, 0x8F220000, 0x43F07B00, 0x00000002, 0x80040805, 0x10000400, 0x04460000, 
0x0550404A, 0x00000004, 0xDB8D9EAF, 0x20085A56, 0x0D2E0000, 0x4452AD0C, 0x00403004, 0xB69DDBDF, 
0x2C156BD9, 0x00020080, 0x09911140, 0x20004000, 0xC10E0809, 0x10000673, 0x00010001, 0x0C000000, 
0x00000000, 0xAE8CEFEF, 0x24156BF9, 0x099B0040, 0x06DA554A, 0x00001014, 0x864E0D8B, 0x20140FF0, 
0xA6D30040, 0x23F61A20, 0x00000003, 0xC1080C0D, 0x10000520, 0x01050040, 0x00500544, 0x00000000, 
0x40040805, 0x10004000, 0x090A0000, 0x01D05504, 0x00002000, 0x40080409, 0x10140414, 0x10000000, 
0x00000200, 0x00000000, 0x00000000, 0x00000000, 0x00080000, 0x00008000, 0x00000000, 0x02000000, 
0x00000020, 0x55550000, 0x51641500, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00400000, 0x02002000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x55A20000, 0x5BA17649, 0x00004014, 0x41040444, 0x10040000, 0x00010000, 
0x00000000, 0x00000000, 0x80040405, 0x00000400, 0x418A0000, 0x05B02645, 0x00000005, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040004, 0x00000400, 0x5E590000, 0x12A5A751, 
0x00401010, 0x00000800, 0x00000400, 0x00000000, 0x00000001, 0x00000000, 0x800C0C08, 0x20040400, 
0x04010090, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x45550000, 0x5DA06A49, 0x04000005, 
0x00000001, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x80080C09, 0x20140800, 0x08551040, 
0x06008004, 0x00001000, 0x00040801, 0x00000000, 0x4A450000, 0x02A02654, 0x00002004, 0x00000800, 
0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04050000, 0x01100104, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x20040595, 0x00000160, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000040, 0x00000200, 0x00000000, 
0x01100000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 0x00000400, 0x00000000, 0x00000040, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x52A20000, 0x1BF37B1D, 
0x00004000, 0x00000000, 0x00000040, 0x08080000, 0x09208109, 0x00802000, 0x40000401, 0x00000440, 
0x16570000, 0x2BF33F44, 0x00000004, 0x40000106, 0x00000010, 0x04000000, 0x01000000, 0x00000000, 
0xE54C0C0E, 0x30044A60, 0x6F5E0092, 0x27E7B600, 0x00803000, 0x00000000, 0x00000000, 0x08160000, 
0x01500405, 0x00001004, 0x80080C0C, 0x20040900, 0x00000001, 0x00000004, 0x00000000, 0x10000404, 
0x00000111, 0x595A0000, 0x5EB6BF0A, 0x20004000, 0x00000042, 0x00000000, 0x00010000, 0x08000000, 
0x00000000, 0xC00C080D, 0x30040840, 0x40061090, 0x04000004, 0x00000000, 0xC00C0C1A, 0x20000CA0, 
0x08160080, 0x02B22B08, 0x00001000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00A10000, 0x01101000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x16000A06, 
0x000001A1, 0x00000000, 0x00000000, 0x00000000, 0x10000000, 0x00000200, 0x00000000, 0x00000000, 
0x00000000, 0x00000010, 0x00000000, 0x02000000, 0x00902100, 0x00000000, 0x00000000, 0x00000100, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x85960000, 0x66623A49, 0x00004004, 0x40000001, 0x00000000, 0x00050000, 
0x00000000, 0x00000000, 0x01050405, 0x00040000, 0x529B0000, 0x7EF37E55, 0x00000412, 0x00000001, 
0x00000000, 0x08050000, 0x00400004, 0x00001000, 0x40040405, 0x20040400, 0xBEDE0040, 0x27FBAA50, 
0x00001026, 0x44080409, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00040405, 0x00000011, 
0x04040000, 0x00004008, 0x00000000, 0x00040405, 0x00000000, 0x40820000, 0x5EA27A08, 0x00000016, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC0080C09, 0x20000400, 0x00030001, 
0x01004040, 0x00000000, 0x00000001, 0x00000000, 0x08D70000, 0x11A5190D, 0x00000000, 0x00040804, 
0x00000000, 0x00040000, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00402000, 
0x00000000, 0x00040400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0xAE20B9E6, 0x040032F7, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00400000, 
0x01A00200, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001000, 0x00000000, 0x04000002, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x51510000, 0x1D517548, 
0x00000000, 0x40040915, 0x00000410, 0x09470000, 0x0B64C14B, 0x00410004, 0x85084906, 0x10044450, 
0x01420000, 0x02501440, 0x00000000, 0x81043406, 0x00000990, 0x44090000, 0x04605609, 0x00000004, 
0x44040405, 0x00000410, 0x91520000, 0x01513740, 0x00000010, 0x40040905, 0x00000000, 0x04060000, 
0x00504404, 0x00000000, 0xC749995F, 0x26041AD9, 0x0C3E0090, 0x0443990C, 0x00401004, 0xB56DBBDF, 
0x24142FE9, 0x51010190, 0x05611008, 0x00000000, 0x81050809, 0x10000F71, 0x00000041, 0x08000000, 
0x00000000, 0xBE59AAEF, 0x181477F6, 0x55970000, 0x0BDB9505, 0x00001000, 0xA10A089F, 0x201447A1, 
0x55530000, 0x33F22708, 0x00000013, 0x80080C0A, 0x20000860, 0x04060140, 0x01400004, 0x00000000, 
0x800D088A, 0x20000743, 0x05060000, 0x00501501, 0x00000000, 0x01040406, 0x00100400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04004000, 0x00000100, 0x00000000, 
0x00000000, 0x00010000, 0x01001000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x10000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x55A10000, 0x2AA06A4D, 0x00000805, 0x00040001, 0x00000000, 0x04000000, 
0x00000000, 0x00000000, 0x01000000, 0x00000100, 0x05820000, 0x0AA02904, 0x00000010, 0x960C0C0A, 
0x20000860, 0x00040040, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x9ADA0000, 0x02A87600, 
0x00402002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x90080808, 0x10000800, 
0x00040040, 0x00000008, 0x00000000, 0x00000005, 0x00000040, 0x45410000, 0x0870750C, 0x00000005, 
0x41000001, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0xC008080E, 0x20000800, 0x00020081, 
0x00001001, 0x00000000, 0x00050401, 0x00000000, 0x80440000, 0x02A01514, 0x00000004, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x45000641, 0x00002170, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000040, 0x00000000, 0x00000000, 
0x00200000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x81550000, 0x1AB17709, 
0x00004024, 0x00000401, 0x00040000, 0x00010000, 0x00000000, 0x00000000, 0x40040004, 0x00000000, 
0x010B0000, 0x06F0BA04, 0x00000000, 0x00000000, 0x00000000, 0x04040000, 0x00100104, 0x00401000, 
0x40040409, 0x00000210, 0x5D550000, 0x16ADAA10, 0x00402000, 0x00040000, 0x00000000, 0x00000000, 
0x00004000, 0x00000000, 0x80080808, 0x10000400, 0x08040000, 0x00000000, 0x00000000, 0x80080C09, 
0x20040400, 0x45960040, 0x1DA16604, 0x10004000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0xC008080D, 0x20000400, 0x040200A0, 0x01000000, 0x00000000, 0x80040806, 0x00000040, 
0x0C090000, 0x01601A18, 0x00806044, 0x00000001, 0x00000000, 0x04040000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00010000, 0x00020000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xB5000906, 
0x000002A0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000040, 0x00000100, 0x00000000, 0x00606000, 0x00000000, 0x10000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x56A60000, 0x5ABA7A59, 0x08008014, 0x00000000, 0x00000000, 0x00000000, 
0x00100000, 0x00000000, 0x00040005, 0x00000000, 0x65970000, 0x6AB06A49, 0x00000025, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x69960000, 0x22E96A45, 
0x00001010, 0x00000000, 0x00000000, 0x00050000, 0x00000004, 0x00000000, 0x04040405, 0x10040400, 
0x08040040, 0x00004004, 0x00000000, 0x80080406, 0x10000040, 0x56560000, 0x5AA56E08, 0x00000014, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x84080805, 0x20000400, 0x00010000, 
0x01004004, 0x00000000, 0x48000442, 0x00000250, 0x45550000, 0x02501908, 0x00000000, 0x00000000, 
0x00000000, 0x04040000, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x41150000, 0x00420400, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0xA9044956, 0x000012E4, 0x00000010, 0x00000000, 0x00000000, 
0x18000000, 0x00000101, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00010000, 
0x11A42900, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x51660000, 0x1BA67B48, 
0x00000014, 0x57080819, 0x20040820, 0x0C4E0040, 0x0BA0828F, 0x00001014, 0x90194D0A, 0x30000990, 
0x52570080, 0x5EF13B09, 0x00000010, 0x810C3807, 0x10000590, 0x0C090040, 0x0920B50A, 0x00402000, 
0x40040005, 0x00000010, 0x04020000, 0x01400008, 0x00000000, 0x40000004, 0x00000440, 0x04050000, 
0x01504045, 0x00000000, 0x9B4D0D1B, 0x210415C0, 0x0C1E0040, 0x0843890C, 0x00402000, 0xA56DFFDF, 
0x34242BD9, 0x42460040, 0x16613A00, 0x00001000, 0x43050809, 0x10100952, 0x00000000, 0x0C000000, 
0x00000000, 0x9A484D9F, 0x200416A0, 0x6CDF0040, 0x0BEADE5D, 0x00403014, 0xC50D0D4F, 0x30140EE0, 
0x04010081, 0x00401400, 0x00000000, 0x800C0C0D, 0x20000420, 0x00040040, 0x00000004, 0x00000000, 
0x4004080B, 0x10000100, 0x04040000, 0x00000000, 0x00000000, 0x40040409, 0x00101000, 0x00000000, 
0x00100000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x11004802, 
0x000013A0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x80800000, 0x11301900, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x51910000, 0x15526945, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x158A0000, 0x1F501100, 0x10000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01150000, 0x10101541, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x14550000, 0x0CA0214A, 0x00000044, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x04000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x82140000, 0x11E1150C, 0x00000001, 0x00000000, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001050, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x51560000, 0x51612545, 
0x00004014, 0x00000000, 0x00000400, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 
0x14410000, 0x11601504, 0x00004004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x4504040A, 0x00000450, 0x45560000, 0x01916640, 0x00000000, 0x00000000, 0x00000000, 0x00050000, 
0x00004000, 0x00000000, 0x40000404, 0x00040000, 0x00050000, 0x00000000, 0x00001000, 0x40000400, 
0x00000000, 0x01110000, 0x55511541, 0x00004014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x40040404, 0x00040400, 0x00060000, 0x40004001, 0x00000000, 0x40040004, 0x00000000, 
0x00140000, 0x00601400, 0x00000000, 0x00000000, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00050000, 0x00004004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 
0x00000050, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x96E70000, 0x6BB97D5E, 0x04004415, 0x40040804, 0x00000410, 0x00040000, 
0x04008045, 0x00000000, 0x4404040A, 0x10004550, 0x55DB0001, 0x6EF97D59, 0x00000416, 0x40044805, 
0x00000010, 0x08040000, 0x04200008, 0x00002000, 0x40040404, 0x00000000, 0xEEFE0000, 0x27EEF954, 
0x00802055, 0x00000000, 0x00000000, 0x04090000, 0x00404105, 0x00000000, 0x800C0C0E, 0x20040850, 
0x040A0080, 0x04804004, 0x00001000, 0x00400441, 0x10000000, 0xD1A60000, 0x6ABB7C4C, 0x00000008, 
0x40050405, 0x10000110, 0x00000000, 0x08000000, 0x00000000, 0x40040005, 0x00000000, 0x04070000, 
0x01004445, 0x00001000, 0x40090949, 0x20000960, 0x599A0040, 0x13E2190D, 0x00001012, 0x00040404, 
0x10000000, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x44460000, 0x41919400, 
0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 
0x00000000, 0x04000000, 0x00000000, 0x5804C99A, 0x000022A2, 0x00000000, 0x00000000, 0x00000000, 
0x04000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x04000040, 0x00000100, 0x80500000, 
0x22501900, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0xD6960000, 0x0BB5776D, 
0x08004415, 0x83080809, 0x10000430, 0x01410000, 0x00001104, 0x00000000, 0x00000400, 0x00000040, 
0x46470000, 0x0BF13A09, 0x00000016, 0x40000000, 0x00000400, 0x00000000, 0x00100000, 0x00000000, 
0x00000000, 0x00000000, 0x9E960000, 0x03EC7740, 0x00800005, 0x00000000, 0x00000000, 0x00000000, 
0x00000001, 0x00000000, 0x00040406, 0x00000000, 0x0C0A0000, 0x0C008108, 0x00002000, 0x40080804, 
0x20000000, 0x97E50000, 0x1EA5794D, 0x00000018, 0xC309180E, 0x20000AF0, 0x00000242, 0x00000400, 
0x00000000, 0x40040000, 0x00000000, 0x00460000, 0x01004044, 0x00000000, 0x00000400, 0x10001000, 
0x04050000, 0x02A03B41, 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00050000, 0x02504000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x2A005B86, 
0x000002B1, 0x00000000, 0x00000000, 0x00000000, 0x10000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x01000040, 0x00000000, 0x01000000, 0x02202000, 0x00000000, 0x0D000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x92A70000, 0x2F653B4D, 0x08004424, 0x40000445, 0x00000400, 0x1C0A0000, 
0x0AA0C24E, 0x01402004, 0x811D0C0F, 0x20040DB0, 0x55470040, 0x9AF13F55, 0x00000016, 0xC2080808, 
0x20000420, 0x0D1A0040, 0x4AA08259, 0x00802000, 0x40440405, 0x10000400, 0xADAB0000, 0x37FEA941, 
0x00801051, 0x80040804, 0x00000800, 0x04050000, 0x00404104, 0x00001000, 0x00040404, 0x10000000, 
0x04040040, 0x00004004, 0x00000000, 0x80080C0E, 0x30040840, 0x55960140, 0x6FB23E08, 0x04004054, 
0x00040401, 0x00000000, 0x00020000, 0x0C000000, 0x00000000, 0x40080805, 0x10040040, 0x6D8F0001, 
0x5B06954D, 0x00402004, 0x810E0D4F, 0x301418F1, 0x1D9B0082, 0x02901A08, 0x00001000, 0x800C0C08, 
0x10000410, 0x04040000, 0x00000000, 0x00000000, 0x00040001, 0x00000000, 0x00060000, 0x04404404, 
0x00000000, 0x40040805, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x000C0000, 0x04008000, 0x00000000, 0x8904AD9B, 0x001012B5, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000040, 0x00000000, 0x44000000, 
0x12500000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x41410000, 0x06545640, 
0x00000000, 0x42280819, 0x100406A0, 0x09CA0000, 0x0A74828E, 0x00802004, 0x90594D09, 0x20140C50, 
0x40410080, 0x09501104, 0x00000001, 0x80082806, 0x10000501, 0x08090000, 0x0830650D, 0x00401004, 
0x61040409, 0x20000400, 0x9A430000, 0x23F43600, 0x00000002, 0x00000804, 0x00000000, 0x04050000, 
0x00404105, 0x00000004, 0xC74D6E5A, 0x20181E81, 0x087E0040, 0x0543AC0C, 0x00802004, 0xF46DFFDF, 
0x28182BD8, 0x02010000, 0x11521540, 0x00000000, 0x855A080A, 0x30080E63, 0x00110040, 0x08400000, 
0x00000000, 0xAE9CDFEE, 0x241457F6, 0x0C8B0140, 0x06C6A64D, 0x00402004, 0x814A0C1E, 0x200406A0, 
0xAAAB0040, 0x73F72B6A, 0x00006025, 0x8008080A, 0x10000040, 0x04050040, 0x01401004, 0x00000000, 
0x00081405, 0x00040000, 0x0C490000, 0x00404000, 0x00002000, 0x50000405, 0x00040000, 0x00000000, 
0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000041, 
0x00000140, 0x01050000, 0x00441040, 0x00000000, 0x00000000, 0x00000000, 0x00030000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000400, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x02000000, 0x00000000, 0x00000000, 0x00000200, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xC1A10000, 0x5BF66748, 0x0000000C, 0x00000000, 0x00000000, 0x10010000, 
0x04000000, 0x00000000, 0x00004041, 0x00000040, 0x058B0000, 0x0EB17A08, 0x00000014, 0x00000001, 
0x00000000, 0x00010000, 0x00010000, 0x00000000, 0x90080809, 0x20040010, 0x4A550080, 0x17A5A600, 
0x00801010, 0x00000400, 0x00000000, 0x00000000, 0x00000044, 0x00000000, 0xC00C0D0C, 0x20000C41, 
0x04010041, 0x00000000, 0x00000000, 0x00000410, 0x00000401, 0x41410000, 0x5EFB770C, 0x00401000, 
0xC2040D49, 0x20000821, 0x00010000, 0x00000000, 0x00000000, 0xC00C0D09, 0x30000800, 0x050702C1, 
0x01004104, 0x00001004, 0x440C0C0A, 0x20000950, 0x55760041, 0x02A0131C, 0x00000004, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00200000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00004000, 0x00000000, 0x60401D86, 0x000002B1, 0x00000000, 0x00000000, 0x00000000, 
0x01000000, 0x00000200, 0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x00000100, 0x00400000, 
0x01600100, 0x00000000, 0x01000080, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00001000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x0C0F0000, 0x0000800C, 0x02403000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xE7F70000, 0x7BA77BAE, 0x08006098, 0x40080808, 0x10040410, 0x0C060040, 
0x0950814B, 0x00402004, 0x9018080B, 0x200008A1, 0xAAEB0040, 0x7FF77F69, 0x00004815, 0x81040409, 
0x10000400, 0x0C0E0000, 0x0850A009, 0x00402000, 0x40040404, 0x10000400, 0xEEEA0001, 0x37EEBE51, 
0x00802026, 0x00000400, 0x00000000, 0x04060000, 0x00404405, 0x00000000, 0x84080909, 0x10040840, 
0x0C0D0000, 0x08408008, 0x00003004, 0x840D0C1D, 0x20040440, 0xE7EA0040, 0x6EA77E6D, 0x08005019, 
0x81054405, 0x100005A0, 0x00000000, 0x08000000, 0x00000000, 0x800C0C0D, 0x20040800, 0x085B0240, 
0x094A8149, 0x00402000, 0x950E0C0F, 0x201408A0, 0x5A960040, 0x12E66908, 0x00001016, 0x400C0808, 
0x20000400, 0x04080040, 0x00004004, 0x00000000, 0x00040001, 0x00000000, 0x00060000, 0x01414140, 
0x00000000, 0x40040405, 0x10000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00040000, 0x04004000, 0x00000000, 0xAA16FEDF, 0x20003ADB, 0x00000000, 0x00000000, 0x00000000, 
0x16000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x10000080, 0x00000000, 0x81410000, 
0x22E01000, 0x00000000, 0x18000040, 0x00002200, 0x00000000, 0x00000000, 0x00000000, 0x01000001, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x96A70000, 0x2FA5BA4D, 
0x00004005, 0x40040404, 0x00040400, 0x08090000, 0x0820810E, 0x00801000, 0x01041405, 0x00000450, 
0x55CB0000, 0x1EF27E4C, 0x00000026, 0x80000809, 0x10000010, 0x00050000, 0x00100000, 0x00000000, 
0x4408050A, 0x10004501, 0xAF6B0000, 0x23A9FA45, 0x00801002, 0x40000000, 0x00000000, 0x04050000, 
0x00104008, 0x00000004, 0x8004040D, 0x00000000, 0x0C050000, 0x00004008, 0x00001000, 0x40080405, 
0x00000400, 0x55D60000, 0x6D723B4C, 0x00000004, 0xC10A0D0D, 0x20000421, 0x00000080, 0x0C000000, 
0x00000000, 0x00040409, 0x10000000, 0x0C1E0000, 0x0810C50C, 0x00803004, 0xC50D1C4F, 0x20040871, 
0x6AAA0080, 0x05B21A6D, 0x00401010, 0x00040400, 0x00000000, 0x04140000, 0x00000004, 0x00000000, 
0x00000000, 0x00000000, 0x01410000, 0x00902900, 0x00000000, 0x00000401, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x69544E97, 
0x000011AA, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x05400000, 0x11240400, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000020, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xD6B60000, 0x5BAA3B5D, 0x00004056, 0x00040404, 0x00000100, 0x00020000, 
0x00004002, 0x00000000, 0x00000401, 0x00000000, 0x65DB0000, 0x1DF53F09, 0x00000012, 0x00000005, 
0x00000010, 0x00000000, 0x10000000, 0x00000000, 0xA508080A, 0x30040450, 0xBEEB0080, 0x37FEFF51, 
0x00802010, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x04040809, 0x10040000, 
0x04050000, 0x00004200, 0x00000000, 0x00040409, 0x00000001, 0x91A20000, 0x5E723A4C, 0x00004019, 
0x00000406, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xC00C0C0D, 0x20040C00, 0x01470282, 
0x04004049, 0x00000000, 0x81080C0A, 0x20004472, 0x4E5A0040, 0x03B12604, 0x00402010, 0x00000406, 
0x00000000, 0x04050000, 0x00004000, 0x00000000, 0x00000000, 0x00000000, 0x00060000, 0x00120100, 
0x00000000, 0x50050402, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x5A05CC53, 0x000001F1, 0x00000000, 0x00000000, 0x00000000, 
0x05000000, 0x00000200, 0x00000000, 0x00000000, 0x00000000, 0x00000040, 0x00000100, 0x40010000, 
0x00600900, 0x00000000, 0x04000000, 0x00000200, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x41620000, 0x07A03648, 
0x00000004, 0x47180419, 0x10042590, 0x04890000, 0x0B60824A, 0x00001000, 0x40189D0A, 0x10040460, 
0x15570040, 0x1AF03B08, 0x00004014, 0x01042006, 0x00000150, 0x48590000, 0x09009909, 0x00002000, 
0x00000008, 0x00000000, 0x6A570000, 0x23E22700, 0x00802010, 0x80040804, 0x00000400, 0x04050000, 
0x05104005, 0x00000000, 0x9A489D5E, 0x20041785, 0x1C1A0040, 0x08415408, 0x00402000, 0x504C4E4B, 
0x10000281, 0x00010000, 0x02401008, 0x00000000, 0x42050C0A, 0x24000662, 0x00000040, 0x08000000, 
0x00000000, 0xF54D9EAF, 0x20042BFA, 0x0D8B0000, 0x0BCA410D, 0x00402010, 0xC10E0C4F, 0x20100AB0, 
0x00010002, 0x00000000, 0x00000000, 0xC0080C08, 0x20000030, 0x00040040, 0x00000000, 0x00000000, 
0x00080803, 0x00000508, 0x44050000, 0x00004000, 0x00001000, 0x41040415, 0x00100000, 0x00010000, 
0x00400000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000926, 
0x000000A0, 0x04000000, 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x00200000, 0x00000000, 0x00000000, 0x00000200, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x81920000, 0x0AA5370D, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x41CF0000, 0x0AF03F08, 0x00000014, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x9EDA0000, 0x23E4A344, 
0x00402000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x45820000, 0x1A68270C, 0x10000008, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x400C0C0C, 0x10000000, 0x00000000, 
0x00000040, 0x00000000, 0x40000000, 0x00000000, 0x08020000, 0x00500100, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x22014846, 0x000001A0, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000000, 
0x00101100, 0x00000000, 0x00000040, 0x00000104, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x41510000, 0x05A02245, 
0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 
0x04150000, 0x01501105, 0x00004000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x40040004, 0x00000000, 0x45450000, 0x41501200, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00400000, 0x00000000, 0x00000404, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000001, 
0x00000040, 0x00010000, 0x00204510, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000400, 0x00000000, 0x00010000, 0x40000040, 0x00000000, 0x40010000, 0x00000000, 
0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00020000, 0x80000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00004000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x40800000, 0x11402500, 0x00000000, 0x00000000, 0x00000000, 0x08000000, 
0x04000204, 0x00401000, 0x00000000, 0x00000000, 0x00020000, 0x00A01A00, 0x00000000, 0x40000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040004, 0x00000000, 0x84950000, 0x11888904, 
0x00801001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x01101000, 0x00000000, 
0x82040804, 0x20000420, 0x00000000, 0x08000000, 0x00000000, 0x00000000, 0x00000000, 0x00040000, 
0x00000000, 0x00000000, 0x40040805, 0x20000420, 0x04040000, 0x01000000, 0x00000000, 0x00040400, 
0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00040400, 0x00001000, 0x40000000, 0x00400000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x10004481, 0x00000040, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x81520000, 0x09506549, 
0x00000000, 0x00000800, 0x00000010, 0x00000000, 0x00004201, 0x00001000, 0x10040004, 0x00000010, 
0x01060000, 0x09603101, 0x00000010, 0x00000000, 0x00000000, 0x00040000, 0x04000004, 0x00400000, 
0x00000004, 0x00000000, 0x00010000, 0x00401000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 
0x00000000, 0x00000000, 0x41040405, 0x00005000, 0x04250000, 0x00025000, 0x00001000, 0x40040649, 
0x10000100, 0x01010000, 0x09612500, 0x00000000, 0x40050800, 0x00000250, 0x00000000, 0x00000000, 
0x00000000, 0x40080505, 0x10000040, 0x180B0000, 0x02404404, 0x00001000, 0x40060400, 0x10000000, 
0x00050000, 0x00011000, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00004000, 0x00000000, 
0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04000402, 
0x00000080, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00100000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x40120000, 0x51511549, 0x00004000, 0x00040400, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x05060000, 0x41611504, 0x00000010, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40000404, 0x00000400, 0x44450000, 0x00505500, 
0x00400010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x10000004, 0x00000000, 
0x00040000, 0x00000000, 0x00000000, 0x00040004, 0x00040000, 0x41010000, 0x44006100, 0x00004000, 
0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x00000004, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04010000, 0x00100000, 0x00001000, 0x00000400, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00100000, 
0x00000000, 0x40040404, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x01004000, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000400, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x41120000, 0x0000610C, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00002008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x04010000, 0x01400040, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x50910000, 0x06512608, 0x00000000, 0x81040808, 0x20000820, 0x0C080010, 
0x0C20C20F, 0x00402000, 0x800C0808, 0x20000810, 0x00030000, 0x00E03600, 0x00000001, 0x820C0808, 
0x20000810, 0x080C0040, 0x0820920C, 0x00502008, 0x00040404, 0x10000000, 0x04040000, 0x01501000, 
0x00000000, 0x40000400, 0x02000400, 0x00000000, 0x00004004, 0x00000000, 0x80080C09, 0x30040800, 
0x08080080, 0x0800C008, 0x01401004, 0x80080808, 0x30000400, 0x91820040, 0x05611600, 0x00000000, 
0x820A080C, 0x10000820, 0x00000141, 0x0C000000, 0x00000000, 0x800C0C0C, 0x20040800, 0x0C0B0241, 
0x0901800D, 0x00001000, 0x800E0C8C, 0x30040830, 0x00000000, 0x00802000, 0x00000000, 0xC00C0C08, 
0x20040820, 0x00000180, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x04000000, 0x00000000, 0x05000942, 0x00001044, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00010000, 0x00000000, 
0x00000000, 0x00000400, 0x00000000, 0x00010000, 0x00400004, 0x00000000, 0x00100405, 0x00000000, 
0x00010000, 0x00001000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00004000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040000, 
0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000441, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04000000, 
0x00000000, 0x40000401, 0x00000000, 0x00010000, 0x01000400, 0x00000000, 0x00040001, 0x10000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000804, 0x10000000, 
0x08080000, 0x00000000, 0x00001000, 0x00000404, 0x10000000, 0x00000000, 0x00000000, 0x00000000, 
0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x40040806, 0x20000490, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000, 0x00000000, 0x08000000, 
0x00000102, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x08000000, 0x00000000, 0x00001000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 
0x04000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x40080401, 0x10000450, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000010, 0x08000000, 0x00100201, 0x00000000, 0x00040800, 0x00000000, 
0x00010000, 0x00400000, 0x00000000, 0x00000000, 0x00000000, 0x08000000, 0x04101204, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000800, 0x00000000, 0x0C000040, 0x00000000, 0x00000000, 0x00000800, 
0x00000000, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08000000, 
0x00000000, 0x00040C00, 0x00000000, 0x08030000, 0x00000000, 0x00000000, 0x00000800, 0x00000020, 
0x00000000, 0x00000000, 0x00000000, 0x00000800, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000404, 0x10000000, 
0x0C000000, 0x00000000, 0x00000000, 0x00000404, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00040806, 0x200004B0, 0x00000000, 0x00000000, 0x00000000, 0x00000804, 
0x10000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x40000800, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 0x00000804, 
0x10000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000402, 0x00000020, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000404, 0x10000000, 
0x04000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040402, 0x00000040, 0x00000000, 
0x00000000, 0x00000000, 0x00000406, 0x10000040, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
 }; 

// ****   TRD header   ******************************************************

ROM_DATA tr_descr_type img_trd_header =  
 { 
    {".\\data\fr_triad.trd"},    
    {'T','r','#',0x33},    
    {'E','n','g',0x00},    
    {'1','.','0',0x00},    
    0,                          // h_trd  
    0,                          // p_trd  
    0,                         // cheksum   
 }; 

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\trd_imgg.cpp ===
// **************************************************************************
// *    TRD file as C file                                                  *
// **************************************************************************

#include "ams_mg.h"  
#include "triads.h"  

// ****   DTI body   ********************************************************
ROM_DATA _ULONG img_trd_body[4001] =  
 {  
0xFFFFFFFC, 0x3A34FFFB, 0xA6B40000, 0x0EB23A85, 0x00004001, 0x86190C0C, 0x26100830, 0x04080000, 
0x04108206, 0x00000004, 0x840C0D0C, 0x25040860, 0x62900000, 0x5AB13A0E, 0x00004002, 0x83080C0C, 
0x26000830, 0x0C080000, 0x09709609, 0x00002504, 0x80080C1C, 0x2A040810, 0x12500000, 0x52A03902, 
0x00004000, 0x80000808, 0x15000800, 0x480C0000, 0x0830E608, 0x00002A00, 0x804C0C0C, 0x2A040900, 
0x4C1C0000, 0x0900C50D, 0x00002A04, 0x8008080C, 0x26040810, 0x25600000, 0x01A21645, 0x00000010, 
0x820A280C, 0x11000870, 0x00040000, 0x08000000, 0x00000000, 0x80090C0C, 0x26000800, 0x0CDC0000, 
0x5B03C149, 0x00002618, 0x800A0C4C, 0x1A040870, 0x55000000, 0x41603901, 0x00000000, 0xC0080C08, 
0x09000410, 0x0C4C0000, 0x0810800C, 0x00002A04, 0x00000000, 0x00000000, 0x00000000, 0x10004000, 
0x00000000, 0x80080818, 0x26048C00, 0x00000000, 0x00000000, 0x00000000, 0x15014000, 0x00000925, 
0x20100000, 0x00900140, 0x00000000, 0x00000030, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x91510000, 0x02601100, 
0x00000000, 0x564AA866, 0x002496A0, 0x04440000, 0x01044087, 0x00000000, 0x41181816, 0x00140660, 
0x50000000, 0x05100504, 0x00000000, 0x10046805, 0x10100360, 0x5D160000, 0x06A05509, 0x00000010, 
0x2A040806, 0x00000170, 0x15010000, 0x41612640, 0x00000000, 0x00000004, 0x00000000, 0x08050000, 
0x02404144, 0x00000010, 0x57885A6A, 0x04145791, 0x0C2A0000, 0x06424849, 0x00001100, 0x7ADAEBAA, 
0x003497A1, 0x00010000, 0x00400100, 0x00000000, 0x40091408, 0x00000452, 0x00000000, 0x04000000, 
0x00000000, 0x6A89AABA, 0x102547A5, 0x08820000, 0x02C14549, 0x00000000, 0x865E4C06, 0x10205A91, 
0xB9A20000, 0x46E22A54, 0x00008010, 0x40040401, 0x00000000, 0x04040000, 0x00000004, 0x00000000, 
0x10080401, 0x00000000, 0x08060000, 0x40400400, 0x00000000, 0x00080501, 0x00004400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x48120000, 0x02401000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x42950000, 0x09702246, 0x00000008, 0x00040405, 0x00040410, 0x00000000, 
0x00004000, 0x00000000, 0x00000000, 0x00000000, 0xAA4A0000, 0x9AF47A8E, 0x00000024, 0x01040405, 
0x01000000, 0x08040000, 0x00100100, 0x00000000, 0x40000405, 0x02000400, 0x48150000, 0x02A06240, 
0x00004000, 0x00000404, 0x04000000, 0x04000000, 0x00004000, 0x00000000, 0x80080808, 0x16000800, 
0x04050000, 0x40000004, 0x00000000, 0x00080404, 0x00000000, 0x46510000, 0x16605601, 0x00000001, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x8008090D, 0x26000800, 0x18850000, 
0x02104009, 0x00000100, 0x00040802, 0x00000050, 0x05800000, 0x01602100, 0x00004000, 0x00000400, 
0x00000000, 0x08040000, 0x00004004, 0x00000100, 0x00000000, 0x00000000, 0x04010000, 0x40401100, 
0x00000000, 0x00040400, 0x00004800, 0x00000000, 0x00000000, 0x00000000, 0x11000040, 0x00000410, 
0x01000000, 0x01500001, 0x00000000, 0x11014040, 0x40000020, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x50010000, 0x05611500, 
0x00000004, 0x00000000, 0x00000000, 0x00000000, 0x00004000, 0x00000000, 0x00000000, 0x00000000, 
0x01510000, 0x00401500, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0xBB8EAD2F, 0x2B20DFF0, 0x54040000, 0x01411100, 0x00000000, 0x00000000, 0x00000000, 0x9D460000, 
0x46901689, 0x00000010, 0x40000404, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00520000, 0x05501500, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04000000, 
0x00000000, 0x00040404, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040401, 0x00000000, 
0x00050000, 0x00410000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00010000, 0x00100000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x51920000, 0x1A612941, 0x00004014, 0x40000404, 0x10000410, 0x00000000, 
0x00000001, 0x00000000, 0x00000400, 0x00000010, 0x549B0000, 0x5BF17A49, 0x00000011, 0x01000004, 
0x10000410, 0x08040000, 0x00100000, 0x00001000, 0x40000400, 0x00000000, 0xD9890000, 0x26A16580, 
0x00000010, 0x00000404, 0x00000000, 0x00040000, 0x04004100, 0x00000400, 0x40080805, 0x00000800, 
0x04050000, 0x04000000, 0x00000000, 0x00080800, 0x00000800, 0x00510000, 0x54621640, 0x00000000, 
0x40001000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x80080809, 0x21000800, 0x44960000, 
0x12411440, 0x00001100, 0x04440806, 0x10004441, 0x14150000, 0x05A12685, 0x00000010, 0x00040000, 
0x00000000, 0x08040000, 0x00004008, 0x00000400, 0x00000000, 0x00000000, 0x00410000, 0x00001400, 
0x00000000, 0x40000400, 0x00004400, 0x00000000, 0x00000000, 0x00000000, 0x14000040, 0x00000000, 
0x00000000, 0x00100100, 0x00000000, 0x14000010, 0x00000060, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x41910000, 0x09512A41, 
0x00000000, 0xA2490C0A, 0x11100AA0, 0x04010000, 0x040040C7, 0x00000000, 0x56094C1A, 0x110048A0, 
0x01110000, 0x01602509, 0x00000000, 0x8508280A, 0x26000660, 0x9C0A0000, 0x0AA0A608, 0x00001010, 
0xAA040C19, 0x09000AB0, 0xEBE20000, 0x57E13B52, 0x00008020, 0x00000404, 0x00000000, 0x08090000, 
0x06609240, 0x00001100, 0xAB5A6E6B, 0x05245791, 0x4A2B0000, 0x05829508, 0x00002104, 0xAA9AAF6B, 
0x2520ABD2, 0x41210000, 0x05211100, 0x00000000, 0x81051409, 0x01000652, 0x00000000, 0x08000000, 
0x00000000, 0xBFDFFE7F, 0x2A30EFF6, 0x5DEB4000, 0x5BD2955A, 0x00001110, 0x55490C0B, 0x053046B0, 
0x99510000, 0x07A06555, 0x00004011, 0x80040805, 0x04000000, 0x08090000, 0x09508008, 0x00001A00, 
0x00040405, 0x00000112, 0x05410000, 0x00101000, 0x00000000, 0x80080809, 0x15004400, 0x00000000, 
0x00000000, 0x00000000, 0x10010000, 0x00000410, 0x10000000, 0x00000000, 0x00000000, 0x00000010, 
0x00000000, 0x08020000, 0x05000100, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x05A10000, 0x04902646, 0x00008001, 0x00000004, 0x00000010, 0x00000000, 
0x00000000, 0x00000000, 0x00040001, 0x00000000, 0x55520000, 0x09B1368A, 0x00000004, 0x65090C16, 
0x11000641, 0x08040000, 0x00100001, 0x00000000, 0x40040404, 0x05000400, 0x88450000, 0x01902140, 
0x00000021, 0x00000000, 0x00000000, 0x00000000, 0x00004104, 0x00000000, 0x80080808, 0x25040800, 
0x04080000, 0x00000000, 0x00000100, 0x00040804, 0x00000800, 0x00010000, 0x01702241, 0x00000000, 
0x41000004, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 0x81080C09, 0x25000400, 0x54560000, 
0x52510544, 0x00000000, 0x46091D17, 0x001055A1, 0x40400000, 0x01502401, 0x00004000, 0x00000400, 
0x00000000, 0x04040000, 0x00000000, 0x00000100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00040400, 0x10004900, 0x00000000, 0x00000000, 0x00000000, 0x22020140, 0x00000450, 
0x00000000, 0x00200000, 0x00000000, 0x12028000, 0x40000120, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x40650000, 0x05A12600, 
0x00004010, 0x01000004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040405, 0x00000000, 
0xBA370000, 0xD2F2BF9B, 0x00005521, 0x40000004, 0x11000010, 0x08010000, 0x00104104, 0x00000000, 
0x00000404, 0x01000000, 0x98250000, 0x0591A500, 0x00004400, 0x00000000, 0x01000000, 0x08000000, 
0x00004000, 0x00000000, 0x80080809, 0x21000000, 0x00140000, 0x00000000, 0x00000100, 0x40080804, 
0x10000400, 0x04010000, 0x01501204, 0x00004000, 0x01000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x80080808, 0x29000800, 0x65AA0000, 0x56915645, 0x00001010, 0x40040C07, 0x00000400, 
0x45140000, 0x02502504, 0x00000004, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00010400, 0x00000000, 0x00000400, 0x00000400, 0x00000000, 
0x00000000, 0x00000000, 0x20000010, 0x00000050, 0x00100000, 0x01100000, 0x00000000, 0x22000000, 
0x00000110, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x75650000, 0x1DA17B45, 0x00004000, 0x40041408, 0x00000010, 0x00000000, 
0x00000000, 0x00000000, 0x00040400, 0x00000010, 0x65A70000, 0x19F5BA8D, 0x00004114, 0x40000404, 
0x10000010, 0x08040000, 0x00000104, 0x00001100, 0x40000405, 0x04000000, 0x98950000, 0x12A16A40, 
0x00000000, 0x00000004, 0x00000000, 0x08000000, 0x00005000, 0x00000000, 0x844C481A, 0x16104A90, 
0x0C0A0000, 0x0A404108, 0x00001100, 0x46491D56, 0x11140A91, 0x25A10000, 0x01A12641, 0x00004000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x564E5D1A, 0x06205A91, 0x08960000, 
0x46101105, 0x00001010, 0x16095D27, 0x10205990, 0x50114000, 0x42512601, 0x00004000, 0x00000400, 
0x00000000, 0x08080000, 0x04004008, 0x00000604, 0x00000000, 0x00000000, 0x00000000, 0x01410000, 
0x00000000, 0x00040800, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x26012100, 0x40000A20, 
0x10400000, 0x00212102, 0x00000000, 0x01014150, 0x00000250, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x41020000, 0x01506600, 
0x00000000, 0x45045805, 0x10040A50, 0x04050000, 0x01004083, 0x00000000, 0x45080C06, 0x00000950, 
0xE7A20000, 0x5AB13716, 0x00008000, 0x41442805, 0x10001651, 0x5C0B0000, 0x0B902188, 0x00000000, 
0x15040804, 0x00000550, 0x04000000, 0x00000000, 0x00000000, 0x00040000, 0x00000000, 0x080A0000, 
0x06508000, 0x00000000, 0x96096A6A, 0x01105A80, 0x081A0000, 0x04425909, 0x00000000, 0x769AEF6B, 
0x1020AAE1, 0x01020000, 0x11513100, 0x00000000, 0x41041401, 0x00100042, 0x00000000, 0x04000000, 
0x00000000, 0x59949959, 0x00104660, 0x4CDA0000, 0x57D1598A, 0x00000400, 0x564D9D1B, 0x12244BA1, 
0x04000000, 0x00401800, 0x00000000, 0x4008080A, 0x00100040, 0x00040000, 0x00000004, 0x00000000, 
0x00040401, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40080815, 0x10001500, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000010, 0x00000000, 0x00400000, 0x00000000, 0x00000000, 
0x00000000, 0x08520000, 0x12001005, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x40410000, 0x00461442, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x42050000, 0x42502481, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04540000, 0x04501101, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x81400000, 0x01502100, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00024000, 0x00000000, 
0x00000000, 0x00100000, 0x00000000, 0x11000000, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x15120000, 0x0AA26A44, 
0x00000004, 0x00000004, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x40000000, 0x00000000, 
0x01020000, 0x12A1364E, 0x00000000, 0x01000404, 0x00000400, 0x08050000, 0x00000004, 0x00000100, 
0x00000404, 0x00000000, 0x48010000, 0x00A06100, 0x00000000, 0x00000000, 0x00000000, 0x04040000, 
0x00104000, 0x00000000, 0x80080809, 0x16000800, 0x04050000, 0x00000000, 0x00000100, 0x40040804, 
0x14000400, 0x14550000, 0x11A27A42, 0x00000000, 0x01000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x40080808, 0x16000400, 0x545A0000, 0x52100409, 0x00000000, 0x86481C07, 0x01005861, 
0x40500000, 0x42A12501, 0x00004000, 0x00000000, 0x00000000, 0x04010000, 0x04000004, 0x00001100, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40040804, 0x00000400, 0x00000000, 
0x00000000, 0x00000000, 0x09004000, 0x00000940, 0x00400000, 0x00112501, 0x00000000, 0x24020050, 
0x40000061, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xE2920000, 0x5AA17944, 0x00008004, 0x4114180A, 0x10004090, 0x00040000, 
0x00000002, 0x00000000, 0x55080816, 0x00000841, 0xE6B70000, 0x5AB2798E, 0x00000005, 0x45045906, 
0x01000560, 0x08050000, 0x06500104, 0x00000000, 0x00000405, 0x00000000, 0x9DDA0000, 0x16866584, 
0x00000121, 0x00000004, 0x01000000, 0x04050000, 0x45408004, 0x00001000, 0x54984C1A, 0x05145A81, 
0x08050000, 0x04000000, 0x00000200, 0x00040906, 0x00000440, 0x95A10000, 0x55D25446, 0x00004000, 
0x41010004, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 0x40040404, 0x00000000, 0x58960000, 
0x46515444, 0x00000000, 0x55491C17, 0x00104891, 0x91910000, 0x02903945, 0x00008011, 0x00040804, 
0x00000000, 0x04040000, 0x00004004, 0x00000000, 0x00000000, 0x00000000, 0x04010000, 0x00501400, 
0x00000000, 0x44044816, 0x00000540, 0x00000000, 0x00000000, 0x00000000, 0x20009180, 0x40000AA1, 
0x10500000, 0x41800101, 0x00004000, 0x00018090, 0x00000180, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x81960000, 0x0AA03659, 
0x00008015, 0x81090804, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 0x00400805, 0x00004050, 
0x05820000, 0x02B0764A, 0x00000005, 0x00000404, 0x01000010, 0x08050000, 0x00000004, 0x00000100, 
0x40010404, 0x00000000, 0x49550000, 0x07902240, 0x00008001, 0x00000000, 0x00000000, 0x04040000, 
0x00100000, 0x00000000, 0x40080405, 0x00000400, 0x0C160000, 0x0A414145, 0x00000000, 0x00040004, 
0x01000000, 0x06550000, 0x06612581, 0x00000000, 0x82052805, 0x04000510, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x10000000, 0x044A0000, 0x56114000, 0x00000100, 0x02150916, 0x00004440, 
0x05400000, 0x02902100, 0x00004000, 0x00000000, 0x00000000, 0x04050000, 0x00004000, 0x00000000, 
0x00000000, 0x00000000, 0x00010000, 0x00100000, 0x00000000, 0x00040000, 0x00000400, 0x00000000, 
0x00000000, 0x00000000, 0x20010140, 0x80000450, 0x81500000, 0x00101101, 0x00000000, 0x21020140, 
0x40000280, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x56A60000, 0x1A612A02, 0x00004000, 0x41080808, 0x10000420, 0x04050000, 
0x00004046, 0x00000004, 0xA64D9C6B, 0x01148AA1, 0x55570000, 0x5AB13A0A, 0x00000011, 0x86050409, 
0x11100620, 0x6C0B0000, 0x4AE15659, 0x00001104, 0x40040808, 0x05000000, 0x9C850000, 0x16D56980, 
0x00000010, 0x00000404, 0x01000400, 0x581A0000, 0x0AA08605, 0x00001110, 0x40080808, 0x01000400, 
0x04080000, 0x00004008, 0x00001500, 0x41094C2B, 0x15145A90, 0x00460000, 0x52A11900, 0x00004000, 
0x41001404, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 0x40040805, 0x05000800, 0x99EA0000, 
0x97969659, 0x00001110, 0xA64AAD1B, 0x101085A0, 0x44040000, 0x02502944, 0x00004000, 0x40000800, 
0x00000000, 0x08080000, 0x00004004, 0x00001100, 0x00000000, 0x00000000, 0x01050000, 0x00004400, 
0x00000000, 0x4508584A, 0x18004A41, 0x00000000, 0x00000000, 0x00000000, 0x04025080, 0x00000020, 
0x00000000, 0x02110000, 0x00000000, 0x10008050, 0x00000251, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00410000, 0x00011100, 
0x00000000, 0x0218481A, 0x00004640, 0x04040000, 0x01004082, 0x00000000, 0x44040805, 0x00000850, 
0x01510000, 0x01510101, 0x00000000, 0x44042406, 0x10000150, 0x48060000, 0x01505108, 0x00000000, 
0x66040905, 0x00000550, 0x00000000, 0x01501100, 0x00000000, 0x00000400, 0x00000000, 0x00050000, 
0x05604044, 0x00000000, 0x9788AA59, 0x00245A41, 0x08190000, 0x40424808, 0x00000400, 0xA0995A5B, 
0x01241690, 0x00010000, 0x01510540, 0x00000000, 0x40062805, 0x02000112, 0x00000000, 0x00000000, 
0x00000000, 0x6A69EB6A, 0x142497A1, 0x08460000, 0x42915549, 0x00000000, 0x840A1916, 0x00105240, 
0x40400000, 0x10211100, 0x00000000, 0x40040405, 0x00000000, 0x04050000, 0x00005014, 0x00000000, 
0x00000401, 0x00000000, 0x00000000, 0x00004000, 0x00000000, 0x00080400, 0x00000400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x58160000, 0x15400451, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x55890000, 0x46A26140, 0x00008010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x41420000, 0x05602685, 0x00000010, 0x4248090A, 
0x01000640, 0x00000000, 0x00000000, 0x00000000, 0x40080409, 0x01040000, 0x08410000, 0x06905100, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x80040409, 0x06000400, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04410000, 0x41A02201, 0x00000000, 
0x41041805, 0x00000240, 0x00000000, 0x00000000, 0x00000000, 0x80080809, 0x22000800, 0x04010000, 
0x01000004, 0x00000004, 0x44084806, 0x00001480, 0x04100000, 0x02112500, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040440, 0x00000240, 
0x00000000, 0x00100000, 0x00000000, 0x11000000, 0x00000110, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x01000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x08080000, 0x00004004, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xE6A60000, 0x5FA17A8A, 0x00004015, 0x82080C09, 0x110009A0, 0x04040000, 
0x04104046, 0x00000000, 0x65484D1A, 0x05004551, 0xA6EB0000, 0x5AE23A8D, 0x00004015, 0x9104080A, 
0x21000650, 0x1D1A0000, 0x4A605608, 0x00000200, 0x80080808, 0x1A040400, 0xADD90000, 0x2AC17680, 
0x00004011, 0x00000408, 0x00000000, 0x081A0000, 0x4A915605, 0x00002610, 0x800C0809, 0x06000440, 
0x481A0000, 0x09408108, 0x00001900, 0x45494A5B, 0x10105680, 0xA6A60000, 0x56A26A56, 0x00008010, 
0x41001409, 0x00000420, 0x00000000, 0x04000000, 0x00000000, 0x55090809, 0x11040680, 0x19DA0000, 
0x5B029449, 0x00001900, 0x660A4C1B, 0x101459B1, 0xA5950000, 0x02A23886, 0x00004000, 0x80080805, 
0x04000400, 0x08080000, 0x04108008, 0x00001600, 0x00000001, 0x00000000, 0x00010000, 0x00000100, 
0x00000000, 0x554A1856, 0x16004A00, 0x00000000, 0x00000000, 0x00000000, 0x2401A190, 0x00100A80, 
0x65400000, 0x01901501, 0x00008000, 0x240265E0, 0x80000140, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00400000, 0x00000000, 0x00000003, 0x00000000, 0x91A60000, 0x0A602E45, 
0x00004001, 0x41040818, 0x10000810, 0x00040000, 0x00004007, 0x00000000, 0x40040404, 0x00000420, 
0x48570000, 0x1AB5778A, 0x00000004, 0x41040408, 0x22000420, 0x0C040000, 0x00100204, 0x00001100, 
0x40040809, 0x15000000, 0x8ED50000, 0x2681A680, 0x00000000, 0x00000004, 0x05000000, 0x08090000, 
0x08604104, 0x00001400, 0x80040808, 0x06000400, 0x04080000, 0x08004008, 0x00001100, 0x40040408, 
0x00000400, 0x65510000, 0x95212601, 0x00004020, 0x81091808, 0x26000430, 0x00000000, 0x04000000, 
0x00000000, 0x00040809, 0x10000400, 0x5C9A0000, 0x5A51550D, 0x00000104, 0x964D9D5F, 0x2B1459B1, 
0x05900000, 0x01512900, 0x00000010, 0x80000800, 0x00000000, 0x08050000, 0x00004008, 0x00001100, 
0x00000000, 0x00000000, 0x00500000, 0x00501900, 0x00000000, 0x00040804, 0x00004800, 0x00000000, 
0x00000000, 0x00000000, 0x15005080, 0x00000600, 0x00000000, 0x00101001, 0x00000000, 0x10000250, 
0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0xD26A0000, 0x5AA03A89, 0x00000001, 0x01040808, 0x00000410, 0x00000000, 
0x00100001, 0x00000000, 0x00040800, 0x10000400, 0x55970000, 0x1BF13B4E, 0x00000011, 0x40040809, 
0x11000410, 0x08040000, 0x00100200, 0x00000000, 0x8408080A, 0x11040410, 0xDC4A0000, 0x26D1EA80, 
0x00000020, 0x00000004, 0x00000000, 0x04040000, 0x04104100, 0x00000000, 0x800C0808, 0x01000400, 
0x04080000, 0x04004004, 0x00000500, 0x40080804, 0x01000000, 0x65960000, 0x15622945, 0x00004004, 
0x41010404, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 0x800C0C0D, 0x16000800, 0xA9EA0000, 
0x56925A95, 0x00000110, 0x46455C5A, 0x01004890, 0x5A550000, 0x16603905, 0x00000000, 0x40000800, 
0x00000000, 0x08080000, 0x04008008, 0x00000100, 0x00000000, 0x00000000, 0x00010000, 0x00010100, 
0x00000000, 0x42495D16, 0x10105A51, 0x00000000, 0x00000000, 0x00000000, 0x25014110, 0x00000A20, 
0x01400000, 0x01611000, 0x00004000, 0x14010090, 0x00000220, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00400000, 0x00000000, 0x00000002, 0x00000000, 0x01010000, 0x01601600, 
0x00000004, 0x16450805, 0x00001140, 0x00050000, 0x00000083, 0x00000000, 0x41084805, 0x00004050, 
0x01020000, 0x00B02604, 0x00000010, 0x5A4AA816, 0x112046A1, 0x4C060000, 0x06516105, 0x00000110, 
0x15080809, 0x05000160, 0x45010000, 0x01401100, 0x00000000, 0x00000004, 0x00000000, 0x04040000, 
0x06004100, 0x00001100, 0x46485A09, 0x01141650, 0xA91A0000, 0x82924945, 0x00000110, 0x5989EB6A, 
0x012067A0, 0x00010000, 0x01100000, 0x00000000, 0x01001405, 0x00000202, 0x00000000, 0x00000000, 
0x00000000, 0x9948A996, 0x212056A0, 0xAAAA0000, 0x92A15686, 0x00001120, 0x81090C46, 0x01200691, 
0x00000000, 0x00001400, 0x00000000, 0x40040404, 0x00000000, 0x04040000, 0x00000004, 0x00000104, 
0x00000401, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x01040405, 0x10004400, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010, 
0x00000000, 0x58120000, 0x02101104, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x01010000, 0x02102104, 0x00000004, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00560000, 0x11B02500, 0x00000004, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x09440000, 0x11905140, 
0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x40010000, 0x00701604, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00040000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00400100, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000100, 
0x40000000, 0x00400100, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x90990000, 0x01A02646, 
0x00000004, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x81910000, 0x02B0260E, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x4A810000, 0x02B12600, 0x00004010, 0x00000400, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 
0x00000000, 0x51550000, 0x10205602, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00040004, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x40000000, 0x00000000, 
0x00400000, 0x01612000, 0x00008000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00400100, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x11024180, 0x00000060, 0x00400000, 0x00100102, 0x00000000, 0x20000000, 
0x40000160, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000002, 0x00000000, 0x00000000, 0x00001440, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00101500, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04510000, 0x00400440, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000410, 0x00000000, 0x00000000, 0x00000000, 
0x41000404, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x40000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00040401, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00010000, 0x00001000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000041, 0x00000000, 0x00000400, 0x00000100, 
0x00000000, 0x00201000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x01040400, 0x00001000, 0x00150000, 0x00015004, 0x00000000, 0x40000404, 
0x00000000, 0x00000000, 0x01101100, 0x00000000, 0x40040401, 0x00000140, 0x00000000, 0x00000000, 
0x00000000, 0x00040000, 0x00000000, 0x04050000, 0x01400004, 0x00000000, 0x00010000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x40000404, 0x00000000, 0x00040000, 0x00000000, 0x00000100, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000003, 0x00000000, 0x00500000, 0x04601506, 0x00000000, 0x01040404, 0x10000400, 0x00000000, 
0x00000001, 0x00000000, 0x00000404, 0x00000000, 0x00160000, 0x09A2360E, 0x00004000, 0x00040404, 
0x05000010, 0x04000000, 0x00000004, 0x00000000, 0x00000404, 0x00000000, 0x9C480000, 0x12516840, 
0x00000000, 0x00000000, 0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x40080404, 0x00000000, 
0x00040000, 0x04000004, 0x00000100, 0x00000404, 0x00000000, 0x84010000, 0x00505100, 0x00000000, 
0x41000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000400, 0x10000000, 0x00000000, 
0x05000000, 0x00000000, 0x01040802, 0x00000000, 0xA5650000, 0x91A12A82, 0x00001010, 0x40000000, 
0x00000000, 0x08090000, 0x04000008, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 
0x00000000, 0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x00000000, 0x00020000, 0x00000010, 
0x80000000, 0x00800100, 0x00000000, 0x10008050, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x10000400, 0x00000100, 0x00000000, 
0x00000082, 0x00000000, 0x00040440, 0x00000100, 0x00000000, 0x00100000, 0x00000000, 0x00040401, 
0x00000250, 0x48010000, 0x06401204, 0x00000004, 0x22080801, 0x00000160, 0x00000000, 0x00400000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02041500, 0x00000200, 
0x04000000, 0x02420504, 0x00000000, 0x60848701, 0x00200100, 0x00000000, 0x00000000, 0x00000000, 
0x00001000, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x08859816, 0x04200640, 0x08400000, 
0x01800008, 0x00000000, 0x00090802, 0x00200640, 0x25500000, 0x02800900, 0x00008000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00040000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x01000108, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x10040410, 0x00000000, 0x00000000, 0x00000042, 0x00000000, 0x01040400, 0x00000000, 
0x00000000, 0x00100000, 0x00000000, 0x01002400, 0x00000100, 0x08000000, 0x00000200, 0x00000000, 
0x25000800, 0x00000510, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00004000, 0x00000000, 0x11401041, 0x00104040, 0x04000000, 0x00000404, 0x00000000, 0x12050441, 
0x00000040, 0x00000000, 0x00000000, 0x00000000, 0x00002000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x14045A11, 0x00000651, 0x08410000, 0x06801008, 0x00000000, 0x00080440, 0x00100500, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x08000000, 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x11040C00, 0x00000550, 0x00000000, 
0x000000C2, 0x00000000, 0x01541904, 0x00105000, 0x40000000, 0x00000000, 0x00000000, 0x00000400, 
0x00000540, 0x08100000, 0x06400104, 0x00000000, 0x16100811, 0x001005A0, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02010404, 0x00000240, 
0x04000000, 0x00010404, 0x00000000, 0x1040A641, 0x00100180, 0x00000000, 0x00000000, 0x00000000, 
0x00001000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x9544A691, 0x00204280, 0x04400000, 
0x02801004, 0x00000000, 0x01054400, 0x00200600, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04410000, 0x06000104, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x04101040, 
0x00000000, 0x40000404, 0x04000410, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 
0x00020000, 0x01602504, 0x00000000, 0x40000004, 0x00000000, 0x04000000, 0x00000000, 0x00000100, 
0x00000404, 0x01000000, 0x80000000, 0x00400000, 0x00000000, 0x00000000, 0x01000000, 0x00040000, 
0x04000000, 0x00000000, 0x00080404, 0x00000000, 0x00040000, 0x04000000, 0x00001100, 0x00000404, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000400, 0x00000000, 0x00000000, 0x01000000, 0x00000000, 0x00000802, 0x00000050, 
0x00000000, 0x00001000, 0x00000000, 0x00000404, 0x01000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00040000, 0x10000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
 }; 

// ****   TRD header   ******************************************************

ROM_DATA tr_descr_type img_trd_header =  
 { 
    {"germ0705.trd"},    
    {'T','r','#',0x33},    
    {'G','r','m',0x00},    
    {'1','.','0',0x00},    
    0,                          // h_trd  
    0,                          // p_trd  
    0,                         // cheksum   
 }; 

// **************************************************************************
// *    END OF ALL                                                          *
// **************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\ws.cpp ===
/* ************************************************************************* */
/*        Word segmentation routines                                         */
/* ************************************************************************* */
/* *     Created 3/17/94 by AVP. Update: 10/25/94   Version 2.80           * */
/* *     Created 3/17/94 by AVP. Update: 05/02/95   Version 2.90  (lrn)    * */
/* ************************************************************************* */

#include "hwr_sys.h"
#include "ams_mg.h"                           /* Most global definitions     */

#include "pws.h"
#include "ws_p.h"
#include "ws.h"
#include "peg_util.h"

#ifdef TRAINTIME_BEAR
#include <stdio.h>
#endif

#if PG_DEBUG || PG_DEBUG_MAC
  #include <stdio.h>
#endif /* PG_DEBUG_MAC */

#if PG_DEBUG
  #include "pg_debug.h"
  #include "xr_exp.h"
#endif /* PG_DEBUG */

/* ------------------ Switches ---------------------------------- */

#define  WS_USE_NNET     ON                // Switch for NN usage
#define  WS_USE_DIST_F   OFF               // Switch for NN usage
#define  WS_USE_DECN_F   OFF               // Switch for NN usage
#define  WS_NNET_NSEGLEV (-100)            // For sure initialization

/* ------------------ Internal defines -------------------------- */

#define HIST_ADD(v, loc) (*(loc) = (_UCHAR)((*(loc) + v < V_LIMIT) ? (*(loc) + v) : V_LIMIT))
#define HIST_SUB(v, loc) (*(loc) = (_UCHAR)((*(loc) > v) ? (*(loc) - v) : 1))
#define HIST_POS(x)      ((x)/HIST_REDUCT)
#define HIST_ADJPOS(x)   (((x)/HIST_REDUCT)*HIST_REDUCT)

#define WSAbs(v)         (((v) >= 0) ? (v) : (-(v)))

#define HORZ_GET(x)      (pwsd->horz[(x)/HORZ_REDUCT])
#define HORZ_PUT(x, v)   (pwsd->horz[(x)/HORZ_REDUCT] = (_SHORT)(v))

#define GET_AVE(g, l)    (((g) > 0) ? ((g) + (l))/2 : (l))

#define CUT_VAL (CUT_LINE_POS*HIST_REDUCT)
#define PIK_VAL ((PIK_UP+PIK_DN)*HIST_REDUCT)


  WS_1

	  #ifdef TRAINTIME_BEAR

int	GetStrokesBeforeGap (p_ws_data_type pws_data, int iGap, int *piStroke)
{
	_INT			l, 
					cStrk,
					line_end_stroke,
					start, 
					end,
					iGapPos;

	p_ws_data_type	pwsd = pws_data;

	// line strokes
	line_end_stroke = pwsd->line_cur_stroke;
	// compute the gap position
	if (iGap == 0)
	{
		iGapPos	=	pwsd->line_start;
	}
	else
	if (iGap == (pwsd->line_ngaps - 1))
	{
		iGapPos	=	pwsd->line_end;
	}
	else
	{
		iGapPos	= (*pwsd->gaps)[iGap].loc + (*pwsd->gaps)[iGap].size/4;
	}
		
	// go thru the strokes
	for (l = 0, cStrk = 0; l < line_end_stroke; l ++)
	{
		start = pwsd->xstrokes[l].st;
		end   = pwsd->xstrokes[l].end;
		
		// is there an intersection
		if (start <= iGapPos && end >= iGapPos)
		{
			if ((iGapPos - start) > (end - iGapPos))
			{
				piStroke[cStrk++]	=	l;
			}
		}

		// is this stroke included
		if (end <= iGapPos)
		{
			piStroke[cStrk++]	=	l;
		}
	}

	return cStrk;
}

extern "C" 
{
int IsCorrectBreak (int iLine, int cStrk, int *piStroke, int *piPrint);
}

void SaveGapFeatures (p_ws_data_type pws_data, int iGap, int *pParams, int iOut)
{
	int				bCorrectBreak;

	int				aiStroke[MAX_STROKES],
					cStrk,
					i,
					iPrint;
	
	static	FILE	*fp		=	NULL;
	int				aScale[11]	=	{10, 15, 2, 50, 5, 15, 8, 15, 1, 1, 1};

	if (!fp)
	{
		fp		=	fopen ("gaps.txt", "wt");
		if (!fp)
		{
			return;
		}
	}

	cStrk	=	GetStrokesBeforeGap (pws_data, iGap, aiStroke);

	// the gap actually falls in the body of a stroke,
	// so it will be considered a non break, but we want to highlight in the output file
	bCorrectBreak	=	IsCorrectBreak (pws_data->global_cur_line - 1, cStrk, aiStroke, &iPrint);
	
	fprintf (fp, "%d\t{", iOut);
	
	// add iprint as a feature
	fprintf (fp, "%d ", iPrint * 65535 / 1000);

	for (i = 0; i < 11; i++)
	{
		fprintf (fp, "%d%c", 
			(128 * aScale[i] * pParams[i]), 
			i == 10 ? '}' : ' ');
	}

	fprintf (fp, "\t{%d}\n", bCorrectBreak ? 1 : 0);
	fflush (fp);
}

int IsRealGap (p_ws_data_type pws_data, int iGap)
{
	int				bCorrectBreak;

	int				aiStroke[MAX_STROKES],
					cStrk,
					iPrint;
	
	cStrk	=	GetStrokesBeforeGap (pws_data, iGap, aiStroke);

	// the gap actually falls in the body of a stroke,
	bCorrectBreak	=	IsCorrectBreak (pws_data->global_cur_line - 1, cStrk, aiStroke, &iPrint);

	if (bCorrectBreak)
	{
		return 100;
	}
	else
	{
		return -100;
	}
}
#endif

#if WS_USE_NNET


extern "C" int RunSpcNet (int *pFeat);

int	GetGapPos (p_ws_data_type pws_data, int iGap)
{
	_INT			line_end_stroke,
					iGapPos;

	p_ws_data_type	pwsd = pws_data;

	// line strokes
	line_end_stroke = pwsd->line_cur_stroke;
	// compute the gap position
	if (iGap == 0)
	{
		iGapPos	=	pwsd->line_start;
	}
	else
	if (iGap == (pwsd->line_ngaps - 1))
	{
		iGapPos	=	pwsd->line_end;
	}
	else
	{
		iGapPos	= (*pwsd->gaps)[iGap].loc + (*pwsd->gaps)[iGap].size/4;
	}
		
	return iGapPos;
}

_INT WS_SegmentWords(p_rec_inst_type pri, _INT finished_x, p_ws_data_type pws_data)
{
	_INT i, iSpcOut = 0;
	_INT num_words, start, nn;
	_INT na = 0;  // AVP
	int params[16];
	register p_ws_data_type pwsd = pws_data;

	if (pwsd->line_finished == 0)
	{
		return 0;
	}

	num_words = 0;
	start     = 0;

	pri->cGap	=	pwsd->line_ngaps - 1;

	if (pri->cGap > WS_MAX_WORDS)
	{
		pri->cGap = WS_MAX_WORDS;
	}

	for (i = 1; i < pwsd->line_ngaps; i++)
	{
		if ((*pwsd->gaps)[i].lst <= finished_x)
			continue; 

		nn		=	1;
		iSpcOut	=	0;
		
		if (i <= pri->cGap)
		{
			pri->axGapPos[i - 1]	=	GetGapPos (pws_data, i);
		}

		if (i == pwsd->line_ngaps-1)
		{
			nn = 0; // Cut on last gap
			
			if (i <= pri->cGap)
			{
				pri->aGapSpcNetOut[i - 1]	=	0;
			}
		}
		else
		{
			params[0] = pwsd->nn_ssp;
			params[1] = pwsd->nn_n_ssp;
			params[2] = pwsd->nn_bsp;
			params[3] = pwsd->nn_n_bsp;
			params[4] = pwsd->nn_sl;
			params[5] = pwsd->nn_inw_dist;
			params[6] = pwsd->nn_npiks;
			
			if (params[3] == 0)
			{
				if (params[5] > 80)
					params[5] = 80;
			}

			params[7]  = i;
			params[8]  = 100 * (*pwsd->gaps)[i].psize / (pwsd->ws_inline_dist);
//          params[8] = (float)100.0*(*pwsd->gaps)[i].size / (pwsd->ws_inline_dist);
			params[9]  = 100 * (*pwsd->gaps)[i].blank / (pwsd->ws_inline_dist);
			params[10] = 100 * (*pwsd->gaps)[i].low / (pwsd->ws_inline_dist);

			if (pwsd->in_word_dist)
			{
				params[8]  = params[8]  + ((6-pwsd->in_word_dist)*(params[8]))/4;
				params[9]  = params[9]  + ((6-pwsd->in_word_dist)*(params[9]))/4;
				params[10] = params[10] + ((6-pwsd->in_word_dist)*(params[10]))/4;
			}

			iSpcOut						=	RunSpcNet (params);
			na							=	(200 * iSpcOut / 65535) - 100;

			if (i <= pri->cGap)
			{
				pri->aGapSpcNetOut[i - 1]	=	iSpcOut;
			}

#ifdef TRAINTIME_BEAR
			//na	= NeuroNetWS(params);

			// save the gap features
			//SaveGapFeatures (pws_data, i, params, na);

			//na	=	IsRealGap (pws_data, i);
#endif			
		}

		if (na > 0 && WSAbs(na) > pwsd->sure_level)
			nn = 0;
		
		if (nn == 0) // Delim zdes!
		{
			pwsd->xwords[num_words].st_gap = (_UCHAR)(start);
			pwsd->xwords[num_words].en_gap = (_UCHAR)(i);
			start = i;
			num_words++;
		}
		else
		{
			(*pwsd->gaps)[i].k_sure = (_SCHAR)na;
		}
	}

	return num_words;
}

#endif

  /* ************************************************************************* */
/*      Make line segmentation                                               */
/* ************************************************************************* */
_INT  WordLineStrokes(p_rec_inst_type pri, p_ws_data_type pws_data, p_ws_results_type pwsr)
{
	_INT     i, j, k, l, m, n;
	_INT     br, s;
	_INT     dist;
	_INT     num_words, wn;
	_INT     sep_let_level;
	_INT     inword_dist; //, inline_dist;
	_INT     line_end_stroke;
	_INT     start, end, st, en, ws, we, fws, fwe;
	_INT     finished_nw, finished_x, finished_ns;
	_UCHAR   finished_strokes[MAX_STROKES];
	_INT     word_dist;
	_INT     slope;
	register p_ws_data_type pwsd = pws_data;
	p_word_strokes_array_type w_str = pwsr->pwsa;
	_UCHAR	   (*sp)[MAX_WORDS][MAX_STROKES][2] = _NULL;

	// ---- Set local variables -----------------------------------

	line_end_stroke = pwsd->line_cur_stroke;
	if (pwsd->line_finished == WS_NEWLINE) line_end_stroke --;

	sep_let_level = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);
	inword_dist   = GET_AVE(pwsd->global_inword_dist, pwsd->line_inword_dist);
	//  inline_dist   = GET_AVE(pwsd->global_inline_dist, pwsd->line_inline_dist);

	// ---- Get current word dist -------------------------------------

	WS_GetWordDist(pwsd);

	word_dist = pwsd->line_word_dist;

	// ---- Get current 'finished' info -------------------------------

	finished_x  = pwsd->line_start;
	finished_ns = 0;
	finished_nw = pwsd->line_st_word;
	for (i = pwsd->line_st_word; i < pwsd->global_num_words; i ++)
	{
		if ((*w_str)[i].flags & WS_FL_PROCESSED)
		{
			finished_nw = i+1;
			finished_x  = (*w_str)[i].word_x_end;
			k = (*w_str)[i].first_stroke_index;

			for (j = 0; j < (*w_str)[i].num_strokes; j ++)
			{
				finished_strokes[finished_ns++] = pwsr->stroke_index[k+j];
			}
		}
	}

	// ---------------------- Make word segmentation -----------------------

	num_words = WS_SegmentWords(pri, finished_x, pwsd);

	// --------------- Assign strokes to words ---------------------

	sp = (_UCHAR (*)[MAX_WORDS][MAX_STROKES][2])HWRMemoryAlloc((sizeof((*sp)[0]))*num_words);
	if (sp == _NULL) goto err;

	wn = finished_nw;
	for (j = 0; j < num_words; j ++, wn ++)
	{
		st = pwsd->xwords[j].st_gap;
		ws = (*pwsd->gaps)[st].loc + (*pwsd->gaps)[st].size/4;
		en = pwsd->xwords[j].en_gap;
		we = (*pwsd->gaps)[en].loc + (*pwsd->gaps)[en].size/4;

		fws   = (j == 0) ? pwsd->line_start : ws;
		fwe   = (j == num_words-1) ? pwsd->line_end : we;

		for (l = 0, m = 0; l <= line_end_stroke; l ++)
		{
			if (l+pwsd->line_st_stroke == pwsd->global_cur_stroke &&
				(pwsd->stroke_flags & WS_FL_FAKE)) break; // Do not include fake stroke in words

			for (i = 0, k = 0; i < finished_ns; i ++)    // Check current stroke for not belonging to a finished  word
				if (l+pwsd->line_st_stroke == finished_strokes[i]) {k = 1; break;}
				if (k) continue;

				start = pwsd->xstrokes[l].st;
				end   = pwsd->xstrokes[l].end;

				if ((start >= fws && start <= fwe) ||
					(end   >= fws && end   <= fwe) ||
					(start <= fws && end   >= fwe))
				{
					p_ws_gaps_type gap = &(*pwsd->gaps)[st+1];

					(*sp)[j][m][0] = (_UCHAR)(pwsd->line_st_stroke + l);

					k = (pwsd->xstrokes[l].a_end+pwsd->xstrokes[l].end+1)/2;
					n = 0;
					for (i = st+1; i < en; i ++, gap ++) // Search corresponding GAP
					{
						if (k >= gap->lst && k < gap->lst+gap->low)
						{
							n = gap->size;
							break;
						}
					}

					if (n) (*sp)[j][m][1] = (_UCHAR) (gap->k_sure + 100);

					else (*sp)[j][m][1] = 0;  // Ne delit!

					//        k = (_INT)(100*(_LONG)(n)/(_LONG)(word_dist));
					//        if (k > 100) k = 100;
					//        (*sp)[j][m][1] = (_UCHAR)(100-k);

					m ++;
				}
		}

		if (j < num_words-1)
		{
			k = (_INT)(100*(_LONG)((*pwsd->gaps)[en].size/(2*(_LONG)word_dist)));
			if (k > 100) k = 100;
		}
		else k = 100;

		n = HWRMax(fws, finished_x);
		slope = pwsd->global_slope;
		if (slope < -127) slope = -127;
		if (slope >  127) slope = 127;

		(*w_str)[wn].word_num       = (_UCHAR)((finished_nw - pwsd->line_st_word) + j + 1);
		(*w_str)[wn].line_num       = (_UCHAR)(pwsd->global_cur_line);
		(*w_str)[wn].seg_sure       = (_UCHAR)(k);
		(*w_str)[wn].sep_let_level  = (_UCHAR)(sep_let_level);
		(*w_str)[wn].slope          = (_SCHAR)(slope);
		(*w_str)[wn].word_mid_line  = (_SHORT)(HORZ_GET((n + fwe)/2));
		(*w_str)[wn].word_x_st      = (_SHORT)((*pwsd->gaps)[st].loc + (*pwsd->gaps)[st].size/2);
		(*w_str)[wn].word_x_end     = (_SHORT)((*pwsd->gaps)[en].loc - (*pwsd->gaps)[en].size/2);
		(*w_str)[wn].writing_step   = (_SHORT)(inword_dist);
		(*w_str)[wn].ave_h_bord     = (_SHORT)(pwsd->line_h_bord);
		(*w_str)[wn].num_strokes    = (_UCHAR)(m);
		(*w_str)[wn].flags          = 0;
		if (pwsd->line_finished) (*w_str)[wn].flags |= WS_FL_FINISHED;
		if (wn == pwsd->line_st_word && (pwsd->line_flags & LN_FL_NL_GESTURE)) (*w_str)[wn].flags |= WS_FL_NL_GESTURE;
		if (pwsd->global_num_extr+pwsd->line_extr > WS_SPNUMEXTRENOUGH) (*w_str)[wn].flags |= WS_FL_SPSURE;
	}

	// ---------------- detect overlapping strokes ---------------------

	for (s = 1; s <= pwsd->line_cur_stroke && s < MAX_STROKES; s ++)
	{
		br = 0;

		for (i = 0, wn = finished_nw; i < num_words-1 && br == 0; i ++, wn ++)
		{
			st  = pwsd->xwords[i].st_gap;
			fws = (*pwsd->gaps)[st].loc + (*pwsd->gaps)[st].size/4;
			en  = pwsd->xwords[i].en_gap;
			fwe = (*pwsd->gaps)[en].loc + (*pwsd->gaps)[en].size/4;

			for (j = 0; j < (*w_str)[wn].num_strokes && br == 0; j ++)
			{
				for (k = 0; k < (*w_str)[wn+1].num_strokes && br == 0; k ++)
				{
					if ((*sp)[i][j][0] == (*sp)[i+1][k][0])
					{
						l     = (*sp)[i][j][0] - pwsd->line_st_stroke;
						start = pwsd->xstrokes[l].st;
						end   = pwsd->xstrokes[l].end;

						m     = WSAbs(fws - start);
						m    += WSAbs(fwe - end);

						m     = (HWRMax(fwe, end) - HWRMin(fws, start)) - m;

						st  = pwsd->xwords[i+1].st_gap;
						ws = (*pwsd->gaps)[st].loc + (*pwsd->gaps)[st].size/4;
						en  = pwsd->xwords[i+1].en_gap;
						we = (*pwsd->gaps)[en].loc + (*pwsd->gaps)[en].size/4;

						n  = WSAbs(ws - start);
						n += WSAbs(we - end);

						n = (HWRMax(we, end) - HWRMin(ws, start)) - n;

						if (m >= n) // Belongs to first more
						{
							HWRMemCpy(&(*sp)[i+1][k][0], &(*sp)[i+1][k+1][0], (MAX_STROKES - (k+1))*sizeof((*sp)[0][0]));
							(*w_str)[wn+1].num_strokes --;
						}
						else // Belongs to second more
						{
							HWRMemCpy(&(*sp)[i][j][0], &(*sp)[i][j+1][0], (MAX_STROKES - (j+1))*sizeof((*sp)[0][0]));
							(*w_str)[wn].num_strokes --;
							br = 1;
						}
					}
				}
			}
		}
	}

	// ---------------- Write output strokes lineout -------------------

	wn = finished_nw;
	n  = pwsd->line_st_stroke + finished_ns;
	for (j = 0; j < num_words; j ++, wn ++)
	{
		for (k = 0; k < (*w_str)[wn].num_strokes; k ++)
		{
			// have we exceeded the limit of the number of strokes we can handle
			if ((n + k) >= WS_MAX_STROKES)
			{
				goto err;
			}

			pwsr->stroke_index[n+k] = (_UCHAR)(*sp)[j][k][0];
			pwsr->k_surs[n+k]       = ((*sp)[j][k][1] - 100);
		}

		(*w_str)[wn].first_stroke_index = (_UCHAR)(n);
		n += (*w_str)[wn].num_strokes;
	}

	// ---------------- If on-line mode -- clear illegal words ---------

	wn = finished_nw;
	for (j = 0; pwsd->in_x_delay > 0 && j < num_words; j ++, wn ++)
	{
		en = pwsd->xwords[j].en_gap;
		we = (*pwsd->gaps)[en].loc;
		if (we > pwsd->line_end - pwsd->in_x_delay)
		{
			(*w_str)[wn].flags |= WS_FL_TENTATIVE;
			//      HWRMemSet(&(*w_str)[wn+j], 0, sizeof((*w_str)[0]));
			//      num_words = j;
			//      break;
		}
	}

	// ---------------- Check & clear 0 stroke words -------------------

	wn = finished_nw;
	for (j = 0; j < num_words; j ++)
	{
		if ((*w_str)[wn+j].num_strokes == 0)
		{
			HWRMemCpy(&(*w_str)[wn+j], &(*w_str)[wn+j+1], sizeof((*w_str)[0]));
			num_words --;
		}
	}

	// ---------------- At end of line check for carriage dash ---------

	if (pwsd->line_finished == WS_NEWLINE && num_words > 0 && pwsd->prev_stroke_dx > pwsd->prev_stroke_dy*2)
	{
		st = HIST_POS(pwsd->line_start);
		en = HIST_POS(pwsd->line_end);
		for (en = en-1; pwsd->hist[en] == 0 && en > st; en --);
		for (i = en, j = 0; i > st && j <= 1; i --)
		{
			if ((k = (pwsd->hist[i] & HIST_FIELD)) == 0) break;
			if (k > 1) {if (k == 1+CUT_VAL/HIST_REDUCT) j ++; else {j = 2; break;}}
		}

		if (j == 1 && (*w_str)[finished_nw+num_words-1].word_x_st < (i*HIST_REDUCT-inword_dist))
		{
			dist = (en-i)*HIST_REDUCT;
			if (dist > pwsd->line_h_bord/2 && dist < pwsd->line_h_bord*2)
				(*w_str)[finished_nw+num_words-1].flags |= WS_FL_CARRYDASH;
		}
	}

	// ---------------- Write found word info --------------------------

	pwsd->global_num_words    = finished_nw + num_words;

	pwsr->num_words           = (_UCHAR)(pwsd->global_num_words);  /* Num of created words */
	pwsr->num_finished_words  = (_UCHAR)(finished_nw); /* Num of finished words */
	pwsr->num_finished_strokes= (_UCHAR)(pwsd->line_st_stroke+finished_ns); /* Num of eternally finished strokes */

	// ---------------- Debug printing of the results ------------------

	WS_3

	WS_4

	WS_5

	if (sp != _NULL) 
	{
		HWRMemoryFree(sp);
	}

	return 0;
err:
	if (sp != _NULL) 
	{
		HWRMemoryFree(sp);
	}

	return 1;
}



/* ************************************************************************* */
/*      Program, called from outer space                                     */
/* ************************************************************************* */
_INT  WordStrokes(p_rec_inst_type pri, PS_point_type _PTR stroke, p_ws_control_type pwsc, p_ws_results_type pwsr)
 {
  p_ws_data_type          pwsd;
  p_ws_memory_header_type pwmh = _NULL;

  // by default no new line is created
  pri->new_line_created	=	0;

  WS_2

  if (pwsc->flags & WS_FL_CLOSE) {ReleaseWSData(pwsc, &pwmh); goto exit;}

  // ------- Startup -----------------------------------------------------

  if (InitWSData(pwsc, &pwmh)) goto err;

  pwsd                    = pwmh->pwsd;
  pwsd->stroke            = stroke;
  pwsd->stroke_num_points = pwsc->num_points;

  // ------- If timeout -- no more data, null stroke -- final wordcut ----

  if (pwsd->global_cur_stroke > 0 && pwsd->stroke_num_points == 0 && (pwsd->stroke_flags & WS_FL_LAST))
   {
    pwsd->stroke_flags |= WS_FL_FAKE;
    goto done;
   }

  // ------- Check situation ---------------------------------------------

  if (pwsd->global_cur_stroke >= MAX_STROKES-1) goto err;
  if (pwsd->stroke_num_points == 0) goto err;
  if (pwsr->pwsa == _NULL) goto err;

  // ------- Count max height of the stroke and filetering length --------

  if (WS_GetStrokeBoxAndSlope(pwsd)) goto err;

  // ----------------- Guess h line size ---------------------------------

  WS_CalcLineHeight(pwsd);

  // ============= Consider start of a new line! ========================

  if (pwsd->line_cur_stroke > 0 && WS_NewLine(pwsd))
   {
    pwsd->in_x_delay    = 0;
    pwsd->line_finished = WS_NEWLINE;

    if (WordLineStrokes(pri, pwsd, pwsr)) goto err;

	// flag for creation of new line
	pri->new_line_created	=	1;

    InitForNewLine(pwsd);
   }

  // ------------ Hist the stroke ---------------------------------------

  if (WS_HistTheStroke(pwsd)) goto err;

  // ------------------ Add stroke info to Gen Hist ---------------------

  WS_AddStrokeToHist(pwsd);

  // --------- Write down HORZ values -----------------------------------

  WS_WriteStrokeHorzValues(pwsd);

  // --------------- Get info on inline spaces --------------------------

  if (WS_CalcGaps(pwsd)) goto err;

  // ---- Recount postprocessed gap sizes ---------------------------

  WS_PostprocessGaps(pwsd);

  // --------------- Get number of line piks ----------------------------

  WS_CountPiks(pwsd);

  // ------------------ Line analysis -----------------------------------

  WS_SetLineVars(pwsd);

  // ------------------ Final word seg, if needed -----------------------

done:

  if (pwsc->flags & WS_FL_LAST)       // It was last stroke
   {
    pwsd->in_x_delay    = 0;
    pwsd->line_finished = WS_ALLSENT;
    if (WordLineStrokes(pri, pwsd, pwsr)) goto err;

    WS_FlyLearn(pwsc, pwmh, pwsd);

    ReleaseWSData(pwsc, &pwmh);

    WS_10
   }
   else
   {
    if (pwsc->x_delay > 0)     // On line reading requested
     {
//For immidiate recognition  if (pwsd->line_cur_stroke > 0 && pwsd->line_last_ws_try < pwsd->line_end - pwsd->line_inline_dist*4)
       {
        pwsd->in_x_delay = pwsc->x_delay * pwsd->line_inword_dist * 2;

        if (WordLineStrokes(pri, pwsd, pwsr)) goto err;

        pwsd->line_last_ws_try = pwsd->line_end;
       }
     }

    if ((pwsd->stroke_flags & WS_FL_FAKE) == 0)
     {
      pwsd->global_cur_stroke ++;
      pwsd->line_cur_stroke   ++;
     }

    UnlockWSData(pwsc, &pwmh);
   }

exit:
  return 0;
err:
  ReleaseWSData(pwsc, &pwmh);
  return 1;
 }

/* ************************************************************************* */
/*      Allocate and/or initialize ws data structure                         */
/* ************************************************************************* */
_INT  InitWSData(p_ws_control_type pwsc, p_ws_memory_header_type _PTR ppwmh)
 {
  register p_ws_data_type pwsd;
  p_ws_memory_header_type pwmh;
  p_ws_lrn_type           lrn;

  if (pwsc == _NULL) goto err;
  if (pwsc->num_points <= 0 && (pwsc->flags & WS_FL_LAST) == 0) goto err;
  if (pwsc->flags & WS_FL_CLOSE) goto err;

  if (pwsc->hdata == _NULL)
   {
    pwsc->hdata = HWRMemoryAllocHandle(sizeof(ws_memory_header_type));
    if (pwsc->hdata == _NULL) goto err;
    pwmh = (p_ws_memory_header_type)HWRMemoryLockHandle(pwsc->hdata);
    if (pwmh == _NULL) goto err;
    HWRMemSet(pwmh, 0, sizeof(ws_memory_header_type));
   }
   else
   {
    pwmh = (p_ws_memory_header_type)HWRMemoryLockHandle(pwsc->hdata);
    if (pwmh == _NULL) goto err;
   }

  if (pwmh->hwsd == _NULL)
   {
    pwmh->hwsd = HWRMemoryAllocHandle(sizeof(*pwsd));
    if (pwmh->hwsd == _NULL) goto err;
    pwsd = (p_ws_data_type)HWRMemoryLockHandle(pwmh->hwsd);
    if (pwsd == _NULL) goto err;
    HWRMemSet(pwsd, 0, sizeof(*pwsd));

    pwsd->in_x_delay             = 0;
    pwsd->sure_level             = pwsc->sure_level;
    pwsd->in_word_dist           = pwsc->word_dist_in;
    if (pwsd->in_word_dist < 0)  pwsd->in_word_dist = 0;
    if (pwsd->in_word_dist > 10) pwsd->in_word_dist = 10;
    pwsd->in_line_dist           = pwsc->line_dist_in;
    if (pwsd->in_line_dist < 0)  pwsd->in_line_dist = 0;

    lrn = (pwsc->word_dist_in == 0 && pwmh->lrn.h_bord_history > 0) ? &(pwmh->lrn) : _NULL;

    pwsd->def_h_bord             = (lrn) ? lrn->h_bord_history : pwsc->def_h_line;

    pwsd->line_h_bord            = pwsd->def_h_bord;
    pwsd->line_word_dist         = pwsd->def_h_bord;
    pwsd->line_inword_dist       = (lrn) ? lrn->inword_dist_history : pwsd->def_h_bord;
    pwsd->line_inline_dist       = (lrn) ? lrn->inline_dist_history : pwsd->def_h_bord;
    pwsd->line_sep_let_level     = (lrn) ? lrn->sep_let_history     : DEF_SEP_LET_LEVEL;

    pwsd->global_line_ave_y_size = pwsd->def_h_bord;
    pwsd->global_dy_sum          = pwsd->def_h_bord;
    pwsd->global_num_dy_strokes  = 1;

    if (lrn)
     {
      pwsd->global_h_bord        = lrn->h_bord_history;
      pwsd->global_inword_dist   = lrn->inword_dist_history;
      pwsd->global_inline_dist   = lrn->inline_dist_history;
      pwsd->global_sep_let_level = lrn->sep_let_history;
      pwsd->global_slope         = lrn->slope_history;
      pwsd->global_slope_dy      = lrn->h_bord_history*10;
      pwsd->global_slope_dx      = (pwsd->global_slope*pwsd->global_slope_dy)/100;
     }

    pwsd->cmp                    = pwsc->cmp;
    InitForNewLine(pwsd);
   }
   else
   {
    pwsd = (p_ws_data_type)HWRMemoryLockHandle(pwmh->hwsd);
    if (pwsd == _NULL) goto err;
    if (pwsd->gaps_handle) pwsd->gaps = (ws_gaps_a_type)HWRMemoryLockHandle(pwsd->gaps_handle);
    pwsd->in_flags     = pwsc->flags;
    pwsd->stroke_flags = (pwsc->flags & (WS_FL_LAST | WS_FL_FAKE));
   }

  pwmh->pwsd = pwsd;
  *ppwmh     = pwmh;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*      Free or clear ws data structure                                      */
/* ************************************************************************* */
_INT  ReleaseWSData(p_ws_control_type pwsc, p_ws_memory_header_type _PTR ppwmh)
{
	p_ws_data_type          pwsd = _NULL;
	p_ws_memory_header_type pwmh = _NULL;
	
	if (!pwsc || !ppwmh)
		return 1;

	if (*ppwmh) 
		pwmh = *ppwmh;
	else 
	if (pwsc->hdata) 
		pwmh = (p_ws_memory_header_type) HWRMemoryLockHandle(pwsc->hdata);
	
	if (pwmh) 
		pwsd = pwmh->pwsd;
	
	if (pwmh && !pwsd) 
	{
		if (pwmh->hwsd) 
			pwsd = (p_ws_data_type) HWRMemoryLockHandle(pwmh->hwsd);
	}
	
	if (pwsd)
	{
		if (pwsd->s_hist) 
		{
			HWRMemoryFree(pwsd->s_hist); 
			pwsd->s_hist = _NULL;
		}

		if (pwsd->gaps)   
		{
			HWRMemoryUnlockHandle(pwsd->gaps_handle); 
			pwsd->gaps = _NULL;
		}

		if (pwsd->gaps_handle) 
			HWRMemoryFreeHandle(pwsd->gaps_handle);
		
		HWRMemoryUnlockHandle(pwmh->hwsd); 
		pwmh->pwsd = _NULL;

		HWRMemoryFreeHandle(pwmh->hwsd);   
		pwmh->hwsd = _NULL;
	}
	
	if ((pwsc->flags & WS_FL_CLOSE) && pwsc->hdata)
	{
		if (pwmh) 
			HWRMemoryUnlockHandle(pwsc->hdata); 

		*ppwmh = _NULL;

		HWRMemoryFreeHandle(pwsc->hdata); 
		pwsc->hdata = _NULL;
	}
	
	if (ppwmh) 
	{
		if (*ppwmh && pwsc->hdata) 
		{
			HWRMemoryUnlockHandle(pwsc->hdata); 
			*ppwmh = _NULL;
		}
	}
	
	return 0;
}

/* ************************************************************************* */
/*      Unlock wsdata structure                                              */
/* ************************************************************************* */
_INT  UnlockWSData(p_ws_control_type pwsc, p_ws_memory_header_type _PTR ppwmh)
 {
  p_ws_data_type          pwsd = _NULL;
  p_ws_memory_header_type pwmh = _NULL;

  if (ppwmh) pwmh = *ppwmh;
   else if (pwsc->hdata) pwmh = (p_ws_memory_header_type)HWRMemoryLockHandle(pwsc->hdata);

  if (pwmh) pwsd = pwmh->pwsd;

  if (pwmh && !pwsd) if (pwmh->hwsd) pwsd = (p_ws_data_type)HWRMemoryLockHandle(pwmh->hwsd);

  if (pwsd)
   {
    if (pwsd->s_hist) {HWRMemoryFree(pwsd->s_hist); pwsd->s_hist = _NULL;}
    if (pwsd->gaps)   {HWRMemoryUnlockHandle(pwsd->gaps_handle); pwsd->gaps = _NULL;}

    HWRMemoryUnlockHandle(pwmh->hwsd);
    pwmh->pwsd = _NULL;
   }

  if (ppwmh) if (*ppwmh && pwsc->hdata) {HWRMemoryUnlockHandle(pwsc->hdata); *ppwmh = _NULL;}

  return 0;
 }

/* ************************************************************************* */
/*      Initialize variables for starting of new line                        */
/* ************************************************************************* */
_INT  InitForNewLine(p_ws_data_type pws_data)
 {
  register p_ws_data_type pwsd = pws_data;

  // ----------- Recalculate global data ------------------

  if (pwsd->global_cur_line > 0)
   {
    pwsd->global_num_extr       += pwsd->line_extr;
    pwsd->global_word_len       += pwsd->line_word_len;

    pwsd->global_slope_dx       /= 2;    // Reduce influence of prev text
    pwsd->global_slope_dy       /= 2;

    pwsd->global_inword_dist     = GET_AVE(pwsd->global_inword_dist, pwsd->line_inword_dist);

    pwsd->global_word_dist       = GET_AVE(pwsd->global_word_dist, pwsd->line_word_dist);
    pwsd->global_inline_dist     = GET_AVE(pwsd->global_inline_dist, pwsd->line_inline_dist);
    pwsd->global_sep_let_level   = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);

    pwsd->global_bw_sp           = GET_AVE(pwsd->global_bw_sp, pwsd->line_bw_sp);
    pwsd->global_sw_sp           = GET_AVE(pwsd->global_sw_sp, pwsd->line_sw_sp);

    pwsd->line_inline_dist       = pwsd->global_inline_dist;
    pwsd->line_inword_dist       = pwsd->global_inword_dist ;
    pwsd->line_sep_let_level     = GET_AVE(pwsd->def_sep_let_level, pwsd->global_sep_let_level);

    HWRMemSet(pwsd->hist, 0, sizeof(pwsd->hist));
    HWRMemSet(pwsd->horz, 0, sizeof(pwsd->horz));

    if (pwsd->line_cur_stroke > 0)
     {
      pwsd->xstrokes[0]          = pwsd->xstrokes[pwsd->line_cur_stroke];
      pwsd->line_cur_stroke      = 0;
     }
   }

  // --------------- Init line data -------------------

  pwsd->line_start        = TABLET_XS;
  pwsd->line_end          = 0;
  pwsd->line_active_start = TABLET_XS;
  pwsd->line_active_end   = 0;
  pwsd->line_extr         = 0;
  pwsd->line_last_ws_try  = 0;

// line_h_bord;          // left for the first sample of the next line
// line_word_dist;
// line_inword_dist;

  pwsd->line_word_len     = 0;
  pwsd->line_bw_sp        = 0;

  pwsd->line_finished     = 0;
  pwsd->global_cur_line  += 1;
  pwsd->line_st_word      = pwsd->global_num_words;
  pwsd->line_st_stroke    = pwsd->global_cur_stroke;

  pwsd->line_flags        = 0;
  if (pwsd->stroke_flags & ST_FL_NL_GESTURE) pwsd->line_flags |= LN_FL_NL_GESTURE;

  return 0;
 }

/* ************************************************************************* */
/*      Calculate stroke initial parameters                                  */
/* ************************************************************************* */
_INT WS_GetStrokeBoxAndSlope(p_ws_data_type pws_data)
 {
  _INT   i, j;
  _INT   x, y;
  _INT   dx, dy;
  _INT   adx, ady;
  _INT   num_points;
  _INT   min_stroke_x, max_stroke_x, min_stroke_y, max_stroke_y;
  _INT   hslp;
  _LONG  x_sum, y_sum;
  _LONG  dx_sum, dy_sum;
  p_ws_data_type pwsd = pws_data;
  PS_point_type _PTR stroke;


  hslp         = pwsd->line_h_bord/16; if (hslp < 3) hslp = 3;
  stroke       = pwsd->stroke;
  num_points   = pwsd->stroke_num_points;
  min_stroke_y = min_stroke_x = TABLET_XS;
  max_stroke_y = max_stroke_x = 0;
  x_sum        = 0;
  y_sum        = 0;
  dx_sum       = 0;
  dy_sum       = 0;
  for (i = 0, j = 0; i < num_points; i ++)
   {
    x = stroke[i].x;
    y = stroke[i].y;

    if (y < 0) break;

    x_sum += x;
    y_sum += y;

    if (y > max_stroke_y) max_stroke_y = y;
    if (y < min_stroke_y) min_stroke_y = y;

    if (x > max_stroke_x) max_stroke_x = x;
    if (x < min_stroke_x) min_stroke_x = x;
    dx  = (x - stroke[j].x);
    adx = WSAbs(dx);
    dy  = -(y - stroke[j].y);
    ady = WSAbs(dy);

    if (ady+adx > hslp) // if too close, skip
     {
      j = i;

      if (dy != 0 && (100*(_LONG)(adx))/(_LONG)(ady) <= 100l) // if too horizontal -- skip
       {
        if (dy < 0)  // going  down the trace, notice more
         {
          dy = -(dy*8);
          dx = -(dx*8);
         }

        dx_sum += dx;
        dy_sum += dy;
       }
     }
   }

  if (i == 0) goto err;

  pwsd->stroke_num_points = i;
  pwsd->stroke_min_x      = min_stroke_x;
  pwsd->stroke_max_x      = max_stroke_x+1;
  pwsd->stroke_min_y      = min_stroke_y;
  pwsd->stroke_max_y      = max_stroke_y+1;

  pwsd->prev_stroke_dy    = pwsd->stroke_dy;
  pwsd->prev_stroke_dx    = pwsd->stroke_dx;

  pwsd->stroke_dy         = max_stroke_y - min_stroke_y + 1;
  pwsd->stroke_dx         = max_stroke_x - min_stroke_x + 1;

  pwsd->stroke_wx_pos     = (_INT)(x_sum/i);
  pwsd->stroke_wy_pos     = (_INT)(y_sum/i);

  pwsd->xstrokes[pwsd->line_cur_stroke].st  = (_SHORT)(min_stroke_x);
  pwsd->xstrokes[pwsd->line_cur_stroke].end = (_SHORT)(max_stroke_x+1);
  pwsd->xstrokes[pwsd->line_cur_stroke].top = (_SHORT)(pwsd->stroke_min_y);

  if (pwsd->stroke_num_points >= 10 && dy_sum > 160)
   {
    pwsd->global_slope_dx += dx_sum;
    pwsd->global_slope_dy += dy_sum;
    pwsd->global_slope     = (_INT)((100*(_LONG)(pwsd->global_slope_dx))/(_LONG)(pwsd->global_slope_dy));
  //  pwsd->global_slope    -= 7;
    if (pwsd->global_slope_dy < 500) pwsd->global_slope /= 2; // Starting slope is unstable

    #if PG_DEBUG
    printw("\nStrokeSlope: %ld, Global: %d ", (100*dx_sum)/dy_sum, pwsd->global_slope);
    #endif
   }

  if (pwsd->stroke_dy > pwsd->line_h_bord/4) // Escape influence of small dots
   {
    pwsd->global_dy_sum += pwsd->stroke_dy;
    pwsd->global_num_dy_strokes ++;
    pwsd->global_line_ave_y_size = pwsd->global_dy_sum/pwsd->global_num_dy_strokes;
   }

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*      Decide, if current stroke belongs to a new line                      */
/* ************************************************************************* */
_INT WS_NewLine(p_ws_data_type pws_data)
 {
  _INT i, m, k, l, d, p;
  _INT horz;
  _INT high, low, min_line;
  _INT new_line = 0;
  register p_ws_data_type pwsd = pws_data;


  horz = HORZ_GET(pwsd->stroke_min_x);

  if (horz > 0 && CheckForSpaceGesture(pwsd))
   {                           // If started to left from the line end
    m  = (pwsd->line_active_end - pwsd->line_inword_dist*2)- pwsd->stroke_min_x;
    m /= 2;
    if (m < -pwsd->line_h_bord) m = -pwsd->line_h_bord;
    if (m > pwsd->line_h_bord)  m = pwsd->line_h_bord;
                               // If ended too left from line end
    k  = (pwsd->line_active_end - pwsd->line_inword_dist) - pwsd->stroke_max_x;
    k /= 2;
    if (k < 0) k = 0; if (k > pwsd->line_h_bord) k = pwsd->line_h_bord;
                               // If top is in current line
    l  = (horz + pwsd->line_h_bord/2) - pwsd->stroke_min_y;
    l *= 3;
    if (l < 0) l = 0; if (l > pwsd->line_h_bord) l = pwsd->line_h_bord;
    if (pwsd->stroke_dx > pwsd->stroke_dy) l = 0; // Appliable Only for 'j' type strokes

    high = pwsd->line_h_bord*3;
    low  = pwsd->line_h_bord*2;

    if (pwsd->stroke_dy < pwsd->line_h_bord) // Small strokes are unlikely to start new line
     {
      low  += low/3;
      if (pwsd->stroke_dx < pwsd->line_inline_dist) low += low/3;
     }

    if (pwsd->stroke_dx < pwsd->line_inline_dist) high += high/3;
    if (pwsd->stroke_dy < pwsd->line_h_bord)      high += high/3; // Small strokes are unlikely to start new line

    if (pwsd->stroke_num_points < 100) // Crosses will not exceed that
     {
      for (i = 1, d = 0; i < pwsd->stroke_num_points; i ++)
        d += WSAbs(pwsd->stroke[i].x - pwsd->stroke[i-1].x) + WSAbs(pwsd->stroke[i].y - pwsd->stroke[i-1].y);
      if (2*d > 3*(pwsd->stroke_dx+pwsd->stroke_dy)) p = 1;
       else
       {
        p = 0;
        if (pwsd->stroke_dx < pwsd->line_h_bord*2 && pwsd->stroke_dy < pwsd->line_h_bord*2)
          high += high/3;
       }
     }
     else p = 1;

    if (p) // Maybe it is long cursive word?
     {
      if (pwsd->stroke_dx > pwsd->line_h_bord*3) high -= high/3;
      if (pwsd->stroke_dx > pwsd->line_h_bord*5) high -= high/3;
     }

    high = high - m;
    low  = low - m - k + l;

    min_line = pwsd->line_h_bord + pwsd->line_h_bord/4;
    if (high < min_line) high = min_line;
    if (low  < min_line) low  = min_line;

    if (pwsd->in_line_dist > 0) high = low = pwsd->in_line_dist; // External in control

    m = (pwsd->stroke_wy_pos + pwsd->stroke_max_y)/2;
    l = pwsd->stroke_wy_pos;

    if (m < horz - high || // Upper line
        l > horz + low)    // Lower line
     {
      new_line = 1;  // ---------------- New line stated !!! because of new line-------------------
     }
   }
   else
   {
    new_line = 1;  // ---------------- New line stated !!! because of undefined -------------------
   }


  return new_line;
 }

/* ************************************************************************* */
/*      Decide, if current stroke belongs to a new line                      */
/* ************************************************************************* */
_INT CheckForSpaceGesture(p_ws_data_type pws_data)
 {
  _INT sx, ex;
  register p_ws_data_type pwsd = pws_data;

  if ((pwsd->in_flags & WS_FL_SPGESTURE) == 0) goto err;
  if (pwsd->stroke_dx*2 < pwsd->line_h_bord) goto err;
  if (pwsd->stroke_dx < pwsd->stroke_dy*3) goto err;

  sx = pwsd->stroke[0].x;
  ex = pwsd->stroke[pwsd->stroke_num_points-1].x;

//  if ((WSAbs(sx-ex))*3 > pwsd->stroke_dx) goto err;
  if ((sx-pwsd->stroke_min_x)*3 > pwsd->stroke_dx) goto err;
  if ((ex-pwsd->stroke_min_x)*3 > pwsd->stroke_dx) goto err;

  pwsd->stroke_flags |= ST_FL_NL_GESTURE;

  return 0;
err:
  return 1;
 }
/* ************************************************************************* */
/*      Write down stroke HORZ values                                        */
/* ************************************************************************* */
_INT WS_WriteStrokeHorzValues(p_ws_data_type pws_data)
 {
  _INT i, k;
  _INT horz;
  _INT pos, spos;
  register p_ws_data_type pwsd = pws_data;

  horz = HORZ_GET(pwsd->stroke_min_x);
  spos = pwsd->stroke_wy_pos;

  if (pwsd->stroke_dy < pwsd->line_h_bord/2)  // Do not honor small strokes
   {
    if (horz > 0) spos = (3*horz + spos)/4;
   }
                              // Do not put 't' crossses etc. in the beg of word
  if (horz > 0 && pwsd->stroke_max_x < pwsd->line_end - pwsd->line_inword_dist) goto err;

  if (horz > 0)
   {
    if (pwsd->stroke_dy < pwsd->line_h_bord || pwsd->stroke_dx < pwsd->line_inline_dist)
      pos = (3*horz + spos)/4;
     else pos = (horz + spos)/2;
   } else pos = spos;

  for (i = pwsd->stroke_max_x-1; i >= 0; i -= HORZ_REDUCT)
   {
    horz = HORZ_GET(i);
    if (horz != 0 && i < pwsd->stroke_min_x) break;

    HORZ_PUT(i, pos);

//    if (horz > 0) HORZ_PUT(i, (horz + str_y_pos)/2);
//     else HORZ_PUT(i, str_y_pos);
   }

  k =  pwsd->stroke_max_x + pwsd->line_h_bord*6;
  if (k > TABLET_XS) k = TABLET_XS;
  for (i = pwsd->stroke_max_x; i < k; i += HORZ_REDUCT)
   {
//    horz = HORZ_GET(i);

    HORZ_PUT(i, pos);

//    if (horz > 0) HORZ_PUT(i, (horz + str_y_pos)/2);
//     else HORZ_PUT(i, str_y_pos);
   }

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*      Write down hist for the stroke                                       */
/* ************************************************************************* */
_INT WS_HistTheStroke(p_ws_data_type pws_data)
 {
  _INT i;
  _INT k, l, m, n;
  _INT h, hh, hp, hv, dist, rasst;
  _INT x, dx, dy, xc, xp, yc, yp, xb, yb, mx, min_x, max_x;
  _INT filt_len, f_len, x_step;
  _INT up_lim, dn_lim;
  _INT up;
  _INT end = 0, suppr, sps;
  _INT num_points;
  _INT max_stroke_hist;
  _INT active_stroke_start, active_stroke_end;
  _INT base_line, slope;
  _INT hist_len, hist_base;
  p_ws_data_type pwsd = pws_data;
  PS_point_type _PTR stroke;


  stroke       = pwsd->stroke;
  num_points   = pwsd->stroke_num_points;
  slope        = pwsd->global_slope;

  filt_len     = pwsd->line_h_bord/FL_DIV;
  if (pwsd->line_extr <= MIN_LINE_EXTR) filt_len /= 2;

  if (filt_len < MIN_FL) filt_len = MIN_FL;
  if (filt_len > MAX_FL) filt_len = MAX_FL;

  base_line = HORZ_GET(pwsd->stroke_min_x);
  base_line = GET_AVE(base_line, pwsd->stroke_wy_pos);

  up_lim    = base_line - pwsd->line_h_bord/2;
  dn_lim    = base_line + pwsd->line_h_bord/2;

  xp = (_INT)(((_LONG)(pwsd->stroke_min_y - base_line) * (_LONG)slope)/100);
  xc = (_INT)(((_LONG)(pwsd->stroke_max_y - base_line) * (_LONG)slope)/100);

  min_x = pwsd->stroke_min_x + ((xp < xc) ? xp : xc);
  max_x = pwsd->stroke_max_x + ((xp > xc) ? xp : xc);

  if (min_x < 0) min_x = 0;
  if (min_x > TABLET_XS-4) min_x = TABLET_XS-4;
  if (max_x < 0) max_x = 0;
  if (max_x > TABLET_XS-4) max_x = TABLET_XS-4;


  hist_len  = HIST_POS(max_x - min_x) + HIST_REDUCT*2;
  hist_base = HIST_ADJPOS(min_x);
  pwsd->s_hist = (_UCHAR (_PTR)[HIST_SIZE])HWRMemoryAlloc(hist_len);
  pwsd->s_hist_base = hist_base;
  if (pwsd->s_hist == _NULL) goto err;
  HWRMemSet(&((*pwsd->s_hist)[0]), 0, hist_len);
                                       // Suppress initial fancies for long strokes  only
  if (max_x - min_x > pwsd->line_h_bord * 2) suppr = 1; else suppr = 0;

  if (suppr) sps = 1; else sps = 0;

  up    = 1;
  m     = 0;
  h     = 1;
  hh    = pwsd->line_h_bord/4; //pwsd->line_inword_dist;
  n     = hh/2;
  x     = mx = 0;
//  hp    = max_x;
//  hv    = 1;
  max_x = 0;
  min_x = TABLET_XS;
  rasst = 0;
  for (i = 0; i < num_points; i ++)
   {
    xc = stroke[i].x;
    yc = stroke[i].y;
                                       // Straighten
    xc += (_INT)(((_LONG)(yc - base_line) * (_LONG)slope)/100l);

    if (xc < 0) xc = 0;
    if (xc > TABLET_XS-4) xc = TABLET_XS-4;

    if (min_x > xc) min_x = xc;
    if (max_x < xc) max_x = xc;

    if (i == 0) {xp = xb = xc; yp = yb = yc;}

    rasst += (WSAbs(xp - xc) + WSAbs(yp - yc));

    if (up)
     {
      if (yc < m - n)
       {
        up = 0;
   //         if (xc-x > hh) {HIST_ADD(CUT_LINE_POS, &pwsd->s_hist[xc]); x = mx = xc;}
       }
       else
       {
        if (yc > m) m = yc;
       }
     }
     else
     {
      if (yc > m + n)
       {
        up = 1;
        if (xc-x > hh) {HIST_ADD(PIK_VAL, &(*pwsd->s_hist)[HIST_POS(xc-hist_base)]); x = mx = xc;}
       }
       else
       {
        if (yc < m) m = yc;
       }
     }

    if (suppr && i > num_points - 5) sps = 1;

    f_len = (sps) ? filt_len*2 : filt_len;

    if (rasst > f_len || i == num_points-1)
     {
      if (i == num_points-1) end = 1;

      dx = WSAbs(xb - xc);
      dy = WSAbs(yb - yc);

      hv = ((PIK_VAL*3)*dy)/pwsd->line_h_bord; // Quater of line of vert stroke is enough for pik
      if (yc < up_lim || yc > dn_lim) hv = 1; // Do not hist up strech or dn strech
      if (sps) hv /= 4;
      if (hv < 1) hv = 1;

      if (dx == 0)
       {
//        if (j == 0 || j > num_points-5) hv /= 4;
        if (!end)  h = hv*HIST_REDUCT;
        HIST_ADD(h, &(*pwsd->s_hist)[HIST_POS(xc-hist_base)]);
       }
       else
       {
    //       h = 1 + (dy*10+5)/(dx*10);
        if (!end) {h = 1+(dy/dx);}// if (!up && h > 2) h -= 1;} // Reward less upward moves (links and  tails)
//        if (j == 0 || j > num_points-5) {if (h > 1) h -= 1;}
        if (h > hv) h = hv; // Fight begining 'fancies' in cursive

        x_step = (xc > xb) ? 1:-1;
        for (l = 0; l < dx; l ++)
         {
          hp = xb + (l * x_step);
          hv = HIST_ADD(h, &(*pwsd->s_hist)[HIST_POS(hp-hist_base)]);
          if (hv >= PIK_VAL) // Pik found, set pos, destr prev close
           {
            if (mx > 0)
             {
              dist = WSAbs(mx-hp);
              if (dist < hh && dist > HIST_REDUCT)
               {HIST_SUB(PIK_VAL, &(*pwsd->s_hist)[HIST_POS(mx-hist_base)]); mx = 0;}
             }

            x = hp;
           }
         }
       }

//      j     = i;
      xb    = xc;
      yb    = yc;
      rasst = 0;
      sps   = 0;
     }

    xp = xc;
    yp = yc;
   }

  // Get hist parameters for the stroke
  mx = max_x + HIST_REDUCT;
  active_stroke_start = active_stroke_end = 0;
  for (i = min_x, max_stroke_hist = 0; i <= mx; i += HIST_REDUCT)
  {
   k = (*pwsd->s_hist)[HIST_POS(i-hist_base)];
   if (k > max_stroke_hist) max_stroke_hist = k;

   if (k >= CUT_VAL)
    {
     if (active_stroke_start == 0) active_stroke_start = i;
     active_stroke_end = i;
    }
  }

  if (max_stroke_hist < CUT_VAL) // Small strokes save
   {
    k = HIST_ADJPOS((max_x + min_x)/2);

    HIST_ADD(CUT_VAL, &(*pwsd->s_hist)[HIST_POS(k-hist_base)]);
    active_stroke_start = active_stroke_end = k;
    pwsd->stroke_flags |= ST_FL_JUNK;
   }

  if (active_stroke_start < min_x) active_stroke_start = min_x;
  if (active_stroke_end > max_x+1) active_stroke_end = max_x+1;

  pwsd->stroke_filt_len   = filt_len;
  pwsd->stroke_active_st  = HIST_ADJPOS(active_stroke_start);
  pwsd->stroke_active_end = HIST_ADJPOS(active_stroke_end)+HIST_REDUCT;

  pwsd->stroke_min_x      = HIST_ADJPOS(min_x);
  pwsd->stroke_max_x      = HIST_ADJPOS(max_x + HIST_REDUCT);
//  pwsd->stroke_dx         = (max_x+1) - min_x;
  pwsd->stroke_dx         = pwsd->stroke_max_x - pwsd->stroke_min_x;

//  pwsd->xstrokes[pwsd->line_cur_stroke].st    = (_SHORT)(min_x);
//  pwsd->xstrokes[pwsd->line_cur_stroke].end   = (_SHORT)(max_x+1);
//  pwsd->xstrokes[pwsd->line_cur_stroke].a_end = (_SHORT)(active_stroke_end+1);
  pwsd->xstrokes[pwsd->line_cur_stroke].st    = (_SHORT)(pwsd->stroke_min_x);
  pwsd->xstrokes[pwsd->line_cur_stroke].end   = (_SHORT)(pwsd->stroke_max_x);
  pwsd->xstrokes[pwsd->line_cur_stroke].a_end = (_SHORT)(pwsd->stroke_active_end);


  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*      Add stroke hist to gen line hist                                     */
/* ************************************************************************* */
_INT WS_AddStrokeToHist(p_ws_data_type pws_data)
 {
  _INT    i;
  _INT    b, v, hv, hb;
  p_UCHAR plh, psh;
  p_ws_data_type pwsd = pws_data;

//  if (pwsd->stroke_max_x - pwsd->stroke_min_x == 1) //Do not place dots and strokes upon word
  v = HORZ_GET(pwsd->stroke_active_st);
//  s = (*pwsd->s_hist)[HIST_POS(pwsd->stroke_active_st-pwsd->s_hist_base)];
  if (pwsd->stroke_flags & ST_FL_JUNK) //Do not place dots and strokes upon word
   {
    if (pwsd->hist[HIST_POS(pwsd->stroke_active_st)] > 0) // Remove marker above covered already place
     {
      HIST_SUB(CUT_VAL, &(*pwsd->s_hist)[HIST_POS(pwsd->stroke_active_st-pwsd->s_hist_base)]);
     }
    if (pwsd->stroke_dx < pwsd->line_inword_dist/2)
     {
      if (v > 0 && pwsd->stroke_min_y > v) goto done; // Do not put on hist periods and commas, only apostrofe
     }
   }

  plh = &pwsd->hist[HIST_POS(pwsd->stroke_min_x)];
  psh = &(*pwsd->s_hist)[HIST_POS(pwsd->stroke_min_x-pwsd->s_hist_base)];
  for (i = pwsd->stroke_min_x; i < pwsd->stroke_max_x; i += HIST_REDUCT, plh ++, psh ++)
   {
    v  = (*psh)/HIST_REDUCT;
    if (i >= pwsd->stroke_active_st && i < pwsd->stroke_active_end) b = FL_BODY; else b = 0;
    hv = (*plh) & HIST_FIELD;
    hb = (*plh) & FL_BODY;

    *plh = (_UCHAR)((((hv+v) > HIST_FIELD) ? HIST_FIELD : (hv+v)) | (hb | b));
   }

done:
  if (pwsd->line_start > pwsd->stroke_min_x) pwsd->line_start = pwsd->stroke_min_x;
  if (pwsd->line_end   < pwsd->stroke_max_x) pwsd->line_end   = pwsd->stroke_max_x;
  if (pwsd->line_active_start > pwsd->stroke_active_st)  pwsd->line_active_start = pwsd->stroke_active_st;
  if (pwsd->line_active_end   < pwsd->stroke_active_end) pwsd->line_active_end   = pwsd->stroke_active_end;

  return 0;
 }


 _INT WS_CalcGaps(p_ws_data_type pws_data)
 {
  _INT   j;
  _INT   cur_val, n_gap, sl, size;
  _INT   l, b, ls, bs;
  _INT   tail_preserve_level;
  _INT   state;
  p_ws_data_type pwsd = pws_data;

  #define HIGH 1
  #define LOW  0

  sl = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);

  //  tail_preserve_level = ((sep_let_level > 20) ? sep_let_level : 20);
  tail_preserve_level = 10 + sl; //(sl-10)*2;
  if (tail_preserve_level < 10) tail_preserve_level = 10;
  if (tail_preserve_level > 90) tail_preserve_level = 90;

  size = pwsd->global_cur_stroke - pwsd->line_st_stroke + 4;

  if (pwsd->gaps_handle) {if (pwsd->gaps) HWRMemoryUnlockHandle(pwsd->gaps_handle); HWRMemoryFreeHandle(pwsd->gaps_handle);}
  pwsd->gaps_handle = HWRMemoryAllocHandle(sizeof(ws_gaps_type)*size);
  if (pwsd->gaps_handle == _NULL) goto err;
  pwsd->gaps = (ws_gaps_a_type)HWRMemoryLockHandle(pwsd->gaps_handle);
  if (pwsd->gaps == _NULL) goto err;
//  HWRMemSet(pwsd->gaps, 0, sizeof(ws_gaps_type)*size);

  state = LOW;
  n_gap = 0;
  l = b = 0;
  ls = bs = pwsd->line_start;
  for (j = ls; j < pwsd->line_end+HIST_REDUCT; j += HIST_REDUCT)
   {
    cur_val = pwsd->hist[HIST_POS(j)];

    if (j >= pwsd->line_end) {cur_val |= FL_BODY; state = LOW;} // Write finishing gap

    if (cur_val & FL_BODY)
     {
      if (state == HIGH) {ls = bs = j; continue;}

      (*pwsd->gaps)[n_gap].loc   = (_SHORT)((ls+j)/2);
      (*pwsd->gaps)[n_gap].bst   = (_SHORT)((b == 0) ? ((ls+j)/2) : bs);
      (*pwsd->gaps)[n_gap].lst   = (_SHORT)((l == 0) ? j : ls);
      (*pwsd->gaps)[n_gap].size  =
      (*pwsd->gaps)[n_gap].psize = (_SHORT)((b + ((_LONG)(l-b)*(_LONG)(100-tail_preserve_level))/100)*HIST_REDUCT);
      (*pwsd->gaps)[n_gap].blank = (_SHORT)(b*HIST_REDUCT);
      (*pwsd->gaps)[n_gap].low   = (_SHORT)(l*HIST_REDUCT);
      (*pwsd->gaps)[n_gap].flags = (_SHORT)(0);
      (*pwsd->gaps)[n_gap].k_sure= (_SHORT)(WS_NNET_NSEGLEV);
	  
      n_gap ++;
      l = b = 0;
      state = HIGH;
     }
     else
     {
      if (state == HIGH) {state = LOW;}
      if ((cur_val & HIST_FIELD) == 0) {if (b == 0) bs = j; b ++;} // Blank hist
      if (l == 0) ls = j;
      l ++;                                  // Low hist
     }
   }

  pwsd->line_ngaps = n_gap;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*      Calculate line relative step and other vars                          */
/* ************************************************************************* */
_INT WS_CountPiks(p_ws_data_type pws_data)
 {
  _INT   j, k, m;
  _INT   low, count, cur_val, up, high;
  _INT   pik_step;
  _INT   sl;
  p_ws_data_type pwsd = pws_data;

  sl           = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);
  pik_step     = pwsd->line_h_bord/PIK_STEP_CONST;
  pik_step     = pik_step + (sl*pik_step)/50; // Sep let has bigger step

  k            = 1;
  low          = 1;
  up           = 1;
  high         = 0;
  m            = 0;
  count        = 0;
  for (j = pwsd->line_active_start; j < pwsd->line_active_end; j += HIST_REDUCT)
   {
    cur_val = (pwsd->hist[HIST_POS(j)] & HIST_FIELD);

    if (m > 0) {m -= HIST_REDUCT; continue;}   // Skip after found extrem
    if (k != 0 && cur_val == 0) continue;

    k = 0;

    if (up && cur_val > high) high = cur_val;
    if (up && cur_val <= high - PIK_DN)
     {count ++; up = 0; low = cur_val; m = pik_step; continue;}

    if (!up && cur_val < low) {low = cur_val;}
    if (!up && cur_val >= low + PIK_UP)
     {up = 1; high = cur_val; m = pik_step; continue;}
   }

  if (up) count ++;

  // ------------------ Write values ---------------------------------------

  pwsd->line_extr     = count;
  pwsd->line_pik_step = pik_step;

  return 0;
 }

/* ************************************************************************* */
/*      Calculate line relative step and other vars                          */
/* ************************************************************************* */
_INT WS_SetLineVars(p_ws_data_type pws_data)
 {
  _INT   i, m, n;
  _INT   s, size, deduct;
  _INT   bws_count, sws_count;
  _INT   h, hh, hhh, hhhh, small_sp_sum, betw_word_sp, blank_sp_sum;
  p_ws_data_type pwsd = pws_data;

  if (pwsd->line_extr > MIN_LINE_EXTR)
   {
    pwsd->line_inline_dist = (pwsd->line_end - pwsd->line_start)/pwsd->line_extr;
   }
   else
   {
    if (pwsd->global_inline_dist > 0) pwsd->line_inword_dist = pwsd->line_inline_dist = pwsd->global_inline_dist;
     else pwsd->line_inword_dist = pwsd->line_inline_dist = pwsd->line_h_bord/2;
   }

//  sl           = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);
  s            = 30;// + sl/2;
  m            = GET_AVE(pwsd->global_inline_dist, pwsd->line_inline_dist);
  n            = (pwsd->line_extr > MIN_LINE_EXTR) ? m : pwsd->line_h_bord;
  h            = (_INT)(n + ((_LONG)n*(_LONG)s)/100);

  hh           = m*3;
  hhh          = m/2;
  hhhh         = m; // - m/4;    // - here

  sws_count    = 0;
  bws_count    = 0;

  small_sp_sum = 0;
  betw_word_sp = 0;
  blank_sp_sum = 0;

  deduct       = 0;

  for (i = 1; i < pwsd->line_ngaps-1; i ++)
   {
    size = (*pwsd->gaps)[i].size;

    if (size > h) // Interword gap
     {
      if (size > hh) deduct += size - hh;
      betw_word_sp += (size > hh) ? hh : size;
      bws_count ++;
     }
     else                          // Inword gap
     {
      n = (*pwsd->gaps)[i].blank;
      if (n > hhhh) n = 0; else  n = (n > hhh) ? hhh : n;
      blank_sp_sum += n;
//      small_sp_sum += ((*pwsd->gaps)[i].low > hhhh) ? hhhh : (*pwsd->gaps)[i].low;
      small_sp_sum += (*pwsd->gaps)[i].low;
      sws_count ++;
     }
   }

  // ------------------ Write values ---------------------------------------

  pwsd->line_word_len = (pwsd->line_end - pwsd->line_start) - betw_word_sp;
  if (pwsd->line_word_len < 1) pwsd->line_word_len = 1;

  if (bws_count > 0) pwsd->line_bw_sp = betw_word_sp/bws_count;
   else pwsd->line_bw_sp = 0;
  if (sws_count > 0) pwsd->line_sw_sp = small_sp_sum/sws_count;
   else pwsd->line_sw_sp = 0;

  if (pwsd->line_extr > MIN_LINE_EXTR)
   {
    pwsd->line_inword_dist = pwsd->line_word_len/pwsd->line_extr;
    pwsd->line_inline_dist = (pwsd->line_end - pwsd->line_start - deduct)/pwsd->line_extr;

    pwsd->line_sep_let_level = (_INT)((200l*(_LONG)(small_sp_sum/4+blank_sp_sum))/pwsd->line_word_len);
    if (pwsd->line_sep_let_level > 100) pwsd->line_sep_let_level = 100;
    if (pwsd->line_sep_let_level < 2)   pwsd->line_sep_let_level = 2;
   }

  return 0;
 }


/* ************************************************************************* */
/*      Estimate line height                                                 */
/* ************************************************************************* */
_INT WS_CalcLineHeight(p_ws_data_type pws_data)
 {
  _INT   h, k;
  register p_ws_data_type pwsd = pws_data;

//without last stroke!!!

  if (pwsd->global_num_extr + pwsd->line_extr > MIN_LINE_EXTR)
   {
    h = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);
//    h = (h > 15) ? h-15 : 0;
//    h = ((_LONG)pwsd->global_line_ave_y_size * (_LONG)(30 + h/2))/100;
    h = h/2;
    h = (_INT)(((_LONG)pwsd->global_line_ave_y_size * (_LONG)(40 + h))/100);
    k = pwsd->line_inline_dist;

    pwsd->line_h_bord = (pwsd->line_h_bord + h + k)/3;
   }
   else
   {
    pwsd->line_h_bord = (pwsd->global_line_ave_y_size + pwsd->line_h_bord + pwsd->def_h_bord)/3;
   }

  if (pwsd->line_h_bord < MIN_H_BORD) pwsd->line_h_bord = MIN_H_BORD;

  return 0;
 }

/* ************************************************************************* */
/*      PostProcess line gaps                                                */
/* ************************************************************************* */
_INT WS_PostprocessGaps(p_ws_data_type pwsd)
 {
  _INT i, l;
  _INT m, n;
  _INT size, start, end, h, hght, sub;
  _INT fws, fwe;
  _INT inline_dist, line_end_stroke, ngaps, dist;
  _INT ono;
  _INT ht;
  _UCHAR gps[MAX_STROKES];
  p_ws_gaps_type pgap, ppgap;


  inline_dist = pwsd->line_inline_dist;
  line_end_stroke = pwsd->line_cur_stroke;
  if (pwsd->line_finished == WS_NEWLINE) line_end_stroke --;

  // ----------- Presegment to groups ----------------------------

  ppgap = &((*pwsd->gaps)[0]);
  for (i = 0, ngaps = 0; i < pwsd->line_ngaps; i ++, ppgap ++)
   {
    ppgap->psize = ppgap->size;
    if (i == 0 || i == pwsd->line_ngaps-1 || ppgap->size > inline_dist/2)
     {
      gps[ngaps++] = (_UCHAR)i;
     }
   }

  // ----------- Searching for punctuation -----------------------

  dist = inline_dist*2;

  for (i = 0; i < ngaps-1; i ++, pgap ++, ppgap ++)
   {
    ppgap = &((*pwsd->gaps)[gps[i]]);
    pgap  = &((*pwsd->gaps)[gps[i+1]]);

//    size  = pgap->bst - (ppgap->bst+ppgap->blank);
    size  = pgap->lst - (ppgap->lst+ppgap->low);
    ono   = (size < inline_dist/2) ? 1 : 0;

//    if (i < ngaps-2 && pgap->psize < inline_dist) ono = 0;

    if (ono)
     {
      m = n = 32000;
      if (i > 0)       m = ppgap->blank; // Left free space
      if (i < ngaps-2) n = pgap->blank;  // Right free space

      if (n < dist || m < dist)
       {
        if (m/2 <= n) pgap = ppgap; // Merge to prev, else to next
       }
     }

    if (ono)
     {
      pgap->psize  = (_SHORT)(pgap->blank/2);
      pgap->flags |= (_SHORT)(WS_GP_EPUNCT);
     }
   }


  // ----------- Searching for leading Capitals --------------------------

  ht = pwsd->line_h_bord - pwsd->line_h_bord/4;
//  ht = pwsd->line_h_bord/2;

  for (i = 1; 0 && i < ngaps; i ++, pgap ++, ppgap ++)
   {
    ppgap = &((*pwsd->gaps)[gps[i-1]]);
    pgap  = &((*pwsd->gaps)[gps[i]]);

    size  = pgap->lst - (ppgap->lst+ppgap->low);
    sub   = 0;

    ono   = (size < inline_dist*2) ? 1 : 0;

    if (i > 1 && ppgap->blank < inline_dist) ono = 0;
    if (pgap->blank > inline_dist*2) ono = 0;

    if (ono)
     {
//      fws  = ppgap->bst + ppgap->blank;
      fws  = pgap->bst - inline_dist/4;
      fwe  = pgap->bst;
      h    = HORZ_GET((fws+fwe)/2);
      hght = 0;

      for (l = 0; l <= line_end_stroke; l ++)  // If small enough -- let's compare height
       {
        start = pwsd->xstrokes[l].st;
        end   = pwsd->xstrokes[l].end;

        if ((start >= fws && start <= fwe) ||
            (end   >= fws && end   <= fwe) ||
            (start <= fws && end   >= fwe))
         {
          if (hght < h - pwsd->xstrokes[l].top) hght = h - pwsd->xstrokes[l].top;
         }
       }

      if (hght < ht) ono = 0;
       else sub = (hght - ht);
     }

    if (ono)
     {
      if (i == 1) pgap->psize = (_SHORT)(pgap->size-sub);
       else pgap->psize  = (_SHORT)(pgap->size-sub/2);
      if (pgap->psize < 0) pgap->psize = 0;
      pgap->flags |= (_SHORT)(WS_GP_LCAP);
     }
   }



#if 0
  // --------------- Check on presence of small words (punct) ------------

  dist  = HWRMin(word_dist*2, pwsd->line_h_bord*2); // + word_dist/2;
//  dist  = word_dist*2; // + word_dist/2;
//dist = 0; //exp
  for (j = 0; j < num_words; j ++)
   {
    _INT punct = 1;

    st  = pwsd->xwords[j].st_gap;
    fws = (*pwsd->gaps)[st].lst + (*pwsd->gaps)[st].low;
    ws  = (*pwsd->gaps)[st].bst + (*pwsd->gaps)[st].blank;
    en  = pwsd->xwords[j].en_gap;
    fwe = (*pwsd->gaps)[en].lst;
    we  = (*pwsd->gaps)[en].bst;

    if (fwe-fws > inword_dist/2) punct = 0; // Active part too big
    if (we - ws > inword_dist && fwe-fws > inword_dist/8) punct = 0; // Dash ?

    if (punct)
     {
      m = n = 32000;
//      k = (fws + fwe)/2;
      if (j > 0)           m = (*pwsd->gaps)[st].blank; //size;
      if (j < num_words-1) n = (*pwsd->gaps)[en].blank; //size;

      if (n < dist || m < dist)
       {
        if (m/2 <= n) pwsd->xwords[j-1].en_gap = pwsd->xwords[j].en_gap; // Merge to prev
         else pwsd->xwords[j+1].st_gap = pwsd->xwords[j].st_gap;       // Merge to next

        HWRMemCpy(&pwsd->xwords[j], &pwsd->xwords[j+1], sizeof(pwsd->xwords[0])*(num_words-(j+1)));
        num_words --;
        j --;
        continue;
       }
     }
   }

  // --------------- Check on presence of small words (Capitals) ---------

  for (j = 0; j < num_words-1; j ++)
   {
    m = 0;
    st  = pwsd->xwords[j].st_gap;
    fws = (*pwsd->gaps)[st].loc + (*pwsd->gaps)[st].size/2;
    en  = pwsd->xwords[j].en_gap;
    fwe = (*pwsd->gaps)[en].loc - (*pwsd->gaps)[en].size/2;
    n = HORZ_GET(fwe+(*pwsd->gaps)[en].size/2);

    if (fwe - fws < inword_dist*2)
     {
      for (l = 0; l <= line_end_stroke; l ++)  // If small enough -- let's compare height
       {
        start = pwsd->xstrokes[l].st;
        end   = pwsd->xstrokes[l].end;

        if ((start >= fws && start <= fwe) ||
            (end   >= fws && end   <= fwe) ||
            (start <= fws && end   >= fwe))
         {
          if (m < n - pwsd->xstrokes[l].top) m = n - pwsd->xstrokes[l].top;
         }
       }

      m = (m - pwsd->line_h_bord)/2; // m now contains superseding height
      if (m <= 0) continue;

      if (j > 0) m /= 2;        // First word is more likely to have cap let

      l = (*pwsd->gaps)[en].size - m;

      if (l < word_dist) // Now has the gap become smaller than word dist?
       {
        pwsd->xwords[j+1].st_gap = pwsd->xwords[j].st_gap;       // Merge to next
        HWRMemCpy(&pwsd->xwords[j], &pwsd->xwords[j+1], sizeof(pwsd->xwords[0])*(num_words-(j+1)));
        num_words --;
        j --;
        continue;
       }
     }
   }
#endif

  return 0;
 }


/* ************************************************************************* */
/*      Estimate word segmentation distance                                  */
/* ************************************************************************* */
_INT WS_GetWordDist(p_ws_data_type pws_data)
 {
  _INT  i;
  _INT  ss, ns, sl, nl, size, sdist, bdist;
  _INT  inline_dist, sw_space, bw_space, word_dist, inword_dist, sep_let_level;
  register p_ws_data_type pwsd = pws_data;
  _INT  action;

//_UCHAR  ws_handle_limits[2][11] = {//0   1    2    3    4    5   6    7    8    9   10
//                                  {  0,  0,   0,   0,   0,   0,  0, 100, 140, 180, 255},
//                                  {  0, 50, 100, 150, 200, 255,  0,   0,   0,   0,   0}
//                                  };

_UCHAR  ws_handle_limits[2][11] = {//0   1    2    3    4    5   6    7    8    9   10
                                  {  0, 40,  60,  80, 100, 120,  0, 150, 180, 200, 240},
                                  {  0, 50,  70,  90, 110, 130,  0, 160, 190, 210, 255}
                                  };

#define GWD_SWD   40 //37  //41  //39  // 37   /* 32  Act1/Act2 IF small word dist coeff */
#define GWD_IWD   88 //80  //79  //79  // 80   /* 76  Act1/Act2 IF inword dist coeff */
#define GWD_BWD   91 //91  //83  //83  // 91   /* 86  Act1/Act2 IF inline dist coeff */
#define GWD_ACT1  48 //49  //49  //47  // 49   /* 42  Act1 Calc coeff   */
#define GWD_ACT2  245//150 //228 //195 //140   /* 136 Act2 Calc coeff  */
#define GWD_ACT21 90 //95  //96  //100 //140


//and spaces betw words count with tails!
//and 4 instead of 2

  inword_dist   = GET_AVE(pwsd->global_inword_dist, pwsd->line_inword_dist);
  inline_dist   = GET_AVE(pwsd->global_inline_dist, pwsd->line_inline_dist);
//  sw_space      = GET_AVE(pwsd->global_sw_sp, pwsd->line_sw_sp);
//  bw_space      = GET_AVE(pwsd->global_bw_sp, pwsd->line_bw_sp);
//  sep_let_level = GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level);
  sep_let_level = pwsd->line_sep_let_level;

  if (inline_dist <= 0) inline_dist = 1;
//  bdist = inline_dist + inline_dist/4;
//  sdist = inline_dist - inline_dist/4;
//  bdist = inline_dist;// + inline_dist/16;
//  sdist = inline_dist;// - inline_dist/16;

  bdist = inline_dist + (_INT)(((_LONG)inline_dist*(_LONG)(sep_let_level/2))/100);
  sdist = inline_dist;// - inline_dist/16;

  ss = ns = sl = nl = 0;
  for (i = 1; i < pwsd->line_ngaps-1; i ++)
   {
    size = (*pwsd->gaps)[i].size;
    if (size < sdist) {ss += (size < inline_dist/8) ? inline_dist/8 : size; ns ++;}
    if (size > bdist) {sl += (size > inline_dist*3) ? inline_dist*3 : size; nl ++;}
   }

  sw_space = (ns > 0) ? (ss/ns) : 0;
//  sw_space = (ss > inline_dist/4) ? ss : inline_dist/4;
  bw_space = (nl > 0) ? (sl/nl) : 0;

//  if (pwsd->line_sw_sp == 0) sw_space = 0;
//  if (pwsd->line_bw_sp == 0) bw_space = 0;

  pwsd->nn_ssp         = (_INT)((100*(_LONG)sw_space)/inline_dist);     // a
  pwsd->nn_n_ssp       = ns;                                            // b
  pwsd->nn_bsp         = (_INT)((100*(_LONG)bw_space)/inline_dist);     // c
  pwsd->nn_n_bsp       = nl;                                            // d
  pwsd->nn_sl          = sep_let_level;                                 // e
  pwsd->nn_inw_dist    = (_INT)((100*(_LONG)inword_dist)/inline_dist);  // f
  pwsd->nn_npiks       = pwsd->line_extr;                               // g

  if (sw_space    < (_INT)((GWD_SWD*(_LONG)bw_space)/100) &&
      inword_dist < (_INT)((GWD_IWD*(_LONG)bw_space)/100) &&
      inline_dist < (_INT)((GWD_BWD*(_LONG)bw_space)/100))
   {
    word_dist = sw_space + (_INT)((GWD_ACT1*(_LONG)(bw_space-sw_space))/100);
//    word_dist = (sw_space + bw_space)/2;
//    if (word_dist < inword_dist) word_dist = inword_dist;
    action = 1;
   }
   else
   {
//    sep_let_level = (sep_let_level > 15) ? sep_let_level-15 : 0;
//    word_dist = inline_dist + (150*(_LONG)((inline_dist*sep_let_level)/100))/100;
//    word_dist = inline_dist - inline_dist/4 + (_INT)((GWD_ACT2*((_LONG)inline_dist*(_LONG)sep_let_level)/100)/100);
    word_dist = (GWD_ACT21*inline_dist)/100 + (_INT)((GWD_ACT2*((_LONG)inline_dist*(_LONG)sep_let_level)/100)/100);
//    word_dist = (5*(_LONG)sw_space*(_LONG)sep_let_level)/100;
    action = 2;
   }

//--------------------
//  if (ns > 0) word_dist = sw_space + nl + ((2*sep_let_level)/ns) + ((76*inline_dist)/100);
//   else word_dist = sw_space + nl + ((76*inline_dist)/100);
//--------------------

//  word_dist = sw_space + (86*inline_dist)/100;

//--------------------

//  word_dist = sw_space + ((pwsd->line_extr > 0) ? (2*inword_dist/pwsd->line_extr) : 0) + (63*inline_dist)/100;

//--------------------

//  word_dist = (37 > 16+pwsd->nn_sl) ? (110+pwsd->nn_n_bsp) : (pwsd->nn_ssp+80);
  word_dist = ((10 > pwsd->nn_npiks) ?  110 : 79) +
              ((pwsd->nn_sl*pwsd->nn_n_ssp+pwsd->nn_npiks > 100) ? pwsd->nn_ssp : (pwsd->nn_sl-pwsd->nn_n_ssp+pwsd->nn_npiks));

  word_dist = inline_dist*word_dist/100;

//--------------------

  if (word_dist < inline_dist-inline_dist/4) word_dist = inline_dist-inline_dist/4;
  if (word_dist > inline_dist*3) word_dist = inline_dist*3;

  if (pwsd->global_num_extr+pwsd->line_extr < MIN_LINE_EXTR*2) // Too little data, stay with default
   {
    if (word_dist < pwsd->def_h_bord + (pwsd->def_h_bord >> 2))
     {
      word_dist = pwsd->def_h_bord + (pwsd->def_h_bord >> 2);
      action    = 0;
     }
   }

//  word_dist = GET_AVE(pwsd->global_word_dist, word_dist);


//  if (pwsd->in_word_dist != 0)    // Absorb input handle
//   {      // 6-- middle of the range (1-10) -- default cut
//    if (pwsd->in_word_dist > 6)
//      word_dist = (_INT)((_LONG)word_dist*(_LONG)(pwsd->in_word_dist-6));
//     else
//      word_dist = (_INT)(((_LONG)word_dist*(_LONG)((pwsd->in_word_dist-1)*10*2))/100);
//
////    if (pwsd->in_word_dist == 10) word_dist = TABLET_XS;
//    if (word_dist <= 0) word_dist = 1;
//   }

  sdist = bdist = 0;
  if (ws_handle_limits[0][pwsd->in_word_dist] > 0) sdist = (inline_dist*ws_handle_limits[0][pwsd->in_word_dist])/100;
  if (ws_handle_limits[1][pwsd->in_word_dist] > 0) bdist = (inline_dist*ws_handle_limits[1][pwsd->in_word_dist])/100;

  if (sdist && word_dist < sdist) word_dist = sdist;
  if (bdist && word_dist > bdist) word_dist = bdist;


  pwsd->line_word_dist = word_dist;

  pwsd->ws_ssp         = sw_space;
  pwsd->ws_bsp         = bw_space;
  pwsd->ws_inline_dist = inline_dist;
  pwsd->ws_word_dist   = word_dist;
  pwsd->ws_action      = action;

// debug

#if HWR_SYSTEM != MACINTOSH
  WS_100
#endif

//if (pwsd->nn_cmp_max > 0) // cmp present
// {
//  if (pwsd->nn_cmp_min < pwsd->nn_cmp_max)
//    word_dist = ((_LONG)((pwsd->nn_cmp_min + pwsd->nn_cmp_max)/2)*inline_dist)/100;
//   else word_dist = ((_LONG)(pwsd->nn_cmp_max)*inline_dist)/100 - 1;
// }

  return word_dist;
 }


/* ************************************************************************* */
/*    Fly learn some ws parameters                                           */
/* ************************************************************************* */
_INT WS_FlyLearn(p_ws_control_type pwsc, p_ws_memory_header_type pwmh, p_ws_data_type pwsd)
 {
  _INT                  i;
  _INT                  loc;
  _ULONG                sh, sw, sl, sp, ss;
  p_ws_lrn_type         lrn;

  if (pwmh == _NULL) goto err;
  if (pwsc == _NULL) goto err;
  if (pwsd == _NULL) goto err;

  for (loc = 0; loc < WS_LRN_SIZE; loc ++) if (pwmh->lrn_buf[loc].h_bord_history == 0) break;

  if (loc >= WS_LRN_SIZE) // The box is full
   {
    loc = WS_LRN_SIZE-1;
    HWRMemCpy(&(pwmh->lrn_buf[0]), &(pwmh->lrn_buf[1]), sizeof(pwmh->lrn_buf[0])*(WS_LRN_SIZE-1));
   }

  lrn = &(pwmh->lrn_buf[loc]);
  lrn->h_bord_history      = (_SHORT)(pwsd->line_h_bord);
  lrn->inword_dist_history = (_SHORT)(GET_AVE(pwsd->global_inword_dist, pwsd->line_inword_dist));
  lrn->inline_dist_history = (_SHORT)(GET_AVE(pwsd->global_inline_dist, pwsd->line_inline_dist));
  lrn->slope_history       = (_SHORT)(pwsd->global_slope);
  lrn->sep_let_history     = (_UCHAR)(GET_AVE(pwsd->global_sep_let_level, pwsd->line_sep_let_level));

  if (loc >= WS_LRN_SIZE-1) // The box is full
   {
    lrn = &(pwmh->lrn_buf[0]);
    for (i = 0, sh = sw = sl = sp = ss = 0l; i < WS_LRN_SIZE; i ++, lrn ++)
     {
      sh += (_ULONG)(lrn->h_bord_history);
      sw += (_ULONG)(lrn->inword_dist_history);
      sl += (_ULONG)(lrn->inline_dist_history);
      sp += (_ULONG)(lrn->slope_history);
      ss += (_ULONG)(lrn->sep_let_history);
     }

    lrn = &(pwmh->lrn);
    lrn->h_bord_history      = (_SHORT)((sh)/(WS_LRN_SIZE));
    lrn->inword_dist_history = (_SHORT)((sw)/(WS_LRN_SIZE));
    lrn->inline_dist_history = (_SHORT)((sl)/(WS_LRN_SIZE));
    lrn->slope_history       = (_SHORT)((sp)/(WS_LRN_SIZE));
    lrn->sep_let_history     = (_UCHAR)((ss)/(WS_LRN_SIZE));
   }
   else goto err;

  return 0;
err:
  return 1;
 }
/* ************************************************************************* */
/*        END  OF ALL                                                        */
/* ************************************************************************* */
/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xrlv.cpp ===
/* ************************************************************************* */
/*        Word  corrector module for handwriting recognition program         */
/*        Created 3/00/96. Last modification 7/12/98.     AVP 1996           */
/* ************************************************************************* */

#include "hwr_sys.h"
#include "zctype.h"

#include "ams_mg.h"                           /* Most global definitions     */
#include "xrword.h"
#include "xrlv.h"

#ifdef DBG
 #define PEGREC_DEBUG  1     /* Allows to print out log of recognition proceedings */
 void PegDebugPrintf(char * format, ...);
#else
 #define PEGREC_DEBUG  0
#endif

#include "xrlv_p.h"


#define XRLV_SNN_SWITCH 1

#if PG_DEBUG
  #define XRLV_DUMP_TRAJECTORY 0
#endif

#if !(XRLV_SNN_SWITCH)
#define XrlvNNXrlvPos(pos, xd);
#else
#include "polyco.h"
#include "snn.h"
#endif

P_XRLV_0

#define PG_DEBUG_LOCAL 0
//#define DEBUG_PRINT_SYM_BUF

#ifdef  DEBUG_PRINT_SYM_BUF
long gPrintSymBuf = 0;
#include <stdio.h>
#include <stdarg.h>
_INT XrlvPrintXrlvPos(_INT pos, p_xrlv_data_type xd);
 #ifdef PEGASUS
  _INT mpr = -6;
  #define printw
  #define put_xr
 #endif
#endif

#if XRLV_DUMP_TRAJECTORY
_INT XrlvDumpTrace(_INT ii, PS_point_type _PTR trace, p_CHAR name);
#endif

#define LSTRIP_CORR_CONST 4

// ------------------------ Debug --------------------------------------------

extern "C" BOOL BearAddSegCol (rc_type _PTR prc, p_xrlv_data_type  xd);
extern "C" void GetXRNetOutput (int iXRSt, int cXR, p_xrdata_type xrdata, _UCHAR *pOut);

#ifdef TRAINTIME_BEAR
extern "C" BOOL SavePrototypes (p_rec_inst_type pri, rc_type _PTR prc, p_xrlv_data_type  xd);
extern "C" BOOL XRLVTune (p_rec_inst_type pri, rc_type _PTR prc, p_xrlv_data_type  xd);
extern "C" unsigned char g_szAnswer[];
#endif

/* ************************************************************************* */
/* *    Separated letter upper level recognizer                            * */
/* ************************************************************************* */

_INT xrlv(p_rec_inst_type pri)
 {
  p_xrdata_type				xrdata	=	&pri->xrdata; 
  p_RWG_type				rwg		=	&pri->rwg;
  rc_type  _PTR				rc		=	&pri->rc;

  _INT                     er = 0;
  _INT                     ext_data_used;
  _SHORT                   xrwm = rc->corr_mode;
  _SHORT                   m_cm = rc->caps_mode;
  _SHORT                   m_cs = rc->enabled_cs;
  p_xrlv_data_type         xd   = _NULL;
  
  /* ------ Allocate memory & init structures ------------------------------ */

  P_XRLV_1

  HWRMemSet(rwg, 0, sizeof(*rwg));

  rc->corr_mode &= ~(XRCM_CACHE);        // Can't make any use of cache

  if (rc->p_xd_data && (rc->f_xd_data & XRLV_DATA_USE)) // Use previously saved status?
   {
    ext_data_used    = 1;
    xd = (p_xrlv_data_type)rc->p_xd_data;
    xd->rc           = rc;
    xd->xrdata       = xrdata;
   }
   else    // Init everything anew
   {
    ext_data_used    = 0;
    if (XrlvAlloc(&xd, xrdata, rc)) goto err;


    XrlvGetCharset(xd);

    #ifndef LSTRIP
    xd->xrcm->flags |= XRMC_DISABLECAPBITS; // Disregard caps bits var masking
//    xd->xrcm->flags &= ~(XRMC_DISABLEON7);  // Allow '7' corr -- or can't learn
    xd->self_weight  = xd->xrcm->self_weight;
    #else
    xd->self_weight  = XRMC_CONST_CORR + xrdata->len*LSTRIP_CORR_CONST;
    #endif

    xd->vs.flags     = 1;
    xd->vs.charset   = xd->rc->alpha_charset;
    xd->vs.lpunct    = xd->rc->lpunct_charset;
    xd->vs.epunct    = xd->rc->epunct_charset;

    /* ------ Init starting sources ------------------------------------------ */

    HWRMemSet(&xd->pxrlvs[0]->buf[0], 0, sizeof(xd->pxrlvs[0]->buf[0]));

    xd->pxrlvs[0]->gw   = xd->init_weight = XRLV_INITIAL_WEIGHT;
    xd->pxrlvs[0]->buf[0].sw = XRLV_INITIAL_WEIGHT;
    xd->pxrlvs[0]->nsym_c = 1;
   }

 /* ------ Begin operations ----------------------------------------------- */

  P_XRLV_2

// ------------ Main Positions cycle ------------------------------------------

//PegFileDebugPrintf(L"Xrlv: Npos: %d", xd->npos);

  for (xd->pos; xd->pos < xd->npos; xd->pos ++)
   {

    if (rc->pFuncYield) if ((*rc->pFuncYield)(rc->FY_param)) {er = XRLV_YIELD_BREAK; goto done;}

//  PegFileDebugPrintf(L"Xrlv: Pos: %d, Nsym_c %d, Nsym_v %d", xd->pos, xd->pxrlvs[xd->pos]->nsym_c, xd->pxrlvs[xd->pos]->nsym_v);

    P_XRLV_3

    XrlvTrimXrlvPos(xd->pos, xd);
    XrlvSortXrlvPos(xd->pos, xd);
    XrlvCHLXrlvPos(xd->pos, xd);
    XrlvSortXrlvPos(xd->pos, xd);

//  PegFileDebugPrintf(L"Xrlv: Pos: %d, Nsym %d", xd->pos, xd->pxrlvs[xd->pos]->nsym);
/*
    if (xd->pos && xd->pos-1+xd->n_real_pos < xd->npos) // Recycle prev pos
     {
      xd->pxrlvs[xd->pos-1+xd->n_real_pos] = pxl = xd->pxrlvs[xd->pos-1];
      xd->pxrlvs[xd->pos-1] = _NULL;
      pxl->min_w_loc_v = xd->nloc_c;
      pxl->gw = pxl->min_w_v = pxl->n_put = pxl->nsym_v = 0;
      pxl->min_w_c = pxl->min_w_loc_c = pxl->nsym_c = pxl->nsym = 0;
      HWRMemSet(pxl->nn_weights, 128, sizeof(pxl->nn_weights));
     }
*/
    P_XRLV_3_5

    XrlvNNXrlvPos(xd->pos, xd);

    P_XRLV_4

    #if PG_DEBUG_LOCAL && defined DEBUG_PRINT_SYM_BUF
    XrlvPrintXrlvPos(xd->pos, xd);
    #endif // PG_DEBUG_LOCAL

    if (xd->pos < xd->npos-1)
     {
      XrlvGuessFutureGws(xd->pos, xd);
      XrlvDevelopPos(xd->pos, xd); // <<<----------------------
     }

    P_XRLV_5
   }

// ------------ Main Positions cycle ends -------------------------------------

  BearAddSegCol (rc, xd);

#ifdef TRAINTIME_BEAR
	//XRLVTune (pri, rc, xd);
	SavePrototypes (pri, rc, xd);	
#endif

  // resort again in case BearAddSeg changes the order of cells
  XrlvSortXrlvPos(xd->pos - 1, xd);

  P_XRLV_6

  XrlvFreeSomePos(xd);

  /* ------ Create answers from graph -------------------------------------- */

//  XrlvCreateAnswers(XRLV_INITIAL_WEIGHT, xd);
  XrlvSortAns(pri, xd);
  XrlvCleanAns(xd);
  if (XrlvCreateRWG(rwg, xd)) goto err;
//  XrlvGetRwgSrcIds(rwg, xd);

  P_XRLV_7

  P_XRLV_8


  /* ------ Closing down --------------------------------------------------- */

done:
  rc->corr_mode = xrwm;
  rc->caps_mode = m_cm;
  rc->enabled_cs= m_cs;

//  if (!((rc->f_xd_data & XRLV_DATA_SAVE) && xd->pos < xd->npos)) XrlvDealloc(&xd);//
//   else if (rc->p_xd_data == _NULL) rc->p_xd_data = xd; // If there is something -- do not touch it!

  if (er == XRLV_YIELD_BREAK && (rc->f_xd_data & XRLV_DATA_SAVE) && 
     (rc->p_xd_data == _NULL || ext_data_used)) // If there is something diff -- do not touch it! 
    rc->p_xd_data = xd; 
   else 
   {
    if (ext_data_used) rc->p_xd_data = _NULL; // Started with this data, and freeing it
    XrlvDealloc(&xd); 
   }

   return er;

err:
  rc->corr_mode = xrwm;
  rc->caps_mode = m_cm;
  rc->enabled_cs= m_cs;

  if (ext_data_used) rc->p_xd_data = _NULL; // Started with this data, and freeing it

  XrlvDealloc(&xd);

  return 1;
 }

/* ************************************************************************* */
/* *  Develop next XRLV position                                           * */
/* ************************************************************************* */
_INT XrlvDevelopPos(_INT pos, p_xrlv_data_type xd)
{
	_INT                     i, n;
	_INT                     cloc;
	_INT                     caps_cnt, cc, penl, p, cv;
	_INT                     cmode = xd->caps_mode;
	_INT                     link_pos, seg_pos;
	p_xrcm_type              xrcm  = xd->xrcm;
	p_xrlv_var_data_type_array cxrlv;
	p_xrlv_cache_type        pc;
	xrlv_var_data_type       xv;
	p_xrlv_var_data_type     xlv;
	p_UCHAR                  po = xd->order;
	_UCHAR					 iSpcCost, iNotSpcCost, iSpcNetOut;

	cxrlv = xd->pxrlvs[pos];
	cloc  = xd->unlink_index[pos];
#ifndef LSTRIP
	xrcm->src_pos = cloc;
	SetInpLineByValue(XRMC_CONST_CORR, cloc, 3, xrcm);
	xrcm->src_pos = cloc;
	xrcm->cmode = XCM_AL_DEFSIZE;
#endif

	caps_cnt = 0;
	if ((cmode & XCM_FL_TRYCAPSp)) caps_cnt = 1;
	if ((cmode & XCM_AL_TRYCAPSp)) caps_cnt = 1;
	if (!(IS_CLEAR_LINK((*xd->xrdata->xrd)[xd->unlink_index[pos]].xr.type))) caps_cnt = 0;

	penl        = WSF_GET((*xd->xrdata->xrd)[xd->unlink_index[pos]].xr.attrib);

	iSpcNetOut	= (*xd->xrdata->xrd)[xd->unlink_index[pos]].xr.iSpc;
	iSpcCost	= ((200 - iSpcNetOut) / 20);
	iNotSpcCost	= (iSpcNetOut / 20);

	link_pos    = (pos == 0 || xd->link_index[xd->unlink_index[pos]]);
	seg_pos     = link_pos && penl;

	for (i = 0, pc = &(xd->cache[0]); i < XRLV_SYMCORR_CACHE_SIZE; i ++, pc ++) pc->flags = 0;

	for (n = 0; n < cxrlv->nsym; n ++) // Step thru all pos parents ...
	{
		xlv = &cxrlv->buf[po[n]];
		
		if (pos && xlv->sd.l_status < XRWD_BLOCKEND)  // Continue source itself
		{
			xv    = *xlv;
			xv.np = (_UCHAR)n;
			xv.st = (_UCHAR)pos;
			cc = caps_cnt; if (!(cmode & XCM_AL_TRYCAPSp)) cc = 0;
			XrlvDevelopCell(pos, cc, 0, &xv, xd);
		}

		if (pos == 0 || iSpcNetOut > 20)  
		{
			xv = *xlv;

			XrlvCheckDictCap(&xv, xd); // Work with dictionary capitalization flags

			XrlvApplyWordEndInfo(pos, &xv, xd);

			xv.np = (_UCHAR)n;
			xv.st = (_UCHAR)pos;

			HWRMemSet(&xv.sd, 0, sizeof(xv.sd));
			xv.sd.l_status = XRWD_INIT;
			xv.wlen        = 0;
			xv.flags       = 0;
			xv.sym_type    = 0;
			xv.nwords ++;

			if (pos)
			{
				xv.word[xv.len] = ' ';
				if (xv.len < XRLV_ANSW_MAX_LEN-2) 
				{
					xv.len ++;
				}
			}

			p	=	iSpcCost;

			if (p < 0 || pos == 0) 
			{
				p = 0;
			}

			if (xd->xrwm & XRWM_VOC)
			{
				if (xv.nwords > 1) 
				{
					cv= 0; 
				}
				else 
				{
					cv = XRLV_DICT_STREWARD; 
					xv.flags |= XRLV_DICT_STREWARDED;
				}

				xv.source = (XRWD_SRCID_VOC);
				XrlvDevelopCell(pos, caps_cnt, p-cv, &xv, xd);

				xv.source = (XRWD_SRCID_USV);
				XrlvDevelopCell(pos, caps_cnt, p-cv, &xv, xd);

				xv.flags &= ~(XRLV_DICT_STREWARDED);
			}

			if (xd->xrwm & XRWM_CS)
			{
				if (!(xlv->source & XRWD_SRCID_CS) || penl == WS_SEGM_NOSP)
				{
					xv.source = (_UCHAR)((xd->xrwm & XRWM_TRIAD) ? (XRWD_SRCID_CS | XRWD_SRCID_TR) : (XRWD_SRCID_CS));
					XrlvDevelopCell(pos, caps_cnt, p, &xv, xd);
				}
			}

			if (xd->xrw_cs & CS_LPUNCT)
			{
				xv.source = (XRWD_SRCID_SPT);       // Start punctuation
				XrlvDevelopCell(pos, caps_cnt, p, &xv, xd);
			}
		}

		// Start Voc and LD from starting punct
		if (pos && xlv->sd.l_status == XRWD_INIT && xlv->source == XRWD_SRCID_SPT)
		{
			xv = *xlv;
			xv.wlen  = 0;
			xv.flags = 0;
			xv.np = (_UCHAR)n;
			xv.st = (_UCHAR)pos;

			p	  = iNotSpcCost;

			if ((cmode & XCM_FL_TRYCAPSp)) cc = 1; else cc = caps_cnt;

			if (xd->xrwm & XRWM_VOC)
			{                                   // Start distinction between CS and VOC
				if (xv.nwords > 1) 
				{
					cv= 0; 
				}
				else 
				{
					cv = XRLV_DICT_STREWARD; 
					xv.flags |= XRLV_DICT_STREWARDED;
				}

				xv.source = (XRWD_SRCID_VOC);
				XrlvDevelopCell(pos, cc, p-cv, &xv, xd);
				xv.source = (XRWD_SRCID_USV);
				XrlvDevelopCell(pos, cc, p-cv, &xv, xd);

				xv.flags &= ~(XRLV_DICT_STREWARDED);
			}
		}

		// Ending punct for voc/ld
		if ((xd->xrw_cs & CS_EPUNCT) && (pos == 0 || (xlv->sd.l_status >= XRWD_WORDEND &&
			(xlv->source == XRWD_SRCID_VOC || xlv->source == XRWD_SRCID_USV))))
		{
			xv = *xlv;
			xv.np = (_UCHAR)n;
			xv.st = (_UCHAR)pos;

			p	=	iNotSpcCost;

			XrlvCheckDictCap(&xv, xd);

			XrlvApplyWordEndInfo(pos, &xv, xd);

			xv.source = (XRWD_SRCID_EPT);
			XrlvDevelopCell(pos, caps_cnt, p, &xv, xd);
		}

		// Suffixes for voc
		if (xlv->sd.l_status >= XRWD_WORDEND && xlv->wlen > 2 &&
			(xlv->source == XRWD_SRCID_VOC || xlv->source == XRWD_SRCID_USV))
		{
			xv      = *xlv;
			xv.np   = (_UCHAR)n;
			xv.st   = (_UCHAR)pos;
			xv.wlen = 0;
			p		= iNotSpcCost;

			cc = caps_cnt; if (!(cmode & XCM_AL_TRYCAPSp)) cc = 0;

			XrlvCheckDictCap(&xv, xd);
			XrlvApplyWordEndInfo(pos, &xv, xd); // Do we attribute not finished words ?-- Word did not end!!!

			xv.sd.l_status = XRWD_INIT;
		}

	} // Step thru parents cycle end

	return 0;
}

/* ************************************************************************* */
/* *  Develop one cell                                                     * */
/* ************************************************************************* */
_INT XrlvDevelopCell(_INT pos, _INT caps_cnt, _INT penl, p_xrlv_var_data_type pxl, p_xrlv_data_type xd)
{
	_INT                     i, j, k, ns, bad;
	_INT                     loc, cloc, fbn;
	_INT                     link_pos;
	_INT                     w, iProtoCorr, symw, sym;
	//  _INT                     min_w_loc, min_w;
	_INT                     bd = xd->bad_dist;
	_INT                     bd2 = bd+bd/4;
	_INT                     iLexPenalty, iOtherPenalties, trnp, iSNNPenalty, sepp;
	_INT					 iXRNetScore;
	_UCHAR                   let, sym_type, l_status;
	p_xrcm_type              xrcm  = xd->xrcm;
	p_fw_buf_type            fbp;
	p_xrlv_var_data_type     pbp, pbt;
	p_xrlv_var_data_type_array pb; //, cxrlv;
	p_xrlv_var_data_type_array xlvc = xd->pxrlvs[pos];
	p_xrlv_cache_type        pc;
	_UCHAR xrlv_transitions[7][7] = {// 0 1 2 3 4 5 6 -- Cur sym types
		{0,2,0,0,0,0,0}, // 0 - Undef, initial
		{0,1,2,2,1,0,3}, // 1 - CS Punctuation (non sym-digit)
		{0,2,0,4,3,2,2}, // 2 - CS Lower Sym
		{0,2,1,0,3,2,2}, // 3 - CS Upper sym
		{0,2,4,4,0,2,1}, // 4 - CS Digit
		{0,2,2,2,2,0,3}, // 5 - Voc/Ld Symbols (any)
		{0,3,2,2,1,3,1}  // 6 - Math operations
	};

	if ((pxl->source != XRWD_SRCID_VOC) && (pxl->source != (XRWD_SRCID_CS | XRWD_SRCID_TR)))
	{
		//ASSERT (!(pxl->source & XRWD_SRCID_VOC));
		return 0;
	}

	cloc = xd->unlink_index[pos];

#ifndef LSTRIP
	for (i = cloc, link_pos = 0; i >= 0; i --)
	{if (IsXrLink(&(*xd->xrdata->xrd)[i])) link_pos = 1; if (!GetXrMovable(&(*xd->xrdata->xrd)[i])) break;}

	xrcm->en_ww = xd->rc->enabled_ww;
	if (!link_pos) xrcm->en_ww &= ~(WW_BLOCK | WW_GENERAL); // Only letters are allowed to be connected
#else
	if (IsXrLink(&(*xd->xrdata->xrd)[cloc])) link_pos = 1; else link_pos = 0;
#endif


	if (pxl->source & (XRWD_SRCID_VOC)) sym_type = 5;
	else sym_type = 0;

	fbn = XrlvGetNextSymbols(pxl, caps_cnt, xd);

	//PegFileDebugPrintf(L"Xrlv: Cell: fbn: %d",fbn);

	for (ns = 0; ns < fbn; ns ++)
	{
		fbp = &((*xd->fbuf)[ns]);

		let = fbp->sym;

		if (isspace1252 (let))
		{
			continue;
		}

		//  PegFileDebugPrintf(L"Xrlv: Cell: Let: %c", let);

		if (xlvc->nn_weights[let])
		{
			if (pxl->source & XRWD_SRCID_VOC)
			{if ((_INT)xlvc->nn_weights[let] < 100-xd->bad_dist*4) continue;} // Voc symbol with bad nn gross weight
			else {if ((_INT)xlvc->nn_weights[let] < 160-xd->bad_dist*4) continue;} // Non-voc symbol with bad nn gross weight
		}

		//  PegFileDebugPrintf(L"Xrlv: Cell: Let: %c, NN W: %d", let, (int)xlvc->nn_weights[let]);

		sym = OSToRec(let)-DTI_FIRSTSYM; if (sym < 0 || sym > XRLV_SYMCORR_CACHE_SIZE) continue;
		pc = &(xd->cache[sym]);

		//    if ((pxl->source & (XRWD_SRCID_VOC) && (pc->flags & XRLV_CACHE_EL_BAD)) continue; // Proven to be bad on previous steps
		if (sym_type == 5) {if (pc->flags & XRLV_CACHE_EL_VBAD) continue;} // Proven to be bad on previous steps
		else {if (pc->flags & XRLV_CACHE_EL_CBAD) continue;} // Proven to be bad on previous steps

		if (!(IsLower(let) || let == '\'') && !link_pos) continue; // Only letters are allowed to be connected

		//  PegFileDebugPrintf(L"Xrlv: Cell: Flags: %d", (int)pc->flags);

		P_XRLV_C_1

		if (!(pc->flags & XRLV_CACHE_EL_SET)) // Fill cache if needed
		{
			pc->st    = 0;   // Mark as unset

			pc->flags = XRLV_CACHE_EL_SET;

#ifndef LSTRIP
			xrcm->sym = let;
			if (CountSym(xrcm) == 0)
			{
				pc->st  = (_UCHAR)xrcm->v_start; if (pc->st == 0) pc->st = 1;
				pc->end = (_UCHAR)xrcm->v_end;
				if (pc->end - pc->st > XRLV_CACHE_LEN) pc->end = (_UCHAR)(pc->st + XRLV_CACHE_LEN);
				for (i = pc->st, j = 0; i < pc->end; i ++, j ++)
				{pc->mbuf[j] = (_UCHAR)(((w = (*xrcm->s_out_line)[i]) >= 0) ? w:0); pc->nvars[j] = xrcm->nvar_vect[i];}
			}
#else
			pc->st  = (_UCHAR)cloc; if (pc->st == 0) pc->st = 1;
			pc->end = (_UCHAR)(pc->st + XRLV_CACHE_LEN);
			for (i = pc->st, j = 0; i < pc->end; i ++, j ++)
			{pc->mbuf[j] = (_UCHAR)(XRMC_CONST_CORR+j*LSTRIP_CORR_CONST); pc->nvars[j] = 0;}
#endif
		}

		P_XRLV_C_2

			//  PegFileDebugPrintf(L"Xrlv: Cell: St: %d", (int)pc->st);

			if (pc->st == 0) continue; // Symbol was unset

		l_status = (_UCHAR)(fbp->l_status & 0x0F);

		loc  = (cloc > pc->st) ? cloc : pc->st;
		//    attr = (l_status >= XRWD_WORDEND) ? fbp->attribute : 0;

		if (sym_type != 5) // Not voc or LD
		{
			if (IsLower(let)) sym_type = 2;
			else if (IsUpper(let)) sym_type = 3;
			else if (IsDigit(let)) sym_type = 4;
			else if (HWRStrChr((_STR)xd->rc->math_charset, let) != 0) sym_type = 6;
			//                       else if (let == '+' || let == '=' ||
			//                                let == '*' || let == '/' ||
			//                                let == '@' || let == '(' || let == ')') sym_type = 6;
			else sym_type = 1;
		}

		trnp = xrlv_transitions[pxl->sym_type][sym_type];
		sepp = ((link_pos) ? 0 : ((pxl->source&XRWD_SRCID_VOC) ? XRLV_SEP_PENL_V:XRLV_SEP_PENL_O));

		for (i = loc, bad = 1; i < pc->end; i ++)
		{
			if ((loc = xd->link_index[i]) <= pos) 
			{
				continue;
			}

			if ((pb = xd->pxrlvs[loc]) == _NULL) 
			{
				break; // Pos not init yet!
			}

			// The correlation with the prototype database
			iProtoCorr			= (_INT)(pc->mbuf[i - pc->st]) - XRMC_CONST_CORR;

			// The XR net score
			if (((loc - pos - 1) < MAX_LANDING_POS) && ((loc - pos - 1) >= 0))
			{
				iXRNetScore			=	xd->aXRNetScore[loc - pos - 1][let];
			}
			else
			{
				iXRNetScore			=	0;
			}

			// Other penalties
			iOtherPenalties		=	penl + sepp;

			// lexicon penalty
			iLexPenalty			= trnp + ((fbp->penalty * (i-cloc) + 2) >> 2);

			// SNN penalty
			iSNNPenalty			= (_INT)pb->nn_weights[let] - 128;
			
			// sum up the scores
#ifdef FOR_ENGLISH
			symw = (int)	(	(0.5723 * iProtoCorr)
								+ (0.0201 * iXRNetScore) 
								- (1.6915 * iSNNPenalty)
								- (2.2485 * iOtherPenalties)
								- (1.6915 * iLexPenalty)
							);

#else
			symw = (int)	(	(0.3385 * iProtoCorr)
								+ (0.0167 * iXRNetScore)
								- (1.8379 * iSNNPenalty)
								- (2.7537 * iOtherPenalties)
								- (1.1162 * iLexPenalty)
							);
#endif
			w = pxl->sw + symw;

			if (w > ((sym_type == 5) ? pb->min_w_v : pb->min_w_c)) // w > pb->gw - bd &&
			{
				bad = 0;

				pbp  = &(pb->buf[((sym_type == 5) ? pb->min_w_loc_v : pb->min_w_loc_c)]);
				*pbp = *pxl;

				pbp->sym				= let;
				pbp->nvar				= pc->nvars[i - pc->st];
				pbp->sym_type			= (_UCHAR)sym_type;
				pbp->w					= (_SHORT)iProtoCorr;
				pbp->sw					= (_SHORT)(w);
				pbp->lexp				= (_SHORT)iLexPenalty;
				pbp->othp				= (_SHORT)iOtherPenalties;
				pbp->ppw				= (_SHORT)iSNNPenalty;
				pbp->iXRScore			= (_SHORT)iXRNetScore;
				pbp->flags				|= (_UCHAR)(fbp->l_status & XRLV_DICT_FL_CAP);

				pbp->sd					= *fbp;
				//        pbp->sd.state       = fbp->state;
				//        pbp->sd.attribute   = (_UCHAR)attr;
				//        pbp->sd.chain_num   = fbp->chain_num;
				pbp->sd.l_status    = l_status;

				pbp->word[pbp->len] = let;
				pbp->symw[pbp->len] = (_SCHAR)symw;
				pbp->nvps[pbp->len] = (_UCHAR)(((pbp->nvar)<<4)|(loc-pos));
				if (pbp->len < XRLV_ANSW_MAX_LEN-2) {pbp->wlen ++;pbp->len ++;}

				// ---------------- Let's find next lowest location --------------------

				if (sym_type == 5)      // Dict / Ld continuation
				{
					if (pb->min_w_v < pb->gw-bd2) pb->min_w_v = pb->gw-bd2;
					if (pb->min_w_v < w-bd2) pb->min_w_v = w-bd2;

					if (pb->nsym_v < xd->nloc_v) pb->nsym_v ++;
					if (pb->nsym_v < xd->nloc_v) pb->min_w_loc_v = xd->nloc_c+pb->nsym_v; // Is there free space ?
					else                   // Need to remove some cell
					{
						for (j = k = 0, pbt = &(pb->buf[xd->nloc_c]), w = pbt->sw; j < pb->nsym_v; j ++, pbt ++)
							if (pbt->sw < w) {w = pbt->sw; k = j;}

							pb->min_w_loc_v = k+xd->nloc_c;
							if (pb->min_w_v < w) pb->min_w_v = w;
					}
				}
				else
				{
					if (w > pb->gw) {pb->gw = w; if (pb->min_w_c < w-bd2) pb->min_w_c = w-bd2;}

					if (pb->nsym_c < xd->nloc_c) pb->nsym_c ++;
					if (pb->nsym_c < xd->nloc_c) pb->min_w_loc_c = pb->nsym_c; // Is there free space ?
					else                   // Need to remove some cell
					{
						for (j = k = 0, pbt = &(pb->buf[0]), w = pbt->sw; j < pb->nsym_c; j ++, pbt ++)
							if (pbt->sw < w) {w = pbt->sw; k = j;}

							pb->min_w_loc_c = k;
							if (pb->min_w_c < w) pb->min_w_c = w;
					}
				}

				pb->n_put ++;
			}
		}
		// Not saved even single time -- bad!
		if (bad) {if (sym_type == 5) pc->flags |= (XRLV_CACHE_EL_VBAD | XRLV_CACHE_EL_CBAD); else pc->flags |= XRLV_CACHE_EL_CBAD;}
	} // ----------------- fbuf symbols cycle end -------------------------

	return 0;
}

/* ************************************************************************* */
/* *  Sort xrlv pos                                                        * */
/* ************************************************************************* */
_INT XrlvSortXrlvPos(_INT pos, p_xrlv_data_type xd)
 {
  _INT                       i, j, all_sorted;
  p_xrlv_var_data_type       xc, xp;
  _UCHAR                     pel;
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[pos];
  p_UCHAR                    po = xd->order;
  _INT                       bd = xd->bad_dist;

//  if (xlv->nsym == 0) xlv->nsym = ((xlv->nsym_c) ? xd->nloc_c : 0) + xlv->nsym_v;
  xlv->nsym = xlv->nsym_c + xlv->nsym_v;

  for (i = j = 0; i < xlv->nsym_c; i ++, j ++) po[j] = (_UCHAR)i;
  for (i = 0; i < xlv->nsym_v; i ++, j ++) po[j] = (_UCHAR)(i+xd->nloc_c);

  all_sorted = 0;
  while (!all_sorted)
   {
    for (i = 1, all_sorted = 1; i < xlv->nsym; i ++)
     {
      xp = &xlv->buf[po[i-1]];
      xc = &xlv->buf[po[i]];

      if (xc->sw > xp->sw)
       {
        pel     = po[i-1];
        po[i-1] = po[i];
        po[i]   = pel;

        all_sorted = 0;
       }
     }
   }

// -------------- Trim position ----------------------------------

  for (i = 0; i < xlv->nsym; i ++)
   {
    if (xlv->buf[po[i]].sw < xlv->gw - bd) break;
   }
  xlv->nsym = i;

//  if (xlv->buf[po[0]].sw < xlv->gw) xlv->gw = xlv->buf[po[0]].sw;
//  if (xlv->buf[po[0]].sw > xlv->gw) xlv->gw = xlv->buf[po[0]].sw;

  return 0;
 }

/* ************************************************************************* */
/* *  Cut position cell based on distance from leader                      * */
/* ************************************************************************* */
_INT XrlvTrimXrlvPos(_INT pos, p_xrlv_data_type xd)
 {
  _INT                       n;
  _INT                       bd = xd->bad_dist;
  _INT                       bd23 = 3*bd/4;
  p_UCHAR                    po = xd->order;
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[pos];

//  if (xlv->nsym < 2) goto err;

// -------------- Save last dying CS location -------------------
#if 0
  for (i = nc = w = 0; i < xlv->nsym; i ++)
    if (xlv->buf[po[i]].source & XRWD_SRCID_CS)
     {if (w < xlv->buf[po[i]].sw) {nc = i; w = xlv->buf[po[i]].sw;}}

                 // If getting bad, limit source penalty
  if (nc && w < xlv->gw - 2*bd/3)
   {
    i = po[nc];
    a = xlv->buf[i].symw[xlv->buf[i].len-1] + (_SCHAR)xlv->buf[i].iLexPenalty;
    if (a > 127) a = 127;
    xlv->buf[i].symw[xlv->buf[i].len-1] = (_SCHAR)a;
    xlv->buf[i].sw += xlv->buf[i].iLexPenalty;
   }
//#else

  nc = 0;
  if (!(xlv->buf[po[0]].source & XRWD_SRCID_CS)) // if leader is not CS already!
   {
    for (i = w = 0; i < xlv->nsym; i ++)
      if (xlv->buf[po[i]].source & XRWD_SRCID_CS)
       {if (w < xlv->buf[po[i]].sw) {nc = i; w = xlv->buf[po[i]].sw;}}

    if (w && w < xlv->gw - bd23) // If getting too bad, return  source penalty
     {
      for (i = 0; i < xlv->nsym; i ++)
       {
        xv = &(xlv->buf[po[i]]);
        if ((xv->source & XRWD_SRCID_CS))
         {
          a = xv->symw[xv->len-1] + (_SCHAR)xv->iLexPenalty; if (a > 127) a = 127;
          xv->symw[xv->len-1] = (_SCHAR)a;
          xv->sw += xv->iLexPenalty;
         }
       }
     }
   }
#endif

// -------------- Trim position ----------------------------------

//  for (n = 0; n < xlv->nsym; n ++)
//   {
//    if (xlv->buf[po[n]].sw < xlv->gw - bd)
//     {
//      if (nc >= n) {po[n] = po[nc]; n ++;}
//      break;
//     }
//   }
//
//  xlv->nsym = n;

// -------------- Zero cells below min level ---------------------

  for (n = 0; n < xd->nloc_c; n ++)
    if (xlv->buf[n].sw < xlv->min_w_c) xlv->buf[n].sw = 0;

  for (n = xd->nloc_c; n < xlv->nsym; n ++)
    if (xlv->buf[n].sw < xlv->min_w_c) xlv->buf[n].sw = 0;

// -------------- Trim CS records --------------------------------

//  i = xd->nloc/8;
//  for (n = nc = 0; n < xlv->nsym; n ++)
//   {
//    if ((xlv->buf[po[n]].source & XRWD_SRCID_VOC) == 0)
//     {
//      nc ++;
//      if (nc > i)                            // Remove extra CS records
//       {
//        HWRMemCpy(&po[n], &po[n+1], sizeof(*po)*(xlv->nsym-n));
//        xlv->nsym--;
//        n --;
//       }
//     }
//   }

  return xlv->nsym;
 }

/* ************************************************************************* */
/* *  Set GWs for future positions                                         * */
/* ************************************************************************* */
_INT XrlvGuessFutureGws(_INT pos, p_xrlv_data_type xd)
 {
  _INT  i, p, w, bw;
  _INT  bd;
  p_xrlv_var_data_type_array xlv;

//  p = 0;
  p  = xd->bad_dist/8;
  w  = xd->pxrlvs[pos]->gw;
  bw = (xd->pxrlvs[pos]->nsym_c > 0) ? xd->pxrlvs[pos]->buf[0].sw : 0;
//  bd = xd->bad_dist + xd->bad_dist/4;
  bd = xd->bad_dist + p;
//  pp = pos;
                                             // Set standarts for the future
  for (i = pos+1; (xlv = xd->pxrlvs[i]) != _NULL && i < xd->npos; i ++)
   {
//    for (j = xd->unlink_index[pp]+1, p = 0; j <= xd->unlink_index[i]; j ++)
//      p += (*xd->xrdata->xrd)[j].xr.penalty;

    if (xlv->gw < w-p) xlv->gw = w-p;
    if (xlv->gw > w) w = xlv->gw;

    if (xlv->min_w_c < w - bd) xlv->min_w_c  = w - bd;
    if (xlv->min_w_v < w - bd) xlv->min_w_v  = w - bd;
    if (xlv->min_w_v < bw - bd) xlv->min_w_v = bw - bd;

//    pp = i;
   }


  return i;
 }

/* ************************************************************************* */
/* *  Apply boxes&vector information to Xrlv position                      * */
/* ************************************************************************* */
_INT XrlvCHLXrlvPos(_INT pos, p_xrlv_data_type xd)
 {
  _INT                       i;
  _INT                       st, end;
  _INT                       dy, a, w;
  _INT                       bx = xd->rc->stroka.box.left;
  _INT                       p, base, pc, prev, pprev;
  _INT                       pBaseLine; //CHE exp.
  _INT                       sizea, sizeb;
  _INT                       kmin, kmax, R, bord_dn_pos, bpos, size;
  _INT                       pvmax, pvmin, cvmax, cvmin;
  _INT                       ztc, ztp, ztpp, zbc, zbp, zbpp;
  _RECT                      boxpp, boxp, boxc;
  _INT                       chltc, chltp, chltpp;
  p_xrlv_var_data_type       xc; //, xp;
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[pos];
  p_dti_descr_type           dtp = (p_dti_descr_type)xd->rc->dtiptr;


  if (xlv->nsym_v + xlv->nsym_c == 0) goto err;
  if (pos == 0)       goto err; // Temp until prev context available

// -------------- Let's find best sw val for later gw correction -------

//  for (i = 0, xv1 = &xlv->buf[0], lgw = xv1->sw; i < xlv->nsym; i ++, xv1 ++)
//    if (lgw < xv1->sw) lgw = xv1->sw;

// ------------------ Get dn bord position -------------------------------------

  a = GetBaseBord(xd->rc);

  bord_dn_pos = bpos = size = 0; // AVP: size init to 0

  if (xd->rc->stroka.size_out && xd->rc->stroka.pos_sure_out >= 70)
   {
    size = 2*xd->rc->stroka.size_out; // Eto 10*sz/5 -- razmer iacheiki
    bpos = 10*xd->rc->stroka.dn_pos_out;
   }
   else
   {
    if (xd->rc->stroka.size_in && xd->rc->stroka.pos_sure_in >= 70)
     {
      size = 2*xd->rc->stroka.size_in; // Eto 10*sz/5 -- razmer iacheiki
      bpos = 10*xd->rc->stroka.dn_pos_in;
     }
   }

  if (bpos)
   {
    dy = a*(((bx + xd->rc->stroka.box.right)/2) - bx)/128;
    bord_dn_pos = bpos - dy;
   }

// ---------------------- Fill boxes to new pos --------------------------------

//  cutoff = xlv->gw - (xd->bad_dist+xd->bad_dist/4);

  for (i = 0; i < xlv->nsym; i ++)
   {
//    xc  = &xlv->buf[i];
    xc = &xlv->buf[xd->order[i]];
//    if (xc->sw < cutoff) break; // Too bad to bother
//    if (xc->len < 2) continue;  // Can't operate on on symbol only!

    p = 0;
    chltc = chltp = chltpp = 0;

    xc->boxp = 0;
    st  = xd->unlink_index[xc->st]+1;
    end = xd->unlink_index[pos];
    ztc = ztp = bord_dn_pos-size;
    zbc = zbp = bord_dn_pos;

    if (GetSymBox(xc->sym, st, end+1, xd->xrdata, &boxc) == 0)
     {
      dy = a*(((boxc.right+boxc.left)/2) - bx)/128;
      boxc.top -= (_SHORT)dy; boxc.bottom -= (_SHORT)dy;

      chltc = GetVarPosSize(xc->sym, xc->nvar, dtp);
      ztc   = (_SHORT)(boxc.top + ((boxc.bottom-boxc.top)*((chltc>>4)&0x000F))/16);
      zbc   = (_SHORT)(boxc.top + ((boxc.bottom-boxc.top)*(((chltc>>0)&0x000F)+1))/16);
     }

    if (xc->len > 1)
     {
      prev  = xc->len-2;
      if (xc->nvps[prev] == 0) prev --;

      if (prev >= 0)
       {
        st  = xd->unlink_index[xc->st - (xc->nvps[prev]&0x0f)]+1;
        end = xd->unlink_index[xc->st];

        if (GetSymBox(xc->word[prev], st, end+1, xd->xrdata, &boxp) == 0)
         {
          dy = a*(((boxp.right+boxp.left)/2) - bx)/128;
          boxp.top -= (_SHORT)dy; boxp.bottom -= (_SHORT)dy;

          chltp = GetVarPosSize(xc->word[prev], (_UCHAR)(xc->nvps[prev]>>4), dtp);
          ztp   = (_SHORT)(boxp.top + ((boxp.bottom-boxp.top)*((chltp>>4)&0x000F))/16);
          zbp   = (_SHORT)(boxp.top + ((boxp.bottom-boxp.top)*(((chltp>>0)&0x000F)+1))/16);
         }
       }

      if (prev > 0)
       {
        pprev  = prev-1;
        if (xc->nvps[pprev] == 0) pprev --;

        if (pprev >= 0)
         {
          end = xc->st - (xc->nvps[prev]&0x0f);
          st  = xd->unlink_index[end - (xc->nvps[pprev]&0x0f)]+1;
          end = xd->unlink_index[end];

          if (GetSymBox(xc->word[pprev], st, end+1, xd->xrdata, &boxpp) == 0)
           {
            dy = a*(((boxpp.right+boxpp.left)/2) - bx)/128;
            boxpp.top -= (_SHORT)dy; boxpp.bottom -= (_SHORT)dy;

            chltpp = GetVarPosSize(xc->word[pprev], (_UCHAR)(xc->nvps[pprev]>>4), dtp);
            ztpp   = (_SHORT)(boxpp.top + ((boxpp.bottom-boxpp.top)*((chltpp>>4)&0x000F))/16);
            zbpp   = (_SHORT)(boxpp.top + ((boxpp.bottom-boxpp.top)*(((chltpp>>0)&0x000F)+1))/16);
           }
         }
       }
     }
     else // Count fiction prev box based on corrector border
     {
      if (xd->rc->stroka.size_in && xd->rc->stroka.pos_sure_in == 100 && 
          xd->rc->stroka.size_sure_in == 100)
       {
        boxp  = boxc;
        boxp.bottom = xd->rc->stroka.dn_pos_in;
        boxp.top    = (_SHORT)(boxp.bottom - xd->rc->stroka.size_in);
        chltp = 0x2a5778; // Magic value of 'a' chlt on 7-30-96.
        ztp   = (_SHORT)(boxp.top + ((boxp.bottom-boxp.top)*((chltp>>4)&0x000F))/16);
        zbp   = (_SHORT)(boxp.top + ((boxp.bottom-boxp.top)*(((chltp>>0)&0x000F)+1))/16);
       }
     }

//
  // ----------- CHE: Let's check box x-relative positions  -----------
#if 0
    if (xc->len > 1 && chltc && chltp) //there is prev symbol, and it's box is calculated
     {
       pc = GetXOverlapPenalty( xc->sym, xc->word[prev], &boxc, &boxp );

       p += pc;
       xc->boxp |= (_USHORT)(pc << 12);
     }
#endif
  // -------------- Let's check box relative positions  ---------------

    if (chltc && chltp)
     {
      _INT dy_gap  = (boxc.bottom - boxc.top);
      _INT dy_pgap = (boxp.bottom - boxp.top);

  //    base = ((boxp.bottom - boxp.top) + (boxc.bottom - boxc.top))/2;
      base = (2*HWRMax(dy_gap,dy_pgap) + HWRMin(dy_gap,dy_pgap) + 1) / 3;

      if (base < 20) base = 20; // Arbitrary limit ... check this later ...

      pc = 0;

      if (ztp > zbc) // Prev lower than current
       {
        if (zbc != boxc.bottom && ztp != boxp.top)
          pc = (20*(ztp - zbc))/base;
       }
       else
       {
        if (ztc > zbp) // Cur lower than current
         {
          if (zbp != boxp.bottom && ztc != boxc.top)
            pc = (20*(ztc - zbp))/base;
         }
       }

      if (pc > 8) pc = 8; // Just arbitrary limit ....
      if (pc < 0) pc = 0;

      p += pc;
      xc->boxp |= (_USHORT)pc;
     }

  // -------------- Let's check box sizes -----------------------------

    if (chltc && chltp)
     {
      sizea = (boxp.bottom - boxp.top);
      sizeb = (boxc.bottom - boxc.top); if (sizeb < 1) sizeb = 1;

      pvmin = (chltp >> 12)&0x0F;
      pvmax = (chltp >>  8)&0x0F;
      cvmin = (chltc >> 12)&0x0F;
      cvmax = (chltc >>  8)&0x0F;

      kmin  = 100*(pvmin)/(cvmax);
      kmax  = 100*(pvmax)/(cvmin);
      R     = 100*(sizea)/(sizeb); if (R < 1) R = 1;

      pc    = 0;

      if (R < kmin)
       {
        if (cvmax < 15 && pvmin > 1) pc = 8*kmin/R - 8;
        if (cvmax>=14 && pvmax>=14 ) //special considerations for big-sized letters
         {
          _INT dCross = HWRMin( (boxc.bottom-boxp.top), (boxp.bottom-boxc.top) );
          if  ( dCross < HWRMax(sizea,sizeb)/2 )
           {
            if  ( dCross < 2*HWRMin(sizea,sizeb)/3 )
             pc /= 2; //!!!!
            else  if  ( dCross < 4L*HWRMin(sizea,sizeb)/5 )
             pc = 2*pc/3;
           }
         }
        if (cvmax > 3*pvmin ) pc /= 2; //!!!!
       }
       else
       {
        if (R > kmax)
         {
          if (cvmin > 1 && pvmax < 15) pc = 8*R/kmax - 8;
          if (cvmax>=14 && pvmax>=14 ) //special considerations for big-sized letters
           {
            _INT dCross = HWRMin( (boxc.bottom-boxp.top), (boxp.bottom-boxc.top) );
            if  ( dCross < HWRMax(sizea,sizeb)/2 )
             {
              if  ( dCross < 2*HWRMin(sizea,sizeb)/3 )
               pc /= 2; //!!!!
              else  if  ( dCross < 4L*HWRMin(sizea,sizeb)/5 )
               pc = 2*pc/3;
             }
           }
          if (pvmax > 3*cvmin ) pc /= 2; //!!!!
         }
       }

      if (pc > 8) pc = 8; // Just arbitrary limit ....
      if (pc < 0) pc = 0;

      p += pc;
      xc->boxp |= (_USHORT)(pc << 4);
     }

    if (chltc && chltpp)
     {
      sizea = (boxpp.bottom - boxpp.top);
      sizeb = (boxc.bottom - boxc.top); if (sizeb < 1) sizeb = 1;

      pvmin = (chltpp >> 12)&0x0F;
      pvmax = (chltpp >>  8)&0x0F;
      cvmin = (chltc  >> 12)&0x0F;
      cvmax = (chltc  >>  8)&0x0F;

      kmin  = 100*(pvmin)/(cvmax);
      kmax  = 100*(pvmax)/(cvmin);
      R     = 100*(sizea)/(sizeb); if (R < 1) R = 1;

      pc    = 0;

      if (R < kmin)
       {
        if (cvmax < 15 && pvmin > 1) pc = 8*kmin/R - 8;
        if (cvmax>=14 && pvmax>=14 ) //special considerations for big-sized letters
         {
          _INT dCross = HWRMin( (boxc.bottom-boxp.top), (boxp.bottom-boxc.top) );
          if  ( dCross < HWRMax(sizea,sizeb)/2 )
           {
            if  ( dCross < 2*HWRMin(sizea,sizeb)/3 )
             pc /= 2; //!!!!
            else  if  ( dCross < 4L*HWRMin(sizea,sizeb)/5 )
             pc = 2*pc/3;
           }
         }
       }
       else
       {
        if (R > kmax)
         {
          if (cvmin > 1 && pvmax < 15) pc = 8*R/kmax - 8;
          if (cvmax>=14 && pvmax>=14 ) //special considerations for big-sized letters
           {
            _INT dCross = HWRMin( (boxc.bottom-boxp.top), (boxp.bottom-boxc.top) );
            if  ( dCross < HWRMax(sizea,sizeb)/2 )
             {
              if  ( dCross < 2*HWRMin(sizea,sizeb)/3 )
               pc /= 2; //!!!!
              else  if  ( dCross < 4L*HWRMin(sizea,sizeb)/5 )
               pc = 2*pc/3;
             }
           }
         }
       }

      if (!IsPunct(xc->word[xc->len-2])) pc /= 2; // If prev is not punct, halve the penalty
      if (pc > 8) pc = 8; // Just arbitrary limit ....
      if (pc < 0) pc = 0;

      p += pc;
      R  = (xc->boxp >> 4) + pc;
//      p += pc/2;
//      R  = (xc->boxp >> 4) + pc/2;
      xc->boxp |= (_USHORT)(R << 4);
     }

  // -------------- Let's check position of symbol according to baseline

    if (chltc && bord_dn_pos)
     {
      pc  = ((boxc.top+boxc.bottom)*5);

      R  = 10+(pc-bord_dn_pos)/size;

      kmin = (chltc >> 20) & 0x0f;
      kmax = (chltc >> 16) & 0x0f;

     #ifdef GRYPHON
      pc = 0;                                         // Gryphon has baseline better defined
      if (R < kmin && kmin != 0)  pc = (kmin-R)*4;
      if (R > kmax && kmax != 15) pc = (R-kmax)*4;
     #else
      pc = 0;
      if (R < kmin && kmin != 0)  pc = (kmin-R)*2;
      if (R > kmax && kmax != 15) pc = (R-kmax)*2;
     #endif

      if (pc > 8) pc = 8; // Just arbitrary limit ....
      if (pc < 0) pc = 0;

      pBaseLine = pc; //CHE exp.

      p += pc;
      xc->boxp |= (_USHORT)(pc << 8);
     }

  // -------------- Apply results and write debug boxp --------------------

	xc->BoxPenalty	=	(SHORT)p;
    xc->sw  -= (_SHORT)p;
//    w = xc->w - p; if (w < -127) w = -127; xc->w = (_SCHAR)w;
    w = xc->symw[xc->len-1] - p;
    //w = xc->symw[xc->len-1] - pBaseLine;
    if (w < -127) w = -127;
    xc->symw[xc->len-1] = (_SCHAR)w;
   }

// -------------- Let's correct global weight --------------------------

//  for (i = 0, xv1 = &xlv->buf[0], w = xv1->sw; i < xlv->nsym; i ++, xv1 ++)
//    if (w < xv1->sw) w = xv1->sw;
//  xlv->gw -= (lgw - w);  // Consider boxes paert of corrmatr process, so it will be real gw

  return 0;
err:
  return 1;
 }

ROM_DATA_EXTERNAL _UCHAR triads_mapping[256];
/* ************************************************************************* */
/* *  Get next possible symbols                                            * */
/* ************************************************************************* */
_INT XrlvGetNextSymbols(p_xrlv_var_data_type pbp, _INT cap_dupl, p_xrlv_data_type xd)
{
	_INT    i, nsym;
	_INT    fbn = 0;
	_INT    f, ts, s2, s1;
	_ULONG  state;
	//  _UCHAR  sym;
	p_lex_data_type  vs = &xd->vs;
	p_fw_buf_type    fbp;
	p_triad_type     triads;
	
	P_XRLV_NS_1
		
		// --------------------- Source switching case ------------------------------
		
		switch (pbp->source)
	{
		
		// --------------- Get Vocabulary symbols --------------------------------------
		
	case XRWD_SRCID_VOC:
	case XRWD_SRCID_USV:
		{
			if (pbp->sd.l_status < XRWD_BLOCKEND)
			{
				vs->l_sym.sources = pbp->source;
				vs->l_sym.sd[XRWD_N_VOC] = pbp->sd;
				
#if AIRUS_VOC
				vs->done_let = pbp->wlen;
				HWRStrCpy((_STR)vs->word, (_STR)&pbp->word[pbp->len - pbp->wlen]);
				if (pbp->flags & XRLV_DICT_FL_CAP) vs->word[0] = (_UCHAR)ToLower(vs->word[0]);
#endif
				
				P_XRLV_NS_2
					
						fbn = GF_VocSymbolSet(vs, &xd->v_fbuf, xd->rc);
					
					if (cap_dupl && pbp->sd.l_status == XRWD_INIT)
					{
						fbp = &(xd->v_fbuf[fbn]);
						for (i = 0, nsym = fbn; i < nsym && fbn < XRLV_VOC_SIZE; i ++) // Duplicate Caps For first letter
						{
							if (IsLower(xd->v_fbuf[i].sym))
							{
								*fbp           = xd->v_fbuf[i];
								fbp->sym       = (_UCHAR)ToUpper(xd->v_fbuf[i].sym);
								fbp->l_status |= XRLV_DICT_FL_CAP;
								fbp->penalty   = (_UCHAR)(XRLV_VFL_CAP_PENL);
								fbp ++; fbn ++;
							}
						}
					}
			}
			
			xd->fbuf = &xd->v_fbuf;
			break;
		}
		
		
		// --------------- Get Charset and triad symbols -------------------------------
		
	case XRWD_SRCID_CS:
	case (XRWD_SRCID_CS|XRWD_SRCID_TR):
		{
			fbp = &xd->c_fbuf[0]; fbn = xd->cs_fbuf_num;
			
			if (xd->vs.p_tr && (pbp->source & XRWD_SRCID_TR)) // If triads enabled, make checks
			{
				triads = (p_triad_type)vs->p_tr;
				if (pbp->sd.l_status == XRWD_INIT) state = 0l;
				else state  = pbp->sd.state;
				s2 = ((state >> 8) & 0xFF); s1 = (state & 0xFF);
				for (i = 0; i < fbn; i ++, fbp ++)
				{
					ts = triads_mapping[fbp->sym]-1;
					if (ts >= 0 && ts < TR_NUMSYMBOLS)
					{
						//            if (ts >= TR_NUMSYMBOLS) ts = 0;
						f = TR_GETVALUE(triads, s2, s1, ts);
						fbp->state   = (state << 8) | ts;
						fbp->penalty = (_UCHAR)(XRLV_TRD_PENL + (3-f));
					}
					else
					{
						fbp->state = 0l;
						
						switch (fbp->attribute)
						{
						case (XRLV_CSA_ID << 4): fbp->penalty = (XRLV_CSA_PENL); break;
						case (XRLV_CSN_ID << 4): fbp->penalty = (XRLV_CSN_PENL); break;
						case (XRLV_CSP_ID << 4): fbp->penalty = (XRLV_CSP_PENL); break;
						case (XRLV_CSO_ID << 4): fbp->penalty = (XRLV_CSO_PENL); break;
						case (XRLV_CSM_ID << 4): fbp->penalty = (XRLV_CSM_PENL); break;
						}
					}
				}
			}
			
			P_XRLV_NS_4
				
				xd->fbuf = (fw_buf_type (_PTR)[XRWD_MAX_LETBUF])&xd->c_fbuf;
			break;
		}
		
		// --------------- Get punctuation symbols -------------------------------------
		
	case XRWD_SRCID_SPT:
		{
			if (xd->lp_fbuf_num == 0)
			{
				for (i = 0, fbp = &xd->lp_fbuf[fbn]; i < XRLV_PT_SIZE && (fbp->sym = vs->lpunct[i]) != 0; i ++)
				{
					fbp->attribute = 0;
					fbp->state     = 0;
					//          HWRMemSet(fbp, 0, sizeof(*fbp));
					fbp->penalty   = XRLV_ST_PUNCT_PENL;
					fbp->l_status  = XRWD_INIT;
					fbp ++; fbn ++;
				}
				
				xd->lp_fbuf_num = fbn;
			}
			
			P_XRLV_NS_5
				
				xd->fbuf = (fw_buf_type (_PTR)[XRWD_MAX_LETBUF])(&xd->lp_fbuf);
			fbn      = xd->lp_fbuf_num;
			break;
		}
		
	case XRWD_SRCID_EPT:
		{
			if (xd->ep_fbuf_num == 0)
			{
				for (i = 0, fbp = &xd->ep_fbuf[fbn]; i < XRLV_PT_SIZE && (fbp->sym = vs->epunct[i]) != 0; i ++)
				{
					fbp->attribute = 0;
					fbp->state     = 0;
					//          HWRMemSet(fbp, 0, sizeof(*fbp));
					fbp->penalty   = XRLV_EN_PUNCT_PENL;
					fbp->l_status  = XRWD_WORDEND;
					fbp ++; fbn ++;
				}
				
				xd->ep_fbuf_num = fbn;
			}
			
			P_XRLV_NS_6
				
				xd->fbuf = (fw_buf_type (_PTR)[XRWD_MAX_LETBUF])(&xd->ep_fbuf);
			fbn      = xd->ep_fbuf_num;
			break;
		}
		
		// --------------------- END of case ----------------------------------------
		
	default: fbn = 0; break;
	}
	
	P_XRLV_NS_7
		
#ifdef  DEBUG_PRINT_SYM_BUF
	{
		extern long gPrintSymBuf;
		FILE * file;
		int h;
		
		if (gPrintSymBuf && (file = fopen("xrlv_sym.log", "at")) != 0)
		{
			
			fprintf (file, "\nSource: %3d, Nsym: %3d, Prefix: %s \n", pbp->source, fbn, pbp->word);
			
			for (h = 0; h < fbn; h ++)
			{
				fprintf(file, "%c %d\n", (*xd->fbuf)[h].sym, (*xd->fbuf)[h].l_status);
			}
			
			fprintf(file, "\n");
			
			fclose (file);
		}
		
	}
#endif
	
	return fbn;
	}
#if 0
/* ************************************************************************* */
/* *  Create answers from xrlv                                             * */
/* ************************************************************************* */
_INT XrlvCreateAnswers(_INT iw, p_xrlv_data_type xd)
 {
  _INT   i, j, n, p;
  _INT   b, e, w;
  _INT   nansw;
  _INT   percent;
  _UCHAR afl;
  _UCHAR t;
  p_xrlv_var_data_type_array cxlv = xd->pxrlvs[xd->npos-1];
  p_xrlv_var_data_type_array xlv;
  p_xrlv_ans_type            xa  = &xd->ans[0];

  for (i = 0, nansw = 0; i < cxlv->nsym && nansw < XRLV_ANS_SIZE; i ++)
   {
    afl = 1;
    for (j = 0, p = xd->npos-1, n = i; p > 0 && j < XRLV_ANSW_MAX_LEN-1; j ++)
     {
      xlv = xd->pxrlvs[p];
      xa->word[j] = xlv->buf[n].sym;
      xa->locs[j] = (_UCHAR)(p);
      xa->nums[j] = (_UCHAR)(n);
      if (afl && !(xlv->buf[n].source & XRWD_SRCID_PT))
       {xa->atrs[j] = xlv->buf[n].sd.attribute; afl = 0;}
      if (xlv->buf[n].flags & XRLV_WORD_ST_FLAG) afl = 1;

      p = xlv->buf[n].st;

      if (p && xlv->buf[n].flags & XRLV_WORD_ST_FLAG) // Insert space
       {
        j ++;
        xa->word[j] = ' ';
        xa->locs[j] = (_UCHAR)(p);
        xa->nums[j] = (_UCHAR)(n);
       }

      n = xlv->buf[n].np;
     }

    for (b = 0, e = j-1, n = (e+1)/2; b < n; b ++, e --) // Reverse strings
     {
      t = xa->word[b]; xa->word[b] = xa->word[e]; xa->word[e] = t;
      t = xa->locs[b]; xa->locs[b] = xa->locs[e]; xa->locs[e] = t;
      t = xa->nums[b]; xa->nums[b] = xa->nums[e]; xa->nums[e] = t;
      t = xa->atrs[b]; xa->atrs[b] = xa->atrs[e]; xa->atrs[e] = t;
     }

    xa->w       = (_SHORT)(cxlv->buf[i].sw - iw);
    xa->vp      = (_UCHAR)((cxlv->buf[i].sd.l_status < XRWD_WORDEND) ? XRLV_NOTFINISHED_PENL : 0);
    xa->src_id  = (_UCHAR)((cxlv->buf[i].source & (XRWD_SRCID_VOC)) ? 0 : -3);
    xa->sources = cxlv->buf[i].source;

    w = xa->w - xa->vp;

//    percent = (_INT)((1000l*(_LONG)w + (_LONG)(sts)*STAT_QUAL*2*100l) /(_LONG)self_w +
//                     (_LONG)(sts)*STAT_QUAL);
    percent = (_INT)((1000l*(_LONG)w) /(_LONG)xd->self_weight);

    if (percent < 0)    percent = 0;
    if (percent > 2000) percent = 2000;

    xa->percent = (_SHORT)percent;

    xa ++; nansw ++;
   }

  return 0;
 }
#endif
/* ************************************************************************* */
/* *  Sort xrlv answers                                                    * */
/* ************************************************************************* */
_INT XrlvSortAns(p_rec_inst_type pri, p_xrlv_data_type xd)
 {
  _INT i, k, all_sorted;
  _INT w, vp, percent;
  p_xrlv_ans_type xc, xp;
  xrlv_ans_type   pel;
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[xd->npos-1];
  p_xrlv_var_data_type       buf;


// ------------ Count percents -------------------------------------------

  for (i = 0, xc = &xd->ans[0]; i < xlv->nsym; i ++, xc ++)
   {
    k = xd->order[i];
    buf = &xlv->buf[k];

               // Write final attribute info at last position
    if (buf->source & (XRWD_SRCID_VOC))
     {
      XrlvCheckDictCap(buf, xd);
      XrlvApplyWordEndInfo(xd->npos-1, buf, xd);
     }
                                       // Subtract initial reward for first voc letter
    if (buf->flags & XRLV_DICT_STREWARDED) vp = XRLV_DICT_STREWARD;
     else vp = 0;

    vp += ((buf->sd.l_status < XRWD_WORDEND) ? XRLV_NOTFINISHED_PENL : 0);
    w   = (buf->sw) - xd->init_weight - vp;

    //percent = (_INT)((1000l*(_LONG)w) /(_LONG)xd->self_weight);
	percent = w;

    if (buf->source & (XRWD_SRCID_VOC)) percent ++; // Ensure voc seq is first in equal weights

    if (percent < 0)    percent = 0;
    if (percent > 2000) percent = 2000;

	// disable invalid answers when PEG_RECFL_COERCE is on
	if ((buf->sd.l_status < XRWD_WORDEND) && (pri->flags & PEG_RECFL_COERCE))
		percent = 0;

    xc->percent = (_SHORT)percent;
    xc->vp  = (_UCHAR)vp;
    xc->num = (_UCHAR)k;
   }

// ------------ Sort percents -------------------------------------------

  all_sorted = 0;
  while (!all_sorted)
   {
    all_sorted = 1;
    xp = &xd->ans[0]; xc = xp+1;
    for (i = 1; i < xlv->nsym; i ++, xc ++, xp ++)
     {
      if (xc->percent > xp->percent)
       {
        pel = *xp;
        *xp = *xc;
        *xc = pel;

        all_sorted = 0;
       }
     }
   }

  return 0;
 }

/* ************************************************************************* */
/* *  Clean duplicate words from answer array                              * */
/* ************************************************************************* */
_INT XrlvCleanAns(p_xrlv_data_type xd)
 {
  _INT i, j, n;
  p_xrlv_ans_type xc, xp;
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[xd->npos-1];

  for (i = 1, xc = &xd->ans[1], n = 0; i < xlv->nsym && n < XRWS_MAX_OUT_ANSWERS; i ++, xc ++)
   {
    for (j = 0, xp = &xd->ans[0]; j < i; j ++, xp ++)
     {
      if (HWRStrCmp((_STR)xlv->buf[xp->num].word, (_STR)xlv->buf[xc->num].word) == 0) // Words are the same
       {
        xc->percent = 0;
        break;
       }

      if (j == i) n ++;
     }
   }

  return 0;
 }

/* ************************************************************************* */
/* *    Fill RWS of symbol graph from answers                              * */
/* ************************************************************************* */
_INT XrlvCreateRWG(p_RWG_type rwg, p_xrlv_data_type xd)
 {
  _INT            nw, j;
  _INT            num_symbols;
  _INT            best_percent;
  _INT            answer_level, answer_allow;
  _INT            loc, st;
  _INT            src_id, attr;
  p_xrlv_ans_type pansw = &xd->ans[0];
  p_xrlv_var_data_type_array xlvc = xd->pxrlvs[xd->npos-1];
  p_xrlv_var_data_type xlv;
  _SCHAR          src_ids[XRWS_MAX_OUT_ANSWERS];

  best_percent = pansw->percent;
  answer_level = xd->rc->answer_level*10;
  answer_allow = xd->rc->answer_allow*10;

  num_symbols = 0;
  for (nw = j = 0; j < xlvc->nsym && nw < XRWS_MAX_OUT_ANSWERS; pansw ++, j ++)
   {
    if (pansw->percent == 0) continue;
    //if (pansw->percent < answer_level) break;
    //if (pansw->percent < best_percent - answer_allow) break;

    xlv = &xlvc->buf[pansw->num];

    if (xlv->len == xlv->wlen && (xlv->source & XRWD_SRCID_VOC))
     {
      xd->vs.l_sym.sources = xlv->source;
      HWRStrCpy((_STR)xd->vs.word, (_STR)&xlv->word[xlv->len-xlv->wlen]);
      if (GetWordAttributeAndID(&xd->vs, &src_id, &attr))
       {
        xd->vs.word[0] = (_UCHAR)ToLower(xd->vs.word[0]);
        if (GetWordAttributeAndID(&xd->vs, &src_id, &attr)) src_id = -3;
       }
      src_ids[nw] = (_SCHAR)src_id;
     }
     else src_id = -3;

    src_ids[nw] = (_SCHAR)src_id;

    if (xlv->len > XRLV_ANSW_MAX_LEN-1) xlv->len = XRLV_ANSW_MAX_LEN-1;
    if (xlv->word[xlv->len-1] == ' ') xlv->len --; // Remove trailing blank, if any

    num_symbols += xlv->len;
    nw ++;
   }

/* -------------------------- Fill RWG --------------------------------- */

   {
    _INT					i;
    _INT					rwsi;
    RWS_type				(_PTR rws)[RWS_MAX_ELS];
    p_RWS_type				prws;
    p_xrlv_var_data_type	xlvLocal;

#ifndef PEGASUS
    RWG_PPD_type   (_PTR ppd)[RWS_MAX_ELS];
#endif

    if (nw >  1) num_symbols += nw+1;     /* Reserve space for brackets and ORs */
    if (nw == 0) goto err;

    rwg->type     = RWGT_WORD;
    rwg->size     = num_symbols;

    rwg->rws_mem  = HWRMemoryAlloc((num_symbols+1) * sizeof(RWS_type));
    if (rwg->rws_mem == _NULL) goto err;

    rws = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);
    HWRMemSet(rws, 0, (num_symbols+1) * sizeof(RWS_type));

    #ifndef PEGASUS
    rwg->ppd_mem = HWRMemoryAlloc((num_symbols+1) * sizeof(RWG_PPD_type));
    if (rwg->ppd_mem == _NULL) goto err;

    ppd = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])(rwg->ppd_mem);
    HWRMemSet(ppd, 0, (num_symbols+1) * sizeof(RWG_PPD_type));
    #endif

    rwsi = 0;
    prws = &(*rws)[0];

    if (nw > 1)              /* If more than one answer in RecWords add brackets */
     {
      prws->type = RWST_SPLIT;
      (*rws)[num_symbols-1].type = RWST_JOIN;
      rwsi ++;
      prws ++;
     }

    for (i = 0, pansw = &xd->ans[0]; rwsi < num_symbols && i < nw; pansw ++)
     {
      if (pansw->percent == 0) continue;

      loc = 0;
      xlvLocal = &xlvc->buf[pansw->num];
      for (j = 0; j < XRLV_ANSW_MAX_LEN-1 && j < xlvLocal->len; j ++)
       {
        prws->type   = RWST_SYM;
        prws->src_id = src_ids[i];
        prws->letw   = (_SCHAR)(xlvLocal->symw[j]);
        prws->lexw   = (_UCHAR)(pansw->vp);
        prws->d_user = 1;                       /* Start of xrdata, for this alternative */
        //prws->weight = (_UCHAR)(min (255, pansw->percent / 3));
		prws->weight = pansw->percent;

        //if (prws->weight > 100) prws->weight = 100;
        prws->sym    = prws->realsym = xlvLocal->word[j];

        st            = xd->unlink_index[loc];
        prws->xrd_beg = (_UCHAR)(st + 1);
        prws->xrd_len = (_UCHAR)(xd->unlink_index[loc+(xlvLocal->nvps[j]&0xF)] - st);
        prws->nvar    = (_UCHAR)(xlvLocal->nvps[j]>>4);
        prws->ppdw    = (_UCHAR)(0);

        #if !defined PEGASUS && !defined LSTRIP
        XrlvGetRwgSymAliases(rwsi, rwg, xd);
        #endif

        loc  += xlvLocal->nvps[j]&0xF;
        rwsi ++;
        prws ++;

       }

      if (nw > 1 && i < nw-1) {prws->type = RWST_NEXT; rwsi ++; prws ++;}
      i ++;
     }

   }


  return 0;
err:
  if (rwg->rws_mem) {HWRMemoryFree(rwg->rws_mem); rwg->rws_mem = _NULL;};
  if (rwg->ppd_mem) {HWRMemoryFree(rwg->ppd_mem); rwg->ppd_mem = _NULL;};
  return 1;
 }

/* ************************************************************************* */
/* *  Check created words to dictionary                                    * */
/* ************************************************************************* */
_INT XrlvSetLocations(p_xrlv_data_type xd, _INT fl)
 {
  _INT          i, j, k, n;
  _INT          npos, ok;
  _INT          len;
  _INT          max_pos;
//  _INT          last, lastl;
//  _UCHAR        xr;
  p_xrd_type    xrd = xd->xrdata->xrd;
  p_xrd_el_type xrp;

#define IS_LINKLIKE1_XR(xr) ((xr) == X_UD_F || (xr) == X_DD_L || (xr) == X_BGD || \
                             (xr) == X_SGD || (xr) == X_CU_L || (xr) == X_GL ||   \
                             (xr) == X_DU_L || (xr) == X_AN_UL || (xr) == X_ST || \
                             (xr) == X_UDC_B || (xr) == X_XT_ST)
#define IS_LINKLIKE2_XR(xr) ((xr) == X_ID_F || (xr) == X_ID_STK)
#define IS_LINKLIKE3_XR(xr) ((xr) == X_DU_R || (xr) == X_CU_R || (xr) == X_GR || \
                             (xr) == X_BGU || (xr) == X_SGU || (xr) == X_ST ||   \
                             (xr) == X_DF || (xr) == X_XT || (xr) == X_XT_ST  || \
                             (xr) == X_AN_UR)
#define IS_LINKLIKE4_XR(xr) ((xr) == X_UDC_F)
#define IS_LINKLIKE5_XR(xr) ((xr) == X_BGU)
#define IS_LINKLIKE6_XR(xr) ((xr) == X_ST)

  len = xd->xrdata->len;

//  for (i = 0, npos = 0, last = 0, xrp = &(*xrd)[0]; i < len; i ++, xrp ++)
  for (i = 0, npos = 0, xrp = &(*xrd)[0]; i < len; i ++, xrp ++)
   {
#if  0
    xr = (*xrd)[i].xr.type;
    ok = 0;
    if (IS_XR_LINK(xr)) {ok = 1; last = lastl = i;}
    if (!ok && (i >= len-2 || IS_XR_LINK((xrp+1)->xr.type) || IS_XR_LINK((xrp+2)->xr.type))) continue;

    if (!ok && i-last  > 1 && i < len-2) if (IS_LINKLIKE1_XR(xr)) ok = 1;
    if (!ok && i-last  > 3 && i < len-2) if (IS_LINKLIKE2_XR(xr)) ok = 1;
    if (!ok && i-last  > 1 && i < len-2) if (IS_LINKLIKE3_XR((xrp+1)->xr.type)) ok = 1;
    if (!ok && i-last  > 1 && i < len-2) if (IS_LINKLIKE4_XR((xrp+2)->xr.type)) ok = 1;
    if (!ok && i-last  > 1 && i > 2)     if (IS_LINKLIKE4_XR((xrp-2)->xr.type)) ok = 1;
    if (!ok && i-last  > 1 && i > 1)     if (IS_LINKLIKE5_XR((xrp-1)->xr.type)) ok = 1;
    if (!ok && i-last == 1 && i < len-2) if (IS_LINKLIKE6_XR(xr)) ok = 1;
    if (!ok && i-lastl > 5 && i < len-2) ok = 1;
#else
    ok=(xrp->xr.attrib & END_LETTER_FLAG);
#endif

    if (ok && fl) if (i > 0 && i < len-1) ok = 0;    // If one symbol mode, leave only last pos
    if (ok && xd->rc->corr_mode & XRCM_SEPLET) if (!(IS_XR_LINK(xrp->xr.type))) ok = 0; // In sep let mode, set locations only on links

    if (ok)
     {
      xd->link_index[i]      = (_UCHAR)npos;
      xd->unlink_index[npos] = (_UCHAR)i;

      npos ++;
//      lastl = i;
     }
   }

  if (npos < 2) goto err;
  if (i < 3)    goto err;

  for (i = 0, max_pos = 0; i < npos; i ++)
   {
    for (j = k = xd->unlink_index[i]+1, n = 0; j < len && j < k + DTI_XR_SIZE+5; j ++)
     if (xd->link_index[j]) n ++;
    if (n > max_pos) max_pos = n;
   }


  xd->npos = npos;
  xd->n_real_pos = max_pos+1;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/* *  Create charset strings                                               * */
/* ************************************************************************* */
_INT XrlvGetCharset(p_xrlv_data_type xd)
 {
  _INT    j, k;
  _INT    dupl;
  p_UCHAR ptr;
  _INT    en_alc = xd->xrw_cs;
  _INT    caps = 1;
  
  /*
  The original code had:
		_INT    caps = xd->rc->caps_mode & XCM_AL_TRYCAPS;

  We are now unconditionally turning the capitalization machine ON for the out-of-dictionary string generation algo in Bear.
  */

  p_fw_buf_type p, fbp = &(xd->c_fbuf[0]);


  j = 0;

  if (en_alc & CS_ALPHA)
   {
    for (ptr = xd->rc->alpha_charset; *ptr != 0 && j < XRLV_CS_SIZE-1; ptr ++)
     {
      fbp->sym = *ptr;
      fbp->attribute = (XRLV_CSA_ID << 4);
      fbp->penalty   = (XRLV_CSA_PENL);
      fbp->l_status  = XRWD_WORDEND;
      j ++; fbp ++; if (j >= XRWD_MAX_LETBUF) goto done;

      if (caps && IsLower(*ptr)) // Put capitals, if allowed
       {
        fbp->sym = (_UCHAR)ToUpper(*ptr);
        fbp->attribute = (XRLV_CSA_ID << 4);
        fbp->penalty   = (XRLV_CSA_PENL);
        fbp->l_status  = XRWD_WORDEND;
        j ++; fbp ++;  if (j >= XRWD_MAX_LETBUF) goto done;
       }
     }
   }

  if (en_alc & CS_NUMBER)
   {
    for (ptr = xd->rc->num_charset; *ptr != 0 && j < XRLV_CS_SIZE-1; ptr ++)
     {
      for (k = 0, dupl = 0, p = &(xd->c_fbuf[0]); k < j; k ++, p++) if (p->sym == *ptr) {dupl = 1; break;}
      if (!dupl)
       {
        fbp->sym = *ptr;
        fbp->attribute = (XRLV_CSN_ID << 4);
        fbp->penalty   = (XRLV_CSN_PENL);
        fbp->l_status  = XRWD_WORDEND;
        j ++; fbp ++; if (j >= XRWD_MAX_LETBUF) goto done;
       }
     }
   }

  if (en_alc & CS_EPUNCT)
   {
    for (ptr = xd->rc->epunct_charset; *ptr != 0 && j < XRLV_CS_SIZE-1; ptr ++)
     {
      for (k = 0, dupl = 0, p = &(xd->c_fbuf[0]); k < j; k ++, p++) if (p->sym == *ptr) {dupl = 1; break;}
      if (!dupl)
       {
        fbp->sym = *ptr;
        fbp->attribute = (XRLV_CSP_ID << 4);
        fbp->penalty   = (XRLV_CSP_PENL);
        fbp->l_status  = XRWD_WORDEND;
        j ++; fbp ++; if (j >= XRWD_MAX_LETBUF) goto done;
       }
     }
   }

  if (en_alc & CS_LPUNCT)
   {
    for (ptr = xd->rc->lpunct_charset; *ptr != 0 && j < XRLV_CS_SIZE-1; ptr ++)
     {
      for (k = 0, dupl = 0, p = &(xd->c_fbuf[0]); k < j; k ++, p++) if (p->sym == *ptr) {dupl = 1; break;}
      if (!dupl)
       {
        fbp->sym = *ptr;
        fbp->attribute = (XRLV_CSP_ID << 4);
        fbp->penalty   = (XRLV_CSP_PENL);
        fbp->l_status  = XRWD_WORDEND;
        j ++; fbp ++; if (j >= XRWD_MAX_LETBUF) goto done;
       }
     }
   }

  if (en_alc & CS_OTHER)
   {
    for (ptr = xd->rc->other_charset; *ptr != 0 && j < XRLV_CS_SIZE-1; ptr ++)
     {
      for (k = 0, dupl = 0, p = &(xd->c_fbuf[0]); k < j; k ++, p++) if (p->sym == *ptr) {dupl = 1; break;}
      if (!dupl)
       {
        fbp->sym = *ptr;
        fbp->attribute = (XRLV_CSO_ID << 4);
        fbp->penalty   = (XRLV_CSO_PENL);
        fbp->l_status  = XRWD_WORDEND;
        j ++; fbp ++; if (j >= XRWD_MAX_LETBUF) goto done;
       }
     }
   }

  if (en_alc & CS_MATH)
   {
    for (ptr = xd->rc->math_charset; *ptr != 0 && j < XRLV_CS_SIZE-1; ptr ++)
     {
      for (k = 0, dupl = 0, p = &(xd->c_fbuf[0]); k < j; k ++, p++) if (p->sym == *ptr) {dupl = 1; break;}
      if (!dupl)
       {
        fbp->sym = *ptr;
        fbp->attribute = (XRLV_CSM_ID << 4);
        fbp->penalty   = (XRLV_CSM_PENL);
        fbp->l_status  = XRWD_WORDEND;
        j ++; fbp ++; if (j >= XRWD_MAX_LETBUF) goto done;
       }
     }
   }

// ------------ Sort charsets by frequency ------------------------
#if 0
  {
  _INT    i, all_sorted;
  _INT    w1, w2;
  p_fw_buf_type xc, xp;
  fw_buf_type pel;

  all_sorted = 0;
  while (!all_sorted)
   {
    for (i = 1, all_sorted = 1; i < j; i ++)
     {
      xc = &xd->c_fbuf[i];
      xp = (xc-1);
      w1 = ((xc->sym > 127) ? xc->sym : (let_stat[xc->sym])<<8);
      w2 = ((xp->sym > 127) ? xp->sym : (let_stat[xp->sym])<<8);

      if (w1 > w2)
       {
        pel = *xp;
        *xp = *xc;
        *xc = pel;

        all_sorted = 0;
       }
     }
   }
  }
#endif
done:
  xd->cs_fbuf_num = j;
  return j;
 }

#if !defined PEGASUS && !defined LSTRIP
/* ************************************************************************* */
/* *  Fill aliases to xrdata in RWG                                        * */
/* ************************************************************************* */
_INT XrlvGetRwgSymAliases(_INT rwsi, p_RWG_type rwg, p_xrlv_data_type xd)
 {
  _INT            i, k;
  _INT            st, len, nvar;
  _UCHAR          sym, found;
  RWS_type       (_PTR rws)[RWS_MAX_ELS];
  RWG_PPD_type   (_PTR ppd)[RWS_MAX_ELS];
  p_RWS_type     prws;
  p_RWG_PPD_el_type pppd;
  _UCHAR         buf[XRLV_PP_INFO_SIZE];

  rws = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);
  ppd = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])(rwg->ppd_mem);

  prws = &(*rws)[rwsi];
  sym  = prws->sym; st = prws->xrd_beg; len = prws->xrd_len; nvar = prws->nvar;

  for (i = 0, prws = &(*rws)[0], found = 0; i < rwsi; i ++, prws ++)
   {
    if (prws->type != RWST_SYM) continue;
    if (prws->sym == sym && prws->xrd_beg == st && prws->xrd_len == len)
     {found = 1; break;}
   }

  if (found)
   {
    HWRMemCpy(&(*ppd)[rwsi][0], &(*ppd)[i][0], sizeof((*ppd)[0]));
    (*rws)[rwsi].nvar = (*rws)[i].nvar;
   }
   else // No such symbol -- need to count aliases
   {
    _INT link_pos;

    for (i = st-1, link_pos = 0; i >= 0; i --)
     {if (IsXrLink(&(*xd->xrdata->xrd)[i])) link_pos = 1; if (!GetXrMovable(&(*xd->xrdata->xrd)[i])) break;}

    xd->xrcm->en_ww = xd->rc->enabled_ww;
    if (!link_pos) xd->xrcm->en_ww &= ~(WW_BLOCK | WW_GENERAL); // Only letters are allowed to be connected

    XrlvGetSymAliases(prws->sym, nvar, st-1, st+len, buf, xd->xrcm);
    for (k = 0, pppd = &(*ppd)[rwsi][0]; buf[k] > 0 && k < DTI_XR_SIZE && k < XRLV_PP_INFO_SIZE; k ++, pppd ++)
     {pppd->alias = (_UCHAR)(st-1 + (buf[k] & 0x3F)); pppd->type = (_UCHAR)((buf[k] >> 6) & 0x03);}
    if (nvar == 15) prws->nvar = xd->xrcm->nvar_vect[len-1];
   }


  return 0;
 }

/* ************************************************************************* */
/* *  Get alias info for lv position                                       * */
/* ************************************************************************* */
_INT XrlvGetSymAliases(_UCHAR sym, _INT nvar, _INT st, _INT end, p_UCHAR buf, p_xrcm_type xrcm)
 {
  _INT           t;
  _INT           cx;
  _INT           pp, ip;
  _UCHAR         vect;
  _INT           xrinp_len = xrcm->xrinp_len;
  _INT           flags = xrcm->flags;
  _INT           caps_mode = xrcm->caps_mode;
  p_letlayout_hdr_type  plsym;
  xrinp_type    (_PTR xrinp)[XRINP_SIZE] = xrcm->xrinp;

  xrcm->flags |= XRMC_DISABLECAPBITS; // Disregard caps bits var masking
  xrcm->flags &= ~(XRMC_DISABLEON7);  // Allow '7' corr -- or can't learn

  xrcm->xrinp       = (xrinp_type (_PTR)[XRINP_SIZE])(&(*xrinp)[st]);
  xrcm->trace_end   = end-st-1;
  xrcm->xrinp_len   = end-st+1;
  SetInpLineByValue(XRMC_CONST_CORR, 0, 3, xrcm);
  xrcm->src_pos     = 0;          // 15 is flag for counting on its own
  xrcm->var_mask[0] = (_SHORT)((nvar == 15) ? 0 : ~(0x0001 << nvar));
  xrcm->word[0] = sym; xrcm->word[1] = 0;
  xrcm->caps_mode = XCM_AL_DEFSIZE;

  if (CountWord(xrcm->word, xrcm->caps_mode, xrcm->flags | XRMC_DOTRACING, xrcm)) goto err;

  if (xrcm->p_hlayout == _NULL) goto err;
  plsym = xrcm->p_hlayout->llhs[0];
  vect = XRWG_ALST_CR; // AVP much later ... To init 'vect' ...
  for (t = 0, pp = -1, ip = 0, cx = 0; t < plsym->len; t ++)
   {
    p_tr_pos_type trp = &(plsym->trp[t]);

    if (trp->xrp_num != pp)
     {
      if (trp->vect == XRMC_T_CSTEP) vect = XRWG_ALST_CR;
      if (trp->vect == XRMC_T_PSTEP)
       {
        if (ip) vect = XRWG_ALST_DS;
         else   vect = XRWG_ALST_VS;
       }

//      buf[cx] = (_UCHAR)((vect << 6) | (trp->inp_pos - st));
      buf[cx] = (_UCHAR)((vect << 6) | (trp->inp_pos));

      pp = trp->xrp_num;
      cx ++;
      ip = 0;
     }
     else ip = 1;
   }

  if (cx < DTI_XR_SIZE) buf[cx] = (_UCHAR)(0);

err:
  FreeLayout(xrcm);

  xrcm->flags     = flags;
  xrcm->trace_end = 0;
  xrcm->var_mask[0] = xrcm->svm = 0;
  xrcm->xrinp_len = xrinp_len;
  xrcm->xrinp     = xrinp;
  xrcm->caps_mode = caps_mode;
  return 0;
 }

#endif // ifdef PEGASUS

#if 0
/* ************************************************************************* */
/* *  Get SRC Ids and attributes for RWG words                             * */
/* ************************************************************************* */
_INT XrlvGetRwgSrcIds(p_RWG_type rwg, p_xrlv_data_type xd)
 {
  _INT            i, n;
  _INT            src_id, attr;
  RWS_type       (_PTR rws)[RWS_MAX_ELS];
  p_RWS_type     prws;

  rws = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);

  for (i = n = 0, prws = &(*rws)[0]; i < rwg->size; i ++, prws ++)
   {
    if (prws->type == RWST_SYM && prws->sym != ' ')
     {xd->vs.word[n++] = prws->sym; continue;}

    if (n > 0)
     {
      xd->vs.word[n] = 0;

      if (xd->xrwm & XRWM_VOC)
       {
        xd->vs.l_sym.sources =  XRWD_SRCID_VOC;
        if (GetWordAttributeAndID(&xd->vs, &src_id, &attr) == 0)
         {
          (prws-1)->attr   = (_UCHAR)attr;
          (prws-1)->src_id = (_SCHAR)src_id;
          n = 0;
         }
       }

      n = 0;
     }
   }

  return 0;
 }
#endif
/* ************************************************************************* */
/* *  Allocate memory for XrLW                                             * */
/* ************************************************************************* */
_INT XrlvAlloc(p_xrlv_data_type _PTR xdd, p_xrdata_type xrdata, p_rc_type rc)
{
	_INT						i;
	_INT						t, 
								pa, 
								allocated = 0;
	p_xrlv_data_type			xd;
	p_xrlv_var_data_type_array	pxl;

	xd = (p_xrlv_data_type)HWRMemoryAlloc(sizeof(xrlv_data_type));
	if (xd == _NULL) 
	{
		goto err;
	}

	HWRMemSet(xd, 0, sizeof(xrlv_data_type));

#ifndef LSTRIP
	if (xrmatr_alloc(rc, xrdata, &xd->xrcm) != 0) goto err;
#endif

	xd->xrdata = xrdata;
	
#if XRLV_DUMP_TRAJECTORY
	XrlvDumpTrace(rc->ii, rc->trace, "tracedmp.cpp");
#endif

	xd->rc           = rc;
	xd->xrdata       = xrdata;
	xd->bad_dist     = rc->bad_distance/4;
	xd->xrwm         = rc->xrw_mode;
	xd->xrw_cs       = rc->enabled_cs;
	xd->caps_mode    = rc->caps_mode;

	if (XrlvSetLocations(xd, (rc->xrw_max_wlen == 1))) 
	{
		goto err;
	}

	xd->n_real_pos	=	xd->npos;

	if (xd->n_real_pos < 2) 
	{
		goto err;
	}

	xd->nloc  = (rc->xrw_tag_size < XRLV_VARNUM) ? rc->xrw_tag_size : XRLV_VARNUM;

	for (t = 0, pa = 100; t < 5; t ++)
	{
		xd->nloc      = xd->nloc*pa/100; 
		
		if (xd->nloc < XRLV_MIN_BUFFERS) 
		{
			goto err;
		}

		xd->size_pos  = sizeof(xrlv_var_data_type_array) - 
			(XRLV_VARNUM-xd->nloc)*sizeof(xrlv_var_data_type);

		// Pust budet ...
		xd->size_pos += 16; 

		for (i = 0, pa = 100, allocated = 0; i < xd->n_real_pos; i ++)
		{
			xd->pxrlvs[i]	= 
			pxl				= (p_xrlv_var_data_type_array)HWRMemoryAlloc(xd->size_pos);
			
			if (pxl == _NULL) 
			{
				pa = 100*i/xd->n_real_pos; 
				break;
			}

			allocated += xd->size_pos;
		}

		// If all memory taken OK, then done
		if (pa == 100) 
		{
			break; 
		}
		// If not, free it, and begin all over again ...
		else                 
		{
			for (i = 0; i < xd->n_real_pos; i ++)
			{
				if (xd->pxrlvs[i]) 
				{
					HWRMemoryFree(xd->pxrlvs[i]); 
					xd->pxrlvs[i] = _NULL;
				}
			}
		}
	}

	if (pa < 100) 
	{
		goto err;
	}

	xd->nloc_c = xd->nloc/XRLV_CS_LOC_SHARE;
	xd->nloc_v = xd->nloc - xd->nloc_c;

	for (i = 0; i < xd->n_real_pos; i ++)
	{
		pxl = xd->pxrlvs[i];

		if (pxl)
		{
			pxl->min_w_loc_v	= xd->nloc_c;

			pxl->gw				= 
			pxl->min_w_v		= 
			pxl->n_put			= 
			pxl->nsym_v			= 0;

			pxl->min_w_c		= 
			pxl->min_w_loc_c	= 
			pxl->nsym_c			= 
			pxl->nsym			= 0;

			HWRMemSet(pxl->nn_weights, 128, sizeof(pxl->nn_weights));
		}
	}

	InitSnnData((p_UCHAR)"snn.mlp", &xd->mlpd); // MLP net data init

	*xdd = xd;

	allocated += sizeof(xrlv_data_type);

#ifndef LSTRIP
	allocated += xd->xrcm->allocated;
#endif

	P_XRLV_A_1

	if (((p_tr_descr_type)rc->tr_ptr)->p_tr == _NULL) 
	{
		xd->xrwm &= ~(XRWM_TRIAD);
	}

	if (xd->xrwm & XRWM_TRIAD) 
	{
		xd->vs.p_tr = ((p_tr_descr_type)rc->tr_ptr)->p_tr;
	}

	AssignDictionaries(&xd->vs, rc);

	return 0;

err:
	XrlvDealloc(&xd);
	*xdd = _NULL;

	return allocated + 1;
}

/* ************************************************************************* */
/* *  DeAllocate memory for XrLW                                           * */
/* ************************************************************************* */
_INT XrlvDealloc(p_xrlv_data_type _PTR xd)
 {
  _INT i;
  p_xrlv_data_type xdp;

  if (xd && *xd)
   {
    xdp = *xd;
    
//    if (xdp->xTrace)
//      {
//      HWRMemoryFree(xdp->xTrace);
//      xdp->xTrace = _NULL;
//      xdp->yTrace = _NULL;
//      }

    #ifndef LSTRIP
    if (xdp->xrcm) xrmatr_dealloc(&xdp->xrcm);
    #endif

    for (i = 0; i < XRINP_SIZE; i ++)
      if (xdp->pxrlvs[i]) {HWRMemoryFree(xdp->pxrlvs[i]); xdp->pxrlvs[i] = _NULL;}

//    xdp->rc->p_xd_data = _NULL;
    HWRMemoryFree(xdp);
    *xd = _NULL;
   }

  return 0;
 }
/* ************************************************************************* */
/* *  DeAllocate all positions except for last                             * */
/* ************************************************************************* */
_INT XrlvFreeSomePos(p_xrlv_data_type xd)
 {
  _INT i;

  if (xd)
   {
    for (i = 0; i < xd->npos-1; i ++)
      if (xd->pxrlvs[i]) {HWRMemoryFree(xd->pxrlvs[i]); xd->pxrlvs[i] = _NULL;}
   }

  return 0;
 }

/* ************************************************************************* */
/* ** Check if capitalization change is allowed **************************** */
/* ************************************************************************* */
_INT XrlvCheckDictCap(p_xrlv_var_data_type xv, p_xrlv_data_type xd)
 {
/*
  _INT i;
  _INT wp = xv->len-xv->wlen;
  _INT a;


  if ((xv->sd.attribute & XRWS_VOCCAPSFLAG) == XRWS_VOCCAPSFLAG)
   {
    for (i = wp; i < xv->len; i ++)
     {
      if (IsLower(xv->word[i]))                // Set nvar to 15 -- flag to count again!
       {
        #ifndef LSTRIP
        if (GetVarRewcapAllow(xv->word[i], (_UCHAR)(xv->nvps[i]>>4), xd->rc->dtiptr) == 0)
         {
          xv->sw -= (_SHORT)XRLV_F_NCAP_PENL;
          a = xv->symw[i] - XRLV_F_NCAP_PENL; if (a < -127) a = -127; xv->symw[i]  = (_SCHAR)(a);
         }
        #endif

        xv->word[i] = (_UCHAR)ToUpper(xv->word[i]);
        xv->nvps[i] |= 0xF0;
       }
     }
   }
   else
   {
    if ((xv->sd.attribute & XRWS_VOC_FL_CAPSFLAG) && (IsLower(xv->word[wp])))
     {
      #ifndef LSTRIP
      if (GetVarRewcapAllow(xv->word[wp], (_UCHAR)(xv->nvps[wp]>>4), xd->rc->dtiptr) == 0)
       {
        xv->sw -= (_SHORT)XRLV_F_NCAP_PENL;
        a = xv->symw[xv->len-1] - XRLV_F_NCAP_PENL; if (a < -127) a = -127; xv->symw[xv->len-1]  = (_SCHAR)(a);
       }
      #endif

      xv->word[wp] = (_UCHAR)ToUpper(xv->word[wp]);
      xv->nvps[wp] |= 0xF0;
     }
   }
*/

  return 0;
 }

/* ************************************************************************* */
/* *  Apply attribute rewards and other penalties on word end              * */
/* ************************************************************************* */
_INT XrlvApplyWordEndInfo(_INT pos, p_xrlv_var_data_type xv, p_xrlv_data_type xd)
 {
  _INT a, aw;
  _INT len, srcp;


  if (xv->len < 1) goto done;

  if ((xv->source == XRWD_SRCID_VOC) && xv->wlen == 1) // Penalize single-letter voc words
   {
    len = xd->unlink_index[pos] - xd->unlink_index[pos-(xv->nvps[xv->len-1]&0x0F)];
    srcp = (XRLV_S_LET_PENL * len + 2) >> 2;
    xv->sw -= (_SHORT)srcp;
    a = xv->symw[xv->len-1] - srcp; if (a < -127) a = -127; xv->symw[xv->len-1]  = (_SCHAR)(a);
   }

  if (!(xv->flags & XRLV_DICT_PREFIXED) && xv->sd.l_status > XRWD_MIDWORD) // Don't attribute prefixed words
   {
    aw = (xv->sd.attribute&0x03) + (((xv->sd.attribute&0x03) * xv->wlen * STAT_QUAL)>>3);
    xv->sw += (_SHORT)(aw); //Add attribute if word really ended
  //  a = xv->w + aw; if (a > 127) a = 127; xv->w  = (_SCHAR)(a);
    a = xv->symw[xv->len-1] + aw; if (a > 127) a = 127; xv->symw[xv->len-1]  = (_SCHAR)(a);
   }

done:
  return 0;
 }

#if XRLV_SNN_SWITCH
#ifdef USE_SYM_LENS
#if 1

#define XRLV_SYM_LENS  {                                                        \
                        {'a', 0x48},                                            \
                        {'b', 0x48},                                            \
                        {'c', 0x26},                                            \
                        {'d', 0x48},                                            \
                        {'e', 0x28},                                            \
                        {'f', 0x38},                                            \
                        {'g', 0x36},                                            \
                        {'h', 0x38},                                            \
                        {'i', 0x26},                                            \
                        {'j', 0x26},                                            \
                        {'k', 0x48},                                            \
                        {'l', 0x25},                                            \
                        {'m', 0x59},                                            \
                        {'n', 0x48},                                            \
                        {'o', 0x26},                                            \
                        {'p', 0x48},                                            \
                        {'q', 0x48},                                            \
                        {'r', 0x28},                                            \
                        {'s', 0x26},                                            \
                        {'t', 0x36},                                            \
                        {'u', 0x36},                                            \
                        {'v', 0x36},                                            \
                        {'w', 0x59},                                            \
                        {'x', 0x48},                                            \
                        {'y', 0x36},                                            \
                        {'z', 0x38},                                            \
                        {'A', 0x48},                                            \
                        {'B', 0x48},                                            \
                        {'C', 0x26},                                            \
                        {'D', 0x48},                                            \
                        {'E', 0x49},                                            \
                        {'F', 0x36},                                            \
                        {'G', 0x48},                                            \
                        {'H', 0x48},                                            \
                        {'I', 0x36},                                            \
                        {'J', 0x36},                                            \
                        {'K', 0x49},                                            \
                        {'L', 0x25},                                            \
                        {'M', 0x58},                                            \
                        {'N', 0x48},                                            \
                        {'O', 0x36},                                            \
                        {'P', 0x36},                                            \
                        {'Q', 0x59},                                            \
                        {'R', 0x48},                                            \
                        {'S', 0x25},                                            \
                        {'T', 0x38},                                            \
                        {'U', 0x36},                                            \
                        {'V', 0x36},                                            \
                        {'W', 0x58},                                            \
                        {'X', 0x48},                                            \
                        {'Y', 0x46},                                            \
                        {'Z', 0x36},                                            \
                        {'0', 0x36},                                            \
                        {'1', 0x36},                                            \
                        {'2', 0x38},                                            \
                        {'3', 0x36},                                            \
                        {'4', 0x48},                                            \
                        {'5', 0x38},                                            \
                        {'6', 0x36},                                            \
                        {'7', 0x36},                                            \
                        {'8', 0x38},                                            \
                        {'9', 0x36},                                            \
                        {'@', 0x5C},                                            \
                        {'#', 0x7C},                                            \
                        {'$', 0x7C},                                            \
                        {'%', 0x6C},                                            \
                        {'&', 0x59},                                            \
                        {'!', 0x46},                                            \
                        {'?', 0x48},                                            \
                        {'*', 0x6A},                                            \
                        {'/', 0x35},                                            \
                        {'+', 0x46},                                            \
                        {'-', 0x23},                                            \
                        {'=', 0x35},                                            \
                        {'(', 0x35},                                            \
                        {')', 0x35},                                            \
                        {'{', 0x36},                                            \
                        {'}', 0x36},                                            \
                        {'[', 0x36},                                            \
                        {']', 0x36},                                            \
                        {';', 0x36},                                            \
                        {':', 0x35},                                            \
                        {'~', 0x35},                                            \
                        {'\\', 0x35},                                           \
                        {'>', 0x36},                                            \
                        {'<', 0x36},                                            \
                        {'^', 0x26},                                            \
                        {'|', 0x46}                                             \
                       }
#else

#define XRLV_SYM_LENS  {                                                        \
                        {'a', 0x0F},                                            \
                        {'b', 0x0F},                                            \
                        {'c', 0x0F},                                            \
                        {'d', 0x0F},                                            \
                        {'e', 0x0F},                                            \
                        {'f', 0x0F},                                            \
                        {'g', 0x0F},                                            \
                        {'h', 0x0F},                                            \
                        {'i', 0x0F},                                            \
                        {'j', 0x0F},                                            \
                        {'k', 0x0F},                                            \
                        {'l', 0x0F},                                            \
                        {'m', 0x0F},                                            \
                        {'n', 0x0F},                                            \
                        {'o', 0x0F},                                            \
                        {'p', 0x0F},                                            \
                        {'q', 0x0F},                                            \
                        {'r', 0x0F},                                            \
                        {'s', 0x0F},                                            \
                        {'t', 0x0F},                                            \
                        {'u', 0x0F},                                            \
                        {'v', 0x0F},                                            \
                        {'w', 0x0F},                                            \
                        {'x', 0x0F},                                            \
                        {'y', 0x0F},                                            \
                        {'z', 0x0F},                                            \
                        {'A', 0x0F},                                            \
                        {'B', 0x0F},                                            \
                        {'C', 0x0F},                                            \
                        {'D', 0x0F},                                            \
                        {'E', 0x0F},                                            \
                        {'F', 0x0F},                                            \
                        {'G', 0x0F},                                            \
                        {'H', 0x0F},                                            \
                        {'I', 0x0F},                                            \
                        {'J', 0x0F},                                            \
                        {'K', 0x0F},                                            \
                        {'L', 0x0F},                                            \
                        {'M', 0x0F},                                            \
                        {'N', 0x0F},                                            \
                        {'O', 0x0F},                                            \
                        {'P', 0x0F},                                            \
                        {'Q', 0x0F},                                            \
                        {'R', 0x0F},                                            \
                        {'S', 0x0F},                                            \
                        {'T', 0x0F},                                            \
                        {'U', 0x0F},                                            \
                        {'V', 0x0F},                                            \
                        {'W', 0x0F},                                            \
                        {'X', 0x0F},                                            \
                        {'Y', 0x0F},                                            \
                        {'Z', 0x0F},                                            \
                        {'0', 0x0F},                                            \
                        {'1', 0x0F},                                            \
                        {'2', 0x0F},                                            \
                        {'3', 0x0F},                                            \
                        {'4', 0x0F},                                            \
                        {'5', 0x0F},                                            \
                        {'6', 0x0F},                                            \
                        {'7', 0x0F},                                            \
                        {'8', 0x0F},                                            \
                        {'9', 0x0F},                                            \
                        {'@', 0x0F},                                            \
                        {'#', 0x0F},                                            \
                        {'$', 0x0F},                                            \
                        {'%', 0x0F},                                            \
                        {'&', 0x0F},                                            \
                        {'!', 0x0F},                                            \
                        {'?', 0x0F},                                            \
                        {'*', 0x0F},                                            \
                        {'/', 0x0F},                                            \
                        {'+', 0x0F},                                            \
                        {'-', 0x0F},                                            \
                        {'=', 0x0F},                                            \
                        {'(', 0x0F},                                            \
                        {')', 0x0F},                                            \
                        {'{', 0x0F},                                            \
                        {'}', 0x0F},                                            \
                        {'[', 0x0F},                                            \
                        {']', 0x0F},                                            \
                        {';', 0x0F},                                            \
                        {':', 0x0F},                                            \
                        {'~', 0x0F},                                            \
                        {'\\', 0x0F},                                           \
                        {'>', 0x0F},                                            \
                        {'<', 0x0F},                                            \
                        {'^', 0x0F},                                            \
                        {'|', 0x0F}                                             \
                       }

const static _UCHAR  sym_lens[MLP_NET_NUMOUTPUTS][2] = XRLV_SYM_LENS;
#endif // 0
#endif // #ifdef USE_SYM_LENS
/* ************************************************************************* */
/* *  Apply NN weighting to XRLV position                                  * */
/* ************************************************************************* */



_INT XrlvNNXrlvPos(_INT pos, p_xrlv_data_type xd)
{
	_INT						i, n, k, iXRSt;
	_INT    st, end, len, w, c;
	_INT						bd = xd->bad_dist; 
	_UCHAR  outs[256];
	p_xrlv_var_data_type_array xlv, xlvc = xd->pxrlvs[pos];
	_UCHAR   coeff[PC_NUM_COEFF+GBM_NCOEFF];

#define NNXP_WEIGHT_FLOOR -1000
#define MAX_NN_LEN 10

	if (xlvc->nsym == 0) 
	{
		goto err;
	}

	HWRMemSet(xlvc->nn_weights, 0, sizeof(xlvc->nn_weights));

	st = xd->unlink_index[pos] + 1;

	if (pos == 0)
	{
		iXRSt	=	0;
	}
	else
	{
		iXRSt	=	st;
	}

	for (i = pos+1, len = 0; i < xd->npos; i ++)
	{
		xlv = xd->pxrlvs[i];
		if (xlv == _NULL) 
		{
			break;
		}

		end  = xd->unlink_index[i];
		len = end - st + 1;

		if ((i - pos - 1) < MAX_LANDING_POS)
		{
			GetXRNetOutput		(iXRSt, end - iXRSt + 1, 
				xd->xrdata, xd->aXRNetScore[i - pos - 1]);	
		}

		P_XRLV_NN_1

		if (!GetPolyCo(st, len, xd->xrdata, xd->rc->trace, coeff)) 
		{
			HWRMemSet(xlv->nn_weights, 128, sizeof(xlv->nn_weights));
			HWRMemSet(outs, 0, sizeof(outs));

			if (GetSnnResults(coeff, outs, &xd->mlpd) == 0)
			{
				n = len;

				for (k = 32; k < 256; k++)
				{
					if (outs[k] < xd->aXRNetScore[i - pos - 1][k])
					{
						outs[k]	=	xd->aXRNetScore[i - pos - 1][k];
					}
				}

#ifdef TRAINTIME_BEAR
				memset (outs, 0, sizeof (outs));

				for (k = 0; g_szAnswer[k]; k++)
				{
					outs[(unsigned char)g_szAnswer[k]]	=	255;
				}				
#endif

#ifndef LSTRIP
				c = 10;
#else
				c = 25;
				if (coeff[1]  & 1) 
				{
					c += c/4;
				}

				if (coeff[1]  & 2) 
				{
					c += c/5;
				}

				if ((coeff[1] & 3) == 3) 
				{
					c += c/3;
				}
#endif
				c *= n;

				for (k = n = 32; k < 256; k ++)
				{
					if (outs[k])
					{
						w = 150-(_INT)outs[k];

						if (outs[k] > xlvc->nn_weights[k]) 
						{
							xlvc->nn_weights[k] = outs[k];
						}

						xlv->nn_weights[k] = (_UCHAR)(128 + ((c*w) / 1024));

						P_XRLV_NN_3

							n++;
					}
				}
			}

			P_XRLV_NN_4
		}

		if (len >= MAX_NN_LEN) 
		{
			break;
		}
	}

err:
	return 0;
}

#endif // XRLV_SNN_SWITCH

#ifdef LSTRIP
extern ROM_DATA _ULONG sym_box_data[];
/* ************************************************************************* */
/*        Return CHL position value for variant                              */
/* ************************************************************************* */
_INT  GetVarPosSize(_UCHAR chIn, _UCHAR nv, p_VOID dtp)
 {
  return  sym_box_data[chIn];
 }
#endif
/* ************************************************************************* */
/* ** DBG functions of XRLW ********************************************** */
/* ************************************************************************* */
#if PG_DEBUG || PG_DEBUG_MAC || PG_DEBUG_LOCAL

/* ************************************************************************* */
/*       Debug print utility (xrlv)                                          */
/* ************************************************************************* */
_INT printwf (FILE * file, const p_CHAR fmt_str,...);

_INT printwf (FILE * file, const p_CHAR fmt_str,...)
 {
  va_list ap;
  _CHAR   str[1024];

  va_start(ap, fmt_str);

  vsprintf(str, fmt_str, ap);

  if (file == 0) printw(str);
   else fprintf(file, str);

  va_end(ap);

  return 0;
 }

/* ************************************************************************* */
/*       Debug print utility (xrlv)                                          */
/* ************************************************************************* */
_INT XrlvPrintXrlvPos(_INT pos, p_xrlv_data_type xd)
 {
  _INT i, j, n, p;
  p_UCHAR  ptr;
  p_xrdata_type xrdata = xd->xrdata;
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[pos];
  FILE * file = _NULL;
  p_CHAR fname = "c:\\avp\\xrlv.log";


  if (mpr == -6)
   {
    if ((file = fopen(fname, "at")) == 0) goto err;
    printw("Printing to file %s position # %d.\n", fname, pos);
   }

  if (pos == 0)
   {
    printwf(file, "+---------- XRLV Printout Legend -------------+\n");
    printwf(file, "|      Sym :  StartPos  : NumParentCell       |\n");
    printwf(file, "|  PostProcWeight : SymWeight : StringWeight  |\n");
    printwf(file, "| NumVar  :  Source  :  LetStatus  :  NWords  |\n");
    printwf(file, "| LexPenl : BoxPenl(Bord/Size/Loc) :  OthPenl |\n");
    printwf(file, "|          Lexical source State               |\n");
    printwf(file, "|          Current word                       |\n");
    printwf(file, "+---------------------------------------------+\n");
    printwf(file, "\n");
   }
   else
   {
    if (pos == xd->npos-1) XrlvSortXrlvPos(pos, xd); // Sort last, because it is unsorted!

    for (j = 0; j < 7; j ++)
     {
      if (mpr == -10) break;
                                   // TEMP!!!! until penlab is fixed!
      for (i = 0; i < xlv->nsym && i < 100; i ++)
       {
        p_xrlv_var_data_type xl = &xlv->buf[xd->order[i]];

        if ((n = HWRStrLen((_STR)xl->word)) < 9) ptr = xl->word;
         else ptr = &(xl->word[n - 9]);

        switch (j)
         {
          case 0: if (file) printwf(file, "+ "); else printwf(file, "+");
                  if (!file) put_xr((*xrdata->xrd)[xd->unlink_index[pos]].xr, 0);
                  printwf(file, "%02d-%02d-%02d",      xd->unlink_index[pos], pos, i); break;
          case 1: printwf(file, "| %c: %02d:%02d",     xl->sym, xl->st, xl->np); break;
          case 2: p = xl->iSNNPenalty; if (p >= 0 && p <= 9) p += '0'; else if (p > 9) p += 'a'-10; else p += 'z'+1;
                  printwf(file, "|%c:%03d:%03d",       (_CHAR)p, xl->w, xl->sw-XRLV_INITIAL_WEIGHT); break;
          case 3: printwf(file, "|%1x:%02x:%01d:%02d", xl->nvar,xl->source, xl->sd.l_status, xl->nwords);  break;
          case 4: printwf(file, "|%02d:%1x%1x%1x:%02d",xl->iLexPenalty,((xl->boxp>>8)&0xF), ((xl->boxp>>4)&0xF),((xl->boxp>>0)&0xF),(int)((_SCHAR)xl->iOtherPenalties));  break;
          case 5: printwf(file, "| %08x",              xl->sd.state);  break;
          case 6: printwf(file, "|%-9s",               ptr);  break;
         }
       }
      printwf(file, "\n");
     }
   }


  if (file) fclose (file);
  return 0;
err:
  if (file) fclose (file);
  return 1;
 }

#endif // #if PG_DEBUG || PG_DEBUG_MAC || PG_DEBUG_LOCAL

#if PG_DEBUG || PG_DEBUG_MAC
/* ************************************************************************* */
/*       Debug print utility (ans)                                           */
/* ************************************************************************* */
_INT XrlvPrintAns(p_xrlv_data_type xd)
 {
  _INT i, j;
  p_xrlv_ans_type  pans = &xd->ans[0];
  p_xrlv_var_data_type_array xlv = xd->pxrlvs[xd->npos-1];
  _UCHAR word[XRLV_ANSW_MAX_LEN*2];
  p_UCHAR pw;

  printw("ANS\n");
  printw("\n");

  for (i = 0; i < xlv->nsym; i ++, pans ++)
   {
    if (mpr == -10) break;
    for (j = 0, pw = word; j < xlv->buf[pans->num].len; j ++)
     {
      *pw++ = xlv->buf[pans->num].word[j];
     } *pw = 0;

    printw("%3d %-12s W:%3d %%:%4d VP:%1d ID:%2d SS:%2x \n",
           i, word, xlv->buf[pans->num].sw - xd->init_weight,
           pans->percent, pans->vp, 0, xlv->buf[pans->num].source);
   }

  printw("\n");

  return 0;
 }

/* ************************************************************************* */
/* *  Dump to file some statistics                                         * */
/* ************************************************************************* */
_INT avp_dbg_close(_VOID)
 {
  _ULONG Time, tpl, tpw;
  FILE *file;


  if ((file = fopen("c:\\avp\\Timestat.log", "wt")) != _NULL)
   {
    Time = gOTime + gLTime + gPTime + gWTime;
    tpl  = (Nletters > 0) ? Time / Nletters : 0l;
    tpw  = (Nwords > 0)   ? Time / Nwords   : 0l;

    fprintf(file, "\nWords: %ld, Letters: %ld\n\n", Nwords, Nletters);

    fprintf(file, "Total Time: %d.%03ds, Time per let: %d.%03ds, Time per wrd: %d.%03ds\n",
           (_INT)(Time/1000), (_INT)(Time%1000), (_INT)(tpl/1000), (_INT)(tpl%1000), (_INT)(tpw/1000), (_INT)(tpw%1000));

    fprintf(file, "Checks -> Voc: %ld, Ld: %ld, Cs: %ld, Spt: %ld, Ept: %ld\n",
            Nvocchecks, Nldchecks, Ncschecks, Nsptchecks, Neptchecks);
    fprintf(file, "CellsTried: %ld, CellsSaved: %ld\n",
            Ncellstried, Ncellssaved);
    fprintf(file, "TracesCoeffed: %ld, SymbolsNetted: %ld\n",
            NnPolCounts, NnSymChecks);

    fprintf(file, "\n\n");

    fprintf(file, "Letter Time: %4d.%03ds\n", (_INT)(gLTime/1000), (_INT)(gLTime%1000));
    fprintf(file, "PP     Time: %4d.%03ds\n", (_INT)(gPTime/1000), (_INT)(gPTime%1000));
    fprintf(file, "Word   Time: %4d.%03ds\n", (_INT)(gWTime/1000), (_INT)(gWTime%1000));
    fprintf(file, "Other  Time: %4d.%03ds\n", (_INT)(gOTime/1000), (_INT)(gOTime%1000));
    fprintf(file, "\n");
    fprintf(file, "Coeff  Time: %4d.%03ds\n", (_INT)(gCTime/1000), (_INT)(gCTime%1000));
    fprintf(file, "NN     Time: %4d.%03ds\n", (_INT)(gNTime/1000), (_INT)(gNTime%1000));
    fprintf(file, "Voc    Time: %4d.%03ds\n", (_INT)(gVTime/1000), (_INT)(gVTime%1000));
    fprintf(file, "Matrix Time: %4d.%03ds\n", (_INT)(gMTime/1000), (_INT)(gMTime%1000));

    fclose(file);
   }

  return 0;
 }

#if XRLV_DUMP_TRAJECTORY
/* ************************************************************************* */
/* *  Dump to file some statistics                                         * */
/* ************************************************************************* */
_INT XrlvDumpTrace(_INT ii, PS_point_type _PTR trace, p_CHAR name)
 {
  _INT    i, len;
  p_ULONG ptr;
  FILE *  file;

  if ((file = fopen(name, "wt")) != _NULL)
   {
    fprintf(file, "// **************************************************************************\n");
    fprintf(file, "// *    Trajectory ink file                                                 *\n");
    fprintf(file, "// **************************************************************************\n");

//    fprintf(file, "\n#include \"ams_mg.h\"  \n\n");

    len = ((ii-1)*sizeof(PS_point_type))/4; // len was in bytes
    fprintf(file, "unsigned long img_trace_body[%d] =  \n", len);
    fprintf(file, " {  \n");
    for (i = 0, ptr = (p_ULONG)trace+1; i < len; i ++, ptr ++)
     {
      fprintf(file, "0x%08X", *ptr);
      if (i < len-1) fprintf(file, ", ");
      if (i%8 == 7)  fprintf(file, "\n");
     }
    fprintf(file, " }; \n\n");

    fprintf(file, "// **************************************************************************\n");
    fprintf(file, "// *    Trajectory ink file end                                             *\n");
    fprintf(file, "// **************************************************************************\n");

    fclose(file);
   }

  return 0;
 }

#endif
#endif // PG_DEBUG

/* ************************************************************************* */
/*        END  OF ALL                                                        */
/* ************************************************************************* */
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\tr_util.cpp ===
/*****************************************************************************
 *
 * TR_UTIL.C                                    Created: Dec 29 1993
 * Last modification : Feb 16 1994
 *
 ****************************************************************************/

#include "hwr_sys.h"
#include "hwr_swap.h"

#include "ams_mg.h"
#include "triads.h"

#ifndef DUMP_TRD
#define DUMP_TRD 0
#endif

#ifndef ARMC
	#ifndef LOAD_RESOURCES_FROM_ROM
    	#ifdef PEGASUS
      		#define LOAD_RESOURCES_FROM_ROM     1
    	#else
      		#define LOAD_RESOURCES_FROM_ROM     0
    	#endif
    #endif
    #define LockRamParaData             HWRMemoryLockHandle
    #define UnlockRamParaData           HWRMemoryUnlockHandle
    #if HWR_SYSTEM == MACINTOSH
        #include "MyFopen.h"
    #else
    #endif
#else
    #define LOAD_RESOURCES_FROM_ROM     1
    p_VOID  LockRamParaData(_HMEM HData);    /* LoadResources.c */
    _BOOL   UnlockRamParaData(_HMEM HData);
#endif

#if !LOAD_RESOURCES_FROM_ROM
#include <stdio.h>

#if DUMP_TRD
  _INT DumpTriadsToC(_ULONG trd_len, p_tr_descr_type trd_descr);
#endif

/* ************************************************************************* */
/* *   Triads load                                                         * */
/* ************************************************************************* */

_INT triads_load(p_CHAR triadsname, _INT what_to_load, p_VOID _PTR tp)
 {
  FILE *               tr_file = _NULL;
  tr_header_type       tr_header;
  p_tr_descr_type      tr_descr = _NULL;
#if HWR_SYSTEM == MACINTOSH
  _HMEM                tr_descrH = _NULL;
#endif

  *tp = _NULL;


  /* ----------- Dig in file header -------------------------------------- */

#if HWR_SYSTEM == MACINTOSH
  if((tr_descrH = HWRMemoryAllocHandle(sizeof(tr_descr_type))) == _NULL) goto err;
  if((tr_descr = (p_tr_descr_type)HWRMemoryLockHandle(tr_descrH)) == _NULL)
   {
    HWRMemoryFreeHandle(tr_descrH);
    tr_descrH = _NULL;
    goto err;
   }
#else
  tr_descr = (p_tr_descr_type)HWRMemoryAlloc(sizeof(tr_descr_type));
#endif
  if (tr_descr == _NULL) goto err;
  HWRMemSet(tr_descr, 0, sizeof(*tr_descr));

  if ((tr_file = fopen(triadsname, "rb")) == _NULL) goto err;
  if (fread(&tr_header, 1, sizeof(tr_header), tr_file) != sizeof(tr_header)) goto err;

  HWRSwapLong(&tr_header.tr_offset);
  HWRSwapLong(&tr_header.tr_len);
  HWRSwapLong(&tr_header.tr_chsum);

  if (HWRStrnCmp(tr_header.object_type, TR_OBJTYPE, TR_ID_LEN) != 0) goto err;
  if ((what_to_load & TR_REQUEST) && tr_header.tr_offset == 0l) goto err;

  /* ----------- Begin load operations ----------------------------------- */

  HWRMemCpy(tr_descr->object_type, tr_header.object_type, TR_ID_LEN);
  HWRMemCpy(tr_descr->type, tr_header.type, TR_ID_LEN);
  HWRMemCpy(tr_descr->version, tr_header.version, TR_ID_LEN);
  HWRStrnCpy(tr_descr->tr_fname, triadsname, TR_FNAME_LEN-1);

  /* ----------- Beg Triads load operations ------------------------------------- */

  if (what_to_load & TR_REQUEST)
   {
     _ULONG  tr_i, tr_chsum;

    tr_descr->h_tr = HWRMemoryAllocHandle(tr_header.tr_len);
    if (tr_descr->h_tr == _NULL) goto err;
    tr_descr->p_tr = (p_UCHAR)HWRMemoryLockHandle((_HANDLE)tr_descr->h_tr);
    if (tr_descr->p_tr == _NULL) goto err;

    if (fseek(tr_file, tr_header.tr_offset, SEEK_SET) != 0) goto err;
    if (fread(tr_descr->p_tr, 1, (_UINT)tr_header.tr_len, tr_file) != tr_header.tr_len) goto err;

    for (tr_i = 0l, tr_chsum = 0l; tr_i < tr_header.tr_len; tr_i ++)
      tr_chsum += (_UCHAR)(*(tr_descr->p_tr + (_UINT)tr_i));

    if (tr_chsum != tr_header.tr_chsum) goto err;

#if DUMP_TRD
    DumpTriadsToC(tr_header.tr_len, tr_descr);
#endif

    HWRMemoryUnlockHandle((_HANDLE)tr_descr->h_tr); tr_descr->p_tr = _NULL;
   }


  /* ----------- Closing down -------------------------------------------- */

  fclose(tr_file); tr_file = _NULL;
#if HWR_SYSTEM == MACINTOSH
  HWRMemoryUnlockHandle(tr_descrH);
  *tp = (p_VOID _PTR)tr_descrH;
#else
  *tp = (p_VOID _PTR)tr_descr;
#endif

/* ----- Time to exit ----------------------------------------------------- */

  return 0;
err:
  if (tr_file)         fclose(tr_file);
  if (tr_descr->p_tr)  HWRMemoryUnlockHandle((_HANDLE)tr_descr->h_tr);
  if (tr_descr->h_tr)  HWRMemoryFreeHandle((_HANDLE)tr_descr->h_tr);
#if HWR_SYSTEM == MACINTOSH
  if (tr_descr)        HWRMemoryUnlockHandle(tr_descrH);
  if (tr_descrH)       HWRMemoryFreeHandle(tr_descrH);
#else
  if (tr_descr)        HWRMemoryFree(tr_descr);
#endif
  return 1;
 }

/* ************************************************************************* */
/*      Unload dat ingredients                                               */
/* ************************************************************************* */
_INT triads_unload(p_VOID _PTR tp)
 {
  p_tr_descr_type ptr = (p_tr_descr_type)(*tp);

#if HWR_SYSTEM == MACINTOSH
  ptr = (p_tr_descr_type)HWRMemoryLockHandle((_HMEM)(*tp));
  if (ptr == _NULL) HWRMemoryFreeHandle((_HMEM)(*tp));
#endif

  if (ptr != _NULL)
   {
    triads_unlock((p_VOID)ptr);

#if !LOAD_RESOURCES_FROM_ROM
    if (ptr->h_tr)  HWRMemoryFreeHandle((_HANDLE)ptr->h_tr);
#endif /* #if !LOAD_RESOURCES_FROM_ROM */

#if HWR_SYSTEM == MACINTOSH
    HWRMemoryUnlockHandle((_HMEM)(*tp));
    HWRMemoryFreeHandle((_HMEM)(*tp));
#else
    HWRMemoryFree(*tp);
#endif

    *tp = _NULL;
   }

  return 0;
 }

/* ************************************************************************* */
/* *   Writes  Triads to a disk file                                           * */
/* ************************************************************************* */
_INT triads_save(p_CHAR fname, _INT what_to_save, p_VOID tp)
 {

  UNUSED(fname);
  UNUSED(what_to_save);
  UNUSED(tp);

  /* Now it is empty ?! */
  /* Until somebody will need it ... */

  return 0;
 }

/* ************************************************************************* */
/* *   Lock Triads                                                           * */
/* ************************************************************************* */
_INT triads_lock(p_VOID tr_ptr)
 {
  p_tr_descr_type tp = (p_tr_descr_type)(tr_ptr);

  if (tp == _NULL) goto err;

  if (tp->p_tr == _NULL && tp->h_tr != _NULL)
   {
    tp->p_tr = (p_UCHAR)LockRamParaData((_HANDLE)tp->h_tr);
    if (tp->p_tr == _NULL) goto err;
   }

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/* *   UnLock DTI                                                          * */
/* ************************************************************************* */
_INT triads_unlock(p_VOID tr_ptr)
 {
  p_tr_descr_type tp = (p_tr_descr_type)(tr_ptr);

  if (tp == _NULL) goto err;

  if (tp->p_tr != _NULL && tp->h_tr != _NULL) {UnlockRamParaData((_HANDLE)tp->h_tr); tp->p_tr = _NULL;}

  return 0;
err:
  return 1;
 }
 
#endif /* #if !LOAD_RESOURCES_FROM_ROM */

/* ************************************************************************* */
/* ************************************************************************* */
/*        Debug functions                                                    */
/* ************************************************************************* */
/* ************************************************************************* */
#if DUMP_TRD
#include <stdio.h>
/* ************************************************************************* */
/*        Dump DTI to C file                                                 */
/* ************************************************************************* */
_INT DumpTriadsToC(_ULONG trd_len, p_tr_descr_type trd_descr)
 {
  _ULONG  i, len;
  p_ULONG ptr;
  FILE *  file;

  if ((file = fopen("trd_img.cpp", "wt")) != _NULL)
   {
    fprintf(file, "// **************************************************************************\n");
    fprintf(file, "// *    TRD file as C file                                                  *\n");
    fprintf(file, "// **************************************************************************\n");

    fprintf(file, "\n#include \"ams_mg.h\"  \n");
    fprintf(file, "#include \"triads.h\"  \n\n");

    fprintf(file, "// ****   DTI body   ********************************************************\n");

    len = trd_len/4; // len was in bytes
    fprintf(file, "ROM_DATA _ULONG img_trd_body[%d] =  \n", len + 1);
    fprintf(file, " {  \n");
    for (i = 0, ptr = (p_ULONG)trd_descr->p_tr; i < len; i ++, ptr ++)
     {
      fprintf(file, "0x%08X", *ptr);
      if (i < len-1) fprintf(file, ", ");
      if (i%8 == 7)  fprintf(file, "\n");
     }
    fprintf(file, " }; \n\n");

    fprintf(file, "// ****   TRD header   ******************************************************\n\n");

    fprintf(file, "ROM_DATA tr_descr_type img_trd_header =  \n");
    fprintf(file, " { \n");
    fprintf(file, "    {\"%s\"},    \n", trd_descr->tr_fname);
    fprintf(file, "    {'%c','%c','%c',0x%02X},    \n", trd_descr->object_type[0], trd_descr->object_type[1], trd_descr->object_type[2], trd_descr->object_type[3]);
    fprintf(file, "    {'%c','%c','%c',0x%02X},    \n", trd_descr->type[0], trd_descr->type[1], trd_descr->type[2], trd_descr->type[3]);
    fprintf(file, "    {'%c','%c','%c',0x%02X},    \n", trd_descr->version[0], trd_descr->version[1], trd_descr->version[2], trd_descr->version[3]);

    fprintf(file, "    0,                          // h_trd  \n");
    //fprintf(file, "  (p_UCHAR)&img_trd_body[0],    // p_trd  \n");
    fprintf(file, "    0,                          // p_trd  \n");
    fprintf(file, "    %d,                         // cheksum   \n", trd_descr->tr_chsum);

    fprintf(file, " }; \n\n");


    fprintf(file, "// **************************************************************************\n");
    fprintf(file, "// *    END OF ALL                                                          *\n");
    fprintf(file, "// **************************************************************************\n");

    fclose(file);
    err_msg("TRIADS output to trd_img.cpp.");
   }

  return 0;
 }

#endif

/* ************************************************************************* */
/*        END  OF ALL                                                        */
/* ************************************************************************* */
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xrwdictp.cpp ===
/* ************************************************************************* */
/*        XRW routines for dictionary interfacing                            */
/* ************************************************************************* */

#include "hwr_sys.h"
#include "ams_mg.h"                           /* Most global definitions     */
#include "zctype.h"

#if PS_VOC

#include "xrwdict.h"
#include "elk.h"
#include "xrword.h"
#include "vocutilp.h"
#if HWR_SYSTEM != MACINTOSH
    #include "ldbtypes.h"
    #include "ldbutil.h"
#endif

/* ************************************************************************* */
/*        Assign pointers to dictionaries to lex data structures             */
/* ************************************************************************* */
_INT AssignDictionaries(lex_data_type _PTR vs, rc_type _PTR rc)
 {
  vs->huserdict	= _NULL;

  // huserdict is actually an inferno wordlist pointer (if not NULL)
  if (rc->vocptr[0]) 
  {
	  vs->huserdict = rc->vocptr[0];
  }

  return 0;
 }

/* ************************************************************************* */
/*        Get letter buffer filled with possible vocabulary letters          */
/* ************************************************************************* */
_INT GF_VocSymbolSet(lex_data_type _PTR vs, fw_buf_type (_PTR fbuf)[XRWD_MAX_LETBUF], p_rc_type prc)
 {
  _INT   fbi = 0;
  p_fw_buf_type cfw;

//  if (vs->l_sym.sd[XRWD_N_VOC].l_status == XRWD_INIT) state = 0;
//   else state = vs->l_sym.sd[XRWD_N_VOC].state;

  if (vs->l_sym.sd[XRWD_N_VOC].l_status == XRWD_INIT) cfw = 0;
   else cfw = &vs->l_sym.sd[XRWD_N_VOC];

  fbi = ElkGetNextSyms(cfw, &((*fbuf)[0]), NULL, vs->l_sym.sources, vs->huserdict, prc);

  return fbi;
 }


/* ************************************************************************* */
/*        Get word attributes (Microlytics post-atttr version)               */
/* ************************************************************************* */
_INT GetWordAttributeAndID(lex_data_type _PTR vs, p_INT  src_id, p_INT stat)
 {
  _UCHAR status;
  _UCHAR attr;
  _INT   found = 0;

  //if ((vs->l_sym.sources & XRWD_SRCID_VOC) && vs->hdict)
  // Comment by Ahmad abulKader 04/18/00
  // We no longer load callig's dictionary we us Inferno's
  if ((vs->l_sym.sources & XRWD_SRCID_VOC))
   {

    if (ElkCheckWord((p_UCHAR)vs->word, &status, &attr, vs->huserdict)) goto err;

#if defined (FOR_GERMAN)
                    //ayv 072795 for covering german dictionary
     if( IsUpper(vs->word[0])) attr |= XRWS_VOC_FL_CAPSFLAG;
#endif

    *stat   = (_INT)(attr);
    *src_id = 0;
    found   = 1;
   }

  if (!found && (vs->l_sym.sources & XRWD_SRCID_LD))
   {
    *stat   = 0;
    *src_id = 1;
    found   = 1;
   }

  if (!found) goto err;

  return 0;
err:
  *stat   = 0;
  *src_id = 0;
  return 1;
 }


/* ************************************************************************* */
/* *    END OF ALLLLLLLLLLLLL                                              * */
/* ************************************************************************* */

#endif  /* PS_VOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xrw_util.cpp ===
/*****************************************************************************
 *
 * XRW_UTIL.C                                             Created: 07/03/91
 * Last modification : 10/15/91 01:50pm
 *
 * XrWord utility modules   PC-DOS/PC-WIN3.0/MAC/ATARI Portable version
 *
 ****************************************************************************/
#include "hwr_file.h"
#include "hwr_sys.h"
#include "hwr_swap.h"
#include "zctype.h"

#include "ams_mg.h"
#include "xrword.h"
#include "xrword_p.h"

/* ************************************************************************* */
/*        Single letter recognition algorithm                                */
/* ************************************************************************* */
_INT GetCharset(p_UCHAR charset, _INT cs_size, rc_type _PTR rc)
 {
  _INT    i, j;
  _INT    all_sorted;
  _INT    en_alc;


  charset[0] = 0;
  en_alc     = rc->enabled_cs;

//  if (rc->filter == FLT_NUMBER) en_alc = CS_NUMBER | CS_OTHER;

  i = HWRStrLen((_STR)&charset[0]);
  if ((en_alc & CS_ALPHA) && i + (_INT) HWRStrLen((_STR)rc->alpha_charset) < cs_size-2)
    HWRStrCpy((_STR)&charset[i], (_STR)rc->alpha_charset);

  i = HWRStrLen((_STR)&charset[0]);
  if ((en_alc & CS_NUMBER) && i + (_INT) HWRStrLen((_STR)rc->num_charset) < cs_size-2)
    HWRStrCpy((_STR)&charset[i], (_STR)rc->num_charset);

  i = HWRStrLen((_STR)&charset[0]);
  if ((en_alc & CS_MATH) && i + (_INT) HWRStrLen((_STR)rc->math_charset) < cs_size-2)
    HWRStrCpy((_STR)&charset[i], (_STR)rc->math_charset);

  i = HWRStrLen((_STR)&charset[0]);
  if ((en_alc & CS_LPUNCT) && i + (_INT) HWRStrLen((_STR)rc->lpunct_charset) < cs_size-2)
    HWRStrCpy((_STR)&charset[i], (_STR)rc->lpunct_charset);

  i = HWRStrLen((_STR)&charset[0]);
  if ((en_alc & CS_EPUNCT) && i + (_INT) HWRStrLen((_STR)rc->epunct_charset) < cs_size-2)
    HWRStrCpy((_STR)&charset[i], (_STR)rc->epunct_charset);

  i = HWRStrLen((_STR)&charset[0]);
  if ((en_alc & CS_OTHER) && i + (_INT) HWRStrLen((_STR)rc->other_charset) < 254)
    HWRStrCpy((_STR)&charset[i],(_STR) rc->other_charset);

  j = HWRStrLen((_STR)&charset[0]);

  all_sorted = 0;
  while (!all_sorted)
   {
    _UCHAR m;

    all_sorted = 1;
    for ( i = 1; i < j; i++)
     {
      if (charset[i] < charset[i-1])
       {
        m            = charset[i-1];
        charset[i-1] = charset[i];
        charset[i]   = m;
        all_sorted   = 0;
       }
     }
   }

  for (i = 1; i < j; i ++)
   {
    if (charset[i-1] == charset[i])
     {
      HWRMemCpy((_STR)&charset[i-1], (_STR)&charset[i], j - i + 1);
      j --;
      i --;
     }
   }

  return 0;
 }

/* ************************************************************************* */
/*  This function calculates the coeffs "a" and "b" of the  */
/* straight line with formula "y=a*x+b".  This line must be */
/* the best in terms of the least sum of (error squared).   */
/* ************************************************************************* */
_INT GetBaseBord(p_rc_type rc)
 {
 _INT  i;
 _INT  a;
 _UCHAR _PTR curv_bord = rc->curv_bord;
 _LONG SXY=0, SY=0;
 _INT  Dx = (rc->stroka.box.right - rc->stroka.box.left);
 _INT  Dy = (rc->stroka.box.bottom - rc->stroka.box.top);

  for(i=0; i <= (CB_NUM_VERTEX-1); i++)
   {
    SXY += i*(_LONG)((curv_bord[2*i]+curv_bord[2*i+1])/2);
    SY  +=   (_LONG)((curv_bord[2*i]+curv_bord[2*i+1])/2);
   }

  if(Dx != 0)
   {
    a = (_INT)(3*Dy*(2*SXY - (CB_NUM_VERTEX-1)*SY) / (Dx*(CB_NUM_VERTEX)*(CB_NUM_VERTEX+1)));
   }
   else a = 0;

  return a;
 }
 
#if defined(FOR_GERMAN) || defined(FOR_FRENCH) || defined (FOR_SWED) || defined (FOR_INTERNATIONAL)
ROM_DATA_EXTERNAL _CHAR DiacriticsLetter[]; //in ParaLibs.CPP
#endif /* FOR_GERMAN... */

/* ************************************************************************* */
/* *  Count box for a given xrdata elements line                           * */
/* ************************************************************************* */
_INT GetSymBox(_UCHAR sym, _INT st, _INT end, p_xrdata_type xrdata, p_RECT box)
 {
  _INT                      j;
  _INT                      fl_punct = IsPunct(sym);
  _INT                      yt, yb, ytp, ybp, set, setp;
  _INT                      xl, xr, xlp, xrp;
  _INT                      fl_crest = 0;
//  xrlw_gr_data_type_array  (_PTR xrlg)[XRINP_SIZE] = xd->xrlg;
//  p_xrlw_gr_data_type_array pxrlg;
//  p_xrd_type                xrd = xd->xrdata->xrd;
  p_xrd_el_type             xel;

  if (st >= end) goto err;

  xel = &((*xrdata->xrd)[st]);
  yt  = ytp = 32000; yb = ybp = 0; set = setp = 0;
  xl  = xlp = 32000; xr = xrp = 0;
  for (j = st; j < end; j ++, xel ++)
   {
    if (IsXrLink(xel)) continue;
    if (GetXrMovable(xel))
     {
      if (ytp > xel->box_up   ) ytp = xel->box_up;
      if (ybp < xel->box_down ) ybp = xel->box_down;
      if (xlp > xel->box_left ) xlp = xel->box_left;
      if (xrp < xel->box_right) xrp = xel->box_right;
      if (xel->xr.type != X_ST) fl_crest ++;
      setp ++;
     }
     else
     {
      if (yt > xel->box_up   ) yt = xel->box_up;
      if (yb < xel->box_down ) yb = xel->box_down;
      if (xl > xel->box_left ) xl = xel->box_left;
      if (xr < xel->box_right) xr = xel->box_right;
      set ++;
     }
   }

  if (set < 2) // Less than 2 normal els in letter
   {
    if (!setp)
     {
      yt = yb = (*xrdata->xrd)[0].box_up;   // Nothing at alll???
      xl = xr = (*xrdata->xrd)[0].box_left; // Nothing at alll???
     }
     else
     {
      if (set) {yt = HWRMin(yt,ytp); yb = HWRMax(yb,ybp);xl = HWRMin(xl,xlp); xr = HWRMax(xr,xrp);}
       else {yt = ytp; yb = ybp; xl = xlp; xr = xrp;}
     }
   }

  if (fl_punct && setp) {yt = HWRMin(yt,ytp); yb = HWRMax(yb,ybp);xl = HWRMin(xl,xlp); xr = HWRMax(xr,xrp);}

  box->top    = (_SHORT)yt;
  box->bottom = (_SHORT)yb;
  box->left   = (_SHORT)xl;
  box->right  = (_SHORT)xr;

  if (fl_crest && setp) // Widen box for letters like capital 'T' and 'E' and 'I'
   {
#if defined(FOR_GERMAN) || defined(FOR_FRENCH) || defined (FOR_SWED) || defined (FOR_INTERNATIONAL)
    if (HWRStrChr((p_CHAR)DiacriticsLetter, sym) == _NULL)
#endif /* FOR_GERMAN... */
     {
      yt = HWRMin(yt,ytp); yb = HWRMax(yb,ybp);xl = HWRMin(xl,xlp); xr = HWRMax(xr,xrp);
      if (yt < box->top)
       {
        if (box->top-yt > (box->bottom - box->top)/3) box->top -= (box->bottom - box->top)/3;
          else box->top = (_SHORT)yt;
       }

      if (yb > box->bottom)
       {
        if (yb - box->bottom > (box->bottom - box->top)/3) box->bottom += (box->bottom - box->top)/3;
          else box->bottom = (_SHORT)yb;
       }
     }
   }

  return 0;
err:
  return 1;
 }


/* ************************************************************************* */
/*        END  OF ALL                                                        */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xrnet.c ===
#include "common.h"
#include "runnet.h"
#include "resource.h"
#include "bear.h"
#include "bearp.h"
#include "pegrec.h"
#include "peg_util.h"
#include "xrwdict.h"
#include "xrword.h"
#include "xrlv.h"
#include "ws.h"
#include "polyco.h"


#define	MIN_XR_NET		1
#define	MAX_XR_NET		14
#define NUM_XR_NET		(MAX_XR_NET - MIN_XR_NET + 1)

#define	XR_FEAT			25

static	int			s_aiXRNetSize[NUM_XR_NET]	=	{0};
static	LOCAL_NET	s_aXRNet[NUM_XR_NET];

BOOL LoadXRNets(HINSTANCE hInst)
{
	void		*pRet = NULL;
	int			i, iResSize;
	
	// was it loaded before
	if (s_aiXRNetSize[0] > 0)
	{
		return TRUE;
	}

	for (i = MIN_XR_NET; i <= MAX_XR_NET; i++)
	{
		pRet = loadNetFromResource(hInst, RESID_BEAR_XRNET_1 + i - MIN_XR_NET, &iResSize);
		if ( !pRet || !restoreLocalConnectNet(pRet, 0, s_aXRNet + i - MIN_XR_NET))
		{
			return FALSE;
		}

		s_aiXRNetSize[i - MIN_XR_NET] = getRunTimeNetMemoryRequirements(pRet);
		if (s_aiXRNetSize[i - MIN_XR_NET] <= 0)
		{
			return FALSE;
		}		
	}

	return TRUE;
}


void UnLoadXRNets()
{
	
}

int Convert2BitMap (int iVal, int cVal, int *pFeat)
{
	int		i		=	cVal, 
			j		=	iVal,
			cFeat	=	0;
	
	while (i > 1)
	{
		pFeat[cFeat++]	=	((j % 2) == 1 ? 65535 : 0);

		i	=	i >> 1;
		j	=	j >> 1;
	}

	return cFeat;
}

int RunXRNet (int cXR, int *pFeat, BYTE *pOutput)
{	
	RREAL			*pNetMem,
					*pNetOut;

	int				i, 
					iWinner, 
					cOut,
					cFeat;

	_UCHAR			*pOut2Char	= (p_UCHAR)MLP_NET_SYMCO;
	
	memset (pOutput, 0, 256 * sizeof (*pOutput));
	if (!s_aiXRNetSize[0] || cXR <= MIN_XR_NET || cXR >= MAX_XR_NET)
	{			
		return -1;
	}

	// allocate net memory
	pNetMem		=	
		(RREAL *) ExternAlloc (s_aiXRNetSize[cXR - MIN_XR_NET] * sizeof (*pNetMem));

	if (!pNetMem)
		return FALSE;

	cFeat	=	XR_FEAT * cXR;

	for (i = 0; i < cFeat; i++)
	{
		pNetMem[i]	=	pFeat[i];
	}

	pNetOut	=	runLocalConnectNet(s_aXRNet + cXR - MIN_XR_NET, pNetMem, &iWinner, &cOut);
	if (!pNetOut)
	{
		ExternFree (pNetMem);
		return 0;
	}

	//ASSERT (cOut == (int)strlen (pOut2Char));

	for (i = 0; pOut2Char[i] != '\0' && i < cOut; i++)
	{
		if (pOut2Char[i] == ' ')
		{
			continue;
		}

		pOutput[pOut2Char[i]]	=	(BYTE)(min (255, 256 * pNetOut[i] / SOFT_MAX_UNITY));		
	}

	ExternFree (pNetMem);

	return pOut2Char[iWinner];
}

void GetXRNetOutput (int iXRSt, int cXR, p_xrdata_type xrdata, _UCHAR *pOut)
{
	int		aFeat[MAX_XR_NET * XR_FEAT];
	int		i,
			cFeat	=	0;

#ifdef HWX_TIMING
#include <madTime.h>
	extern void setMadTiming(DWORD, int);
	TCHAR aDebugString[256];
	DWORD	iStartTime, iEndTime;
	iStartTime = GetTickCount();
#endif

	memset (pOut, 0, 256 * sizeof (*pOut));

	if (!s_aiXRNetSize[0] || cXR <= MIN_XR_NET || cXR >= MAX_XR_NET)
	{
		return;
	}

	// featurize
	for (i = 0; i < cXR; i++)
	{
		cFeat +=	Convert2BitMap ((*xrdata->xrd)[i + iXRSt].xr.type, 64, aFeat + cFeat);		
		cFeat +=	Convert2BitMap ((*xrdata->xrd)[i + iXRSt].xr.height, 16, aFeat + cFeat);
		cFeat +=	Convert2BitMap ((*xrdata->xrd)[i + iXRSt].xr.shift, 16, aFeat + cFeat);
		cFeat +=	Convert2BitMap ((*xrdata->xrd)[i + iXRSt].xr.depth, 16, aFeat + cFeat);		
		cFeat +=	Convert2BitMap ((*xrdata->xrd)[i + iXRSt].xr.orient, 32, aFeat + cFeat);

		aFeat[cFeat++]	=	((*xrdata->xrd)[i + iXRSt].xr.penalty << 12) - 1;
		aFeat[cFeat++]	=	((*xrdata->xrd)[i + iXRSt].xr.attrib & TAIL_FLAG) ? 65535 : 0;
	}

	RunXRNet (cXR, aFeat, pOut);

#ifdef HWX_TIMING
#include <madTime.h>
	iEndTime = GetTickCount();

	_stprintf(aDebugString, TEXT("Running Xr net %d\n"), iEndTime - iStartTime); 
	OutputDebugString(aDebugString);
	setMadTiming(iEndTime - iStartTime, MM_XR_NET);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xr_mc.cpp ===
/* ************************************************************************* */
/*        Correlation matrix support programs                                */
/* ************************************************************************* */
/* * Created 12/4/1993  AVP  Last modification date 4/22/1994               * */
/* ************************************************************************* */

#include "ams_mg.h"                           /* Most global definitions     */
#include "zctype.h"

#include "xrword.h"                           /* Definition for use as engine*/
#include "xrword_p.h"                         /* Debug information include   */

#if defined PEGASUS && !defined PSR_DLL
 #define XRMC_ENWORDROUTINES 0
 #define XRMC_ENTRACING      0
#else
 #define XRMC_ENWORDROUTINES 1
 #define XRMC_ENTRACING      1
#endif

#if ASM_MCORR
  #define CountXr  CountXrAsm
  #define TCountXr TCountXrAsm
#else
  #define CountXr  CountXrC
  #define TCountXr TCountXrC
#endif

#ifdef _FOR_THINK_C
#include "IntDraw.h"
#endif


#undef XRMC_SEPLET_PEN // Temp test
#define XRMC_SEPLET_PEN        4                  /* Penalty for enforcing separate letter mode */


#if !(defined LSTRIP && defined PEGASUS)

/* ************************************************************************* */
/*        Allocate memory for matrix counting and init its variables         */
/* ************************************************************************* */
_INT  xrmatr_alloc(p_rc_type rc, p_xrdata_type xrd, p_xrcm_type _PTR xrcm)
 {
  _INT       i;
  _INT       xi_len, xrinp_len;
  _INT       shift;
  _INT       n_links;
  _ULONG     alloc_size, cc_size;
  p_VOID     alloc_addr;
  xrcm_type  _PTR xm;
  p_UCHAR    mem;

  for (xrinp_len = 0, n_links = 0; xrinp_len < xrd->len; xrinp_len ++)
    if (IS_XR_LINK((*xrd->xrd)[xrinp_len].xr.type)) n_links ++;

  xi_len =  xrinp_len - (xrinp_len%4) + 8;

/* ------------------------- Count needed memory --------------------------- */

  cc_size     = sizeof(xrcm_cc_pos_type)*n_links;
  alloc_size  = 0;
  alloc_size += sizeof(xrcm_type);

  alloc_size += sizeof(_USHORT)*xi_len;                    /*  s_inp_line    */
  alloc_size += sizeof(_USHORT)*xi_len;                    /*  s_out_line    */
  alloc_size += sizeof(_USHORT)*xi_len*DTI_MAXVARSPERLET;  /*  s_res_lines   */
  alloc_size += sizeof(_USHORT)*xi_len;                    /*  p_self_corr   */
  alloc_size += sizeof(xrinp_type)*xi_len;                 /*  inp string   */
  if (rc->corr_mode & XRCM_CACHE) alloc_size += cc_size;   /* Allocate cache if requested */

  alloc_size += 8;                                         /* DWORD align    */

  if ((alloc_addr = HWRMemoryAlloc(alloc_size)) == _NULL) goto err;
  HWRMemSet(alloc_addr, 0, (_USHORT)alloc_size);

/* ------------------------- Assign pointers ------------------------------- */

  mem                = (p_UCHAR)alloc_addr;
  xm                 = (p_xrcm_type)alloc_addr;
  xm->allocated      = alloc_size;

  shift              = sizeof(xrcm_type);
  shift              = shift - (shift%4) + 4;

  xm->s_inp_line     = (p_cline_type)(mem+shift); shift += sizeof(_USHORT)*xi_len;
  xm->s_out_line     = (p_cline_type)(mem+shift); shift += sizeof(_USHORT)*xi_len;
  for (i = 0; i < DTI_MAXVARSPERLET; i ++) {xm->s_res_lines[i]= (p_cline_type)(mem+shift); shift += sizeof(_USHORT)*xi_len;}
  xm->p_self_corr    = (p_SHORT)(mem+shift); shift += sizeof(_USHORT)*xi_len;
  xm->xrinp          = (xrinp_type (_PTR)[XRINP_SIZE])(mem+shift); shift += sizeof(xrinp_type)*xi_len;
  if (rc->corr_mode & XRCM_CACHE)
    {xm->cc_size = cc_size; xm->cc = (p_xrcm_cc_type)(mem+shift);/* shift += sizeof(xrcm_cc_pos_type)*n_links;*/}

/* ------------------------- Write default values -------------------------- */

  xm->caps_mode      = rc->caps_mode;

  xm->cmode          = xm->caps_mode;
  xm->corr_mode      = rc->corr_mode;
  xm->en_ww          = rc->enabled_ww;
  xm->en_languages   = rc->enabled_languages;
  xm->flags         |= (_UCHAR)((rc->use_vars_inf) ? XRMC_USELEARNINF : 0);
  xm->flags         |= (_UCHAR)(XRMC_DISABLEON7);
  xm->bad_amnesty    = rc->bad_amnesty;
  xm->xrinp_len      = xrinp_len;

  xm->p_dte          = (p_dti_descr_type)rc->dtiptr;
  xm->vexbuf         = (p_dte_vex_type)(xm->p_dte)->p_vex;

  for (i = 0; i < xrinp_len; i ++) (*xm->xrinp)[i] = (*xrd->xrd)[i].xr;

//  for (i = 0; i < xrinp_len; i ++) xm->p_self_corr[i] = (_SHORT)(i * (XRMC_DEF_CORR_VALUE*4 - xm->bad_amnesty));
  SetWWCLine(xm->bad_amnesty, xm);

  xm->self_weight    = (xrinp_len-1)*XRMC_DEF_CORR_VALUE;

  change_direction(0, xm);

  *xrcm = xm;

  XRCM_ALLOC_1

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*        Deallocate matrix memory                                           */
/* ************************************************************************* */
_INT  xrmatr_dealloc(p_xrcm_type _PTR xrcm)
 {

  if (*xrcm == _NULL) goto err;
  HWRMemoryFree(*xrcm);
  *xrcm = _NULL;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*       Set order of xrcm fields to required direction                      */
/* ************************************************************************* */
_INT change_direction(_INT change_to, p_xrcm_type xrcm)
 {
  _INT         i, j;
  _INT         direction, len, len1;
  xrinp_type   txr;
  p_xrinp_type xi;

  direction = xrcm->inverse;
  if (change_to > 1) xrcm->inverse ^= 0x01;
   else xrcm->inverse = change_to;

  if (xrcm->inverse != direction)            /* Inverse xrinp if needed */
   {
    len  = (xrcm->xrinp_len-1)/2;
    len1 = xrcm->xrinp_len-1;
    for (i = 1; i <= len; i ++, len1 --)
     {
      txr                  = (*xrcm->xrinp)[len1];
      (*xrcm->xrinp)[len1] = (*xrcm->xrinp)[i];
      (*xrcm->xrinp)[i]    = txr;
     }
    if (xrcm->cc) HWRMemSet(xrcm->cc, 0, xrcm->cc_size);
   }

  if (xrcm->inverse)
   {
    xrcm->merge_results  = 0;
    xrcm->switch_to_best = 0;
   }
   else
   {
    xrcm->merge_results  = 1;
    xrcm->switch_to_best = 1;
   }

  if (xrcm->inverse)  // Inverse pass set link info
   {
    len  = xrcm->xrinp_len-1;
    xi   = &(*xrcm->xrinp)[2];

    for (i = 2, j = 1; i <= len; i ++, xi ++)
      if (IS_XR_LINK(xi->type)) xrcm->link_index[i-1] = (_CHAR)(j ++); else xrcm->link_index[i-1] = 0;
    xrcm->link_index[len] = (_UCHAR)(j);
   }
   else               // direct pass link info
   {
    len  = xrcm->xrinp_len-1;
    xi   = &(*xrcm->xrinp)[1];

    for (i = 1, j = 1; i <= len; i ++, xi ++)
      if (IS_XR_LINK(xi->type)) xrcm->link_index[i] = (_UCHAR)(j ++); else xrcm->link_index[i] = 0;
   }

  SetWWCLine(xrcm->bad_amnesty, xrcm);

  return 0;
 }

#if XRMC_ENWORDROUTINES
/* ************************************************************************* */
/*       Count correlation of whole word                                     */
/* ************************************************************************* */
_INT CountWord(p_UCHAR word, _INT caps_mode, _INT flags, p_xrcm_type xrcm)
 {
  _INT    l;
  _INT    wl;
  _INT    st, end, w;
  _UCHAR  sym;
  _INT    mfl = xrcm->flags;
//  p_SHORT ma = _NULL;
//  _INT    ma_loc = 0;

  xrcm->flags = flags;
  wl = HWRStrLen((p_CHAR)word);
  if (wl >= w_lim) goto err;
  HWRStrCpy((p_CHAR)xrcm->word, (p_CHAR)word);

  if (flags & XRMC_DOTRACING) {if (TraceAlloc(wl, xrcm)) goto err;}

  xrcm->wwc_pos = xrcm->src_pos;
  for (l = 0; l < wl; l ++)
   {
    xrcm->let   = sym = xrcm->word[l];
    xrcm->cmode = XCM_AL_DEFSIZE;
    xrcm->src_pos = xrcm->wwc_pos;
    xrcm->svm     = xrcm->var_mask[l];

    if (IsAlpha(sym))
     {
      if ((l == 0 && xrcm->inverse == 0) || (l == wl-1 && xrcm->inverse != 0))
       {
        if (caps_mode & XCM_FL_TRYCAPSp)    xrcm->cmode |= XCM_AL_TRYCAPS;
        if (caps_mode & XCM_AL_TRYS4Cp)     xrcm->cmode |= XCM_AL_TRYS4C;
        if (!(caps_mode & XCM_FL_DEFSIZEp)) xrcm->cmode &= ~(XCM_AL_DEFSIZE);
       }
       else                                               /* Not first letter */
       {
        if (caps_mode & XCM_AL_TRYCAPSp)    xrcm->cmode |= XCM_AL_TRYCAPS;
        if (caps_mode & XCM_AL_TRYS4Cp)     xrcm->cmode |= XCM_AL_TRYS4C;
        if (!(caps_mode & XCM_AL_DEFSIZEp)) xrcm->cmode &= ~(XCM_AL_DEFSIZE);
       }
     }

    if (flags & XRMC_DOTRACING)
     {
      p_let_hdr_type plh = (p_let_hdr_type)(TDwordAdvance(sizeof(let_hdr_type), xrcm));

      if (plh == _NULL) goto err;
      HWRMemSet(plh, 0, sizeof(let_hdr_type));

      xrcm->p_htrace->lhdrs[l] = plh;
      xrcm->let_htr            = plh;
      xrcm->cur_let_num        = l;
     }

    if (CountLetter(xrcm)) goto err;

    if (flags & XRMC_DOTRACING)
     {
      HWRMemCpy(xrcm->p_htrace->ma+xrcm->p_htrace->ma_loc, &((*xrcm->s_out_line)[0]), xrcm->xrinp_len*sizeof(_SHORT));
      xrcm->p_htrace->ma_loc += xrcm->xrinp_len;
     }

    w = (*xrcm->s_out_line)[xrcm->wwc_pos] - (XRMC_DEF_CORR_VALUE*5);
    for (st = xrcm->v_start; st < xrcm->wwc_pos-2 && (*xrcm->s_out_line)[st] < w; st ++);

    w += (XRMC_DEF_CORR_VALUE*2);
    for (end = xrcm->v_end-1; end > xrcm->wwc_pos+2 && (*xrcm->s_out_line)[end] < w; end --);
    end ++;

    SetInpLine((p_SHORT)(&(*xrcm->s_out_line)[st]), st, end - st, xrcm);
   }

  if (flags & XRMC_DOTRACING)
   {
    if (CreateLayout(xrcm)) goto err;
    FillLetterWeights(xrcm->p_htrace->ma, xrcm);
    TraceDealloc(xrcm);
   }


  xrcm->flags = mfl;

  return 0;
err:
  xrcm->flags = mfl;
  TraceDealloc(xrcm);
//  if (ma) HWRMemoryFree(ma);
  return 1;
 }

/* ************************************************************************* */
/*       Count correlation of letter (cap and decap if needed)               */
/* ************************************************************************* */
_INT CountLetter(p_xrcm_type xrcm)
 {
  _INT   d;
  _INT   cmode = xrcm->cmode;
  _INT   m_fl  = xrcm->flags;
  _UCHAR let, sym, altsym;

  let = sym = xrcm->let;
  altsym = 0;
  xrcm->flags &= ~(XRMC_CHECKCAPBITS | XRMC_RESTRICTEDCAP);

  if (IsAlpha(let))
   {
    if ((cmode & XCM_AL_DEFSIZEp) == 0) sym = 0;
    if (IsLower(let))                                     /* Smalls */
     {                                                    /* First letter */
      if ((cmode & XCM_AL_TRYCAPSp) != 0) altsym = (_UCHAR)ToUpper(let);
     }
     else
     {
      if ((cmode & XCM_AL_TRYS4Cp) != 0) altsym = (_UCHAR)ToLower(let);
     }

    if (!(sym && altsym) && xrcm->vexbuf != _NULL && !(xrcm->flags & XRMC_DISABLECAPBITS))
      xrcm->flags |= XRMC_CHECKCAPBITS;
   }

  if (sym == 0) {sym = altsym; altsym = 0;}

  if (sym && altsym) xrcm->flags |= XRMC_CACHESUSPEND;

  xrcm->sym     = sym;
  xrcm->realsym = sym;
  xrcm->wwc_delt= 0;

  if (xrcm->flags & XRMC_DOTRACING)
   {
    p_sym_hdr_type psh = (p_sym_hdr_type)(TDwordAdvance(sizeof(sym_hdr_type), xrcm));

    if (psh == _NULL) goto err;
    HWRMemSet(psh, 0, sizeof(sym_hdr_type));

    xrcm->sym_htr           = psh;
    xrcm->let_htr->shdrs[0] = psh;
    xrcm->let_htr->syms[0]  = sym;

    xrcm->sym_htr->sym      = sym;
    xrcm->cur_alt_num       = 0;

    psh->sym                = sym;
   }

  if (CountSym(xrcm)) goto err;

  if (xrcm->flags & XRMC_DOTRACING)
   {
    xrcm->let_htr->v_start  = xrcm->sym_htr->v_start;
    xrcm->let_htr->v_end    = xrcm->sym_htr->v_end;
   }

  if (altsym)
   {
    _INT   wc, wwc, wwc_pos, v_start, v_end, end_wc;
    _SHORT mbuf[XRINP_SIZE];

    _UCHAR vars[XRINP_SIZE];
    xrcm->sym = altsym;

    if (IsLower(altsym)) xrcm->flags |= XRMC_RESTRICTEDCAP;
    wc      = xrcm->wc;
    wwc     = xrcm->wwc;
    wwc_pos = xrcm->wwc_pos;
    end_wc  = xrcm->end_wc;
    v_start = xrcm->v_start;
    v_end   = xrcm->v_end;
    GetOutLine(mbuf, xrcm->v_start, xrcm->v_end - xrcm->v_start, xrcm);
    HWRMemCpy(vars, xrcm->nvar_vect, sizeof(vars));

    if (xrcm->flags & XRMC_DOTRACING)
     {
      p_sym_hdr_type psh = (p_sym_hdr_type)(TDwordAdvance(sizeof(sym_hdr_type), xrcm));

      if (psh == _NULL) goto err;
      HWRMemSet(psh, 0, sizeof(sym_hdr_type));

      xrcm->sym_htr           = psh;
      xrcm->let_htr->shdrs[1] = psh;
      xrcm->let_htr->syms[1]  = altsym;

      xrcm->sym_htr->sym      = altsym;
      xrcm->cur_alt_num       = 1;
     }

    if (CountSym(xrcm)) goto err;

    if (xrcm->wwc > wwc) {xrcm->realsym = altsym; d = xrcm->wwc - wwc + 1;}
      else d = (wwc - xrcm->wwc) + 1;
    xrcm->wwc_delt = (_UCHAR)((d > 0xff) ? 0xff : d);
    if (xrcm->end_wc < end_wc) xrcm->end_wc = end_wc;

       /* Altsym is worse than sym -- restore prev or flag not to switch to better alt sym*/
//    if (xrcm->wwc <= wwc || !xrcm->switch_to_best)
//     {
//      xrcm->wc      = wc;
//      xrcm->wwc     = wwc;
//      xrcm->wwc_pos = wwc_pos;
//      xrcm->v_start = v_start;
//      xrcm->v_end   = v_end;
//      SetOutLine(mbuf, v_start, v_end - v_start, xrcm);
//     }
//     else
//     {
//      xrcm->realsym = altsym;
//      MergeWithOutLine(mbuf, v_start, v_end - v_start, xrcm);
//     }

       /* Altsym is worse than sym -- restore prev or flag not to switch to better alt sym*/
    if (xrcm->wwc <= wwc || !xrcm->switch_to_best)
     {
      xrcm->wc      = wc;
      xrcm->wwc     = wwc;
      xrcm->wwc_pos = wwc_pos;
      xrcm->v_start = v_start;
      xrcm->v_end   = v_end;
      SetOutLine(mbuf, v_start, v_end - v_start, xrcm);
      HWRMemCpy(xrcm->nvar_vect, vars, sizeof(vars));
     }
      if (xrcm->switch_to_best) MergeWithOutLine(mbuf, v_start, v_end - v_start, xrcm);
//       else SetOutLine(mbuf, v_start, v_end - v_start, xrcm);
     }

  COUNT_LETTER_1

  xrcm->flags = m_fl;

  return 0;
err:
  xrcm->flags = m_fl;
  return 1;
 }

#endif // if XRMC_ENWORDROUTINES

/* ************************************************************************* */
/*       Count correlation of symbol                                         */
/* ************************************************************************* */
_INT CountSym(p_xrcm_type xrcm)
 {
  _INT                  v;
  _INT                  len;
  _INT                  cstate = 0;
  _INT                  count_var;
  _UCHAR                sym;
  p_dti_descr_type      dp = (p_dti_descr_type)xrcm->p_dte;
  p_dte_sym_header_type sfc;
 #if DTI_COMPRESSED
  p_dte_var_header_type xrpv;
  p_dte_index_type      plt;
 #else
  p_xrp_type            xrpv;
  p_let_table_type      plt;
 #endif

#ifdef _FOR_THINK_C
  INT_DRAW(1)
#endif

  sym = (_UCHAR)OSToRec(xrcm->sym);
  if (sym < DTI_FIRSTSYM || sym >= DTI_FIRSTSYM+DTI_NUMSYMBOLS) goto err;

//#if CACHE // Under construction
  if (xrcm->cc && (!(xrcm->flags & (XRMC_DOTRACING | XRMC_CACHESUSPEND))))
   {
    _INT loc;

    cstate = 2;                             /* Need to be counted and cached */
    loc = xrcm->link_index[xrcm->src_pos];


    if ((*xrcm->cc)[loc][sym-DTI_FIRSTSYM].pos) cstate = 1;  /* Need not to be counted -- already in cache */
    if (!loc) cstate = 0;
   }
//#endif

  if (!(cstate & 0x01))
   {
    sfc = _NULL;

   #if DTI_COMPRESSED
    if (dp->p_ram_dte != _NULL) // Is RAM dte present?
     {
      plt = (p_dte_index_type)dp->p_ram_dte;
      if (plt->sym_index[sym] != 0l) sfc = (p_dte_sym_header_type)(dp->p_ram_dte + (plt->sym_index[sym] << 2));
     }
    if (sfc == _NULL && dp->p_dte != _NULL) // Is ROM dte present?
     {
      plt = (p_dte_index_type)dp->p_dte;
      if (plt->sym_index[sym] != 0l) sfc = (p_dte_sym_header_type)(dp->p_dte + (plt->sym_index[sym] << 2));
     }
   #else
    if (dp->p_ram_dte != _NULL) // Is RAM dte present?
     {
      plt = (p_let_table_type)dp->p_ram_dte;
      if ((*plt)[sym] != 0l) sfc = (p_dte_sym_header_type)(dp->p_ram_dte + (*plt)[sym]);
     }
    if (sfc == _NULL && dp->p_dte != _NULL) // Is ROM dte present?
     {
      plt = (p_let_table_type)dp->p_dte;
      if ((*plt)[sym] != 0l) sfc = (p_dte_sym_header_type)(dp->p_dte + (*plt)[sym]);
     }
   #endif

    if (sfc == _NULL) goto err; // Pointer was 0!, symbol not defined
    if (sfc->num_vars == 0) goto err;

    xrcm->sfc = sfc;
    if ((xrcm->flags & XRMC_USELEARNINF) && xrcm->vexbuf != _NULL)
      HWRMemCpy(xrcm->vb, (&((*xrcm->vexbuf)[sym-DTI_FIRSTSYM])), sizeof (xrcm->vb));

   #if DTI_COMPRESSED
    xrcm->plt = plt;
    xrpv = (p_dte_var_header_type)((p_UCHAR)sfc + sizeof(dte_sym_header_type));
   #else
    xrpv = (p_xrp_type)((p_UCHAR)sfc + sizeof(dte_sym_header_type));
   #endif

    for (v = 0; v < DTI_MAXVARSPERLET; v ++)
     {
      count_var = 1; len = 0;

      if (v >= sfc->num_vars) count_var = 0;
     #if DTI_COMPRESSED
      if (count_var && (len = xrpv->nx_and_vex & DTI_NXR_MASK) < 1) count_var = 0;
      if (count_var && (xrpv->veis & (_UCHAR)(xrcm->en_ww << DTI_OFS_WW)) == 0) count_var = 0;
      if (count_var && (xrcm->flags & XRMC_RESTRICTEDCAP) && (xrpv->veis & (_UCHAR)(DTI_CAP_BIT))) count_var = 0;
      if (!(xrcm->flags & XRMC_USELEARNINF)) xrcm->vb[v] = (_UCHAR)(xrpv->nx_and_vex >> DTI_VEX_OFFS);
      if (count_var && (xrcm->flags & XRMC_DISABLEON7) && (xrcm->vb[v] & 0x07) == 7) count_var = 0;
     #else
      if (count_var && (len = sfc->var_lens[v]) < 1) count_var = 0;
      if (count_var && (sfc->var_veis[v] & (_UCHAR)(xrcm->en_ww << DTI_OFS_WW)) == 0) count_var = 0;
      if (count_var && (xrcm->flags & XRMC_RESTRICTEDCAP) && (sfc->var_veis[v] & (_UCHAR)(DTI_CAP_BIT))) count_var = 0;
      if (!(xrcm->flags & XRMC_USELEARNINF)) xrcm->vb[v] = (_UCHAR)(sfc->var_vexs[v]);
      if (count_var && (xrcm->flags & XRMC_DISABLEON7) && (xrcm->vb[v] & 0x07) == 7) count_var = 0;
     #endif
      if (count_var && (xrcm->svm & (0x0001 << v))) count_var = 0;
      if (count_var && xrcm->vexbuf != _NULL && (xrcm->flags & XRMC_CHECKCAPBITS))
       {
        p_UCHAR  capbuf = (p_UCHAR)xrcm->vexbuf + DTI_SIZEOFVEXT;

        if ((capbuf[((sym-DTI_FIRSTSYM)*DTI_MAXVARSPERLET+v)>>3] & (0x01 << (v%8))) != 0)
          count_var = 0;
       }


      if (count_var)
       {
        xrcm->xrpv     = xrpv;
        xrcm->var_len  = len;
        xrcm->inp_line = xrcm->s_inp_line;
        xrcm->out_line = xrcm->s_res_lines[v];

        COUNT_SYM_1

       #if XRMC_ENTRACING
        if (xrcm->flags & XRMC_DOTRACING)
         {
          p_var_hdr_type pvh = (p_var_hdr_type)(TDwordAdvance(sizeof(var_hdr_type), xrcm));

          if (pvh == _NULL) goto err;
          HWRMemSet(pvh, 0, sizeof(var_hdr_type));

          xrcm->var_htr           = pvh;
          xrcm->sym_htr->vhdrs[v] = pvh;

          pvh->sym                = xrcm->sym;
          pvh->var_num            = (_UCHAR)v;
          pvh->var_len            = (_UCHAR)len;

          xrcm->cur_var_num       = v;
         }
       #endif // XRMC_ENTRACING

        if (CountVar(xrcm)) goto err;

        xrcm->vste[v].st  = (_UCHAR)xrcm->res_st;
        xrcm->vste[v].end = (_UCHAR)xrcm->res_end;
       }
       else
       {
        xrcm->vste[v].st  = xrcm->vste[v].end = 0;
       }

     #if DTI_COMPRESSED
      if (len) xrpv = (p_dte_var_header_type)((p_UCHAR)xrpv + sizeof(*xrpv) + (len-1)*sizeof(xrp_type));
     #else
      xrpv += len;
     #endif
     }

    if (MergeVarResults(xrcm)) goto err;
   }

//#if CACHE // Under construction
  if (cstate)
   {
    _INT loc;

    _INT pos;
    _INT w;
    _INT en = xrcm->xrinp_len-1;
    loc = xrcm->link_index[xrcm->src_pos];

    if (cstate == 1) // Restore from cache
     {

      pos = (*xrcm->cc)[loc][sym-DTI_FIRSTSYM].pos;
      w   = (*xrcm->cc)[loc][sym-DTI_FIRSTSYM].dw + (*xrcm->s_inp_line)[xrcm->src_pos];

      (*xrcm->s_out_line)[pos] = (_SHORT)w;
      if (pos > 1)  (*xrcm->s_out_line)[pos-2] = (_SHORT)(w - 2*XRMC_DEF_CORR_VALUE);
      if (pos > 0)  (*xrcm->s_out_line)[pos-1] = (_SHORT)(w -   XRMC_DEF_CORR_VALUE);
      if (pos < en) (*xrcm->s_out_line)[pos+1] = (_SHORT)(w -   XRMC_DEF_CORR_VALUE);
      if (pos <=en) (*xrcm->s_out_line)[pos+2] = (_SHORT)(w - 2*XRMC_DEF_CORR_VALUE);

      xrcm->v_start = (pos-2 >  0)  ? pos-2 : 0;
      xrcm->v_end   = (pos+2 <= en) ? pos+2 : en+1;

      xrcm->wwc     = (w << 2) - xrcm->p_self_corr[pos];
      xrcm->wwc_pos = pos;
      xrcm->wc      = w;
      xrcm->end_wc  = (pos == en) ? w : XRMC_FLOOR;
     }

    if (cstate == 2) // Put down in cache
     {
      w = (*xrcm->s_out_line)[xrcm->wwc_pos] - (*xrcm->s_inp_line)[xrcm->src_pos];
      pos = xrcm->link_index[xrcm->wwc_pos];
      if (pos == loc && w >= 0) pos = 0; // Do not cache uneven vars

//      if (pos) // > loc)
      if (pos > loc || w < -20)
       {
        if (w < -127) w = -127; if (w > 127) w = 127;
        (*xrcm->cc)[loc][sym-DTI_FIRSTSYM].pos = (_UCHAR)(xrcm->wwc_pos);
        (*xrcm->cc)[loc][sym-DTI_FIRSTSYM].dw  = (_SCHAR)(w);
       }
     }
   }
//#endif

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*       Count correlation of one variant                                    */
/* ************************************************************************* */
_INT CountVar(p_xrcm_type xrcm)
 {
  _INT  n;
  _INT  inc;
  _INT  len, limit;
  _INT  pos;

  pos   = (xrcm->src_pos > 0) ? xrcm->src_pos : 1;
  len   = xrcm->var_len;
//  limit = pos + len;
  limit = xrcm->src_end + len;
  if (limit > xrcm->xrinp_len) limit = xrcm->xrinp_len;

 #if DTI_COMPRESSED
  if (xrcm->inverse == 0) {inc = 1; xrcm->xrp = xrcm->xrpv->xrs;}
   else {inc = -1; xrcm->xrp = xrcm->xrpv->xrs + (len-1);}
 #else
  if (xrcm->inverse == 0) {inc = 1; xrcm->xrp = xrcm->xrpv;}
   else {inc = -1; xrcm->xrp = xrcm->xrpv + (len-1);}
 #endif

  COUNT_VAR_1

  for (n = 0; n < len; n ++, xrcm->xrp += inc)
   {
    xrcm->inp_start  = xrcm->src_st + ((n > (len>>1)) ? (n-(len>>1)) : 0);
    if (xrcm->inp_start > pos-1) xrcm->inp_start = pos-1;
    xrcm->inp_end    = xrcm->src_end + n + 1;
    if (xrcm->inp_end   > limit) xrcm->inp_end = limit;

   #if XRMC_ENTRACING
    if (xrcm->flags & XRMC_DOTRACING)
     {
      _INT len;
      p_xrp_hdr_type pxh;

      len = xrcm->inp_end - xrcm->inp_start;
      pxh = (p_xrp_hdr_type)(TDwordAdvance(sizeof(xrp_hdr_type) - (XRINP_SIZE-len), xrcm));
//      if (pxh == _NULL) goto err;

      xrcm->xrp_htr           = pxh;
      xrcm->var_htr->xhdrs[n] = pxh;

      pxh->sym                = xrcm->sym;
      pxh->xr                 = xrcm->xrp->type;
      pxh->st                 = (_UCHAR)xrcm->inp_start;
      pxh->len                = (_UCHAR)(len);

      TCountXr(xrcm);
     }
     else
    #endif // XRMC_ENTRACING
     {
//      p_SHORT p;

      CountXr(xrcm);

//      p = (p_SHORT)xrcm->out_line;
//      xrcm->out_line =  xrcm->s_res_lines[15];
//      CountXr(xrcm);
//      xrcm->out_line = (_SHORT (_PTR)[120])p;
     }

    xrcm->inp_line = xrcm->out_line;

    COUNT_VAR_2
   }

  xrcm->res_st  = xrcm->inp_start;
  xrcm->res_end = xrcm->inp_end;

  return 0;
 }

#if !ASM_MCORR
#if DTI_COMPRESSED
/* ************************************************************************* */
/*       Count correlation of one XR (may be assembler!)                     */
/* ************************************************************************* */
_INT CountXrC(p_xrcm_type xrcm)
 {
  _INT         ppip, ppic;
  _INT         vm, vpp, vpi;
  _INT         vc, ct;
//  _UCHAR       t, h, s, z, o;
//  _UCHAR       ct, ch, cs, cz, co;
  _UCHAR       sh_ct, sh_ch, sh_cs, sh_cz, sh_co;
//  _INT         st, en;
  _UCHAR       pp;
  p_SHORT      lp, lc, le;
  p_UCHAR      xtc, xhc, xsc, xzc, xoc;
  p_xrp_type   xrp;
  p_xrinp_type pxrinp;

//  st   = xrcm->inp_start;
//  en   = xrcm->inp_end;

//  ppip = (*lp)[en-1];
//  ppic = (*lp)[en];
//  pcip = 0;

  xrp  = xrcm->xrp;
  xtc  = xrcm->plt->xt_palette[xrp->xtc];
  xhc  = xrcm->plt->xh_palette[xrp->xhc];
  xsc  = xrcm->plt->xs_palette[xrp->xsc];
  xzc  = xrcm->plt->xz_palette[xrp->xzc];
  xoc  = xrcm->plt->xo_palette[xrp->xoc];
  pp   = (_UCHAR)(xrp->penl & DTI_PENL_MASK);

  sh_ct = (_UCHAR)((xrp->type & DTI_XT_LSB) ? 4 : 0);
  sh_ch = (_UCHAR)((xrp->type & DTI_XH_LSB) ? 4 : 0);
  sh_cs = (_UCHAR)((xrp->type & DTI_XS_LSB) ? 4 : 0);
  sh_cz = (_UCHAR)((xrp->type & DTI_XZ_LSB) ? 4 : 0);
  sh_co = (_UCHAR)((xrp->type & DTI_XO_LSB) ? 4 : 0);

  lp     = &(*xrcm->inp_line)[xrcm->inp_start];
  lc     = &(*xrcm->out_line)[xrcm->inp_start];
  le     = lc + (xrcm->inp_end - xrcm->inp_start);
  pxrinp = &(*xrcm->xrinp)[xrcm->inp_start];

  ppic = vm = 0;

  for (; lc < le; lc ++, lp ++, pxrinp ++)
   {
    ppip = vc = ppic - XRMC_BALLANCE_COEFF;
    ppic = *lp;

    if (!((xrp->attr & TAIL_FLAG) && !(pxrinp->attrib & TAIL_FLAG)))
     {
      ct  = ((xtc[pxrinp->type] >> sh_ct) & 0x0F);
      if (ct > 0) vc  = ppip + ct + ((xhc[pxrinp->height] >> sh_ch) & 0x0F) +
                                    ((xsc[pxrinp->shift]  >> sh_cs) & 0x0F) +
                                    ((xzc[pxrinp->depth]  >> sh_cz) & 0x0F) +
                                    ((xoc[pxrinp->orient] >> sh_co) & 0x0F);
     }

    vpp = ppic - pp;
    vpi = vm - pxrinp->penalty;

    vm  = (vpp > vpi) ? vpp : vpi;
    vm  = (vm  > vc)  ? vm : vc;

    *lc = (_SHORT)vm;
   }

  *lc = 0;

  return 0;
 }

#if 0
#if VERTIGO
    if ((xrp->attr & XRB_ST_ELEM) && !(pxrinp->attrib & XRB_ST_ELEM))
      goto mix;
    if ((xrp->attr & XRB_EN_ELEM) && !(pxrinp->attrib & XRB_EN_ELEM))
      goto mix;
#else
    if ((xrp->attr & TAIL_FLAG) && !(pxrinp->attrib & TAIL_FLAG)) goto mix;
#endif

    ct  = (_UCHAR)((xrp->type & DTI_XT_LSB) ? xtc[pxrinp->type] >> 4 : xtc[pxrinp->type] & 0x0F);
    if (ct == 0) goto mix;

    ch  = (_UCHAR)((xrp->type & DTI_XH_LSB) ? xhc[pxrinp->height] >> 4 : xhc[pxrinp->height] & 0x0F);
    cs  = (_UCHAR)((xrp->type & DTI_XS_LSB) ? xsc[pxrinp->shift] >> 4  : xsc[pxrinp->shift] & 0x0F);
    cz  = (_UCHAR)((xrp->type & DTI_XZ_LSB) ? xzc[pxrinp->depth] >> 4  : xzc[pxrinp->depth] & 0x0F);
    co  = (_UCHAR)((xrp->type & DTI_XO_LSB) ? xoc[pxrinp->orient] >> 4 : xoc[pxrinp->orient] & 0x0F);

//co = 12; // AVP TMP create DTI

    vc  = (_SHORT)(ppip + ct + ch + cs + cz + co);
#endif
#if 0
    t   = pxrinp->type;
    ct  = xtc[t/2];
    ct  = (_UCHAR)((t & 1) ? ct & 0x0F : ct >> 4);
    if (ct == 0) goto mix;

    h   = pxrinp->height;
    ch  = xhc[h/2];
    ch  = (_UCHAR)((h & 1) ? ch & 0x0F : ch >> 4);
//    if (ch == 0)  goto mix;

    s   = pxrinp->shift;
    cs  = xsc[s/2];
    cs  = (_UCHAR)((s & 1) ? cs & 0x0F : cs >> 4);

    z   = pxrinp->depth;
    cz  = xzc[z/2];
    cz  = (_UCHAR)((z & 1) ? cz & 0x0F : cz >> 4);

    o   = pxrinp->orient;
    co  = xoc[o/2];
    co  = (_UCHAR)((o & 1) ? co & 0x0F : co >> 4);

//co = 12; // AVP TMP create DTI

    vc  = (_SHORT)(ppip + ct + ch + cs + cz + co);
#endif

//    vc  = (_SHORT)(ppip + xtc[pxrinp->type] + xhc[pxrinp->height] +
//                   xsc[pxrinp->shift] + xzc[pxrinp->depth] + xoc[pxrinp->orient]);
#if XRMC_ENTRACING
/* ************************************************************************* */
/*       Count correlation of one XR (may be assembler!)                     */
/* ************************************************************************* */
_INT TCountXrC(p_xrcm_type xrcm)
 {
  _INT         i;
  _SHORT       ppip, ppic, pcip;
  _SHORT       vm, vpp, vpi;
  _SHORT       vc;
//  _UCHAR       t, h, s, z, o;
  _UCHAR       v;
  _UCHAR       ct, ch, cs, cz, co;
  _INT         st, en;
  _UCHAR       pp;
  p_cline_type lp, lc;
  p_xrp_type   xrp;
  p_UCHAR      xtc, xhc, xsc, xzc, xoc;
  _UCHAR       (_PTR tv)[XRINP_SIZE];
  p_xrinp_type pxrinp;

  lp   = xrcm->inp_line;
  lc   = xrcm->out_line;

  st   = xrcm->inp_start;
  en   = xrcm->inp_end;

//  ppip = (*lp)[en-1];
//  ppic = (*lp)[en];
//  pcip = 0;

  ppic = vm = 0;

  xrp  = xrcm->xrp;
  xtc  = xrcm->plt->xt_palette[xrp->xtc];
  xhc  = xrcm->plt->xh_palette[xrp->xhc];
  xsc  = xrcm->plt->xs_palette[xrp->xsc];
  xzc  = xrcm->plt->xz_palette[xrp->xzc];
  xoc  = xrcm->plt->xo_palette[xrp->xoc];
  pp   = (_UCHAR)(xrp->penl & DTI_PENL_MASK);

  pxrinp = &(*xrcm->xrinp)[st];

  tv   = &(xrcm->xrp_htr->vects);

  for (i = st; i < en; i ++, pxrinp ++)
   {
    ppip = vc = (_SHORT)(ppic - XRMC_BALLANCE_COEFF);
    ppic = (*lp)[i];
    pcip = vm;

    vpp = (_SHORT)(ppic - pp);
    vpi = (_SHORT)(pcip - pxrinp->penalty);

#if VERTIGO
    if ((xrp->attr & XRB_ST_ELEM) && !(pxrinp->attrib & XRB_ST_ELEM))
      goto mix;
    if ((xrp->attr & XRB_EN_ELEM) && !(pxrinp->attrib & XRB_EN_ELEM))
      goto mix;
#else
    if ((xrp->attr & TAIL_FLAG) && !(pxrinp->attrib & TAIL_FLAG)) goto mix;
#endif

    ct  = (_UCHAR)((xrp->type & DTI_XT_LSB) ? xtc[pxrinp->type] >> 4 : xtc[pxrinp->type] & 0x0F);
    if (ct == 0) goto mix;

    ch  = (_UCHAR)((xrp->type & DTI_XH_LSB) ? xhc[pxrinp->height] >> 4 : xhc[pxrinp->height] & 0x0F);
    cs  = (_UCHAR)((xrp->type & DTI_XS_LSB) ? xsc[pxrinp->shift] >> 4  : xsc[pxrinp->shift] & 0x0F);
    cz  = (_UCHAR)((xrp->type & DTI_XZ_LSB) ? xzc[pxrinp->depth] >> 4  : xzc[pxrinp->depth] & 0x0F);
    co  = (_UCHAR)((xrp->type & DTI_XO_LSB) ? xoc[pxrinp->orient] >> 4 : xoc[pxrinp->orient] & 0x0F);

    vc  = (_SHORT)(ppip + ct + ch + cs + cz + co);

#if 0
    t   = pxrinp->type;
    ct  = xtc[t/2];
    ct  = (_UCHAR)((t & 1) ? ct & 0x0F : ct >> 4);
    if (ct == 0)  goto mix;

    h   = pxrinp->height;
    ch  = xhc[h/2];
    ch  = (_UCHAR)((h & 1) ? ch & 0x0F : ch >> 4);
//    if (ch == 0)  goto mix;

    s   = pxrinp->shift;
    cs  = xsc[s/2];
    cs  = (_UCHAR)((s & 1) ? cs & 0x0F : cs >> 4);

    z   = pxrinp->depth;
    cz  = xzc[z/2];
    cz  = (_UCHAR)((z & 1) ? cz & 0x0F : cz >> 4);

    o   = pxrinp->orient;
    co  = xoc[o/2];
    co  = (_UCHAR)((o & 1) ? co & 0x0F : co >> 4);

//co = 12; // AVP TMP create DTI

    vc  = (_SHORT)(ppip + ct + ch + cs + cz + co);
#endif

//    vc  = (_SHORT)(ppip + xtc[pxrinp->type] + xhc[pxrinp->height] +
//                   xsc[pxrinp->shift] + xzc[pxrinp->depth] + xoc[pxrinp->orient]);
    mix:;

    if (vpp > vpi) {vm = vpp; v = XRMC_T_PSTEP;} else {vm = vpi; v = XRMC_T_ISTEP;}
    if (vc  > vm)  {vm = vc;  v = XRMC_T_CSTEP;}

    (*lc)[i]    = vm;
    (*tv)[i-st] = v;
   }

  (*lc)[i] = 0;

  return 0;
err:
  return 1;
 }
#endif //XRMC_ENTRACING
#else  // ifdef DTI_COMPRESSED

/* ************************************************************************* */
/*       Count correlation of one XR (may be assembler!)                     */
/* ************************************************************************* */
_INT CountXrC(p_xrcm_type xrcm)
 {
  _INT         i;
  _SHORT       ppip, ppic, pcip;
  _SHORT       vm, vpp, vpi;
  _SHORT       vc;
  _UCHAR       t, h, s, z, o;
  _UCHAR       ct, ch, cs, cz, co;
  _INT         st, en;
  _UCHAR       pp;
  p_cline_type lp, lc;
  p_xrp_type   xrp;
  p_UCHAR      xtc, xhc, xsc, xzc, xoc;
  p_xrinp_type pxrinp;

  lp   = xrcm->inp_line;
  lc   = xrcm->out_line;

  st   = xrcm->inp_start;
  en   = xrcm->inp_end;

//  ppip = (*lp)[en-1];
//  ppic = (*lp)[en];
//  pcip = 0;

  ppic = vm = 0;

  xrp  = xrcm->xrp;
  xtc  = xrp->xtc;
  xhc  = xrp->xhc;
  xsc  = xrp->xsc;
  xzc  = xrp->xzc;
  xoc  = xrp->xoc;
  pp   = xrp->penl;

  pxrinp = &(*xrcm->xrinp)[st];

  for (i = st; i < en; i ++, pxrinp ++)
   {
    ppip = vc = (_SHORT)(ppic - XRMC_BALLANCE_COEFF);
    ppic = (*lp)[i];
    pcip = vm;

    vpp = (_SHORT)(ppic - pp);
    vpi = (_SHORT)(pcip - pxrinp->penalty);

#if VERTIGO
    if ((xrp->attr & XRB_ST_ELEM) && !(pxrinp->attrib & XRB_ST_ELEM))
      goto mix;
    if ((xrp->attr & XRB_EN_ELEM) && !(pxrinp->attrib & XRB_EN_ELEM))
      goto mix;
#else
    if ((xrp->attr & TAIL_FLAG) && !(pxrinp->attrib & TAIL_FLAG)) goto mix;
#endif

    t   = pxrinp->type;
    ct  = xtc[t/2];
    ct  = (_UCHAR)((t & 1) ? ct & 0x0F : ct >> 4);
    if (ct == 0) goto mix;

    h   = pxrinp->height;
    ch  = xhc[h/2];
    ch  = (_UCHAR)((h & 1) ? ch & 0x0F : ch >> 4);
//    if (ch == 0)  goto mix;

    s   = pxrinp->shift;
    cs  = xsc[s/2];
    cs  = (_UCHAR)((s & 1) ? cs & 0x0F : cs >> 4);

    z   = pxrinp->depth;
    cz  = xzc[z/2];
    cz  = (_UCHAR)((z & 1) ? cz & 0x0F : cz >> 4);

    o   = pxrinp->orient;
    co  = xoc[o/2];
    co  = (_UCHAR)((o & 1) ? co & 0x0F : co >> 4);

//co = 12; // AVP TMP create DTI

    vc  = (_SHORT)(ppip + ct + ch + cs + cz + co);

    mix:;

    vm  = (vpp > vpi) ? vpp : vpi;
    vm  = (vm  > vc)  ? vm : vc;

    (*lc)[i] = vm;
   }

  (*lc)[i] = 0;

  return 0;
 }
#if XRMC_ENTRACING
/* ************************************************************************* */
/*       Count correlation of one XR (may be assembler!)                     */
/* ************************************************************************* */
_INT TCountXrC(p_xrcm_type xrcm)
 {
  _INT         i;
  _SHORT       ppip, ppic, pcip;
  _SHORT       vm, vpp, vpi;
  _SHORT       vc;
  _UCHAR       t, h, s, z, o;
  _UCHAR       v;
  _UCHAR       ct, ch, cs, cz, co;
  _INT         st, en;
  _UCHAR       pp;
  p_cline_type lp, lc;
  p_xrp_type   xrp;
  p_UCHAR      xtc, xhc, xsc, xzc, xoc;
  _UCHAR       (_PTR tv)[XRINP_SIZE];
  p_xrinp_type pxrinp;

  lp   = xrcm->inp_line;
  lc   = xrcm->out_line;

  st   = xrcm->inp_start;
  en   = xrcm->inp_end;

//  ppip = (*lp)[en-1];
//  ppic = (*lp)[en];
//  pcip = 0;

  ppic = vm = 0;

  xrp  = xrcm->xrp;
  xtc  = xrp->xtc;
  xhc  = xrp->xhc;
  xsc  = xrp->xsc;
  xzc  = xrp->xzc;
  xoc  = xrp->xoc;
  pp   = xrp->penl;

  pxrinp = &(*xrcm->xrinp)[st];

  tv   = &(xrcm->xrp_htr->vects);

  for (i = st; i < en; i ++, pxrinp ++)
   {
    ppip = vc = (_SHORT)(ppic - XRMC_BALLANCE_COEFF);
    ppic = (*lp)[i];
    pcip = vm;

    vpp = (_SHORT)(ppic - pp);
    vpi = (_SHORT)(pcip - pxrinp->penalty);

#if VERTIGO
    if ((xrp->attr & XRB_ST_ELEM) && !(pxrinp->attrib & XRB_ST_ELEM))
      goto mix;
    if ((xrp->attr & XRB_EN_ELEM) && !(pxrinp->attrib & XRB_EN_ELEM))
      goto mix;
#else
    if ((xrp->attr & TAIL_FLAG) && !(pxrinp->attrib & TAIL_FLAG)) goto mix;
#endif

    t   = pxrinp->type;
    ct  = xtc[t/2];
    ct  = (_UCHAR)((t & 1) ? ct & 0x0F : ct >> 4);
    if (ct == 0)  goto mix;

    h   = pxrinp->height;
    ch  = xhc[h/2];
    ch  = (_UCHAR)((h & 1) ? ch & 0x0F : ch >> 4);
//    if (ch == 0)  goto mix;

    s   = pxrinp->shift;
    cs  = xsc[s/2];
    cs  = (_UCHAR)((s & 1) ? cs & 0x0F : cs >> 4);

    z   = pxrinp->depth;
    cz  = xzc[z/2];
    cz  = (_UCHAR)((z & 1) ? cz & 0x0F : cz >> 4);

    o   = pxrinp->orient;
    co  = xoc[o/2];
    co  = (_UCHAR)((o & 1) ? co & 0x0F : co >> 4);

//co = 12; // AVP TMP create DTI

    vc  = (_SHORT)(ppip + ct + ch + cs + cz + co);

    mix:;

    if (vpp > vpi) {vm = vpp; v = XRMC_T_PSTEP;} else {vm = vpi; v = XRMC_T_ISTEP;}
    if (vc  > vm)  {vm = vc;  v = XRMC_T_CSTEP;}

    (*lc)[i]    = vm;
    (*tv)[i-st] = v;
   }

  (*lc)[i] = 0;

  return 0;
//err:
//  return 1;
 }

#endif // XRMC_ENTRACING

#endif // ifdef DTI_COMPRESSED

#endif // #if !ASM_MCORR

/* ************************************************************************* */
/*       Join results of separate variants to output line and count WWC      */
/* ************************************************************************* */
_INT MergeVarResults(p_xrcm_type xrcm)
 {
  register p_SHORT ol, pl; //, psc;
  _INT             i, v;
  _INT             st, en, nv;
  _INT             vs, ve;
  _INT             wwc, wwc_pos, comp_pos;
  p_SHORT          psc;
  _INT             vex;
  p_st_end_type    vste = xrcm->vste;
  _UCHAR     (_PTR vb)[DTI_MAXVARSPERLET] = &xrcm->vb;

  MERGE_VAR_RES_1

  st = XRINP_SIZE;
  en = 0;
  for (v = 0, nv = 0; v < DTI_MAXVARSPERLET; v ++)
   {
    if (vste[v].end == 0) continue;
    if (st > vste[v].st)  st = vste[v].st;
    if (en < vste[v].end) en = vste[v].end;
    nv ++;
   }

  if (nv == 0)
   {
    xrcm->wwc     =
    xrcm->wwc_pos =
    xrcm->wc      =
    xrcm->end_wc  = XRMC_FLOOR;
    xrcm->v_start =
    xrcm->v_end   = 0;
    goto done;
   }

  for (i = st, ol = &(*xrcm->s_out_line)[st]; i < en; i ++) *(ol++) = XRMC_FLOOR;

  if (xrcm->flags & XRMC_DOTRACING)
   {
    p_sym_hdr_type psh = xrcm->sym_htr;

    psh->v_start  = (_UCHAR)st;
    psh->v_end    = (_UCHAR)en;
    psh->num_vars = (_UCHAR)nv;
   }


  for (v = 0; v < DTI_MAXVARSPERLET; v ++)
   {
    vs = vste[v].st;
    ve = vste[v].end;

    MERGE_VAR_RES_2

    if (ve == 0) continue;

    ol = &(*xrcm->s_out_line)[vs];
    pl = &((*(xrcm->s_res_lines[v]))[vs]);

    vex = ((*vb)[v] & 0x07) << 1;

//    if (xrcm->flags & XRMC_DISABLEON7) vex = ((*vb)[v] & 0x07) << 1;
//     else vex = ((*vb)[v] & 0x07);

    if (xrcm->flags & XRMC_DOTRACING)
     {
      p_UCHAR mv = &(xrcm->sym_htr->merge_vect[vs]);

      p_UCHAR gmv = &(xrcm->nvar_vect[vs]);

      for (i = vs; i < ve; i ++, ol ++, pl ++, mv ++, gmv ++)
       {
        if (*ol < (*pl-vex)) {*ol = (_SHORT)(*pl-vex); *mv = *gmv = (_UCHAR)v;}
       }
     }
     else
     {
      p_UCHAR gmv = &(xrcm->nvar_vect[vs]);

      for (i = vs; i < ve; i ++, ol ++, pl ++, gmv ++)
        if (*ol < (*pl-vex)) {*ol = (_SHORT)(*pl-vex); *gmv = (_UCHAR)v;}
     }

    MERGE_VAR_RES_3
   }

  if (xrcm->corr_mode & XRCM_SEPLET) /* Allow letter ends on breaks only */
   {
    ol = &(*xrcm->s_out_line)[st];

    for (i = st; i < en; i ++, ol ++)
      if (xrcm->link_index[i] == 0) *ol -= (_SHORT)(XRMC_SEPLET_PEN);
   }

  xrcm->v_start = st;
  xrcm->v_end   = en;

 /* =============== Count WWC and its pos ==================================== */
#if 1
  wwc     = 0;
  wwc_pos = (st > 0) ? st : 2;
  ol      = &(*xrcm->s_out_line)[wwc_pos];
  psc     = &(xrcm->p_self_corr)[wwc_pos];
  for (i = wwc_pos; i < en; i ++)
   {
    if (wwc <= (comp_pos = (*(ol++) << 2) - *(psc++))) {wwc = comp_pos; wwc_pos = i;}
   }

  xrcm->wwc     = wwc;
  xrcm->wwc_pos = wwc_pos;
  xrcm->wc      = (*xrcm->s_out_line)[wwc_pos];
#endif
 /* ========================================================================== */

  xrcm->end_wc  = (en == xrcm->xrinp_len) ? (*xrcm->s_out_line)[en-1] : XRMC_FLOOR;

  MERGE_VAR_RES_4

done:
  return 0;
 }

/* ************************************************************************* */
/*       Set starting default values of input line                           */
/* ************************************************************************* */
_INT SetInitialLine(_INT count, p_xrcm_type xrcm)
 {
  SetInpLineByValue(XRMC_CONST_CORR, 0, count, xrcm);
  xrcm->src_pos = 0;
  return 0;
 }

/* ************************************************************************* */
/*       Set initial values of correlation                                   */
/* ************************************************************************* */
_INT SetInpLine(p_SHORT p_line, _INT st, _INT count, p_xrcm_type xrcm)
 {
  _INT    i;
  p_SHORT il = &(*xrcm->s_inp_line)[st];
  p_SHORT pl = p_line;

  if (st > 0) *(il-1) = XRMC_FLOOR;
  for (i = st; i < count+st && i < xrcm->xrinp_len; i ++)
   {
    *(il++) = *(pl++);
   }
  *il = XRMC_FLOOR;

  xrcm->src_st  = st;
  xrcm->src_end = i;

  return 0;
 }

/* ************************************************************************* */
/*       Set initial values of correlation                                   */
/* ************************************************************************* */
_INT SetInpLineByValue(_INT value, _INT st, _INT count, p_xrcm_type xrcm)
 {
  _INT    i, p;
  p_SHORT il = &(*xrcm->s_inp_line)[st];

  if (st > 0) *(il-1) = XRMC_FLOOR;
  *il = (_SHORT)value;
  p = 0;
  for (i = st+1, il ++; i < count+st && i < xrcm->xrinp_len; i ++, il ++)
   {
    p  += (*xrcm->xrinp)[i].penalty;
    *il = (_SHORT)(value - p);
    if ((xrcm->corr_mode & XRCM_SEPLET) && xrcm->link_index[i] == 0)
      *il -= (_SHORT)(XRMC_SEPLET_PEN);
   }

  *il = XRMC_FLOOR;

  xrcm->src_st  = st;
  xrcm->src_end = i;

  return 0;
 }

/* ************************************************************************* */
/*       Set values to output vector                                         */
/* ************************************************************************* */
_INT SetOutLine(p_SHORT p_line, _INT st, _INT count, p_xrcm_type xrcm)
 {
  register _INT    i;
  register p_SHORT ol = &(*xrcm->s_out_line)[st];
  register p_SHORT pl = p_line;

  for (i = 0; i < count; i ++) *(ol++) = *(pl++);

  return 0;
 }

/* ************************************************************************* */
/*       Merge given vector values with output line                          */
/* ************************************************************************* */
_INT MergeWithOutLine(p_SHORT p_line, _INT st, _INT count, p_xrcm_type xrcm)
 {
  _INT    i;
  p_SHORT ol = &(*xrcm->s_out_line)[0];
  p_SHORT pl = p_line;
  _INT    mst, mend, vst, vend, end;

  vst  = mst  = xrcm->v_start;
  vend = mend = xrcm->v_end;
  end  = st+count;

  if (vst > st) vst = st;
  if (vend < end) vend = end;
  if (vend > xrcm->xrinp_len) vend = xrcm->xrinp_len;

  if (xrcm->flags & XRMC_DOTRACING)
   {
    p_let_hdr_type plh = xrcm->let_htr;
    p_UCHAR        mv  = plh->merge_vect;

    if (xrcm->merge_results == 0)
     {
      for (i = vst; i < vend; i ++) mv[i] = 1;
      goto done;
     }

    plh->v_start = vst;
    plh->v_end   = vend;

    for (i = vst; i < vend; i ++)
     {
      if (i < st) {mv[i] = 1; continue;}          // Extr has not started yet
      if (i < mst) {ol[i] = pl[i-st]; mv[i] = 0; continue;}  // Intr has not started yet

      if (i >= end) {mv[i] = 1; continue;}        // Extr has finished
      if (i >= mend) {ol[i] = pl[i-st]; mv[i] = 0; continue;}// Intr has finished

      if (pl[i-st] >= ol[i]) {ol[i] = pl[i-st]; mv[i] = 0;}// Both present -- compare
       else mv[i] = 1;
     }
   }
   else
   {
    if (xrcm->merge_results == 0) goto done;

    for (i = vst; i < vend; i ++)
     {
      if (i < st) continue;                       // Extr has not started yet
      if (i < mst) {ol[i] = pl[i-st]; continue;}  // Intr has not started yet

      if (i >= end) continue;                     // Extr has finished
      if (i >= mend) {ol[i] = pl[i-st]; continue;}// Intr has finished

      if (pl[i-st] >= ol[i]) ol[i] = pl[i-st];     // Both present -- compare
     }
   }

  xrcm->v_start = vst;
  xrcm->v_end   = vend;

done:
  return 0;
 }

/* ************************************************************************* */
/* *    Return some number as final weight of matrix count                 * */
/* ************************************************************************* */
_INT GetFinalWeight(p_xrcm_type xrcm)
 {
  _INT i, wc;

#if 0
  _INT         end;
  p_cline_type mbuf;
/*  _SHORT  start, max; */
/*  register _INT st;   */

  end   = xrcm->v_end;
  mbuf  = xrcm->s_out_line;

#if 0
  start = xrcm->v_start;
  for (st = start, max = 0; st < end; st ++)
    if (max < (_INT)mbuf[st]) max = (*mbuf)[st];

  if (xrcm->wwc_pos < xrcm->xrinp_len - XR_SIZE) goto err;
#endif

//  wc = max;                                    /* Max element   */
//  wc = xrcm->wc;                             /* Max wwc el    */


  if ((wc -= XRMC_CONST_CORR) < 0) wc = 0;

  return wc;
err:
  return 0;
#else

#if 0
  return  (xrcm->end_wc - XRMC_CONST_CORR < 0) ? 0 : xrcm->end_wc - XRMC_CONST_CORR;
#else
  if (xrcm->v_end == xrcm->xrinp_len)
   {
    wc = xrcm->end_wc - XRMC_CONST_CORR;
   }
   else
   {
    wc = (*xrcm->s_out_line)[xrcm->v_end-1] - XRMC_CONST_CORR;   /* Last  element */
    for (i = xrcm->v_end; wc > 0 && i < xrcm->xrinp_len; i ++) wc -= (*xrcm->xrinp)[i].penalty;
   }

  return (wc > 0) ? wc : 0;
#endif

#endif
 }

/* ************************************************************************* */
/*        Advance used memory pointer and report if not enough memory        */
/* ************************************************************************* */
_INT  SetWWCLine(_INT ba, p_xrcm_type xrcm)
 {
  _INT i;

  for (i = 0; i < xrcm->xrinp_len; i ++)
    xrcm->p_self_corr[i] = (_SHORT)(i * (XRMC_DEF_CORR_VALUE*4 - ba));

  xrcm->cur_ba = ba;

  return 0;
 }

#if XRMC_ENTRACING
/* ************************************************************************* */
/*       Get resulting vector of correlation                                 */
/* ************************************************************************* */
_INT GetOutLine(p_SHORT p_line, _INT st, _INT count, p_xrcm_type xrcm)
 {
  register _INT    i;
  register p_SHORT ol = &(*xrcm->s_out_line)[st];
  register p_SHORT pl = p_line;
  _INT     vs, ve;

  vs = xrcm->v_start;
  ve = xrcm->v_end;
  for (i = st; i < count+st; i ++, pl ++, ol ++)
   {
    if (i >= vs && i < ve) *pl = *ol; else *pl = XRMC_FLOOR;
   }

  return 0;
 }

/* ************************************************************************* */
/*       Get results of correlation to tag buffer                            */
/* ************************************************************************* */
_INT GetOutTB(_SHORT (_PTR tb)[XRWS_MBUF_SIZE], _INT trace_pos, p_xrcm_type xrcm)
 {
  register _INT  i;
  p_SHORT        ol;
  p_SHORT        pl;
  _INT           vs, ve, m_st, w;

  #define GOTB_DROPOUT (XRMC_DEF_CORR_VALUE*4) /* Level of previous vect values to WWC_POS val */

  vs   = trace_pos - XRWS_MBUF_SIZE/2;
  if (vs < xrcm->v_start) vs = xrcm->v_start;
  m_st = vs;

  ol = &(*xrcm->s_out_line)[0];
  pl = &((*tb)[0]);

  w  = ol[trace_pos] - GOTB_DROPOUT;
  for (i = m_st; i < trace_pos-1; i ++)
   {
    if ((_INT)ol[i] >= w)
     {m_st = i; break;}
   }

  ol = &(*xrcm->s_out_line)[m_st];
  ve = xrcm->v_end - m_st;
  for (i = 0; i < XRWS_MBUF_SIZE; i ++, ol ++, pl ++)
   {
    if (i < ve) *pl = *ol; else *pl = XRMC_FLOOR;
   }

  return m_st;
 }

/* ************************************************************************* */
/*     Allocate memory for tracing needs                                     */
/* ************************************************************************* */
_INT TraceAlloc(_INT wl, p_xrcm_type xrcm)
 {
  p_UCHAR mem;
  p_trace_hdr_type pth;

  _INT    size;

  size  = XRMC_TRACE_BL_SIZE;
  size += wl*xrcm->xrinp_len*sizeof(_SHORT) + 16;

  mem   = (p_UCHAR)HWRMemoryAlloc(size);
  if (mem == _NULL) goto err;

  pth = (p_trace_hdr_type)mem;

  HWRMemSet(pth, 0, sizeof(trace_hdr_type));

  pth->mem[0]    = mem;
  pth->cur_mem   = mem;
  pth->cur_block = 0;
  pth->mem_used = sizeof(trace_hdr_type);

  pth->ma        = (p_SHORT)(mem + XRMC_TRACE_BL_SIZE);
  pth->ma_loc    = 0;
  xrcm->p_htrace = pth;

  return 0;
err:
  if (mem != _NULL) HWRMemoryFree(mem);
  return 1;
 }

/* ************************************************************************* */
/*     Allocate additional memory for tracing needs                          */
/* ************************************************************************* */
_INT TraceAddAlloc(p_xrcm_type xrcm)
 {
  p_UCHAR mem;
  p_trace_hdr_type pth;


  pth = (p_trace_hdr_type)xrcm->p_htrace;
  if (pth == _NULL) goto err;

  if (pth->cur_block >= XRMC_MAX_TRACE_BL-1) goto err;

  mem   = (p_UCHAR)HWRMemoryAlloc(XRMC_TRACE_BL_SIZE);
  if (mem == _NULL) goto err;

  pth->cur_block          += 1;
  pth->mem[pth->cur_block] = mem;
  pth->cur_mem             = mem;
  pth->mem_used            = 0;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*   DeAllocate memory for tracing needs                                     */
/* ************************************************************************* */
_INT TraceDealloc(p_xrcm_type xrcm)
 {

  _INT i;
  p_trace_hdr_type pth;
  if (xrcm == _NULL) goto err;
  pth = (p_trace_hdr_type)xrcm->p_htrace;
  if (pth == _NULL) goto err;

  for (i = pth->cur_block; i >= 0 ; i --)
   {
    if (pth->mem[i] == _NULL) goto err;
    HWRMemoryFree(pth->mem[i]);
   }

  xrcm->p_htrace = _NULL;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*     Create resulting trace layout on for processed word                   */
/* ************************************************************************* */
_INT CreateLayout(p_xrcm_type xrcm)
 {
  _INT                  i, l;
  _INT                  x, tp;
  _INT                  wl;
  _INT                  size, loc;
  _INT                  len, len1;
  _INT                  maxlen;
  _UCHAR                s_index, nvar, vect;
  p_UCHAR               mem = _NULL;
  p_wordlayout_hdr_type pwh;

  p_let_hdr_type        plh;
  p_sym_hdr_type        psh;
  p_var_hdr_type        pvh;
  p_xrp_hdr_type        pxh;
  p_tr_pos_type         trp;
  p_letlayout_hdr_type  plsym;

  if (xrcm->p_htrace == _NULL) goto err;

  if (xrcm->p_hlayout) HWRMemoryFree(xrcm->p_hlayout->mem);
  xrcm->p_hlayout = _NULL;

  wl    = HWRStrLen((p_CHAR)xrcm->word);
  size  = sizeof(wordlayout_hdr_type);
  size += wl * sizeof(letlayout_hdr_type);

  mem = (p_UCHAR)HWRMemoryAlloc(size); if (mem == _NULL) goto err;
  pwh = (p_wordlayout_hdr_type)mem;
  HWRMemSet(pwh, 0, sizeof(wordlayout_hdr_type));

  loc = sizeof(wordlayout_hdr_type);
  for (i = 0; i < wl; i ++)
   {
    pwh->llhs[i] = (p_letlayout_hdr_type)(mem + loc);
    HWRMemSet(pwh->llhs[i], 0, sizeof(letlayout_hdr_type));
    loc         += sizeof(letlayout_hdr_type);
   }

  pwh->mem      = mem;
  pwh->mem_size = size;
  pwh->mem_used = loc;

  tp = (xrcm->trace_end > 0) ? xrcm->trace_end : xrcm->v_end-1;
  for (l = wl-1; l >= 0; l --)
   {
    plsym = pwh->llhs[l];

    plh = xrcm->p_htrace->lhdrs[l];
    if (tp < plh->v_start || tp >= plh->v_end) goto err;
    s_index = plh->merge_vect[tp];

    psh            = plh->shdrs[s_index];
    plsym->realsym = plh->syms[s_index];
    plsym->end     = (_UCHAR)tp;

    if (tp < psh->v_start || tp >= psh->v_end) goto err;
    nvar           = psh->merge_vect[tp];

    if (nvar >= DTI_MAXVARSPERLET) goto err;
    pvh            = psh->vhdrs[nvar];
    if (pvh == _NULL) goto err;

    plsym->var_num = nvar;

    maxlen = xrcm->xrinp_len + DTI_XR_SIZE;
    for (i = 0, x = pvh->var_len-1; i < maxlen && x >= 0; i ++)  /* Variant step cycle */
     {
      pxh = pvh->xhdrs[x];
      if (tp < pxh->st || tp >= pxh->st+pxh->len) goto err;

      vect = pxh->vects[tp - pxh->st];
      if (vect > 3) goto err;

      trp = &plsym->trp[i];
      trp->inp_pos = (_UCHAR)tp;
      trp->xrp_num = (_UCHAR)x;
      trp->vect    = vect;


      if (vect == XRMC_T_ISTEP) tp --;
      if (vect == XRMC_T_PSTEP) x  --;
      if (vect == XRMC_T_CSTEP) {x  --; tp --;}
     }

    plsym->len = (_UCHAR)i;
    plsym->beg = (_UCHAR)tp;

    len  = (plsym->len)/2;                /* Inverse trace layout */
    len1 = plsym->len-1;
    for (i = 0; i < len; i ++, len1 --)
     {
      tr_pos_type rp =  plsym->trp[len1];

      plsym->trp[len1] = plsym->trp[i];
      plsym->trp[i]    = rp;
     }

   }

  xrcm->p_hlayout = pwh;

  return 0;
err:
  if (mem) HWRMemoryFree(mem);
  return 1;
 }

/* ************************************************************************* */
/*     Free memory used by tracing layout                                    */
/* ************************************************************************* */
_INT FreeLayout(p_xrcm_type xrcm)
 {

  if (xrcm == _NULL) goto err;
  if (xrcm->p_hlayout) HWRMemoryFree(xrcm->p_hlayout->mem);
   else goto err;

  xrcm->p_hlayout = _NULL;

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/*        Advance used memory pointer and report if not enough memory        */
/* ************************************************************************* */
p_VOID TDwordAdvance(_INT size, p_xrcm_type xrcm)
 {
  _INT cur_loc, loc;

  #define DWORD_ALIGN(n) ((((n)-1) & (~3))+4)

  cur_loc = xrcm->p_htrace->mem_used;
  loc = DWORD_ALIGN(cur_loc + size);

  if (loc >= XRMC_TRACE_BL_SIZE)
   {
    if (TraceAddAlloc(xrcm)) goto err;
    cur_loc = xrcm->p_htrace->mem_used;
    loc = DWORD_ALIGN(cur_loc + size);
    if (loc >= XRMC_TRACE_BL_SIZE) goto err;
   }

  xrcm->p_htrace->mem_used = loc;

  return (p_VOID)((p_CHAR)xrcm->p_htrace->cur_mem + cur_loc);
err:
  return _NULL;
 }

/* ************************************************************************* */
/*        Dig and write individual character weights                         */
/* ************************************************************************* */
_INT  FillLetterWeights(p_SHORT ma, p_xrcm_type xrcm)
 {
  _INT cl;
  _INT ma_loc = 0;
  _INT prev   = 0;
  _INT w;
  p_letlayout_hdr_type  plsym;
  p_tr_pos_type         trp;

  if (ma == _NULL || xrcm == _NULL) goto err;
  if (xrcm->p_hlayout == _NULL) goto err;

  for (cl = 0; cl < w_lim && xrcm->word[cl] != 0; cl ++)
   {
    plsym = xrcm->p_hlayout->llhs[cl];
    trp   = &(plsym->trp[plsym->len-1]);

    w = *(ma + ma_loc + trp->inp_pos) - XRMC_CONST_CORR;
    xrcm->letter_weights[cl] = (_SHORT)(w - prev);
    prev = w;

    ma_loc += xrcm->xrinp_len;
   }

  return 0;
err:
  return 1;
 }
/* ========================================================================= */
/*     Misc. garbage                                                         */
/* ========================================================================= */
/* ************************************************************************* */
/*     Retrieve average value of xrp corr line                               */
/* ************************************************************************* */
_INT xrp_ave_val(p_UCHAR pc, _INT len)
 {
  _INT    i, loc, loc1;
  _UCHAR  val, max = 0;
  p_UCHAR a = (p_UCHAR)pc;

  for (i = 0, loc = 0, loc1 = 0; i < len; i ++)
   {
    val = (_UCHAR)((i%2) ? a[i/2] & 0x0F : a[i/2] >> 4);
    if (max < val) {max = val; loc = i;}
    if (max == val) loc1 = i;
   }

  return (loc + loc1)/2;
 }

#endif // if XRMC_ENTRACING

#endif //#ifndef LSTRIP
/* ************************************************************************* */
/* ************************************************************************* */
/*        END  OF ALL                                                        */
/* ************************************************************************* */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xr_attr.cpp ===
/* ************************************************************************* */
/* *   Fill in xr attributes routines                            AVP 1-1996* */
/* ************************************************************************* */

#include "hwr_sys.h"
#include "ams_mg.h"
#include "dti.h"
#include "lowlevel.h"
#include "xr_attr.h"
#include "xr_names.h"

#if PG_DEBUG
//#include <stdio.h>
#include "pg_debug.h"
#endif


/************************************************************************** */
/*       XR_MERITS definition table support programs                        */
/************************************************************************** */

ROM_DATA_EXTERNAL _SHORT xr_type_merits[XT_COUNT];
//extern _SHORT xr_type_merits[XT_COUNT];

#ifndef LSTRIP

/************************************************************************** */
/*       Decide what type xr is -- upper, lower, or junk                    */
/************************************************************************** */
_INT GetXrHT(p_xrd_el_type xrd_el)
 {
  _INT t = FHR_JUNK;

  if (xr_type_merits[xrd_el->xr.type] & XRM_LOWER) t = FHR_LOWER;
  if (xr_type_merits[xrd_el->xr.type] & XRM_UPPER) t = FHR_UPPER;
  if (xr_type_merits[xrd_el->xr.type] & XRM_WILD)  t = FHR_WILD;

  return t;
 }

#endif //#ifndef LSTRIP

/************************************************************************** */
/*       Decide what type xr is -- upper, lower, or junk                    */
/************************************************************************** */
_INT GetXrMovable(p_xrd_el_type xrd_el)
 {
  _INT t = 0;

  if (xr_type_merits[xrd_el->xr.type] & XRM_MVBLE) t = 1;

  return t;
 }

/************************************************************************** */
/*       Decide what type xr is link or not                                 */
/************************************************************************** */
_INT IsXrLink(p_xrd_el_type xrd_el)
 {
  _INT t = 0;

  if (xr_type_merits[xrd_el->xr.type] & XRM_LINK) t = 1;

  return t;
 }

#ifndef LSTRIP

/************************************************************************** */
/*       Decide what type xr is -- duga with end or not                     */
/************************************************************************** */
_INT IsEndedArc(p_xrd_el_type xrd_el)
 {
  _INT t = 0;

  if (xr_type_merits[xrd_el->xr.type] & XRM_ENARC) t = 1;

  return t;
 }

/************************************************************************** */
/*       Return xr metrics directly from table                              */
/************************************************************************** */
_INT GetXrMetrics(p_xrd_el_type xrd_el)
 {
  return xr_type_merits[xrd_el->xr.type];
 }


/* ************************************************************************* */
/* *       Main call to fill XR                                            * */
/* *                           attributes (features, merits, etc...)       * */
/* ************************************************************************* */
_INT FillXrFeatures(p_xrdata_type xrdata, low_type _PTR low_data)
 {
  _INT err = 0;
  _INT slope;
  PS_point_type _PTR trace = low_data->p_trace;
  _INT           trace_len = low_data->rc->ii;

//  slope = GetCurSlope(trace_len, trace);
//  slope = 0; // Since trace is straigtened in PreP.cpp
//  if (slope < -100) slope = -100;
//  if (slope >  100) slope =  100;
//  if (xrdata->len < 7) slope /= 2;

  slope = low_data->rc->slope;

  err += FillSHR(slope, xrdata, low_data);
  err += FillOrients(slope, xrdata, low_data);

//  low_data->slope = slope; // AVP -- that's better!

  return err;
 }
#if 0 // Moved to PreP.cpp
/* ************************************************************************* */
/* *    Get right extrema presize X                                        * */
/* ************************************************************************* */
_INT  GetCurSlope(_INT num_points, p_PS_point_type trace)
 {
  _INT   i, j;
  _INT   x, y;
  _INT   dx, dy;
  _INT   adx, ady;
  _LONG  dx_sum, dy_sum;
  _INT   slope;


  if (num_points < 10) goto err;

  dx_sum       = 0;
  dy_sum       = 300;  // Stabilize to vert on small traces
  for (i = 0, j = 0; i < num_points; i ++)
   {
    x = trace[i].x;
    y = trace[i].y;

    if (y < 0) {j = i+1; continue;}

    dx  = (x - trace[j].x);
    adx = HWRAbs(dx);
    dy  = -(y - trace[j].y);
    ady = HWRAbs(dy);

    if (ady+adx > 10) // if too close, skip
     {
      j = i;

      if (dy != 0 && (100*adx)/ady <= 200) // if too horizontal -- skip
       {
        if (dy < 0)  // going  down the trace, notice more
         {
          dy = -(dy*8);
          dx = -(dx*8);
         }

        dx_sum += dx;
        dy_sum += dy;
       }
     }
   }

  slope = (100*dx_sum)/dy_sum;

//  if (num_points < 100) slope /= 4; // To few points

#if PG_DEBUG
printw("\nTraceSlope: %d, dy_sum: %d ", (100*dx_sum)/dy_sum, dy_sum);
#endif

  return slope;
err:
  return 0;
 }
#endif
/* ************************************************************************* */
/* *       Relative    Height                                              * */
/* *                           & shift calculations                        * */
/* ************************************************************************* */

/* ************************************************************************* */
/* *    Get aliases to a given word on given XrData                        * */
/* ************************************************************************* */
_INT FillSHR(_INT slope, p_xrdata_type xrdata, low_type _PTR low_data)
 {
  _INT          i, j;
  _INT          e[4], x[4], y[4];
  _INT          height, shift;
  _INT          px, nx, plx, pux, nlx, nux, xfc;
  _INT          dy, dpy, hr, dx, dx1, dx2;
  _INT          done;
  p_xrd_el_type xrd_el;
  _UCHAR        xf[XRINP_SIZE]  = {0};
  _SCHAR        sht[XRINP_SIZE] = {0};
  PS_point_type _PTR trace = low_data->p_trace;
//  _INT h_coder[16] = {0, 10, 40, 55, 65, 75, 85, 95, 106, 118, 134, 154, 182, 250, 1000, 32000};
  _INT h_coder[16] = {0, 10, 20, 30, 40, 50, 60, 75, 90, 111, 133, 166, 200, 250, 400, 32000};
  _INT s_coder[16] = {0, -32000, -100, -60, -30, -10, 10, 30, 60, 100, 150, 210, 280, 360, 450, 32000};


  if (xrdata->len < 3) goto err;

// --------------- Let's create xr profile string -------------------------
  for (i = 0, xrd_el = &(*xrdata->xrd)[i]; i < xrdata->len; i ++, xrd_el ++)
   {
    xf[i] = (_UCHAR)GetXrMetrics(xrd_el);
   }

  // Make clear with Wilds
//  for (i = 1, xrd_el = &(*xrdata->xrd)[i]; i < xrdata->len; i ++, xrd_el ++)
//   {
//    if (!(xf[i] & XRM_WILD)) continue;
//    px = nx = 0;
//    for (j = i-1; j > 0; j --) if (xf[j] & (XRM_UPPER|XRM_LOWER)) {px = j; break;}
//    for (j = i+1; j < xrdata->len; j ++) if (xf[j] & (XRM_UPPER|XRM_LOWER)) {nx = j; break;}
//    if ((xf[px] & XRM_UPPER) && (xf[nx] & XRM_UPPER)) xf[i] |= XRM_LOWER;
//    if ((xf[px] & XRM_LOWER) && (xf[nx] & XRM_LOWER)) xf[i] |= XRM_UPPER;
//   }

// --------------- Assign heights and shifts ------------------------------

  for (i = 0; i < xrdata->len; i ++)
   {
    done = e[0] = e[1] = e[2] = e[3] = 0;
    xfc  = xf[i];

    if ((xfc & XRM_WILD) && (xf[i+1] & XRM_LINK)) // Define type of last wild before link
     {
      px = nx = 0;
      for (j = i-1; j > 0 && !(xf[j] & XRM_LINK); j --) if (xf[j] & (XRM_UPPER|XRM_LOWER)) {px = j; break;}
      if (px) {if ((xf[px] & XRM_UPPER)) xfc |= XRM_LOWER; else xfc |= XRM_UPPER;}
       else
       {
        for (j = i+1; j < xrdata->len; j ++) if (xf[j] & (XRM_UPPER|XRM_LOWER)) {nx = j; break;}
        if (nx) {if ((xf[nx] & XRM_UPPER)) xfc |= XRM_LOWER; else xfc |= XRM_UPPER;}
       }
     }

    if (!done && (xfc & XRM_LINK))
     {
      pux = plx = nux = nlx = 0;
      for (j = i-1; j > 0; j --) if (xf[j] & XRM_LW) {plx = j; break;}
      for (j = j-1; j > 0; j --) if (xf[j] & XRM_UW) {pux = j; break;}
      for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_UW) {nux = j; break;}
      for (j = j+1; j < xrdata->len; j ++) if (xf[j] & XRM_LW) {nlx = j; break;}
      if (pux > 0 && plx > 0 && nux > 0 && nlx > 0) {e[0] = pux; e[1] = plx; e[2] = nlx; e[3] = nux;}
      done = 1;
     }

    if (!done && (xfc & XRM_UPPER))
     {
      nx = px = 0;
      for (j = i-1; j > 0; j --) if (xf[j] & XRM_LW) {px = j; break;}
      for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_LW) {nx = j; break;}
      if (px > 0 && nx > 0) {e[0] = px; e[1] = e[2] = i; e[3] = nx;}
      done = 1;
     }

    if (!done && (xfc & XRM_LOWER))
     {
      nx = px = 0;
      for (j = i-1; j > 0; j --) if (xf[j] & XRM_UW) {px = j; break;}
      for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_UW) {nx = j; break;}
      if (px > 0 && nx > 0) {e[0] = px; e[1] = e[2] = i; e[3] = nx;}
      done = 1;
     }

    if (!done && (xfc & XRM_MVBLE))
     {
      nux = nlx = e[3] = 0;
      for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_UW) {nux = j; break;}
      for (j = j+1; j < xrdata->len; j ++) if (xf[j] & XRM_LW) {nlx = j; break;}
//      if (nlx > 0 && nux > 0) {e[0] = nux; e[1] = e[2] = nlx; e[3] = i;}
      if (!((*xrdata->xrd)[i].xr.attrib & X_RIGHT_KREST)
             &&  nlx > 0 && nux > 0)
        {e[0] = nux; e[1] = e[2] = nlx; e[3] = i;}
       else // Try to find back, if nothing forward ...
       {
        for (j = i-1; j > 0; j --) if (xf[j] & XRM_LW) {nlx = j; break;}
        for (j = j-1; j > 0; j --) if (xf[j] & XRM_UW) {nux = j; break;}
        if (nlx > 0 && nux > 0) {e[0] = nux; e[1] = e[2] = nlx; e[3] = i;}
       }

      if (e[3] > 0 && nlx > 0)
       {
        j = ((*xrdata->xrd)[e[3]].box_up + (*xrdata->xrd)[e[3]].box_down) / 2;
        if (j > (*xrdata->xrd)[nlx].box_down) e[3] = e[2];
       }

      done = 1;
     }

    if (!done && (xfc & XRM_WILD)) // Make understanding with wilds ...
     {
      px = nx = 0;
      for (j = i-1; j > 0; j --) if (xf[j] & XRM_ANY) {px = j; break;}
      for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_ANY) {nx = j; break;}

      if (i > 0 && xf[i-1] & XRM_LINK) // Predecessor is link -- define base
       {
        if (xf[nx] & XRM_UPPER) for (j = i-1; j > 0; j --) if (xf[j] & XRM_UPPER) {px = j; break;}
        if (xf[nx] & XRM_LOWER) for (j = i-1; j > 0; j --) if (xf[j] & XRM_LOWER) {px = j; break;}
       }
      if (xf[i+1] & XRM_LINK) // Next is link -- define base
       {
        if (xf[px] & XRM_UPPER) for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_UPPER) {nx = j; break;}
        if (xf[px] & XRM_LOWER) for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_LOWER) {nx = j; break;}
       }

      if (px > 0 && nx > 0)  {e[0] = px; e[1] = e[2] = i; e[3] = nx;}
      done = 1;
     }

    if (!done)  // Junk
     {
      px = nx = 0;
      for (j = i-1; j > 0; j --) if (xf[j] & XRM_UW) {px = j; break;}
      for (j = i+1; j < xrdata->len; j ++) if (xf[j] & XRM_LW) {nx = j; break;}
      if (px > 0 && nx > 0)  {e[0] = px; e[1] = e[2] = nx; e[3] = i;}
     }

   // ----------- Fill Values -------------------

    if (e[0] != 0 && e[1] != 0 && e[2] != 0 && e[3] != 0) // If all defined
     {
      for (j = 0; j < 4; j ++)
       {
        xrd_el = &(*xrdata->xrd)[e[j]];

        if (xrd_el->hotpoint)
         {
          y[j] = trace[xrd_el->hotpoint].y;
          x[j] = trace[xrd_el->hotpoint].x;
         }
         else
         {
          y[j] = (xrd_el->box_up + xrd_el->box_down)/2;
          x[j] = (xrd_el->box_left + xrd_el->box_right)/2;
         }

        if (xf[e[j]] & XRM_UPPER) y[j] = xrd_el->box_up;
        if (xf[e[j]] & XRM_LOWER) y[j] = xrd_el->box_down;
        if (xf[e[j]] & XRM_LEFT)  x[j] = xrd_el->box_left;
        if (xf[e[j]] & XRM_RIGHT) x[j] = xrd_el->box_right;
       }

      dpy = HWRAbs(y[0] - y[1]);
      dy  = HWRAbs(y[2] - y[3]);
      if (dy  <= 0) dy = 1;
      if (dpy <= 0) dpy = 1;
      hr = (100*dy)/dpy;
      for (j = 1, height = 0; j < 16; j ++) if (hr < h_coder[j]) {height = j; break;}
      if (j == 16) height = 15;

      if (xfc & XRM_LINK)
       {
        dx1  = 100*x[3];
        dx2  = 100*x[0];
        dx1 -= slope*(y[2]-y[3]);
        dx2 -= slope*(y[1]-y[0]);
        dx1  = dx1 - dx2; dx2 = 0;
       }
       else
       {
        dx1  = 100*(x[3]-x[2]);
        dx2  = 100*(x[0]-x[1]);
        dx1 -= slope*(y[2]-y[3]);
        dx2 -= slope*(y[1]-y[0]);
       }

//      dx = (100*(x[3]-x[2]))/dy - (100*(x[0]-x[1]))/dpy;
//      dx = ((100*(x[3]-x[2])) - (100*(x[0]-x[1])))/((dy+dpy)/2);
      dx = (dx1 - dx2)/((dy+dpy)/2);

      for (j = 1, shift = 0; j < 16; j ++) if (dx < s_coder[j]) {shift = j; break;}
      if (j == 16) shift = 15;

      if (dx < -510) dx = -510; if (dx > 510) dx = 510; if (dx == 0) dx = 1;
      sht[i] = (_SCHAR)(dx/4);
     }
     else // Something's undef here ...
     {
      height = 0;
      shift  = 0;
     }

    (*xrdata->xrd)[i].xr.height = (_UCHAR)height;
    (*xrdata->xrd)[i].xr.shift  = (_UCHAR)shift;
   } // End of xrdata cycle


// ---------- Scale shifts to average -----------------------------------

  if (xrdata->len > 10)
   {
    _LONG sdx, k;

    for (i = 0, j = 0, sdx = 0; i < xrdata->len; i ++) if (sht[i] != 0) {sdx += sht[i]; j ++;}
    if (j > 8)
     {
      k = 100*sdx/j;
      if (k > 500 && k < 80000)
       {
        k = 23*100*100/k;
        k = (3*k+100*1)/4;
        for (i = 0; k > 0 && i < xrdata->len; i ++)
         {
          if (sht[i] == 0) continue;
          dx = (_INT)sht[i]*k/100;
          for (j = 1, shift = 0; j < 16; j ++) if (dx < s_coder[j]/4) {shift = j; break;}
          if  (j == 16) shift = 15;
         (*xrdata->xrd)[i].xr.shift  = (_UCHAR)shift;
         }
       }
     }
   }


  return 0;
err:
  return 1;
 }


/* ************************************************************************* */
/* *       Calculate Absolute height for XRs                               * */
/* *                                                                       * */
/* ************************************************************************* */
#if 0 // Save space
/* ************************************************************************* */
/* *    Absolute H                                                         * */
/* ************************************************************************* */
_INT FillAH(p_xrdata_type xrdata, low_type _PTR low_data)
 {
  _INT  i;
  _INT  a, b, A, B;
  _INT  x, h, bh, ah;
  _INT  bsize, xf;
 _LONG  SXY=0, SY=0;
  p_rc_type rc = low_data->rc;
//  _INT  ah_coder[16] = {-32000, -250, -190, -150, -120, -83, -50, -17,
//                        17, 50, 83, 120, 150, 190, 250, 32000};
  _INT  ah_coder[16] = {-32000, -325, -275, -225, -175, -125, -75, -25,
                        25, 75, 125, 175, 225, 275, 325, 32000};
  _INT  Dx = (rc->stroka.box.right - rc->stroka.box.left);
  _INT  Dy = (rc->stroka.box.bottom - rc->stroka.box.top);
  p_xrd_el_type xrd_el;

  if (xrdata->len < 3) goto err;

  if (rc->stroka.size_sure_out < 75) goto err;

// --------------- Let's count middle line --------------------------------

  for(i=0; i < CB_NUM_VERTEX; i++)
   {
    SXY += i*(_LONG)(((_INT)rc->curv_bord[2*i]+(_INT)rc->curv_bord[2*i+1])/2);
    SY  += (_LONG)((((_INT)rc->curv_bord[2*i]+(_INT)rc->curv_bord[2*i+1])/2));
   }

  b = (_INT)( 2*(2*(CB_NUM_VERTEX-1)+1)*SY - 6*SXY ) / (((CB_NUM_VERTEX-1)+1)*((CB_NUM_VERTEX-1)+2));
  a = (_INT)( 6*(2*SXY - (CB_NUM_VERTEX-1)*SY)) / ((CB_NUM_VERTEX-1)*((CB_NUM_VERTEX-1)+1)*((CB_NUM_VERTEX-1)+2));

//  for(i=0; i < CB_NUM_VERTEX; i++)
//   {
//    rc->curv_bord[2*i+1] = (_UCHAR)(a*i+b);
//   }

  if(Dx != 0)
   {
    A = (_INT)((((CB_NUM_VERTEX-1)*a*Dy) * 100) / (255L*Dx));
    B = (_INT)((rc->stroka.box.top + b*Dy/255L)*100 - A*rc->stroka.box.left);
   }
   else {A = 0; B = 100*(rc->stroka.box.top + rc->stroka.box.bottom)/2;}

  bsize = rc->stroka.size_out;

// --------------- Fill absolute height -----------------------------------

  for (i = 0, xrd_el = &(*xrdata->xrd)[0]; i < xrdata->len; i ++, xrd_el ++)
   {
    xf = GetXrHT(xrd_el);
    h  = (xrd_el->box_up + xrd_el->box_down)/2;
    if (xf == FHR_UPPER) h = xrd_el->box_up;
    if (xf == FHR_LOWER) h = xrd_el->box_down;

    x  = (xrd_el->box_left + xrd_el->box_right)/2;
    bh = A*x + B;
    ah = (2*(100*h-bh))/bsize;
    for (h = 1; h < 16; h ++) if (ah < ah_coder[h]) break;
    if (h > 15) h = 15;

    xrd_el->xr.height  = (_UCHAR)h;
   }


  return 0;
err:
  for (i = 0, xrd_el = &(*xrdata->xrd)[0]; i < xrdata->len; i ++, xrd_el ++)
    xrd_el->xr.height  = (_UCHAR)0;
  return 1;
 }

#endif // 0
/* ************************************************************************* */
/* *       Calculate orientation vectors for XRs                           * */
/* *                                                                       * */
/* ************************************************************************* */

/* ************************************************************************* */
/* *    Get aliases to a given word on given XrData                        * */
/* ************************************************************************* */
_INT FillOrients(_INT slope, p_xrdata_type xrdata, low_type _PTR low_data)
 {
  _INT          i, j;
  _INT          pt, py, sy, xf, dx, dy;
  _INT          base, done;
  p_xrd_el_type xrd_el;
  vect_type     vect;
  PS_point_type _PTR trace = low_data->p_trace;
  _INT          trace_len  = low_data->rc->ii;

// --------------- Find base for the xr string ----------------------------

  py = 0; pt = 0; sy = 0;
  for (i = 1, j = 0, xrd_el = &(*xrdata->xrd)[i]; i < xrdata->len; i ++, xrd_el ++)
   {
    xf = GetXrMetrics(xrd_el);
    if (pt == 0 || pt == XRM_LOWER)
      if (xf & XRM_UPPER) {if (pt) sy += HWRAbs(py - xrd_el->box_up); pt = XRM_UPPER; py = xrd_el->box_up; j ++;}
    if (pt == XRM_UPPER)
      if (xf & XRM_LOWER) {sy += HWRAbs(py - xrd_el->box_down); pt = XRM_LOWER; py = xrd_el->box_down; j ++;}
   }

  if (j > 1) base = (sy/j)/3;
   else base = (low_data->rc->stroka.box.bottom - low_data->rc->stroka.box.top)/3;

// --------------- Find base for the xr string ----------------------------

  for (i = 1, xrd_el = &(*xrdata->xrd)[i]; i < xrdata->len; i ++, xrd_el ++)
   {
    done = 0;
    xf   = GetXrMetrics(xrd_el);

    if (!done && (xf & XRM_LINK)) // For links -- count direction of prev el end
     {
      if (GetXrMetrics(xrd_el-1) & XRM_ENARC) vect.stp = vect.enp = (xrd_el-1)->endpoint;
       else vect.stp = vect.enp = ((xrd_el-1)->hotpoint) ? (xrd_el-1)->hotpoint:((xrd_el-1)->begpoint+(xrd_el-1)->endpoint)/2;

      GetBlp(0, &vect, i-1, xrdata);
      GetVect(0, &vect, trace, trace_len, base);
      done = 1;
     }

    if (!done && (xf & XRM_MVBLE)) // For dots and dashes get vect from beg to end
     {
      vect.stp = xrd_el->begpoint;  vect.enp = xrd_el->endpoint;
      vect.stx = trace[vect.stp].x; vect.sty = trace[vect.stp].y;
      vect.enx = trace[vect.enp].x; vect.eny = trace[vect.enp].y;
      done = 1;
     }

    if (!done)
     {
      vect.stp = (xrd_el->hotpoint) ? xrd_el->hotpoint:(xrd_el->begpoint+xrd_el->endpoint)/2;

      if (IsXrLink(xrd_el+1))
       {
        vect.stp = xrd_el->endpoint;
        vect.enp = (xrd_el+1)->endpoint;
        vect.stx = trace[vect.stp].x; vect.sty = trace[vect.stp].y;
        vect.enx = trace[vect.enp].x; vect.eny = trace[vect.enp].y;
       }
       else
       {
        if (xf & XRM_GAMMA) vect.enp = (xrd_el->endpoint + vect.stp)/2;
         else vect.enp = vect.stp;

        GetBlp(1, &vect, i, xrdata);
        GetVect(1, &vect, trace, trace_len, base);
       }

     }

    dx  = vect.enx - vect.stx; dy = vect.sty - vect.eny;
    dx -= (slope*dy)/100;

    xrd_el->xr.orient = (_UCHAR)GetAngle(dx, dy);
   }



  return 0;
//err:
//  return 1;
 }

ROM_DATA_EXTERNAL _INT ratio_to_angle[8];

/************************************************************************** */
/*       Get angle based on ord deltas                                      */
/************************************************************************** */
_INT GetAngle(_INT dx, _INT dy)
 {
  _INT i;
  _INT r, a, q;

  q  = (dx >= 0) ?  0 : 1;
  q += (dy >= 0) ?  0 : 2;

  if (dx == 0) {if (dy == 0) r = 0; else r = 32000;}
   else r = (100*HWRAbs(dy))/(HWRAbs(dx));

  for (i = 0; i < 8; i ++) if (r < ratio_to_angle[i]) break;
//  if (i > 7) i = 7;

  switch (q)
   {
    case 0: a =    i; break;
    case 1: a = 16-i; break;
    case 3: a = 16+i; break;
    case 2: a = 32-i; break;
   }

  if (a > 31) a = 0;

  return a;
 }

/************************************************************************** */
/*       Get vect for an xr                                                 */
/************************************************************************** */
_INT GetVect(_INT dir, p_vect_type vect, _TRACE trace, _INT trace_len, _INT base)
 {
  _INT i;
  _INT inc, set, pd;
  _INT d, dx, dy, vx, vy;

  inc = (dir) ? 1 : -1;

  vx = trace[vect->stp].x; vy = trace[vect->stp].y;
  for (i = vect->enp, set = 0, pd = 0; i < trace_len && i > 0; i += inc)
   {
    if (trace[i].y < 0) {pd = 0; continue;}
    dx   = vx - trace[i].x;
    dy   = vy - trace[i].y;
    d    = HWRMathILSqrt(dx*dx + dy*dy);
    if (d > base) {set = 1; break;}
    if (i == vect->blp) {set = 1; break;}
    pd = d;
   }

  if (pd && (base - pd) < (d - base)) i -= inc;

  if (!set)  // End of trajectory
   {
    vect->stx = vx;    vect->sty = vy;
    vect->enx = vx+10; vect->eny = vy;
   }
   else
   {
    vect->stx = vx; vect->sty = vy;
    vect->enx = trace[i].x; vect->eny = trace[i].y;
   }

  if (!dir)
   {
    i = vect->stx; vect->stx = vect->enx; vect->enx = i;
    i = vect->sty; vect->sty = vect->eny; vect->eny = i;
   }

  return 0;
 }

/************************************************************************** */
/*       Get angle based on ord deltas                                      */
/************************************************************************** */
_INT GetBlp(_INT dir, p_vect_type vect, _INT xrn, p_xrdata_type xrdata)
 {
  _INT i;
  _INT inc;
  p_xrd_el_type xrd_el;

  vect->blp = 0;
  inc = (dir) ? 1 : -1;

  for (i = xrn+inc; i > 0 && i < xrdata->len; i += inc)
   {
    xrd_el = &(*xrdata->xrd)[i];
    if (GetXrHT(xrd_el) != FHR_JUNK)
     {
      vect->blp = (xrd_el->hotpoint) ? xrd_el->hotpoint:(xrd_el->begpoint+xrd_el->endpoint)/2;
      break;
     }
   }

  return 0;
 }

 #endif //#ifndef LSTRIP

/************************************************************************** */
/*       End of all                                                         */
/************************************************************************** */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\zctabs.cpp ===
/* ******************************************************************** */
/* *  ZC tables for the Zctype.cpp functions                          * */
/* ******************************************************************** */

#include "bastypes.h"
#include "zctype.h"

//#ifndef __ParaConstants__
//ROM_DATA_EXTERNAL unsigned char  _xctype[];
//ROM_DATA_EXTERNAL unsigned char  _xupper[];
//ROM_DATA_EXTERNAL unsigned char  _xlower[];
//#endif 

/*from zctype.c*/

ROM_DATA unsigned char  _xctype[] = {
0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,  //x00
0x20, 0x60, 0x60, 0x20, 0x60, 0x60, 0x20, 0x20,  //x08
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,  //x10
0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,  //x18
0x48, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  //x20
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  //x28
0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84, 0x84,  //x30
0x84, 0x84, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,  //x38
0x10, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x01,  //x40
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  //x48
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  //x50
0x01, 0x01, 0x01, 0x10, 0x10, 0x10, 0x10, 0x10,  //x58
0x10, 0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x02,  //x60
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  //x68
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  //x70
0x02, 0x02, 0x02, 0x10, 0x10, 0x10, 0x10, 0x00,  //x78
                                                      
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //x80//128
0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,  //x88//136
0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,  //x90//144
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01,  //x98//152
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //xA0//160
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //xA8//168
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //xB0//176
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  //xB8//184
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  //xC0//192
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,  //xC8//200
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,  //xD0//208
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02,  //xD8//216
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  //xE0//224
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  //xE8//232
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00,  //xF0//240
0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02   //xF8//248
};

/*******************************************************************/
ROM_DATA unsigned char  _xupper[] = {
#if !HALF_TABLE
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  //x00
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  //x08
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,  //x10
0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,  //x18
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,  //x20
0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,  //x28
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,  //x30
0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,  //x38
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,  //x40
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,  //x48
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,  //x50
0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,  //x58
0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,  //x60
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,  //x68
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,  //x70
0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,  //x78
#endif
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  //x80//128
0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,  //x88//136
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,  //x90//144
0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,  //x98//152
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,  //xA0//160
0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,  //xA8//168
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,  //xB0//176
0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,  //xB8//184
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,  //xC0//192
0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,  //xC8//200
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,  //xD0//208
0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,  //xD8//216
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,  //xE0//224
0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,  //xE8//232
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,  //xF0//240
0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xfe, 0x9f   //xF8//248
};

/*******************************************************************/
ROM_DATA unsigned char  _xlower [] = {
#if !HALF_TABLE
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,   //x00
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,   //x08
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,   //x10
0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,   //x18
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,   //x20
0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,   //x28
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,   //x30
0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,   //x38
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,   //x40
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,   //x48
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,   //x50
0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,   //x58
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,   //x60
0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,   //x68
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,   //x70
0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,   //x78
#endif
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,  //x80//128
0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,  //x88//136
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,  //x90//144
0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xff,  //x98//152
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,  //xA0//160
0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,  //xA8//168
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,  //xB0//176
0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,  //xB8//184
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,  //xC0//192
0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,  //xC8//200
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,  //xD0//208
0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xde, 0xff,  //xD8//216
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,  //xE0//224
0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,  //xE8//232
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,  //xF0//240
0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff   //xF8//248
};


/* ******************************************************************** */
/* ******************************************************************** */
/* ******************************************************************** */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\xr_rwg.cpp ===
/* ************************************************************************** */
/* *  Support for RecWords Graph (PPD)                                      * */
/* ************************************************************************** */

#include "ams_mg.h"                           /* Most global definitions     */
#include "zctype.h"

#include "xrword.h"
//#include "postcalc.h"

/* ************************************************************************* */
/*        Free memory allocated for RWG                                      */
/* ************************************************************************* */
_INT FreeRWGMem(p_RWG_type rwg)
 {

  if (rwg)
   {
    if (rwg->rws_mem != _NULL) {HWRMemoryFree(rwg->rws_mem); rwg->rws_mem = _NULL;}
    if (rwg->ppd_mem != _NULL) {HWRMemoryFree(rwg->ppd_mem); rwg->ppd_mem = _NULL;}
   }

  return 0;
 }

#if !defined PEGASUS || defined PSR_DLL
/* ************************************************************************** */
/* *  Create structure in form of RWG for XRWS internal calls to PP         * */
/* ************************************************************************** */
_INT AskPpWeight(p_UCHAR word, _INT start, _INT end, p_RWG_type rwg, p_xrcm_type xrcm)
 {
  UNUSED(word);
  UNUSED(start);
  UNUSED(end);
  UNUSED(rwg);
  UNUSED(xrcm);

   return 0;
 }

#if 0
/* ************************************************************************** */
/* *  Create structure in form of RWG for PPD use                           * */
/* ************************************************************************** */

_SHORT xr_rwg(xrdata_type (_PTR xrdata)[XRINP_SIZE], rec_w_type (_PTR rec_words)[NUM_RW], p_RWG_type rwg, rc_type  _PTR rc)
 {
  _INT           i, j, nlet, nw;
  _INT           num_symbols;
  _INT           xrd_size;
  _INT           rwsi;
  _SHORT         caps_mode = rc->caps_mode;
  RWS_type       (_PTR rws)[RWS_MAX_ELS];
  RWG_PPD_type   (_PTR ppd)[RWS_MAX_ELS];



  HWRMemSet(rwg, 0, sizeof(*rwg));

  for (xrd_size = 0; xrd_size < XRINP_SIZE; xrd_size ++)
    if ((*xrdata)[xrd_size].xr.xr == 0) break;

  if (rc->algorithm == XRWALG_XR_SPL) /* Character variants (numbers) */
   {                                  /* Letter variants mode */
    typedef struct {
                    _CHAR  let[2];
                    _CHAR  w;
                    _CHAR  id;
                   } xrwg_la_type;

    _INT         nl;
    _INT         xrd_len, xrd_loc, rcwl, rcmd, num_symbols;
    _INT         rc_alc;
    xrwg_la_type (_PTR la)[w_lim][NUM_RW];
    xrdata_type  (_PTR xrd)[XRINP_SIZE];
    rec_w_type   (_PTR recw)[NUM_RW];

    if ((*rec_words)[0].alias[0] == 0) goto err; /* Aliases required !*/

    la = (xrwg_la_type (_PTR)[w_lim][NUM_RW])HWRMemoryAlloc(sizeof(*la)+sizeof(*xrd)+sizeof(*recw)); if (la == _NULL) goto err;
    HWRMemSet(la, 0, sizeof(*la)+sizeof(*xrd)+sizeof(*recw));

    xrd    = (xrdata_type (_PTR)[XRINP_SIZE])(la + 1);
    recw   = (rec_w_type (_PTR)[NUM_RW])(xrd + 1);

    rcwl             = rc->xrw_max_wlen;
    rc->xrw_min_wlen = 1;
    rc->xrw_max_wlen = 2;
    rcmd             = rc->xrw_mode;
    rc->xrw_mode     = XRWM_CS | XRWM_TRIAD;// | XRWM_BLOCK;
    rc->caps_mode    = caps_mode;
    rc_alc           = rc->enabled_cs;
//    if (isdigit((*rec_words)[0].word[0])) rc->enabled_cs = CS_NUMBER | CS_OTHER;
//    if (!isdigit((*rec_words)[0].word[0])) rc->enabled_cs &= ~(CS_NUMBER /* | CS_OTHER */);


    xrd_loc     = 1;
    (*xrd)[0] = (*xrdata)[0];
    num_symbols = 0;
    for (nl = 0; nl < w_lim-1 && (*rec_words)[0].alias[nl] != 0; nl ++)
     {
      xrd_len  = (*rec_words)[0].alias[nl] >> 4;

      if ((*rec_words)[0].alias[nl+1] == 0)  /* It is last letter */
        xrd_len = xrd_size-xrd_loc;

      HWRMemCpy(&(*xrd)[1], &(*xrdata)[xrd_loc], xrd_len*sizeof(xrdata_type));
      HWRMemSet(&(*xrd)[xrd_len+1], 0, sizeof(xrdata_type)*2);
      if (IS_XR_LINK((*xrd)[xrd_len].xr.xr)) (*xrd)[xrd_len] = (*xrdata)[0];
       else (*xrd)[xrd_len+1] = (*xrdata)[0];

      if (nl == 1) /* On all letters after first recount caps flags */
       {
        rc->caps_mode &= ~(XCM_FL_DEFSIZEp | XCM_FL_TRYCAPSp);
        if (rc->caps_mode & XCM_AL_DEFSIZEp) rc->caps_mode |= XCM_FL_DEFSIZEp;
        if (rc->caps_mode & XCM_AL_TRYCAPSp) rc->caps_mode |= XCM_FL_TRYCAPSp;
       }

      if (xrws(xrd, recw, rc) != 0)
       {
        rc->xrw_mode     = rcmd;
        rc->xrw_max_wlen = rcwl;
        rc->enabled_cs   = rc_alc;
        HWRMemoryFree(la);
        goto err;
       }

      if ((*recw)[0].word[0] == 0) continue;

      for (i = 0; i < NUM_RW && (*recw)[i].word[0] != 0; i ++)
       {
        if (((*la)[nl][i].let[0] = (*recw)[i].word[0]) != 0) num_symbols ++;
        if (((*la)[nl][i].let[1] = (*recw)[i].word[1]) != 0) num_symbols ++;
        (*la)[nl][i].w      = (_CHAR)(*recw)[i].weight;
        (*la)[nl][i].id     = (_CHAR)(*recw)[i].src_id;
       }

      if (i > 1) num_symbols += i+1;

      xrd_loc += xrd_len;
     }

    nlet = nl;
    rc->xrw_max_wlen = rcwl;
    rc->xrw_mode     = rcmd;
    rc->enabled_cs   = rc_alc;

/* ------------------------------Fill RWG --------------------------------*/

    rwg->type     = RWGT_SEPLET;
    rwg->size     = num_symbols;
    rwg->hrws_mem = HWRMemoryAllocHandle((num_symbols+1) * sizeof(RWS_type));
    rwg->hppd_mem = HWRMemoryAllocHandle((num_symbols+1) * sizeof(RWG_PPD_type));

    if (rwg->hrws_mem == _NULL || rwg->hppd_mem == _NULL) {HWRMemoryFree(la); goto err;}

    rws = (RWS_type (_PTR)[RWS_MAX_ELS])HWRMemoryLockHandle(rwg->hrws_mem);
    ppd = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])HWRMemoryLockHandle(rwg->hppd_mem);
    HWRMemSet(rws, 0, (num_symbols+1) * sizeof(RWS_type));
    HWRMemSet(ppd, 0, (num_symbols+1) * sizeof(RWG_PPD_type));

    rwsi = 0;
    xrd_loc = 1;
    for (nl = 0; nl < w_lim && nl < nlet; nl ++)
     {
      if ((*la)[nl][0].let[0] == 0) continue; // Skip empty records

      if ((*la)[nl][1].let[0] != 0)/* If more than one answer in RecWords add brackets */
       {
        (*rws)[rwsi].type = RWST_SPLIT;
        rwsi ++;
       }

      for (i = 0; i < NUM_RW && (*la)[nl][i].let[0] != 0; i ++)
       {
        for (j = 0; j < 2 && (*la)[nl][i].let[j] != 0; j ++)
         {
          (*rws)[rwsi].sym     = (*la)[nl][i].let[j];
          (*rws)[rwsi].type    = RWST_SYM;
          (*rws)[rwsi].weight  = (*la)[nl][i].w;
          (*rws)[rwsi].src     = (*la)[nl][i].id;
          (*rws)[rwsi].d_user  = (_UCHAR)xrd_loc;
          rwsi ++;
         }

        if ((*la)[nl][1].let[0] != 0)/* If more than one answer in RecWords add brackets */
         {(*rws)[rwsi].type   = RWST_NEXT; rwsi ++;}
       }

      if ((*la)[nl][1].let[0] != 0)/* If more than one answer in RecWords add brackets */
        (*rws)[rwsi-1].type = RWST_JOIN;

      rc->caps_mode = XCM_AL_DEFSIZE;

      xrd_len = (*rec_words)[0].alias[nl] >> 4;

      xrd_loc += xrd_len;
     }

    HWRMemoryUnlockHandle(rwg->hrws_mem);
    HWRMemoryUnlockHandle(rwg->hppd_mem);

    HWRMemoryFree(la);
   }
   else /* ===================== Word variants mode ==================== */
   {

    if ((*rec_words)[0].word[0] == 0) goto err;

    num_symbols = 0;
    for (nw = 0; nw < NUM_RW && (*rec_words)[nw].word[0] != 0; nw ++)
     {
      num_symbols += HWRStrLen((p_CHAR)(*rec_words)[nw].word);
     }

    if (nw > 1) num_symbols += nw+1;     /* Reserve space for brackets and ORs */

    rwg->type     = RWGT_WORD;
    rwg->size     = num_symbols;
    rwg->hrws_mem = HWRMemoryAllocHandle((num_symbols+1) * sizeof(RWS_type));
    rwg->hppd_mem = HWRMemoryAllocHandle((num_symbols+1) * sizeof(RWG_PPD_type));

    if (rwg->hrws_mem == _NULL || rwg->hppd_mem == _NULL) goto err;

    rws = (RWS_type (_PTR)[RWS_MAX_ELS])HWRMemoryLockHandle(rwg->hrws_mem);
    ppd = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])HWRMemoryLockHandle(rwg->hppd_mem);
    HWRMemSet(rws, 0, (num_symbols+1) * sizeof(RWS_type));
    HWRMemSet(ppd, 0, (num_symbols+1) * sizeof(RWG_PPD_type));

    rwsi = 0;

    if (nw > 1)              /* If more than one answer in RecWords add brackets */
     {
      (*rws)[0].type             = RWST_SPLIT;
      (*rws)[num_symbols-1].type = RWST_JOIN;
      rwsi ++;
     }

    for (i = 0; rwsi < num_symbols-1 && i < nw; i ++)
     {
      for (j = 0; j < w_lim && (*rec_words)[i].word[j] != 0; j ++)
       {
        (*rws)[rwsi].sym    = (*rec_words)[i].word[j];
        (*rws)[rwsi].type   = RWST_SYM;
        (*rws)[rwsi].weight = (*rec_words)[i].weight;
        (*rws)[rwsi].src    = (*rec_words)[i].src_id;
        (*rws)[rwsi].d_user = 1;
        rwsi ++;
       }


      if (nw > 1 && i < nw-1) {(*rws)[rwsi].type = RWST_NEXT; rwsi ++;}
     }

    HWRMemoryUnlockHandle(rwg->hrws_mem);
    HWRMemoryUnlockHandle(rwg->hppd_mem);
   }

   if (create_rwg_ppd(rc, xrdata, rwg) != 0) goto err;

   rc->caps_mode = caps_mode;

   return 0;
err:
  rc->caps_mode = caps_mode;
  if (rwg->hrws_mem != _NULL)
   {
    HWRMemoryUnlockHandle(rwg->hrws_mem);
    HWRMemoryFreeHandle(rwg->hrws_mem);
    rwg->hrws_mem = _NULL;
   }
  if (rwg->hppd_mem != _NULL)
   {
    HWRMemoryUnlockHandle(rwg->hppd_mem);
    HWRMemoryFreeHandle(rwg->hppd_mem);
    rwg->hppd_mem = _NULL;
   }

  return 1;
 }
#endif
/* ************************************************************************** */
/* *  Create structure in form of RWG for XRWS internal calls to PP         * */
/* ************************************************************************** */
#if 0
_SHORT AskPpWeight(p_UCHAR word, _INT start, _INT end, p_RWG_type rwg, p_xrcm_type xrcm)
 {
  _INT                 i, j;
  _INT                 rwsi;
  _SHORT               ppw       = 0;
  _INT                 num_symbols;
  _INT                 ts, trace_len, cur_sl, cl;
  _INT                 new_split, prev_inp_loc, sym_loc;
  _SHORT               cx        = PYSTO;
  _SHORT               prev_voc  = PYSTO;
  _UCHAR               sym;
  _UCHAR               st_reward = xrcm->start_reward;
  p_RWS_type           prws;
  p_RWG_PPD_el_type    pppd;
  RWS_type       (_PTR rws)[RWS_MAX_ELS];
  RWG_PPD_type   (_PTR ppd)[RWS_MAX_ELS];
  trace_type      _PTR ptrace_el;
  p_UCHAR              letxrv;
  let_table_type  _PTR letxr_tabl;
  let_descr_type  _PTR let_descr;


  num_symbols = HWRStrLen((p_CHAR)word);

  if (num_symbols == 0) goto err;     /* Reserve space for brackets and ORs */
  if (rwg->rws_mem == _NULL || rwg->ppd_mem == _NULL) goto err;

  letxrv       = (p_UCHAR)xrcm->letxrv;
  letxr_tabl   = (let_table_type _PTR)xrcm->letxrv;

/* ----- Fill RWS ------------------------------------------------------- */

  rws  = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);
  ppd  = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])(rwg->ppd_mem);

  HWRMemSet(rws, 0, w_lim * sizeof(RWS_type));
  HWRMemSet(ppd, 0, w_lim * sizeof(RWG_PPD_type));

  rwsi = 0;
  prws = &(*rws)[0];

  if (start > 0)
   {
    (prws++)->sym = RWSS_PREFIX;
    rwsi ++;
   }

  for (j = 0; j < w_lim && word[j] != 0; j ++)
   {
    prws->sym     = word[j];
    prws->type    = RWST_SYM;
    prws->weight  = 0;
    prws->src_id  = 0;
    prws->d_user  = start;

    prws ++;
   }

  if (end < xrcm->xrinp_len) {j ++; (prws++)->sym = RWSS_SUFFIX;}

  rwg->size = rwsi + j;

/* ------- Find aliases ------------------------------------------------- */

  HWRStrCpy((_STR)xrcm->word, (_STR)word);
  xrcm->xrvoc_start    = (start) ? 1:0;
  xrcm->start_let      = 0;
  xrcm->end_let        = num_symbols;
  xrcm->inp_start      = start;
  xrcm->inp_end        = end;
  xrcm->trace_start    = end;

  mmc_floor(0, xrcm->xrinp_len, xrcm);
  mmc_put(&st_reward, start, 1, xrcm);

  if (voc_xr(xrcm) < 0) goto err;
  wcomp(0, -1, xrcm);

  trace_len    = xrcm->trace_len;

  cur_sl       = 0;
  cl           = 0;
  cx           = 0;
  new_split    = 1;
  prev_inp_loc = start-1;
  prev_voc     = 0;
  sym_loc      = 1;
  for (ts = trace_len-1; ts >= 0; ts --)              /* Find start point */
    if ((xrcm->p_xrvoc[0])[(xrcm->p_trace)[ts].voc].xr != XR_LINK) break;

  pppd  = &(*ppd)[rwsi+cl][cx];
  prws  = &(*rws)[rwsi+cl];

  for (ts=ts; ts >= 0; ts --)              /* Make trace walk */
   {
    ptrace_el = &(xrcm->p_trace)[ts];

    pppd  = &(*ppd)[rwsi+cl][cx];
    prws  = &(*rws)[rwsi+cl];

    if ((xrcm->p_xrvoc[0])[ptrace_el->voc].xr == XR_LINK && new_split)/* Split on main   */
     {
      if (cl == w_lim) goto err;

      pppd->xr    = (xrcm->p_xrvoc[0])[ptrace_el->voc];
      pppd->alias = ptrace_el->inp;
      prws->nvar  = cur_sl;

      if (ptrace_el->inp > prev_inp_loc) pppd->type  = ALST_CR;
       else pppd->type  = ALST_VS;

      {                 /* Recount var number */
      _INT j;
      _INT num_vars = xrcm->p_split_voc[sym_loc];

      sym    = (xrcm->p_vexvoc[0])[sym_loc];

      for (j = 0; j < 16 && j < num_vars; j ++)
        if (sym != (xrcm->p_vexvoc[j])[sym_loc]) break;

      sym = (xrcm->p_vexvoc[cur_sl])[sym_loc];
      prws->realsym = sym;

      if ((xrcm->p_vexvoc[0])[sym_loc] != sym)  /* Set bit 3 - dif. let. sign */
        if (cur_sl >= j) prws->nvar = cur_sl - j; /* It was altsym */

      }
             /* Adjust number of variant to possible skip of '7' in vex */
//      if (xrcm->vocxr_flags & USEVARSINF) // AVP for Ardulov
//        if (0) // TEMP!!!
       {
        _INT      n_vars, vex;

        sym       = OSToRec((*rws)[rwsi+cl].realsym);
        let_descr = (let_descr_type _PTR)(letxrv+(*letxr_tabl)[sym]);
        n_vars    = (_INT)let_descr->num_of_vars;


        for (i = 0, j = -1; i <= (*rws)[rwsi+cl].nvar; i ++)
         {
          j ++;
          for (; j < n_vars; j ++)
           {
            if (sym >= DTEFIRSTSYM+DTEVEXBUFSIZE) vex = (_INT)let_descr->var_veis[j];
              else vex = (*xrcm->vexbuf)[sym-DTEFIRSTSYM][j];
            if ((vex & 7) < 7) break;
           }
         }

        if (j < n_vars) prws->nvar = j;
       }

      sym_loc      = ptrace_el->voc+1;
      prev_inp_loc = ptrace_el->inp;
      new_split    = 0;
      cx           = 0;
      cl ++;
     }
     else
     {
      if ((xrcm->p_xrvoc[0])[ptrace_el->voc].xr != XR_LINK) new_split = 1;
       else continue;

      cur_sl = (xrcm->p_trace)[ts-1].sl;                        /* Get slide for cur var */
      if ((xrcm->p_xrvoc[cur_sl])[ptrace_el->voc].xr != EMPTY &&
          prev_voc < (_SHORT)ptrace_el->voc)           /* Not ot write the same */
       {
        pppd->xr    = (xrcm->p_xrvoc[cur_sl])[ptrace_el->voc];
        pppd->alias = ptrace_el->inp;
        if (ptrace_el->inp > prev_inp_loc)
         {
          if (ptrace_el->vect == ALST_CR) pppd->type  = ALST_CR;
           else pppd->type  = ALST_DS;
         }
         else pppd->type  = ALST_VS;

        prev_voc             = ptrace_el->voc;
        prev_inp_loc         = ptrace_el->inp;

        cx ++;
        if (cx > XR_SIZE) goto err;
       }
     }
   }




/* ------- Make PosProcessing ------------------------------------------- */

  if (xrcm->inverse == 0)
     rwg->bReversePass = _FALSE;
  else
     rwg->bReversePass = _TRUE;
  EvaluateInUpperLevel(rwg);

/* ------- Recalc weights ----------------------------------------------- */

  for (i = 0, prws = &(*rws)[0]; i < w_lim && prws->sym != RWSS_NULL; i ++, prws ++)
   {
    ppw += prws->weight;
   }


/* ---------------------------------------------------------------------- */

  ppw = ppw/2;


  return ppw;
err:
  return 0;
 }
#endif
/* ************************************************************************* */
/*        Create Post Processing Data function                               */
/* ************************************************************************* */
_INT create_rwg_ppd(p_xrcm_type xrcm_ext, rc_type _PTR rc, p_xrdata_type xrdata, p_RWG_type rwg)
 {
  _INT           i, ns;
  _INT           cur_xr_len, num_segments, xrd_size;
  RWS_type       (_PTR rws)[RWS_MAX_ELS] = _NULL;
  RWG_PPD_type   (_PTR ppd)[RWS_MAX_ELS] = _NULL;
  xrdata_type    xrd                     = {0};
  _UCHAR         graph_st[w_lim];
  _UCHAR         xrd_st[w_lim];
  _SHORT         caps_mode = rc->caps_mode;
  xrcm_type _PTR xrcm = xrcm_ext;

  if (rwg->rws_mem == _NULL) goto err;
  if (rwg->ppd_mem != _NULL) goto err;

  rws  = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);

  xrd_size = xrdata->len;
  if (xrd_size < 3) goto err;

  rwg->ppd_mem = HWRMemoryAlloc((rwg->size+1) * sizeof(RWG_PPD_type));
  if (rwg->ppd_mem == _NULL) goto err;

  ppd = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])(rwg->ppd_mem);
  HWRMemSet(ppd, 0, (rwg->size+1) * sizeof(RWG_PPD_type));

  cur_xr_len = -1;
  for (i = 0, num_segments = 0; i < rwg->size; i ++)
   {
    if ((*rws)[i].type != RWST_SYM) continue;

    if ((*rws)[i].d_user != cur_xr_len)
     {
      graph_st[num_segments] = (_UCHAR)i;
      xrd_st[num_segments]   = (*rws)[i].d_user;

      cur_xr_len = (*rws)[i].d_user;
      num_segments ++;
     }
   }
  xrd_st[num_segments] = (_UCHAR)xrd_size;


  graph_st[num_segments] = (_UCHAR)rwg->size;


  AllocXrdata(&xrd, xrd_size+1);
  if (xrd.xrd == _NULL) goto err;

  if (num_segments > 1) xrcm = _NULL;

  (*xrd.xrd)[0] = (*xrdata->xrd)[0];

  for (ns = 0; ns < num_segments; ns ++)
   {
    xrd.len = xrd_st[ns+1]-xrd_st[ns]+1;
    HWRMemCpy(&(*xrd.xrd)[1], &(*xrdata->xrd)[xrd_st[ns]], (xrd_st[ns+1]-xrd_st[ns])*sizeof(xrd_el_type));
    HWRMemSet(&(*xrd.xrd)[(xrd_st[ns+1]-xrd_st[ns])+1], 0, sizeof(xrd_el_type));
    if (!(IS_XR_LINK((*xrd.xrd)[(xrd_st[ns+1]-xrd_st[ns])].xr.type)))
      (*xrd.xrd)[(xrd_st[ns+1]-xrd_st[ns])+1] = (*xrdata->xrd)[0];
//     else
//      (*xrd.xrd)[(xrd_st[ns+1]-xrd_st[ns])] = (*xrdata->xrd)[0];

    if (ns == 1) /* On all letters after first recount caps flags */
     {
      rc->caps_mode &= ~(XCM_FL_DEFSIZEp | XCM_FL_TRYCAPSp);
      if (rc->caps_mode & XCM_AL_DEFSIZEp) rc->caps_mode |= XCM_FL_DEFSIZEp;
      if (rc->caps_mode & XCM_AL_TRYCAPSp) rc->caps_mode |= XCM_FL_TRYCAPSp;
     }

if (rwg->type == RWGT_SEPLET) rc->caps_mode = XCM_AL_DEFSIZE; // AVP->CHE

    if (create_rwg_ppd_node(xrcm, rc, (_INT)xrd_st[ns]-1, &xrd, (_INT)graph_st[ns], (_INT)graph_st[ns+1], rwg)) goto err;
   }


  FreeXrdata(&xrd);
  rc->caps_mode    = caps_mode;
  return 0;
err:
  FreeXrdata(&xrd);
  if (rwg->ppd_mem != _NULL) {HWRMemoryFree(rwg->ppd_mem); rwg->ppd_mem = _NULL;}
  rc->caps_mode    = caps_mode;
  return 1;
 }

/* ************************************************************************* */
/*        Create Post Processing Data function                               */
/* ************************************************************************* */
_INT create_rwg_ppd_node(p_xrcm_type xrcm_ext, rc_type _PTR rc, _INT xrd_loc, p_xrdata_type xrd, _INT rws_st, _INT rws_end, p_RWG_type rwg)
 {
  _INT           i, j, rwsi;
  _INT           wn;
//  _INT           m_cm;
  _INT           cx, cl;
  _INT           pp, ip;
  _INT           w_len;
  _INT           beg, end, f_let;
  _UCHAR         vect;
  _UCHAR         xl;
  xrcm_type _PTR xrcm = xrcm_ext;
  RWS_type       (_PTR rws)[RWS_MAX_ELS] = _NULL;
  RWG_PPD_type   (_PTR ppd)[RWS_MAX_ELS] = _NULL;

  if (rwg->rws_mem == _NULL || rwg->ppd_mem == _NULL) goto err;

  if (xrcm_ext == _NULL) if (xrmatr_alloc(rc, xrd, &xrcm) != 0) goto err;

//  m_cm = xrcm->caps_mode;

  rws  = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);
  ppd  = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])(rwg->ppd_mem);

  rwsi = rws_st;
  if ((*rws)[rwsi].type == RWST_SPLIT) rwsi ++;

  xl = (_UCHAR)xrd_loc;

  for (wn = 0; wn < NUM_RW; wn ++)/* Cycle by answers */
   {
    for (i = 0; i < w_lim && (rwsi+i) < rws_end; i ++)
     {
      if ((*rws)[rwsi+i].type != RWST_SYM) break;
      xrcm->word[i] = (_CHAR)(*rws)[rwsi+i].sym;
     }

    w_len = i; xrcm->word[w_len] = 0;

//    if ((*rws)[rwsi].attr & XRWS_VOCCAPSFLAG) xrcm->caps_mode = m_cm;
//      else xrcm->caps_mode = XCM_AL_DEFSIZE;


    SetInitialLine(DTI_XR_SIZE/3, xrcm);
    if (CountWord(xrcm->word, xrcm->caps_mode, xrcm->flags | XRMC_DOTRACING, xrcm)) goto err;

    if (xrcm->p_hlayout == _NULL) goto err;

    for (cl = 0; cl < w_len; cl ++)
     {
      _INT t;
      p_letlayout_hdr_type  plsym = xrcm->p_hlayout->llhs[cl];

      (*rws)[rwsi+cl].nvar    = plsym->var_num;
      (*rws)[rwsi+cl].realsym = plsym->realsym;
      (*rws)[rwsi+cl].letw    = (_SCHAR)xrcm->letter_weights[cl];

      for (t = 0, pp = -1, ip = 0, cx = 0; t < plsym->len; t ++)
       {
        p_tr_pos_type trp = &(plsym->trp[t]);

        if (trp->xrp_num != pp)
         {
          if (trp->vect == XRMC_T_CSTEP) vect = XRWG_ALST_CR;
          if (trp->vect == XRMC_T_PSTEP)
           {
            if (ip) vect = XRWG_ALST_DS;
             else   vect = XRWG_ALST_VS;
           }

          (*ppd)[rwsi+cl][cx].alias = (_UCHAR)(trp->inp_pos + xl);
          (*ppd)[rwsi+cl][cx].type  = vect;

          pp = trp->xrp_num;
          cx ++;
          ip = 0;
         }
         else ip = 1;
       }

      (*ppd)[rwsi+cl][cx].type = 0;
     }

    FreeLayout(xrcm);


    rwsi += w_len;
    if ((*rws)[rwsi].type != RWST_NEXT) break; /* All variants here used */
     else rwsi ++;

    if (rwsi >= rws_end) break;
    if (rwsi >= rwg->size) break;
   }                                                    /* End of cyc by answers */


  /* --------------------- Count beginings and lengths ------------------ */


  for (i = rws_st; i < rws_end; i ++)
   {

    if ((*rws)[i].type != RWST_SYM) {f_let = 1; continue;}

    if (f_let) beg = xrd_loc+1; /* Include all skips in first letter len */
     else
     {
      for (j = 0, beg = (*ppd)[i][0].alias; j < DTI_XR_SIZE && (*ppd)[i][j].type != 0; j ++)
        if ((*ppd)[i][j].type != 2) {beg = (*ppd)[i][j].alias; break;}
     }

    for (j = 0; j < DTI_XR_SIZE && (*ppd)[i][j].type != 0; j ++);
    if  (j > 0)  end = (*ppd)[i][j-1].alias; else end = 0;

    (*rws)[i].xrd_beg = (_UCHAR)beg;
    (*rws)[i].xrd_len = (_UCHAR)((end - beg >= 0) ? (end-beg+1) : 0);

    f_let = 0;
   }

  if (xrcm_ext == _NULL) xrmatr_dealloc(&xrcm);

  return 0;
err:
  FreeLayout(xrcm);
  if (xrcm_ext == _NULL) xrmatr_dealloc(&xrcm);
  return 1;
 }

/* ************************************************************************* */
/*        Create Post Processing Data function                               */
/* ************************************************************************* */
_INT  fill_RW_aliases(rec_w_type (_PTR rec_words)[NUM_RW], p_RWG_type rwg)
 {
  _INT        nw, nl, rwsi;
  _INT        first;
  p_RWS_type  rws = _NULL;

  if (rwg->type == RWGT_SEPLET)
   {
    rws = (p_RWS_type)(rwg->rws_mem);

    if (rws == _NULL) goto err;

    for (rwsi = 0, nl = 0, first = 1; rwsi < rwg->size; rwsi ++)
     {
      if (rws[rwsi].type == RWST_SPLIT) first = 1;
      if (rws[rwsi].type != RWST_SYM) continue;

      if (first)
       {
        (*rec_words)[0].nvar[nl] = rws[rwsi].nvar;
        (*rec_words)[0].linp[nl] = rws[rwsi].xrd_len;

        if ((*rec_words)[0].word[nl] != rws[rwsi].realsym)
          (*rec_words)[0].nvar[nl] |= XRWG_FCASECHANGE;  /* Set bit of symbol change */

        nl ++;
        first = 0;
       }
     }

    for (nw = 1; nw < NUM_RW && (*rec_words)[nw].word[0] != 0; nw ++)
     {
      HWRMemCpy((*rec_words)[nw].linp, (*rec_words)[0].linp, sizeof((*rec_words)[0].linp));
      HWRMemCpy((*rec_words)[nw].nvar, (*rec_words)[0].nvar, sizeof((*rec_words)[0].nvar));
     }
   }

  if (rwg->type == RWGT_WORD  ||  rwg->type == RWGT_WORDP)
   {
    rws = (p_RWS_type)(rwg->rws_mem);

    if (rws == _NULL) goto err;

    for (nw = 0, rwsi = 0; nw < NUM_RW && rwsi < rwg->size; rwsi ++)
     {
      if (rws[rwsi].type != RWST_SYM) continue;

      for (nl = 0; nl < w_lim && rws[rwsi].type == RWST_SYM; nl ++, rwsi ++)
       {
        (*rec_words)[nw].nvar[nl] = rws[rwsi].nvar;
        (*rec_words)[nw].linp[nl] = rws[rwsi].xrd_len;
        (*rec_words)[nw].word[nl] = rws[rwsi].sym; //CHE: since it could be changed
        if (ToLower((*rec_words)[nw].word[nl])
               != ToLower(rws[rwsi].realsym))
         {
          (*rec_words)[nw].linp[0] = 0; //if PPD changed sym, then do no aliases
         }
        if ((*rec_words)[nw].word[nl] != rws[rwsi].realsym)
          (*rec_words)[nw].nvar[nl] |= XRWG_FCASECHANGE;  /* Set bit of symbol change */
       }

      nw ++;
     }
   }

  return 0;
err:
  return 1;
 }

/* ************************************************************************* */
/* *    Get aliases to a given word on given XrData                        * */
/* ************************************************************************* */
_INT GetCMPAliases(p_xrdata_type xrdata, p_RWG_type rwg, p_CHAR word, rc_type  _PTR rc)
 {
  _INT i;
  p_RWS_type     prws = _NULL;
  p_RWG_PPD_type ppd  = _NULL;

  rwg->rws_mem = _NULL;
  rwg->ppd_mem = _NULL;

  rwg->type = RWGT_WORD;
  rwg->size = HWRStrLen((_STR)word);

  rwg->rws_mem = HWRMemoryAlloc((rwg->size + 1)*sizeof(RWS_type));
  if (rwg->rws_mem == _NULL) goto err;

  prws = (p_RWS_type)(rwg->rws_mem);

  HWRMemSet(prws, 0, (rwg->size + 1)*sizeof(RWS_type));

  for (i = 0; i < rwg->size; i ++)
   {
    prws[i].sym    = word[i];
    prws[i].weight = 100;
    prws[i].d_user = 1;
    prws[i].type = RWST_SYM;
   }

  if (create_rwg_ppd(_NULL, rc, xrdata, rwg)) goto err;

  ppd = (p_RWG_PPD_type)rwg->ppd_mem;
  if (ppd == _NULL) goto err;

//  /*  Ok, we have the data. Now fill the word */
//  /* data for the output word.                */
//  for (i = 0; i < rwg->size; i ++)
//   {
//     prw->word[i] = prws[i].sym;
//     prw->nvar[i] = prws[i].nvar;
//     prw->linp[i] = prws[i].xrd_len;
//     if (prws[i].sym != prws[i].realsym) prw->nvar[i] |= XRWG_FCASECHANGE;
//   }

  return 0;
err:
  if (rwg->rws_mem != _NULL) {HWRMemoryFree(rwg->rws_mem); rwg->rws_mem = _NULL;}
  if (rwg->ppd_mem != _NULL) {HWRMemoryFree(rwg->ppd_mem); rwg->ppd_mem = _NULL;}

  return 1;
 }

/* ************************************************************************* */
/*        Sort Graph accroding to index                                      */
/* ************************************************************************* */
_INT SortGraph(_INT (_PTR index)[NUM_RW], p_RWG_type rwg)
 {
  _INT         i, j, k, n, nw, st;
  RWS_type     (_PTR rws)[RWS_MAX_ELS], (_PTR rws1)[RWS_MAX_ELS] = _NULL;
  RWG_PPD_type (_PTR ppd)[RWS_MAX_ELS], (_PTR ppd1)[RWS_MAX_ELS] = _NULL;

  rws  = (RWS_type (_PTR)[RWS_MAX_ELS])(rwg->rws_mem);
  ppd  = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])(rwg->ppd_mem);

  if (rws == _NULL) goto err;
  if (ppd == _NULL) goto err;

  rws1 = (RWS_type (_PTR)[RWS_MAX_ELS])HWRMemoryAlloc(rwg->size*sizeof(RWS_type));
  ppd1 = (RWG_PPD_type (_PTR)[RWS_MAX_ELS])HWRMemoryAlloc(rwg->size*sizeof(RWG_PPD_type));

  if (rws1 == _NULL) goto err;
  if (ppd1 == _NULL) goto err;

  for (j = 1, nw = 0; j < rwg->size; j ++) if ((*rws)[j].type != RWST_SYM) nw ++;

  for (i = 0, k = 1; i < nw; i ++)
   {
    for (j = 1, st = 1, n = 0; j < rwg->size; j ++)
     {
      if ((*rws)[j].type != RWST_SYM)
       {
        if (n == (*index)[i])
         {
          HWRMemCpy(&(*rws1)[k], &(*rws)[st], (j-st)*sizeof(RWS_type));
          HWRMemCpy(&(*ppd1)[k], &(*ppd)[st], (j-st)*sizeof(RWG_PPD_type));

          k += j-st;
          HWRMemSet(&(*ppd1)[k], 0, sizeof(RWG_PPD_type));
          (*rws1)[k++].type = RWST_NEXT;

          break;
         }

        n ++;
        st = j + 1;
       }
     }
   }

  (*rws1)[0]   = (*rws)[0];
  (*rws1)[k-1] = (*rws)[rwg->size-1];
  rwg->size = k;

  rwg->rws_mem = rws1;
  rwg->ppd_mem = ppd1;
  HWRMemoryFree(rws);
  HWRMemoryFree(ppd);


  return 0;
err:
  if (rws1) HWRMemoryFree(rws1);
  if (ppd1) HWRMemoryFree(ppd1);
  return 1;
 }
#endif // indef PEGASUS
/* ************************************************************************** */
/* *  END OF ALL                                                            * */
/* ************************************************************************** */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\inc\centipede.h ===
#ifndef CENTIPEDE_H
#define CENTIPEDE_H

#include <score.h>
#include <inkbox.h>

typedef struct CENTIPEDE_INFO {
	WORD				cCodePoints;			// Number of supported code points.
	DWORD				cCharClasses;			// Number of character classes
	BYTE				*pDch2CharClassMap;		// Convert a Dense code to a character class
	SCORE_GAUSSIAN		*pScoreGaussianUnigrams;
	SCORE_GAUSSIAN		*pScoreGaussianBigrams;
	
	// Fields to map a database file containing Centipede's data.
	HANDLE				hFile;
	HANDLE				hMap;
	BYTE				*pbMapping;
} CENTIPEDE_INFO;

// Load runtime localization information from a resource.
BOOL
CentipedeLoadRes(CENTIPEDE_INFO *pCentipedeInfo, HINSTANCE hInst, int nResID, int nType, LOCRUN_INFO *pLocRunInfo);

// Load and unload runtime localization information from a file.
BOOL
CentipedeLoadFile(CENTIPEDE_INFO *pCentipedeInfo, wchar_t *pPath, LOCRUN_INFO *pLocRunInfo);

BOOL
CentipedeUnloadFile(CENTIPEDE_INFO *pCentipedeInfo);

// Load runtime localization information from an image already loaded into memory.
BOOL
CentipedeLoadPointer(
	CENTIPEDE_INFO *pCentipedeInfo, 
	void *pData, 
	LOCRUN_INFO *pLocRunInfo
);

/* Assuming a single character written in a box that was drawn on the screen, this routine computes the probability of the 
particular x, y, w, h combination given the character.  All coordinates used below
must be scaled so the width of the bounding box is exactly 1000.

pUnigramParams: must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H on input.  None changed on output

*/

SCORE
ShapeUnigramBoxCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch,	// Character to be analyzed
	int *pUnigramParams
);

/* Assuming two characters written on the screen with a guide (boxed input), this routine computes the probability of the 
particular combination given the characters.  This routine assumes horizontal writing.  Scaling requires width of drawn boxes be 1000.

pUnigramParams (left and right): must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H, INKSTAT_MARGIN_W on input.  
None changed on output.  

*/

SCORE
ShapeBigramBoxCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch1,	// Left character
	wchar_t dch2,	// Right character
	int *pLeftUnigramParams,
	int *pRightUnigramParams
);	

/* Assuming a single character written on the screen with no guide (free input), this routine computes the probability of the 
particular w, h combination given the character.

pUnigramParams: must set INKSTAT_W and INKSTAT_H on input.  None changed on output

*/

SCORE
ShapeUnigramFreeCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch,	// Character to be analyzed
	int *pUnigramParams
);

/* Assuming two characters written on the screen with no guide (free input), this routine computes the probability of the 
particular combination given the characters.  This routine assumes (but does not require) horizontal writing.  The bounding
box containing both characters must be scaled to 2000.

pBigramParams: must set INKBIN_W_LEFT, INKBIN_W_GAP, INKBIN_W_RIGHT, INKBIN_H_LEFT, INKBIN_H_GAP, INKBIN_H_RIGHT,  on input.  
None changed on output

*/


SCORE
ShapeBigramFreeCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch1,	// Left character
	wchar_t dch2,	// Right character
	int *pBigramParams
);	

/* Given a character and the width and height of its bounding box, return the width and height of the imaginary box
a user would probably have drawn around it, plus the x and y offset to place the character inside that box 

pUnigramParams: must set INKSTAT_W and INKSTAT_H on input.  On output, returns INKSTAT_BOX_W, INKSTAT_BOX_H, INKSTAT_X, and INKSTAT_Y
*/

void
ShapeUnigramBaseline(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch,
	int *pUnigramParams
);

/* Given a set of Unigram parameters, rescale so INKSTAT_BOX_W == 1000

pUnigramParams: must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H, INKSTAT_BOX_W
On Output, INKSTAT_BOX_W == 1000 and the others are scaled proportionately
*/

void
CentipedeNormalizeUnigram(
	int *pUnigramParams
);

/* Given a set of Bigram parameters, rescale so INKBIN_W_LEFT+INKBIN_W_GAP+INKBIN_W_RIGHT == 2000 

pBigramParams: must set INKBIN_W_LEFT, INKBIN_W_GAP, INKBIN_W_RIGHT, INKBIN_H_LEFT, INKBIN_H_GAP, INKBIN_H_RIGHT  
On Output, INKBIN_W_LEFT+INKBIN_W_GAP+INKBIN_W_RIGHT == 2000 and the others are scaled proportionately
*/

void
CentipedeNormalizeBigram(
	int *pBigramParams
);

/* Given two sets of Unigram Parameters, generate a set of Bigram Parameters.  Assumes inputs are aligned horizontally
and that INKSTAT_BOX_W == 1000
Input pUnigramParams (left and right): must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H, INKSTAT_MARGIN_W.
Output pBigramParams: INKBIN_W_LEFT, INKBIN_W_GAP, INKBIN_W_RIGHT, INKBIN_H_LEFT, INKBIN_H_GAP, INKBIN_H_RIGHT
Output is NOT normalized.
*/

void
CentipedeUnigramToBigram(
	int *pLeftUnigramParams,
	int *pRightUnigramParams,
	int *pBigramParams
);

#endif // CENTIPEDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\bear\src\zctype.cpp ===
/*******************************************************************\
 This file provide several functions as replacement for standard ones
 from file <ctype.?>        created Jun-15-93 by bigor, AVP Jan-16-94
\*******************************************************************/

#include "bastypes.h"
#ifndef HWR_SYSTEM_NO_LIBC
#include <ctype.h>
#endif
#include "zctype.h"

/*******************************************************************/
#define _2UC(n) (unsigned int)((n)&0x00ff)
#define _CHECK_RANGE(n) ((n) <= 0xff)
#define _SEEK_RANGE  0x100
#define _ZTERM  '\0'

#define True 1
#define False 0

#define _UPPER      0x1     /* upper case letter */
#define _LOWER      0x2     /* lower case letter */
#define _DIGIT      0x4     /* digit[0-9] */
#define _SPACE      0x8     /* tab, carriage return, newline, */
                            /* vertical tab or form feed */
#define _PUNCT      0x10    /* punctuation character */
#define _CONTROL    0x20    /* control character */
#define _BLANK      0x40    /* space char */
#define _HEX        0x80    /* hexadecimal digit */


ROM_DATA_EXTERNAL unsigned char  _xctype[];
ROM_DATA_EXTERNAL unsigned char  _xupper[];
ROM_DATA_EXTERNAL unsigned char  _xlower[];

/*******************************************************************/
int
#ifdef _FLAT32
IsUpper
#else 
isupper 
#endif /* _FLAT32 */
        (int n) {
register unsigned int m;
    m = _2UC(n);
    if _CHECK_RANGE(m)
        if ((_xctype[m] & _UPPER) != 0) return True;

  return False;
}

/*******************************************************************/
int
#ifdef _FLAT32
IsLower
#else 
islower 
#endif /* _FLAT32 */
        (int n) {
register unsigned int m;
    m = _2UC(n);
    if _CHECK_RANGE(m)
        if ((_xctype[m] & _LOWER) != 0) return True;

  return False;
}

/*******************************************************************/
int  
#ifdef _FLAT32
IsPunct
#else 
ispunct 
#endif /* _FLAT32 */
        (int n) {
register unsigned int m;
    m = _2UC(n);
    if _CHECK_RANGE(m)
        if ((_xctype[m] & _PUNCT) != 0) return True;

  return False;
}

/*******************************************************************/
int  
#ifdef _FLAT32
IsAlnum
#else 
isalnum 
#endif /* _FLAT32 */
        (int n) {
#ifdef _FLAT32
  return (int)(IsAlpha(n) || IsDigit(n));
#else
  return (int)(isalpha(n) || isdigit(n));
#endif /* _FLAT32 */ 
}

/*******************************************************************/
int  
#ifdef _FLAT32
IsAlpha
#else 
isalpha 
#endif /* _FLAT32 */
        (int n) {
#ifdef _FLAT32
  if (IsUpper(n) || IsLower(n)) return True;

#else
    if (isupper(n) || islower(n)) return True;
#endif /* _FLAT32 */ 
  return False;
}

/*******************************************************************/
int  
#ifdef _FLAT32
ToUpper
#else 
toupper 
#endif /* _FLAT32 */
        (int n) {
register unsigned int m;
    m = _2UC(n);
#ifdef _FLAT32

  if (IsAlpha(n))

#else
    if (isalpha(n))
#endif /* _FLAT32 */ 
  #if HALF_TABLE
    if (m > 0x7f)
        return (int)_xupper[m&0x7f];
    else if (m >= 'a' && m <= 'z')
        return m - 0x20;
  #else
    return (int)_xupper[m];
  #endif /* HALF_TABLE */

  return n;
 }

/*******************************************************************/
int  
#ifdef _FLAT32
ToLower
#else 
tolower 
#endif /* _FLAT32 */
        (int n) {
  register unsigned int m;

  m = _2UC(n);
#ifdef _FLAT32
  if (IsAlpha(n))
#else
    if (isalpha(n))
#endif /* _FLAT32 */ 
  #if HALF_TABLE
    if (m > 0x7f)
      return (int)_xlower[m&0x7f];
     else if (m >= 'A' && m <= 'Z')
      return m + 0x20;
  #else
     return (int)_xlower[m];
  #endif
    return n;
 }

/*******************************************************************/
char *  
#ifdef _FLAT32
StrLwr
#else
strlwr
#endif /* _FLAT32 */
        (char * str) {
  char *  buf;

  buf = str;
  if (str)
    while (*str != _ZTERM) 
      *str++ = 
#ifdef _FLAT32
          (char)ToLower((int)*str);
#else
          (char)tolower((int)*str);
#endif /* _FLAT32 */

  return buf;
 }

/*******************************************************************/
char *
#ifdef _FLAT32
StrUpr
#else
strupr
#endif /* _FLAT32 */
        (char * str) {
  char *  buf;

  buf = str;
  if (str)
    while (*str != _ZTERM) 
      *str++ = 
#ifdef _FLAT32
          (char)ToUpper((int)*str);
#else
          (char)toupper((int)*str);
#endif /* _FLAT32 */

  return buf;
 }

/*******************************************************************/
int IsDigit (int n) 
 {
#if defined(PEGASUS) || defined(HWR_SYSTEM_NO_LIBC)
  return (int)(n >= '0' && n <= '9') ? 1 : 0;
#else  
  return (int)isdigit(n);
#endif
 }
/*******************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\inc\inkbox.h ===
/* Common header file for ink2box and box2tab tools.  This defines the various statistical structures used by both tools */

#ifndef INKBOX_H
#define INKBOX_H

typedef struct INKSTATS {
	int cx;		// Total number of values
	double sumx;	// Sum of all values
	double sumx2;	// Sum of squares of all values
} INKSTATS;

/* We conpute stats for each character based on position of the bounding box within the guide box (x and y) and
the width and height of the bounding box (w and h). */

#define INKSTAT_CX			0
#define INKSTAT_CY			1
#define INKSTAT_W			2
#define INKSTAT_H			3
#define INKSTAT_X			4
#define INKSTAT_Y			5		// Last stat used in tables
#define INKSTAT_STROKES		6		// Here and below are for curiosity purposes
#define INKSTAT_BOX_W		7
#define INKSTAT_BOX_H		8
#define INKSTAT_MARGIN_W	9		// actually, we use this one too
#define INKSTAT_MARGIN_H	10
#define INKSTAT_RATIO_W_H	11		// Aspect ratio W/H
#define INKSTAT_RATIO_H_W	12		// Aspect ratio H/W
#define INKSTAT_ALL		13

#define INKSTAT_STD	(INKSTAT_H+1)

/* Offsets for binary ink statistics */

#define INKBIN_W_LEFT	0	// Width of left-hand character
#define INKBIN_W_GAP	1	// Space between characters 
#define INKBIN_W_RIGHT	2	// Width of right-hand character
#define INKBIN_H_LEFT	3	// Height of left-hand character
#define INKBIN_H_GAP	4	// Vertical space between characters
#define INKBIN_H_RIGHT	5	// height of right-hand character
#define INKBIN_ALL		6

#define INKBIN_LW_RW	0	// Ratio of left width to right width
#define INKBIN_LH_RH	1	// Ratio of left height to right height 
#define INKBIN_LW_RH	2	// Ratio of left width to right height
#define INKBIN_RW_LH	3	// Ratio of right width to left height
#define INKBIN_V_POS	4	// Vertical position difference
#define INKBIN_TBD		5	// TBD

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\inc\centipedep.h ===
// FILE: CentipedeP.h
//
// Structures and functions internal to the library that are used to access the 
// Shape Unigram/Bigram information.
//

// The format of the Shape Unigram/Bigram file is:
//		Header:
//			DWORD		File type indicator
//			DWORD		Size of header
//			BYTE		Lowest version this code that can read this file
//			BYTE		Version of this code that wrote this file
//			DWORD * 3	Signature of the source file (see description below)
//			WORD		Number of supported code points (and size of Dense To Unicode map table).
//			WORD		Number of character classes
//		DenseCode-to-CharacterClass Mapping Table (one entry for each dense code)
//			BYTE		class DenseCode 0 maps to
//			BYTE		class DenseCode 1 maps to
//				.
//				.
//				.
//		Shape Unigram Table:
//			SCORE_GAUSSIAN	rgUnigram[number-of-char-classes][INKSTAT_ALL]
//		Shape Bigram Table:
//			SCORE_GAUSSIAN	rgrgBigram[number-of-char-classes][number-of-char-classes][INKBIN_ALL]
//

//
// Constants
//

// Magic key the identifies the Local Runtime files
#define	CENTIPEDE_FILE_TYPE	0x82980562

// Version information for file.
#define	CENTIPEDE_MIN_FILE_VERSION		0		// First version of code that can read this file
#define CENTIPEDE_CUR_FILE_VERSION		0		// Current version of code.
#define	CENTIPEDE_OLD_FILE_VERSION		0		// Oldest file version this code can read.


/* Output Header File */

typedef struct CENTIPEDE_HEADER {
	DWORD		fileType;			// This should always be set to CENTIPEDE_FILE_TYPE.
	DWORD		adwSignature[3];	// A signature computed form the loc info
	WORD		headerSize;			// Size of the header.
	WORD		cCodePoints;		// Number of supported code points.
	BYTE		minFileVer;			// Earliest version of code that can read this file
	BYTE		curFileVer;			// Current version of code that wrote the file.
	WORD		pad1;				// Common header is 64-bit aligned (24 bytes)

									// DWORD0:	Date/Time Stamp (time_t)
									// DWORD1:	XORING ALC values for all CPs
									// DWORD2	HIWORD: XORING ALL Valid CPs
									//			LOWORD: XORING ALL BasLn,Hgt Info
	
	DWORD		cCharClasses;		// Number of character classes
	DWORD		pad2;				// Full header is also 64-bit aligned (32 bytes)
} CENTIPEDE_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\src\centipede.c ===
// Centipede.c

#include <stdlib.h>
#include <stdio.h>
#include "common.h"
#include <math.h>
#include <memory.h>
#include <score.h>
#include <centipede.h>
#include <inkbox.h>
#include "centipedep.h"

// Load runtime localization information from an image already loaded into memory.
BOOL
CentipedeLoadPointer(
	CENTIPEDE_INFO *pCentipedeInfo, 
	void *pData, 
	LOCRUN_INFO *pLocRunInfo
) {
	const CENTIPEDE_HEADER	*pHeader	= (CENTIPEDE_HEADER *)pData;
	BYTE				*pScan;
	int i;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != CENTIPEDE_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > CENTIPEDE_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < CENTIPEDE_OLD_FILE_VERSION)
	) {
		goto error;
	}

	// verify signature -- otherwise this was built with a different loc file
	if (memcmp(pHeader->adwSignature, pLocRunInfo->adwSignature, sizeof(pHeader->adwSignature)) != 0) {
		goto error;
	}

	// Fill in information from header.
	pCentipedeInfo->cCodePoints		=	pHeader->cCodePoints;

	pCentipedeInfo->cCharClasses		=	pHeader->cCharClasses;

	// Fill in pointers to the other data in the file
	pScan							= (BYTE *)pData + pHeader->headerSize;
	pCentipedeInfo->pDch2CharClassMap		= (BYTE *)pScan;

	/* Calculate the size of the Dense-to-class mapping (including the paddint to 64-bits) and skip over it. */

	i = pCentipedeInfo->cCodePoints;
	while (i%8) {
		++i;
	}

	pScan += i;

	pCentipedeInfo->pScoreGaussianUnigrams = (SCORE_GAUSSIAN *)pScan;
	pScan += pCentipedeInfo->cCharClasses*INKSTAT_ALL*sizeof(SCORE_GAUSSIAN);

	pCentipedeInfo->pScoreGaussianBigrams = (SCORE_GAUSSIAN *)pScan;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

error:
	return FALSE;
} // CentipedeLoadPointer

/* Assuming a single character written in a box that was drawn on the screen, this routine computes the probability of the 
particular x, y, w, h combination given the character.  All coordinates used below
must be scaled so the width of the bounding box is exactly 1000.

pUnigramParams: must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H on input.  None changed on output

*/

SCORE
ShapeUnigramBoxCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch,	// Character to be analyzed
	int *pUnigramParams
) {
	SCORE scoreTotal, score;
	int i;
	int iClass;
	SCORE_GAUSSIAN *pScoreGaussianUnigrams;

	iClass = pCentipedeInfo->pDch2CharClassMap[dch];
	if (iClass == (BYTE)(-1)) {
		iClass = 0;
	}

	scoreTotal = 0;

	pScoreGaussianUnigrams = pCentipedeInfo->pScoreGaussianUnigrams + iClass*INKSTAT_ALL;
	for (i = 0; i < INKSTAT_STD; ++i) {
		score = ScoreGaussianPoint(pUnigramParams[i],pScoreGaussianUnigrams);
		scoreTotal = ScoreMulProbs(scoreTotal,score);
		pScoreGaussianUnigrams++;
	}

	return (scoreTotal);	
} // ShapeUnigramBoxCost

/* Assuming a single character written on the screen with no guide (free input), this routine computes the probability of the 
particular w, h combination given the character.

pUnigramParams: must set INKSTAT_W and INKSTAT_H on input.  None changed on output

*/

SCORE
ShapeUnigramFreeCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch,	// Character to be analyzed
	int *pUnigramParams
) {
	int iClass, iNum, iDenom, iRatio, ratio;
	SCORE score;

	iNum = INKSTAT_W;
	iDenom = INKSTAT_H;
	iRatio = INKSTAT_RATIO_W_H;

	if (pCentipedeInfo->pScoreGaussianUnigrams[INKSTAT_W].mean > pCentipedeInfo->pScoreGaussianUnigrams[INKSTAT_H].mean) {
		iNum = INKSTAT_H;
		iDenom = INKSTAT_W;
		iRatio = INKSTAT_RATIO_H_W;
	}

	iClass = pCentipedeInfo->pDch2CharClassMap[dch];
	if (iClass == (BYTE)(-1)) {
		iClass = 0;
	}


	ratio = pUnigramParams[iNum]*1000 + pUnigramParams[iDenom]/2;
	if (pUnigramParams[iDenom] > 0) {
		ratio /= pUnigramParams[iDenom];
	}

	score = ScoreGaussianPoint(ratio,&pCentipedeInfo->pScoreGaussianUnigrams[iClass*INKSTAT_ALL + iRatio]);

	return (score);
}

/* Given a scale factor, scale the bigram params and compute the total score */

SCORE
ScaleBigramParams(
	int num,
	int denom, 
	int *pBigramParams,
	SCORE_GAUSSIAN *pScoreGaussianBigrams
) {
	int i, denom2;
	SCORE score, scoreTotal;

	denom2 = denom/2;

	/* Instead of divide by zero, treat as a delta function */

	if (denom == 0) {
		denom = 1;
	}

	for (i = 0; i < INKBIN_ALL; ++i) {
		pBigramParams[i] *= num;
		if (pBigramParams[i] > 0) {
			pBigramParams[i] += denom2;
		} else {
			pBigramParams[i] -= denom2;
		}

		pBigramParams[i] /= denom;
	}

	/* Multiply out the costs computed all three ways.  For the standard placement, all are computed
	directly.  For the horizontally displaced, we act as if the character were at the mean displacement horizontally,
	and for the vertically displaced, we use vertical and horizontal means */

	scoreTotal = SCORE_ONE;
	for (i = 0; i < INKBIN_ALL; ++i) {
		score = ScoreGaussianPoint(pBigramParams[i],&pScoreGaussianBigrams[i]);
		scoreTotal = ScoreMulProbs(scoreTotal,score);
	}

	return (scoreTotal);

} // ScaleBigramParams

/* Assuming two characters written on the screen with no guide (free input), this routine computes the probability of the 
particular combination given the characters.  This routine assumes (but does not require) horizontal writing.  The bounding
box containing both characters must be scaled to 2000.

pBigramParams: must set INKBIN_W_LEFT, INKBIN_W_GAP, INKBIN_W_RIGHT, INKBIN_H_LEFT, INKBIN_H_GAP, INKBIN_H_RIGHT,  on input.  
None changed on output

*/

/* We figure one chance in eight two characters weren't meant to be adjacent at all and one in four that they
were meant to be on the same line but not consecutive.  These numbers need tuning.  Also, they will change for the
vertical case. */

#define VERT_PRIOR		768	// 1/8
#define HORIZ_PRIOR		561	// 7/32
#define STANDARD_PRIOR	156	// 21/32

SCORE
ShapeBigramFreeCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch1,	// Left character
	wchar_t dch2,	// Right character
	int *pBigramParams
) {
	SCORE scoreTotal, scoreStandard, scoreHoriz, scoreVert;
	SCORE scoreVTail, scoreHTail;
	int iClass1, iClass2;
	int iDiffVert, iDiffHoriz;
	SCORE_GAUSSIAN *pScoreGaussianBigrams;
	int bigramStandard[INKBIN_ALL], bigramHoriz[INKBIN_ALL], bigramVert[INKBIN_ALL];
	int var, num, denom;

	iClass1 = pCentipedeInfo->pDch2CharClassMap[dch1];
	if (iClass1 == (BYTE)(-1)) {
		iClass1 = 0;
	}

	iClass2 = pCentipedeInfo->pDch2CharClassMap[dch2];
	if (iClass2 == (BYTE)(-1)) {
		iClass2 = 0;
	}

	pScoreGaussianBigrams = pCentipedeInfo->pScoreGaussianBigrams + (iClass1 * pCentipedeInfo->cCharClasses + iClass2)*INKBIN_ALL;


	/* Compute normalized parameters for all three scenarios */
	
	// First the standard one: chars follow each other left to right on the same line

	num = 2000;
	denom = pBigramParams[INKBIN_W_LEFT] + pBigramParams[INKBIN_W_GAP] + pBigramParams[INKBIN_W_RIGHT];
	memcpy(bigramStandard,pBigramParams,sizeof(bigramStandard));
	scoreStandard = ScaleBigramParams(num, denom, bigramStandard,pScoreGaussianBigrams);


	// Next the vertical one -- chars are in no obvious order

	var = pScoreGaussianBigrams[INKBIN_W_LEFT].sigma * pScoreGaussianBigrams[INKBIN_W_LEFT].sigma;
	num = 100*pBigramParams[INKBIN_W_LEFT]*pScoreGaussianBigrams[INKBIN_W_LEFT].mean/var;
	denom = 100*pBigramParams[INKBIN_W_LEFT]*pBigramParams[INKBIN_W_LEFT]/var;

	var = pScoreGaussianBigrams[INKBIN_W_GAP].sigma * pScoreGaussianBigrams[INKBIN_W_GAP].sigma;
	num += 100*(pBigramParams[INKBIN_W_LEFT] + pBigramParams[INKBIN_W_RIGHT])*(2000 - pScoreGaussianBigrams[INKBIN_W_GAP].mean)/var;
	denom += 100*(pBigramParams[INKBIN_W_LEFT] + pBigramParams[INKBIN_W_RIGHT])*(pBigramParams[INKBIN_W_LEFT] + pBigramParams[INKBIN_W_RIGHT])/var;

	var = pScoreGaussianBigrams[INKBIN_W_RIGHT].sigma * pScoreGaussianBigrams[INKBIN_W_RIGHT].sigma;
	num += 100*pBigramParams[INKBIN_W_RIGHT]*pScoreGaussianBigrams[INKBIN_W_RIGHT].mean/var;
	denom += 100*pBigramParams[INKBIN_W_RIGHT]*pBigramParams[INKBIN_W_RIGHT]/var;
	
	var = pScoreGaussianBigrams[INKBIN_H_LEFT].sigma * pScoreGaussianBigrams[INKBIN_H_LEFT].sigma;
	num += 100*pBigramParams[INKBIN_H_LEFT]*pScoreGaussianBigrams[INKBIN_H_LEFT].mean/var;
	denom += 100*pBigramParams[INKBIN_H_LEFT]*pBigramParams[INKBIN_H_LEFT]/var;

	var = pScoreGaussianBigrams[INKBIN_H_RIGHT].sigma * pScoreGaussianBigrams[INKBIN_H_RIGHT].sigma;
	num += 100*pBigramParams[INKBIN_H_RIGHT]*pScoreGaussianBigrams[INKBIN_H_RIGHT].mean/var;
	denom += 100*pBigramParams[INKBIN_H_RIGHT]*pBigramParams[INKBIN_H_RIGHT]/var;
	
	memcpy(bigramVert,pBigramParams,sizeof(bigramVert));
	scoreVert = ScaleBigramParams(num, denom, bigramVert,pScoreGaussianBigrams);

	// Finally the horizontal one -- chars don't follow but are on the same line

	var = pScoreGaussianBigrams[INKBIN_H_GAP].sigma * pScoreGaussianBigrams[INKBIN_H_GAP].sigma;
	num += 100*pBigramParams[INKBIN_H_GAP]*pScoreGaussianBigrams[INKBIN_H_GAP].mean/var;
	denom += 100*pBigramParams[INKBIN_H_GAP]*pBigramParams[INKBIN_H_GAP]/var;

	memcpy(bigramHoriz,pBigramParams,sizeof(bigramHoriz));
	scoreHoriz = ScaleBigramParams(num, denom, bigramHoriz,pScoreGaussianBigrams);

	/* Scale each by the prior probabilities (which add to one) */

	scoreStandard = ScoreMulProbs(STANDARD_PRIOR,scoreStandard);
	scoreHoriz = ScoreMulProbs(HORIZ_PRIOR,scoreHoriz);
	scoreVert = ScoreMulProbs(VERT_PRIOR,scoreVert);
	
	/* See how many sigmas we're off in vertical, using the scaled, input H-gap.  Essentially, we pay a penalty for
	moving it, and the less we moved it, the worse the penalty (on the theory that we didn't need to move it) */

	iDiffVert = pScoreGaussianBigrams[INKBIN_H_GAP].mean - bigramVert[INKBIN_H_GAP];
	scoreVTail = ScoreGaussianTail2(iDiffVert,&pScoreGaussianBigrams[INKBIN_H_GAP]);

	/* Synthesize both the gaps */

	bigramVert[INKBIN_H_GAP] = pScoreGaussianBigrams[INKBIN_H_GAP].mean;
	bigramVert[INKBIN_W_GAP] = 2000 - bigramVert[INKBIN_W_LEFT] - bigramVert[INKBIN_W_RIGHT];

	/* Simply scale the vertical score by the vertical tail */

	scoreVert = ScoreMulProbs(scoreVert,scoreVTail);

	/* Subtract the Vertical prob from one for the next two */

	scoreVTail = ScoreSubProbs(SCORE_ONE,scoreVTail);

	/* Now measure how far off the horizontal was and compute the cost, */

	iDiffHoriz = pScoreGaussianBigrams[INKBIN_W_GAP].mean - bigramHoriz[INKBIN_W_GAP];
	scoreHTail = ScoreGaussianTail2(iDiffHoriz,&pScoreGaussianBigrams[INKBIN_W_GAP]);

	/* Synthesize the missing gap */

	bigramHoriz[INKBIN_W_GAP] = 2000 - bigramHoriz[INKBIN_W_LEFT] - bigramHoriz[INKBIN_W_RIGHT];
	
	/* Scale the Horizontal score by one minus the vertical tail and by the horizontal tail */

	scoreHoriz = ScoreMulProbs(scoreHoriz,scoreVTail);
	scoreHoriz = ScoreMulProbs(scoreHoriz,scoreHTail);

	scoreHTail = ScoreSubProbs(SCORE_ONE,scoreHTail);
	
	/* And scale the standard one by one minus the vertical and one minus the horizontal tail */

	scoreStandard = ScoreMulProbs(scoreStandard,scoreVTail);
	scoreStandard = ScoreMulProbs(scoreStandard,scoreHTail);

	scoreTotal = ScoreAddProbs(scoreStandard,scoreHoriz);
	scoreTotal = ScoreAddProbs(scoreTotal,scoreVert);

	return (scoreTotal);	
}

/* Assuming two characters written on the screen with a guide (boxed input), this routine computes the probability of the 
particular combination given the characters.  This routine assumes horizontal writing.  Scaling requires width of drawn boxes be 1000.

pUnigramParams (left and right): must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H, INKSTAT_MARGIN_W on input.  
None changed on output.  

*/

SCORE
ShapeBigramBoxCost(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch1,	// Left character
	wchar_t dch2,	// Right character
	int *pLeftUnigramParams,
	int *pRightUnigramParams
) {	
	int bigramParams[INKBIN_ALL];
	int iClass1, iClass2, num, denom;
	SCORE score;
	SCORE_GAUSSIAN *pScoreGaussianBigrams;

	iClass1 = pCentipedeInfo->pDch2CharClassMap[dch1];
	if (iClass1 == (BYTE)(-1)) {
		iClass1 = 0;
	}

	iClass2 = pCentipedeInfo->pDch2CharClassMap[dch2];
	if (iClass2 == (BYTE)(-1)) {
		iClass2 = 0;
	}

	pScoreGaussianBigrams = pCentipedeInfo->pScoreGaussianBigrams + (iClass1 * pCentipedeInfo->cCharClasses + iClass2)*INKBIN_ALL;

	CentipedeUnigramToBigram(pLeftUnigramParams, pRightUnigramParams, bigramParams);

	num = 2000;
	denom = bigramParams[INKBIN_W_LEFT] + bigramParams[INKBIN_W_GAP] + bigramParams[INKBIN_W_RIGHT];
	score = ScaleBigramParams(num, denom, bigramParams, pScoreGaussianBigrams);

	return (score);

} // ShapeBigramBoxCost


/* Given a character and the width and height of its bounding box, return the width and height of the imaginary box
a user would probably have drawn around it, plus the x and y offset to place the character inside that box 

pUnigramParams: must set INKSTAT_W and INKSTAT_H on input.  On output, returns INKSTAT_BOX_W, INKSTAT_BOX_H, INKSTAT_X, and INKSTAT_Y
*/

void
ShapeUnigramBaseline(
	CENTIPEDE_INFO *pCentipedeInfo,
	wchar_t dch,
	int *pUnigramParams
) {
	int iClass, i, ix, var;
	double num, denom;
	SCORE_GAUSSIAN *pScoreGaussianUnigrams;
	int dmParams[4] = {INKSTAT_BOX_W, INKSTAT_BOX_H, INKSTAT_X, INKSTAT_Y,};

	iClass = pCentipedeInfo->pDch2CharClassMap[dch];
	if (iClass == (BYTE)(-1)) {
		iClass = 0;
	}

	pScoreGaussianUnigrams = pCentipedeInfo->pScoreGaussianUnigrams + iClass*INKSTAT_ALL;
	
	/* Note that num and denom are reversed here because we are scaling up from canonical to fit given
	width and height -- not the other way around */

	var = pScoreGaussianUnigrams[INKSTAT_W].sigma * pScoreGaussianUnigrams[INKSTAT_W].sigma;
	denom = 100.0 * (double)pUnigramParams[INKSTAT_W] * (double)pScoreGaussianUnigrams[INKSTAT_W].mean / (double)var;
	num = 100.0 * (double)pUnigramParams[INKSTAT_W] * (double)pUnigramParams[INKSTAT_W]/ (double)var;

	var = pScoreGaussianUnigrams[INKSTAT_H].sigma * pScoreGaussianUnigrams[INKSTAT_H].sigma;
	denom += 100.0 * (double)pUnigramParams[INKSTAT_H] * (double)pScoreGaussianUnigrams[INKSTAT_H].mean / (double)var;
	num += 100.0 * (double)pUnigramParams[INKSTAT_H] * (double)pUnigramParams[INKSTAT_H] / (double)var;

	/* Instead of divide by zero, treat as a delta function */

	if (denom == 0) {
		denom = 1;
	}

	/* Make sure we don't scale everything down to zero */

	if (num == 0) {
		num = 1;
	}

	/* Now scale everything */

	for (i = 0; i < 4; ++i) {
		ix = dmParams[i];
		pUnigramParams[ix] = (int)floor(0.5 + pScoreGaussianUnigrams[ix].mean * num / denom);
	}

} // ShapeUnigramBaseline


/* Given a set of Unigram parameters, rescale so INKSTAT_BOX_W == 1000

pUnigramParams: must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H, INKSTAT_BOX_W
On Output, INKSTAT_BOX_W == 1000 and the others are scaled proportionately
*/

void
CentipedeNormalizeUnigram(
	int *pUnigramParams
) {
	
	int base, base2, i;

	base = pUnigramParams[INKSTAT_BOX_W];
	if (base == 0) {
		return;
	}

	base2 = base/2;

	for (i = 0; i < INKSTAT_ALL; ++i) {
		if (i != INKSTAT_STROKES) {
			pUnigramParams[i] *= 1000;
			if (pUnigramParams[i] >= 0) {
				pUnigramParams[i] += base2; // round rather than truncate
			} else {
				pUnigramParams[i] -= base2; // round rather than truncate
			}
			pUnigramParams[i] /= base;	
		}
	}

} // CentipedeNormalizeUnigram

/* Given a set of Bigram parameters, rescale so INKBIN_W_LEFT+INKBIN_W_GAP+INKBIN_W_RIGHT == 2000 

pBigramParams: must set INKBIN_W_LEFT, INKBIN_W_GAP, INKBIN_W_RIGHT, INKBIN_H_LEFT, INKBIN_H_GAP, INKBIN_H_RIGHT  
On Output, INKBIN_W_LEFT+INKBIN_W_GAP+INKBIN_W_RIGHT == 2000 and the others are scaled proportionately
*/

void
CentipedeNormalizeBigram(
	int *pBigramParams
) {

	int base, base2, i;

	base = pBigramParams[INKBIN_W_LEFT] + pBigramParams[INKBIN_W_GAP] + pBigramParams[INKBIN_W_RIGHT];

	if (base == 0) {
		return;
	}

	base2 = base/2;

	for (i = 0; i < INKBIN_ALL; ++i) {
		pBigramParams[i] *= 2000;
		if (pBigramParams[i] >= 0) {
			pBigramParams[i] += base2; // round rather than truncate
		} else {
			pBigramParams[i] -= base2; // round rather than truncate
		}
		pBigramParams[i] /= base;
	}


} // CentipedeNormalizeBigram

/* Given two sets of Unigram Parameters, generate a set of Bigram Parameters.  Assumes inputs are aligned horizontally
and that INKSTAT_BOX_W == 1000
Input pUnigramParams (left and right): must set INKSTAT_X, INKSTAT_Y, INKSTAT_W, INKSTAT_H, INKSTAT_MARGIN_W.
Output pBigramParams: INKBIN_W_LEFT, INKBIN_W_GAP, INKBIN_W_RIGHT, INKBIN_H_LEFT, INKBIN_H_GAP, INKBIN_H_RIGHT
Output is NOT normalized.
*/

void
CentipedeUnigramToBigram(
	int *pLeftUnigramParams,
	int *pRightUnigramParams,
	int *pBigramParams
) {
	pBigramParams[INKBIN_W_LEFT] = pLeftUnigramParams[INKSTAT_W];
	pBigramParams[INKBIN_W_GAP] = 
		pLeftUnigramParams[INKSTAT_BOX_W] - pLeftUnigramParams[INKSTAT_W] - pLeftUnigramParams[INKSTAT_X] +
		pLeftUnigramParams[INKSTAT_MARGIN_W] +		
		pRightUnigramParams[INKSTAT_MARGIN_W] + 
		pRightUnigramParams[INKSTAT_X];
	pBigramParams[INKBIN_W_RIGHT] = pRightUnigramParams[INKSTAT_W];
	pBigramParams[INKBIN_H_LEFT] = pLeftUnigramParams[INKSTAT_H];
	pBigramParams[INKBIN_H_GAP] = pRightUnigramParams[INKSTAT_Y] - pLeftUnigramParams[INKSTAT_Y] - pLeftUnigramParams[INKSTAT_H];
	pBigramParams[INKBIN_H_RIGHT] = pRightUnigramParams[INKSTAT_H];

} // CentipedeUnigramToBigram
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\src\centipedefl.c ===
/***********************************************************************************************\
 * FILE: CentipedeFL.c
 *
 *	Code to load Shape Bigram tables from a file.
 *
\***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include <inkbox.h>
#include <centipede.h>

// Load runtime localization information from a file.
BOOL
CentipedeLoadFile(CENTIPEDE_INFO *pCentipedeInfo, wchar_t *pPath, LOCRUN_INFO *pLocRunInfo)
{
	wchar_t			aFullName[128];
	HANDLE			hFile, hMap;
	BYTE			*pByte;

	// Initialize
	pCentipedeInfo->hFile = INVALID_HANDLE_VALUE;
	pCentipedeInfo->hMap = INVALID_HANDLE_VALUE;
	pCentipedeInfo->pbMapping = INVALID_HANDLE_VALUE;

	// Generate path to file.
	FormatPath(aFullName, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"centipede.bin");

	// Try to open the file.
	hFile = CreateMappingCall(
		aFullName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		// DWORD		errCode;

		// errCode	= GetLastError();
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		goto error3;
	}

	// Extract info from mapped data.
	if (!CentipedeLoadPointer(pCentipedeInfo, pByte, pLocRunInfo)) {
		goto error3;
	}

	// ?? Should verify that we don't point past end of file ??

	// Record some pointers for unloading
	pCentipedeInfo->hFile = hFile;
	pCentipedeInfo->hMap = hMap;
	pCentipedeInfo->pbMapping = pByte;
	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	memset(pCentipedeInfo, 0, sizeof(*pCentipedeInfo));

	return FALSE;
}

BOOL
CentipedeUnloadFile(CENTIPEDE_INFO *pInfo)
{
	if (pInfo->hFile == INVALID_HANDLE_VALUE ||
		pInfo->hMap == INVALID_HANDLE_VALUE ||
		pInfo->pbMapping == INVALID_HANDLE_VALUE) {
		return FALSE;
	}

	UnmapViewOfFile(pInfo->pbMapping);
	CloseHandle(pInfo->hMap);
	CloseHandle(pInfo->hFile);

	pInfo->pbMapping = INVALID_HANDLE_VALUE;
	pInfo->hMap = INVALID_HANDLE_VALUE;
	pInfo->hFile = INVALID_HANDLE_VALUE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\src\sources.inc ===
TARGETNAME=centipede
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\centipede\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\centipede.c \
         ..\centipedefl.c \
         ..\centipeders.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\centipede\src\centipeders.c ===
/************************************************************************************************
 * FILE: CentipedeRS.c
 *
 *	Code to load Shape Bigram tables from resources.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include <centipede.h>

// Load runtime localization information from a resource.
BOOL
CentipedeLoadRes(CENTIPEDE_INFO *pCentipedeInfo, HINSTANCE hInst, int nResID, int nType, LOCRUN_INFO *pLocRunInfo)
{
	HRSRC			hres;
	HGLOBAL			hglb;
	void			*pRes;

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR)nResID, (LPCTSTR)nType);
	if (!hres) {
		goto error;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
		goto error;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (!pRes) {
		goto error;
	}

	pCentipedeInfo->hFile = INVALID_HANDLE_VALUE;
	pCentipedeInfo->hMap = INVALID_HANDLE_VALUE;
	pCentipedeInfo->pbMapping = INVALID_HANDLE_VALUE;

	return CentipedeLoadPointer(pCentipedeInfo, pRes, pLocRunInfo);

error:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\ceassert.h ===
// ASSERT.h - this is a wrapper so that the assert functions can be
//  safely ignored on WinCE (which does not support the normal ASSERT.h

#ifndef UNDER_CE
#include <ASSERT.h>
#else
#define ASSERT(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\apinames.h ===
// APINAMEs.h
// Angshuman Guha, aguha
// April 12, 2000
//
// This file is intended to be used by apps which dyna-link to the 
// recognizer DLL.  Of the private API, any or all may be absent in
// the DLL.

// public (published) API
#define APINAME_AddPenInputHRC             "AddPenInputHRC"
#define APINAME_CreateCompatibleHRC        "CreateCompatibleHRC"
#define APINAME_CreateHWL                  "CreateHWL"
#define APINAME_CreateInksetHRCRESULT      "CreateInksetHRCRESULT"
#define APINAME_DestroyHRC                 "DestroyHRC"
#define APINAME_DestroyHRCRESULT           "DestroyHRCRESULT"
#define APINAME_DestroyHWL                 "DestroyHWL"
#define APINAME_DestroyInkset              "DestroyInkset"
#define APINAME_EnableLangModelHRC         "EnableLangModelHRC"
#define APINAME_EnableSystemDictionaryHRC  "EnableSystemDictionaryHRC"
#define APINAME_EndPenInputHRC             "EndPenInputHRC"
#define APINAME_GetAlternateWordsHRCRESULT "GetAlternateWordsHRCRESULT"
#define APINAME_GetCostHRCRESULT           "GetCostHRCRESULT"
#define APINAME_GetInksetInterval          "GetInksetInterval"
#define APINAME_GetInksetIntervalCount     "GetInksetIntervalCount"
#define APINAME_GetMaxResultsHRC           "GetMaxResultsHRC"
#define APINAME_GetResultsHRC              "GetResultsHRC"
#define APINAME_GetSymbolCountHRCRESULT    "GetSymbolCountHRCRESULT"
#define APINAME_GetSymbolsHRCRESULT        "GetSymbolsHRCRESULT"
#define APINAME_IsStringSupportedHRC       "IsStringSupportedHRC"
#define APINAME_ProcessHRC                 "ProcessHRC"
#define APINAME_SetAlphabetHRC             "SetAlphabetHRC"
#define APINAME_SetGuideHRC                "SetGuideHRC"
#define APINAME_SetMaxResultsHRC           "SetMaxResultsHRC"
#define APINAME_SetRecogSpeedHRC           "SetRecogSpeedHRC"
#define APINAME_SetWordlistCoercionHRC     "SetWordlistCoercionHRC"
#define APINAME_SetWordlistHRC             "SetWordlistHRC"
#define APINAME_SymbolToCharacter          "SymbolToCharacter"
#define APINAME_SymbolToCharacterW         "SymbolToCharacterW"
#define APINAME_GetBaselineHRCRESULT       "GetBaselineHRCRESULT"

#define APINAME_SetHwxFactoid              "SetHwxFactoid"
#define APINAME_SetHwxFlags                "SetHwxFlags"
#define APINAME_SetHwxCorrectionContext    "SetHwxCorrectionContext"
#define APINAME_GetWordConfLevel           "GetWordConfLevel"

// private API
#define APINAME_HwxGetCosts                "_HwxGetCosts@12"
#define APINAME_HwxGetInputFeatures        "_HwxGetInputFeatures@12"
#define APINAME_HwxGetNeuralOutput         "_HwxGetNeuralOutput@12"
#define APINAME_HwxGetTiming               "_HwxGetTiming@8"
#define APINAME_HwxGetWordResults          "_HwxGetWordResults@16"
#define APINAME_HwxSetAnswer               "_HwxSetAnswer@4"
#define APINAME_GetMsgTiming               "_GetMsgTiming@4"
#define APINAME_GetLatinLayoutHRCRESULT	   "_GetLatinLayoutHRCRESULT@28"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\frame.h ===
// frame.h

#ifndef __INCLUDE_FRAME
#define __INCLUDE_FRAME

#ifdef __cplusplus
extern "C" 
{
#endif

typedef	POINT	XY;

typedef struct tagFRAME
{
	void	   *pvData;		// Recognizer specific private data
	STROKEINFO	info;		// Physical info about ink (Penwin.h)
	UINT        csmoothxy;	// points in smoothed strokes
	XY		   *rgrawxy;	// tablet coords of all the points in the stroke
	XY		   *rgsmoothxy;	// array of points after smoothing
	RECT        rect;		// bounding box of this stroke
	int         iframe;		// pos of this frame in linked list of glyphs
} FRAME;

FRAME	   *NewFRAME(void);
void		DestroyFRAME(FRAME *self);
RECT	   *RectFRAME(FRAME *self);

BOOL IsSafeForAdd(int a, int b);
BOOL IsSafeForMult(int a, int b);

BOOL TranslateFrame (FRAME *pFrame, int dx, int dy);
FRAME	*copyFRAME(FRAME *pFrame);

#define SetIFrameFRAME(frame,i)		((frame)->iframe = (i))
#define IFrameFRAME(frame)			((frame)->iframe)
#define DeInitRectFRAME(frame)		((frame)->rect.left = -1)
#define IsVisibleSTROKE(info)		(((info)->wPdk) & PDK_TIPMASK)
#define IsVisibleFRAME(frame)		(IsVisibleSTROKE(&(frame)->info))
#define RgrawxyFRAME(frame)			((frame)->rgrawxy)
#define CrawxyFRAME(frame)			((frame)->info.cPnt)
#define RawxyAtFRAME(frame,i)		((frame)->rgrawxy[i])
#define LppointFRAME(frame)			((LPPOINT)(frame)->rgrawxy)
#define CpointFRAME(frame)			((frame)->info.cPnt)
#define CpointSmoothFRAME(frame)	((frame)->csmoothxy)
#define LpframeinfoFRAME(frame)		(&(frame)->info)


#ifdef __cplusplus
};
#endif

#endif	//__INCLUDE_FRAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\errsys.h ===
/******************************Module*Header*******************************\
* Module Name: errsys.h
*
* This provides the ASSERT and VERIFY macros for all apps in all the
* recognition apps.
*
* Created: 04-Oct-1995 16:17:00
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#ifndef _INC_ERRSYS_H
#define _INC_ERRSYS_H

#include <TabInc.h>

#if (defined(DBG) || defined(DBG) || defined(DEBUGINTERNAL))

extern int giDebugLevel;
#define JUST_DEBUG_MSG (giDebugLevel = 1)  // Add to program init if desired.

#ifdef __cplusplus
extern "C" {
#endif

int HwxAssertFn(int, char *, char *);
int HwxWarning(int, char *, char *);

#ifdef __cplusplus
}
#endif

#ifndef VERIFY
#define VERIFY(cond) ((cond) || HwxAssertFn(__LINE__,__FILE__,#cond))
#endif
#ifndef PANIC
#define PANIC        ASSERT(0)
#endif
#ifndef WARNING
#define WARNING(cond) ((cond) || HwxWarning(__LINE__,__FILE__,#cond))
#endif


#else

#ifndef VERIFY
#define	VERIFY(x)	(x)
#endif
#ifndef PANIC
#define PANIC
#endif
#ifndef WARNING
#define WARNING(x)
#endif

#endif // DBG

#endif // _INC_ERRSYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\cestubs.h ===
// cestubs.h - This is stuff that we need from elsewhere to compile (even if we don't
//              use the OS functions that these data structures imply

// c runtime functions that we have to simulate or replace

#ifndef _CESTUBS_H_
#define _CESTUBS_H_


#ifdef UNDER_CE

#define CETEXT(x)	L##x

// Can't use ASSERT or putc from inside CE (porky uses them for debugging only
#undef  ASSERT
#define ASSERT(x)
//#define putc(x, y)


#define OFS_MAXPATHNAME 128
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[OFS_MAXPATHNAME];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

#define NOPENAPPS
#define NOPENDICT
#define NOPENRC1
#define NOPENVIRTEVENT
#define NOPENAPIFUN

//int islower( int c );
//int toupper( int c );
#define toupper towupper
//#define islower iswlower

// HACK ALERT! HACK ALERT! 
//  Problem - the WinCE compiler can't find these three symbols which are related
//  to floating point.  We did the long term fix by changing the code to use
//  fixed point instead on WinCE, but if we go back to floating, we will have
//  to solve this problem (perhaps a later version of the WinCE Extensions for VC
//  will fix the problem, I saw it while using a beta.  If you uncomment, add the 
//  actual vars back in to cestubs.c
//extern int __gts;
//extern int __gtd;
//extern int __ltd;


#else	// UNDER_CE not defined

#ifdef UNICODE
#define CETEXT(x)	L##x
#else
#define CETEXT(x)	x
#endif

#endif


#endif	_CESTUBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\foldchar.h ===
// foldchar.h
// Angshuman Guha
// aguha
// July 24, 2000

#ifndef _INC_FOLDCHAR_H
#define _INC_FOLDCHAR_H

#ifdef __cplusplus
extern "C" {
#endif

BOOL IsValidStringLatin(wchar_t *wsz, char **pszErrorMsg);
int FoldStringLatin(wchar_t *wszSrc, wchar_t *wszDst);

BOOL IsValidStringEastAsian(wchar_t *wsz, char **pszErrorMsg);
int FoldStringEastAsian(wchar_t *wszSrc, wchar_t *wszDst);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\cp1252.h ===
// cp1252.h
// James A. Pittman
// Mar 11, 1999

// Functions to support CodePage 1252.  Versions of isalpha, isdigit, etc.
// plus tolower(), toupper(), strlower(), and strupper().

// Also translation functions, for translation between codepage 1252 and Unicode.

#ifndef _CP1252_
#define _CP1252_

#include <windows.h>

// Should non-breaking space be an alpha?

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* space, tab, carriage return, newline, */
                                /* vertical tab, form feed, or non-breaking space */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space and non-breaking space chars only */
#define _HEX            0x80    /* hexadecimal digit */

#ifdef __cplusplus
extern "C" 
{
#endif

extern unsigned char _ctype1252[256];

#define isalpha1252(_c)     (_ctype1252[(unsigned char)_c] & (_UPPER | _LOWER))
#define isupper1252(_c)     (_ctype1252[(unsigned char)_c] & _UPPER)
#define islower1252(_c)     (_ctype1252[(unsigned char)_c] & _LOWER)
#define isdigit1252(_c)     (_ctype1252[(unsigned char)_c] & _DIGIT)
#define isxdigit1252(_c)    (_ctype1252[(unsigned char)_c] & _HEX)
#define isspace1252(_c)     (_ctype1252[(unsigned char)_c] & _SPACE)
#define ispunct1252(_c)     (_ctype1252[(unsigned char)_c] & _PUNCT)
#define isalnum1252(_c)     (_ctype1252[(unsigned char)_c] & (_UPPER | _LOWER | _DIGIT))
#define isprint1252(_c)     (_ctype1252[(unsigned char)_c] & (_BLANK | _PUNCT | _UPPER | _LOWER | _DIGIT))
#define isgraph1252(_c)     (_ctype1252[(unsigned char)_c] & (_PUNCT | _UPPER | _LOWER | _DIGIT))
#define iscntrl1252(_c)     (_ctype1252[(unsigned char)_c] & _CONTROL)
#define isundef1252(_c)		(!_ctype1252[(unsigned char)_c])

// These 2 macros will return the arg letter if there is no lowercase (or uppercase)
// equivalent (as far as I can tell this is not true of the ANSI c toupper() and tolower()).

// Note that the German esset is a lowercase letter, but there is no uppercase equivalent.

//                                               caron S and OE                       diaeresis Y           most letters
#define tolower1252(_c)		(isupper1252(_c) ? (((_c & 0xF0) == 0x80) ? (_c + 16) : ((_c == 0x9F) ? 0xFF : (_c + 32))) : _c)
//                                               caron s and oe                       diaeresis y           esset                most letters
#define toupper1252(_c)		(islower1252(_c) ? (((_c & 0xF0) == 0x90) ? (_c - 16) : ((_c == 0xFF) ? 0x9F : ((_c == 0xDF) ? _c : (_c - 32)))) : _c)

// Two functions to translate case in strings.  Any characters which do
// not have case translations are preserved.
extern void strlower1252(unsigned char *s);
extern void strupper1252(unsigned char *s);

// If successful, 1 is returned.
// If an undefined code is passed in, 0 is returned and *pwch is unchanged.
extern int CP1252ToUnicode(unsigned char ch, WCHAR *pwch);

// If successful, 1 is returned.
// If a unicode codepoint is passed in which is not supported in 1252,
// 0 is returned and *pch is unchanged.
extern int UnicodeToCP1252(WCHAR u, unsigned char *pch);
extern unsigned char *UnicodeToCP1252String(WCHAR *wsz);
WCHAR *CP1252StringToUnicode(unsigned char *psz, WCHAR *wsz, int *piLen);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\gesturep.h ===
#ifndef __INC_GESTURE_P_H__
#define __INC_GESTURE_P_H__

#define GESTURE_UNDEFINED                   0xf0ff

#ifdef __cplusplus
extern "C" {
#endif

int GestureNameToID(char *szName);
char *GestureIDToName(int iID);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\common.h ===
// This file is for things that are common across projects

#ifndef __INCLUDE_COMMON
#define __INCLUDE_COMMON

// And of course, DBG

#ifdef DBG
#ifndef DBG
#define DBG 1
#endif //!DBG
#endif //!DBG

#ifdef DBG
#ifndef DBG
#define DBG 1
#endif //!DBG
#endif //!DBG

// Include WINDOWS headers

#include <windows.h>
#include <windowsx.h>

// Include 'pen' stuff

#include "penwin32.h"

// We really don't want these defines to mean anything

#define INLINE
#define EXPORT
#define _loadds
#define _far
#define _pascal
#define PUBLIC 
#define PRIVATE 
#define BLOCK

// Use const only when ROM_IT is set.  Most tables need to be modifiable
// at train/tune time, but should be ROM in the final release.

#ifdef ROM_IT
#define ROMMABLE   const
#else
#define ROMMABLE
#endif

// Include the memory management functions

#include "memmgr.h"

// Include the system dependent file management layer

#include "cestubs.h"

#ifndef UNDER_CE
#include <stdio.h>
#include "util.h"
#endif

// Include the common error handling stuff

#include "errsys.h"

#define ALC_NUMERIC_PUNC    0x00001000L // Non digit characters in numbers
#define ALC_BEGINPUNC		0x20000000L // English: [ { ( " etc.
#define ALC_ENDPUNC         0x40000000L // English: ] } ) " etc.
#define ALC_JIS2            0x00040000L // kanji JPN, ShiftJIS 2+3

LPPENDATA WINAPI BeginEnumStrokes(HPENDATA);
LPPENDATA WINAPI EndEnumStrokes(HPENDATA);
BOOL      WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR*,
                                  LPVOID FAR*, LPSTROKEINFO);

// include the unicode checking string functions
#include <tchar.h>

// Include the math code

#include "math.h"
#include "mathx.h"

#ifndef abs
#define abs(x)  ((x) < 0 ? -(x) : (x))
#endif

// Include the 'Mars' stuff

#include "frame.h"
#include "glyph.h"

// For now, include the XJIS layer.  When we switch to UNICODE
// this will be replaced

#include "xjis.h"
#include "unicode.h"

// Fundemental types and structures everybody needs to know about

typedef struct tagCHARSET
{
	ALC		recmask;			// Specifies which character types are to be returned
	ALC		recmaskPriority;	// What types should be at the top of the list.
	UINT	uDir;				// direction of writing.
} CHARSET;

#define	MAX_ALT_LIST	20

typedef struct tagALT_LIST
{
	UINT	cAlt;						// Count of valid alternatives
	FLOAT	aeScore[MAX_ALT_LIST];		// Scores for each alternatives
	wchar_t	awchList[MAX_ALT_LIST];		// List of alternatives
} ALT_LIST;

extern void SortAltList(ALT_LIST *pAltList);

#define	HWX_SUCCESS		0
#define	HWX_FAILURE		1
#define	HWX_ERROR		2

// Partial recognition modes
#define RECO_MODE_REMAINING		0
#define	RECO_MODE_INCREMENTAL	1

// Include support for translations between codepage 1252 and unicode.

#include "cp1252.h"

// Include the XRCRESULT support.

#include "xrcreslt.h"
#include "langtax.h"
#include "foldchar.h"

#endif // !__INCLUDE_COMMON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\madtime.h ===
#ifndef H_MAD_TIMING_H
#define H_MAD_TIMING_H

#define	MM_FEAT				0
#define MM_NET				1
#define	MM_BEAM				2
#define	MM_HMM				3
#define	MM_PP				4
#define	MM_TOT				5
#define	MM_BEAM_LM_WALK		6
#define	MM_BEAM_HARVEST		7
#define	MM_OUTDICT			8
#define MM_RESWRDBRK		9
#define MM_RECOG_WHOLE_WORD	10
#define MM_CMPWRDBRK		11
#define MM_RUN_AVAL			12
#define	MM_CALLIG			13
#define MM_CALLIG_PHRASE	14
#define MM_CALLIG_WORD		15
#define MM_INF				16
#define MM_INF_PHRASE		17
#define MM_INF_WORD			18
#define MM_GEO_ALT			19
#define MM_GEO_PLAIN		20
#define MM_XR_NET			21
#define MM_MULT_SEG_FEAT	22

#define MM_CNT				23

typedef struct tagMAD_TIMING
{
	DWORD		dTime[MM_CNT];		// Times
	DWORD		dCnt[MM_CNT];
} MAD_TIMING;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\langtax.h ===
// langtax.h
// rsarac & aguha
// July 10, 2000

#ifndef _LANGTAX
#define _LANGTAX

#ifdef __cplusplus
extern "C" {
#endif

extern int GetIndexFromLANG(WORD wIDLanguage);
extern int GetIndexFromLocale(wchar_t *wszLang);
extern int GetClassCountLANG(int iLangIndex);
extern wchar_t *GetClassNameLANG(int iLangIndex, int iClassIndex);
extern int GetClassFromLANG(int iLangIndex, wchar_t wChar);
extern BOOL IsLatinLANG(int iLangIndex);
extern wchar_t *GetNameLANG(int iLangIndex);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\glyph.h ===
// glyph.h

#ifndef __INCLUDE_GLYPH
#define __INCLUDE_GLYPH

#ifdef __cplusplus
extern "C" 
{
#endif

#include "frame.h"

typedef struct tagGLYPH GLYPH;

typedef struct tagGLYPH
{
	FRAME  *frame;
	GLYPH  *next;
} GLYPH;

GLYPH  *NewGLYPH(void);
void	DestroyGLYPH(GLYPH *self);
void	DestroyFramesGLYPH(GLYPH *self);
int		CframeGLYPH(GLYPH * self);
FRAME  *FrameAtGLYPH(GLYPH * self, int iframe);
void	GetRectGLYPH(GLYPH * self, LPRECT rect);
BOOL	AddFrameGLYPH(GLYPH * self, FRAME * frame);
GLYPH  *MergeGlyphGLYPH(GLYPH * self, GLYPH * merge);
GLYPH  *GlyphFromHpendata(HPENDATA hpendata);
XY     *SaveRawxyGLYPH(GLYPH *self);
void    RestoreRawxyGLYPH(GLYPH *self, XY *xy);
BOOL TranslateGlyph (GLYPH *pGlyph, int dx, int dy);
BOOL TranslateGuide (GUIDE *pGuide, int dx, int dy);
GLYPH *CopyGlyph (GLYPH *pGlyph);
BOOL GuideNormalizeInk (GUIDE *pGuide, GLYPH *pGlyph);
BOOL NormalizeInk(GLYPH *pGlyph, int yDev);
BOOL CheckInkBounds (GLYPH *pGlyph, GUIDE *pGuide);


#define  GlyphCopyGLYPH(self) MergeGlyphGLYPH(self, 0)

#ifdef __cplusplus
};
#endif

#endif	//__INCLUDE_GLYPH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\memmgr.h ===
// memmgr.h
//
// This file contains declarations and macros for memory management.  
// Implementation details may change so beware of relying on internal details.


#ifndef __INCLUDE_MEMMGR
#define __INCLUDE_MEMMGR

#ifdef __cplusplus
extern "C" 
{
#endif

void *ExternAlloc(DWORD cb);
void *ExternRealloc(void *pv, DWORD cb);
void  ExternFree(void *pv);

char *Externstrdup( const char *strSource );

#ifdef DBG
extern int cAllocMem;     // Amount of memory alloced
extern int cAlloc;        // Count of allocs outstanding
extern int cAllocMaxMem;  // Max amount of memory ever alloced.
#endif

#ifdef __cplusplus
};
#endif

#endif //__INCLUDE_MEMMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\inkio.h ===
#ifndef __INC_INKIO_H_
#define __INC_INKIO_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef struct WritingArea_tag
{
	RECT rect;
	GUIDE guide;
	// warning: both of the following cannot be nonzero
	unsigned int iMultInk; // ink scaling (0 means no scaling)
	unsigned int iDivInk;  // ink scaling (0 means no scaling) 
} WritingArea;

typedef struct {
	char *szOS;
	char *szSystemRoot;
	char *szUSERNAME;
	POINT SCREEN;
	BOOL bWordmode;
	BOOL bUseGuide;
	BOOL bCoerce;
	BOOL bNNonly;
	unsigned char *szWordlist; // NULL means not used
	char *szRecogDLLName;
	int  cDLLSize;
	char *szDLLTime;
	WritingArea WA;
	WritingArea WAGMM;
	char *szLabel;
	char *szComment;
	GLYPH *glyph;
	GLYPH *glyphGMM;
	BOOL bUseFactoid;
	DWORD factoid;
	unsigned char *szPrefix;
	unsigned char *szSuffix;
} InkData;

extern const char *szWordmode;
extern const char *szUseGuide;
extern const char *szCoerce;
extern const char *szNNonly;
extern const char *szUseFactoid;
extern const char *szFactoid;
extern const char *szUseHWL;
extern const char *szHWL;
extern const char *szDll;

extern char gszInkIoError[];
int WriteInkFile(char *szFile, InkData *pInkData);
int ReadInkFile(char *szFile, InkData *pInkData);
void CleanupInkData(InkData *pInkData); // should only be called after a read

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\math16.h ===
#ifndef __MATH16_H__
#define __MATH16_H__

#ifdef __cplusplus
extern "C" {
#endif 

#define	SHFTBITS    16

#define LOWMASK	    ((1 << SHFTBITS)-1)
#define HGHMASK	    (~LOWMASK)
#define LOWBITS(x)  ((x) & LOWMASK)
#define HGHBITS(x)  ((x) & HGHMASK)
#define	LSHFT(x)    ((x) << SHFTBITS)
#define RSHFT(x)    ((x) >> SHFTBITS)

#define	PI	    (3373259427 >> (30-SHFTBITS))
#define TWOPI	    (PI << 1)
#define PIOVER2	    (PI >> 1)

#define Need(dw) (dw & 0xFF000000 ? 32 : (dw & 0x00FF0000 ? 24 : (dw & 0x0000FF00 ? 16 : 8)))

int	Div16(int iX,int iY);
int	Sigmoid16(int iX);

// Greg's multiplication algorithm:
typedef struct {
	unsigned short frac;
	short whole;
} FIX1616, *PFIX1616;

#define Mul16(a,b,c) {	\
	int i1, i2;											\
	FIX1616 fix1, fix2;									\
	i1=(a);												\
	i2=(b);												\
	fix1 = *(PFIX1616)&i1;								\
	fix2 = *(PFIX1616)&i2;								\
	c = (unsigned int)(fix1.frac*fix2.frac) >> 16;		\
	c += fix1.frac*fix2.whole + fix1.whole*fix2.frac;	\
	c += (fix1.whole*fix2.whole) << 16;					\
}

#ifdef __cplusplus
}
#endif

#endif // __MATH16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\mathx.h ===
// mathx.h

#ifndef __INCLUDE_MATHX
#define __INCLUDE_MATHX

#ifdef __cplusplus
extern "C" 
{
#endif

int Arctan2(int y, int x);
int Distance(int a, int b);
int	AddLogProb(int a, int b);

#define	DISTANCE_POINT(a,b)	Distance((a).x - (b).x, (a).y - (b).y)
#define	CROSS_PRODUCT(a,b) (((long) (a).x) * ((long) (b).y) - ((long) (a).y) * ((long) (b).x))

// Calculate difference between two angles and bring into range -180 < angle <= 180.

#define ANGLEDIFF(a,b,c)  {	\
	c	= b - a;			\
	if (c > 180) {			\
		c	-= 360;			\
	} else if (c <= -180) {	\
		c	+= 360;			\
	}						\
}

// Calc d = the angle betw (the extension of rgxy[a]:rgxy[b]) and
//          (rgxy[b]:rgxy[c]).  The sign of d reflects clockwise vs
//          counterclockwise turns.
// LEFT FOR A RAINY DAY: make this more efficient

#define CALCANGLE(a,b,c,d)  \
    ANGLEDIFF(Arctan2(rgxy[b].y - rgxy[a].y, rgxy[b].x - rgxy[a].x),    \
              Arctan2(rgxy[c].y - rgxy[b].y, rgxy[c].x - rgxy[b].x),    \
              d);

#define CALCANGLEPT(a,b,c,d)  \
    ANGLEDIFF(Arctan2(b.y - a.y, b.x - a.x),    \
              Arctan2(c.y - b.y, c.x - b.x),    \
              d);

#define	INTEGER_LOG_SCALE	256
#define INTEGER_ARCTAN		100

#ifdef __cplusplus
};
#endif

#endif	//__INCLUDE_MATHX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\penwin32.h ===
/****************************************************************************\
*                                                                            *
* PENWIN32.H -  Pen Windows functions, types, and definitions                *
*                                                                            *
*             Version 3.2                                                    *
*                                                                            *
*             Copyright (c) 1992-1999 Microsoft Corp. All rights reserved.   *
*                                                                            *
*****************************************************************************/

#ifndef _INC_PENWIN32
#define _INC_PENWIN32

#include <penwin.h>

#ifdef __cplusplus
extern "C" 
{
#endif

//
// New API's supported for NT5.0
//

int WINAPI EnableLangModelHRC(HRC, BOOL);
int WINAPI GetCostHRCRESULT(HRCRESULT);
BOOL WINAPI IsStringSupportedHRC(HRC hrc, unsigned char *sz);
int WINAPI SetRecogSpeedHRC(HRC hrc, int iSpeed);
BOOL WINAPI SymbolToCharacterW(SYV *pSyv, int cSyv, WCHAR *wsz, int *pConv);
int WINAPI GetBaselineHRCRESULT(HRCRESULT hrcresult, RECT *pRect, BOOL *pbBaselineValid, BOOL *pbMidlineValid);
int WINAPI SetHwxFactoid(HRC hrc, WCHAR* pwcFactoid);
BOOL WINAPI SetHwxFlags(HRC hrc, DWORD flags);

// Extra user Dictionary API's
int WINAPI AddWordsHWLW(HWL hwl, wchar_t *pwsz, UINT uType);
HWL WINAPI CreateHWLW(HREC hrec, wchar_t * pwsz, UINT uType, DWORD dwReserved);

// If the following API is called, the recognizer expects the RECOFLAG_WORDMODE
// and the RECOFLAG_COERCE flags to be ON.  Otherwise, ProcessHRC fails.
BOOL WINAPI SetHwxCorrectionContext(HRC hrc, WCHAR *wszPrefix, WCHAR *wszSuffix);

#ifdef __cplusplus
};
#endif

#endif /* #ifndef _INC_PENWIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\runnet.h ===
/************************************************************
 *
 * runNet.h
 *
 * Bare bones net. 
 * Use this implementation to build and run a net
 * (Not for training)
 *
 * mrevow
 *
 ***********************************************************/
#ifndef H_RUN_NET_H
#define H_RUN_NET_H

// Versioning infrmation
//   December 2001 Introduced versioning information. Prior to this the version
//					number did not exist. The first element was eNetType which had value < 10
//
//		Changes introduce lossType, txfer and unitType into runNet description
//
// March 2002
//		Incompatible changes:
//		Add upfront scaling of features (Added the range vector for input vars)
//		Also add data-type sizes for all weight, bias and range vectors
//
#define RUN_NET_VER_START	(10)	// First version number introduced December 2001
#define RUN_NET_VER_10		(10)	// December 2001 - March 2002
#define RUN_NET_VER_11		(11)	// March 2002 Current Version Number

//#define NET_FLOAT
typedef int				RREAL;					// Used for intermediate calculation and unit activations
typedef short			RREAL_WEIGHT;			// Used for Net weights (excluding bias)
typedef int				RREAL_BIAS;				// Used for bias weights
typedef __int64			RREAL_INPUT;			// Used for scaling inputs which are of type RREAL

// This types is shared between the train and run time nets
// It is defined here and in netTypes.h - kkep them in sync
#ifndef CAMEL_NET_TYPE_DEFINED
typedef enum tagNET_TYPE		{NO_NET_TYPE, FULLY_CONNECTED, LOCALLY_CONNECTED} NET_TYPE;
typedef enum tagLOSS_TYPE		{SUMSQUARE, SUMSQUARE_CLASS, CROSSENTROPY, CROSSENTROPY_FULL, C_LOSS_TYPE} LOSS_TYPE;
typedef enum tagTXF_TYPE		{TXF_LINEAR, TXF_INT_SIGMOID, TXF_SIGMOID, TXF_TANH, TXF_SOFTMAX, CTXF_TYPE} TXF_TYPE;
typedef enum tagLAYER_TYPE		{INPUT_LAYER, HIDDEN_LAYER, OUTPUT_LAYER, BIAS_LAYER, CLAYER_TYPE} LAYER_TYPE;
#define CAMEL_NET_TYPE_DEFINED
#endif

#define		MIN_PREC_VAL		0
#define		SOFT_MAX_UNITY		10000			// Value of 1.0 in the softMax

// Describes a net. In a running net the description
// up to and including the weight vector will be loaded
// from a resource
typedef struct tagRUN_NET
{
	WORD			iVer;			    // Added December 2001 - Versioning information -> 0 implies none present
	WORD			cLayer;				// Number of layers in net
	LOSS_TYPE		lossType;			// Added December 2001 - Type of output loss - only present for net versions > 10
	TXF_TYPE		*txfType;			// Added December 2001 - Txfer type for each layer - only present for net versions > 10
	LAYER_TYPE		*layerType;			// Added December 2001 - Unit type of eachlayer - only present for net versions > 10
	WORD			cWeight;			// Total # of weights in network
	WORD			cTotUnit;			// Total number of units in network
	WORD			*cUnitsPerLayer;	// # of units per layer
	WORD			*bUseBias;			// Use bias units? per layer
	WORD			*pWeightScale;		// Amount by which each layers incoming weights are scaled
	WORD			iInputScaledMeanDataSize;	// Data type size for pInputMean (Introduced March 2002)
	WORD			iInputRangeDataSize;// Data type size for Input Range Vector (Introduced March 2002)
	WORD			iWeightDataSize;		// Data Type size for weight vector (Introduced March 2002)
	RREAL			*pInputRange;		// Ranges for each input variable > 0 (Introduced March 2002)
	RREAL_INPUT		*pInputScaledMean;	// Scaled Means for input data (Introduced March 2002 to replace pInputMean)
	RREAL			*pInputMean;		// Means for input data 
	UINT			cWeightByte;		// Count of bytes used for weights
	RREAL_WEIGHT	*pWeight;			// All network weights.
} RUN_NET;


// describes the outgoing connections of a unit
// as the start and end unit offsets to which it connects
typedef struct tagOUT_CONNECTIONS
{
	WORD		iUnit;					// The unit in question
	WORD		iStartUnitOffset;
	WORD		iEndUnitOffset;
} OUT_CONNECTIONS;

// Describes a locally connected network
typedef struct tagLOCAL_NET
{
	WORD			iVer;					// Version Number (Started December 2001, Before all nets had eNetType as the first element set to LOCALLY_CONNECT (
	WORD			eNetType;				// Must be of type LOCALLY_CONNECTED
	RUN_NET			runNet;					// How to run the Net
	int				cConnect;				// Number of connections
	OUT_CONNECTIONS	*pOutConnect;
} LOCAL_NET;


#ifdef __cplusplus
extern "C"
{
#endif


// API functions

extern BYTE			*restoreRunNet( BYTE *pBuf, BYTE *pBCurr, RUN_NET *pNet, WORD iVer) ;
extern LOCAL_NET *	restoreLocalConnectNet( void *pBuf, wchar_t wNetId,  LOCAL_NET *pNet  ) ;
extern RREAL		*runFullConnectNet( RUN_NET *pNet,  RREAL *pfUnits,  UINT *piWinner  ) ;
extern RREAL		*runLocalConnectNet( LOCAL_NET *pNet,  RREAL *pfUnits,  UINT *piWinner, UINT *pcOut  ) ;
extern int			getRunTimeNetMemoryRequirements(void *pBuf);

extern LOCAL_NET	*loadNet(HINSTANCE hInst, int iKey, int *iNetSize, LOCAL_NET *pNet);
extern void			*loadNetFromResource(HINSTANCE hInst, int iKey, int *iSize);

#ifdef NET_FLOAT
	#define SIGMOID fsigmoid
	#define EXP(x) exp((x)/65536.0F) * 65536.0F
	RREAL * fsigmoid(RREAL *pVec, int cVec, WORD	scale);
#else
	#define SIGMOID isigmoid
	#define EXP(x)      iexp(x)
	RREAL * isigmoid(RREAL *pVec, int cVec, WORD	scale);
	RREAL iexp(RREAL val);
#endif

#ifdef HWX_INTERNAL
	LOCAL_NET * LoadRunNetFromFp(LOCAL_NET *pNet, int *iNetSize, char * fname);
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\quicktrie.h ===
// FILE: QuickTrie.h
//
// Definitions for QuickTrie program and access code.

// Flag values.
#define	QT_FLAG_VALID	0x01
#define	QT_FLAG_END		0x02

// Basic node in trie.
typedef struct tagQT_NODE {
	BYTE	label;
	BYTE	flags;
	WORD	oDown;
} QT_NODE;

// Table name generated by QuickTrie.
extern const QT_NODE	g_aQuickTrie[];

// Functions to access the QuickTrie.
extern WCHAR	FirstChildQuickTrie(DWORD *hState);
extern WCHAR	NextSiblingQuickTrie(DWORD *hState);
extern BOOL		IsValidQuickTrie(DWORD state);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\toolmain.h ===
/******************************************************************************
 *	FILE:	toolmain.h
 *
 *	This is a header for the code that provides a standard main and argument
 *	parsing for command line tools.  To use this, you need to copy toolmain.c
 *	from \hwx\common\template and edit it to specify the parameters needed by
 *	your application.  You will also need to call your main function ToolMain
 *	(as declared below) so that the standard code can call it.
 *
 *	NOTE: It may be necessary to support additional switch and argument types.
 *	To do this, you will need to edit this file and toolprs.c.  See comments
 *	with "EXTEND:" in them for notes on where to do this.
 ******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////////////
//	Stuff tool code needs to provide.
////////////////////////////////////////////////////////////////////////////////

// Decleration for the main processing the tool does.
extern BOOL	ToolMain(void);

////////////////////////////////////////////////////////////////////////////////
//	Declerations relating to command line switches.
////////////////////////////////////////////////////////////////////////////////

// Types of switches supported.
// EXTEND: You can add more switch types here.
typedef enum tagSWITCH_TYPES {
	SWITCH_HELP,			// Print out help message and exit.
	SWITCH_BOOL,			// Boolean, set to TRUE if specified.
	SWITCH_STRING,			// A string.
	SWITCH_UNSIGNED,		// An unsigned integer value.
} SWITCH_TYPES;

// Structure to hold spec for a switch.
typedef struct tagSWITCH_SPEC {
	TCHAR			wchSwitch;		// Switch character
	SWITCH_TYPES	switchType;		// What type is it.
	void			*pSwitch;		// Where to put results.
} SWITCH_SPEC;

////////////////////////////////////////////////////////////////////////////////
//	Declerations relating to command line arguments.
////////////////////////////////////////////////////////////////////////////////

// Magic names to use for standard IO files.
#define	ARG_STDIN		_T("<stdin>")
#define	ARG_STDOUT		_T("<stdout>")
#define	ARG_STDERR		_T("<stderr>")

// Types of arguments supported.
// EXTEND: You can add more argument types here.
typedef enum tagARG_TYPES {
	ARG_STRING,				// Any old string
	ARG_FILE,				// File to open with specified mode.
	ARG_FILE_UTIL,			// File to open with UtilOpen
	ARG_UNSIGNED,		// An unsigned integer value.
} ARG_TYPES;

// Struct to hold spec for an argument.
typedef struct tagARG_SPEC {
	TCHAR			*pName;		// Argument name, used in log file.
	ARG_TYPES		argType;	// Type of argument.
	TCHAR			*pMode;		// Mode for file opens.
	TCHAR			*pDefault;	// Optional default value.
	TCHAR			**ppText;	// Where to put text of argument.
	void			*pValue;	// Where to put value (if needed).
} ARG_SPEC;

////////////////////////////////////////////////////////////////////////////////
//	Public interface types and functions.
////////////////////////////////////////////////////////////////////////////////

// Structure to pull togather all the configuration pieces so that we only
// have to pass one thing to the functions.
typedef struct tagPARSE_INFO {
	int			cUsageStrings;					// Number of usage strings.
	TCHAR		const * const *ppUsageStrings;	// Text for usage message.
	int			cSwitchSpecs;					// Number of switch spec.
	SWITCH_SPEC	const *pSwitchSpecs;			// Switch specifications.
	int			cArgSpecs;						// Number of program arguments.
	ARG_SPEC	const *pArgSpecs;				// Argument specifications.
	FILE		**ppLogFile;					// File to log output too.
} PARSE_INFO;

// Actually parses command line.
BOOL	ToolMainParseArguments(
	PARSE_INFO	const *pParseInfo,
	int			argc,
	TCHAR		**argv
);

// Print out usage message.
void	ToolMainUsage(PARSE_INFO const *pParseInfo);

// Log standard header information.
void	ToolMainLogHeader(
	PARSE_INFO	const *pParseInfo,
	int			argc,
	TCHAR		**argv
);

// Log standard trailer information
void	ToolMainLogTrailer(PARSE_INFO const *pParseInfo);

// Cleanup, close files etc.
BOOL	ToolMainCleanup(
	PARSE_INFO		const *pParseInfo
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 8
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                        // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                        // Trie in which to find indexed word
        DWORD           nIndex,                 // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int                     cwc                             // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                        // Trie in which to find word index
        wchar_t    *pwszWord,           // Word for which we're looking
        int                     tag                             // Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                        // Trie in which to find indexed word
        DWORD           nIndex,                 // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int                     cwc,                    // Max characters in buffer (including NULL)
        int                     tag                             // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                        // Trie in which to find prefix range
        wchar_t    *pwszWord,           // Prefix for which we're looking
        int                *piStart                     // Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                            // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,                      // buffer to hold words being enumerated
        void *pvParam,                          // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\udictp.h ===
/******************************************************
 *
 * uDictP.h
 *
 * Private dclartaions involving the user dictionary
 *
 *****************************************************/

#ifndef H_UDICTP_H
#define H_UDICTP_H


#define	NO_LINK		(-1)	// Offset value use when no valid link.

// User dictionary Flags.
#define	UDF_VALID		0x0001	// End of valid word.
#define	UDF_HAS_TAG		0x0002	// Tag information stored for this node.
#define	UDF_IS_TAG		0x0004	// Tag information, is NOT normal node.


#ifdef __cplusplus
extern "C"
{
#endif

// Node in user dictionary.
typedef struct tagNODE {
	wchar_t		wchLabel;			// Character label of node
	WORD		flags;				// Node flags.
	int			iDown;				// Index of down node.
	union {
		int				iRight;				// Index of right node.
		const wchar_t	*pTag;				// Pointer to tag info.
	} uu;
} NODE;

typedef enum tagUDICT_IDX {READER=1, WRITER} UDICT_IDX;		// Identifer if I am a reader or writer of the XWL

// The header structure for the user dictionary.
// June 2001. Implement read/write locking to protect
// multiple thread access as in the following table:
//           Read Access       Write Access
// Reading      Yes					No
// Writing		No					No
//
typedef struct tagUDICT {
	NODE		*pNodeAlloc;		// Allocated array of nodes.
	int			cNodes;				// Count of allocated nodes in array.
	int			cNodesUsed;			// Count of nodes used in array.
	int			iFreeList;			// Offset of first item in free list.
	int			iRoot;				// Offset of root of trie.
	BOOL		bIsChanged;			// True if dictionary has changed since last save
	int			iLen;				// Amount of space needed to save all the words in the dictionary
	int			cReadLock;			// Number of read locks on to prevent write updates during a read
	HANDLE		hReadLockEvent;		// Signal reading of the User dictiionary
	HANDLE		hWriteLockMutex;	// Signals a writing thread has ownership
	HANDLE		hRWevent;			// Signals either read or write has ownership
} UDICT;

// Synchronization functions
BOOL UDictInitLocks(UDICT *pDict);
void UDictDestroyLocks(UDICT *pDict);
void UDictGetLock(HWL hwl, UDICT_IDX idx );
void UDictReleaseLock(HWL hwl, UDICT_IDX idx);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\recogdll.h ===
/****************************************************************************
*
* recogDLL.h
* created: 13 March 2000
* mrevow
*
* Support routines for loading the DLL and calling its api.
* This library supports the following API:
*
* OpenRecognizer();
* DoXXX()   - One for each function tin the DLL api
* CloseRecognizer();
*
* Error return policy.
*
* 1) The only error that OpenRecognizer will report if it cannot find the DLL
* The DoXXX() routines will pass on the **real** API error return. If the API
* does not exist in the DLL it will return HRCR_UNSUPPORTED
*
* Here is the preferred usage
*
* void *pvRecog;
* unsigned char *pRecogDLL = "madusa.dll";

* pvRecog = OpenRecognizer("madusa.dll");
* if (!pvRecog);
* {
*	printf("Cannot find madusa.dll\n");
*   exit (1);
* }
*
* hrc = DoCreateCompatibleHRC();
* .
* .
* .
* CloseRecognizer(pvRecog);
*
******************************************************************************/

#ifndef H_RECOGDLL_H
#define H_RECOGDLL_H

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif
	
extern void * OpenRecognizer(const char *name);
extern const char *DoRecogDLLName(void *pv);
extern void CloseRecognizer(void * pv);

		// Available Api's
extern const char *DoRecogDLLName(void *pv);
extern int DoConfigRecognizer(void *pv, unsigned int uSubFunc, WPARAM wParam, LPARAM lParam);
extern HRC DoCreateCompatibleHRC(void *pv, HRC hrc, HREC hrecUnused);
extern int DoSetAlphabetHRC(void *pv, HRC hrc, ALC alc, LPBYTE pbUnused);
extern int DoSetGuideHRC(void *pv, HRC hrc, LPGUIDE lpguide,  UINT nFirstVisible);
extern int DoSetRecogSpeedHRC(void *pv, HRC hrc, int iSpeed);
extern int DoDestroyHRC(void *pv, HRC hrc);
extern int DoAddPenInputHRC(void *pv, HRC hrc, POINT *rgPoint, LPVOID lpvUnused, UINT uiUnused, STROKEINFO *pSi);
extern int DoEndPenInputHRC(void *pv, HRC hrc);
extern int DoProcessHRC(void *pv, HRC hrc, DWORD dwUnused);
extern int DoHwxGetWordResults(void *pv, HRC hrc, UINT cAlt, char *buffer, UINT buflen);
extern int DoHwxGetCosts(void *pv, HRC hrc, UINT cAltMax, int *rgCost);
extern int DoHwxGetNeuralOutput(void *pv, HRC hrc, void *buffer, UINT buflen);
extern int DoHwxGetInputFeatures(void *pv, HRC hrc, unsigned short *rgFeat, UINT cWidth);
extern void DoHwxSetPrivateRecInfo(void *pv, void *v);
extern int DoHwxSetAnswer(void *pv, char *sz);
extern int DoSetWordlistCoercionHRC(void *pv, HRC hrc, UINT uCoercion);
extern HWL DoCreateHWL(void *pv, HREC hrec, LPSTR lpsz, UINT uType, DWORD dwReserved);
extern int DoDestroyHWL(void *pv, HWL hwl);
extern int DoSetWordlistHRC(void *pv, HRC hrc, HWL hwl);
extern int DoEnableSystemDictionaryHRC(void *pv, HRC hrc, BOOL fEnable);
extern int DoEnableLangModelHRC(void *pv, HRC hrc, BOOL fEnable);
extern BOOL DoIsStringSupportedHRC(void *pv, HRC hrc, unsigned char *sz);
extern int DoGetMaxResultsHRC(void *pv, HRC hrc);
extern int DoSetMaxResultsHRC(void *pv, HRC hrc, UINT cAltMax);
extern int DoGetResultsHRC(void *pv, HRC hrc, UINT uType, HRCRESULT *pResults, UINT cResults);
extern int DoGetAlternateWordsHRCRESULT(void *pv, HRCRESULT hrcresult, UINT iSyv, UINT cSyv, HRCRESULT *pResults, UINT cResults);
extern int DoGetSymbolsHRCRESULT(void *pv, HRCRESULT hrcresult, UINT iSyv, SYV *pSyv, UINT cSyv);
extern int DoGetSymbolCountHRCRESULT(void *pv, HRCRESULT hrcresult);
extern BOOL DoSymbolToCharacter(void *pv, SYV *pSyv, int cSyv, char *sz, int *pConv);
extern BOOL DoSymbolToCharacterW(void *pv, SYV *pSyv, int cSyv, WCHAR *wsz, int *pConv);
extern int DoGetCostHRCRESULT(void *pv, HRCRESULT hrcresult);
extern int DoDestroyHRCRESULT(void *pv, HRCRESULT hrcresult);
extern HINKSET DoCreateInksetHRCRESULT(void *pv, HRCRESULT hrcresult, unsigned int iSyv, unsigned int cSyv);
extern BOOL DoDestroyInkset(void *pv, HINKSET hInkset);
extern int DoGetInksetInterval(void *pv, HINKSET hInkset, unsigned int uIndex, INTERVAL *pI);
extern int DoGetInksetIntervalCount(void *pv, HINKSET hInkset);
extern DWORD DoGetTiming(void *pv, void *pVoid, BOOL bReset);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\udict.h ===
// FILE: udict.h
// Internal API for User dictionary.

#ifdef __cplusplus
extern "C"
{
#endif

// Status values returned from User Dictionary procedures.
enum {
	udError,			// Externally caused error, E.g. out of memory.
	udFail,				// Operation failed because requested action not possable.
	udSuccess,			// Operation completed successfully.
	udWordFound,		// Word was in dictionary.
	udWordNotFound,		// Word was NOT in dictionary.
	udWordAdded,		// Word was added to dictinary.
	udWordDeleted,		// Word was deleted from dictionary.
	udWordChanged,		// Word tag information was changed in dictionary.
	udNoTag,			// Word has no tags.
	udStopEarly,		// Stop processing early (not an error).
	udNumStatus
};

// Flags for UD_NODE_INFO flags field.
#define UDNIF_VALID		0x0001		// End of valid word.
#define UDNIF_HAS_RIGHT	0x0002		// There is a node to the right of this one.
#define UDNIF_HAS_DOWN	0x0004		// There is a node down from of this one.
#define UDNIF_HAS_TAG	0x0008		// Tag information stored for this node.

// Information that can be fetched from a node.
// Note: tags only occur on nodes that are valid.
// Note: if fValid is true and fHasTag is false, then then there is no tag.  
// If fHasTag is valid, then you have to
// check out the tags to find out what versions exist (e.g. don't assume that
// an untagged version exists).
typedef struct tagUD_NODE_INFO {
	wchar_t		wchLabel;
	WORD		flags;		// Node flags.
	HANDLE		hRight;		// Handle on right node, only valid if fHasRight.
	HANDLE		hDown;		// Handle on down node, only valid if fHasDown.
	HANDLE		hTag;		// Handle on tag, only valid if hsHasTag.
} UD_NODE_INFO;

// Longest word allowed in user dictionary.
#define	UDICT_MAX_WORD		128
//
// User dictionary APIs.
//

// Create a new User Dictionary
// Return:
//		NULL			Could not allocate memory for Dictionary
//		!NULL			Handle on dictionary.
HANDLE	UDictCreate();

// Destroy a User Dictionary, free all allocated memory.
// Return:
//		udError			Error freeing memory
//		udSuccess		All memory successfully freed.
int		UDictDestroy(HANDLE hUDict);

// Get Handle on root node.
// Return:
//		udFail			User dictionary is empty, no root node available.
//		udSuccess		Root node successfully filled in.
int		UDictRootNode(HANDLE hUDict, HANDLE *phRoot);

// Move one node to the right (e.g. alternate character to current one).
// Fill in phNode with your current node.  On success, it will be replaced
// with the new node.
// Return:
//		udFail			No right node available.
//		udSuccess		Right node successfully filled in.
int		UDictRightNode(HANDLE hUDict, HANDLE *phNode);

// Move one node to the down (e.g. character following current one).
// Fill in *phNode with your current node.  On success, it will be replaced
// with the new node.
// Return:
//		udFail			No down node available.
//		udSuccess		Right node successfully filled in.
int		UDictDownNode(HANDLE hUDict, HANDLE *phNode);

// Fetch the character label on the node.
// Return:
//		The character label on the node.
wchar_t	UDictNodeLabel(HANDLE hUDict, HANDLE hNode);

// Fetch information about node.  Passed in node info structure will be filled
// in with contents of hNode.
// Return:
//		udSuccess		Node values successfully filled in.
int		UDictGetNode(HANDLE hUDict, HANDLE hNode, UD_NODE_INFO *pNodeInfo);

// Fetch tag.  You must pass in a valid tag handle.
// Note that the returned pointer is to memory allocated by user dictionary.
// If you want to keep the value around, copy it into memory you control, because
// the returned copy may go away the next time the udict is modified.
// Return:
//		!NULL		Pointer to tag.
const wchar_t	*UDictFetchTag(HANDLE hUDict, HANDLE hTag);

// Add a word to the user dictionary.  Optional tag allowed.
// Return:
//		udError			Could not grow dictinary to hold new word.
//		udFail			Zero length word can not be added.
//		udWordFound		Word (and tag) already in dictinary, no update needed.
//		udWordAdded		Word added to dictionary.
//		udWordChanged	New word tag was set for existing word in dictionary.
// Note: word and tag are copied into User dictionary, so that callers memory
// may be reused or freed after call returns.
int		UDictAddWord(HANDLE hUDict, const wchar_t *pwchWord, const wchar_t *pTag);

// Delete a word from the user dictionary.
// Return:
//		udError			Error adjusting size of dictionary (?possable?).
//		udWordNotFound	Word was not in dictionary. no update needed.
//		udWordDeleted	Word was deleted from dictionary.
int		UDictDeleteWord(HANDLE hUDict, const wchar_t *pwchWord);

// Find a word, also gets its tag if it has one.
// Return:
//		udWordNotFound	Word was not in dictionary, no tag returned.
//		udWordFound		Word found, tag pointer for node filled in.
// Note that the returned tag pointer is to memory allocated by user dictionary.
// If you want to keep the value around, copy it into memory you control, because
// the returned copy may go away the next time the udict is modified.
int		UDictFindWord(
	HANDLE			hUDict, 
	const wchar_t	*pwchWord,
	const wchar_t	**ppTag		// Out: pointer tag.
);

// Enumerate the tree.  Call a callback function for each word in selected range.
// Return:
//		udFail			Invalid range of words or call back failed.
//		udSuccess		Right node successfully filled in.
// The enumeration function must return one of the following three values:
//		udFail			Error in processing, abort traversal and return error.
//		udStopEarly		Successfully prcessed word, but we don't need to see any more.
//		udSuccess		Successfully prcessed word, continue to next..
#define UDICT_ENUM_TO_END	-1			// Value for lastWord to go to end of dictionary.
typedef	int	(*P_UD_ENUM_CALL_BACK)(
	void			*pCallBackData,
	int				wordNumber,
	const wchar_t	*pWord,
	const wchar_t	*pTag
);

int		UDictEnumerate(
	HANDLE				hUDict,
	P_UD_ENUM_CALL_BACK	pCallBack,		// Function to call on each selected word.
	void				*pCallBackData	// Data to pass to callback function
);

// Merge one word list into another
//   Supply both the Source and Destination word Lists
//   The merge directly merges the tries rather than expanding
//   adding
//
// CAVEATES:
//   1) Before merging we allocate enough memory to guarantee
//      the merge completes, but this may leave memory unused
//      Code changes at the expense of speed will be required to modify this
//	 2) If a word in both the source and destination both contain
//		tags, we retain only the original (destination) tag. 
//		(The code does not support multiple tags)
//
// Returns TRUE if the merge completed successfully, FALSE
// otherwise
//
int UDictMerge(HANDLE hUSrc, HANDLE hUDest);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\unicode.h ===
#ifndef __INCLUDE_UNICODE
#define __INCLUDE_UNICODE

#ifdef __cplusplus
extern "C" {
#endif

typedef long  SYV;
typedef ALC   RECMASK;
typedef WORD SYM;
typedef SYM * LPSYM;

extern const RECMASK rgrecmaskUnicode[94];

#define RecmaskFromUnicode(w)    \
   (((w) < 0x0021) ? ALC_OTHER : \
    ((w) > 0x007E) ? ALC_OTHER : \
    rgrecmaskUnicode[w-0x0021])

wchar_t MapFromCompZone(wchar_t wch);
BOOL    IsSupportedCode(DWORD cp, wchar_t wch);
BOOL    IsHan(DWORD cp, wchar_t wch);
BOOL    IsPunc(wchar_t wch);
BOOL    IsDigit(wchar_t wch);
BOOL    IsAlpha(wchar_t wch);
BOOL    IsHiragana(wchar_t wch);
BOOL    IsKatakana(wchar_t wch);
BOOL    IsBoPoMoFo(wchar_t wch);

#ifdef __cplusplus
}
#endif

#endif //__INCLUDE_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\util.h ===
#ifndef	__INCLUDE_UTIL
#define	__INCLUDE_UTIL

#ifdef	__cplusplus
extern "C" {
#endif

/* Attempt to fopen pszFileName in mode pszMode. If that fails, try it in the subdirectory
above the current one.  Continue up the directory tree until you reach the top.  Return
NULL only if ALL attempts fail.  In case of success, return the actual path to the
opened file in pszFullPath.  cchFullPathMax is the size of the buffer pszFullPath
points to. */

FILE *
UtilOpen(
	TCHAR *pszFileName,		// File to open 
	TCHAR *pszMode, 		// stdio mode string
	TCHAR *pszFullPath,		// Out: path to file opened, if any
	int    cchFullPathMax	// size in bytes of pszFullPath
);

/* Same as UtilOpen except current directory is not used.  Instead, search starts in  
directory named by pszPath */

FILE *
UtilOpenPath(
	TCHAR *pszPath,			// Path to start looking for file
	TCHAR *pszFileName,		// File to open 
	TCHAR *pszMode, 		// stdio mode string
	TCHAR *pszFullPath,		// Out: path to file opened, if any
	int    cchFullPathMax	// size in bytes of pszFullPath
);

#ifdef	__cplusplus
};
#endif

#endif	//__INCLUDE_UTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\unitools.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>

/* Simple but direct hash function that hashes across several bits by
multiplying by the greatest prime less than bits**2 and masking off the excess. */

#define PrimeHash(wOld, wNew, cBitsMax)	(((wOld) + (wNew))*hashPrime[cBitsMax]&hashMask[cBitsMax])

WCHAR
GetCharacter(FILE *pFile);

WCHAR
PutCharacter(WCHAR wch, FILE *pFile);

WCHAR *
GetLine(
	WCHAR *pStr0,
	int maxlen,
   FILE *pFile
);

void
PutLine(WCHAR *pString, FILE *pFile);

const unsigned int hashPrime[];
const unsigned int hashMask[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\xrcreslt.h ===
// xrcreslts.c
// James A. Pittman
// Jan 7, 1999

// A container object to hold the results of recognition.

// This is currently used by Inferno, MadCow, and Famine.

#ifndef _XRCRESLTS_
#define _XRCRESLTS_

#define MAXMAXALT 32

// Spped Accuracy tradeof values
#define HWX_MIN_SPEED		0
#define HWX_MAX_SPEED		100

#ifdef UNDER_CE
#define HWX_DEFAULT_SPEED	50
#else
#define HWX_DEFAULT_SPEED	0
#endif

#define PHRASE_GROW_SIZE	4

#define NOT_RECOGNIZED		"\a"

#define BASELIMIT			700				// scale ink to this guide hgt if we have a guide
#define MAX_SCALE			10				// We will not scale more than this.

#define MAX_SEG			5			// maximum number of segmentations to resolve among
#define MAX_SEG_WORD	5			// maximum number of wordmaps in a segmentation

#ifdef __cplusplus
extern "C" 
{
#endif

typedef struct tagWORDMAP WORDMAP;

typedef struct tagLATINLAYOUT
{
	// the first 4 fields are y-values for 4 lines relative to the bounding rect of ink
	// see the functions AbsoluteToLatinLayout() and LatinLayoutToAbsolute() for details
	short iBaseLine;
	short iMidLine;
	short iAscenderLine;
	short iDescenderLine;
	// the next 4 fields indicate which of the previous 4 are computed
	unsigned char bBaseLineSet;
	unsigned char bMidLineSet;
	unsigned char bAscenderLineSet;
	unsigned char bDescenderLineSet;
} LATINLAYOUT;

// The XRCRESULT object describes a single alternative interpretation of the ink.
// There are 2 types: phrase and word.  Both have a string and a cost.
// Word XRCRESULT objects have a 0 cWords and a NULL pMap.
// Phrase XRCRESULT objects have pMap pointing to an array of word mappings,
// with the count of mappings in cWords.  The PenWin API represents this
// with an HRCRESULT.

typedef struct tagXRCRESULT		
{
	unsigned char *szWord;		// we use malloc for this string/phrase
	int			cost;			// 0 for perfect match, intmax for no match, neg numbers meaningless
    unsigned int cWords;		// 0 in word mode, count of space delimited words in panel mode
	DWORD		iLMcomponent;	// Portion of LM generating this result
    WORDMAP		*pMap;			// NULL in word mode, valid in panel mode.
    void		*pXRC;			// Pointer to the xrc.
} XRCRESULT;

// The ALTERNATES object represents a set of alternative results for the
// same ink.  It has a count of alternates, and an array of XRCRESULT objects.
// The array is in-line, with a length of MAXMAXALT.  The alternates stay sorted
// in increasing cost order.  This is not represented in the PenWin API.

// The users code, an implementation of HRC, should probably include an ALTERNATES
// object in-line.  On initialization the field cAlt should be zeroed.
// Use RCRESALTInsert() to insert answers into the list of alternates.

typedef struct tagALTERNATES
{
	unsigned int cAlt;			// how many (up to 10) actual answers do we have
    unsigned int cAltMax;       // I can use this to say "I only want 4". !!! should be in xrc
	XRCRESULT aAlt[MAXMAXALT];	// The array of XRCRESULT structures
	LATINLAYOUT all[MAXMAXALT];  // baseline stuff for each alternate
	int iConfidence;            //Contains the confidence level
} ALTERNATES;

// The WORDMAP contains a description of a word within the phrase
// (the start index and the length), and a ALTERNATES to hold the alternative
// results for this word.  This is not represented in the PenWin API.

typedef struct tagWORDMAP
{
	unsigned short start;		// start of the word in the phrase
    unsigned short len;         // len of word in the phrase
    int cStrokes;               // Count of strokes in this word
    int *piStrokeIndex;         // Stroke indexes for this word
    ALTERNATES alt;             // alternates for the word (only)
} WORDMAP;

// The XINKSET is the struct pointed to by an HINKSET.
// It contains a counted array of INTERVALs, describing a (sub)set
// of the ink in an HRC.  The INTERVAL struct is defined in penwin.h

typedef struct tagXINKSET
{
	unsigned int count;
	INTERVAL interval[1];
} XINKSET;

// Verifies that the count of alternates is between 0 and 10 (inclusive).
// Verifies that each live alternate has a non-NULL szWord.

typedef struct tagANSWER_SET
{
	ALTERNATES	*pAlternates;
	int			capSegments;
	int			cAnsSets;
} ANSWER_SET;
	

// place holders for segmentation and SegCol structures
typedef struct tagSEGMENTATION		SEGMENTATION;
typedef struct tagSEG_COLLECTION	SEG_COLLECTION;

// structure representing a single word alternate
typedef struct tagWORD_ALT
{
	unsigned char	*pszStr;		// CP1252 string 
	int				iCost;			// cost assigned to the string by the recognizer
	LATINLAYOUT		ll;
} 
WORD_ALT;

// structure representing a single word alternate list
typedef struct tagWORD_ALT_LIST
{
	int			cAlt;				// number of alternates
	WORD_ALT	*pAlt;				// list of alternates
}
WORD_ALT_LIST;

// structure describing the set of features for a word map
typedef struct tagWORD_FEAT
{
	RECT	rect;
	int		cSeg;

	int		iInfernoScore;			// score inferno assign to Top1 of wordmap
	int		iInfernoUnigram;		// unigram value for Inferno's Top1 of wordmap
	int		bInfTop1Supported;		// Is inferno's Top1 word supported

	int		iInfCharCost;
	int		iInfAspect;
	int		iInfHeight;
	int		iInfMidLine;

	int		iInfRelUni;
	int		iInfRelBi;
	
	int		iBearScore;				// score Bear assign to Top1 of wordmap
	int		iBearUnigram;			// unigram value for Bear's Top1 of wordmap
	int		bBearTop1Supported;		// Is Bear's Top1 word supported

	int		iBearCharCost; 
	int		iBearAspect;
	int		iBearHeight; 
	int		iBearMidLine;

	int		iBearRelUni;
	int		iBearRelBi;

	int		bIdentical;				// are Inferno and Bear's output identical
}
WORD_FEAT;

// structure representing a single word map (an ink chunk hypothesized to be a word)
typedef struct tagWORD_MAP
{
	int				cStroke;			// number of strokes
    int				*piStrokeIndex;     // list of stroke IDs (Frame IDs)

	WORD_ALT_LIST	*pInfernoAltList;	// alt list produced by inferno
	WORD_ALT_LIST	*pBearAltList;		// alt list produced by bear
	WORD_ALT_LIST	*pFinalAltList;		// final alt list 

	int				iConfidence;		// confidence value assigned to this word
	
	WORD_FEAT		*pFeat;				// word map features used for segmentation
}
WORD_MAP;


// structure describing the set of features for a segmentation.
typedef struct tagSEG_FEAT
{
	BOOL	bInfernoTop1;			// is this Inferno 's Top1 segmentation
	BOOL	bBearTop1;				// is this Bear 's Top1 segmentation

	int		iSort1;					// Sort criteria 1, currently for USA = cWord
	int		iSort2;					// Sort criteria 2, currently for USA = Avg. Inferno score
}
SEG_FEAT;

// structure describing a particular segmentation of a chunk of ink into word_map(s)
typedef struct tagSEGMENTATION
{
	int				cWord;				// # of word maps
	WORD_MAP		**ppWord;			// list of wordmaps
	
	int				iScore;				// score assigned to this segmentation by
										// the segmentation classifier. Ranges from 0-0xFFFF
	
	SEG_FEAT		*pFeat;				// Segmentation feature vector

	SEG_COLLECTION	*pSegCol;			// the SegCol that this segmentation belongs to
}
SEGMENTATION;

// structure describing all the possible segmentations of a chunk of ink referred to as a 
// segmentation set
typedef struct tagSEG_COLLECTION
{
	int				cSeg;				// # of possible segmenatations
	SEGMENTATION	**ppSeg;			// list of possible segmentations
}
SEG_COLLECTION;

// structure describing a whole piece of ink as a number of seg_set (s)
typedef struct tagLINE_SEGMENTATION
{
	int				iyDev;					// yDev for the whole ink line

	int				cSegCol;				// # of SegCols
	SEG_COLLECTION	**ppSegCol;				// list of SegCols

	int				cWord;					// # of wordmaps constiuting the seg_set segmentations
	WORD_MAP		**ppWord;				// list of word maps constiuting the seg_set segmentations
}
LINE_SEGMENTATION;


// structure used in Word breaking; similar to wordmap but got rid of unused entries.
typedef struct tagWORDINFO
{
	int			cStrokes;		// Count of strokes in this word
    int			*piStrokeIndex;	// Stroke indexes for this word
	ALTERNATES	alt;
}
WORDINFO;

// line structure
typedef struct tagINKLINE
{
	DWORD				dwCheckSum;
	BOOL				bRecognized;

	RECT				rect;
	int					cStroke;
	int					cPt;
	POINT				**ppPt;
	int					*pcPt;
	GLYPH				*pGlyph;

	LINE_SEGMENTATION	*pResults;

	__int64				Mean;
	__int64				SD;
}INKLINE;


// line breaking structure
typedef struct tagLINEBRK
{
	int		cLine;
	INKLINE	*pLine;

	RECT	Rect;
}
LINEBRK;

#ifndef NDEBUG
extern void ValidateALTERNATES(ALTERNATES *pAlt);
#endif

// Inserts a new word and its cost into the set of alternates.
// The alternates remain in sorted order.
extern int InsertALTERNATES(ALTERNATES *pAlt, int cost, unsigned char *word, void *pxrc);

// Initializes a XRCRESULT object to represent a phrase.
// The caller passes in a vector of pointers to ALTERNATES, representing
// the sequence of words and their alternates.  We steal them into
// a vector of WORDMAP structs, and set up an XRCRESULT object
// to own that vector of maps.

// If an ALTERNATES object contains 0 answers, we insert "???" into the
// phrase string, and in the word map we set the start and len fields
// to refer to the "???".

// We assume the caller passes at least 1 ALTERNATES, even though
// it might have 0 answers.

// Should the symbol be something special for "???".

// Currently this version handles isolated periods and commas
// correctly (they do not get a space before them).  This is
// to accomodate the current MadCow, which handles periods and
// commas separately.

// This should probably change to init (rather than malloc) an alt set
// to have 1 result.
extern int RCRESULTInitPhrase(XRCRESULT *pRes, ALTERNATES **ppWords, unsigned int cWords, int cost);

// Sets the backpointers in all XRCRESULT objects within and ALTERNATES object,
// including any contained within word mappings.
//extern void SetXRCALTERNATES(ALTERNATES *pAlt, void *pxrc);


// A destruction function that should only be used by an HRC destroying
// the result objects that it owns.  The PenWin function DestroyHRCRESULT()
// is a no-op, since the result objects are internal to larger data structures.
extern void ClearALTERNATES(ALTERNATES *pAlt);

// Truncates the alt list to cAltmax, From cAltMax onwards: Does what ClearALTERNATES
// Only intended for WORD ALTERNATES
extern void TruncateWordALTERNATES(ALTERNATES *pAlt, unsigned int cAltMax);

// Frees the stroke index array associated with a wordmap. 
void FreeIdxWORDMAP(XRCRESULT *pMap);

// Add a stroke to the wordmap checking for duplicates and maintaining the a sorted list
extern void AddThisStroke(WORDMAP *pMap, int iInsertStroke);

// Locates WORDMAP under a specified result phrase based on the word position and length.
extern WORDMAP *findWORDMAP(XRCRESULT *pRes, unsigned int iWord, unsigned int cWord);

// Locates WORDMAP under a specified phrase result that contains a specified word result.
extern WORDMAP *findResultInWORDMAP(XRCRESULT *pPhrase, XRCRESULT *pWord);
extern WORDMAP *findResultAndIndexInWORDMAP(XRCRESULT *pPhrase, XRCRESULT *pWord, int *pindex);

// Copy word maps into an xrCresult
extern BOOL XRCRESULTcopyWordMaps(XRCRESULT *pRes, int cWord, WORDMAP *pMap);

// Returns an array of RES pointers, one for each alternative interpretation of the
// same word.  The word is designated by RES object, start index, and letter count.
// We return the pointers in ppRes, and return the count.
// We only do whole words, so if the caller requests a substring that is not a word,
// we return 0.  If the word is the special marker "???" meaning the recognizer could
// not produce interpretations, we return 0.
extern int RCRESULTWords(XRCRESULT *pRes, unsigned int iWord, unsigned int cWord, XRCRESULT **ppRes, unsigned int cRes);

// Returns (in a buffer provided by the caller) the "symbols" of the
// word or phrase represented by pRes.  Symbols are 32 bit codes.
// Here the null byte at the end of a string is part of the string and
// is copied into the symbol value array if there is room.
// Returns the number of symbols inserted.
extern int RCRESULTSymbols(XRCRESULT *pRes, unsigned int iSyv, int *pSyv, unsigned int cSyv);

// Translates an array of symbols into an ANSI (codepage 1252) string.
// This and SymbolToUnicode() below both translate until either cSyv is
// exhausted or until they hit a NULL symbol or a NULL character.
// The both return the count of symbols translated in *pCount.
// Both return 1 if successful, or 0 if they encountered something
// that could not be translated.
extern int SymbolToANSI(unsigned char *sz, int *pSyv, int cSyv, int *pCount);

// Translates an array of symbols into a Unicode string.
extern int SymbolToUnicode(WCHAR *wsz, int *pSyv, int cSyv, int *pCount);

// Backward compatibility.
// These 2 functions exist to support the old API.

extern int ALTERNATESString(ALTERNATES *pAlt, char *buffer, int buflen, int max);
extern int ALTERNATESCosts(ALTERNATES *pAlt, int max, int *pCost);

// Creates an InkSet to represent the part of pGlyph included within
// a specified WORDMAP.
extern XINKSET *mkInkSetWORDMAP(GLYPH *pGlyph, WORDMAP *pMap);

// Creates an InkSet to represent the part of pGlyph included
// within a specified word within a phrase.
extern XINKSET *mkInkSetPhrase(GLYPH *pGlyph, XRCRESULT *pRes, unsigned int iWord, unsigned int cWord);

// given a main glyph and a wordmap, 
// this function returns a pointer to glyph representing the word only
extern GLYPH *GlyphFromWordMap (GLYPH *pMainGlyph, WORDMAP *pMap);
extern GLYPH *GlyphFromNewWordMap (GLYPH *pMainGlyph, WORD_MAP *pMap);

// given a main glyph and set of strokes, 
// this function returns a pointer to glyph representing only those strokes
extern GLYPH *GlyphFromStrokes(GLYPH *pMainGlyph, int cStroke, int *piStrokeIndex);

// Frees a word alt
void FreeWordAlt (WORD_ALT *pAlt);

// Frees a word alt list
void FreeWordAltList (WORD_ALT_LIST *pAltList);

// Frees a word map
void FreeWordMap (WORD_MAP *pWordMap);

// Frees a specific segmentation
void FreeSegmentation (SEGMENTATION *pSeg);

// frees the word maps in a segmentation
void FreeSegmentationWordMaps (SEGMENTATION *pSeg);

// Frees a segmentation set
void FreeSegCol (SEG_COLLECTION *pSegCol);

// Frees an ink line segmentation
void FreeLineSegm (LINE_SEGMENTATION *pLineSegm);

// compares the stroke contents of two word maps
BOOL IsEqualWordMap (WORD_MAP *pMap1, WORD_MAP *pMap2);

// compares the stroke contents of two word maps
BOOL IsEqualOldWordMap (WORDMAP *pMap1, WORDMAP *pMap2);

// compares two segmentations
BOOL IsEqualSegmentation (SEGMENTATION *pSeg1, SEGMENTATION *pSeg2);

// clones a wordmap, only copies the stroke part
WORD_MAP *CloneWordMap (WORD_MAP *pOldWordMap);

// finds a word_map in pool or wordmaps
// returns the pointer to the word map if found
// if the bAdd parameter is TRUE: adds the new word map if not found a return a pointer
// other wise returns false
WORD_MAP	*FindWordMap (LINE_SEGMENTATION *pLineSegm, WORD_MAP *pWordMap, BOOL bAdd);


// adds a new SegCol to a line segmentation
SEG_COLLECTION *AddNewSegCol (LINE_SEGMENTATION *pLineSegm);

// adds a new segmentation to a SegCol if it is a new one
// returns TRUE: if the segmentation is added to the SegCol (new words are also added to 
// the word map pool in the line segmentation).
// return FALSE: if no addition was made, TRUE otherwise
BOOL AddNewSegmentation		(	LINE_SEGMENTATION		*pLineSegm, 
								SEG_COLLECTION			*pSegCol, 
								SEGMENTATION			*pNewSeg,
								BOOL					bCheckForDuplicates
							 );


// adds a new word_map to a segmentation
WORD_MAP *AddNewWordMap (SEGMENTATION *pSeg);


// appends the wordmaps of one segmentation to another
BOOL AppendSegmentation	(	SEGMENTATION	*pSrcSeg, 
							int				iStWrd, 
							int				iEndWrd, 
							SEGMENTATION	*pDestSeg
						);


// adds a new stroke to a wordmap
BOOL AddNewStroke (WORD_MAP *pWordMap, int iStrk);

// reverses the order of words maps with a segmentation
void ReverseSegmentationWords (SEGMENTATION *pSeg);

// determines the min & max value for a strokeID in a wordmap
int GetMinMaxStrokeID (WORD_MAP *pWord, int *piMin, int *piMax);

BOOL InsertNewAlternate (WORD_ALT_LIST *pAltList, int iCost, unsigned char *pszWord);

// This function finds the range on wordmaps in the search segmentation that
// use exactly the same strokes in the specified wordmap map range in the matching
// segmentation
// The passed bEnd flag specified whether piEndWordMap has to be the last wordmap
// of the search segmentation or not. 
// The return value will be FALSE if no wordmap range with the required specification
// is found
BOOL GetMatchingWordMapRange	(	SEGMENTATION	*pMatchSeg,
									int				iStartWordMap,
									int				iEndWordMap,
									SEGMENTATION	*pSearchSeg,
									int				*piStartWordMap,
									int				*piEndWordMap,
                                    BOOL            bBegin,
									BOOL			bEnd
								);

BOOL WordMapNew2Old (WORD_MAP *pNewWordMap, WORDMAP *pWordMap, BOOL bClone);

BOOL AltListOld2New (ALTERNATES *pOldAltList, WORD_ALT_LIST *pAltList, BOOL bClone);

BOOL AltListNew2Old (	HRC				hrc, 
						WORD_MAP		*pNewWordMap,
						WORD_ALT_LIST	*pAltList, 
						ALTERNATES		*pOldAltList, 
						BOOL bClone
					);

void FreeLines	(LINEBRK *pLineBrk);

BOOL AddNewStroke2Line (int cPt, POINT *pPt, FRAME *pFrame, INKLINE *pLine);

int	FindWordMapInXRCRESULT (XRCRESULT *pRes, WORDMAP *pMap);

short AbsoluteToLatinLayout(int y, RECT *pRect);
int LatinLayoutToAbsolute(short y, RECT *pRect);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\cestubs.c ===
// cestubs.c

#include "common.h"		// this includes cestubs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\inc\xjis.h ===
#ifndef __INCLUDE_XJIS
#define __INCLDUE_XJIS

#ifdef __cplusplus
extern "C" 
{
#endif

typedef long  SYV;
typedef ALC   RECMASK;
typedef WORD SYM;
typedef SYM * LPSYM;

#define SyvFromWord(w)     ((LONG)(WORD)(w) | 0x00030000)
#define WordFromSyv(syv)   ((WORD) (LOWORD((syv))))
#define IsSpecialSYV(syv)  (HIWORD((syv))==SYVHI_SPECIAL)
#define IsAnsiSYV(syv)     (HIWORD((syv))==SYVHI_ANSI)
#define IsGestureSYV(syv)  (HIWORD((syv))==SYVHI_GESTURE)
#define IsKanjiSYV(syv)    (HIWORD((syv))==SYVHI_KANJI)

#define RECMASK_LCALPHA      ALC_LCALPHA   // 0x0001L  a..z
#define RECMASK_UCALPHA      ALC_UCALPHA   // 0x0002L  A..Z
#define RECMASK_ALPHA        (ALC_LCALPHA | ALC_UCALPHA)
#define RECMASK_NUMERIC      ALC_NUMERIC   // 0x00000004L // 0..9
#define RECMASK_ALPHANUMERIC (ALC_ALPHA | ALC_NUMERIC)
#define RECMASK_PUNC         ALC_PUNC      // 0x0008L // !-;`"?()&.,; and backslash
#define RECMASK_MATH         ALC_MATH      // 0x0010L // %^*()-+={}<>,/.
#define RECMASK_MONETARY     ALC_MONETARY  // 0x0020L // ,.$ or local
#define RECMASK_OTHER        ALC_OTHER     // 0x0040L // @#|_~[]
#define RECMASK_ASCII        ALC_ASCII     // 0x0080L // restrict to 7-bit chars 20..7f
#define RECMASK_WHITE        ALC_WHITE     // 0x0100L // white space
#define RECMASK_NONPRINT     ALC_NONPRINT  // 0x0200L // sp tab ret ctrl glyphs
#define RECMASK_DBCS         ALC_DBCS      // 0x0400L // allow DBCS variety of SBCS
#define RECMASK_JIS1         ALC_JIS1      // 0x0800L // kanji JPN, ShiftJIS 1 only
#define RECMASK_GESTURE      ALC_GESTURE   // 0x4000L // gestures
#define RECMASK_HIRAGANA     ALC_HIRAGANA  // 0x00010000L // hiragana JPN
#define RECMASK_KATAKANA     ALC_KATAKANA  // 0x00020000L // katakana JPN
#define RECMASK_JIS2         ALC_JIS2      // 0x00040000L // ShiftJIS 2+3
#define RECMASK_GLOBALPRIORITY  ALC_GLOBALPRIORITY // 0x10000000
//#define RECMASK_DEFAULT      0x00002000
#define RECMASK_NOPRIORITY   ALC_NOPRIORITY // 0x00000000L // for alcPriority == none

#define RECMASK_ALL_DEFAULTS (/*RECMASK_DEFAULT |*/ RECMASK_ALPHANUMERIC | RECMASK_WHITE | RECMASK_PUNC | RECMASK_HIRAGANA | RECMASK_KATAKANA | RECMASK_JIS1 | RECMASK_JIS2 | RECMASK_OTHER)


#define RECMASK_FROM_ALC        (~ALC_RESERVED & ~ALC_USEBITMAP & ~ALC_ASCII)
#define ALC_FROM_RECMASK        (~ALC_RESERVED & ~ALC_GESTURE)

#define RecmaskFromALC(alc)     (RECMASK)(RECMASK_FROM_ALC & (RECMASK)(alc))
#define AlcFromRECMASK(rm)              (ALC)(ALC_FROM_RECMASK & (ALC)(rm))

#define UnsupportedOrBitmapALC(alc)     \
			(~((ALC)RECMASK_FROM_ALC) & (alc))

// KANJI STUFF

#define KANJI_MATCHMAX  6

#define TOKEN_FIRST             600
#define TOKEN_LAST              643

#define KANJI_FIRST             0x8141
#define KANJI_LAST              0xfcfc

#define WDBCSRECMASK_FIRST      0x8140
#define WDBCSRECMASK_LAST       0x81A7

#define KANA_FIRSTMAP           0x8340
#define KANA_LASTMAP            0x8393

#define PUNC_FIRSTMAP           0x8140
#define PUNC_LASTMAP            0x8197

#define CHAR_FIRSTSBCS          0x20 // space
#define CHAR_LASTSBCS           0x7E // '~'

#define CHAR_FIRSTKATA          0xA1
#define CHAR_LASTKATA           0xDF

extern const RECMASK rgrecmaskDbcs[];
extern const RECMASK mptokenrecmask[];
extern const WORD mptokenwmatches[][KANJI_MATCHMAX];

#define IsShiftJisLeadByte(b)   (((BYTE)0x81 <= (BYTE)(b) && (BYTE)(b) <= (BYTE)0x9f) || \
                                 ((BYTE)0xe0 <= (BYTE)(b) && (BYTE)(b) <= (BYTE)0xfc))

#define IsValidShiftJisWORD(w)  \
			((((BYTE)0x81 <= HIBYTE(w) && HIBYTE(w) <= (BYTE)0x9f) || \
			  ((BYTE)0xe0 <= HIBYTE(w) && HIBYTE(w) <= (BYTE)0xfc)) && \
			 (((BYTE)0x40 <= LOBYTE(w) && LOBYTE(w) <= (BYTE)0x7e) || \
			  ((BYTE)0x80 <= LOBYTE(w) && LOBYTE(w) <= (BYTE)0xfc)))
 
#define RecmaskFromWORD(w)               \
   (((w) >  0x9872) ? RECMASK_JIS2 :     \
    ((w) >= 0x889f) ? RECMASK_JIS1 :     \
    ((w) >= 0x8340) ? RECMASK_KATAKANA : \
    ((w) >= 0x829f) ? RECMASK_HIRAGANA : \
    ((w) >= 0x8281) ? RECMASK_LCALPHA :  \
    ((w) >= 0x8260) ? RECMASK_UCALPHA :  \
    ((w) >= 0x824f) ? RECMASK_NUMERIC :  \
	((w) >= WDBCSRECMASK_FIRST && (w) <= WDBCSRECMASK_LAST) ? rgrecmaskDbcs[(w) - WDBCSRECMASK_FIRST] :     \
	RECMASK_OTHER)

#define RecmaskFromShapeWORD(w)                                         \
	(((w) >= TOKEN_FIRST && (w) <= TOKEN_LAST) ?    \
	mptokenrecmask[(w) - TOKEN_FIRST] :                             \
	RecmaskFromWORD(w))

WORD XJISFromSYV(SYV syv);
BOOL SupportedXJIS(WORD wxjis);
SYV	 SBCSFromDBCS(wchar_t wDbcs);
const WORD *pwListFromToken(WORD sym);
WORD   GetFirstMatch(WORD wDbcs);

UINT	IndexFromSYV(SYV syv, UINT maxIndex);
SYV		SyvFromIndex(UINT index);
WORD	TokenFromWORD(WORD wDbcs);
int		IsEnglishCodePoint(int iCode);

int ValidStrokeCount(wchar_t wch, short iStroke);
int NotSuspStrokeCount(wchar_t wch, short iStroke);

#ifdef __cplusplus
};
#endif

#endif //__INCLUDE_XJIS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\altlist.c ===
// altlist.c

#include "common.h"

// Sort the alternate list.
// We do a bubble sort.  The list is small and we can't use qsort because the data is stored in
// two parallel arrays.
void SortAltList(ALT_LIST *pAltList)
{
	int		pos1, pos2;
	int		limit1, limit2;
	FLOAT	* const peScore		= pAltList->aeScore;
	wchar_t	* const pwchList	= pAltList->awchList;

	limit2	= pAltList->cAlt;
	limit1	= limit2 - 1;
	for (pos1 = 0; pos1 < limit1; ++pos1) {
		for (pos2 = pos1 + 1; pos2 < limit2; ++pos2) {
			// Are elements pos1 and pos2 out of order?
			if (peScore[pos1] < peScore[pos2]) {
				FLOAT			eTemp;
				wchar_t			wchTemp;

				// Swap scores and swap characters.
				eTemp			= peScore[pos1];
				peScore[pos1]	= peScore[pos2];
				peScore[pos2]	= eTemp;

				wchTemp			= pwchList[pos1];
				pwchList[pos1]	= pwchList[pos2];
				pwchList[pos2]	= wchTemp;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\english.c ===
#include "common.h"

/******************************Public*Routine******************************\
* IsEnglishCodePoint
*
* This routine can handle folded shapes too.
*
* Returns True if it's a English code point, False otherwise.
*
* History:
*  10-Sep-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int IsEnglishCodePoint(int iCode)
{
    switch (iCode)
    {
         case 0x8149:  // 0x21
         case 0x8168:  // 0x22
         case 0x8194:  // 0x23
         case 0x8190:  // 0x24
         case 0x8193:  // 0x25
         case 0x8195:  // 0x26
         case 0x8166:  // 0x27
         case 0x8169:  // 0x28
         case 0x816a:  // 0x29
         case 0x8196:  // 0x2a
         case 0x817b:  // 0x2b
         case 0x8143:  // 0x2c
         case 0x817c:  // 0x2d
         case 0x8144:  // 0x2e
         case 0x815e:  // 0x3f
         case 0x824f:  // 0x30
         case 0x8250:  // 0x31
         case 0x8251:  // 0x32
         case 0x8252:  // 0x33
         case 0x8253:  // 0x34
         case 0x8254:  // 0x35
         case 0x8255:  // 0x36
         case 0x8256:  // 0x37
         case 0x8257:  // 0x38
         case 0x8258:  // 0x39
         case 0x8146:  // 0x3a
         case 0x8147:  // 0x3b
         case 0x8183:  // 0x3c
         case 0x8181:  // 0x3d
         case 0x8184:  // 0x3e
         case 0x8148:  // 0x3f
         case 0x8197:  // 0x40
         case 0x8260:  // 0x41
         case 0x8261:  // 0x42
         case 0x8262:  // 0x43
         case 0x8263:  // 0x44
         case 0x8264:  // 0x45
         case 0x8265:  // 0x46
         case 0x8266:  // 0x47
         case 0x8267:  // 0x48
         case 0x8268:  // 0x49
         case 0x8269:  // 0x4a
         case 0x826a:  // 0x4b
         case 0x826b:  // 0x4c
         case 0x826c:  // 0x4d
         case 0x826d:  // 0x4e
         case 0x826e:  // 0x4f
         case 0x826f:  // 0x50
         case 0x8270:  // 0x51
         case 0x8271:  // 0x52
         case 0x8272:  // 0x53
         case 0x8273:  // 0x54
         case 0x8274:  // 0x55
         case 0x8275:  // 0x56
         case 0x8276:  // 0x57
         case 0x8277:  // 0x58
         case 0x8278:  // 0x59
         case 0x8279:  // 0x5a
         case 0x816d:  // 0x5b
         case 0x818f:  // 0x5c
         case 0x816e:  // 0x5d
         case 0x814f:  // 0x5e
         case 0x8151:  // 0x5f
         case 0x814d:  // 0x60
         case 0x8281:  // 0x61
         case 0x8282:  // 0x62
         case 0x8283:  // 0x63
         case 0x8284:  // 0x64
         case 0x8285:  // 0x65
         case 0x8286:  // 0x66
         case 0x8287:  // 0x67
         case 0x8288:  // 0x68
         case 0x8289:  // 0x69
         case 0x828a:  // 0x6a
         case 0x828b:  // 0x6b
         case 0x828c:  // 0x6c
         case 0x828d:  // 0x6d
         case 0x828e:  // 0x6e
         case 0x828f:  // 0x6f
         case 0x8290:  // 0x70
         case 0x8291:  // 0x71
         case 0x8292:  // 0x72
         case 0x8293:  // 0x73
         case 0x8294:  // 0x74
         case 0x8295:  // 0x75
         case 0x8296:  // 0x76
         case 0x8297:  // 0x77
         case 0x8298:  // 0x78
         case 0x8299:  // 0x79
         case 0x829a:  // 0x7a
         case 0x816f:  // 0x7b
         case 0x8162:  // 0x7c
         case 0x8170:  // 0x7d
         case 0x8160:  // 0x7e
            return(TRUE);
         default:
            return(FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\cp1252.c ===
// cp1252.c
// James A. Pittman
// Mar 11, 1999
// Added UnicodeToCP1252String() -- May 4, 2001, AGuha


// Translation functions, for translation between codepage 1252 and Unicode.

//#include <windows.h>
//#include "cp1252.h"
#include "common.h"

unsigned char _ctype1252[256] = {
        _CONTROL,               /* 00 (NUL) */
        _CONTROL,               /* 01 (SOH) */
        _CONTROL,               /* 02 (STX) */
        _CONTROL,               /* 03 (ETX) */
        _CONTROL,               /* 04 (EOT) */
        _CONTROL,               /* 05 (ENQ) */
        _CONTROL,               /* 06 (ACK) */
        _CONTROL,               /* 07 (BEL) */
        _CONTROL,               /* 08 (BS)  */
        _SPACE+_CONTROL,        /* 09 (HT)  */
        _SPACE+_CONTROL,        /* 0A (LF)  */
        _SPACE+_CONTROL,        /* 0B (VT)  */
        _SPACE+_CONTROL,        /* 0C (FF)  */
        _SPACE+_CONTROL,        /* 0D (CR)  */
        _CONTROL,               /* 0E (SI)  */
        _CONTROL,               /* 0F (SO)  */
        _CONTROL,               /* 10 (DLE) */
        _CONTROL,               /* 11 (DC1) */
        _CONTROL,               /* 12 (DC2) */
        _CONTROL,               /* 13 (DC3) */
        _CONTROL,               /* 14 (DC4) */
        _CONTROL,               /* 15 (NAK) */
        _CONTROL,               /* 16 (SYN) */
        _CONTROL,               /* 17 (ETB) */
        _CONTROL,               /* 18 (CAN) */
        _CONTROL,               /* 19 (EM)  */
        _CONTROL,               /* 1A (SUB) */
        _CONTROL,               /* 1B (ESC) */
        _CONTROL,               /* 1C (FS)  */
        _CONTROL,               /* 1D (GS)  */
        _CONTROL,               /* 1E (RS)  */
        _CONTROL,               /* 1F (US)  */
        _SPACE+_BLANK,          /* 20 SPACE */
        _PUNCT,                 /* 21 !     */
        _PUNCT,                 /* 22 "     */
        _PUNCT,                 /* 23 #     */
        _PUNCT,                 /* 24 $     */
        _PUNCT,                 /* 25 %     */
        _PUNCT,                 /* 26 &     */
        _PUNCT,                 /* 27 '     */
        _PUNCT,                 /* 28 (     */
        _PUNCT,                 /* 29 )     */
        _PUNCT,                 /* 2A *     */
        _PUNCT,                 /* 2B +     */
        _PUNCT,                 /* 2C ,     */
        _PUNCT,                 /* 2D -     */
        _PUNCT,                 /* 2E .     */
        _PUNCT,                 /* 2F /     */
        _DIGIT+_HEX,            /* 30 0     */
        _DIGIT+_HEX,            /* 31 1     */
        _DIGIT+_HEX,            /* 32 2     */
        _DIGIT+_HEX,            /* 33 3     */
        _DIGIT+_HEX,            /* 34 4     */
        _DIGIT+_HEX,            /* 35 5     */
        _DIGIT+_HEX,            /* 36 6     */
        _DIGIT+_HEX,            /* 37 7     */
        _DIGIT+_HEX,            /* 38 8     */
        _DIGIT+_HEX,            /* 39 9     */
        _PUNCT,                 /* 3A :     */
        _PUNCT,                 /* 3B ;     */
        _PUNCT,                 /* 3C <     */
        _PUNCT,                 /* 3D =     */
        _PUNCT,                 /* 3E >     */
        _PUNCT,                 /* 3F ?     */
        _PUNCT,                 /* 40 @     */
        _UPPER+_HEX,            /* 41 A     */
        _UPPER+_HEX,            /* 42 B     */
        _UPPER+_HEX,            /* 43 C     */
        _UPPER+_HEX,            /* 44 D     */
        _UPPER+_HEX,            /* 45 E     */
        _UPPER+_HEX,            /* 46 F     */
        _UPPER,                 /* 47 G     */
        _UPPER,                 /* 48 H     */
        _UPPER,                 /* 49 I     */
        _UPPER,                 /* 4A J     */
        _UPPER,                 /* 4B K     */
        _UPPER,                 /* 4C L     */
        _UPPER,                 /* 4D M     */
        _UPPER,                 /* 4E N     */
        _UPPER,                 /* 4F O     */
        _UPPER,                 /* 50 P     */
        _UPPER,                 /* 51 Q     */
        _UPPER,                 /* 52 R     */
        _UPPER,                 /* 53 S     */
        _UPPER,                 /* 54 T     */
        _UPPER,                 /* 55 U     */
        _UPPER,                 /* 56 V     */
        _UPPER,                 /* 57 W     */
        _UPPER,                 /* 58 X     */
        _UPPER,                 /* 59 Y     */
        _UPPER,                 /* 5A Z     */
        _PUNCT,                 /* 5B [     */
        _PUNCT,                 /* 5C \     */
        _PUNCT,                 /* 5D ]     */
        _PUNCT,                 /* 5E ^     */
        _PUNCT,                 /* 5F _     */
        _PUNCT,                 /* 60 `     */
        _LOWER+_HEX,            /* 61 a     */
        _LOWER+_HEX,            /* 62 b     */
        _LOWER+_HEX,            /* 63 c     */
        _LOWER+_HEX,            /* 64 d     */
        _LOWER+_HEX,            /* 65 e     */
        _LOWER+_HEX,            /* 66 f     */
        _LOWER,                 /* 67 g     */
        _LOWER,                 /* 68 h     */
        _LOWER,                 /* 69 i     */
        _LOWER,                 /* 6A j     */
        _LOWER,                 /* 6B k     */
        _LOWER,                 /* 6C l     */
        _LOWER,                 /* 6D m     */
        _LOWER,                 /* 6E n     */
        _LOWER,                 /* 6F o     */
        _LOWER,                 /* 70 p     */
        _LOWER,                 /* 71 q     */
        _LOWER,                 /* 72 r     */
        _LOWER,                 /* 73 s     */
        _LOWER,                 /* 74 t     */
        _LOWER,                 /* 75 u     */
        _LOWER,                 /* 76 v     */
        _LOWER,                 /* 77 w     */
        _LOWER,                 /* 78 x     */
        _LOWER,                 /* 79 y     */
        _LOWER,                 /* 7A z     */
        _PUNCT,                 /* 7B {     */
        _PUNCT,                 /* 7C |     */
        _PUNCT,                 /* 7D }     */
        _PUNCT,                 /* 7E ~     */
        _CONTROL,               /* 7F (DEL) */
		_PUNCT,					/* 80 Euro currency symbol */
		0,						/* 81 not used */
		_PUNCT,					/* 82 lower quote */
		_PUNCT,					/* 83 hooked f */
		_PUNCT,					/* 84 lower double quote */
		_PUNCT,					/* 85 ellipsis */
		_PUNCT,					/* 86 dagger */
		_PUNCT,					/* 87 double dagger */
		_PUNCT,					/* 88 circumflex */
		_PUNCT,					/* 89 per mille */
        _UPPER,                 /* 8A uppercase caron S */
		_PUNCT,					/* 8B open angular quote */
        _UPPER,                 /* 8C uppercase OE ligature */
		0,						/* 8D not used */
		0,						/* 8E not used */
		0,						/* 8F not used */
		0,						/* 90 not used */
		_PUNCT,					/* 91 open single quote */
		_PUNCT,					/* 92 close single quote */
		_PUNCT,					/* 93 open double quote */
		_PUNCT,					/* 94 close double quote */
		_PUNCT,					/* 95 bullet */
		_PUNCT,					/* 96 en dash */
		_PUNCT,					/* 97 em dash */
		_PUNCT,					/* 98 tilda */
		_PUNCT,					/* 99 trade mark */
        _LOWER,                 /* 9A lowercase caron S */
		_PUNCT,					/* 9B close angular bracket */
        _LOWER,                 /* 9C lowercase OE ligature */
		0,						/* 9D not used */
		0,						/* 9E not used */
        _UPPER,                 /* 9F uppercase diaresis Y */
		_SPACE+_BLANK,			/* A0 non-breaking space */
		_PUNCT,					/* A1 inverted exclamation */
		_PUNCT,					/* A2 cent sign */
		_PUNCT,					/* A3 British pound sign */
		_PUNCT,					/* A4 universal currency sign */
		_PUNCT,					/* A5 Japanese yen sign */
		_PUNCT,					/* A6 broken bar */
		_PUNCT,					/* A7 section */
		_PUNCT,					/* A8 diaresis */
		_PUNCT,					/* A9 copyright */
		_PUNCT,					/* AA feminine ordinal */
		_PUNCT,					/* AB open double angular quote */
		_PUNCT,					/* AC not */
		_PUNCT,					/* AD soft hyphen */
		_PUNCT,					/* AE registered */
		_PUNCT,					/* AF macron */
		_PUNCT,					/* B0 degree */
		_PUNCT,					/* B1 plus or minus */
		_PUNCT,					/* B2 superscript two */
		_PUNCT,					/* B3 superscript three */
		_PUNCT,					/* B4 acute */
		_PUNCT,					/* B5 micro sign */
		_PUNCT,					/* B6 pilcrow (paragraph) */
		_PUNCT,					/* B7 middle dot */
		_PUNCT,					/* B8 cedilla */
		_PUNCT,					/* B9 superscript one */
		_PUNCT,					/* BA masculine ordinal */
		_PUNCT,					/* BB close double angular quote */
		_PUNCT,					/* BC one quarter */
		_PUNCT,					/* BD one half */
		_PUNCT,					/* BE three quarters */
		_PUNCT,					/* BF inverted question */
        _UPPER,                 /* C0 uppercase grave A */
        _UPPER,                 /* C1 uppercase acute A */
        _UPPER,                 /* C2 uppercase circumflex A */
        _UPPER,                 /* C3 uppercase tilda A */
        _UPPER,                 /* C4 uppercase diaeresis A */
        _UPPER,                 /* C5 uppercase ring A */
        _UPPER,                 /* C6 uppercase AE ligature */
        _UPPER,                 /* C7 uppercase cedilla C */
        _UPPER,                 /* C8 uppercase grave E */
        _UPPER,                 /* C9 uppercase acute E */
        _UPPER,                 /* CA uppercase circumflex E */
        _UPPER,                 /* CB uppercase diaeresis E */
        _UPPER,                 /* CC uppercase grave I */
        _UPPER,                 /* CD uppercase acute I */
        _UPPER,                 /* CE uppercase circumflex I */
        _UPPER,                 /* CF uppercase diaeresis I */
        _UPPER,                 /* D0 uppercase ETH */
        _UPPER,                 /* D1 uppercase tilda N */
        _UPPER,                 /* D2 uppercase grave O */
        _UPPER,                 /* D3 uppercase acute O */
        _UPPER,                 /* D4 uppercase circumflex O */
        _UPPER,                 /* D5 uppercase tilda O */
        _UPPER,                 /* D6 uppercase diaeresis O */
        _PUNCT,                 /* D7 multiply */
        _UPPER,                 /* D8 uppercase stroke O */
        _UPPER,                 /* D9 uppercase grave U */
        _UPPER,                 /* DA uppercase acute U */
        _UPPER,                 /* DB uppercase circumflex U */
        _UPPER,                 /* DC uppercase diaeresis U */
        _UPPER,                 /* DD uppercase acute Y */
        _UPPER,                 /* DE uppercase THORN */
        _LOWER,                 /* DF esset */
        _LOWER,                 /* E0 lowercase grave a */
        _LOWER,                 /* E1 lowercase acute a */
        _LOWER,                 /* E2 lowercase circumflex a */
        _LOWER,                 /* E3 lowercase tilda a */
        _LOWER,                 /* E4 lowercase diaeresis a */
        _LOWER,                 /* E5 lowercase ring a */
        _LOWER,                 /* E6 lowercase ae ligature */
        _LOWER,                 /* E7 lowercase cedilla c */
        _LOWER,                 /* E8 lowercase grave e */
        _LOWER,                 /* E9 lowercase acute e */
        _LOWER,                 /* EA lowercase circumflex e */
        _LOWER,                 /* EB lowercase diaeresis e */
        _LOWER,                 /* EC lowercase grave i */
        _LOWER,                 /* ED lowercase acute i */
        _LOWER,                 /* EE lowercase circumflex i */
        _LOWER,                 /* EF lowercase diaeresis i */
        _LOWER,                 /* F0 lowercase eth */
        _LOWER,                 /* F1 lowercase tilda n */
        _LOWER,                 /* F2 lowercase grave o */
        _LOWER,                 /* F3 lowercase acute o */
        _LOWER,                 /* F4 lowercase circumflex o */
        _LOWER,                 /* F5 lowercase tilda o */
        _LOWER,                 /* F6 lowercase diaeresis o */
        _PUNCT,                 /* F7 divide */
        _LOWER,                 /* F8 lowercase stroke o */
        _LOWER,                 /* F9 lowercase grave u */
        _LOWER,                 /* FA lowercase acute u */
        _LOWER,                 /* FB lowercase circumflex u */
        _LOWER,                 /* FC lowercase diaeresis u */
        _LOWER,                 /* FD lowercase acute y */
        _LOWER,                 /* FE lowercase thorn */
        _LOWER					/* FF lowercase diaeresis y */
};

void strlower1252(unsigned char *s)
{
	for (; *s; s++)
		*s = tolower1252(*s);
}

void strupper1252(unsigned char *s)
{
	for (; *s; s++)
		*s = toupper1252(*s);
}

// Table of section of codepage 1252, for columns \x8x and \x9x

#define MAXTABLE 32

static const WCHAR UniTable[MAXTABLE] =
{L'\x20AC', // x80 European currency
 L'\x0000', // x81
 L'\x201A', // x82 open low quote
 L'\x0192', // x83 script f
 L'\x201E', // x84 open double low quotes
 L'\x2026', // x85 ...
 L'\x2020', // x86 dagger
 L'\x2021', // x87 double dagger
 L'\x02c6', // x88 circumflex
 L'\x2030', // x89 per mille
 L'\x0160', // x8A Uppercase Caron S
 L'\x2039', // x8B open angle quote
 L'\x0152', // x8C Uppercase OE ligature
 L'\x0000', // x8D
 L'\x0000', // x8E
 L'\x0000', // x8F
 L'\x0000', // x90
 L'\x2018', // x91 open single quote
 L'\x2019', // x92 close single quote
 L'\x201C', // x93 open double quotes
 L'\x201D', // x94 close double quotes
 L'\x2022', // x95 bullet
 L'\x2013', // x96 en dash
 L'\x2014', // x97 em dash
 L'\x02dc', // x98 tilda
 L'\x2122', // x99 trademark
 L'\x0161', // x9A lowercase caron s
 L'\x203A', // x9B close angle quote
 L'\x0153', // x9C lowercase oe ligature
 L'\x0000', // x9D
 L'\x0000', // x9E
 L'\x0178', // x9F Uppercase diaresis Y
};

// If successful, 1 is returned.
// If an undefined code is passed in, 0 is returned and *pwch is unchanged.
int CP1252ToUnicode(unsigned char ch, WCHAR *pwch)
{
	// If we are in column \x8x or \x9x use the table above.
	if ((ch & 0xE0) == 0x80)
	{
		WCHAR wch = UniTable[(int)ch - 0x80];
		if (wch)
			*pwch = wch;
		else
			return 0;
	}
	else
		*pwch = (WCHAR)ch;
	return 1;
}

// If successful, 1 is returned.
// If a unicode codepoint is passed in which is not supported in 1252,
// 0 is returned and *pch is unchanged.
int UnicodeToCP1252(WCHAR u, unsigned char *pch)
{
	int ch;

	if (!HIBYTE(u))
	{
		if ((u & 0xE0) == 0x80)
			return 0;
		*pch = LOBYTE(u);
		return 1;
	}

	for (ch = 0; ch < MAXTABLE; ch++)
	{
		if (UniTable[ch] == u)
		{
			*pch = (unsigned char)(0x80 + ch);
			return 1;
		}
	}

	return 0;
}

/******************************Public*Routine******************************\
* UnicodeToCP1252String
*
* Function to convert a Unicode STRING to a string in codepage 1252.
* WARNING:  This function does an ExternAlloc and returns the pointer.
* WARNIGN:  It is the caller's responsibility to free the memory.
*
* History:
* 04-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
unsigned char *UnicodeToCP1252String(WCHAR *wsz)
{
	int len;
	unsigned char *sz, *pch;

	if (!wsz || !*wsz)
		return NULL;

	len = wcslen(wsz);
	ASSERT(len > 0);
	sz = (unsigned char *) ExternAlloc((len+1)*sizeof(unsigned char));
	ASSERT(sz);
	if (!sz)
		return NULL;
	pch = sz;
	while (*wsz)
	{
		if (!UnicodeToCP1252(*wsz++, pch++))
		{
			ExternFree(sz);
			return NULL;
		}
	}
	*pch = 0;
	return sz;
}

/******************************Public*Routine******************************\
* CP1252StringToUnicode
*
* Function to convert a 1252 STRING to a unicode string
* Caller can pass in a preallocated buffer of length *piLen
* If the buffer is too small (or NULL), the function does an ExternRealloc()
* and changes the size in piLen. In all cases the function returns a pointer
* to the converted buffer
*
* History:
* June 2001 mrevow
\**************************************************************************/
WCHAR *CP1252StringToUnicode(unsigned char *psz, WCHAR *wsz, int *piLen)
{
	int		len;
	WCHAR	*pwch;

	if (!psz || !*psz)
		return NULL;

	len = strlen(psz);
	ASSERT(len > 0);
	
	// Extend the input buffer if necessary
	if (!wsz || len >= *piLen)
	{
		wsz = (WCHAR *) ExternRealloc(wsz, (len+1)*sizeof(*wsz));
		ASSERT(wsz);
		if (!wsz)
		{
			*piLen = 0;
			return NULL;
		}
		*piLen = len + 1;
	}

	pwch = wsz;
	while (*psz)
	{
		if (!CP1252ToUnicode(*psz++, pwch++))
		{
			ExternFree(wsz);
			return NULL;
		}
	}
	*pwch = 0;
	return wsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\errsys.c ===
/******************************Module*Header*******************************\
* Module Name: errsys.c
*
* This provides the output functions that log the debug output.  Don't
* stick any crap or dependencies in here so this can be put in any
* project without modification.  errsys.h errsys.c are an independent
* set of files for generic use anywhere.
*
* Created: 04-Oct-1995 16:17:00
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#if (defined(DBG) || defined(DBG) || defined(DEBUGINTERNAL))

#include <windows.h>

#if (defined(_CONSOLE_) || defined(_CONSOLE) || defined(CONSOLE))
#include <stdlib.h>
#include <stdio.h>
#else
#define sprintf wsprintf
#endif

#include "tchar.h"

/******************************Public*Routine******************************\
* HwxAssertFn
*
* Standard debug routine that ASSERT calls.
*
* History:
*  17-Feb-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int giDebugLevel = 0;  // Setting this to 1 makes the debug output get
                       // registered but the app won't stop running.
                       // Use the JUST_DEBUG_MSG macro at app init.

int HwxAssertFn(int iLine, char *pchFile, char *pchExp)
{
    TCHAR achBuffer[256];
    sprintf(achBuffer, TEXT("ASSERT %hs : %d : %hs\n"), pchFile, iLine, pchExp);

#if (defined(_CONSOLE_) || defined(_CONSOLE) || defined(CONSOLE))

    fprintf(stderr, achBuffer);

    if (giDebugLevel == 0)
    {
        exit(1);
    }

#else

    OutputDebugString(achBuffer);

    if (giDebugLevel == 0)
    {
        MessageBox(NULL, achBuffer, TEXT("ASSERT"), MB_OK | MB_APPLMODAL | MB_ICONSTOP);
    }

#endif

    return(1);
}

/******************************Public*Routine******************************\
* HwxWarning
*
* Print out diagnostic messages about abnormal conditions.  In windows mode
* it just sends the message to the debugger.
*
* History:
*  09-Oct-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int HwxWarning(int iLine, char *pchFile, char *pchExp)
{
    TCHAR achBuffer[256];
    sprintf(achBuffer, TEXT("WARNING %hs : %d : %hs\n"), pchFile, iLine, pchExp);

#if (defined(_CONSOLE_) || defined(_CONSOLE) || defined(CONSOLE))

    fprintf(stderr, achBuffer);

#else

    OutputDebugString(achBuffer);

#endif

    return(1);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\foldchar.c ===
// foldchar.c
// Angshuman Guha
// aguha
// July 24, 2000

#include "common.h"

/******************************Public*Routine******************************\
* IsValidStringLatin
*
* Function to
*
* History:
*  21-July-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsValidStringLatin(wchar_t *wsz, char **pszErrorMsg)
{
	char * const szUndefined = "undefined char x%04x";
	char * const szControl = "control char x%04x";
	char * const szAccent = "disembodied accent x%04x";
	static char szError[30];

	*pszErrorMsg = NULL;

	for (; *wsz; wsz++)
	{
		unsigned char c1252;
		
		if (!UnicodeToCP1252(*wsz, &c1252))
		{
			sprintf(szError, szUndefined, *wsz);
			*pszErrorMsg = szError;
			return FALSE;
		}
		if (iscntrl1252(c1252))
		{			
			sprintf(szError, szControl, *wsz);
			*pszErrorMsg = szError;
			return FALSE;
		}
		if (isundef1252(c1252))
		{
			sprintf(szError, szUndefined, *wsz);
			*pszErrorMsg = szError;
			return FALSE;
		}
		// LEFT FOR A RAINY DAY: can we make an isaccent1252()?
		// Need one for accented alphas, another for disembodied accents.
		// Do we want isaccute1252(), etc for each individual accent?
		// LEFT FOR A RAINY DAY: should we add backquote, tilde, and circumflex?
		if (strchr("", c1252))
		{
			sprintf(szError, szAccent, *wsz);
			*pszErrorMsg = szError;
			return FALSE;
		}
	}
	return TRUE;
}

/******************************Public*Routine******************************\
* FoldStringLatin
*
* Function to
*
* History:
*  21-July-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
static unsigned char LatinFoldTable[128] = {
	128, 129,  44, 131, 132, 133, 134, 135,  94, 137, 138,  60, 140, 141, 142,
	143, 144,  39,  39,  34,  34,  46,  45,  45, 126, 153, 154,  62, 156, 157,
	158, 159,  32, 161, 162, 163, 164, 165, 124, 167, 168, 169, 170, 171,  45,
	 45, 174, 175, 176, 177, 178, 179,  39, 181, 182,  46, 184, 185, 186, 187,
	188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202,
	203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,
	218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
	233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
	248, 249, 250, 251, 252, 253, 254, 255};

int FoldStringLatin(wchar_t *wszSrc, wchar_t *wszDst)
{
	wchar_t *t;

	if (!wszDst)
	{
		// we need to compute the size of the buffer required
		// 
		int x;

		t = wszSrc;
		x = 0;
		while (t = wcspbrk(t, L""))  // TM or ... or 1/4 or 1/2 or 3/4
		{
			if (*t == L'') // 153 TM
				x++;
			else
				x += 2;
			++t;
		}
		return wcslen(wszSrc) + x + 1;
	}

	// let's do it
	t = wszDst;
	for (; *wszSrc; )
	{
		if (*wszSrc < 128)
			*wszDst++ = *wszSrc++;
		else
		{
			unsigned char c1252;

			if (!UnicodeToCP1252(*wszSrc++, &c1252))
				*wszDst = L' ';  // this should not happen if IsValidStringLatin has already been called
			else if (127 < c1252)
				CP1252ToUnicode(LatinFoldTable[c1252 - 128], wszDst);

			if (*wszDst == L'') // 153 TM
			{
				*wszDst++ = L'T';
				*wszDst++ = L'M';
			}
			else if (*wszDst == L'') // 133 ...
			{
				*wszDst++ = L'.';
				*wszDst++ = L'.';
				*wszDst++ = L'.';
			}
			else if (*wszDst == L'')
			{
				*wszDst++ = L'1';
				*wszDst++ = L'/';
				*wszDst++ = L'4';
			}
			else if (*wszDst == L'')
			{
				*wszDst++ = L'1';
				*wszDst++ = L'/';
				*wszDst++ = L'2';
			}
			else if (*wszDst == L'')
			{
				*wszDst++ = L'3';
				*wszDst++ = L'/';
				*wszDst++ = L'4';
			}
			else
				wszDst++;
		}
	}
	*wszDst++ = 0;
	return wszDst - t;
}

/******************************Public*Routine******************************\
* IsValidStringEastAsian
*
* Function to
*
* History:
*  21-July-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
BOOL IsValidStringEastAsian(wchar_t *wsz, char **pszErrorMsg)
{
	*pszErrorMsg = NULL;
	return TRUE;
}

/******************************Public*Routine******************************\
* FoldStringEastAsian
*
* Function to
*
* History:
*  21-July-2000 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int FoldStringEastAsian(wchar_t *wszSrc, wchar_t *wszDst)
{
	int retVal = wcslen(wszSrc) + 1;

	if (!wszDst)
		return retVal;

	for (; *wszSrc; )
	{
		int count;
		WORD wFolded;

		// Fold compatibility zone to normal.
		count = FoldStringW(MAP_FOLDCZONE, wszSrc++, 1, &wFolded, 1);
		if (count == 0)
			wFolded = 0xFFFD;
		else if (wFolded == 0xFF3C) // work around bug in FoldString
			wFolded = L'\\';
		else if (wFolded == 0x3000)
			wFolded = 0x0020;
		*wszDst++ = wFolded;
	}
	*wszDst = 0;
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\frame.c ===
// frame.c

#include "common.h"
#include <limits.h>

/******************************Public*Routine******************************\
* NewFRAME
*
* Allocates a FRAME object out of the heap.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

FRAME *NewFRAME(void)
{
// We know ExternMalloc returns zeroed out memory

    FRAME *self = ExternAlloc(sizeof(FRAME));

	if (self != (FRAME *) NULL)
	{
		memset(self, '\0', sizeof(FRAME));
	    self->rect.left = -1;					// uninitialized rectangle
	}

	return self;
}

/******************************Public*Routine******************************\
* DestroyFRAME
*
* Frees a FRAME object
* Effects:
*
* Warnings:
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void DestroyFRAME(FRAME *self)
{
	if (!self) return;
	if (self->pvData) ExternFree(self->pvData);
	if (self->rgrawxy) ExternFree(self->rgrawxy); 
	if (self->rgsmoothxy) ExternFree(self->rgsmoothxy);

	ExternFree(self);
}

/******************************Public*Routine******************************\
* RectFRAME
*
* Returns the bounding rectangle of the frame, inclusive top left,
* exclusive bottom right.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

RECT *RectFRAME(FRAME *self)
{
	XY	   *xy, *xyMax;
	RECT   *rect;

	rect = &(self->rect);

	if (rect->left == -1) // Uninitialized
	{
		xy = self->rgrawxy;
		xyMax = xy + CrawxyFRAME(self);

		rect->left = rect->right = xy->x;
		rect->top = rect->bottom = xy->y;

		for (++xy; xy < xyMax; xy++)
		{
			if (xy->x < rect->left)
				rect->left = xy->x;
			else if (xy->x > rect->right)
				rect->right = xy->x;

			if (xy->y < rect->top)
				rect->top = xy->y;
			else if (xy->y > rect->bottom)
				rect->bottom = xy->y;
		}

        rect->right++;      // Make it lower right exclusive.
		rect->bottom++;
	}

	return(rect);
}
// Check for under/over flow conditions when constructing a + b
// Return FALSE if an under or overflow will occur TRUE if is safe
BOOL IsSafeForAdd(int a, int b)
{
	BOOL	bRet;

	if (b < 0)
	{
		bRet = ( (INT_MIN - b) < a )? TRUE : FALSE;
	}
	else
	{
		bRet = ( (INT_MAX - b) > a )? TRUE : FALSE;
	}
	return bRet;
}
// Check for under/over flow conditions when constructing a * b
// Return FALSE if an under or overflow will occur TRUE if is safe
BOOL IsSafeForMult(int a, int b)
{
	BOOL	bRet;

	if (0 == b)
	{
		return TRUE;
	}

	// Do check in absolute domain
	a = (a < 0) ? -a : a;
	b = (b < 0) ? -b : b;

	bRet = ( (INT_MAX / b) > a )? TRUE : FALSE;

	return bRet;
}

// Translate a frame by dx & dy
BOOL TranslateFrame (FRAME *pFrame, int dx, int dy)
{
	UINT	i;

	// Check for Overflow
	RectFRAME(pFrame);
	if (   FALSE == IsSafeForAdd(pFrame->rect.left, dx)
		|| FALSE == IsSafeForAdd(pFrame->rect.right, dx)
		|| FALSE == IsSafeForAdd(pFrame->rect.top, dy)
		|| FALSE == IsSafeForAdd(pFrame->rect.bottom, dy) )
	{
		return FALSE;
	}

	for (i = 0; i < pFrame->info.cPnt; i++)
	{
		pFrame->rgrawxy[i].x	+=	dx;
		pFrame->rgrawxy[i].y	+=	dy;
	}

	// Adjust the Bounding rect if it has been computed
	if ( !(pFrame->rect.left == -1 && pFrame->rect.right == 0 && pFrame->rect.top == 0 && pFrame->rect.bottom == 0))
	{
		pFrame->rect.left	+=	dx;
		pFrame->rect.right	+=	dx;

		pFrame->rect.top	+=	dy;
		pFrame->rect.bottom	+=	dy;

	}

	return TRUE;
}

// Clones a frame
FRAME *copyFRAME(FRAME *pFrame)
{
    FRAME *pNew = (FRAME *)ExternAlloc(sizeof(FRAME));
	ASSERT(pNew);
	if (!pNew)
		return NULL;

	pNew->pvData = pFrame->pvData;
	pNew->info = pFrame->info;
	pNew->rect = pFrame->rect;
	pNew->iframe = pFrame->iframe;

	if (pFrame->rgrawxy)
	{
		pNew->rgrawxy = (POINT *)ExternAlloc(pFrame->info.cPnt * sizeof(POINT));
		ASSERT(pNew->rgrawxy);
		if (!pNew->rgrawxy)
		{
			ExternFree(pNew);
			return NULL;
		}
		memcpy(pNew->rgrawxy, pFrame->rgrawxy, pFrame->info.cPnt * sizeof(POINT));
	}
	else
		pNew->rgrawxy = NULL;

	pNew->csmoothxy = pFrame->csmoothxy;
	if (pFrame->rgsmoothxy)
	{
		pNew->rgsmoothxy = (POINT *)ExternAlloc(pFrame->csmoothxy * sizeof(POINT));
		ASSERT(pNew->rgsmoothxy);
		if (!pNew->rgsmoothxy)
		{
			if (pNew->rgrawxy)
				ExternFree(pNew->rgrawxy);

			ExternFree(pNew);
			return NULL;
		}
		memcpy(pNew->rgsmoothxy, pFrame->rgsmoothxy, pFrame->csmoothxy * sizeof(POINT));
	}
	else
		pNew->rgsmoothxy = NULL;

	return pNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\glyphtrn.c ===
/******************************Module*Header*******************************\
* Module Name: glyphtrn.c
*
* Glyph functions only needed during training or tuning.
*
* Created: 13-Feb-1997 15:14:55
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "common.h"

GLYPH *MergeGlyphGLYPH(GLYPH *self, GLYPH *merge)
{
	GLYPH *result, *source, *glyph;

	ASSERT(self && self->frame && self != merge);
	ASSERT(merge == 0 || self->frame != merge->frame);

	result = NewGLYPH();
	glyph   = result;

	for (source = self; source; source = source->next)
	{
		glyph->next = NewGLYPH();
		glyph = glyph->next;
		glyph->frame = source->frame;
	}

	for (source = merge; source; source = source->next)
	{
		glyph->next = NewGLYPH();
		glyph = glyph->next;
		glyph->frame = source->frame;
	}

	glyph  = result;			// dummy node heading list
	result = glyph->next;		// first node in merged glyph
	glyph->next = 0;			// terminate dummy
	DestroyGLYPH(glyph);		// free dummy

	return result;
}

GLYPH *GlyphFromHpendata(HPENDATA hpendata)
{
	int			istroke = 0;
	LPPENDATA	lppendata;
	STROKEINFO	strokeinfo;
	GLYPH	   *glyph = NULL;
	XY		   *rgrawxy = NULL;
	void	   *rgrawoem = NULL;
	FRAME	   *frame;

	lppendata = BeginEnumStrokes(hpendata);

	ASSERT(lppendata != NULL);

	while (GetPenDataStroke(lppendata, istroke, (POINT **) &rgrawxy,  (void **) &rgrawoem, &strokeinfo))
	{
		if ((strokeinfo.wPdk & PDK_DOWN))       // ignore up strokes
		{
			if (!glyph)
				glyph = NewGLYPH();

			frame = NewFRAME();

			frame->info = strokeinfo;
			frame->info.wPdk |= PDK_TRANSITION;           // its a complete stroke
			frame->rgrawxy = (XY *) ExternAlloc((unsigned) ((long) strokeinfo.cPnt * sizeof(XY)));
			memmove(frame->rgrawxy, rgrawxy, strokeinfo.cPnt * sizeof(XY));

			// add stroke to glyph
			AddFrameGLYPH(glyph, frame);
		}
		istroke++;
	}

	EndEnumStrokes(hpendata);
	return(glyph);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\glyph.c ===
// glyph.c

#include "common.h"

/******************************Public*Routine******************************\
* NewGLYPH
*
* Creates a GLYPH from the heap.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

GLYPH *NewGLYPH(void)
{
    GLYPH *self = (GLYPH *) ExternAlloc(sizeof(GLYPH));

	if (self != (GLYPH *) NULL)
		memset(self, '\0', sizeof(GLYPH));

    return self;
}

/******************************Public*Routine******************************\
* DestroyGLYPH
*
* Frees a GLYPH.  Note this doesn't free the frames allocated as they
* may belong to many glyphs, especially in free input mode where each
* frame is put in all possible glyphs that could be constructed with it.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void DestroyGLYPH(GLYPH *glyph)
{
	GLYPH *glyphNext;


	// Note the frames are destroyed somewhere else !

	while (glyph)
	{
		glyphNext = glyph->next;

		ExternFree(glyph);

		glyph = glyphNext;
	}
}

BOOL AddFrameGLYPH(GLYPH *self, FRAME *frame)
{
    GLYPH *glyph;

    ASSERT(self);
	if (!self)
	{
		return FALSE;
	}

    for (glyph = self; glyph->next; glyph = glyph->next)
    {
        ;
    }

    if (glyph->frame)
    {
        if ((glyph->next = NewGLYPH()) == (GLYPH *) NULL)
			return FALSE;

        glyph = glyph->next;
        glyph->next = 0;
    }

    glyph->frame = frame;

	return TRUE;
}

void DestroyFramesGLYPH(GLYPH *self)
{
   GLYPH *glyph;

   ASSERT(self);

    for (glyph = self; glyph; glyph = glyph->next)
    {
        DestroyFRAME(glyph->frame);
    }
}

int CframeGLYPH(GLYPH *self)
{
    GLYPH *glyph;
    int     cframe = 0;

    for (glyph = self; glyph; glyph = glyph->next)
      if ((glyph->frame) && (IsVisibleFRAME(glyph->frame)))
         ++cframe;

    return cframe;
}

FRAME *FrameAtGLYPH(GLYPH *self, int iframe)
{
	GLYPH *glyph;

	ASSERT(iframe >= 0);
	ASSERT(self && self->frame);

	for (glyph = self; glyph && iframe; glyph = glyph->next)
		if (glyph->frame && IsVisibleFRAME(glyph->frame))
			--iframe;

	for (; glyph && (NULL==glyph->frame || !IsVisibleFRAME(glyph->frame)); glyph = glyph->next);

	ASSERT(glyph == 0 || IsVisibleFRAME(glyph->frame));

	return glyph ? glyph->frame : (FRAME *) NULL;
}


/******************************Public*Routine******************************\
* GetRectGLYPH
*
* Returns the inclusive top left / exclusive bottom right bounding
* rectangle of the visible points in the glyph.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

void GetRectGLYPH(GLYPH *self, LPRECT rectUnion)
{
    RECT     *rect;
    GLYPH    *glyph;

	if (!rectUnion)
	{
		return;
	}
    // Get to first visible glyph.

    for (glyph = self; glyph; glyph = glyph->next)
    {
       if (glyph->frame && IsVisibleFRAME(glyph->frame))
          break;
    }

    // Set the rect initially to the bounding rect
    // of the first frame.

	if (!glyph)
	{
		memset(rectUnion, 0, sizeof(*rectUnion));
		return;
	}

    *rectUnion = *RectFRAME(glyph->frame);

    // Now "or" in the rest of the rectangles
    // for the visible frames.

    for (glyph = glyph->next; glyph; glyph = glyph->next)
    {
        if (IsVisibleFRAME(glyph->frame))
        {
            rect = RectFRAME(glyph->frame);
            rectUnion->left   = min(rectUnion->left,  rect->left);
            rectUnion->right  = max(rectUnion->right, rect->right);
            rectUnion->top    = min(rectUnion->top,   rect->top);
            rectUnion->bottom = max(rectUnion->bottom, rect->bottom);
        }
    }
}

XY *SaveRawxyGLYPH(GLYPH *self)
{
	int cXY = 0;
	GLYPH *glyph;
	XY *xy, *pXY;

	glyph = self;
	while (glyph)
	{
		cXY += CrawxyFRAME(glyph->frame);
		glyph = glyph->next;
	}

	if (cXY <= 0)
		return NULL;

	pXY = xy = (XY *) ExternAlloc(cXY * sizeof(XY));
	if (!xy)
		return NULL;

	glyph = self;
	while (glyph)
	{
		cXY = CrawxyFRAME(glyph->frame);
		memcpy(pXY, RgrawxyFRAME(glyph->frame), cXY*sizeof(XY));
		pXY += cXY;
		glyph = glyph->next;
	}

	return xy;
}

void RestoreRawxyGLYPH(GLYPH *self, XY *xy)
{
	while (self)
	{
		int cXY = CrawxyFRAME(self->frame);
		memcpy(RgrawxyFRAME(self->frame), xy, cXY*sizeof(XY));
		xy += cXY;
		self = self->next;
	}
}

// Translate a Glyph by dx & dy
BOOL TranslateGlyph (GLYPH *pGlyph, int dx, int dy)
{
	BOOL		bRet = TRUE;

	for (; bRet && pGlyph; pGlyph = pGlyph->next)
	{
		FRAME	*pFrame	=	pGlyph->frame;
		
		bRet = TranslateFrame (pFrame, dx, dy);
	}

	return bRet;
}

// Translate a Glyph by dx & dy
BOOL TranslateGuide (GUIDE *pGuide, int dx, int dy)
{
	BOOL		bRet = TRUE;

	// Check for overflows
	if (   FALSE == IsSafeForAdd(pGuide->xOrigin, dx)
		|| FALSE == IsSafeForAdd(pGuide->xOrigin, dx))
	{
		return FALSE;
	}

	pGuide->xOrigin += dx;
	pGuide->yOrigin += dy;

	return TRUE;
}

// Clones a Glyph
GLYPH *CopyGlyph (GLYPH *pGlyph)
{
	GLYPH	*pgl, *pglNew;

	pglNew	=	NewGLYPH ();
	if (!pglNew)
		return NULL;

	for (pgl = pGlyph; pgl; pgl = pgl->next)
		AddFrameGLYPH (pglNew, copyFRAME (pgl->frame));

	return pglNew;
}

// Normalize ink function called when a guide is available
// Works on all the ink in the glyph. Also Translates the guide
BOOL GuideNormalizeInk (GUIDE *pGuide, GLYPH *pGlyph)
{
	int base = 2*pGuide->cyBox/3;
	int shift = 0;

	ASSERT(0 < base);

	while (BASELIMIT < base)
	{
		shift++;
		base >>= 1;
	}
	while (base < (BASELIMIT / 2))
	{
		shift--;
		base <<= 1;
	}

	if (!shift)
		return TRUE;

	for (; pGlyph; pGlyph = pGlyph->next)
	{
		FRAME *pFrame = pGlyph->frame;
		POINT *pPt = RgrawxyFRAME(pFrame);
		int cPt = CrawxyFRAME(pFrame);

		// Prepare to check for Over or Under Flows
		// Using the BB of the frame
		RectFRAME(pFrame);

		if (0 < shift)
		{
			if (   FALSE == IsSafeForMult(pFrame->rect.left, 1 >> shift)
				|| FALSE == IsSafeForMult(pFrame->rect.right, 1 >> shift)
				|| FALSE == IsSafeForMult(pFrame->rect.bottom, 1 >> shift)
				|| FALSE == IsSafeForMult(pFrame->rect.top, 1 >> shift) )
			{
				return FALSE;
			}

			for (; cPt; cPt--, pPt++)
			{
				pPt->x >>= shift;
				pPt->y >>= shift;
			}
			if (pFrame->rect.left != -1)
			{
				pFrame->rect.left >>= shift;
				pFrame->rect.top >>= shift;

				// Ensure retain exclusivity of bottom and right 
				// by shifting max value and adding 1
				ASSERT(pFrame->rect.right > 0);
				pFrame->rect.right = ((pFrame->rect.right - 1) >> shift);
				if (FALSE == IsSafeForAdd(pFrame->rect.right, 1))
				{
					return FALSE;
				}
				pFrame->rect.right += 1;

				ASSERT(pFrame->rect.bottom > 0);
				pFrame->rect.bottom = ((pFrame->rect.bottom - 1) >> shift);
				if (FALSE == IsSafeForAdd(pFrame->rect.bottom, 1))
				{
					return FALSE;
				}
				pFrame->rect.bottom += 1;
			}
		}
		else
		{
			// Division will always be safe from over/under flows
			for (; cPt; cPt--, pPt++)
			{
				pPt->x <<= -shift;
				pPt->y <<= -shift;
			}
			if (pFrame->rect.left != -1)
			{
				pFrame->rect.left <<= -shift;
				pFrame->rect.top <<= -shift;

				// Ensure retain exclusivity of bottom and right 
				// by shifting max value and adding 1
				ASSERT(pFrame->rect.right > 0);
				pFrame->rect.right = ( (pFrame->rect.right - 1) << -shift) + 1;
				ASSERT(pFrame->rect.bottom > 0);
				pFrame->rect.bottom = ( (pFrame->rect.bottom - 1) << -shift) + 1;
			}
		}

		ASSERT(!(pFrame->pvData));
		ASSERT(!(pFrame->csmoothxy));
		ASSERT(!(pFrame->rgsmoothxy));
	}

	if (0 < shift)
	{
		if (   FALSE == IsSafeForMult(pGuide->yOrigin, 1 >> shift)
			|| FALSE == IsSafeForMult(pGuide->xOrigin, 1 >> shift)
			|| FALSE == IsSafeForMult(pGuide->cyBox, 1 >> shift)
			|| FALSE == IsSafeForMult(pGuide->cxBox, 1 >> shift)
			|| FALSE == IsSafeForMult(pGuide->cyBase, 1 >> shift)
			|| FALSE == IsSafeForMult(pGuide->cxBase, 1 >> shift)
			|| FALSE == IsSafeForMult(pGuide->cyMid, 1 >> shift) )
		{
			return FALSE;
		}

		pGuide->yOrigin >>= shift;
		pGuide->xOrigin >>= shift;
		pGuide->cyBox >>= shift;
		pGuide->cxBox >>= shift;
		pGuide->cyBase >>= shift;
		pGuide->cxBase >>= shift;
		pGuide->cyMid >>= shift;
	}
	else
	{
		pGuide->yOrigin <<= -shift;
		pGuide->xOrigin <<= -shift;
		pGuide->cyBox <<= -shift;
		pGuide->cxBox <<= -shift;
		pGuide->cyBase <<= -shift;
		pGuide->cxBase <<= -shift;
		pGuide->cyMid <<= -shift;
	}

	return TRUE;
}

// Scales based on yDev of the glyph
// Used for ink which does not have aguide
BOOL NormalizeInk(GLYPH *pGlyph, int yDev)
{
	int base	=	max (1, yDev * 8);

	if ((BASELIMIT / base) > MAX_SCALE)
		base	=	BASELIMIT / MAX_SCALE;

	for (; pGlyph; pGlyph = pGlyph->next)
	{
		FRAME *pFrame = pGlyph->frame;
		POINT *pPt = RgrawxyFRAME(pFrame);
		int cPt = CrawxyFRAME(pFrame);
			
		// Check for Over or Under Flows
		// Using the BB of the frame
		RectFRAME(pFrame);
		if (   FALSE == IsSafeForMult(pFrame->rect.left - 1, BASELIMIT)
			|| FALSE == IsSafeForMult(pFrame->rect.right - 1, BASELIMIT)
			|| FALSE == IsSafeForMult(pFrame->rect.bottom - 1, BASELIMIT)
			|| FALSE == IsSafeForMult(pFrame->rect.top - 1, BASELIMIT) )
		{
			return FALSE;
		}

		for (; cPt; cPt--, pPt++)
		{
			pPt->x =	(pPt->x * BASELIMIT / base);
			pPt->y =	(pPt->y * BASELIMIT / base);
		}

		if (pFrame->rect.left != -1)
		{
			pFrame->rect.left	=	(pFrame->rect.left * BASELIMIT / base);
			pFrame->rect.top	=	(pFrame->rect.top * BASELIMIT / base);

			// Ensure retain exclusivity of bottom and right 
			// by scaling max value and adding 1
			ASSERT(pFrame->rect.right > 0);
			pFrame->rect.right = ( (pFrame->rect.right - 1) * BASELIMIT / base);
			if (FALSE == IsSafeForAdd(pFrame->rect.right, 1))
			{
				return FALSE;
			}
			pFrame->rect.right += 1;

			ASSERT(pFrame->rect.bottom > 0);
			pFrame->rect.bottom = ( (pFrame->rect.bottom - 1) * BASELIMIT / base);
			if (FALSE == IsSafeForAdd(pFrame->rect.bottom, 1))
			{
				return FALSE;
			}
			pFrame->rect.bottom += 1;

		}
	}

	return TRUE;
}


// checks for -ve ink and eliminates by trnslation
// Adjusts the guide (if one is supplied)
BOOL CheckInkBounds (GLYPH *pGlyph, GUIDE *pGuide)
{
	RECT	r;
	BOOL	bRet = TRUE;

	GetRectGLYPH (pGlyph, &r);

	if (pGuide)
	{
		if (r.left < 0 || r.top < 0 || pGuide->xOrigin < 0 || pGuide->yOrigin < 0)
		{
			int		xOff, yOff;

			xOff = min(r.left, pGuide->xOrigin );
			yOff = min(r.top, pGuide->yOrigin );

			xOff = min(xOff, 0);
			yOff = min(yOff, 0);

			if (   FALSE == TranslateGlyph (pGlyph, -xOff, -yOff)
				|| FALSE == TranslateGuide (pGuide, -xOff, -yOff) )
			{
				bRet = FALSE;
			}
		}
	}
	else
	{
		if (r.left < 0 || r.top < 0)
		{
			int		xOff, yOff;

			xOff = min (r.left, 0);
			yOff = min (r.top, 0 );

			bRet = TranslateGlyph (pGlyph, -xOff, -yOff);
		}
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\gesturep.c ===
#include "common.h"
#include "recdefs.h"
#include "gesturep.h"

typedef struct {
	char *szName;
	int iID;
} GESTURE_NAME_ID;

const GESTURE_NAME_ID gaGestureNameID[] = {
    {"gesture-arrow-down",               GESTURE_ARROW_DOWN            },
    {"gesture-arrow-left",               GESTURE_ARROW_LEFT            },
    {"gesture-arrow-right",              GESTURE_ARROW_RIGHT           },
    {"gesture-arrow-up",                 GESTURE_ARROW_UP              },
    {"gesture-asterisk",                 GESTURE_ASTERISK              },
    {"gesture-brace-left",               GESTURE_BRACE_LEFT            },
    {"gesture-brace-over",               GESTURE_BRACE_OVER            },
    {"gesture-brace-right",              GESTURE_BRACE_RIGHT           },
    {"gesture-brace-under",              GESTURE_BRACE_UNDER           },
    {"gesture-bracket-left",             GESTURE_BRACKET_LEFT          },
    {"gesture-bracket-over",             GESTURE_BRACKET_OVER          },
    {"gesture-bracket-right",            GESTURE_BRACKET_RIGHT         },
    {"gesture-bracket-under",            GESTURE_BRACKET_UNDER         },
    {"gesture-bullet",                   GESTURE_BULLET                },
    {"gesture-bullet-cross",             GESTURE_BULLET_CROSS          },
    {"gesture-check",                    GESTURE_CHECK                 },
    {"gesture-chevron-down",             GESTURE_CHEVRON_DOWN          },
    {"gesture-chevron-left",             GESTURE_CHEVRON_LEFT          },
    {"gesture-chevron-right",            GESTURE_CHEVRON_RIGHT         },
    {"gesture-chevron-up",               GESTURE_CHEVRON_UP            },
    {"gesture-circle",                   GESTURE_CIRCLE                },
    {"gesture-circle-circle",            GESTURE_CIRCLE_CIRCLE         },
    {"gesture-circle-cross",             GESTURE_CIRCLE_CROSS          },
    {"gesture-circle-line-horz",         GESTURE_CIRCLE_LINE_HORZ      },
    {"gesture-circle-line-vert",         GESTURE_CIRCLE_LINE_VERT      },
    {"gesture-circle-tap",               GESTURE_CIRCLE_TAP            },
    {"gesture-closeup",                  GESTURE_CLOSEUP               },
    {"gesture-cross",                    GESTURE_CROSS                 },
    {"gesture-curlicue",                 GESTURE_CURLICUE              },
    {"gesture-diagonal-leftdown",        GESTURE_DIAGONAL_LEFTDOWN     },
    {"gesture-diagonal-leftup",          GESTURE_DIAGONAL_LEFTUP       },
    {"gesture-diagonal-rightdown",       GESTURE_DIAGONAL_RIGHTDOWN    },
    {"gesture-diagonal-rightup",         GESTURE_DIAGONAL_RIGHTUP      },
    {"gesture-digit-0",                  GESTURE_DIGIT_0               },
    {"gesture-digit-1",                  GESTURE_DIGIT_1               },
    {"gesture-digit-2",                  GESTURE_DIGIT_2               },
    {"gesture-digit-3",                  GESTURE_DIGIT_3               },
    {"gesture-digit-4",                  GESTURE_DIGIT_4               },
    {"gesture-digit-5",                  GESTURE_DIGIT_5               },
    {"gesture-digit-6",                  GESTURE_DIGIT_6               },
    {"gesture-digit-7",                  GESTURE_DIGIT_7               },
    {"gesture-digit-8",                  GESTURE_DIGIT_8               },
    {"gesture-digit-9",                  GESTURE_DIGIT_9               },
    {"gesture-dollar",                   GESTURE_DOLLAR                },
    {"gesture-double-arrow-down",        GESTURE_DOUBLE_ARROW_DOWN     },
    {"gesture-double-arrow-left",        GESTURE_DOUBLE_ARROW_LEFT     },
    {"gesture-double-arrow-right",       GESTURE_DOUBLE_ARROW_RIGHT    },
    {"gesture-double-arrow-up",          GESTURE_DOUBLE_ARROW_UP       },
    {"gesture-double-circle",            GESTURE_DOUBLE_CIRCLE         },
	{"gesture-double-curlicue",          GESTURE_DOUBLE_CURLICUE       },
    {"gesture-double-down",              GESTURE_DOUBLE_DOWN           },
    {"gesture-double-left",              GESTURE_DOUBLE_LEFT           },
    {"gesture-double-right",             GESTURE_DOUBLE_RIGHT          },
    {"gesture-double-tap",               GESTURE_DOUBLE_TAP            },
    {"gesture-double-up",                GESTURE_DOUBLE_UP             },
    {"gesture-down",                     GESTURE_DOWN                  },
    {"gesture-down-arrow-left",          GESTURE_DOWN_ARROW_LEFT       },
    {"gesture-down-arrow-right",         GESTURE_DOWN_ARROW_RIGHT      },
    {"gesture-down-left",                GESTURE_DOWN_LEFT             },
    {"gesture-down-left-long",           GESTURE_DOWN_LEFT_LONG        },
    {"gesture-down-right",               GESTURE_DOWN_RIGHT            },
    {"gesture-down-right-long",          GESTURE_DOWN_RIGHT_LONG       },
    {"gesture-down-up",                  GESTURE_DOWN_UP               },
    {"gesture-exclamation",              GESTURE_EXCLAMATION           },
    {"gesture-infinity",                 GESTURE_INFINITY              },
    {"gesture-left",                     GESTURE_LEFT                  },
    {"gesture-left-arrow-down",          GESTURE_LEFT_ARROW_DOWN       },
    {"gesture-left-arrow-up",            GESTURE_LEFT_ARROW_UP         },
    {"gesture-left-down",                GESTURE_LEFT_DOWN             },
    {"gesture-left-right",               GESTURE_LEFT_RIGHT            },
    {"gesture-left-up",                  GESTURE_LEFT_UP               },
    {"gesture-letter-A",                 GESTURE_LETTER_A              },
    {"gesture-letter-B",                 GESTURE_LETTER_B              },
    {"gesture-letter-C",                 GESTURE_LETTER_C              },
    {"gesture-letter-D",                 GESTURE_LETTER_D              },
    {"gesture-letter-E",                 GESTURE_LETTER_E              },
    {"gesture-letter-F",                 GESTURE_LETTER_F              },
    {"gesture-letter-G",                 GESTURE_LETTER_G              },
    {"gesture-letter-H",                 GESTURE_LETTER_H              },
    {"gesture-letter-I",                 GESTURE_LETTER_I              },
    {"gesture-letter-J",                 GESTURE_LETTER_J              },
    {"gesture-letter-K",                 GESTURE_LETTER_K              },
    {"gesture-letter-L",                 GESTURE_LETTER_L              },
    {"gesture-letter-M",                 GESTURE_LETTER_M              },
    {"gesture-letter-N",                 GESTURE_LETTER_N              },
    {"gesture-letter-O",                 GESTURE_LETTER_O              },
    {"gesture-letter-P",                 GESTURE_LETTER_P              },
    {"gesture-letter-Q",                 GESTURE_LETTER_Q              },
    {"gesture-letter-R",                 GESTURE_LETTER_R              },
    {"gesture-letter-S",                 GESTURE_LETTER_S              },
    {"gesture-letter-T",                 GESTURE_LETTER_T              },
    {"gesture-letter-U",                 GESTURE_LETTER_U              },
    {"gesture-letter-V",                 GESTURE_LETTER_V              },
    {"gesture-letter-W",                 GESTURE_LETTER_W              },
    {"gesture-letter-X",                 GESTURE_LETTER_X              },
    {"gesture-letter-Y",                 GESTURE_LETTER_Y              },
    {"gesture-letter-Z",                 GESTURE_LETTER_Z              },
    {"gesture-null",                     GESTURE_NULL                  },
    {"gesture-openup",                   GESTURE_OPENUP                },
    {"gesture-paragraph",                GESTURE_PARAGRAPH             },
    {"gesture-plus",                     GESTURE_PLUS                  },
    {"gesture-quad-tap",                 GESTURE_QUAD_TAP              },
    {"gesture-question",                 GESTURE_QUESTION              },
    {"gesture-rectangle",                GESTURE_RECTANGLE             },
    {"gesture-right",                    GESTURE_RIGHT                 },
    {"gesture-right-arrow-down",         GESTURE_RIGHT_ARROW_DOWN      },
    {"gesture-right-arrow-up",           GESTURE_RIGHT_ARROW_UP        },
    {"gesture-right-down",               GESTURE_RIGHT_DOWN            },
    {"gesture-right-left",               GESTURE_RIGHT_LEFT            },
    {"gesture-right-up",                 GESTURE_RIGHT_UP              },
    {"gesture-scratchout",               GESTURE_SCRATCHOUT            },
    {"gesture-section",                  GESTURE_SECTION               },
	{"gesture-semicircle-left",          GESTURE_SEMICIRCLE_LEFT       },
	{"gesture-semicircle-right",         GESTURE_SEMICIRCLE_RIGHT      },
    {"gesture-sharp",                    GESTURE_SHARP                 },
    {"gesture-square",                   GESTURE_SQUARE                },
    {"gesture-squiggle",                 GESTURE_SQUIGGLE              },
    {"gesture-star",                     GESTURE_STAR                  },
    {"gesture-swap",                     GESTURE_SWAP                  },
    {"gesture-tap",                      GESTURE_TAP                   },
    {"gesture-triangle",                 GESTURE_TRIANGLE              },
    {"gesture-triple-down",              GESTURE_TRIPLE_DOWN           },
    {"gesture-triple-left",              GESTURE_TRIPLE_LEFT           },
    {"gesture-triple-right",             GESTURE_TRIPLE_RIGHT          },
    {"gesture-triple-tap",               GESTURE_TRIPLE_TAP            },
    {"gesture-triple-up",                GESTURE_TRIPLE_UP             },
    {"gesture-up",                       GESTURE_UP                    },
    {"gesture-up-arrow-left",            GESTURE_UP_ARROW_LEFT         },
    {"gesture-up-arrow-right",           GESTURE_UP_ARROW_RIGHT        },
    {"gesture-up-down",                  GESTURE_UP_DOWN               },
    {"gesture-up-left",                  GESTURE_UP_LEFT               },
    {"gesture-up-left-long",             GESTURE_UP_LEFT_LONG          },
    {"gesture-up-right",                 GESTURE_UP_RIGHT              },
    {"gesture-up-right-long",            GESTURE_UP_RIGHT_LONG         },
};


/***********************************************************************\
*	GestureNameToID:													*
*		Given gesture name, return gesture ID or GESTURE_UNDEFINED if	*
*		gesture name is not in the list of gestures.					*
\***********************************************************************/

int
GestureNameToID(char *szName)
{
	int lo = 0;
	int hi = sizeof(gaGestureNameID)/sizeof(gaGestureNameID[0]) - 1;

	while (lo <= hi)
	{
		int n, mid;

		mid = (lo + hi) >> 1;
		n = strcmp(szName, gaGestureNameID[mid].szName);
		if (n < 0)
			hi = mid-1;
		else if (n == 0)
		{
			return gaGestureNameID[mid].iID;
		}
		else
			lo = mid+1;
	}

	return GESTURE_UNDEFINED;
}

/***********************************************************************\
*	GestureIDToName:													*
*		Given gesture ID, return gesture name or NULL if gesture ID is	*
*		not in the list of gestures.									*
\***********************************************************************/

char *
GestureIDToName(int iID)
{
	int i = sizeof(gaGestureNameID)/sizeof(gaGestureNameID[0]) - 1;

	while (i >= 0)
	{
		if (gaGestureNameID[i].iID == iID)
		{
			return gaGestureNameID[i].szName;
		}
		i--;
	}

	return (char *)NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\inkio.c ===
#include <stdlib.h>
#include <common.h>
#include "inkio.h"

#define MAXLINE 1024

char gszInkIoError[256];

const char *szWordmode = "Wordmode";
const char *szUseGuide = "UseGuide";
const char *szCoerce = "Coerce";
const char *szNNonly = "NNonly";
const char *szUseFactoid = "UseFactoid";
const char *szFactoid = "Factoid";
const char *szUseHWL = "UseWordlist";
const char *szHWL = "Wordlist";
const char *szDll = "DLL";
const char *szPrefix = "Prefix";
const char *szSuffix = "Suffix";

#define STRING_CHECKFORNULL(sz) ((sz) ? (sz) : "")

/************************WRITING FUNCTIONS****************************************/
static void SaveWritingArea(FILE *f, WritingArea *pWA, char *sz)
{
	fprintf(f, "%s\n", sz);
	fprintf(f, "\tL=%d T=%d R=%d B=%d\n", pWA->rect.left, pWA->rect.top, pWA->rect.right, pWA->rect.bottom);
	fprintf(f, "\txOrigin=%d\tyOrigin=%d\n", pWA->guide.xOrigin, pWA->guide.yOrigin);
	fprintf(f, "\tcxBox=%d\tcyBox=%d\n", pWA->guide.cxBox, pWA->guide.cyBox);
	fprintf(f, "\tcxBase=%d\tcyBase=%d\tcyMid=%d\n", pWA->guide.cxBase, pWA->guide.cyBase, pWA->guide.cyMid);
	fprintf(f, "\tcHorzBox=%d\tcVertBox=%d\n", pWA->guide.cHorzBox, pWA->guide.cVertBox);
	fprintf(f, "\tiMultInk=%d\tiDivInk=%d\n", pWA->iMultInk, pWA->iDivInk);
}

static void SaveInk(FILE *f, GLYPH *glyph, char *szHeader)
{
	int cStroke;
	
	cStroke = CframeGLYPH(glyph);
	fprintf(f, "%s\n%d\n", szHeader, cStroke);
	for (; glyph; glyph=glyph->next)
	{
		FRAME *frame = glyph->frame;
		POINT *pPoint = RgrawxyFRAME(frame);
		int iPoint, cPoint = CrawxyFRAME(frame);
		fprintf(f, "%d\n", cPoint);
		for (iPoint=0; iPoint<cPoint; iPoint++, pPoint++)
			fprintf(f, "%d\t%d\n", pPoint->x, pPoint->y);
	}
}

/******************************Public*Routine******************************\
* WriteInkFile
*
* Top-level function to save an ink file.
* Returns 1 on success.  Returns 0 otherwise.
*
* History:
* 18-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int WriteInkFile(char *szFile, InkData *pInkData)
{
	FILE *f;
	
	f = fopen(szFile, "w");
	if (!f)
	{
		sprintf(gszInkIoError, "Could not create file %s", szFile);
		return 0;
	}

	// version number
	fprintf(f, "VERSION=2\n");

	// some environment variables
	fprintf(f, "OS=%s\n", STRING_CHECKFORNULL(pInkData->szOS));
	fprintf(f, "SystemRoot=%s\n", STRING_CHECKFORNULL(pInkData->szSystemRoot));
	fprintf(f, "USERNAME=%s\n", STRING_CHECKFORNULL(pInkData->szUSERNAME));
	fprintf(f, "SCREEN: h=%d w=%d\n", pInkData->SCREEN.y, pInkData->SCREEN.x);

	// settings
	fprintf(f, "%s=%d\n", szWordmode, pInkData->bWordmode);
	fprintf(f, "%s=%d\n", szUseGuide, pInkData->bUseGuide);
	fprintf(f, "%s=%d\n", szCoerce, pInkData->bCoerce);
	fprintf(f, "%s=%d\n", szNNonly, pInkData->bNNonly);
	fprintf(f, "%s=%d\n", szUseFactoid, pInkData->bUseFactoid);
	fprintf(f, "%s=%d\n", szFactoid, pInkData->factoid);
	fprintf(f, "%s=%s\n", szPrefix, STRING_CHECKFORNULL(pInkData->szPrefix));
	fprintf(f, "%s=%s\n", szSuffix, STRING_CHECKFORNULL(pInkData->szSuffix));
	if (pInkData->szWordlist)
	{
		fprintf(f, "%s=1\n", szUseHWL);
		fprintf(f, "%s=%s\n", szHWL, pInkData->szWordlist);
	}
	else
	{
		fprintf(f, "%s=0\n", szUseHWL);
	}
	fprintf(f, "%s=%s size=%d time=%s", szDll, STRING_CHECKFORNULL(pInkData->szRecogDLLName), pInkData->cDLLSize, STRING_CHECKFORNULL(pInkData->szDLLTime));

	// writing areas
	SaveWritingArea(f, &pInkData->WA, "WA=");
	SaveWritingArea(f, &pInkData->WAGMM, "WAGMM=");

	// label
	fprintf(f, "label=%s\n", STRING_CHECKFORNULL(pInkData->szLabel));

	// comment
	fprintf(f, "comment=%s\ncommentend=\n", STRING_CHECKFORNULL(pInkData->szComment));

	// points
	SaveInk(f, pInkData->glyph, "regular points");
	SaveInk(f, pInkData->glyphGMM, "GMM points");

	fclose(f);
	return 1;
}

/************************READING FUNCTIONS****************************************/
static BOOL LoadWritingArea(FILE *f, WritingArea *pWA, char *szHeader)
{
	const int maxline = MAXLINE;
	char szLine[MAXLINE];

	if (!fgets(szLine, maxline, f) || strncmp(szLine, szHeader, strlen(szHeader)))
		return FALSE;
	if (fscanf(f, "\tL=%d T=%d R=%d B=%d\n", &pWA->rect.left, &pWA->rect.top, &pWA->rect.right, &pWA->rect.bottom) != 4)
		return FALSE;
	if (fscanf(f, "\txOrigin=%d\tyOrigin=%d\n", &pWA->guide.xOrigin, &pWA->guide.yOrigin) != 2)
		return FALSE;
	if (fscanf(f, "\tcxBox=%d\tcyBox=%d\n", &pWA->guide.cxBox, &pWA->guide.cyBox) != 2)
		return FALSE;
	if (fscanf(f, "\tcxBase=%d\tcyBase=%d\tcyMid=%d\n", &pWA->guide.cxBase, &pWA->guide.cyBase, &pWA->guide.cyMid) != 3)
		return FALSE;
	if (fscanf(f, "\tcHorzBox=%d\tcVertBox=%d\n", &pWA->guide.cHorzBox, &pWA->guide.cVertBox) != 2)
		return FALSE;
	if (fscanf(f, "\tiMultInk=%d\tiDivInk=%d\n", &pWA->iMultInk, &pWA->iDivInk) != 2)
		return FALSE;
	return TRUE;
}

static GLYPH *LoadInk(FILE *f, char *szHeader, BOOL *pbError)
{
	int i, cStroke, iStroke, iPoint;
	BYTE *pBuffer = NULL;
	GLYPH *aGlyph, *glyph;
	FRAME *aFrame;
	int iStartTime;
	char szLine[MAXLINE];

	*pbError = FALSE;

	if (!fgets(szLine, MAXLINE, f))
		goto error2;
	if (strcmp(szLine, szHeader))
		goto error2;
	i = fscanf(f, "%d\n", &cStroke);
	if (i != 1)
	{
		sprintf(gszInkIoError, "ReadInkFile: could not read stroke count");
		goto error2;
	}
	if (cStroke <= 0)
		return NULL;

	pBuffer = (BYTE *) ExternAlloc(cStroke*(sizeof(GLYPH)+sizeof(FRAME)));
	if (!pBuffer)
	{
		sprintf(gszInkIoError, "ReadInkFile: malloc failure");
		goto error2;
	}
	
	aGlyph = (GLYPH *) pBuffer;
	aFrame = (FRAME *) (pBuffer + cStroke*sizeof(GLYPH));

	iStartTime = 0;
	glyph = aGlyph;
	for (iStroke=0; iStroke<cStroke;)
	{
		int cPoint;
		FRAME *frame;
		POINT *rgPoint;

		i = fscanf(f, "%d\n", &cPoint);
		if ((i != 1) || (cPoint <= 0))
		{
			sprintf(gszInkIoError, "ReadInkFile: error with point count for stroke index %d", iStroke);
			goto error;
		}
		frame = glyph->frame = aFrame++;
		if (iStroke < cStroke-1)
		{
			glyph->next = glyph+1;
			glyph++;
		}
		else
			glyph->next = NULL;
		memset(frame, 0, sizeof(FRAME));
		CrawxyFRAME(frame) = cPoint;
		frame->rect.left = -1;
		frame->info.wPdk = PDK_TRANSITION | PDK_DOWN;  // Each stroke passed in is down and
		frame->info.dwTick = iStartTime;
		rgPoint = RgrawxyFRAME(frame) = (POINT *) ExternAlloc(cPoint * sizeof(POINT));
		if (!rgPoint)
		{
			sprintf(gszInkIoError, "ReadInkFile: malloc failure for %d points, stroke index %d", cPoint, iStroke);
			goto error;
		}
		iStroke++; // don't move this, memory free in case of error depends on this being here
		for (iPoint=0; iPoint<cPoint; iPoint++)
		{
			i = fscanf(f, "%d\t%d\n", &rgPoint[iPoint].x, &rgPoint[iPoint].y);
			if (i != 2)
			{
				sprintf(gszInkIoError, "ReadInkFile: could not read point at index %d, stroke index %d", iPoint, iStroke-1);
				goto error;
			}
		}
		iStartTime += 1000 + 10*cPoint;
	}
	return aGlyph;

error:
	glyph = aGlyph;
	while (iStroke)
	{
		ASSERT(glyph);
		ASSERT(glyph->frame);
		if (glyph && glyph->frame)
			ExternFree(RgrawxyFRAME(glyph->frame));
		iStroke--;
		glyph = glyph->next;
	}

error2:
	if (pBuffer)
		ExternFree(pBuffer);
	*pbError = TRUE;
	return NULL;
}

/******************************Public*Routine******************************\
* ReadInkFile
*
* Top-level function to read an ink file.
* Returns 1 on success.  Returns 0 otherwise.
*
* History:
* 18-May-2001 -by- Angshuman Guha aguha
* Wrote it.
\**************************************************************************/
int ReadInkFile(char *szFile, InkData *pInkData)
{
    FILE *f;
	const int maxline = MAXLINE;
	char szLine[MAXLINE];
	int iVersion;
	BOOL bUseHWL;
	BOOL bError;
	
	if (!szFile || !*szFile)
	{
		sprintf(gszInkIoError, "ReadInkFile: Null or empty filename");
		return 0;
	}
	f = fopen(szFile, "r");
	if (!f)
	{
		sprintf(gszInkIoError, "ReadInkFile: Could not open file %s", szFile);
		return 0;
	}

	pInkData->szWordlist = NULL;
	pInkData->szLabel = NULL;

	// version number
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "VERSION=", 8))
		goto error;
	iVersion = atoi(szLine + 8);
	if (iVersion < 1 || iVersion > 2)
		goto error;

	// some environment variables
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "OS=", 3))
		goto error;
	pInkData->szOS = NULL;
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "SystemRoot=", 11))
		goto error;
	pInkData->szSystemRoot = NULL;
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "USERNAME=", 9))
		goto error;
	pInkData->szUSERNAME = NULL;
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "SCREEN:", 7))
		goto error;
	pInkData->SCREEN.x = 0;
	pInkData->SCREEN.y = 0;

	// settings
	if (iVersion == 1)
	{
		const char *szEnableSpace = "EnableSpace";
		if (!fgets(szLine, maxline, f) || strncmp(szLine, szEnableSpace, strlen(szEnableSpace)))
			goto error;
		pInkData->bWordmode = !atoi(szLine + strlen(szEnableSpace) + 1);
	}
	else if (iVersion == 2)
	{
		if (!fgets(szLine, maxline, f) || strncmp(szLine, szWordmode, strlen(szWordmode)))
			goto error;
		pInkData->bWordmode = !!atoi(szLine + strlen(szWordmode) + 1);
	}

	if (!fgets(szLine, maxline, f) || strncmp(szLine, szUseGuide, strlen(szUseGuide)))
		goto error;
	pInkData->bUseGuide = !!atoi(szLine + strlen(szUseGuide) + 1);

	if (!fgets(szLine, maxline, f) || strncmp(szLine, szCoerce, strlen(szCoerce)))
		goto error;
	pInkData->bCoerce = !!atoi(szLine + strlen(szCoerce) + 1);

	if (!fgets(szLine, maxline, f) || strncmp(szLine, szNNonly, strlen(szNNonly)))
		goto error;
	pInkData->bNNonly = !!atoi(szLine + strlen(szNNonly) + 1);

	if (iVersion == 1)
	{
		pInkData->bUseFactoid = FALSE;
		pInkData->factoid = 0;
		pInkData->szPrefix = NULL;
		pInkData->szSuffix = NULL;
	}
	else if (iVersion == 2)
	{
		char *sz;
		int n;

		if (!fgets(szLine, maxline, f) || strncmp(szLine, szUseFactoid, strlen(szUseFactoid)))
			goto error;
		pInkData->bUseFactoid = !!atoi(szLine + strlen(szUseFactoid) + 1);

		if (!fgets(szLine, maxline, f) || strncmp(szLine, szFactoid, strlen(szFactoid)))
			goto error;
		pInkData->factoid = atoi(szLine + strlen(szFactoid) + 1);

		// prefix
		if (!fgets(szLine, maxline, f) || strncmp(szLine, szPrefix, strlen(szPrefix)))
			goto error;
		sz = szLine + strlen(szPrefix) + 1;
		n = strlen(sz);
		if (n <= 0)
			pInkData->szPrefix = NULL;
		else
		{
			if (sz[n-1] == '\n')
				sz[--n] = '\0';
			pInkData->szPrefix = (char *) ExternAlloc((n+1)*sizeof(char));
			strcpy(pInkData->szPrefix, sz);
		}

		// suffix
		if (!fgets(szLine, maxline, f) || strncmp(szLine, szSuffix, strlen(szSuffix)))
			goto error;
		sz = szLine + strlen(szSuffix) + 1;
		n = strlen(sz);
		if (n <= 0)
			pInkData->szSuffix = NULL;
		else
		{
			if (sz[n-1] == '\n')
				sz[--n] = '\0';
			pInkData->szSuffix = (char *) ExternAlloc((n+1)*sizeof(char));
			strcpy(pInkData->szSuffix, sz);
		}
	}

	if (!fgets(szLine, maxline, f) || strncmp(szLine, szUseHWL, strlen(szUseHWL)))
		goto error;
	bUseHWL = !!atoi(szLine + strlen(szUseHWL) + 1);

	if (bUseHWL)
	{
		char *sz;
		int n;

		if (!fgets(szLine, maxline, f) || strncmp(szLine, szHWL, strlen(szHWL)))
			goto error;
		sz = szLine + strlen(szHWL) + 1;
		n = strlen(sz);
		if ((n > 0) && (sz[n-1] == '\n'))
			sz[--n] = '\0';
		pInkData->szWordlist = (char *) ExternAlloc((n+2)*sizeof(char));
		strcpy(pInkData->szWordlist, sz);
		pInkData->szWordlist[n+1] = '\0';
	}

	if (!fgets(szLine, maxline, f) || strncmp(szLine, szDll, strlen(szDll)))
		goto error;
	pInkData->szRecogDLLName = NULL;
	pInkData->cDLLSize = 0;
	pInkData->szDLLTime = NULL;

	if (!LoadWritingArea(f, &pInkData->WA, "WA=") || !LoadWritingArea(f, &pInkData->WAGMM, "WAGMM="))
		goto error;

	// label
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "label=", 6))
		goto error;
	pInkData->szLabel = Externstrdup(szLine + 6);

	// comment
	if (!fgets(szLine, maxline, f) || strncmp(szLine, "comment=", 8))
		goto error;
	while (strcmp(szLine, "commentend=\n"))
	{
		if (!fgets(szLine, maxline, f))
			goto error;
	}
	pInkData->szComment = NULL;

	// points
	pInkData->glyph = LoadInk(f, "regular points\n", &bError);
	if (bError)
	{
		ASSERT(!pInkData->glyph);
		goto error;
	}
	pInkData->glyphGMM = LoadInk(f, "GMM points\n", &bError);
	if (bError)
	{
		ASSERT(!pInkData->glyphGMM);
		goto error;
	}
	if (!pInkData->glyph && !pInkData->glyphGMM)
		goto error;

	fclose(f);
	return 1;

error:
	fclose(f);
	if (pInkData->szWordlist)
		ExternFree(pInkData->szWordlist);
	if (pInkData->szLabel)
		ExternFree(pInkData->szLabel);
	return 0;
}

void CleanupInkData(InkData *pInkData)
{
	GLYPH *glyph;
	
	glyph = pInkData->glyph;
	while (glyph)
	{
		ExternFree(glyph->frame->rgrawxy);
		glyph = glyph->next;
	}
	glyph = pInkData->glyphGMM;
	while (glyph)
	{
		ExternFree(glyph->frame->rgrawxy);
		glyph = glyph->next;
	}

	ExternFree(pInkData->glyph);
	ExternFree(pInkData->glyphGMM);
	ExternFree(pInkData->szLabel);
	ExternFree(pInkData->szWordlist);
	ExternFree(pInkData->szPrefix);
	ExternFree(pInkData->szSuffix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\memmgr.c ===
// memmgr.c
//
// This file contains definitions for the memory management.
// Implementation details may change so beware of relying on internal details.
//

#include <stdlib.h>
#include "common.h"

#ifdef DBG
int cAllocMem = 0;     // Amount of memory alloced
int cAlloc = 0;        // Count of allocs outstanding
int cAllocMaxMem = 0;  // Max amount of memory ever alloced.

int	gFailure = 0;

CRITICAL_SECTION GlobalCriticalSection = {0}; 
long	g_cCrticalSectionInitialize = -1;

void initMemMgr()
{
	if (0 == InterlockedIncrement(&g_cCrticalSectionInitialize))
	{
		InitializeCriticalSection(&GlobalCriticalSection); 
	}
	else
	{
		InterlockedDecrement(&g_cCrticalSectionInitialize);
	}
}

void destroyMemMgr()
{
	if (GlobalCriticalSection.LockCount != 0)
	{
		DeleteCriticalSection(&GlobalCriticalSection);
	}
}
#endif

/******************************Public*Routine******************************\
* ExternAlloc
*
* This guy keeps the size in the first long so we can fake a realloc.  Lot's
* of debug checking for heap overwrites.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternAlloc(DWORD cb)
{
    long   *pl;
	DWORD	cbAlloc;

#ifdef  DBG
#ifndef WINCE
    //
    // If gFailure is 0 nothing happens, if it's non-zero we
    // fail 1 in gFailure allocations.
    //

    if (gFailure)
    {
        if (((rand() * gFailure) / (RAND_MAX + 1)) == 0)
        {
            return (void *) NULL;
        }
    }
#endif
#endif

// Since we can't use realloc on WINCE, we need to save the original size for memcpy
// in our own realloc function.

	cbAlloc = cb + 4;

#ifdef DBG
    cbAlloc +=  3;	// round it up to DWORD boundary
    cbAlloc &= ~3;
    cbAlloc +=  8;	// write size at begining and overwrite detector at begining and end
#endif

	pl = (long *) malloc(cbAlloc);
	if (pl == (long *) NULL)
		return pl;

// Stamp this baby full of invalid bytes so code that relies on 0's in it are sniffed out.

#ifdef DBG
	memset(pl,0xff,cbAlloc);
#endif

// OK, tuck the object size away at the begining

  *(pl++) = cb;

#ifdef DBG
  // Will only initialize the crtical section flag once
  initMemMgr();
EnterCriticalSection(&GlobalCriticalSection); 
  *(pl++) = 0xDEADBEEF;
    pl[(cbAlloc / 4) - 3] = 0xDEADBEEF;
    cAlloc++;
    cAllocMem += cb;

// JPittman: The OutputDebugString() call here is commented out because
// of complaints from Word about spewing of tons of output to the
// debug window hiding their own debug output.  This caused us to be
// excluded from Cicero's TIP profiling.

	if (cAllocMem > cAllocMaxMem)
	{
//		TCHAR szDebug[128];
		cAllocMaxMem = cAllocMem;
//		wsprintf(szDebug, TEXT("cAllocMaxMem = %d \r\n"), cAllocMaxMem);
//		OutputDebugString(szDebug);
	}
LeaveCriticalSection(&GlobalCriticalSection);
#endif

    return pl;
}

/******************************Public*Routine******************************\
* ExternRealloc
*
* Well this sucks buts we want the same exact code on NT and WINCE and
* we can't find a way to use the flags and have Realloc work the same on
* both.  Realloc is a very infrequent event so this work for us.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternRealloc(void *pv, DWORD cbNew)
{
    void   *pvNew = ExternAlloc(cbNew);

    if (pv && pvNew)
    {
        long   *pl;
        DWORD	cb;

        pl = (long *) pv;

#ifdef	DBG
		pl--;
#endif

        cb = (DWORD) *(--pl);
		memcpy(pvNew, pv, min(cbNew, cb));
        ExternFree(pv);
    }

	return pvNew;
}

/******************************Public*Routine******************************\
* ExternFree
*
* Free up the memory, in debug mode check for heap corruption !
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void ExternFree(void *pv)
{
    long   *pl;
// We now allow freeing of null pointers

	if (pv == (void *) NULL)
		return;

    pl = (long *) pv;
    pl--;

#ifdef DBG
{
    int		cbAlloc;
#if defined(HWX_INTERNAL) && defined(HWX_HEAPCHECK)
	HANDLE	hHeap = GetProcessHeap();
	BOOL	bHeapState;

	if (hHeap)
	{
		bHeapState = HeapValidate(hHeap, 0, NULL);
		ASSERT(bHeapState);
	}
#endif // #if defined(HWX_INTERNAL) && defined(HWX_HEAPCHECK)
// Check nothing has been stepped on.

EnterCriticalSection(&GlobalCriticalSection); 
    ASSERT(*pl == 0xDEADBEEF);
    pl--;
    cbAlloc = *pl;
    cAllocMem -= cbAlloc;
    ASSERT(cAllocMem >= 0);
    cbAlloc = (cbAlloc + 11) & ~3;
    ASSERT(pl[(cbAlloc / 4)] == 0xDEADBEEF);
    cAlloc--;
	ASSERT(!IsBadWritePtr(pl, cbAlloc));

LeaveCriticalSection(&GlobalCriticalSection);
}
#endif

	free(pl);

}

char *Externstrdup( const char *strSource )
{
	int		nLen = 0;
	char*	pszOut = NULL;

	// fail immediately on a null pointer
	if (NULL == strSource)
		return NULL;

	// get the length of the ansi string 
	nLen = strlen(strSource) * sizeof(char);

	if (nLen < 0)
		return NULL;

	// allow room for a trailing null
	nLen += sizeof(char);

	// allocate space for the string
	pszOut = ExternAlloc(nLen);

	if (NULL == pszOut)
		return NULL;

	// copy the string into the buffer provided
	strcpy(pszOut, strSource);

    return pszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\math16.c ===
#include "common.h"
#include "math16.h"

/* Wecker's div; debugged by AGuha */
int Div16(int iX,int iY)
{
    BOOL    fSign;
    DWORD   dwX;
    DWORD   dwY;
    int     iXShft;
    int     iYShft;
    int     iShiftLeft;
    DWORD   dwVal;

    // Handle 0
    if (iY == 0) 
	{
		if (iX == 0)	    return 0;
		else if (iX < 0)    return 0x80000000;
		else				return 0x7FFFFFFF;
    }
	
    // Remember sign

    fSign    = FALSE;
    if (iX < 0) 
	{
		iX					= -iX;
		if (iY > 0)	fSign   = TRUE;
		else		iY		= -iY;
    }
    else if (iY < 0) 
	{
		iY	 = -iY;
		fSign	 = TRUE;
    }

    dwX          = (DWORD) iX;
    dwY          = (DWORD) iY;

    // Guess at avail bits

    iXShft       = 32 - Need(dwX);
    iYShft       = Need(dwY);
    iShiftLeft   = SHFTBITS;
    
    // Move numerator as far as we can (and need)
    //int	    iXShft	     = 32 - iXNeed;
    if (iXShft >= iShiftLeft)	
		iXShft		     = iShiftLeft;

    iShiftLeft		    -= iXShft;

    if (iYShft > iShiftLeft) 
	{
		iYShft		     = iShiftLeft;
		iShiftLeft	     = 0;
    }
	else
		iYShft = 0;
    
    if (iXShft)	    dwX	   <<= iXShft;
    if (iYShft)	    dwY	   >>= iYShft;
    dwVal          = dwX / dwY;
    if (iShiftLeft) dwVal <<= iShiftLeft;
    
    if (fSign)	
        return -((int) dwVal);
    else	
        return  ((int) dwVal);
}


#define	NUMSIG	256
const int piSigmoid[NUMSIG+1] = {			// From 0.0 to 9.0
    32768, 33344, 33920, 34494, 35068, 35641, 36211, 36780, 37346, 37909,
    38469, 39026, 39579, 40128, 40673, 41213, 41748, 42279, 42803, 43322,
    43836, 44343, 44844, 45338, 45826, 46307, 46782, 47249, 47709, 48161,
    48606, 49044, 49474, 49897, 50311, 50718, 51118, 51509, 51893, 52269,
    52637, 52997, 53350, 53695, 54032, 54362, 54684, 54998, 55306, 55605,
    55898, 56183, 56462, 56733, 56998, 57255, 57506, 57751, 57989, 58220,
    58446, 58665, 58878, 59086, 59287, 59483, 59674, 59858, 60038, 60213,
    60382, 60547, 60706, 60861, 61012, 61157, 61299, 61436, 61569, 61698,
    61823, 61944, 62062, 62176, 62286, 62393, 62497, 62597, 62694, 62788,
    62879, 62967, 63053, 63135, 63215, 63293, 63368, 63440, 63510, 63578,
    63644, 63707, 63769, 63828, 63886, 63941, 63995, 64047, 64098, 64146,
    64193, 64239, 64283, 64325, 64366, 64406, 64444, 64481, 64517, 64552,
    64585, 64618, 64649, 64679, 64709, 64737, 64764, 64790, 64816, 64841,
    64864, 64887, 64910, 64931, 64952, 64972, 64991, 65010, 65028, 65045,
    65062, 65078, 65094, 65109, 65124, 65138, 65152, 65165, 65178, 65190,
    65202, 65213, 65224, 65235, 65245, 65255, 65265, 65274, 65283, 65292,
    65300, 65309, 65316, 65324, 65331, 65338, 65345, 65352, 65358, 65364,
    65370, 65376, 65381, 65387, 65392, 65397, 65402, 65406, 65411, 65415,
    65419, 65423, 65427, 65431, 65435, 65438, 65441, 65445, 65448, 65451,
    65454, 65457, 65459, 65462, 65465, 65467, 65469, 65472, 65474, 65476,
    65478, 65480, 65482, 65484, 65486, 65487, 65489, 65491, 65492, 65494,
    65495, 65497, 65498, 65499, 65501, 65502, 65503, 65504, 65505, 65506,
    65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65514, 65515,
    65516, 65517, 65517, 65518, 65518, 65519, 65520, 65520, 65521, 65521,
    65522, 65522, 65523, 65523, 65524, 65524, 65525, 65525, 65525, 65526,
    65526, 65526, 65527, 65527, 65527, 65528, 65535,
};

int Sigmoid16(int iX)
{
    BOOL    fNeg;
    int iIdx;
    int iFrc;
    int iY1;
    int iY2;
    int iY;

    if (iX < 0)	{
	fNeg	 = TRUE;
	iX	 = -iX;
    }
    else fNeg	 = FALSE;
	
    // End of the range?
    if (iX >= LSHFT(9)) {
	if (fNeg)   return 0;
	else	    return LSHFT(1);
    }
    
    iX			    *= NUMSIG;
    iX			    /= 9;
    iIdx             = RSHFT(iX);
    iFrc             = LOWBITS(iX) >> 8;
    iY1          = piSigmoid[iIdx++];
    iY2          = piSigmoid[iIdx];
    iY   = (iY1 * (256-iFrc) + iY2 * iFrc) >> 8;
    if (fNeg)	return LSHFT(1) - iY;
    else	return iY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\langtax.c ===
// langtax.c
// Radmila Sarac, rsarac & Angshuman Guha, aguha
// July 11, 2000

// Language Taxonomy file
// Given any language and a unicode value, this code attempts
// to define a "class" for that codepoint.

#include <search.h>
#include <windows.h>
#include "langtax.h"

#define CLANG 9

typedef struct {
	wchar_t	startCodePoint;
	int		Class;
	wchar_t	stopCodePoint;
}ENTRY;

typedef struct {
	WORD	wLangID;
	wchar_t *wszLanguage;
	int		cClass;
	int		cEntry;
	ENTRY	*pEntry;
	wchar_t	**aClassNames;
}PARTITION;

#include "usatax.ci"
#include "chstax.ci"
#include "chttax.ci"
#include "jpntax.ci"
#include "kortax.ci"

#define USA_ID MAKELANGID(LANG_ENGLISH,  SUBLANG_DEFAULT)
#define UK_ID  MAKELANGID(LANG_ENGLISH,  SUBLANG_ENGLISH_UK)
#define FRA_ID MAKELANGID(LANG_FRENCH,   SUBLANG_DEFAULT)
#define DEU_ID MAKELANGID(LANG_GERMAN,   SUBLANG_DEFAULT)
#define ESP_ID MAKELANGID(LANG_SPANISH,  SUBLANG_DEFAULT)
#define CHS_ID MAKELANGID(LANG_CHINESE,  SUBLANG_CHINESE_SIMPLIFIED)
#define CHT_ID MAKELANGID(LANG_CHINESE,  SUBLANG_CHINESE_TRADITIONAL)
#define JPN_ID MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)
#define KOR_ID MAKELANGID(LANG_KOREAN,   SUBLANG_DEFAULT)

static PARTITION aPartition[CLANG] = {
	{USA_ID,  L"USA", 6,  32, USATable, USA_CLASSES},
	{UK_ID,   L"UK", 6,  32, USATable, USA_CLASSES},
	{FRA_ID,  L"FRA", 6,  30, USATable, USA_CLASSES},
	{DEU_ID,  L"DEU", 6,  30, USATable, USA_CLASSES},
	{ESP_ID,  L"ESP", 6,  30, USATable, USA_CLASSES},
	{CHS_ID,  L"CHS", 6,  42, CHSTable, CHS_CLASSES},
	{CHT_ID,  L"CHT", 4,  20, CHTTable, CHT_CLASSES},
	{JPN_ID,  L"JPN", 6,  32, JPNTable, JPN_CLASSES},
	{KOR_ID,  L"KOR", 7, 4117, KORTable, KOR_CLASSES}
};

int GetIndexFromLANG(WORD wIDLanguage)
{
	int i;
	for (i = 0; i < CLANG; i++)
		if (aPartition[i].wLangID == wIDLanguage)
				return i;
	return -1;
}

int GetIndexFromLocale(wchar_t *wszLang)
{
	int i;
	for (i = 0; i < CLANG; i++)
		if (wcscmp(_wcsupr(aPartition[i].wszLanguage), _wcsupr(wszLang)) == 0)
			return i;
	return -1;
}

int GetClassCountLANG(int iLangIndex)
{
	return (aPartition[iLangIndex].cClass);
}

wchar_t *GetNameLANG(int iLangIndex)
{
	return aPartition[iLangIndex].wszLanguage;
}

wchar_t *GetClassNameLANG(int iLangIndex, int iClassIndex)
{
	return (aPartition[iLangIndex].aClassNames[iClassIndex]);
}

int __cdecl cmpEntry(const void *v1, const void *v2)
{
	if (*(wchar_t *)v1 < (*(ENTRY *)v2).startCodePoint)
		return -1;
	else if (*(wchar_t *)v1 > (*(ENTRY *)v2).stopCodePoint)
		return 1;
	else return 0;
}

int GetClassFromLANG(int iLangIndex, wchar_t wChar)

{
	ENTRY *pEntry;
	pEntry = (ENTRY *)bsearch(&wChar, aPartition[iLangIndex].pEntry, aPartition[iLangIndex].cEntry,
		      sizeof(ENTRY), cmpEntry);
	if (!pEntry)
		return -1;
	else 
		return (pEntry->Class);
}

BOOL IsLatinLANG(int iLangIndex)
{
	return iLangIndex < 5;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\mathx.c ===
#include "mathx.h"
#include <math.h>

//	Array of angles in degrees associated with arctan values

const char arctan_array[] =
{
    0,	 1,	 1,	 2,	 2,	 3,	 3,	 4,	 5,	 5,
	6,	 6,	 7,	 7,	 8,	 9,	 9,	10,	10,	11,
	11, 12,	12,	13,	13,	14,	15,	15,	16,	16,
	17,	17,	18,	18,	19,	19,	20,	20,	21,	21,
	22,	22,	23,	23,	24,	24,	25,	25,	26,	26,
	27,	27,	27,	28,	28,	29,	29,	30,	30,	31,
	31,	31,	32,	32,	33,	33,	33,	34,	34,	35,
	35,	35,	36,	36,	37,	37,	37,	38,	38,	38,
	39,	39,	39,	40,	40,	40,	41,	41,	41,	42,
	42,	42,	43,	43,	43,	44,	44,	44,	44,	45
};

// 	Rough integer approximation (fast) of arctan2 based on table for 0-45 degrees
//	Return degrees, base on integer y and x inputs to arctan

int Arctan2(int y, int x)
{
	int xneg=0,yneg=0;
    int index,angle=45;

    if (x < 0)
	{ 
        xneg = 1;
        x = -x;
   	}

    if (y < 0)
	{
        yneg = 1;
        y = -y;
   	}

    if (x == 0 && y == 0) return 0;

    if (y == 0)
        return(xneg ? 180 : 0);

    if (x == 0)
        return(yneg ? 270 : 90);

    if (x > y)
	{
        index = (int)(((long)y * INTEGER_ARCTAN) / (long)x);
        angle = arctan_array[index];
   	}
	else if (y > x)
	{
        index = (int)(((long)x * INTEGER_ARCTAN) / (long)y);
        angle = 90 - arctan_array[index];
   	}
    
    if (xneg)
        if (yneg) 
            return(180 + angle);
        else
            return(180 - angle);
    else
        if (yneg) 
            return(360 - angle);
        else
            return(angle);
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\recogdll.c ===
/****************************************************************************
*
* recogDLL.h
* created: 13 March 2000
* mrevow
*
* Support routines for loading the DLL and calling its api.
* This library supports the following API:
*
* OpenRecognizer()
* DoXXX()   - One for each function tin the DLL api
* CloseRecognizer()
*
* Error return policy.
*
* 1) The only error that OpenRecognizer will report if it cannot find the DLL
* The DoXXX() routines will pass on the **real** API error return. If the API
* does not exist in the DLL it will return HRCR_UNSUPPORTED
*
* Here is the preferred usage
*
* void *pvRecog;
* unsigned char *pRecogDLL = "madusa.dll";

* pvRecog = Open("madusa.dll");
* if (!pvRecog)
* {
*	printf("Cannot find madusa.dll\n");
*   exit (1);
* }
*
* hrc = DoCreateCompatibleHRC()
* .
* .
* .
* CloseRecognizer(pvRecog);
*
******************************************************************************/
#include <RecogDLL.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include "ApiNames.h"

#define MAX_MSG_LEN		_MAX_PATH

// Global pointers to functions within the Recognizer DLL:
typedef struct tagDllInfo
{
	HINSTANCE		hDll;					// Handle to the loaded DLL


	int				cDLLSize;				// Byte size of the Dll
	const char		pszDLLTime[32];			// Dll Creation Time (Big enough too hold a ctime() string)
	const char		acDllName[_MAX_PATH];	// Dll name
	const char		acLastError[MAX_MSG_LEN];	// Last error Message

	// Pointer to all functions in the recognizer
	HRC (*pfnCreateCompatibleHRC)(HRC,HREC);
	int (*pfnConfigRecognizer)(unsigned int uSubFunc, WPARAM wParam, LPARAM lParam);
	
	int (*pfnSetAlphabetHRC)(HRC, ALC, LPBYTE);
	int (*pfnSetRecogSpeedHRC)(HRC, int);
	int (*pfnSetGuideHRC)(HRC, GUIDE*, UINT);
	int (*pfnEnableSystemDictionaryHRC)(HRC, int);
	int (*pfnSetWordlistCoercionHRC)(HRC, UINT);
	int (*pfnEnableLangModelHRC)(HRC, int);
	
	int (*pfnAddPenInputHRC)(HRC, POINT*, void*, UINT, STROKEINFO*);
	int (*pfnEndPenInputHRC)(HRC hrc);
	int (*pfnHwxSetAnswer)(char*);
	int (*pfnProcessHRC)(HRC, DWORD);
	int (*pfnHwxGetWordResults)(HRC hrc, UINT cAlt, char *buffer, UINT buflen);
	int (*pfnHwxGetCosts)(HRC hrc, UINT cAltMax, int *rgCost);
	int (*pfnHwxGetNeuralOutput)(HRC hrc, void *buffer, UINT buflen);
	int (*pfnHwxGetInputFeatures)(HRC hrc, unsigned short *rgFeat, UINT cWidth);
	int (*pfnGetMaxResultsHRC)(HRC);
	int (*pfnGetResultsHRC)(HRC, UINT, HRCRESULT*, UINT);
	int (*pfnGetSymbolCountHRCRESULT)(HRCRESULT);
	int (*pfnGetSymbolsHRCRESULT)(HRCRESULT, UINT, SYV*, UINT);
	int (*pfnGetCostHRCRESULT)(HRCRESULT hrcresult);
	BOOL (*pfnSymbolToCharacter)(SYV*, int, char*, int*);
	BOOL (*pfnSymbolToCharacterW)(SYV*, int, WCHAR*, int*);
	int (*pfnDestroyHRCRESULT)(HRCRESULT);
	
	HWL (*pfnCreateHWL)(HREC hrec, LPSTR lpsz, UINT uType, DWORD dwReserved);
	int (*pfnDestroyHWL)(HWL hwl);
	int (*pfnSetWordlistHRC)(HRC hrc, HWL hwl);
	int (*pfnSetMaxResultsHRC)(HRC hrc, UINT cAltMax);
	int (*pfnDestroyHRC)(HRC);
	
	BOOL (*pfnIsStringSupportedHRC)(HRC, char*);
	int (*pfnGetAlternateWordsHRCRESULT)(HRCRESULT, UINT, UINT, HRCRESULT*, UINT);

	HINKSET (*pfnCreateInksetHRCRESULT)(HRCRESULT hrcresult, unsigned int iSyv, unsigned int cSyv);
	BOOL (*pfnDestroyInkset)(HINKSET hInkset);
	int (*pfnGetInksetInterval)(HINKSET hInkset, unsigned int uIndex, INTERVAL *pI);
	int (*pfnGetInksetIntervalCount)(HINKSET hInkset);

	DWORD (*pfnGetTiming)(void *, BOOL);
	int (*pfnGetMsgTiming)(DWORD **);
} DllInfo;


// Loads a DLL function specified by name, and either returns its pointer or returns
// NULL if it cannot find the function.  In that case a warning is displayed for
// the user.

static void *LoadCall(HINSTANCE hDll, const char *name)
{
	void *fn = GetProcAddress(hDll, name);

	return fn;
}

static int LoadAPI(DllInfo *pDllInfo)
{
	pDllInfo->pfnCreateCompatibleHRC = (HRC (*) (HRC, HREC))LoadCall(pDllInfo->hDll, APINAME_CreateCompatibleHRC);

	pDllInfo->pfnSetAlphabetHRC = (int (*) (HRC, ALC, LPBYTE))LoadCall(pDllInfo->hDll, APINAME_SetAlphabetHRC);
	pDllInfo->pfnSetRecogSpeedHRC = (int (*) (HRC, int))LoadCall(pDllInfo->hDll, APINAME_SetRecogSpeedHRC);
	pDllInfo->pfnSetGuideHRC = (int (*) (HRC, GUIDE*, UINT))LoadCall(pDllInfo->hDll, APINAME_SetGuideHRC);
	pDllInfo->pfnEnableSystemDictionaryHRC = (int (*) (HRC, int))LoadCall(pDllInfo->hDll, APINAME_EnableSystemDictionaryHRC);
	pDllInfo->pfnEnableLangModelHRC = (int (*) (HRC, int))LoadCall(pDllInfo->hDll, APINAME_EnableLangModelHRC);

	pDllInfo->pfnAddPenInputHRC = (int (*) (HRC, POINT*, void*, UINT, STROKEINFO*))LoadCall(pDllInfo->hDll, APINAME_AddPenInputHRC);
	pDllInfo->pfnHwxSetAnswer = (int (*) (char*))LoadCall(pDllInfo->hDll, APINAME_HwxSetAnswer);
	pDllInfo->pfnProcessHRC = (int (*) (HRC, DWORD))LoadCall(pDllInfo->hDll, APINAME_ProcessHRC);
	pDllInfo->pfnGetMaxResultsHRC = (int (*) (HRC))LoadCall(pDllInfo->hDll, APINAME_GetMaxResultsHRC);
	pDllInfo->pfnGetResultsHRC = (int (*) (HRC, UINT, HRCRESULT*, UINT))LoadCall(pDllInfo->hDll, APINAME_GetResultsHRC);
	pDllInfo->pfnGetSymbolCountHRCRESULT = (int (*) (HRCRESULT))LoadCall(pDllInfo->hDll, APINAME_GetSymbolCountHRCRESULT);
	pDllInfo->pfnGetSymbolsHRCRESULT = (int (*) (HRCRESULT, UINT, SYV*, UINT))LoadCall(pDllInfo->hDll, APINAME_GetSymbolsHRCRESULT);
	pDllInfo->pfnSymbolToCharacter = (BOOL (*) (SYV*, int, char*, int*))LoadCall(pDllInfo->hDll, APINAME_SymbolToCharacter);
	pDllInfo->pfnSymbolToCharacterW = (BOOL (*) (SYV*, int, WCHAR*, int*))LoadCall(pDllInfo->hDll, APINAME_SymbolToCharacterW);
	pDllInfo->pfnDestroyHRCRESULT = (int (*)(HRCRESULT))LoadCall(pDllInfo->hDll, APINAME_DestroyHRCRESULT);
	pDllInfo->pfnDestroyHRC = (int (*) (HRC))LoadCall(pDllInfo->hDll, APINAME_DestroyHRC);
    pDllInfo->pfnIsStringSupportedHRC = (BOOL (*)(HRC, char*)) LoadCall(pDllInfo->hDll, APINAME_IsStringSupportedHRC);
	pDllInfo->pfnGetAlternateWordsHRCRESULT = (int (*)(HRCRESULT, UINT, UINT, HRCRESULT*, UINT))LoadCall(pDllInfo->hDll, APINAME_GetAlternateWordsHRCRESULT);
	pDllInfo->pfnGetTiming = (DWORD (*)(void *, BOOL))LoadCall(pDllInfo->hDll, APINAME_HwxGetTiming);
	pDllInfo->pfnGetMsgTiming = (int (*)(DWORD **))LoadCall(pDllInfo->hDll, APINAME_GetMsgTiming);

	pDllInfo->pfnDestroyHWL = (int (*) (HWL)) LoadCall(pDllInfo->hDll, APINAME_DestroyHWL);
	pDllInfo->pfnSetWordlistHRC = (int (*) (HRC, HWL)) LoadCall(pDllInfo->hDll, APINAME_SetWordlistHRC);
	pDllInfo->pfnCreateHWL = (HWL (*) (HREC, LPSTR, UINT, DWORD)) LoadCall(pDllInfo->hDll, APINAME_CreateHWL);
	pDllInfo->pfnHwxGetNeuralOutput = (int (*) (HRC, void *, UINT)) GetProcAddress(pDllInfo->hDll, APINAME_HwxGetNeuralOutput);
	pDllInfo->pfnHwxGetInputFeatures = (int (*) (HRC, unsigned short *, UINT)) GetProcAddress(pDllInfo->hDll, APINAME_HwxGetInputFeatures);
	pDllInfo->pfnCreateInksetHRCRESULT = (HINKSET (*) (HRCRESULT, UINT, UINT)) LoadCall(pDllInfo->hDll, APINAME_CreateInksetHRCRESULT);
	pDllInfo->pfnDestroyInkset = (int (*) (HINKSET)) LoadCall(pDllInfo->hDll, APINAME_DestroyInkset);
	pDllInfo->pfnGetInksetInterval = (int (*) (HINKSET, unsigned int, INTERVAL *)) LoadCall(pDllInfo->hDll, APINAME_GetInksetInterval);
	pDllInfo->pfnGetInksetIntervalCount = (int (*) (HINKSET)) LoadCall(pDllInfo->hDll, APINAME_GetInksetIntervalCount);

	pDllInfo->pfnGetCostHRCRESULT = (int (*)(HRCRESULT))LoadCall(pDllInfo->hDll, APINAME_GetCostHRCRESULT);
	pDllInfo->pfnEndPenInputHRC = (int (*) (HRC))LoadCall(pDllInfo->hDll, APINAME_EndPenInputHRC);
	pDllInfo->pfnHwxGetWordResults = (int (*) (HRC, UINT, char*, UINT))LoadCall(pDllInfo->hDll, APINAME_HwxGetWordResults);
	pDllInfo->pfnHwxGetCosts = (int (*) (HRC, UINT, int *))LoadCall(pDllInfo->hDll, APINAME_HwxGetCosts);

	return 1;
}

void *OpenRecognizer(const char *pName)
{
	HINSTANCE		hDll;				// Handle to the loaded DLL
	DllInfo			*pDllInfo;	
	char			*psTime;
	struct _stat	dllStat;

	if (!pName)
	{
		return NULL;
	}

	hDll = LoadLibrary(pName);
	if (!hDll)
	{
/*
		LPVOID lpMsgBuf;
		
		FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			GetLastError(),
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL 
		);
		MessageBox(NULL, (LPCTSTR)lpMsgBuf, "WARNING", MB_OK | MB_ICONWARNING); 

		LocalFree(lpMsgBuf);
*/
		return NULL;
	}

	pDllInfo = malloc(sizeof(*pDllInfo));
	ASSERT(pDllInfo);
	if (!pDllInfo)
	{
		return pDllInfo;
	}

	memset(pDllInfo, 0, sizeof(*pDllInfo));
	pDllInfo->hDll = hDll;
	LoadAPI(pDllInfo);

	if (0 == _stat(pName, &dllStat))
	{
		pDllInfo->cDLLSize = dllStat.st_size;
		psTime = ctime(&dllStat.st_mtime);

		if (psTime)
		{
			strcpy((char *)pDllInfo->pszDLLTime, psTime);
		}
	}

	strcpy((char *)pDllInfo->acDllName, pName);

	return pDllInfo;
}

void CloseRecognizer(void *pv)
{
	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->hDll)
	{
		return;
	}

	if (pDllInfo->hDll)
	{
		FreeLibrary(pDllInfo->hDll);
	}

	// Defensive in case some tries to use this pointer again
	memset(pDllInfo, 0, sizeof(*pDllInfo));
	free(pDllInfo);
}


const char *DoRecogDLLName(void *pv)
{
	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->hDll)
	{
		return NULL;
	}

	return pDllInfo->acDllName;
}

int DoConfigRecognizer(void *pv, unsigned int uSubFunc, WPARAM wParam, LPARAM lParam)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnConfigRecognizer)
	{
		return HRCR_UNSUPPORTED;
	}

	return pDllInfo->pfnConfigRecognizer(uSubFunc, wParam, lParam);
}


HRC DoCreateCompatibleHRC(void *pv, HRC hrc, HREC hrecUnused)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnCreateCompatibleHRC)
	{
		return NULL;
	}
	return pDllInfo->pfnCreateCompatibleHRC(hrc, hrecUnused);
}

int DoSetAlphabetHRC(void *pv, HRC hrc, ALC alc, LPBYTE pbUnused)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSetAlphabetHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSetAlphabetHRC(hrc, alc, pbUnused);
}

int DoSetGuideHRC(void *pv, HRC hrc, LPGUIDE lpguide,  UINT nFirstVisible)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSetGuideHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSetGuideHRC(hrc, lpguide,  nFirstVisible);
}

int DoSetRecogSpeedHRC(void *pv, HRC hrc, int iSpeed)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSetRecogSpeedHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSetRecogSpeedHRC(hrc, iSpeed);
}

int DoDestroyHRC(void *pv, HRC hrc)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnDestroyHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnDestroyHRC(hrc);
}

int DoAddPenInputHRC(void *pv, HRC hrc, POINT *rgPoint, LPVOID lpvUnused, UINT uiUnused, STROKEINFO *pSi)
{	
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnAddPenInputHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnAddPenInputHRC(hrc, rgPoint, lpvUnused, uiUnused, pSi);
}

int DoEndPenInputHRC(void *pv, HRC hrc)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnEndPenInputHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnEndPenInputHRC(hrc);
}


int DoProcessHRC(void *pv, HRC hrc, DWORD dwUnused)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnProcessHRC)
	{
		return HRCR_UNSUPPORTED;
	}

	return pDllInfo->pfnProcessHRC(hrc, dwUnused);
}

int DoHwxGetWordResults(void *pv, HRC hrc, UINT cAlt, char *buffer, UINT buflen)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnHwxGetWordResults)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnHwxGetWordResults(hrc, cAlt, buffer, buflen);
}

// private API (previously used by the demo app)

int DoHwxGetCosts(void *pv, HRC hrc, UINT cAltMax, int *rgCost)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnHwxGetCosts)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnHwxGetCosts(hrc, cAltMax, rgCost);
}

int DoHwxGetNeuralOutput(void *pv, HRC hrc, void *buffer, UINT buflen)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnHwxGetNeuralOutput)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnHwxGetNeuralOutput(hrc, buffer, buflen);
}

int DoHwxGetInputFeatures(void *pv, HRC hrc, unsigned short *rgFeat, UINT cWidth)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnHwxGetInputFeatures)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnHwxGetInputFeatures(hrc, rgFeat, cWidth);
}

int DoHwxSetAnswer(void *pv, char *sz)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnHwxSetAnswer)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnHwxSetAnswer(sz);
}

int DoSetWordlistCoercionHRC(void *pv, HRC hrc, UINT uCoercion)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSetWordlistCoercionHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSetWordlistCoercionHRC(hrc, uCoercion);
}

HWL DoCreateHWL(void *pv, HREC hrec, LPSTR lpsz, UINT uType, DWORD dwReserved)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnCreateHWL)
	{
		return NULL;
	}
	return pDllInfo->pfnCreateHWL(hrec, lpsz, uType, dwReserved);
}

int DoDestroyHWL(void *pv, HWL hwl)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnDestroyHWL)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnDestroyHWL(hwl);
}

int DoSetWordlistHRC(void *pv, HRC hrc, HWL hwl)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSetWordlistHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSetWordlistHRC(hrc, hwl);
}

int DoEnableSystemDictionaryHRC(void *pv, HRC hrc, BOOL fEnable)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnEnableSystemDictionaryHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnEnableSystemDictionaryHRC(hrc, fEnable);
}

int DoEnableLangModelHRC(void *pv, HRC hrc, BOOL fEnable)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnEnableLangModelHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnEnableLangModelHRC(hrc, fEnable);
}

BOOL DoIsStringSupportedHRC(void *pv, HRC hrc, unsigned char *sz)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnIsStringSupportedHRC)
	{
		return HRCR_UNSUPPORTED;
	}

	return pDllInfo->pfnIsStringSupportedHRC(hrc, sz);
}

// New functions (by Jay) for supporting the PenWindows results reporting.

int DoGetMaxResultsHRC(void *pv, HRC hrc)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetMaxResultsHRC)
	{
		return HRCR_UNSUPPORTED;
	}

	return pDllInfo->pfnGetMaxResultsHRC(hrc);
}

int DoSetMaxResultsHRC(void *pv, HRC hrc, UINT cAltMax)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSetMaxResultsHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSetMaxResultsHRC(hrc, cAltMax);
}

int DoGetResultsHRC(void *pv, HRC hrc, UINT uType, HRCRESULT *pResults, UINT cResults)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetResultsHRC)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetResultsHRC(hrc, uType, pResults, cResults);
}

// This isn't really right.  If we pass in an hrcresult that a word result,
// and is not a top-level member of the hrc answers, we will not
// return its alternates.  This is because the backpointer should not
// be a pointer to the HRC, but a pointer to the ALTERNATES of which it
// is a member (and then the ALTERNATES would need a backpointer to the HRC).

int DoGetAlternateWordsHRCRESULT(void *pv, HRCRESULT hrcresult, UINT iSyv, UINT cSyv, HRCRESULT *pResults, UINT cResults)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetAlternateWordsHRCRESULT)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetAlternateWordsHRCRESULT(hrcresult, iSyv, cSyv, pResults, cResults);
}

// Does not include null symbol at the end.

int DoGetSymbolsHRCRESULT(void *pv, HRCRESULT hrcresult, UINT iSyv, SYV *pSyv, UINT cSyv)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetSymbolsHRCRESULT)
	{
		return HRCR_UNSUPPORTED;
	}
	if (!cSyv || !hrcresult)
		return 0;

	return pDllInfo->pfnGetSymbolsHRCRESULT(hrcresult, iSyv, pSyv, cSyv);
}

// Does not include null symbol at the end.

int DoGetSymbolCountHRCRESULT(void *pv, HRCRESULT hrcresult)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetSymbolCountHRCRESULT)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetSymbolCountHRCRESULT(hrcresult);
}

BOOL DoSymbolToCharacter(void *pv, SYV *pSyv, int cSyv, char *sz, int *pConv)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSymbolToCharacter)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSymbolToCharacter(pSyv, cSyv, sz, pConv);
}

BOOL DoSymbolToCharacterW(void *pv, SYV *pSyv, int cSyv, WCHAR *wsz, int *pConv)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnSymbolToCharacterW)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnSymbolToCharacterW(pSyv, cSyv, wsz, pConv);
}

int DoGetCostHRCRESULT(void *pv, HRCRESULT hrcresult)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetCostHRCRESULT)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetCostHRCRESULT(hrcresult);
}

int DoDestroyHRCRESULT(void *pv, HRCRESULT hrcresult)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnDestroyHRCRESULT)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnDestroyHRCRESULT(hrcresult);
}

HINKSET DoCreateInksetHRCRESULT(void *pv, HRCRESULT hrcresult, unsigned int iSyv, unsigned int cSyv)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnCreateInksetHRCRESULT)
	{
		return NULL;
	}
	return pDllInfo->pfnCreateInksetHRCRESULT(hrcresult, iSyv, cSyv);
}

BOOL DoDestroyInkset(void *pv, HINKSET hInkset)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnDestroyInkset)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnDestroyInkset(hInkset);
}

int DoGetInksetInterval(void *pv, HINKSET hInkset, unsigned int uIndex, INTERVAL *pI)
{
	XINKSET *pInk = (XINKSET *)hInkset;

 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetInksetInterval)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetInksetInterval(hInkset, uIndex, pI);
}

int DoGetInksetIntervalCount(void *pv, HINKSET hInkset)
{
	XINKSET *pInk = (XINKSET *)hInkset;

 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetInksetIntervalCount)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetInksetIntervalCount(hInkset);
}

DWORD DoGetTiming(void *pv, void *pVoid, BOOL bReset)
{
 	DllInfo			*pDllInfo = pv;	

	if (!pDllInfo || !pDllInfo->pfnGetTiming)
	{
		return HRCR_UNSUPPORTED;
	}
	return pDllInfo->pfnGetTiming(pVoid, bReset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\quicktrie.c ===
// FILE: QuickTrie.c
//
// Code to access a small trie created by the QuickTrie program.
// Note that internal states are off by one from external so that we
// can reserve 0 as being above the root of the trie.
#include "common.h"
#include "quicktrie.h"

// Go down one level in the trie.  Initial state of 0 to start trie.
WCHAR
FirstChildQuickTrie(DWORD *hState)
{
	DWORD	state;

	// Check for initial state.
	if (*hState == 0) {
		*hState		= 1;
		return g_aQuickTrie[0].label;
	}

	// OK already in trie.
	state	= *hState - 1;

	// Do we have a down pointer
	state	= g_aQuickTrie[state].oDown;
	if (!state) {
		return (WCHAR)0;
	}

	// Ok, update state and return results.
	*hState	= state + 1;
	return g_aQuickTrie[state].label;
}

// Get next alternate at current level of trie.
WCHAR	NextSiblingQuickTrie(DWORD *hState)
{
	DWORD	state;

	// Get internal state value.
	state	= *hState - 1;

	// Do we have a node to the right
	if (g_aQuickTrie[state].flags & QT_FLAG_END) {
		return (WCHAR)0;
	}
	++state;

	// Ok, update state and return results.
	*hState	= state + 1;
	return g_aQuickTrie[state].label;

}

// Is the valid flag set on the current state.
BOOL
IsValidQuickTrie(DWORD state)
{
	// Get internal state value.
	--state;

	return !!(g_aQuickTrie[state].flags & QT_FLAG_VALID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\sjis.c ===
/******************************Module*Header*******************************\
* Module Name: sjis.c
*
* Single byte <--> Double byte code.  Not needed in final Pegasus DLL
*
* Created: 02-Oct-1996 08:28:15
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "common.h"
#include "xjis.h"

const WORD mpSbcsDbcs[CHAR_LASTSBCS - CHAR_FIRSTSBCS + 1] =
{
	0x8140, // 0x20
	0x8149, // 0x21
	0x8168, // 0x22
	0x8194, // 0x23
	0x8190, // 0x24
	0x8193, // 0x25
	0x8195, // 0x26
	0x8166, // 0x27
	0x8169, // 0x28
	0x816a, // 0x29
	0x8196, // 0x2a
	0x817b, // 0x2b
	0x8143, // 0x2c
    0x817c, // 0x2d
	0x8144, // 0x2e
	0x815e, // 0x3f
	0x824f, // 0x30
	0x8250, // 0x31
	0x8251, // 0x32
	0x8252, // 0x33
	0x8253, // 0x34
	0x8254, // 0x35
	0x8255, // 0x36
	0x8256, // 0x37
	0x8257, // 0x38
	0x8258, // 0x39
	0x8146, // 0x3a
	0x8147, // 0x3b
	0x8183, // 0x3c
	0x8181, // 0x3d
	0x8184, // 0x3e
	0x8148, // 0x3f
	0x8197, // 0x40
	0x8260, // 0x41
	0x8261, // 0x42
	0x8262, // 0x43
	0x8263, // 0x44
	0x8264, // 0x45
	0x8265, // 0x46
	0x8266, // 0x47
	0x8267, // 0x48
	0x8268, // 0x49
	0x8269, // 0x4a
	0x826a, // 0x4b
	0x826b, // 0x4c
	0x826c, // 0x4d
	0x826d, // 0x4e
	0x826e, // 0x4f
	0x826f, // 0x50
	0x8270, // 0x51
	0x8271, // 0x52
	0x8272, // 0x53
	0x8273, // 0x54
	0x8274, // 0x55
	0x8275, // 0x56
	0x8276, // 0x57
	0x8277, // 0x58
	0x8278, // 0x59
	0x8279, // 0x5a
	0x816d, // 0x5b
	0x818f, // 0x5c
	0x816e, // 0x5d
	0x814f, // 0x5e
	0x8151, // 0x5f
	0x814d, // 0x60
	0x8281, // 0x61
	0x8282, // 0x62
	0x8283, // 0x63
	0x8284, // 0x64
	0x8285, // 0x65
	0x8286, // 0x66
	0x8287, // 0x67
	0x8288, // 0x68
	0x8289, // 0x69
	0x828a, // 0x6a
	0x828b, // 0x6b
	0x828c, // 0x6c
	0x828d, // 0x6d
	0x828e, // 0x6e
	0x828f, // 0x6f
	0x8290, // 0x70
	0x8291, // 0x71
	0x8292, // 0x72
	0x8293, // 0x73
	0x8294, // 0x74
	0x8295, // 0x75
	0x8296, // 0x76
	0x8297, // 0x77
	0x8298, // 0x78
	0x8299, // 0x79
	0x829a, // 0x7a
	0x816f, // 0x7b
	0x8162, // 0x7c
	0x8170, // 0x7d
	0x8160  // 0x7e
};

const WORD mpchkatawkata[CHAR_LASTKATA - CHAR_FIRSTKATA + 1] =
{
	0x8142, // 0xa1
	0x8175, // 0xa2
	0x8176, // 0xa3
	0x8141, // 0xa4
	0x8145, // 0xa5
	0x8392, // 0xa6
	0x8340, // 0xa7
	0x8342, // 0xa8
	0x8344, // 0xa9
	0x8346, // 0xaa
	0x8348, // 0xab
	0x8383, // 0xac
	0x8385, // 0xad
	0x8387, // 0xae
	0x8362, // 0xaf
	0x815B, // 0xb0
	0x8341, // 0xb1
	0x8343, // 0xb2
	0x8345, // 0xb3
	0x8347, // 0xb4
	0x8349, // 0xb5
	0x834a, // 0xb6
	0x834c, // 0xb7
	0x834e, // 0xb8
	0x8350, // 0xb9
	0x8352, // 0xba
	0x8354, // 0xbb
	0x8356, // 0xbc
	0x8358, // 0xbd
	0x835a, // 0xbe
	0x835c, // 0xbf
	0x835e, // 0xc0
	0x8360, // 0xc1
	0x8363, // 0xc2
	0x8365, // 0xc3
	0x8367, // 0xc4
	0x8369, // 0xc5
	0x836a, // 0xc6
	0x836b, // 0xc7
	0x836c, // 0xc8
	0x836d, // 0xc9
	0x836e, // 0xca
	0x8371, // 0xcb
	0x8374, // 0xcc
	0x8377, // 0xcd
	0x837a, // 0xce
	0x837d, // 0xcf
	0x837e, // 0xd0
	0x8380, // 0xd1
	0x8381, // 0xd2
	0x8382, // 0xd3
	0x8384, // 0xd4
	0x8386, // 0xd5
	0x8388, // 0xd6
	0x8389, // 0xd7
	0x838a, // 0xd8
	0x838b, // 0xd9
	0x838c, // 0xda
	0x838d, // 0xdb
	0x838f, // 0xdc
	0x8393, // 0xdd
	0x814a, // 0xde
	0x814b  // 0xdf
};

// mpwkanachkana and mpwpuncchpunc convert double byte characters back to single byte.

const BYTE mpwkanachkana[KANA_LASTMAP - KANA_FIRSTMAP + 1] =
{
0xA7,   // 0x8340
0xB1,   // 0x8341
0xA8,   // 0x8342
0xB2,   // 0x8343
0xA9,   // 0x8344
0xB3,   // 0x8345
0xAA,   // 0x8346
0xB4,   // 0x8347
0xAB,   // 0x8348
0xB5,   // 0x8349
0xB6,   // 0x834a
0,      // 0x834b
0xB7,   // 0x834c
0,      // 0x834d
0xB8,   // 0x834e
0,      // 0x834f
0xB9,   // 0x8350
0,      // 0x8351
0xBA,   // 0x8352
0,      // 0x8353
0xBB,   // 0x8354
0,      // 0x8355
0xBC,   // 0x8356
0,      // 0x8357
0xBD,   // 0x8358
0,      // 0x8359
0xBE,   // 0x835a
0,      // 0x835b
0xBF,   // 0x835c
0,      // 0x835d
0xC0,   // 0x835e
0,      // 0x835f
0xC1,   // 0x8360
0,      // 0x8361
0xAF,   // 0x8362
0xC2,   // 0x8363
0,      // 0x8364
0xC3,   // 0x8365
0,      // 0x8366
0xC4,   // 0x8367
0,      // 0x8368
0xC5,   // 0x8369
0xC6,   // 0x836a
0xC7,   // 0x836b
0xC8,   // 0x836c
0xC9,   // 0x836d
0xCA,   // 0x836e
0,      // 0x836f
0,      // 0x8370
0xCB,   // 0x8371
0,      // 0x8372
0,      // 0x8373
0xCC,   // 0x8374
0,      // 0x8375
0,      // 0x8376
0xCD,   // 0x8377
0,      // 0x8378
0,      // 0x8379
0xCE,   // 0x837a
0,      // 0x837b
0,      // 0x837c
0xCF,   // 0x837d
0xD0,   // 0x837e
0,      // 0x837f
0xD1,   // 0x8380
0xD2,   // 0x8381
0xD3,   // 0x8382
0xAC,   // 0x8383
0xD4,   // 0x8384
0xAD,   // 0x8385
0xD5,   // 0x8386
0xAE,   // 0x8387
0xD6,   // 0x8388
0xD7,   // 0x8389
0xD8,   // 0x838a
0xD9,   // 0x838b
0xDA,   // 0x838c
0xDB,   // 0x838d
0,      // 0x838e
0xDC,   // 0x838f
0,      // 0x8390
0,      // 0x8391
0xA6,   // 0x8392
0xDD    // 0x8393
};

const BYTE mpwpuncchpunc[PUNC_LASTMAP - PUNC_FIRSTMAP + 1] = {
0x20,   // 0x8140
0xA4,   // 0x8141
0xA1,   // 0x8142
0x2C,   // 0x8143 ,
0x2E,   // 0x8144 .
0xA5,   // 0x8145
0x3A,   // 0x8146 :
0x3B,   // 0x8147 ;
0x3F,   // 0x8148 ?
0x21,   // 0x8149 !
0xDE,   // 0x814A
0xDF,   // 0x814B
0,      // 0x814C
0x60,   // 0x814D
0,      // 0x814E
0x5E,   // 0x814F ^
0,      // 0x8150
0x5F,   // 0x8151
0,      // 0x8152
0,      // 0x8153
0,      // 0x8154
0,      // 0x8155
0,      // 0x8156
0,      // 0x8157
0,      // 0x8158
0,      // 0x8159
0,      // 0x815A
0xB0,   // 0x815B
0,      // 0x815C
0x2D,   // 0x815D -
0x2F,   // 0x815E /
0x5C,   // 0x815F
0x7E,   // 0x8160
0,      // 0x8161
0x7C,   // 0x8162
0,      // 0x8163
0,      // 0x8164
0x27,   // 0x8165
0x27,   // 0x8166
0x22,   // 0x8167
0x22,   // 0x8168
0x28,   // 0x8169 (
0x29,   // 0x816A )
0,      // 0x816B
0,      // 0x816C
0x5B,   // 0x816D [
0x5D,   // 0x816E ]
0x7B,   // 0x816F {
0x7D,   // 0x8170 }
0,      // 0x8171
0,      // 0x8172
0,      // 0x8173
0,      // 0x8174
0xA2,   // 0x8175
0xA3,   // 0x8176
0,      // 0x8177
0,      // 0x8178
0,      // 0x8179
0,      // 0x817A
0x2B,   // 0x817B +
0x2D,   // 0x817C -
0,      // 0x817D
0,      // 0x817E
0,      // 0x817F
0,      // 0x8180
0x3D,   // 0x8181 =
0,      // 0x8182
0x3C,   // 0x8183 <
0x3E,   // 0x8184 >
0,      // 0x8185
0,      // 0x8186
0,      // 0x8187
0,      // 0x8188
0,      // 0x8189
0,      // 0x818A
0,      // 0x818B
0,      // 0x818C
0,      // 0x818D
0,      // 0x818E
0x5C,   // 0x818F
0x24,   // 0x8190 $
0,      // 0x8191
0,      // 0x8192
0x25,   // 0x8193 %
0x23,   // 0x8194 #
0x26,   // 0x8195 &
0x2A,   // 0x8196 *
0x40    // 0x8197 @
};

// Maps a 'syv' to a wide XJIS value.  Single byte codes are converted to double
// byte in the process.  So no half-width characters should make it past this function

WORD XJISFromSYV(SYV syv)
{
	WORD	wRet;

	syv &= 0x0000ffff;

	if (syv < 0x0100)
	{
		if (syv >= CHAR_FIRSTSBCS && syv <= CHAR_LASTSBCS)
			wRet = mpSbcsDbcs[(int)(syv - CHAR_FIRSTSBCS)];
		else if (syv >= CHAR_FIRSTKATA && syv <= CHAR_LASTKATA)
			wRet = mpchkatawkata[(int)(syv - CHAR_FIRSTKATA)];
		else
			wRet = 0;
	}
	else
		wRet = (WORD) syv;

	return wRet;
}

/******************************Public*Routine******************************\
* IsSupportedCharWORD
*
* This tells if the DBCS character is supported by Rodan.  This is used to
* filter training data and testing data when determining our accuracy
* numbers.
*
* History:
*  05-Dec-1994 -by- Patrick Haluptzok patrickh
* Put it here
\**************************************************************************/

BOOL SupportedXJIS(WORD wxjis)
{
	if (wxjis < 0x824f)
    {
        switch (wxjis)     // Not all punc/symbols are supported.
        {
			case 0x8141:
			case 0x8142:
			case 0x8143:
			case 0x8144:
			case 0x8145:
			case 0x8146:
			case 0x8147:
			case 0x8148:
			case 0x8149:
			case 0x814a:
            case 0x814b:
            case 0x814f:  // '^' Needed for circle gesture, it's a math symbol.
			case 0x8154:
			case 0x8155:
			case 0x8156:
			case 0x8158:
			case 0x8159:
			case 0x815b:
			case 0x815c:
			case 0x815d:
			case 0x815e:
			case 0x815f:
            case 0x8160:
            case 0x8163:
			case 0x8165:
			case 0x8166:
			case 0x8167:
			case 0x8168:
			case 0x8169:
			case 0x816a:
			case 0x816d:
			case 0x816e:
			case 0x816f:
			case 0x8170:
			case 0x8173:
			case 0x8174:
			case 0x8175:
			case 0x8176:
			case 0x817b:
			case 0x817c:
			case 0x817e:
			case 0x8180:
			case 0x8181:
			case 0x8183:
			case 0x8184:
			case 0x818e:
			case 0x818f:
			case 0x8190:
			case 0x8191:
			case 0x8192:
			case 0x8193:
			case 0x8194:
			case 0x8195:
			case 0x8196:
			case 0x8197:
			case 0x81a7:
				return(TRUE);
        }
    }
    else if (wxjis >= 0x824f && wxjis <= 0x8258)
    {
        return(TRUE); // All numbers
    }
    else if (wxjis >= 0x8260 && wxjis <= 0x8279)
    {
        return(TRUE); // All upper
    }
    else if (wxjis >= 0x8281 && wxjis <= 0x829a)
    {
        return(TRUE); // All lower
    }
    else if (wxjis >= 0x829f && wxjis <= 0x82f1)
    {
        return(TRUE); // All hira
    }
    else if (wxjis >= 0x8340 && wxjis <= 0x8396)
    {
        return(TRUE); // All kata
    }
    else if (wxjis >= 0x889f && wxjis <= 0x9872)
    {
        return(TRUE); // All JIS1 supported
    }
	else if (wxjis > 0x9872)
    {
        return(TRUE);  // All JIS2 supported
    }

	return(FALSE);
}

// Convert the XJIS value to a TOKEN

WORD TokenFromWORD(WORD wDbcs)
{
	WORD	imatch, itoken;

	for (itoken = 0; itoken <= (TOKEN_LAST - TOKEN_FIRST); itoken++)
	{
		for (imatch = 0; imatch < KANJI_MATCHMAX; imatch++)
		{
			if (mptokenwmatches[itoken][imatch] == 0)
				break;
			else if (mptokenwmatches[itoken][imatch] == wDbcs)
				return (TOKEN_FIRST + itoken);
		}
	}

	return 0;
}

SYV SBCSFromDBCS(wchar_t wDbcs)
{
	SYV syvRet;

	if (wDbcs >= KANA_FIRSTMAP && wDbcs <= KANA_LASTMAP)
		syvRet = SyvCharacterToSymbol(mpwkanachkana[wDbcs - KANA_FIRSTMAP]);
	else if ((wDbcs >= 0x824f && wDbcs <= 0x8258) ||
		// numeral
		(wDbcs >= 0x8260 && wDbcs <= 0x8279))
		// upper-case
		syvRet = SyvCharacterToSymbol((char)(wDbcs - 0x821f));
	else if (wDbcs >= 0x8281 && wDbcs <= 0x829a)
		// lower-case
		syvRet = SyvCharacterToSymbol((char)(wDbcs - 0x8220));
	else if (wDbcs >= PUNC_FIRSTMAP && wDbcs <= PUNC_LASTMAP)
		syvRet = SyvCharacterToSymbol(mpwpuncchpunc[wDbcs - PUNC_FIRSTMAP]);
	else
		syvRet = SyvKanjiToSymbol(wDbcs);

    // Added following "if" 5/18/95, Angshuman
    if (syvRet == 0x00010000)
        syvRet = SyvKanjiToSymbol(wDbcs);

	return(syvRet);
}

WORD GetFirstMatch(WORD wdbcs)
{
		WORD	wMatch;
const	WORD   *rgwMatches;

	if (wMatch = TokenFromWORD(wdbcs))
	{
		rgwMatches = pwListFromToken(wMatch);
		wdbcs = rgwMatches[0];
	}

	return wdbcs;
}

/******************************Public*Routine******************************\
* StaticNumberOfSamples
*
* Returns the number of samples on which we trained for each glyph
*
* History:
*  27-Nov-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern const unsigned short gaiStaticLabelCnt[][2];
extern int giStaticLabelCnt;

int StaticNumberOfSamples(WORD wCurrent)
{
	int		iMin;
	int		iMax;
	int		iNew;
	WORD	wNew;

	iMin = 0;
    iMax = giStaticLabelCnt - 1;

	while (iMin < iMax)
	{
		iNew = (iMin + iMax) / 2;

        wNew = gaiStaticLabelCnt[iNew][0];

		if (wNew < wCurrent)
		{
			iMin = iNew + 1;
			continue;
		}
		else if (wNew > wCurrent)
		{
			iMax = iNew - 1;
			continue;
		}

        return(gaiStaticLabelCnt[iNew][1]);
	}

    return gaiStaticLabelCnt[iMin][0] == wCurrent ? gaiStaticLabelCnt[iMin][1] : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\runnet.c ===
/************************************************************
 *
 * runNet.c
 *
 * Bare bones net. 
 * Use this implementation to build and run a net
 *
 * mrevow
 *
 ***********************************************************/
#include <common.h>
#include <runNet.h>
#include <math.h>
#include <math16.h>
#include <limits.h>

// Adjust pBuf to ensure it is an integral multiple of size offset from pStart. 
#define SYNC_BUFF_PNT(pStart, pBuf, size, type) {int cRem; ASSERT((BYTE *)pBuf > (BYTE *)pStart); \
						 if ( (cRem = (((BYTE *)pBuf - (BYTE *)pStart)%size)) > 0) 	pBuf = (type)((BYTE *)pBuf + size - cRem);	}

// Restore a RUN net by assigning members from a
// memory image. Avoid copying where possible
// Returns pointer to next memory location passed the
// last used
BYTE *restoreRunNet(
BYTE		*pBuf,				// IN: Start of memory image
BYTE		*pBCurr,			// IN: Next entry into memory image
RUN_NET		*pNet,				// OUT: Run net structure 
WORD		iVer				// IN: Version number
)
{
	WORD		*pB = (WORD *)pBCurr;
	int			i;

	if (!pBuf || !pNet || !pB)
	{
		return NULL;
	}

	pNet->iVer = iVer;

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cLayer), WORD*)
	pNet->cLayer = *(pB++);
	if (pNet->iVer >= RUN_NET_VER_10)
	{
		// Loss Unit and Txfer Types present
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->lossType), WORD*)
		pNet->lossType = *(LOSS_TYPE *)pB;
		pB += sizeof(pNet->lossType) / sizeof(*pB);
	
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->txfType), WORD*);
		pNet->txfType = (TXF_TYPE *)pB;
		pB += sizeof(*pNet->txfType) / sizeof(*pB) * pNet->cLayer;

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->layerType), WORD*);
		pNet->layerType = (LAYER_TYPE *)pB;
		pB += sizeof(*pNet->layerType) / sizeof(*pB) * pNet->cLayer;
	}

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cWeight), WORD*)
	pNet->cWeight = *(pB++);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cTotUnit), WORD*)
	pNet->cTotUnit = *(pB++);
	
	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cWeight), WORD*)
	pNet->cUnitsPerLayer = pB;
	pB += pNet->cLayer;

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->bUseBias), WORD*)
	pNet->bUseBias = pB;
	pB += pNet->cLayer;

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pWeightScale), WORD*)
	pNet->pWeightScale = pB;
	pB += pNet->cLayer;

	if (pNet->iVer >= RUN_NET_VER_11)
	{
		// Some Integrity checks
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->iInputScaledMeanDataSize), WORD*)
		pNet->iInputScaledMeanDataSize =*(pB++);
		if (pNet->iInputScaledMeanDataSize != sizeof(*pNet->pInputScaledMean))
		{
			return NULL;
		}

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->iInputRangeDataSize), WORD*)
		pNet->iInputRangeDataSize =*(pB++);
		if (pNet->iInputRangeDataSize != sizeof(*pNet->pInputRange))
		{
			return NULL;
		}

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->iWeightDataSize), WORD*)
		pNet->iWeightDataSize =*(pB++);
		if (pNet->iWeightDataSize != sizeof(*pNet->pWeight))
		{
			return NULL;
		}

		SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pInputRange), WORD*)
		pNet->pInputRange = (RREAL *)pB;
		// It is bad news if any of these are not positive
		for (i = 0 ; i < *pNet->cUnitsPerLayer ; ++i)
		{
			if (pNet->pInputRange[i] <= 0)
			{
				return NULL;
			}
		}
		pB += *pNet->cUnitsPerLayer * sizeof(*pNet->pInputRange) / sizeof(*pB);

		SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pInputScaledMean), WORD*)
		pNet->pInputScaledMean = (RREAL_INPUT *)pB;
		pB += *pNet->cUnitsPerLayer * sizeof(*pNet->pInputScaledMean) / sizeof(*pB);

	}

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pInputMean), WORD*)
	pNet->pInputMean = (RREAL *)pB;
	pB += *pNet->cUnitsPerLayer * sizeof(*pNet->pInputMean) / sizeof(*pB);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cWeightByte), WORD*)
	pNet->cWeightByte = *((UINT *)pB);
	pB += sizeof(pNet->cWeightByte) / sizeof(*pB);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pWeight), WORD*)
	pNet->pWeight = (RREAL_WEIGHT *)pB;
	
	return ((void *)((BYTE *)pNet->pWeight + pNet->cWeightByte));
}


// Restore a Locally connected network by assigning members from a
//	memory image. Avoid copying where possible
LOCAL_NET * restoreLocalConnectNet(
void		*pBuf,				// IN: Start of memory image
wchar_t		wNetId,
LOCAL_NET	*pNet				// OUT: Run net structure
)
{
	BYTE		*pB = (BYTE *)pBuf;
	int			iSizeLoad;

	pNet->iVer = *(WORD *)pBuf;

	if (pNet->iVer < RUN_NET_VER_START)
	{
		// No Version information present
		pNet->eNetType = pNet->iVer;
	}
	else
	{
		pB += sizeof(pNet->iVer);
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->eNetType), BYTE*)
		pNet->eNetType = *(WORD *)pB;
	}

	// By definition strong nets are fully connected
	if (pNet->eNetType != (WORD)LOCALLY_CONNECTED)
	{
		return NULL;
	}
	pB += sizeof(pNet->eNetType);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(wNetId), BYTE*)
	if (wNetId != *(wchar_t *)pB)
	{
		return NULL;
	}
	pB += sizeof(wNetId);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->runNet.cWeight), BYTE*)
	if (pB = restoreRunNet(pBuf, pB, &(pNet->runNet), pNet->iVer) )
	{
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cConnect), BYTE*)
		pNet->cConnect = * (int *)pB;
		pB += sizeof(pNet->cConnect);

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->pOutConnect->iUnit), BYTE*)
		pNet->pOutConnect = (OUT_CONNECTIONS *)pB;

		if (pNet->iVer >= RUN_NET_VER_10)
		{
			// After VER_10 an integrity check was added

			pB += sizeof(*pNet->pOutConnect) * pNet->cConnect;

			SYNC_BUFF_PNT(pBuf, pB, sizeof(iSizeLoad), BYTE*)
			iSizeLoad = *(int *)pB;
			pB += sizeof(iSizeLoad);
			ASSERT( iSizeLoad == (pB - (BYTE *)pBuf));
		}
		else
		{
			// No integrity check in these files
			iSizeLoad = (pB - (BYTE *)pBuf);
		}

		if (iSizeLoad == (pB - (BYTE *)pBuf))
		{
			return pNet;
		}
		else
		{
			return NULL;
		}
	}
	return NULL;
}
// Ask how much memory a network requires to run. Returns
// memory units required
int getRunTimeNetMemoryRequirements(
void		*pBuf					// IN: Start of net memory image
)
{
	BYTE		*pB = (BYTE *)pBuf;
	RUN_NET		runNet;
	int			iRet = 0, iInc;
	WORD		iVer;

	if (!pBuf)
	{
		return 0;
	}

	if ( (iVer = *(WORD *)pBuf) >= RUN_NET_VER_START)
	{
		// Version Information present
		pB += sizeof(WORD);
		SYNC_BUFF_PNT(pBuf, pB, sizeof(iVer), BYTE*)
	}
	else
	{
		iVer = 0;
	}

	if (   (WORD)FULLY_CONNECTED == *(WORD *)pB 
		|| (WORD)LOCALLY_CONNECTED == *(WORD *)pB)
	{
		pB += sizeof(WORD) + sizeof(wchar_t);;
		SYNC_BUFF_PNT(pBuf, pB, sizeof(wchar_t), BYTE*)

		if (  (pB = restoreRunNet(pBuf, pB, &runNet, iVer) ))
		{
			int		i;

			for (i = 0 ; i < runNet.cLayer ; ++i)
			{
				if ((iInc = runNet.cUnitsPerLayer[i]) > 0)
				{
					if (   i == runNet.cLayer - 1 
						&& iInc == 1)
					{
						// Ok what goes on here??
						// As an efficiency hack we have trained the 2 class
						// recognizer using a single sigmoid output unit.
						// After it runs we break out the single output unit into
						// 2 values (p  and (1-p)) so need to make sure an extra 
						// unit is available
						++iInc;
					}

					iRet += iInc;
				}
				else
				{
					return -1;
				}
			}

		}
	}

	return (iRet > 0 ? iRet : -1);
}
/****************************************************************
*
* NAME: scaleInputs
*
*
* DESCRIPTION:
* Scale all the Inputs (first layer) using stored "bias" and ranges
* This function ensures inputs are in range [0-USHRT_MAX]
* No checking done on input range - assumed this was done at load time (in restoreNet())
* 
* HISTORY
*
* Introduced March 2002 (mrevow) with VER_12
***************************************************************/
static void scaleInputs(RREAL *pInput, RUN_NET *pNet)
{
	int						cUnit;
	RREAL					*pRange, *pMean;
	RREAL_INPUT				*pScaleMean, iTmp;

	pRange		= pNet->pInputRange;
	pScaleMean	= pNet->pInputScaledMean;
	pMean		= pNet->pInputMean;

	for (cUnit = 0 ; cUnit < *pNet->cUnitsPerLayer ; ++cUnit, ++pInput, ++pMean, ++pScaleMean, ++pRange)
	{
		// Special case Invalid features indicated by INT_MAX and INT_MIN
		if (INT_MIN == *pInput)
		{
			*pInput = -(*pMean);
		}
		else if (INT_MAX == *pInput)
		{
			*pInput = USHRT_MAX - *pMean;
		}
		else
		{
			// Normal case scale and clip to range [-USHRT_MAX;USHRT_MAX]
			iTmp	= (RREAL_INPUT)*pInput * (RREAL_INPUT)USHRT_MAX;
			iTmp	-= (RREAL_INPUT)*pScaleMean;
			iTmp	/= *pRange;
			iTmp	= (iTmp > -USHRT_MAX) ? iTmp : -USHRT_MAX;
			*pInput	= (RREAL)((iTmp < USHRT_MAX) ? iTmp : USHRT_MAX);
		}
	}

}
/****************************************************************
*
* NAME: subtractMeans
*
*
* DESCRIPTION:
*
*   Subtract the input means. 
* HISTORY
*
* March 2002 (mrevow) Older version of scaleInputs() above. Code used to be inline
* the runNet() code - just pulled it out into its own function toi make it clean
* deprecated for VER_11 and later
***************************************************************/
static void subtractMeans(RREAL *pInput, RUN_NET *pNet)
{
	int						cUnit;
	RREAL					*pMean;

	pMean	= pNet->pInputMean;

	for (cUnit = 0 ; cUnit < *pNet->cUnitsPerLayer ; ++cUnit, ++pInput, ++pMean)
	{
		*pInput	= *pInput - *pMean;
	}

}

// Run a fully connected classification net. The input units
// are assumed to be initialized with input data
// We adopt the convention that if there is only a single output
// unit (Binary decision) use a sigmoid. For more than 1
// output unit do a softMax
RREAL *runFullConnectNet(
RUN_NET		*pNet,			// In The net to run
RREAL		*pfUnits,		// IN: RAM memory block for the units
UINT		*piWinner		// OUT: Winning output 
)
{

	if (   pNet	&& pfUnits)
	{
		int				iLayer;
		RREAL			*pLow, *pUp;			// Start from input layer	
		RREAL_WEIGHT	*pW;
		int				cUnit = 0;


		if (pNet->iVer >= RUN_NET_VER_11)
		{
			scaleInputs(pfUnits, pNet);
		}
		else
		{
			subtractMeans(pfUnits, pNet);
		}

		pLow = pfUnits;
		pUp = pfUnits + *pNet->cUnitsPerLayer;
		pW = pNet->pWeight;

		// Iterate and  propogate between a "lower" and "upper" layer
		for (iLayer = 1  ; iLayer < pNet->cLayer ; ++iLayer)
		{
			RREAL		*pUpMax;											// Last unit in upper layer
			RREAL		*pLowMax = pLow + pNet->cUnitsPerLayer[iLayer-1];	// Last unit in lower layer

			cUnit = pNet->cUnitsPerLayer[iLayer];
			pUpMax = pUp + cUnit;

			// Initialization depends if Bias units are used
			if (pNet->bUseBias[iLayer])
			{
				RREAL_BIAS	*pwBias;
				int			i, cRem;

				cRem = ((BYTE *)pW - (BYTE*)pNet->pWeight) % sizeof(RREAL_BIAS);
				pwBias = (RREAL_BIAS *)((BYTE *)pW + cRem);

				for (i = 0 ; i < cUnit ; ++i, ++pwBias)
				{
					pUp[i] = (RREAL)*pwBias;
				}
				pW = (RREAL_WEIGHT *)pwBias;
			}
			else
			{
				memset(pUp, 0, sizeof(*pUp) * cUnit);
			}

			// Dot Product with layer below
			for ( ; pLow < pLowMax ; ++pLow)
			{
				RREAL	*pUnit = pUp;

				for ( ; pUnit < pUpMax ; ++pUnit, ++pW)
				{
					*pUnit += *pLow * *pW;
				}


			}

			pLow = pUp;

			// Now Pass through transfer function
			// For the output layer the transfer function
			// depends on how many units
			if (iLayer != pNet->cLayer - 1)
			{
				SIGMOID(pUp, cUnit, pNet->pWeightScale[iLayer]);
			}

			pUp = pUpMax;

		}

		// Now do transfer function on the output units
		if (cUnit == 1)
		{
			// Use sigmoid for binary decisions
			if (*pLow > 0.0F)
			{
				*piWinner = 1;
			}
			else
			{
				*piWinner = 0;
			}
			SIGMOID(pLow, cUnit, pNet->pWeightScale[iLayer]);

			// Simulate having 2 output units
			pLow[1]		= *pLow;
#ifdef FLOAT_NET
			*pLow		= 1.0F - pLow[1];
#else
			*pLow		 = 65536 - pLow[1];
#endif
		}
		else if (pNet->iVer < RUN_NET_VER_START || pNet->lossType >= CROSSENTROPY)
		{
			// Do the softmax
			RREAL		fSum, fMax, *pfO = pLow;
			int			i;

			fMax = *(pfO++);
			*piWinner = 0;

			for (i = 1 ; i < cUnit ; ++i, ++pfO)
			{
				if (*pfO > fMax)
				{
					fMax = *pfO;
					*piWinner = i;
				}
			}

			pfO = pLow;
			fSum = 0;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO = (RREAL)EXP(*pfO - fMax);
				fSum += *pfO;
			}

			if (fSum <= MIN_PREC_VAL)
			{
				return NULL;
			}

			// Normalize;
			pfO = pLow;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO /= fSum;
			}
		}
		else if (pNet->lossType == SUMSQUARE || pNet->lossType  == SUMSQUARE_CLASS)
		{
			RREAL		*pfO = pLow;

			SIGMOID(pLow, cUnit, pNet->pWeightScale[iLayer]);
		}
		
		return (pLow);
	}
	else
	{
		return NULL;
	}

}


// Run a  connected classification net. The input units
// are assumed to be initialized with input data
// We adopt the convention that if there is only a single output
// unit (Binary decision) use a sigmoid. For more than 1
// output unit do a softMax
RREAL *runLocalConnectNet(
LOCAL_NET		*pNet,			// In The net to run
RREAL			*pfUnits,		// IN: RAM memory block for the units
UINT			*piWinner,		// OUT: Winning output 
UINT			*pcOut			// Number of outputs
)
{
	RREAL		*pRange;

	pRange = pNet->runNet.pInputRange;

	if (   pNet	&& pfUnits)
	{
		int				iLayer;
		RREAL			*pLow, *pUp;					// Start from input layer	
		RREAL_WEIGHT	*pW;						// Start of upper layer
		OUT_CONNECTIONS	*pOutConnect;				// Outgoing connections
		int				cUnit = 0, iConnect = 0;

		if (pNet->iVer >= RUN_NET_VER_11)
		{
			scaleInputs(pfUnits, &(pNet->runNet));
		}
		else
		{
			subtractMeans(pfUnits, &(pNet->runNet));
		}


		pLow		= pfUnits;
		pUp			= pfUnits + *pNet->runNet.cUnitsPerLayer;
		pW			= pNet->runNet.pWeight;
		pOutConnect	= pNet->pOutConnect;

		// Initialize all units in the net
		memset(pUp, 0, sizeof(*pUp) * (pNet->runNet.cTotUnit - *pNet->runNet.cUnitsPerLayer));

		// Iterate and  propogate between a "lower" and "upper" layer
		for (iLayer = 1  ; iLayer < pNet->runNet.cLayer ; ++iLayer)
		{
			RREAL		*pLowMax = pLow + pNet->runNet.cUnitsPerLayer[iLayer-1];	// Last unit in lower layer

			cUnit = pNet->runNet.cUnitsPerLayer[iLayer];

			// Add in Bias if used
			if (pNet->runNet.bUseBias[iLayer])
			{
				int			j, cRem;
				RREAL_BIAS	*pwBias;

				cRem = ((BYTE *)pW - (BYTE*)pNet->runNet.pWeight) % sizeof(RREAL_BIAS);
				pwBias = (RREAL_BIAS *)((BYTE *)pW + cRem);

				for (j = 0 ; j < cUnit ; ++j, ++pwBias)
				{
					*(pUp + j) += *pwBias;
				}

				pW = (RREAL_WEIGHT *)pwBias;
			}

			// Dot Product with layer below
			for ( ; pLow < pLowMax ; ++pLow)
			{
				DWORD		i;
				int			iStartUnit = pOutConnect->iUnit;

				while (iStartUnit == pOutConnect->iUnit)
				{
					// Do all outgoing connections from this unit
					for ( i = pOutConnect->iStartUnitOffset; i <= pOutConnect->iEndUnitOffset ; ++i, ++pW)
					{
						*(pfUnits + i) += *pLow * *pW;
					}
					
					++pOutConnect;
					++iConnect;
				}

			}


			// Now Pass through transfer function
			// For the output layer the transfer function
			// depends on how many units
			if (iLayer != pNet->runNet.cLayer - 1)
			{
				SIGMOID(pUp, cUnit, pNet->runNet.pWeightScale[iLayer]);
			}

			pLow = pUp;
			pUp += cUnit;

		}

		if (pcOut)
		{
			*pcOut = cUnit;
		}

		// Now do transfer function on the output units
		if (cUnit == 1)
		{
			// Use sigmoid for binary decisions
			if (*pLow > 0.0F)
			{
				*piWinner = 1;
			}
			else
			{
				*piWinner = 0;
			}
			SIGMOID(pLow, cUnit, pNet->runNet.pWeightScale[iLayer-1]);

			// Simulate having 2 output units
			pLow[1]		= *pLow;
#ifdef FLOAT_NET
			*pLow		= 1.0F - pLow[1];
#else
			*pLow		 = 65536 - pLow[1];
#endif
		}
		else if (pNet->iVer < RUN_NET_VER_START || pNet->runNet.lossType >= CROSSENTROPY)
		{
			// Do the softmax
			RREAL		fSum, fMax, *pfO = pLow;
			int			i;
			RREAL		scale = (RREAL)pNet->runNet.pWeightScale[iLayer-1];

			*pfO /= scale;
			fMax = *(pfO++);
			*piWinner = 0;

			for (i = 1 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO /= scale;

				if (*pfO > fMax)
				{
					fMax = *pfO;
					*piWinner = i;
				}
			}

			fSum = 0;
			pfO = pLow;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO = (RREAL)EXP(*pfO - fMax);
				fSum += *pfO;
			}

			if (fSum <= MIN_PREC_VAL)
			{
				return NULL;
			}

			// Normalize;
			pfO = pLow;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO = (*pfO * SOFT_MAX_UNITY) / fSum;
			}
		}
		else if (pNet->runNet.lossType == SUMSQUARE || pNet->runNet.lossType  == SUMSQUARE_CLASS)
		{
			RREAL		*pfO = pLow;

			SIGMOID(pLow, cUnit, pNet->runNet.pWeightScale[iLayer-1]);
		}
		
		return (pLow);
	}
	else
	{
		return NULL;
	}

}

void * loadNetFromResource(HINSTANCE hInst, int iKey, int *iSize)
{
	HGLOBAL hglb;
	HRSRC hres;
	LPBYTE lpByte;

	*iSize = 0;
	hres = FindResource(hInst, (LPCTSTR)MAKELONG(iKey, 0), (LPCTSTR)TEXT("Net"));

	if (!hres)
	{
		return NULL;
	}

	hglb = LoadResource(hInst, hres);
	if (!hglb)
	{
		return NULL;
	}

	*iSize = SizeofResource(hInst, hres);
	lpByte = LockResource(hglb);
	return (void *)lpByte;
}


LOCAL_NET * loadNet(HINSTANCE hInst, int iKey, int *iNetSize, LOCAL_NET *pNet)
{
	void		*pRet = NULL;
	int			iResSize;

	
	*iNetSize = 0;
	pRet = loadNetFromResource(hInst, iKey, &iResSize);

	if ( !pRet || !(pNet = restoreLocalConnectNet(pRet, 0, pNet)) )
	{
		return NULL;
	}

	*iNetSize = getRunTimeNetMemoryRequirements(pRet);

	if (*iNetSize <= 0)
	{
		return NULL;
	}

	return pNet;
}

#ifdef HWX_INTERNAL
LOCAL_NET * LoadRunNetFromFp(LOCAL_NET *pNet, int *iNetSize, char * fname)
{
	FILE		*fp;
	BYTE		*pBuf = NULL;
	int			iBufSize, iRead;

	if ( (fp = fopen(fname, "rb")) )
	{
		fseek(fp, 0, SEEK_END);
		iBufSize = ftell(fp);
		rewind(fp);
		pBuf = ExternAlloc(iBufSize);
		if (!pBuf)
		{
			return NULL;
		}

		if (   iBufSize != (iRead = (int)fread(pBuf, 1, iBufSize, fp))
			|| !(pNet = restoreLocalConnectNet(pBuf, 0, pNet)) )
		{
			goto fail;
		}

		*iNetSize = getRunTimeNetMemoryRequirements(pBuf);

		if (*iNetSize <= 0)
		{
			goto fail;
		}

		fclose(fp);
	}
	else
	{
		pNet = NULL;
	}

	return pNet;

fail:
	fclose(fp);
	ExternFree(pBuf);
	return NULL;
}
#endif
#ifdef NET_FLOAT
// Pass a vector through a transfer function. Replaces vector
// Here we use sigmoid
// Warning Does not check sanity of pVec
RREAL * fsigmoid(
RREAL		*pVec,			// IN vector of Values Not checked for NULL
int			cVec,			// IN: Size of vector
WORD		scale
)
{
	RREAL	*pVmax = pVec + cVec;
	RREAL	tmp;
	for (; pVec < pVmax ; ++pVec)
	{
		*pVec /= (RREAL)scale;
		tmp = *pVec / 65536.0F;
		tmp = (1.0F + exp(-tmp));
		tmp = 1.0F / tmp;
		*pVec = tmp * 65536.0F;
	}

	return pVec;
}
#else
// Quick integer versions

RREAL * isigmoid(
RREAL		*pVec,			// IN vector of Values Not checked for NULL
int			cVec,			// IN: Size of vector
WORD		scale
)
{
	RREAL	*pVmax = pVec + cVec;

	for (; pVec < pVmax ; ++pVec)
	{
		*pVec /= (RREAL)scale;
		*pVec = Sigmoid16(*pVec);
	}

	return pVec;
}

// Exponential for val <= 0
RREAL iexp(RREAL val)
{
	UINT		iV;
	int		iSigMax = ( 1 << 16);

	ASSERT(val <= 0);

	if (val < 0)
	{
		iV = Sigmoid16(val);
		val = (iV << 16) / ( iSigMax - iV);
	}
	else
	{
		val = iSigMax;
	}

	return val;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\sources.inc ===
TARGETNAME=common
TARGETTYPE=LIBRARY

NTTARGETFILES= $(NTTARGETFILES) hwxbin

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\common\inc; \
          $(_TPG_ROOT)\hwx\wisp\inc; \
          $(_TPG_ROOT)\hwx\inferno\src; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\altlist.c \
         ..\cp1252.c \
         ..\english.c \
         ..\errsys.c \
         ..\foldchar.c \
         ..\frame.c \
         ..\gesturep.c \
         ..\glyph.c \
         ..\inkio.c \
         ..\langtax.c \
         ..\math16.c \
         ..\mathx.c \
         ..\memmgr.c \
         ..\QuickTrie.c \
         ..\runNet.c \
         ..\sjis.c \
         ..\toolprs.c \
         ..\trie.c \
         ..\udict.c \
         ..\unicode.c \
         ..\util.c \
         ..\xjis.c \
         ..\xrcreslt.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\util.c ===
/* This file contain some common functions used by many of the Rodan utilities */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <direct.h>
#include "common.h"

// Attempt to fopen pszFileName in mode pszMode. If that fails, try it in the subdirectory
// above the current one.  Continue up the directory tree until you reach the top.  Return
// NULL only if ALL attempts fail.  In case of success, return the actual path to the
// opened file in pszFullPath.  cchFullPathMax is the size of the buffer pszFullPath
// points to. 
// [donalds] 10-13-96 Made UNICODE/ANSI safe.

FILE *UtilOpenPath(TCHAR *pszPath, TCHAR *pszFileName, TCHAR *pszMode, TCHAR  *pszFullPath, int cchFullPathMax) 
{
	TCHAR  *pszT;
	FILE   *pFile;
	int		i;

// Make a copy of the path to start from so we can modify it
// and return the one we really used

	if (pszFullPath != pszPath) 
	{
		_tcsncpy(pszFullPath, pszPath, cchFullPathMax);
	}

// Make sure the directory path ends with a backslash '\'
	
	i = _tcslen(pszFullPath);
	if (i == 0 || (pszFullPath[i-1] != '\\' && pszFullPath[i-1] != '/')) 
	{
		pszFullPath[i] = '\\';
		pszFullPath[i+1] = '\0';
	}

	while (TRUE) 
	{
		
	// Tack the filename onto the current directory name

		_tcsncat(pszFullPath, pszFileName, cchFullPathMax - _tcslen(pszFullPath));

	// If we can open this, return successfully

		if (pFile = _tfopen(pszFullPath,pszMode))
			return pFile;

	// See if we can back up one directory.  First remove the file at the end

		pszT = _tcsrchr(pszFullPath,'\\');
	   *pszT = '\0';

	// Now look for the previous directory, if any

		if ((pszT = _tcsrchr(pszFullPath,'\\')) == (TCHAR *) NULL)
			return (FILE *) NULL;

	// Drop the directory name but keep the slash

		pszT[1] = '\0';
	}
}

// The basic UtilOpen call, uses the UtilOpenPath to traverse up the tree.
// [donalds] 10-13-96 Made UNICODE/ANSI safe.

FILE *UtilOpen(TCHAR *pszFileName, TCHAR *pszMode, TCHAR *pszFullPath, int cchFullPathMax) 
{
	FILE *pFile;

	// Check for null file name, or a file name that is too long to fit.
	if (!pszFileName || !*pszFileName || _tcslen(pszFileName) + 1 > (unsigned) cchFullPathMax) {
		return (FILE *)NULL;
	}

	// Try it once as is
    if (pFile = _tfopen(pszFileName,pszMode)) {
		_tcsncpy(pszFullPath, pszFileName, cchFullPathMax);
		return pFile;
	}

	// Check for a path.  We can't try our normal search if it is anything but a simple file name.
	if (_tcschr(pszFileName, _T('\\')) || _tcschr(pszFileName, _T('/')
		|| (_tcslen(pszFileName) > 2 && pszFileName[1] == _T(':')))
	) {
		return (FILE *)NULL;
	}

	// Find the directory we're currently in.  If the directory doesn't fit in the output
	// variable, or of adding the file name on to the path doesn't fit, return an error.
	if (_tgetcwd(pszFullPath, cchFullPathMax) == NULL ||
		_tcslen(pszFullPath) + 1 + _tcslen(pszFileName) + 1 > (unsigned) cchFullPathMax)
	{
		return (FILE *)NULL;
	}

	return UtilOpenPath(pszFullPath, pszFileName, pszMode, pszFullPath, cchFullPathMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\unicode.c ===
#include "common.h"

//
// rgrecmaskUnicode
//

const RECMASK rgrecmaskUnicode[94] =
{
	ALC_PUNC | ALC_ENDPUNC,                 // 0x0021 !
	ALC_PUNC | ALC_BEGINPUNC | ALC_ENDPUNC, // 0x0022 "
	ALC_PUNC,                               // 0x0023 #
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x0024 $
	ALC_PUNC,                               // 0x0025 %
	ALC_PUNC,                               // 0x0026 &
	ALC_PUNC | ALC_ENDPUNC,                 // 0x0027 '
	ALC_PUNC | ALC_BEGINPUNC,               // 0x0028 (
	ALC_PUNC | ALC_ENDPUNC,                 // 0x0029 )
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x002A *
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x002B +
	ALC_PUNC | ALC_ENDPUNC,                 // 0x002C ,
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x002D -
	ALC_PUNC | ALC_ENDPUNC | ALC_NUMERIC_PUNC, // 0x002E .
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x002F /
	ALC_NUMERIC,                            // 0x0030 0
	ALC_NUMERIC,                            // 0x0031 1
	ALC_NUMERIC,                            // 0x0032 2
	ALC_NUMERIC,                            // 0x0033 3
	ALC_NUMERIC,                            // 0x0034 4
	ALC_NUMERIC,                            // 0x0035 5
	ALC_NUMERIC,                            // 0x0036 6
	ALC_NUMERIC,                            // 0x0037 7
	ALC_NUMERIC,                            // 0x0038 8
	ALC_NUMERIC,                            // 0x0039 9
	ALC_PUNC | ALC_ENDPUNC | ALC_NUMERIC_PUNC, // 0x003A :
	ALC_PUNC | ALC_ENDPUNC,                 // 0x003B ;
	ALC_PUNC,                               // 0x003C <
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x003D =
	ALC_PUNC,                               // 0x003E >
	ALC_PUNC | ALC_ENDPUNC,                 // 0x003F ?
	ALC_PUNC,                               // 0x0040 @
	ALC_UCALPHA,                            // 0x0041 A
	ALC_UCALPHA,                            // 0x0042 B
	ALC_UCALPHA,                            // 0x0043 C
	ALC_UCALPHA,                            // 0x0044 D
	ALC_UCALPHA,                            // 0x0045 E
	ALC_UCALPHA,                            // 0x0046 F
	ALC_UCALPHA,                            // 0x0047 G
	ALC_UCALPHA,                            // 0x0048 H
	ALC_UCALPHA,                            // 0x0049 I
	ALC_UCALPHA,                            // 0x004A J
	ALC_UCALPHA,                            // 0x004B K
	ALC_UCALPHA,                            // 0x004C L
	ALC_UCALPHA,                            // 0x004D M
	ALC_UCALPHA,                            // 0x004E N
	ALC_UCALPHA,                            // 0x004F O
	ALC_UCALPHA,                            // 0x0050 P
	ALC_UCALPHA,                            // 0x0051 Q
	ALC_UCALPHA,                            // 0x0052 R
	ALC_UCALPHA,                            // 0x0053 S
	ALC_UCALPHA,                            // 0x0054 T
	ALC_UCALPHA,                            // 0x0055 U
	ALC_UCALPHA,                            // 0x0056 V
	ALC_UCALPHA,                            // 0x0057 W
	ALC_UCALPHA,                            // 0x0058 X
	ALC_UCALPHA,                            // 0x0059 Y
	ALC_UCALPHA,                            // 0x005A Z
	ALC_PUNC | ALC_BEGINPUNC,               // 0x005B [
	ALC_PUNC,                               // 0x005C \ 
	ALC_PUNC | ALC_ENDPUNC,                 // 0x005D ]
	ALC_PUNC,                               // 0x005E ^
	ALC_PUNC,                               // 0x005F _
	ALC_PUNC | ALC_BEGINPUNC,               // 0x0060 `
	ALC_LCALPHA,                            // 0x0061 a
	ALC_LCALPHA,                            // 0x0062 b
	ALC_LCALPHA,                            // 0x0063 c
	ALC_LCALPHA,                            // 0x0064 d
	ALC_LCALPHA,                            // 0x0065 e
	ALC_LCALPHA,                            // 0x0066 f
	ALC_LCALPHA,                            // 0x0067 g
	ALC_LCALPHA,                            // 0x0068 h
	ALC_LCALPHA,                            // 0x0069 i
	ALC_LCALPHA,                            // 0x006A j
	ALC_LCALPHA,                            // 0x006B k
	ALC_LCALPHA,                            // 0x006C l
	ALC_LCALPHA,                            // 0x006D m
	ALC_LCALPHA,                            // 0x006E n
	ALC_LCALPHA,                            // 0x006F o
	ALC_LCALPHA,                            // 0x0070 p
	ALC_LCALPHA,                            // 0x0071 q
	ALC_LCALPHA,                            // 0x0072 r
	ALC_LCALPHA,                            // 0x0073 s
	ALC_LCALPHA,                            // 0x0074 t
	ALC_LCALPHA,                            // 0x0075 u
	ALC_LCALPHA,                            // 0x0076 v
	ALC_LCALPHA,                            // 0x0077 w
	ALC_LCALPHA,                            // 0x0078 x
	ALC_LCALPHA,                            // 0x0079 y
	ALC_LCALPHA,                            // 0x007A z
	ALC_PUNC | ALC_BEGINPUNC,               // 0x007B {
	ALC_PUNC,                               // 0x007C |
	ALC_PUNC | ALC_ENDPUNC,                 // 0x007D }
	ALC_PUNC                                // 0x007E ~
};

static const wchar_t awchCompZone[] =
{
    0x0000, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,     // 0xff00
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,     // 0xff08
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,     // 0xff10
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,     // 0xff18
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,     // 0xff20
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,     // 0xff28
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,     // 0xff30
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,     // 0xff38
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,     // 0xff40
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,     // 0xff48
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,     // 0xff50
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x0000,     // 0xff58
    0x0000, 0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1,     // 0xff60
    0x30a3, 0x30a5, 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7, 0x30c3,     // 0xff68
    0x30fc, 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad,     // 0xff70
    0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7, 0x30b9, 0x30bb, 0x30bd,     // 0xff78
    0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8, 0x30ca, 0x30cb, 0x30cc,     // 0xff80
    0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5, 0x30d8, 0x30db, 0x30de,     // 0xff88
    0x30df, 0x30e0, 0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8, 0x30e9,     // 0xff90
    0x30ea, 0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x309b, 0x309c,     // 0xff98
    0x3164, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137,     // 0xffa0
    0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f,     // 0xffa8
    0x3140, 0x3141, 0x3142, 0x3143, 0x3144, 0x3145, 0x3146, 0x3147,     // 0xffb0
    0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x0000,     // 0xffb8
    0x0000, 0x0000, 0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154,     // 0xffc0
    0x0000, 0x0000, 0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a,     // 0xffc8
    0x0000, 0x0000, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160,     // 0xffd0
    0x0000, 0x0000, 0x3161, 0x3162, 0x3163, 0x0000, 0x0000, 0x0000,     // 0xffd8
    0x00a2, 0x00a3, 0x00ac, 0x00af, 0x00a6, 0x00a5, 0x20a9, 0x0000,     // 0xffe0
    0x2502, 0x2190, 0x2191, 0x2192, 0x2193, 0x25a0, 0x25cb, 0x0000,     // 0xffe8
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,     // 0xfff0
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfffd, 0xfffe, 0xffff      // 0xfff8
};

wchar_t MapFromCompZone(wchar_t wch)
{
// If the character is in the compatibility zone, map it back to reality

    if ((wch & 0xff00) == 0xff00)
                wch = awchCompZone[wch & 0x00ff];

    return wch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\trie.c ===
#include "trie.h"
#include "memmgr.h"

#ifndef UNDER_CE
#   include <TabAssert.h>
#else
#   define ASSERT(x)
#endif

#define fNLGNewMemory(pp,cb) ((*pp) = ExternAlloc(cb))       
#define NLGFreeMemory ExternFree

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
        LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	if (lpTrieStats == NULL)
		return(NULL);

	// Check the version number.  This code currently only supports version 1 tries  

	if (lpTrieStats->version > 1)
		return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //

    if (!fNLGNewMemory(&lpTrieCtrl, sizeof(TRIECTRL)))
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //

        lpByte += lpTrieStats->cbHeader;
        lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

        lpwTables = (LPWORD)(lpTrieStats+1);

        lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

        if ((DWORD) lpwTables & 0x02)                           // Deal with possible data mis-alignment
                lpwTables++;

        lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

        if ((DWORD) lpwTables & 0x02)                           // Deal with possible data mis-alignment
                lpwTables++;

        lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

        if ((DWORD) lpwTables & 0x02)                           // Deal with possible data mis-alignment
                lpwTables++;

        lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
        lpwTables += lpTrieStats->cSROffsetsCodesMax;

        if ((DWORD) lpwTables & 0x02)                           // Deal with possible data mis-alignment
                lpwTables++;

        lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
        lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

        lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
        lpwTables += (2 * lpTrieStats->cUniqueTags);

        lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
        lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

        lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
        lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    ASSERT((LPBYTE)lpwTables - (LPBYTE)lpTrieStats == (int)lpTrieStats->cbHeader);

    //
    // Init trie pointers
    //

        lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

        return (void *)lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //

    NLGFreeMemory(lpTrieCtrl);

}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, WORD *pcCodes, unsigned char *pbData)
{
        int cBytes = 0;
        WORD wCode = 0, wiSymbol = 0;

        /* At each stage in this loop, we're trying to see if we've got a length-n code.
        dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
        we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
        the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
                wCode += *pbData++;
                ++cBytes;
        if (wCode < *pcCodes)
        {
                        break;
                }
                wiSymbol += *pcCodes;
                wCode -= *pcCodes++;
                wCode <<= 8;
        }

        /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
        dwiSymbol, because we've already added the counts of the shorter codes to it. */

        wiSymbol += wCode;

        *piSymbol = wiSymbol;

        return cBytes;
}

DWORD Get3ByteAddress(BYTE *pb)
{
        return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the trie */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
    }

    /* Decompress the char/flags */

    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
    lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
    lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

    // Decompress skip enumeration

    if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
    {
    // Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cSkipWords = dwCode;
    }

    /* Code to decompress enumeration goes here */

    if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
    {
    // Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cWords = dwCode;

    // Decompress the tagged enumeration counts

        wMask = 1;
        for (iTag = 0; iTag < MAXTAGS; iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
            {
            // Values greater than 127 are really 15 or 21 bit values.

                dwCode = (DWORD) *lpTrieScan->lpbNode++;

                if (dwCode >= 0x00c0)
                {
                    dwCode  = ((dwCode & 0x003f) << 15);
                    dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                    dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                }
                else if (dwCode >= 0x0080)
                    dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                lpTrieScan->aTags[iTag].cTag = dwCode;
            }
            else
                lpTrieScan->aTags[iTag].cTag = 0;

            wMask <<= 1;
        }
    }
    else
            lpTrieScan->cWords = 0;

    // Any tagged data for this node follows the counts

    lpTrieScan->wMask = 0;

    if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
    {
    // If there is only one tagged field, the mask byte won't be stored

            if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
                    bMask = lpTrieCtrl->lpTrieStats->wDataMask;
            else
                    bMask = *lpTrieScan->lpbNode++;

    // Now that we know which elements are stored here, pull them in their proper place

            wMask = 1;
            for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
            {
                    if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
                    {
                            lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                            lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                            lpTrieScan->wMask |= wMask;
                    }

                    bMask  &= ~wMask;
                    wMask <<= 1;
            }
    }

    // There are two flavors of right pointers: Multiref and Skip.

    if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
    {
        if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
        {
            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
            wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
        }
        else
        {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
            lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
    }
    else
            lpTrieScan->lpbRight = NULL;

    // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
    // Each requires different decompression

    if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
    {
            // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

            lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
            lpTrieScan->lpbNode += 3;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
    {
            /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

            ASSERT(lpTrieScan->wFlags&TRIE_NODE_END);

            lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
    {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                    lpTrieScan->lpbNode);

            lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
    }
    else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
    {
            /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
            into this singleref segment.  So we have to keep the old one around so we can add to it */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                    lpTrieScan->lpbNode);

            if (lpTrieScan->lpbSRDown == 0)
            {
                    lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
            }

            wOffset = lpTrieCtrl->lpwSROffsets[wCode];
            lpTrieScan->lpbSRDown += wOffset;
            lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
    }
    else
            lpTrieScan->lpbDown = NULL;

// We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

    if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
        lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
    // Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
        // If we can follow a right pointer, do so, else fail
        
            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

    // Either we're at a soft EOS or we've followed a right pointer.
    // Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

// If there isn't a right pointer or if the target letter is alphabetically less then
// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
        /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
            return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
            return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

    // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
    // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

        // If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

        // Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
        // Now, follow the skip pointer if exist and the alphabetic character is greater then
        // the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
        // use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

            // This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

    // If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
    // If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

    // Remember this node's character

        pwszWord[ich] = ts.wch;

    // If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

    // Get the count of words in this subtree.

        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

    // Scan to the right until the word count of the subtree would be greater than or equal to the index
    // we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
    // If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;
                
                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, wchar_t *pwszWord, int *piStart)
{
        TRIESCAN        ts;
        int                     ich = 0;
        int                     cnt;
        BOOL            bValid;

        memset(&ts, 0, sizeof(TRIESCAN));
   *piStart = 0;

        if (!TrieGetNextState(ptc, &ts))
                return 0;

        // Deal with special case of empty string

        if (pwszWord && !*pwszWord)
                return ptc->lpTrieStats->cWords;

        do
        {
        // Get the count of words below this prefix

                cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

        // If the node we just arrived at is valid, increment the count

                bValid = ts.wFlags & TRIE_NODE_VALID;

        // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
        // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

                if (ts.wch == pwszWord[ich])
                {
                        ich++;

                // If we reached the end of prefix, return the count remaining below

                        if (pwszWord[ich] == L'\0')
                        {
                                if (bValid)
                                        cnt++;

                                return cnt;
                        }

                // Try going down a level

                        if (!TrieGetNextState(ptc, &ts))
                                return 0;
                }
                else
                {
                // Add the sub tree count.

                   *piStart += cnt;

                // Try the next letter in this state

                        if (!TrieGetNextNode(ptc, &ts))
                                return 0;
                }

                if (bValid)
                        (*piStart)++;

        } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
        TRIESCAN        ts    = *pts;
        DWORD           cTags = 0;

        if (!TrieGetNextState(ptc, &ts))
                return cTags;

        do
        {
                if (ts.wFlags & wMask)
                        cTags++;

                cTags += CountTags(ptc, &ts, wMask, iTag);
        } while (TrieGetNextNode(ptc, &ts));

        return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, wchar_t *pwszWord, int iTag)
{
        TRIESCAN        ts;
        int                     ich = 0;
        int                     index = 0;
        BOOL            bValid;
        DWORD           wMask = 1 << iTag;

        memset(&ts, 0, sizeof(TRIESCAN));

        if (!TrieGetNextState(ptc, &ts))
                return FALSE;

        do
        {
                bValid = ts.wFlags & wMask;

        // Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
        // If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

                if (ts.wch == pwszWord[ich])
                {
                        ich++;

                // If we reached the end of word at a valid state, return the index

                        if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                                return index;

                // Try going down a level

                        if (!TrieGetNextState(ptc, &ts))
                                return -1;
                }
                else
                {
                // Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

                        index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

                        if (!TrieGetNextNode(ptc, &ts))
                                return -1;
                }

        // If the node we just visited was valid, increment the index

                if (bValid)
                        index++;
        } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
        TRIESCAN        ts;
        int                     ich = 0;
        DWORD           cTags;
        DWORD           wMask = 1 << iTag;

        memset(&ts, 0, sizeof(TRIESCAN));

        if (!TrieGetNextState(ptc, &ts))
                return FALSE;

        do
        {
        // If we're at the end of the buffer, fail

                if (ich + 1 >= cwc)
                        return FALSE;

        // Remember this node's character

                pwszWord[ich] = ts.wch;

        // If we're on a valid word AND we've reached the index we're looking for, exit the loop

                if (ts.wFlags & wMask)
                {
                        if (!nIndex)
                                break;

                        nIndex--;
                }

        // Get the count of words in this subtree.

                cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

        // Scan to the right until the word count of the subtree would be greater than or equal to the index
        // we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

                if (nIndex < cTags)
                {
                        if (!TrieGetNextState(ptc, &ts))
                                return FALSE;

                        ich++;                                                  // Advance the character position
                }
                else
                {
                        nIndex -= cTags;

                        if (!TrieGetNextNode(ptc, &ts))
                                return FALSE;
                }
        } while (TRUE);

        pwszWord[++ich] = L'\0';                        // Null terminate the string
        return ts.wFlags & wMask;                       // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                        // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                        // Returned values
        BYTE       *pbValid                     // Mask for valid return values
)
{
        TRIESCAN        ts;
        int             iTag;
        WORD            wMask;
        BYTE            bMask = ptc->lpTrieStats->wTagsMask;

        if (!TrieCheckWord(ptc, &ts, pwszWord))
                return FALSE;

        if (ts.wFlags & TRIE_NODE_TAGGED)
        {
                wMask = 1;
                for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
                {
                        if (ts.wMask & wMask)
                        {
                                pdw[iTag] = ts.aTags[iTag].dwData;
                                bMask |= wMask;
                        }

                        wMask <<= 1;
                }
        }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\udict.c ===
// File: udict.c
//
// Low level code to maintain a user dictionary
#include "common.h"
//#include "langmod.h"
#include "udict.h"
#include "uDictP.h"

/******************************************************************************\
|	Private APIs
\******************************************************************************/

#define	MIN_EXTRA	16
#define	ROUND_SIZE	128

static const NODE	nodeZero		= { 0, /* ... */ };

// Grow the size of the node allocation.
static int
GrowNodeArray(UDICT *pUDict, int maxNodes)
{
	static const int	acTableSizes[]	= { 32, 64, 96, 128, 192, 256 };
	static const int	cTableSizes		= sizeof(acTableSizes)/sizeof(int);

	int		ii;
	int		newSize, oldSize;
	NODE	*pScan, *pLimit;

	// ASSERT(maxNodes > pUDict->cNodes);

	// Save away the current size.
	oldSize		= pUDict->cNodes;

	// Make sure that some room is left over after we add the word.
	maxNodes	+= MIN_EXTRA;

	// Now find the next bigger table size.
	newSize		= 0;
	for (ii = 0 ; ii < cTableSizes; ++ii) {
		if (maxNodes < acTableSizes[ii]) {
			newSize		= acTableSizes[ii];
			break;
		}
	}
	if (newSize == 0) {
		newSize		= ((maxNodes + ROUND_SIZE - 1) / ROUND_SIZE) * ROUND_SIZE;
	}

	// Grow the memory
	pUDict->pNodeAlloc	= (NODE *)ExternRealloc(pUDict->pNodeAlloc, newSize * sizeof(NODE));
	if (NULL == pUDict->pNodeAlloc)
	{
		return FALSE;
	}

	pUDict->cNodes		= newSize;

	// Add new memory to the free list.
	// Note: should add at end of free list if we want shrink array.
	pScan				= pUDict->pNodeAlloc + newSize - 1;
	pLimit				= pUDict->pNodeAlloc + oldSize;
	*pScan				= nodeZero;
	pScan->uu.iRight	= pUDict->iFreeList;
	for (--pScan; pScan >= pLimit; --pScan) {
		*pScan				= nodeZero;
		pScan->uu.iRight	= pScan + 1 - pUDict->pNodeAlloc;
	}
	pUDict->iFreeList	= pLimit - pUDict->pNodeAlloc;

	return TRUE;
}

static int
AllocNode(UDICT *pUDict, NODE **ppNode)
{
	NODE	*pNode;
	int		iNode;

	// ASSERT(pUDict->iFreeList != NO_LINK);

	iNode				= pUDict->iFreeList;
	pNode				= pUDict->pNodeAlloc + iNode;
	pUDict->iFreeList	= pNode->uu.iRight;

	ASSERT(pUDict->cNodesUsed < pUDict->cNodes);
	++pUDict->cNodesUsed;
	
	*ppNode				= pNode;
	return iNode;
}

static void
FreeNode(UDICT *pUDict, int iNode, NODE *pNode)
{
	// ASSERT(pUDict->pNodeAlloc + iNode == pNode);
	
	*pNode				= nodeZero;
	pNode->uu.iRight	= pUDict->iFreeList;
	pUDict->iFreeList	= iNode;

	--pUDict->cNodesUsed;
}

static int
CreateTagNode(UDICT *pUDict, const wchar_t *pTag, int iDown)
{
	int		iNode;
	NODE	*pNode;

	// Allocate a node and fill it in.  Note, we have already made sure there
	// are enough free nodes, so this can not fail.
	iNode				= AllocNode(pUDict, &pNode);
	pNode->wchLabel		= 0;	// Not used
	pNode->flags		= UDF_IS_TAG;
	pNode->iDown		= iDown;
	pNode->uu.pTag		= pTag;

	return iNode;
}

NODE *
FindInState(UDICT *pUDict, int iState, wchar_t wchLabel)
{
	NODE	*pNode;
	int		iNode;

	iNode	= iState;
	while (iNode != NO_LINK) {
		pNode	= pUDict->pNodeAlloc + iNode;
		if (pNode->wchLabel == wchLabel) {
			return pNode;
		}
		iNode	= pNode->uu.iRight;
	}

	return (NODE *)0;
}

static int
DoAdd(UDICT *pUDict, const wchar_t *pwchWord, const wchar_t *pTag)
{
	int		iNode;
	NODE	*pNode;

	// Allocate a node and fill it in.  Note, we have already made sure there
	// are enough free nodes, so this can not fail.
	iNode				= AllocNode(pUDict, &pNode);
	pNode->wchLabel		= *pwchWord;
	pNode->flags		= 0;
	pNode->uu.iRight	= NO_LINK;

	// Now figure out what (if anything) is below us.
	if (*++pwchWord != L'\0') {
		// More to add, recurse.
		pNode->iDown		= DoAdd(pUDict, pwchWord, pTag);
	} else {
		// End of word, set flags and add a tag if needed.
		if (!pTag) {
			pNode->flags		|= UDF_VALID;
			pNode->iDown		= NO_LINK;
		} else {
			pNode->flags		|= UDF_VALID | UDF_HAS_TAG;
			pNode->iDown		= CreateTagNode(pUDict, pTag, NO_LINK);
		}
	}

	return iNode;
}

// Locate point to start adding and do the add.
static int
FindAndAdd(
	UDICT			*pUDict,
	int				iNode,
	const wchar_t	*pwchWord,
	const wchar_t	*pTag
) {
	NODE	*pNode	= pUDict->pNodeAlloc + iNode;
	NODE	*pTagNode;
	int		iTagNode;
	int		iDown;

	while (TRUE) {
		// Scan alt list to find correct letter.
		while (pNode->wchLabel != *pwchWord) {
			if (pNode->uu.iRight == NO_LINK) {
				// Need to add as new alternate.
				pNode->uu.iRight	= DoAdd(pUDict, pwchWord, pTag);
				return udWordAdded;
			} else {
				// Setup to look at next node.
				iNode	= pNode->uu.iRight;
				pNode	= pUDict->pNodeAlloc + iNode;
			}
		}

		// Got correct letter, is it the last one?
		if (*++pwchWord == L'\0') {
			// Last letter, Make it valid, and deal with flags.
			if (pNode->flags & UDF_VALID) {
				// Already valid, deal with tag and return value.
				if (!pTag) {
					// Don't want a tag, is there one?
					if (pNode->flags & UDF_HAS_TAG) {
						// Has a tag, get rid of it.

						// Unlink node from trie
						// ASSERT(pNode->iDown != NO_LINK);
						iTagNode		= pNode->iDown;
						pTagNode		= pUDict->pNodeAlloc + iTagNode;
						pNode->iDown	= pTagNode->iDown;

						// Free tag and put node on free list.
						ExternFree((wchar_t *)pTagNode->uu.pTag);
						FreeNode(pUDict, iTagNode, pTagNode);

						// Clear flag.
						pNode->flags	&= ~UDF_HAS_TAG;

						return udWordChanged;
					} else {
						// No tag, we are already done.
						return udWordFound;
					}
				} else {
					// Want a tag, do we have one already?
					if (pNode->flags & UDF_HAS_TAG) {
						// Has a tag, is it the right one?
						iTagNode		= pNode->iDown;
						pTagNode		= pUDict->pNodeAlloc + iTagNode;

						if (wcscmp(pTag, pTagNode->uu.pTag) == 0) {
							// Already has same tag, were done.
							return udWordFound;
						} else {
							// Wrong tag, change it.
							ExternFree((wchar_t *)pTagNode->uu.pTag);
							pTagNode->uu.pTag	= pTag;	// Already copied in calling routine.
							return udWordChanged;
						}
					} else {
						// No tag, Need to add one.
						pNode->iDown	= CreateTagNode(pUDict, pTag, pNode->iDown);
						pNode->flags	|= UDF_HAS_TAG;
						return udWordChanged;
					}
				}
			} else {
				// Not valid, make it valid, and deal with tag.
				pNode->flags	|= UDF_VALID;
				return udWordAdded;
			}
		}

		// Have more letters, so go down to next level, if possable.
		iDown		= iNode;
		if (UDictDownNode((HANDLE)pUDict, (HANDLE *)&iDown) == udSuccess) {
			// Have next level, set up first node of that level.
			iNode	= iDown;
			pNode	= pUDict->pNodeAlloc + iNode;
		} else {
			int		iAddNode;

			// No next level, need to add here.
			iAddNode			= DoAdd(pUDict, pwchWord, pTag);
			if (pNode->iDown != NO_LINK) {
				// Have to deal with the tag on the current word.
				// ASSERT(pNode->flags & UDF_HAS_TAG);
				iNode		= pNode->iDown;
				pNode		= pUDict->pNodeAlloc + iNode;
				// ASSERT(pNode->uu.iDown == NO_LINK);
			}
			pNode->iDown	= iAddNode;
			return udWordAdded;
		}
	}
}

// Locate a word and remove everything unique to it.
static int
FindAndDelete(
	UDICT			*pUDict,
	int				*piNode,
	const wchar_t	*pwchWord
) {
	NODE	*pNode		= pUDict->pNodeAlloc + *piNode;
	int		*piDown;
	int		retVal;
	int		iNode;

	// Scan alt list to find correct letter.
	while (pNode->wchLabel != *pwchWord) {
		if (pNode->uu.iRight == NO_LINK) {
			// Word not found.
			return udWordNotFound;
		} else {
			// Setup to look at next node.
			piNode	= &pNode->uu.iRight;
			pNode	= pUDict->pNodeAlloc + pNode->uu.iRight;
		}
	}

	// Got correct letter, is it the last one?
	if (*++pwchWord == L'\0') {
		// Last letter, Make sure it is valid.
		if (!(pNode->flags & UDF_VALID)) {
			// Not valid end of word.
			return udWordNotFound;
		}

		// Delete the tag if it exists
		if (pNode->flags & UDF_HAS_TAG) {
			NODE	*pTagNode;
			int		iTagNode;

			// Unlink node from trie
			// ASSERT(pNode->iDown != NO_LINK);
			iTagNode		= pNode->iDown;
			pTagNode		= pUDict->pNodeAlloc + iTagNode;
			pNode->iDown	= pTagNode->iDown;

			// Free tag and put node on free list.
			ExternFree((wchar_t *)pTagNode->uu.pTag);
			FreeNode(pUDict, iTagNode, pTagNode);
		}

		// See if we still need this node.
		if (pNode->iDown == NO_LINK) {
			// Don't need this, node, unlink it and put it on free list.
			iNode				= *piNode;
			// ASSERT(pUDict->pNodeAlloc + iNode == pNode);
			*piNode				= pNode->uu.iRight;
			FreeNode(pUDict, iNode, pNode);
		} else {
			// Still need node, Clear flags for valid and tag.
			pNode->flags	&= ~(UDF_HAS_TAG | UDF_VALID);
		}

		return udWordDeleted;
	}

	// Have more letters, so go down to next level, if possable.
	// Deal with the tag node if it exists.
	if (pNode->flags & UDF_HAS_TAG) {
		NODE	* const pTagNode	= pUDict->pNodeAlloc + pNode->iDown;

		piDown	= &pTagNode->iDown;
	} else {
		piDown	= &pNode->iDown;
	}

	// Check for existance of link.
	if (*piDown == NO_LINK) {
		return udWordNotFound;
	}

	// Have next level, process it.
	retVal		= FindAndDelete(pUDict, piDown, pwchWord);

	// Now figure out if we need to free the current node.
	if (pNode->iDown == NO_LINK && !(pNode->flags & UDF_VALID)) {
		// Unneeded node, unlink it and put it on free list.
		iNode				= *piNode;
		// ASSERT(pUDict->pNodeAlloc + iNode == pNode);
		*piNode				= pNode->uu.iRight;
		FreeNode(pUDict, iNode, pNode);
	}

	return retVal;
}

static int
DoEnumerate(
	UDICT				*pUDict,
	int					*pcWords,
	wchar_t				*pWord,
	wchar_t				*pCurPos,
	int					iNode,
	P_UD_ENUM_CALL_BACK	pCallBack,
	void				*pCallBackData
) {
	// ASSERT(pCurPos - pWord < UDICT_MAX_WORD);

	// Loop through each node in this state.
	while (iNode != NO_LINK) {
		NODE	*pNode;
		int		iDown;
		int		status;

		pNode		= pUDict->pNodeAlloc + iNode;

		// Fill in current character in word buffer.
		*pCurPos	= pNode->wchLabel;

		// Check if this node is valid.
		if (pNode->flags & UDF_VALID) {
			const wchar_t	*pTag;

			// Get tag if any.
			if (pNode->flags & UDF_HAS_TAG) {
				const NODE	*pTagNode	= pUDict->pNodeAlloc + pNode->iDown;

				pTag	= pTagNode->uu.pTag;
			} else {
				pTag	= (const wchar_t *)0;
			}

			// Terminate the word.
			*(pCurPos + 1)	= L'\0';

			// Call the callback function.  Catch early abort.
			status	= (*pCallBack)(pCallBackData, *pcWords, pWord, pTag);
			if (status != udSuccess) {
				return status;
			}

			// Count the word.
			++*pcWords;
		}

		// Any thing below here?
		iDown	= iNode;
		if (UDictDownNode((HANDLE)pUDict, (HANDLE *)&iDown) == udSuccess) {
			// Do recursive call.  Catch early abort.
			status	= DoEnumerate(
				pUDict, pcWords, pWord, pCurPos + 1, iDown,
				pCallBack, pCallBackData
			);
			if (status != udSuccess) {
				return status;
			}
		}

		// OK, move on to next node in state.
		iNode	= pNode->uu.iRight;
	}

	return udSuccess;
}

/******************************************************************************\
|	Public APIs
\******************************************************************************/

// Create a new User Dictionary
void *
UDictCreate()
{
	UDICT	*pUDict;

	// Allocate the header.
	pUDict	= (UDICT *)ExternAlloc(sizeof(UDICT));
	if (!pUDict) 
	{
		return NULL;
	}

	// Clear it.
	memset(pUDict, 0, sizeof(*pUDict));

	pUDict->iFreeList	= NO_LINK;
	pUDict->iRoot		= NO_LINK;
	pUDict->bIsChanged	= FALSE;

	if (FALSE == UDictInitLocks(pUDict))
	{
		ExternFree(pUDict);
		return NULL;
	}

	return (void *)pUDict;
}

// Destroy a User Dictionary, free all allocated memory.
int
UDictDestroy(HANDLE hUDict)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;
	int			retVal;
	NODE		*pScan, *pLimit;

	retVal	= udSuccess;

	// Free node array if it exists.
	if (pUDict->pNodeAlloc) {
		// Free any tags in the array first.
		pScan	= pUDict->pNodeAlloc;
		pLimit	= pScan + pUDict->cNodes;
		for ( ; pScan < pLimit; ++pScan) {
			if (pScan->flags & UDF_IS_TAG) {
				// ASSERT(pScan->uu.pTag);
				ExternFree((wchar_t *)pScan->uu.pTag);
			}
		}

		// Now free the actual array.
		ExternFree(pUDict->pNodeAlloc);
	}

	UDictDestroyLocks(pUDict);

	// Free header.
	ExternFree(hUDict);


	return retVal;
}

// Get Handle on root node.
int
UDictRootNode(HANDLE hUDict, HANDLE *phRoot)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;

	if (pUDict->iRoot == NO_LINK) {
		return udFail;
	} else {
		*phRoot	= (HANDLE)pUDict->iRoot;
		return udSuccess;
	}
}

// Move one node to the right (e.g. alternate character to current one).
int
UDictRightNode(HANDLE hUDict, HANDLE *phNode)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;
	const NODE	*pNode	= pUDict->pNodeAlloc + (int)*phNode;
	const int	iRight	= pNode->uu.iRight;

	// ASSERT(!(pNode->flags & UDF_IS_TAG));

	if (iRight == NO_LINK) {
		return udFail;
	} else {
		*phNode	= (HANDLE)iRight;
		return udSuccess;
	}
}

// Move one node to the down (e.g. character following current one).
int
UDictDownNode(HANDLE hUDict, HANDLE *phNode)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;
	const NODE	*pNode	= pUDict->pNodeAlloc + (int)*phNode;
	int			iDown	= pNode->iDown;

	// ASSERT(!(pNode->flags & UDF_IS_TAG));

	// Deal with the tag node if it exists.
	if (pNode->flags & UDF_HAS_TAG) {
		// ASSERT(iDown != NO_LINK);
		const NODE	*pTagNode	= pUDict->pNodeAlloc + iDown;

		iDown	= pTagNode->iDown;
	}

	// Check for existance of link.
	if (iDown == NO_LINK) {
		return udFail;
	} else {
		*phNode	= (HANDLE)iDown;
		return udSuccess;
	}
}

// Fetch the character label on the node.
// Return:
//		The character label on the node.
wchar_t
UDictNodeLabel(HANDLE hUDict, HANDLE hNode)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;
	NODE		* const pNode	= pUDict->pNodeAlloc + (int)hNode;

	// ASSERT(!(pNode->flags & UDF_IS_TAG));

	return pNode->wchLabel;
}

// Fetch information about node.
int
UDictGetNode(HANDLE hUDict, HANDLE hNode, UD_NODE_INFO *pNodeInfo)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;
	NODE		* const pNode	= pUDict->pNodeAlloc + (int)hNode;
	HANDLE		hDown;

	// ASSERT(!(pNode->flags & UDF_IS_TAG));

	// Get label and clear flags.
	pNodeInfo->wchLabel	= pNode->wchLabel;
	pNodeInfo->flags	= 0;

	// Check if valid bit should be set.
	if (pNode->flags & UDF_VALID) {
		pNodeInfo->flags	|= UDNIF_VALID;
	}

	// Get the right pointer.
	if (pNode->uu.iRight != NO_LINK) {
		pNodeInfo->flags	|= UDNIF_HAS_RIGHT;
		pNodeInfo->hRight	= (HANDLE)pNode->uu.iRight;
	} else {
		pNodeInfo->hRight	= (HANDLE)NO_LINK;	// Optional, should make bugs easier to track.
	}
	
	// Since down pointer is complex to compute, call standard routine.
	hDown	= hNode;
	if (UDictDownNode(hUDict, &hDown) == udSuccess) {
		pNodeInfo->flags	|= UDNIF_HAS_DOWN;
		pNodeInfo->hDown	= hDown;
	} else {
		pNodeInfo->hDown	= (HANDLE)NO_LINK;	// Optional, should make bugs easier to track.
	}

	// Get tag.
	if (pNode->flags & UDF_HAS_TAG) {
		pNodeInfo->flags	|= UDNIF_HAS_TAG;
		pNodeInfo->hTag		= (HANDLE)pNode->iDown;
	} else {
		pNodeInfo->hTag		= (HANDLE)NO_LINK;	// Optional, should make bugs easier to track.
	}

	return udSuccess;
}

// Fetch tag
const wchar_t	*UDictFetchTag(
	HANDLE	hUDict, 
	HANDLE	hTag	// Handle on tag to fetch.
) {
	UDICT		* const pUDict	= (UDICT *)hUDict;
	NODE		* const pNode	= pUDict->pNodeAlloc + (int)hTag;

	// ASSERT(pNode->flags & UDF_IS_TAG);

	// Check for the first tag in the list since it needs special handling.
	return pNode->uu.pTag;
}

// Check if the supplied string is a valid word
// Currently only checks if there are no embedded spaces
// June 2001 mrevow
//
// Nov 2001 Remove the space restriction, replace
// it with th restriction that there cannot be leading,
// training or multiple sequential spaces
BOOL checkWordValidity(const wchar_t *pwchWord)
{
	const wchar_t		*pwch = pwchWord;
	const wchar_t		*pwLastSpace = NULL;

	// First check for a NULL pointer, empty string or leading spaces
	if (NULL == pwch || *pwch == '\0' || iswspace(*pwch))
	{
		return FALSE;
	}

	// Check for Consecutive spaces
	// NOTE we know the pointer is not NULL nor 
	// is the string empty
	while(*pwch != '\0')
	{
		if (iswspace(*pwch))
		{
			if (NULL != pwLastSpace)
			{
				// Consecutive Spaces
				return FALSE;
			}

			pwLastSpace = pwch;
		}
		else
		{
			pwLastSpace = NULL;
		}

		++pwch;
	}

	// Check for trailing spaces

	// Must be a string character since the string is not empty
	--pwch;
	if (iswspace(*pwch))
	{
		return FALSE;
	}

	return TRUE;
}

// Strip out illegasl spaces (leading, trailing or consecutive 
// spaces
// Returns
// FALSE - if string is still illegal
BOOL stripIllegalSpaces(wchar_t *pwchWord)
{
	wchar_t				*pwch = pwchWord;				// Leading exploratory point
	wchar_t				*pwCopyPoint = pwchWord;		// Last valid or copy point

	// First check for a NULL pointer or empty string
	if (NULL == pwch || '\0' == *pwch)
	{
		return FALSE;
	}

	while (*pwch != '\0' && iswspace(*pwch))
	{
		++pwch;
	}

	if ('\0' == *pwch)
	{
		// A blank string
		return FALSE;
	}


	// Check for Consecutive spaces
	// NOTE we know the pointer is not NULL nor 
	// is the string empty
	while(*pwch != '\0')
	{
		if (!iswspace(*pwch) || !iswspace(pwch[-1]))
		{
			// Not a consecutive space - copy it
			*pwCopyPoint = *pwch;
			++pwCopyPoint;
		}
		++pwch;
	}

	ASSERT(pwCopyPoint <= pwch);
	ASSERT(pwCopyPoint > pwchWord);

	// Add the NULL terminator
	*pwCopyPoint = *pwch;

	// Check for a trailing space - there should only be one

	// Must be a string character since the string is not empty
	// and it did not have all spaces
	--pwCopyPoint;
	if (iswspace(*pwCopyPoint))
	{
		ASSERT(pwCopyPoint > pwchWord);
		*pwCopyPoint = '\0';
	}

	return TRUE;
}

// Add a word to the user dictionary.  Optional tag allowed.
int
UDictAddWord(HANDLE hUDict, const wchar_t *pwchWord, const wchar_t *pTag)
{
	UDICT		* const pUDict	= (UDICT *)hUDict;
	int			maxNodes;
	int			iAddNode, iLen;
	wchar_t		*pTagCopy;
	wchar_t		*pwchWordCopy = NULL;
	int			retVal = udFail;
	
	// Verify that we actually have a word.
	if (*pwchWord == L'\0') {
		return udFail;
	}

	iLen = wcslen(pwchWord);
	if (FALSE == checkWordValidity(pwchWord))
	{
		// Maybe we can fix it by stripping invalid
		// spaces
		pwchWordCopy = (wchar_t *)ExternAlloc(sizeof(*pwchWordCopy) * (iLen+1));
		if (NULL == pwchWordCopy)
		{
			goto exit;
		}

		wcscpy(pwchWordCopy, pwchWord);

		if (FALSE == stripIllegalSpaces(pwchWordCopy))
		{
			goto exit;
		}
		pwchWord = pwchWordCopy;
	}

	// Verify that we have enough room for the addition.  The worst possable
	// increase is the length of the word plus one for the tag if we have one.
	maxNodes	= pUDict->cNodesUsed;
	maxNodes	+= iLen + (!pTag ? 0 : 1);
	if (maxNodes > pUDict->cNodes) {
		if (!GrowNodeArray(pUDict, maxNodes))
		{
			retVal = udError;
			goto exit;
		}
	}

	// We may also have to make a copy of the tag, we will free it if we don't use it.
	if (pTag) 
	{
		pTagCopy	= (wchar_t *)ExternAlloc(sizeof(wchar_t) * (wcslen(pTag) + 1));

		if (NULL == pTagCopy)
		{
			retVal = udError;
			goto exit;
		}
		wcscpy(pTagCopy, pTag);
	} else 
	{
		pTagCopy	= NULL;
	}


	// Deal with special case of empty dictionary.
	if (pUDict->iRoot == NO_LINK) {
		// Add whole word with no branches.
		iAddNode		= DoAdd(pUDict, pwchWord, pTagCopy);
		pUDict->iRoot	= iAddNode;
		retVal = udWordAdded;
	}
	else 
	{

		// Find where to add the word, and add it.
		retVal	= FindAndAdd(pUDict, pUDict->iRoot, pwchWord, pTagCopy);

		// Free copy of tag if it was not used.
		if (pTagCopy && retVal == udWordFound) {
			ExternFree(pTagCopy);
		}

	}

exit:
	// Free up the copy if it was used
	if (NULL != pwchWordCopy)
	{
		ExternFree(pwchWordCopy);
	}

	return retVal;
}

//------------------------------------------
//
// FindNodeOnLevel 
// 
// Search for a node amongst destination siblings
// that matches the source. Add a new node
// if don't find a matching node.
// Take care of tag
//
// NOTE:
//		The scan to find a match is exhaustive. Further speed
//		enhancements may be obtained by sorting the siblings
//		
//
// CAVEATE:
//  If both source and destination have tags we
// have a conflict. Decision here is to discard
// the source tag, keeping the original one
//
// RETURNS - node offset of the matched node
//
// mrevow Oct 2001
//--------------------------------------------
int FindNodeOnLevel(UDICT *pUDest, NODE *pDest, int iDestOff, UDICT const *pUSrc, NODE *pSrc)
{
	NODE		*pDestNext;
	int			iDestNode = iDestOff;

	// This loop must terminate because we explicitly add
	// a new node onto the end if we don't find a match
	while (pSrc->wchLabel != pDest->wchLabel)
	{
		if (NO_LINK == pDest->uu.iRight)
		{
			// Reached the End Add a new node with no children or siblings
			iDestNode = AllocNode(pUDest, &pDestNext);
			pDestNext->wchLabel = pSrc->wchLabel;
			pDestNext->iDown	= NO_LINK;
			pDestNext->uu.iRight= NO_LINK;

			// No flags - we add these incrementally later
			pDestNext->flags	= 0;

			// Hook new node into list
			pDest->uu.iRight	= iDestNode;
			pDest = pDestNext;
		}
		else
		{
			iDestNode = pDest->uu.iRight;
			pDest = pUDest->pNodeAlloc + iDestNode;
		}
	}

	// If both source and destination have tags then keep the
	// Original destination tag - i.e. Discard the source tag
	if (pSrc->flags & UDF_HAS_TAG && !(pDest->flags & UDF_HAS_TAG)) 
	{
		const NODE	*pTagNode	= pUSrc->pNodeAlloc + pSrc->iDown;
		pDest->iDown = CreateTagNode(pUDest, pTagNode->uu.pTag, NO_LINK);
		pDest->flags |= UDF_HAS_TAG;
	}
	
	return iDestNode;
}

//------------------------------------------
//
// UDictMergeNodesAtOneLevel 
// 
// Merge all sibling nodes from source dictionary
// of Node iSrcOff into the  
// destination dictionary. Create nodes in
// destination that don't already exist. 
// For each sibling recurse down to any children
//
// RETURNS - Number of valid words ADDED
//
// mrevow Oct 2001
//--------------------------------------------
int UDictMergeNodesAtOneLevel(UDICT const *pUSrc, int iSrcOff, UDICT *pUDest, int iDestOff, int cWordAdd)
{
	NODE		*pSrcStart, *pSrcNext, *pDestStart, *pDestNext;

	ASSERT(iSrcOff > NO_LINK && iDestOff > NO_LINK);

	pSrcStart = pSrcNext = pUSrc->pNodeAlloc + iSrcOff;
	pDestStart = pUDest->pNodeAlloc + iDestOff;

	while (NO_LINK != iSrcOff)
	{
		int			iSrcDown, iDestDown;
		int			iDestNext;

		// Search if this node exists on this level If none is found - 
		// return a new Node
		iDestNext = FindNodeOnLevel(pUDest, pDestStart, iDestOff, pUSrc, pSrcNext);

		pDestNext = pUDest->pNodeAlloc + iDestNext;

		if (pSrcNext->flags & UDF_VALID)
		{
			if (! (pDestNext->flags & UDF_VALID) )
			{
				++cWordAdd;
			}
			pDestNext->flags |= UDF_VALID;
		}

		// Go down to next level
		iSrcDown = iSrcOff;
		if (udSuccess == UDictDownNode((HANDLE)pUSrc, (HANDLE *)&iSrcDown))
		{
			iDestDown = iDestNext;
	
			// Create a 'down' node in the destination when none already exists
			if (udSuccess != UDictDownNode((HANDLE)pUDest, (HANDLE *)&iDestDown))
			{
				NODE		*pDestDown, *pSrcDown;

				iDestDown = AllocNode(pUDest, &pDestDown);
				ASSERT(iDestDown > NO_LINK);

				// Link the new guy into my parent
				pDestNext->iDown = iDestDown;
				pSrcDown = pUSrc->pNodeAlloc + iSrcDown;


				// Copy in label, tags, flags and complete initialzation of the new node
				pDestDown->wchLabel		= pSrcDown->wchLabel;

				// Create a tag if the Source has one
				if (pSrcDown->flags & UDF_HAS_TAG)
				{
					const NODE	*pTagNode	= pUSrc->pNodeAlloc + pSrcDown->iDown;
					pDestDown->iDown = CreateTagNode(pUDest, pTagNode->uu.pTag, NO_LINK);
				}
				else
				{
					pDestDown->iDown = NO_LINK;
				}

				if (pSrcDown->flags & UDF_VALID)
				{
					++cWordAdd;
					pDestDown->flags |= UDF_VALID;
				}

				// So far I have no siblings
				pDestDown->uu.iRight	= NO_LINK;

				// Possible speedup available here to do copy
				// instead of falling through and recursing
			}

			// Recurse down to next level
			cWordAdd = UDictMergeNodesAtOneLevel(pUSrc, iSrcDown, pUDest, iDestDown, cWordAdd);
		}

		iSrcOff = pSrcNext->uu.iRight;
		if (NO_LINK != iSrcOff)
		{
			pSrcNext = pUSrc->pNodeAlloc + iSrcOff;
		}
	}

	return cWordAdd;
}
//--------------------------------------------------
// UDictCopyAll
//
// Copy all nodes from the source to the destination.//
// Assumption:
//   pUDest->cNode >= pUSrc->cNode
//
// This is guaranteed by the calling convention
// in uDICTMerge
//
// mrevow Oct 2001
//--------------------------------------------------
int UDictCopyAll(UDICT const *pUSrc, UDICT	*pUDest)
{
	NODE	*pNextSrc, *pNextDest;
	int		iNode = 0;
	int		cWordAdd = 0;

	ASSERT(NO_LINK == pUDest->iRoot);
	ASSERT(0 == pUDest->cNodesUsed);
	ASSERT(pUSrc->cNodes <= pUDest->cNodes);

	pNextSrc	= pUSrc->pNodeAlloc;
	pNextDest	= pUDest->pNodeAlloc;

	for (iNode = 0 ; iNode < pUSrc->cNodes  ; ++iNode, ++pNextSrc, ++pNextDest)
	{
		*pNextDest = *pNextSrc;
		cWordAdd += (pNextSrc->flags & UDF_VALID);
	}

	pUDest->cNodesUsed = pUSrc->cNodesUsed;
	pUDest->iRoot	= pUSrc->iRoot;
	pUDest->iFreeList = pUSrc->iFreeList;

	return cWordAdd;
}
//--------------------------------------------------
// UDictMerge
//
// Top level for merging a source uDict into
// a destination UDict. Method tries to
// emphasize speed
//
// If the destination is empty just duplicate
// the source into the destination
// otherwise do the full merge
//
// CAVEATE
// In both case we probably waste memory because we 
// preallocate enough nodes assuming no common nodes
// Could improve this by incrementing allocating nodes
//
// RETURNS
// Number of words added to the destination
//
// mrevow Oct 2001
//--------------------------------------------------
int UDictMerge(HANDLE hUSrc, HANDLE hUDest)
{
	UDICT		const	*pUSrc		= (UDICT *)hUSrc;
	UDICT				*pUDest		= (UDICT *)hUDest;
	int					cWordAdd	= 0;
	int					iMaxNode;

	if (NO_LINK == pUSrc->iRoot || pUSrc->cNodesUsed <= 0)
	{
		return -1;
	}

	// Gurantee that enough nodes are allocated
	iMaxNode	= pUSrc->cNodesUsed + pUDest->cNodesUsed;

	if (iMaxNode > pUDest->cNodes) 
	{
		if (!GrowNodeArray(pUDest, iMaxNode)) 
		{
			return -1;
		}
	}


	if (NO_LINK == pUDest->iRoot)
	{
		// Deal with special case of an empty Destination tree
		cWordAdd = UDictCopyAll(pUSrc, pUDest);
	}
	else
	{
		// Need to do a real merge
		cWordAdd = UDictMergeNodesAtOneLevel(pUSrc, pUSrc->iRoot, pUDest, pUSrc->iRoot, cWordAdd);
	}

	pUDest->bIsChanged	= TRUE;
	pUDest->iLen		+= pUSrc->iLen;

	return cWordAdd;
}

// Delete a word from the user dictionary.
int		UDictDeleteWord(
	HANDLE			hUDict,
	const wchar_t	*pwchWord
) {
	UDICT		* const pUDict	= (UDICT *)hUDict;

	// Verify there are any words before we try to delete one of them.
	if (pUDict->iRoot == NO_LINK) {
		return udWordNotFound;
	}

	// OK, call recursive code to find and delete the word.
	return FindAndDelete(pUDict, &pUDict->iRoot, pwchWord);
}

// Find a word, also gets its tag if it has one.
// Return:
//		udWordNotFound	Word was not in dictionary, no tag handle returned.
//		udGotTag,		Tag for node returned.
int		UDictFindWord(
	HANDLE			hUDict, 
	const wchar_t	*pwchWord,
	const wchar_t	**ppTag		// Out: pointer tag.
) {
	UDICT	* const pUDict	= (UDICT *)hUDict;
	int		iState;
	NODE	*pNode;

	// Verify that we actually have a word.
	if (*pwchWord == L'\0') {
		return udWordNotFound;
	}

	// Scan one character at a time.
	iState	= pUDict->iRoot;
	pNode	= (NODE *)0;
	for ( ; *pwchWord; ++pwchWord) {
		// See if character exists in the state.
		pNode	= FindInState(pUDict, iState, *pwchWord);
		if (!pNode) {
			return udWordNotFound;
		}

		// Get index of next state, dealing with tag if needed.
		iState		= pNode->iDown;
		if (pNode->flags & UDF_HAS_TAG) {
			NODE	*pTagNode;

			pTagNode	= pUDict->pNodeAlloc + iState;
			iState		= pTagNode->iDown;
		}
	}

	if (pNode)	// This is not needed but Prefast would report a bug otherwise
	{
		if (!(pNode->flags & UDF_VALID)) {
			return udWordNotFound;
		}

	}
	if (ppTag) {
		if (pNode->flags & UDF_HAS_TAG) {
			NODE	* const pTagNode	= pUDict->pNodeAlloc + pNode->iDown;

			*ppTag		= pTagNode->uu.pTag;
		} else {
			*ppTag		= (wchar_t *)0;
		}
	}

	return udWordFound;
}

// Enumerate the tree.  Call a callback function for each word in selected range.
int		UDictEnumerate(
	HANDLE				hUDict,
	P_UD_ENUM_CALL_BACK	pCallBack,
	void				*pCallBackData
) {
	UDICT	* const pUDict	= (UDICT *)hUDict;
	int		cWords;
	int		status;
	wchar_t	aWordBuf[UDICT_MAX_WORD + 1];

	// Make sure we have some words.
	if (pUDict->iRoot == NO_LINK) {
		return udSuccess;
	}

	// Do recursive traversal.
	cWords	= 0;
	status	= DoEnumerate(
		pUDict, &cWords, aWordBuf, aWordBuf, pUDict->iRoot,
		pCallBack, pCallBackData
	);

	// Figure out correct return value.
	// ASSERT(status == udFail || status == udSuccess || status == udStopEarly);
	return (status == udFail) ? udFail : udSuccess;
		
}


/***********************************************************
 * Functions implementing Read/Write synchronization.
 *
 * Basic idea is that we allow multiple read accesse to the 
 * data structure but only 1 write access. Read/Writes block
 * each other. 
 * The 'global' event hRWevent regulates that only one of
 * Read/write is available at a time. The 'local' hWriteLockMutex
 * allows only a single write access while the counter and hReadLockEvent
 * guard read events
 *
 * Synchronization is achieved using 4 functions:
 *
 * UdictInitLocks	- Initialize and create the locks - called on HWL creation
 * UDictDestroyLocks - Destroy the locks on destruction of HWL
 * UDictGetLock		- Request a lock (blocks until lock available)
 * UDictReleaseLock - Release a lock when finished using it
 *
 * mrevow June 2001
 *
 ******************************************************/

BOOL UDictInitLocks(UDICT *pDict)
{
	pDict->hReadLockEvent	= CreateEvent(NULL, TRUE, FALSE, NULL);		// Initialized not signalled
	pDict->hWriteLockMutex	= CreateMutex(NULL, FALSE, NULL);
	pDict->hRWevent			= CreateEvent(NULL, FALSE, TRUE, NULL);		// Initialize signalled

	if (   !pDict->hReadLockEvent
		|| !pDict->hWriteLockMutex
		|| !pDict->hRWevent )
	{
		UDictDestroyLocks(pDict);
		return FALSE;
	}

	pDict->cReadLock = -1;									// No Readers 
	return TRUE;
}

void UDictDestroyLocks(UDICT *pDict)
{
	if (pDict)
	{
		if (pDict->hReadLockEvent)
		{
			CloseHandle(pDict->hReadLockEvent);
		}

		if (pDict->hWriteLockMutex)
		{
			CloseHandle(pDict->hWriteLockMutex);
		}

		if (pDict->hRWevent)
		{
			CloseHandle(pDict->hRWevent);
		}
	}
}

void UDictGetLock(HWL hwl, UDICT_IDX idx)
{
	UDICT *pDict	= (UDICT *)hwl;

	if (pDict)
	{
		if (WRITER == idx)
		{
			// Only 1 writer at a time - so must first must get the mutex, then
			WaitForSingleObject(pDict->hWriteLockMutex, INFINITE);

			// Ensure no readers busy
			WaitForSingleObject(pDict->hRWevent, INFINITE);
		}
		else if (READER == idx)
		{
			// Am I the first reader?
			if (InterlockedIncrement(&pDict->cReadLock)  == 0)
			{
				// Check for any writers
				WaitForSingleObject(pDict->hRWevent, INFINITE);
				
				// Enable all subsequent writers
				SetEvent(pDict->hReadLockEvent);
			}

			WaitForSingleObject(pDict->hReadLockEvent, INFINITE);
		}
	}
}


void UDictReleaseLock(HWL hwl, UDICT_IDX idx)
{
	UDICT *pDict	= (UDICT *)hwl;

	if (pDict)
	{
		if (WRITER == idx)
		{
			// First must give up control of the global event (because of order of GetLock for WRITER)
			SetEvent(pDict->hRWevent);

			// Now can release the local writer
			ReleaseMutex(pDict->hWriteLockMutex);
		}

		else if (READER == idx)
		{
			// AM I the last reader
			if (InterlockedDecrement(&pDict->cReadLock) < 0)
			{
				// Ok Release locks in reverse order of GetLock for READER
				ResetEvent(pDict->hReadLockEvent);
				SetEvent(pDict->hRWevent);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\toolprs.c ===
/******************************************************************************\
 *	FILE:	toolprs.c
 *
 *	This is the command line argument parsing code called by the template
 *	toolmain.c, which is used in all the command line tools.  Since it may
 *	be necessary to supp
\******************************************************************************/

// Standard Headers.
// SETUP: all tools need common.h, some need other headers as well, 
// add any needed ones.
#include <stdlib.h>
#include <direct.h>		// For _tgetcwd()
#include <time.h>		// For time() & ctime()
#include <fcntl.h>
#include <io.h>
#include <tchar.h>
#include "common.h"
#include "toolmain.h"

// Place to store program name.
static TCHAR		g_pProgram[_MAX_FNAME];

// Timing information used by start and end status procedures.
static time_t		g_timeStart, g_timeEnd;

// Code to actually process a switch.
// SETUP: You only need to change this if you have a new switch type.
// Return of -1 is error, otherwise, this specifies how many extra
// parameters were used.
static int
ProcessSwitch(
	SWITCH_SPEC	const *pSwitchSpec,	// Selected switch spec.
	int			argc,				// Number of remaining arguments
	TCHAR		**argv				// Pointer to remaining arguments
) {
	switch (pSwitchSpec->switchType) {
		case SWITCH_HELP :		// Return error, whitch prints help.
			return -1;

		case SWITCH_BOOL :		// Boolean,
			*(BOOL *)pSwitchSpec->pSwitch	= TRUE;
			break;

		case SWITCH_STRING :	// A string.
			// Make sure value exists.
			if (argc < 1) {
				 _ftprintf(stderr, _T("Missing value for switch '%c'\n"),
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			*(TCHAR **)pSwitchSpec->pSwitch	= argv[0];
			return 1;

		case SWITCH_UNSIGNED :	{	// An unsigned number.
			unsigned int		iValue;
			TCHAR				*pEnd;

			// Make sure value exists.
			if (argc < 1) {
				_ftprintf(stderr, _T("Missing value for switch '%c'\n"),
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			// Convert number
			iValue	= _tcstol(argv[0], &pEnd, 10);
			if (*pEnd != L'\0' || pEnd == argv[0]) {
				_ftprintf(stderr, _T("Invalid switch value for switch '%c'\n"),
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			*(unsigned int *)pSwitchSpec->pSwitch	= iValue;
			return 1;
		}

		default:
			_ftprintf(stderr, _T("Program error in switch parser!\n"));
			exit(-2);
	}

	return 0;  // Default, no extra args used.
}

// Return a string representing the value of the passed in switch.
// SETUP: You only need to change this if you added a new type above.
static TCHAR *
SwitchToString(SWITCH_SPEC	const *pSwitchSpec)
{
	static TCHAR		aRetBuf[256];

	switch (pSwitchSpec->switchType) {
		case SWITCH_HELP :		// Don't bother showing state for help.
			return (TCHAR *)0;;

		case SWITCH_BOOL :		// Boolean,
			if (*(BOOL *)pSwitchSpec->pSwitch) {
				return _T("TRUE");
			} else {
				return _T("FALSE");
			}
			break;	// Should never get here.

		case SWITCH_STRING :	// A string.
			return *(TCHAR **)pSwitchSpec->pSwitch;

		case SWITCH_UNSIGNED :	// An unsigned number.
			_stprintf(aRetBuf, _T("%u"), *(unsigned int *)pSwitchSpec->pSwitch);
			return aRetBuf;

		default:
			_ftprintf(stderr, _T("Program error in switch printer!\n"));
			exit(-2);
	}

	// Should never get here, but don't fail if we do.
	return (TCHAR *)0;;
}

// Code to actually process an argument.
// SETUP: You only need to change this if you have a new argument type.
// Return of FALSE is error, TRUE is success.
static BOOL
ProcessArgument(ARG_SPEC const *pArgSpec, TCHAR *pArgText)
{
	BOOL	fFixMode;
	FILE	*pFile;
	TCHAR	pError[256];
	TCHAR	pFileInput[256];

	// Record text of argument.
	*pArgSpec->ppText	= pArgText;

	// Now process based on type of argument.
	switch (pArgSpec->argType) {
		case ARG_STRING :		// Any old string
			// Saving the string is all we needed to do.
			break;

		case ARG_FILE :			// File to open with specified mode.
			// Check for special names for standard IO files.
			fFixMode	= FALSE;
			if (_tcscmp(pArgText, ARG_STDIN) == 0) {
				pFile		= stdin;
				fFixMode	= TRUE;
			} else if (_tcscmp(pArgText, ARG_STDOUT) == 0) {
				pFile		= stdout;
				fFixMode	= TRUE;
			} else if (_tcscmp(pArgText, ARG_STDERR) == 0) {
				pFile		= stderr;
				fFixMode	= TRUE;
			} else {
				// Normal open code.
				pFile = _tfopen(pArgText, pArgSpec->pMode);
				if (!pFile) {
					_stprintf(pError, _T("Couldn't open %s with mode %s"), 
						pArgText, pArgSpec->pMode
					);
					_tperror(pError);
					return FALSE;;
				}
			}

			// For already opened files, we may need to make them binary.
			if (fFixMode 
				&& (pArgSpec->pMode[_tcscspn(pArgSpec->pMode, _T("bB"))] != '\0')
			) {
				int		result;

				result = _setmode(_fileno(pFile), _O_BINARY);
				if( result == -1 ) {
					_stprintf(pError, _T("Couldn't set %s to binary mode"), pArgText);
					_tperror(pError);
				}
			}
			*(FILE **)pArgSpec->pValue	= pFile;
			break;

		case ARG_FILE_UTIL :	// File to open with UtilOpen
			if (_tcschr(pArgText, L'\\')) {
				// Have path, can't use UtilOpen.
				pFile = _tfopen(pArgText, pArgSpec->pMode);
			} else {
				// No path, use UtilOpen.
				pFile = UtilOpen(
					pArgText, pArgSpec->pMode, 
					pFileInput, 256
				);

				// Copy updated path, note that this is never freed.
				*pArgSpec->ppText	= _tcsdup(pFileInput);
			}
			if (!pFile) {
				_stprintf(pError, _T("Couldn't open %s with mode %s"), 
					pArgText, pArgSpec->pMode
				);
				_tperror(pError);
				return FALSE;;
			}
			*(FILE **)pArgSpec->pValue	= pFile;
			break;

		case ARG_UNSIGNED :	{	// An unsigned number.
			unsigned int		iValue;
			TCHAR				*pEnd;

			// Convert number
			iValue	= _tcstol(pArgText, &pEnd, 10);
			if (*pEnd != L'\0' || pEnd == pArgText) {
				_ftprintf(stderr, _T("Not a valid unsigned number: %s\n"), pArgText);
				return FALSE;
			}

			*(unsigned int *)pArgSpec->pValue	= iValue;
			break;
		}

		default:
			_ftprintf(stderr, _T("Program error in argument parser!\n"));
			exit(-2);
	}

	return TRUE;  // Default, success.
}

// Code to cleanup anything related to an argument just before the
// program exits.  Typically this is where we close the files we
// opened at startup time.
// SETUP: You only need to change this if you have a new argument type.
// Return of FALSE is error, TRUE is success.
static BOOL
CleanupArgument(ARG_SPEC const *pArgSpec)
{
	// Now process based on type of argument.
	switch (pArgSpec->argType) {
		case ARG_FILE :			// File to open with specified mode.
		case ARG_FILE_UTIL :	// File to open with UtilOpen
			// Close up the file.
			if (fclose(*(FILE **)pArgSpec->pValue) != 0) {
				return FALSE;
			}
			break;

		case ARG_STRING :		// Any old string
		default:
			// No processing needed before exit.
			break;
	}

	return TRUE;  // Default, success.
}

// Code to parse the arguments.
BOOL
ToolMainParseArguments(PARSE_INFO const *pParseInfo, int argc, TCHAR **argv)
{
	int		cArgsParsed;
	TCHAR	pDrive[_MAX_DRIVE], pDir[_MAX_DIR], pExt[_MAX_EXT];

	// Deal with program name.
	_tsplitpath(argv[0], pDrive, pDir, g_pProgram, pExt); 
	--argc;
	++argv;

	// Scan all the arguments.
	cArgsParsed		= 0;
	while (argc > 0) {
		// Check for switches
		if (argv[0][0] == L'-' || argv[0][0] == L'/') {
			// We have a switch list
			TCHAR		*pScan;
			int			cSwitchValues;

			pScan			= argv[0] + 1;
			--argc;
			++argv;
			for (; *pScan; ++pScan) {
				SWITCH_SPEC		const *pScanSS;
				SWITCH_SPEC		const *pLimitSS;

				// Figure out which switch it is.
				pLimitSS  = pParseInfo->pSwitchSpecs + pParseInfo->cSwitchSpecs;
				for (
					pScanSS = pParseInfo->pSwitchSpecs;
					pScanSS < pLimitSS;
					++pScanSS
				) {
					if (*pScan == pScanSS->wchSwitch) {
						// Found switch
						break;
					}
				}

				// Check for falling off end of list.
				if (pScanSS >= pLimitSS) {
					_ftprintf(stderr, _T("Unknown switch '%c'\n"), *pScan);
					return FALSE;
				}

				// Found switch, process it.
				cSwitchValues	= ProcessSwitch(pScanSS, argc, argv);
				if (cSwitchValues < 0) {
					return FALSE;
				}
				argc			-= cSwitchValues;
				argv			+= cSwitchValues;
			}
		} else {
			// We have an argument.  Have we run out of known ones?
			if (cArgsParsed >= pParseInfo->cArgSpecs) {
				_ftprintf(stderr, _T("Too many arguments provided.\n"));
				return FALSE;
			}

			// OK, it is expected, process it.
			if (!ProcessArgument(
				pParseInfo->pArgSpecs + cArgsParsed, argv[0]
			)) {
				return FALSE;
			}

			// Argument successfully processed.
			++cArgsParsed;
			--argc;
			++argv;
		}
	}
	
	// Handle defaulted arguments.
	while (cArgsParsed < pParseInfo->cArgSpecs) {
		if (!pParseInfo->pArgSpecs[cArgsParsed].pDefault) {
			_ftprintf(stderr, _T("Too few arguments specified.\n"));
			return FALSE;
		}

		// Handle default value.
		if (!ProcessArgument(
			pParseInfo->pArgSpecs + cArgsParsed,
			pParseInfo->pArgSpecs[cArgsParsed].pDefault
		)) {
			return FALSE;
		}

		// Argument successfully defaulted.
		++cArgsParsed;
	}

	return TRUE;
}

// Code to print out usage message.
void
ToolMainUsage(PARSE_INFO const *pParseInfo)
{
	int		ii;

	_ftprintf(stderr, _T("Usage: %s %s\n"),
		g_pProgram, pParseInfo->ppUsageStrings[0]
	);

	for (ii = 1; ii < pParseInfo->cUsageStrings; ++ii) {
		_ftprintf(stderr, _T(" %s\n"), pParseInfo->ppUsageStrings[ii]);
	}
}

// Output header for log file.
void
ToolMainLogHeader(PARSE_INFO const *pParseInfo, int argc, TCHAR **argv)
{
	FILE	* const pLogFile	= *pParseInfo->ppLogFile;
	int			ii;
	int			maxName;
	TCHAR		pWorkingDir[256];

	// Log name of program and the command line.
	_ftprintf(pLogFile, _T("Application: %s\n"), g_pProgram);

	_ftprintf(pLogFile, _T("Command line: "));
	for (ii = 0; ii < argc; ++ii) {
		_ftprintf(pLogFile, _T("%s "), argv[ii]);
	}
	putwc('\n',pLogFile);

	// Log directory we are running from.
	_tgetcwd(pWorkingDir, 256);
	_ftprintf(pLogFile, _T("Working Directory: %s\n"), pWorkingDir);

	// Log the values for each switch.
	_ftprintf(pLogFile, _T("Program switch values:\n"));
	for (ii = 0; ii < pParseInfo->cSwitchSpecs; ++ii) {
		TCHAR		*pValueStr;

		// Make sure we have a value worth printing.
		pValueStr	= SwitchToString(pParseInfo->pSwitchSpecs + ii);
		if (pValueStr) {
			_ftprintf(pLogFile, _T("  -%c is %s\n"),
				pParseInfo->pSwitchSpecs[ii].wchSwitch, pValueStr
			);
		}
	}

	// Figure out longest label to use in formating list.
	maxName	= 0;
	for (ii = 0; ii < pParseInfo->cArgSpecs; ++ii) {
		int		cName;

		cName	= _tcslen(pParseInfo->pArgSpecs[ii].pName);
		if (maxName < cName) {
			maxName	= cName;
		}
	}

	// Log values for each parameter
	_ftprintf(pLogFile, _T("Program argument values:\n"));
	for (ii = 0; ii < pParseInfo->cArgSpecs; ++ii) {
		_ftprintf(pLogFile, _T("%*s: %s\n"),
			maxName + 2, pParseInfo->pArgSpecs[ii].pName,
			*pParseInfo->pArgSpecs[ii].ppText
		);
	}

	// Log the time we started.
	time(&g_timeStart);
	_ftprintf(pLogFile, _T("Start Time: %s"), _tctime(&g_timeStart));

	// Blank line to seperate this from anything the program logs.
	putwc('\n', pLogFile);
}

// Output Trailer for log file.
void
ToolMainLogTrailer(PARSE_INFO const *pParseInfo)
{
	FILE	* const pLogFile	= *pParseInfo->ppLogFile;

	// A Blank line to seperate from any logged messages.
	putwc('\n', pLogFile);

	// When did we finish, and how long did we run?
	time(&g_timeEnd);
	_ftprintf(pLogFile, _T("End Time: %s"), _tctime(&g_timeEnd));
	_ftprintf(pLogFile, _T("Elapsed Time: %d seconds\n"), g_timeEnd - g_timeStart);
}

// Close all the files we opened up.
BOOL
ToolMainCleanup(
	PARSE_INFO		const *pParseInfo
) {
	BOOL	status;
	int		ii;

	// Default to success.
	status	= TRUE;

	// Close up the arguments.
	for (ii = 0; ii < pParseInfo->cArgSpecs; ++ii) {
		if (!CleanupArgument(pParseInfo->pArgSpecs + ii)) {
			status	= FALSE;
		}
	}

	// Give some indication of a problem to the outside world if cleanup
	// was not successfull.
	if (!status) {
		_ftprintf(stderr, _T("Error during cleanup?!?\n"));
	}

	// Let caller know status.
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\xjis.c ===
/******************************Module*Header*******************************\
* Module Name: xjis.c
*
* Gives the folding tables and conversion tables in a format that requires
* no other files or include files.
*
* Created: 02-Oct-1996 08:28:15
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "common.h"

// Integer Log Table

const static unsigned short logdiff[] =
{
    2440, 2033, 1844, 1719, 1626, 1551, 1489, 1436,
    1389, 1348, 1310, 1276, 1245, 1216, 1189, 1164,
    1140, 1118, 1097, 1077, 1058, 1040, 1023, 1006,
     990,  975,  960,  946,  932,  919,  906,  894,
     882,  870,  859,  848,  837,  826,  816,  806,
     796,  787,  778,  769,  760,  751,  742,  734,
     726,  718,  710,  702,  694,  687,  680,  672,
     665,  658,  651,  645,  638,  631,  625,  619,
     612,  606,  600,  594,  588,  582,  576,  571,
     565,  559,  554,  548,  543,  538,  532,  527,
     522,  517,  512,  507,  502,  497,  493,  488,
     483,  478,  474,  469,  465,  460,  456,  451,
     447,  443,  438,  434,  430,  426,  421,  417,
     413,  409,  405,  401,  397,  393,  390,  386,
     382,  378,  374,  371,  367,  363,  360,  356,
     352,  349,  345,  342,  338,  335,  331,  328,
     324,  321,  318,  314,  311,  308,  304,  301,
     298,  295,  291,  288,  285,  282,  279,  276,
     272,  269,  266,  263,  260,  257,  254,  251,
     248,  245,  242,  240,  237,  234,  231,  228,
     225,  222,  220,  217,  214,  211,  208,  206,
     203,  200,  197,  195,  192,  189,  187,  184,
     181,  179,  176,  174,  171,  168,  166,  163,
     161,  158,  156,  153,  151,  148,  146,  143,
     141,  138,  136,  133,  131,  129,  126,  124,
     121,  119,  117,  114,  112,  110,  107,  105,
     103,  100,   98,   96,   93,   91,   89,   86,
      84,   82,   80,   78,   75,   73,   71,   69,
      66,   64,   62,   60,   58,   56,   53,   51,
      49,   47,   45,   43,   41,   38,   36,   34,
      32,   30,   28,   26,   24,   22,   20,   18,
      16,   14,   12,   10,    8,    6,    4,    2
};

int Distance(int a, int b)
{
    return ((int) sqrt((double) (a * a + b * b)));
}

int AddLogProb(int a, int b)
{
    int diff = a - b;

// We will compute a function from the difference between the max of the two
// and the min and we will add that back to the max.  We only need the larger
// of the two values for the remainder of the computation.  We pick 'a' for this.

    if (diff < 0)
    {
        diff = -diff;
        a = b;
    }

// If the difference is too large, the result is simply the max of the two

    if (diff >= logdiff[0])
        return a;

// Otherwise, we have to find it in the table.  Use a binary search to convert
// the difference to an index value.

    {
        const unsigned short *pLow = &logdiff[0];
        const unsigned short *pTop = &logdiff[INTEGER_LOG_SCALE];
        const unsigned short *pMid = (const unsigned short *) 0L;

        while (1)
        {
            pMid = pLow + (pTop - pLow) / 2;

            if (pMid == pLow)
                break;

            if (diff < *pMid)
                pLow = pMid;
            else
                pTop = pMid;
        }

        a += pLow - &logdiff[0] + 1;
    }

    return a;
}

// KANJI STUFF - Folding table - look alike characters are folded together.

const WORD mptokenwmatches[TOKEN_LAST - TOKEN_FIRST + 1][KANJI_MATCHMAX] =
{
    {0x82a0,0x829f,0,0,0,0},          // 600  0x258
    {0x82a2,0x82a1,0,0,0,0},          // 601  0x259
    {0x82a4,0x82a3,0,0,0,0},          // 602  0x25a
    {0x82a6,0x82a5,0,0,0,0},          // 603  0x25b
    {0x82a8,0x82a7,0,0,0,0},          // 604  0x25c
    {0x82c2,0x82c1,0,0,0,0},          // 605  0x25d
    {0x82e2,0x82e1,0,0,0,0},          // 606  0x25e
    {0x82e4,0x82e3,0,0,0,0},          // 607  0x25f
    {0x82e6,0x82e5,0,0,0,0},          // 608  0x260
    {0x82ed,0x82ec,0,0,0,0},          // 609  0x261
    {0x8341,0x8340,0,0,0,0},          // 610  0x262
    {0x8343,0x8342,0,0,0,0},          // 611  0x263
    {0x8345,0x8344,0,0,0,0},          // 612  0x264
    {0x8349,0x8348,0,0,0,0},          // 613  0x265
    {0x8350,0x8396,0,0,0,0},          // 614  0x266
    {0x8363,0x8362,0,0,0,0},          // 615  0x267
    {0x8384,0x8383,0,0,0,0},          // 616  0x268
    {0x8386,0x8385,0,0,0,0},          // 617  0x269
    {0x8388,0x8387,0,0,0,0},          // 618  0x26a
    {0x838f,0x838e,0,0,0,0},          // 619  0x26b
    {0x82d6,0x8377,0,0,0,0},          // 620  0x26c
    {0x82d7,0x8378,0,0,0,0},          // 621  0x26d
    {0x82d8,0x8379,0,0,0,0},          // 622  0x26e
    {0x836a,0x93f1,0},                // 623  0x26f
    {0x8347,0x8346,0x8d48,0,0,0},     // 624  0x270
    {0x834a,0x8395,0x97cd,0,0,0},     // 625  0x271
    {0x838d,0x8cfb,0x9a98,0,0,0},     // 626  0x272
    {0x8283,0x8262,0,0,0,0},          // 627  0x273
    {0x8142,0x824F,0x828f,
     0x826e,0x814b,0x815a},           // 628  0x274
    {0x8290,0x826f,0,0,0,0},          // 629  0x275
    {0x8293,0x8272,0,0,0,0},          // 630  0x276
    {0x8295,0x8274,0,0,0,0},          // 631  0x277
    {0x8296,0x8275,0,0,0,0},          // 632  0x278
    {0x8297,0x8276,0,0,0,0},          // 633  0x279
    {0x8298,0x8277,0,0,0,0},          // 634  0x27a
    {0x829a,0x8279,0,0,0,0},          // 635  0x27b
    {0x8145,0x8144,0,0,0,0},          // 636  0x27c
    {0x88ea,0x815b,0x815c,
     0x815d,0x817c,0x0000},           // 637  0x27d
    {0x8f5c,0x817b,0,0,0,0},          // 638  0x27e
    {0x836E,0x94AA,0,0,0,0},          // 639  0x27f
    {0x8143,0x8166,0x818C,0,0,0},     // 640  0x280
    {0x8141,0x8165,0,0,0,0},          // 641  0x281 ??? Really
    {0x8156,0x8168,0x818D,0,0,0},     // 642  0x282
    {0x88e4,0x8194,0,0,0,0},          // 643  0x283
};

// Tells the combined recmask for the folded characters.

const RECMASK mptokenrecmask[TOKEN_LAST - TOKEN_FIRST + 1] =
{
	ALC_HIRAGANA,                                     // 600
	ALC_HIRAGANA,                                     // 601
	ALC_HIRAGANA,                                     // 602
	ALC_HIRAGANA,                                     // 603
	ALC_HIRAGANA,                                     // 604
	ALC_HIRAGANA,                                     // 605
	ALC_HIRAGANA,                                     // 606
	ALC_HIRAGANA,                                     // 607
	ALC_HIRAGANA,                                     // 608
	ALC_HIRAGANA,                                     // 609
	ALC_KATAKANA,                                     // 610
	ALC_KATAKANA,                                     // 611
	ALC_KATAKANA,                                     // 612
	ALC_KATAKANA,                                     // 613
	ALC_KATAKANA,                                     // 614
	ALC_KATAKANA,                                     // 615
	ALC_KATAKANA,                                     // 616
	ALC_KATAKANA,                                     // 617
	ALC_KATAKANA,                                     // 618
	ALC_KATAKANA,                                     // 619
	ALC_KATAKANA | ALC_HIRAGANA,                      // 620
	ALC_KATAKANA | ALC_HIRAGANA,                      // 621
	ALC_KATAKANA | ALC_HIRAGANA,                      // 622
	ALC_KATAKANA | ALC_JIS1,                          // 623
	ALC_KATAKANA | ALC_JIS1,                          // 624
	ALC_KATAKANA | ALC_JIS1,                          // 625
	ALC_KATAKANA | ALC_JIS1 | ALC_JIS2,               // 626
	ALC_ALPHA,                                        // 627
	ALC_ALPHA | ALC_PUNC | ALC_KATAKANA |
	ALC_JIS1 | ALC_NUMERIC,                           // 628
	ALC_ALPHA,                                        // 629
	ALC_ALPHA,                                        // 630
	ALC_ALPHA,                                        // 631
	ALC_ALPHA,                                        // 632
	ALC_ALPHA,                                        // 633
	ALC_ALPHA,                                        // 634
	ALC_ALPHA,                                        // 635
	ALC_PUNC | ALC_MATH | ALC_MONETARY | ALC_NUMERIC_PUNC,		                        // 636
	ALC_JIS1 | ALC_HIRAGANA | ALC_PUNC | ALC_MATH | ALC_KATAKANA | ALC_NUMERIC_PUNC,	// 637
	ALC_JIS1 | ALC_MATH | ALC_NUMERIC_PUNC /*| RECMASK_DEFAULT*/,		   // 638
	ALC_KATAKANA | ALC_JIS1,                       // 639
	ALC_PUNC | ALC_MONETARY | ALC_MATH | ALC_OTHER,            // 640
	ALC_PUNC,                                                  // 641
	ALC_JIS1 | ALC_PUNC | ALC_OTHER,               // 642
	ALC_OTHER | ALC_JIS1
};

//
// rgrecmaskDbcs defines the recmask for a dbcs character.
//

const RECMASK rgrecmaskDbcs[WDBCSRECMASK_LAST - WDBCSRECMASK_FIRST + 1] =
{
	ALC_WHITE | ALC_NONPRINT,               // 0x8140
	ALC_PUNC,                               // 0x8141
	ALC_PUNC,                               // 0x8142
	ALC_PUNC | ALC_MONETARY | ALC_MATH,     // 0x8143 ,
	ALC_PUNC | ALC_MONETARY | ALC_MATH | ALC_NUMERIC_PUNC,     // 0x8144 .
	ALC_PUNC,                               // 0x8145
	ALC_PUNC | ALC_NUMERIC_PUNC,            // 0x8146 :
	ALC_PUNC,                               // 0x8147 ;
	ALC_PUNC,                               // 0x8148 ?
	ALC_PUNC,                               // 0x8149 !
	ALC_KATAKANA,                           // 0x814A
	ALC_KATAKANA,                           // 0x814B
	ALC_OTHER,                              // 0x814C
	ALC_OTHER,                              // 0x814D
	ALC_OTHER,                              // 0x814E
	ALC_MATH,                               // 0x814F ^
	ALC_OTHER,                              // 0x8150
	ALC_OTHER,                              // 0x8151
	ALC_KATAKANA,                           // 0x8152
	ALC_KATAKANA,                           // 0x8153
	ALC_HIRAGANA,                           // 0x8154
	ALC_HIRAGANA,                           // 0x8155
	ALC_JIS1,                               // 0x8156
	ALC_JIS1,                               // 0x8157
	ALC_JIS1,                               // 0x8158
	ALC_JIS1,                               // 0x8159
	ALC_JIS1,                               // 0x815A
	ALC_HIRAGANA | ALC_KATAKANA | ALC_PUNC, // 0x815B
	ALC_PUNC,                               // 0x815C
	ALC_PUNC,                               // 0x815D -
	ALC_MATH | ALC_PUNC | ALC_NUMERIC_PUNC, // 0x815E /
	ALC_PUNC,                               // 0x815F
	/*RECMASK_DEFAULT |*/ ALC_OTHER,            // 0x8160
	ALC_OTHER,                              // 0x8161
	ALC_OTHER,                              // 0x8162
	ALC_PUNC,                               // 0x8163
	ALC_OTHER,                              // 0x8164
	ALC_PUNC,                               // 0x8165
	ALC_PUNC,                               // 0x8166
	ALC_PUNC,                               // 0x8167
	ALC_PUNC,                               // 0x8168
	ALC_MATH | ALC_PUNC,                    // 0x8169 (
	ALC_MATH | ALC_PUNC,                    // 0x816A )
	ALC_OTHER,                              // 0x816B
	ALC_OTHER,                              // 0x816C
	ALC_PUNC,                               // 0x816D [
	ALC_PUNC,                               // 0x816E ]
	ALC_MATH | ALC_PUNC,                    // 0x816F {
	ALC_MATH | ALC_PUNC,                    // 0x8170 }
	ALC_OTHER,                              // 0x8171
	ALC_OTHER,                              // 0x8172
	ALC_OTHER,                              // 0x8173
	ALC_OTHER,                              // 0x8174
	ALC_PUNC,                               // 0x8175
	ALC_PUNC,                               // 0x8176
	ALC_PUNC,                               // 0x8177
	ALC_PUNC,                               // 0x8178
	ALC_OTHER,                              // 0x8179
	ALC_OTHER,                              // 0x817A
	/*RECMASK_DEFAULT |*/ ALC_MATH | ALC_NUMERIC_PUNC,	// 0x817B +
	ALC_MATH | ALC_PUNC | ALC_NUMERIC_PUNC,	// 0x817C -
	ALC_MATH,                               // 0x817D
	/*RECMASK_DEFAULT |*/ ALC_MATH,             // 0x817E
	ALC_OTHER,                              // 0x817F
	/*RECMASK_DEFAULT |*/ ALC_MATH,             // 0x8180
	/*RECMASK_DEFAULT |*/ ALC_MATH | ALC_NUMERIC_PUNC,	// 0x8181 =
	ALC_MATH,                               // 0x8182
	/*RECMASK_DEFAULT |*/ ALC_MATH,             // 0x8183 <
	/*RECMASK_DEFAULT |*/ ALC_MATH,             // 0x8184 >
	ALC_MATH,                               // 0x8185
	ALC_MATH,                               // 0x8186
	ALC_MATH,                               // 0x8187
	ALC_MATH,                               // 0x8188
	ALC_OTHER,                              // 0x8189
	ALC_OTHER,                              // 0x818A
	ALC_OTHER,                              // 0x818B
	ALC_OTHER,                              // 0x818C
	ALC_OTHER,                              // 0x818D
	/*RECMASK_DEFAULT |*/ ALC_OTHER,            // 0x818E
	/*RECMASK_DEFAULT |*/ ALC_MONETARY | ALC_NUMERIC_PUNC,	// 0x818F
	/*RECMASK_DEFAULT |*/ ALC_MONETARY,         // 0x8190 $
	ALC_MONETARY,                           // 0x8191
	ALC_MONETARY,                           // 0x8192
	/*RECMASK_DEFAULT |*/ ALC_MATH,             // 0x8193 %
	ALC_OTHER,                              // 0x8194 #
	ALC_PUNC,                               // 0x8195 &
	/*RECMASK_DEFAULT |*/ ALC_MATH | ALC_NUMERIC_PUNC,	// 0x8196 *
	/*RECMASK_DEFAULT |*/ ALC_OTHER,            // 0x8197 @
	ALC_OTHER,                              // 0x8198
	ALC_OTHER,                              // 0x8199
	ALC_OTHER,                              // 0x819A
	ALC_OTHER,                              // 0x819B
	ALC_OTHER,                              // 0x819C
	ALC_OTHER,                              // 0x819D
	ALC_OTHER,                              // 0x819E
	ALC_OTHER,                              // 0x819F
	ALC_OTHER,                              // 0x81A0
	ALC_OTHER,                              // 0x81A1
	ALC_OTHER,                              // 0x81A2
	ALC_OTHER,                              // 0x81A3
	ALC_OTHER,                              // 0x81A4
	ALC_OTHER,                              // 0x81A5
	ALC_OTHER,                              // 0x81A6
	/*RECMASK_DEFAULT |*/ ALC_OTHER             // 0x81A7
};

const WORD *pwListFromToken(WORD sym)
{
	if ((sym < TOKEN_FIRST) || (sym > TOKEN_LAST))
		return NULL;
	else
		return mptokenwmatches[sym - TOKEN_FIRST];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\api\sources.inc ===
TARGETNAME=commonAPI
TARGETTYPE=LIBRARY

NTTARGETFILES= $(NTTARGETFILES) hwxbin

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\common\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\tpgHandle.c \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\xrcreslt.c ===
// xrcreslts.c
// James A. Pittman
// Jan 7, 1999

// A container object to hold the results of recognition.

// This is currently used by Inferno, MadCow, and Famine.

// The XRCRESULT object describes a single alternative interpretation of the ink.
// There are 2 types: phrase and word.  Both have a string and a cost.
// Word XRCRESULT objects have a 0 cWords and a NULL pMap.
// Phrase XRCRESULT objects have pMap pointing to an array of word mappings,
// with the count of mappings in cWords.

// The XRCRESSET object represents a set of alternative results for the
// same ink.  It has a count of alternates, a glyph of the ink in question
// (not yet implemented), and an array of XRCRESULT objects.  The array
// is in-line, with a length of MAXALT.

// The WORDMAP contains a description of a word within the phrase
// (the start index and the length), and a XRCRESSET to hold the alternative
// results for this word.

// We would like (I think) to be able to ask a word XRCRESULT for its alternate
// interpretations, and get back all 10 words (need a back pointer to
// phrase?).  Well, maybe not.

#include <string.h>
#include <stdlib.h>
#include "common.h"
#include "frame.h"
#include "recdefs.h"

#ifndef NDEBUG
void ValidateALTERNATES(ALTERNATES *pAlt)
{
	XRCRESULT *p = &(pAlt->aAlt[0]);
	unsigned int c = pAlt->cAlt;

	ASSERT(c <= pAlt->cAltMax);
	ASSERT(pAlt->cAltMax <= MAXMAXALT);

	for (; c; c--, p++)
	{
        int cm = p->cWords;
        WORDMAP *pm = p->pMap;

		ASSERT(p->szWord);
		ASSERT(-1 < p->cost);
		ASSERT(p->pXRC);

		for (; cm; cm--, pm++)
		{
			ASSERT(-1 < pm->start);
			// April 2002 Strings can be zero length
			//ASSERT(0 < pm->len);
			ASSERT(0 < pm->cStrokes);
			ASSERT(pm->piStrokeIndex);
			ValidateALTERNATES(&(pm->alt));
		}
	}
}
#endif

// Inserts a new word and its cost into the set of alternates.
// The alternates remain in sorted order.
// Returns insertion position
int InsertALTERNATES(ALTERNATES *pAlt, int cost, unsigned char *word, void *pxrc)
{
	XRCRESULT		*pPos, *pPrev = NULL;
	unsigned int	after;

	unsigned int	cRes = pAlt->cAlt;
	unsigned int	cAltMax = pAlt->cAltMax;
	
	unsigned int	iPos;
	XRCRESULT		*pRes = pAlt->aAlt;
	int				cWords = 0;
	WORDMAP			*pMap = NULL;	
	unsigned char		*szWordCopy;

	ASSERT(cRes <= cAltMax);

	if (cRes == 0)
	{
		if (cRes >= cAltMax)
		{
			return -1;
		}

		pPos = pRes;
		after = 0;
	}
	else if (cRes == 1)
	{
		if (pRes[0].cost <= cost && cRes < cAltMax)
		{
			pPos = pRes + 1;
			pPrev = pRes;
			after = 0;
		}
		else
		{
			if (pRes[0].cost > cost)
			{
				pPos = pRes;
				after = 1;
			}
			else
			{
				return -1;
			}
		}
	}
	else
	{
		// Find pPos using a form of binary search.
		XRCRESULT *pBest, *pWorst;

		pBest = pRes;
		pWorst = pRes + cRes - 1;

		if (pWorst->cost <= cost)
		{
			if (cRes == cAltMax)
				return -1;

			if (pWorst->cost == cost && strcmp(word, pWorst->szWord) == 0)
			{
				// Dont allow dups
				return -1;
			}

			pPos = pWorst + 1;
			pPrev = pWorst;
			after = 0;
		}
		else if (cost < pBest->cost)
		{
			pPos = pBest;
			after = cRes;
		}
		else
		{
			while ((pBest + 1) < pWorst)
			{
				pPos = pBest + ((pWorst - pBest) / 2);
				if (pPos->cost <= cost)
					pBest = pPos;
				else
					pWorst = pPos;
			}
			pPos = pWorst;
			pPrev = pWorst - 1;
			after = cRes - (pPos - pRes);
		}
	}

	// Check For Duplicates in the list
	while (pPrev && pPrev->cost == cost)
	{
		if (strcmp(word, pPrev->szWord) == 0)
		{
			ASSERT(pPrev - pAlt->aAlt >= 0);
			// Dont allow dups
			return -1;
		}
		--pPrev;
		pPrev = (pPrev >= pRes) ? pPrev : NULL;
	}

	szWordCopy = Externstrdup(word);
	if (NULL == szWordCopy)
	{
		return -1;
	}

	if (after)
	{
		ASSERT(pPos->szWord);

		if (cRes == cAltMax)
		{
			ExternFree(pRes[cAltMax-1].szWord);
			after--;
			cRes--;

			pRes[cAltMax-1].szWord	= NULL;

			// Save allocated memory that would be pushed off the top
			cWords = pRes[cRes].cWords;
			pMap =  pRes[cRes].pMap;
		}

		memmove(pPos + 1, pPos, after * sizeof(XRCRESULT));
	}

	iPos = pPos - pAlt->aAlt;
	// ASSERT(iPos >= 0);
	ASSERT(iPos <= cRes);

	pPos->szWord	= szWordCopy;
	pPos->cost = cost;
	pPos->pXRC = pxrc;

	pPos->cWords = cWords;
	pPos->pMap = pMap;

	pAlt->cAlt = ++cRes;

	return (pPos - pAlt->aAlt);
}

// Initializes a XRCRESULT object to represent a phrase.
// The caller passes in a vector of pointers to ALTERNATES, representing
// the sequence of words and their alternates.  We steal them into
// a vector of WORDMAP structs, and set up the XRCRESULT object
// to own that vector of maps.  We return 1 for success, 0 for failure.

// If an ALTERNATES object contains 0 answers, we insert "???" into the
// phrase string, and in the word map we set the start and len fields
// to refer to the "???".

// We assume the caller passes at least 1 ALTERNATES, even though
// it might have 0 answers.

// Should the symbol be something special for "???".

// Currently this version handles isolated periods and commas
// correctly (they do not get a space before them).  This is
// to accomodate the current MadCow, which handles periods and
// commas separately.

/*		
int RCRESULTInitPhrase(XRCRESULT *pRes, ALTERNATES **ppWords, unsigned int cWords, int cost)
{
    WORDMAP *pMaps;
	unsigned int len, pos;
	unsigned char *sz;

	ASSERT(cWords);

    pMaps = (WORDMAP *)ExternAlloc(sizeof(WORDMAP) * cWords);
	ASSERT(pMaps);
	if (!pMaps)
		goto failure;

	for (len = 0, pos = 0; pos < cWords; pos++)
	{
		if (ppWords[pos]->cAlt)
			len += strlen(ppWords[pos]->aAlt[0].szWord) + 1;
		else
			len += 4;
	}
	ASSERT(len);

    pRes->cWords = cWords;
	pRes->pMap = pMaps;
	pRes->szWord = (unsigned char *)ExternAlloc(len);
	ASSERT(pRes->szWord);
	if (!(pRes->szWord))
	{
		ExternFree(pMaps);
		goto failure;
	}
	pRes->cost = cost;
	pRes->pXRC = NULL;

	pos = 0;
	sz = pRes->szWord;
	for (; cWords; cWords--, ppWords++, pMaps++)
	{
		int cAlt = (*ppWords)->cAlt;
		unsigned char *szWord;
		
		if (cAlt)
			szWord = (*ppWords)->aAlt[0].szWord;
		else
			szWord = "???";

		if (pos)
		{
			pos++;
			*sz++ = ' ';
		}

		pMaps->start = (unsigned short int)pos;
		strcpy(sz, szWord);

		pMaps->len = (unsigned short int)strlen(szWord);
		pos += pMaps->len;
		sz += pMaps->len;

        memcpy(&(pMaps->alt), *ppWords, sizeof(ALTERNATES));
		(*ppWords)->cAlt = 0;
//		(*ppWords)->pGlyph = NULL;
	}
	return 1;

failure:
    pRes->cWords = 0;
	pRes->pMap = NULL;
	pRes->szWord = NULL;
	pRes->cost = 0;
	pRes->pXRC = NULL;
	return 0;
}
*/

// Sets the backpointers in all XRCRESULT objects within
// and ALTERNATES object, including any contained within
// word mappings.

#if 0
void SetXRCALTERNATES(ALTERNATES *pAlt, void *pxrc)
{
	unsigned int c = pAlt->cAlt;
	XRCRESULT *p = pAlt->aAlt;

	for (; c; c--, p++)
	{
        int cm = p->cWords;
        WORDMAP *pm = p->pMap;

		p->pXRC = pxrc;

		for (; cm; cm--, pm++)
			SetXRCALTERNATES(&(pm->alt), pxrc);
	}
}
#endif

// Frees stroke index array memory associated the WORDMAPs in a XRCRESULT
void FreeIdxWORDMAP(XRCRESULT *pRes)
{
	if (pRes && pRes->pMap)
	{
		if (pRes->cWords > 0 && pRes->pMap[pRes->cWords-1].piStrokeIndex)
		{
			WORDMAP			*pMap = pRes->pMap;
			unsigned int	i;

			ExternFree(pMap[pRes->cWords-1].piStrokeIndex);

			for (i = 0 ; i < pRes->cWords ; ++i, ++pMap)
			{
				pMap->cStrokes = 0;
				pMap->piStrokeIndex = NULL;
			}
			pRes->cWords = 0;
		}

	}
}


// Frees all memory except for pAlt itself, since we assume that an HRC will
// have one of these in-line.  Also zeroes out the count of alternates.
// This function that should only be used by an HRC destroying the result
// objects that it owns.  The PenWin function DestroyHRCRESULT() should be
// a no-op, since the result objects are internal to larger data structures.
void ClearALTERNATES(ALTERNATES *pAlt)
{
	unsigned int c = pAlt->cAlt;
	XRCRESULT *p = pAlt->aAlt;

	for (; c; c--, p++)
	{
        int cm = p->cWords;
        WORDMAP *pm = p->pMap;

		ExternFree(p->szWord);

		FreeIdxWORDMAP(p);

		// clear all mappings
		for (; pm && cm; cm--, pm++)
		{
			ClearALTERNATES(&(pm->alt));
		}

		ExternFree(p->pMap);
	}

	pAlt->cAlt = 0;
}

// Truncates the alt list to cAltmax, From cAltMax onwards: Does what ClearALTERNATES
// Only intended for WORD ALTERNATES
void TruncateWordALTERNATES(ALTERNATES *pAlt, unsigned int cAltMax)
{
	unsigned int c;
	XRCRESULT *p;

	if (pAlt->cAlt <= cAltMax)
		return;

	pAlt->cAltMax	=	cAltMax;

	p	=	pAlt->aAlt + cAltMax;

	for (c = cAltMax; c < pAlt->cAlt; c++, p++)
	{
		// for WORD ALTERNATES, cWords should be 1, cAlt should be 0
		ASSERT (p->cWords == 1 && p->pMap && p->pMap->alt.cAlt == 0);

		ExternFree(p->szWord);

		FreeIdxWORDMAP(p);

		ExternFree(p->pMap);
		p->pMap = NULL;
	}

	pAlt->cAlt	=	cAltMax;
}

// Add a stroke to the wordmap checking for duplicates and maintaining the a sorted list
void AddThisStroke(WORDMAP *pMap, int iInsertStroke)
{
	int			k;
	int			iLast;
	int			cStroke = 1;					// Count of non duplicate strokes
	int			iStroke;
		
	ASSERT(pMap);
	ASSERT(pMap->piStrokeIndex);

	iLast = *pMap->piStrokeIndex;

	// Most of the time the strokes will already be sorted
	// so use linear insertion sort
	for (k = 0 ; k < pMap->cStrokes ; ++k)
	{
		iStroke = pMap->piStrokeIndex[k];

		// Check strokes are indeed sorted
		ASSERT(iStroke >= iLast);
		iLast = iStroke;

		if (iInsertStroke == iStroke)
		{
			// Already have this stroke - just return
			return;
		}


		// Found place where it should be inserted
		if (iInsertStroke < iStroke)
		{
			int		l;

			for (l = k ; l < pMap->cStrokes ; ++l)
			{
				iStroke = pMap->piStrokeIndex[l];
				pMap->piStrokeIndex[l] = iInsertStroke;
				iInsertStroke = iStroke;
			}

			break;
		}
	}

	
	// Add final stroke
	if (0 == pMap->cStrokes || pMap->piStrokeIndex[pMap->cStrokes-1] != iInsertStroke)
	{
		pMap->piStrokeIndex[pMap->cStrokes] = iInsertStroke;
		++pMap->cStrokes;
	}

}



// Locates WORDMAP under a specified phrase result based on the word position and length.

WORDMAP *findWORDMAP(XRCRESULT *pRes, unsigned int iWord, unsigned int cWord)
{
	WORDMAP *p = pRes->pMap;
	unsigned int c = pRes->cWords;

	for (; c; c--, p++)
	{
		if ((p->start == iWord) && (p->len == cWord))
			return p;
	}

	return NULL;
}

// Locates WORDMAP under a specified phrase result that contains a specified word result.

WORDMAP *findResultInWORDMAP(XRCRESULT *pPhrase, XRCRESULT *pWord)
{
	WORDMAP *p = pPhrase->pMap;
	unsigned int c = pPhrase->cWords;

	for (; c; c--, p++)
	{
		if ((p->alt.aAlt <= pWord) && (pWord < (p->alt.aAlt + p->alt.cAlt)))
			return p;
	}

	return NULL;
}

WORDMAP *findResultAndIndexInWORDMAP(XRCRESULT *pPhrase, XRCRESULT *pWord, int *pindex)
{
	WORDMAP *p = pPhrase->pMap;
	unsigned int c = pPhrase->cWords;

	for (; c; c--, p++)
	{
		if ((p->alt.aAlt <= pWord) && (pWord < (p->alt.aAlt + p->alt.cAlt)))
		{
			*pindex = pWord - p->alt.aAlt;
			return p;
		}
	}

	return NULL;
}

// Make a Copy word maps in an xrcResult being sure to allocate
// The stroke maps in the way that they can be later freed by FreeIdxWORDMAP
// There are assumed to be cWord pMaps
//
// NOTE: Makes assumption that words length in Src word maps are 
//  equal to those in the destination word map - This may be a BAD assumption
//
BOOL XRCRESULTcopyWordMaps(XRCRESULT *pRes, int cWord, WORDMAP *pMap)
{
	int			iWord, cWordLen;
	int			cStroke = 0;
	WORDMAP		*pSrcMap, *pDestMap;
	int			*piIndex;

	if (NULL == pRes || cWord < 1 || NULL == pMap)
	{
		return FALSE;
	}

	pSrcMap	 = pMap;
	for (iWord = 0 ; iWord < cWord ; ++iWord, ++pSrcMap)
	{
		cStroke += pSrcMap->cStrokes;
	}

	ASSERT(cStroke > 0);
	if (cStroke <= 0)
	{
		return FALSE;
	}

	pRes->cWords = cWord;
	pRes->pMap = ExternAlloc(cWord * sizeof(*pRes->pMap));
	if (NULL == pRes->pMap)
	{
		return FALSE;
	}
	memset(pRes->pMap, 0, cWord * sizeof(*pRes->pMap));

	piIndex = pRes->pMap[cWord - 1].piStrokeIndex = (int *)ExternAlloc(sizeof(*pRes->pMap->piStrokeIndex) * cStroke);
	if (NULL == pRes->pMap[cWord - 1].piStrokeIndex)
	{
		goto fail;
	}

	pSrcMap		= pMap + cWord - 1;
	pDestMap	= pRes->pMap + cWord - 1;

	for(iWord = cWord - 1 ; iWord >= 0 ; --iWord)
	{
		pDestMap->cStrokes		= pSrcMap->cStrokes;
		pDestMap->len			= pSrcMap->len;
		pDestMap->start			= pSrcMap->start;
		pDestMap->piStrokeIndex = piIndex;
		ASSERT(piIndex + pDestMap->cStrokes <= pRes->pMap[cWord - 1].piStrokeIndex + cStroke);
		memcpy(pDestMap->piStrokeIndex, pSrcMap->piStrokeIndex, pDestMap->cStrokes * sizeof(*pDestMap->piStrokeIndex));

		piIndex					+= pDestMap->cStrokes;
	}

	return TRUE;

fail:

	if (NULL != pRes->pMap)
	{
		ExternFree(pRes->pMap[cWord - 1].piStrokeIndex);

		ExternFree(pRes->pMap);
		pRes->pMap = NULL;
	}

	return FALSE;
}
// Returns an array of RES pointers, one for each alternative interpretation of the
// same word.  The word is designated by the XRCRESULT object, start index, and letter count.
// We return the pointers in ppRes, and return the count.
// We only do whole words, so if the caller requests a substring that is not a word,
// we return 0.  If the word is the special marker "???" meaning the recognizer could
// not produce interpretations, we return 0.  This function assumes the XRCRESULT object
// represents a phrase, not a word.  If this is not a phrase (we have no mappings) we
// return 0;

int RCRESULTWords(XRCRESULT *pRes, unsigned int iWord, unsigned int cWord,
				  XRCRESULT **ppRes, unsigned int cRes)
{
	WORDMAP *pMap = findWORDMAP(pRes, iWord, cWord);

	if (!pMap)
		return 0;

	if (pMap->alt.cAlt < cRes)
		cRes = pMap->alt.cAlt;

	if (cRes)
	{
		XRCRESULT *p = pMap->alt.aAlt;
		int c;

		for (c = cRes; c; c--, ppRes++, p++)
			*ppRes = p;
	}

	return cRes;
}

// Returns (in a buffer provided by the caller) the "symbols" of the
// word or phrase represented by pRes.  Symbols are 32 bit codes.
// The null byte at the end of a string is NOT a part of the string and
// is NOT copied into the symbol value array.
// Returns the number of symbols inserted.

// We follow the convention that all symbols produced by MadCow, Inferno,
// and Famine are strickly CodePage 1252 (so called ANSI codepage), with
// the exception that an unrecognized word is coded as one-symbol "word"
// whose symbol is SYV_UNKNOWN (value 1).
// Internally (since we only store one byte per char) we represent the
// unrecognized word with \a (alert, bell, 7).

int RCRESULTSymbols(XRCRESULT *pRes, unsigned int iSyv, int *pSyv, unsigned int cSyv)
{
	unsigned char *szWord = pRes->szWord;
	int c = 0;

	if (strlen(szWord) < iSyv)
		return 0;

	szWord += iSyv;
	for (; *szWord && cSyv; pSyv++, cSyv--, szWord++, c++)
	{
		if (*szWord == '\a')
			*pSyv = SYV_UNKNOWN;
		else
			*pSyv = MAKELONG(*szWord, SYVHI_ANSI);
	}
	return c;
}

// Translates an array of symbols into an ANSI (codepage 1252) string.

// This and SymbolToUnicode() below both translate until either cSyv is
// exhausted or until they hit a NULL symbol or a NULL character.
// The both return the count of symbols translated in *pCount.
// Both return 1 if successful, or 0 if they incountered something
// that could not be translated.  This one translates SYV_UNKNOWN
// (meaning ink that got 0 entries in the top 10 list) into the bell,
// also called control G (7, or '\a').

int SymbolToANSI(unsigned char *sz, int *pSyv, int cSyv, int *pCount)
{
	int c = 0;
	int ret = 1;

	for (; cSyv; pSyv++, sz++, cSyv--, c++)
	{
		if (HIWORD(*pSyv) == SYVHI_ANSI)
			*sz = (unsigned char)*pSyv;
		else if (HIWORD(*pSyv) == SYVHI_UNICODE)
		{
			if (!UnicodeToCP1252((unsigned char)LOWORD(*pSyv), sz))
			{
				*sz = '\0';
				ret = 0;
			}
		}
		else if (*pSyv == SYV_NULL)
			*sz = '\0';
		else if (*pSyv == SYV_UNKNOWN)
			*sz = '\a';
		else
		{
			*sz = '\0';
			ret = 0;
		}
		// Break on NULL done here rather than at SYV_NULL check above,
		// because an ANSI or UNICODE char might also be NULL.
		if (!*sz)
			break;
	}

	if (pCount)
		*pCount = c;
	return ret;
}

// Translates an array of symbols into a Unicode string.
// See comments on SymbolToANSI() above.
// This one translates SYV_UNKNOWN (meaning ink that got 0 entries
// in the top 10 list) into the UNICODE replacement character,
// also called unknown character (0xFFFD).

extern int SymbolToUnicode(WCHAR *wsz, int *pSyv, int cSyv, int *pCount)
{
	int c = 0;
	int ret = 1;

	for (; cSyv; pSyv++, wsz++, cSyv--, c++)
	{
		if (HIWORD(*pSyv) == SYVHI_UNICODE)
			*wsz = LOWORD(*pSyv);
		else if (HIWORD(*pSyv) == SYVHI_ANSI)
		{
			if (!CP1252ToUnicode((unsigned char)(*pSyv & 0x000000FF), wsz))
			{
				*wsz = L'\0';
				ret = 0;
			}
		}
		else if (*pSyv == SYV_NULL)
			*wsz = L'\0';
		else if (*pSyv == SYV_UNKNOWN)
			*wsz = 0xFFFD;
		else
		{
			*wsz = L'\0';
			ret = 0;
		}
		// Break on NULL done here rather than at SYV_NULL check above,
		// because an ANSI or UNICODE char might also be NULL.
		if (!*wsz)
			break;
	}

	if (pCount)
		*pCount = c;
	return ret;
}

// Backward compatibility.

// These 2 functions exist to support the old API.

// Returns recognition results in order, without scores.
// The words are placed in buffer, with a null byte between
// each word.
// If buflen is zero, it only returns the required minimum buflen.
// If buflen is less than minimum required, it returns -1.
// Otherwise, returns the count of words returned (each null-separated in buffer).
// If there are no answers, and buflen is zero, we return 0
// (don't need any buffer to store 0 answers).  If there are
// no answers, and buflen is no zero, we do not alter the buffer,
// and we return 0.

int ALTERNATESString(ALTERNATES *pAlt, char *buffer, int buflen, int max)
{
	XRCRESULT *pRes = pAlt->aAlt;
	int count = 0;

	if (pAlt->cAlt < (unsigned int)max)
		max = (int)pAlt->cAlt;

	if (!buflen)
	{
		for (; max; max--, pRes++)
		{
			count += strlen(pRes->szWord) + 1;
		}
	}
	else
	{
		for (; max; max--, pRes++)
		{
			int c = strlen(pRes->szWord) + 1;

			if (buflen < c)
				return -1;
			strcpy(buffer, pRes->szWord);
			buffer += c;
			buflen -= c;
			count++;
		}
	}

	return count;
}

int ALTERNATESCosts(ALTERNATES *pAlt, int max, int *pCost)
{
	XRCRESULT *pAns = pAlt->aAlt;
	int cAlt = pAlt->cAlt;

	if (cAlt < max)
		max = cAlt;
	else if (max < cAlt)
		cAlt = max;

	for (; max; max--, pAns++)
		*pCost++ = pAns->cost;

	return cAlt;
}

// Finds a frame within a glyph based on the iframe index.

static GLYPH *IndexGLYPH(GLYPH *pG, int i)
{
	for (; pG; pG = pG->next)
	{
		if (pG->frame->iframe == i)
			return pG;
	}
	return NULL;
}

// Initializes a sequence of intervals representing selected frames from a glyph.

static int mapIntervals(GLYPH *pGlyph, int *piSt, int cSt, INTERVAL *buffer)
{
	int c = 0;

	for (; cSt; cSt--, piSt++)
	{
		FRAME *pFrame;
		unsigned int ms;
		unsigned int sec = 0;

		pGlyph = IndexGLYPH(pGlyph, *piSt);
		ASSERT(pGlyph);
		if (!pGlyph)
			return -1;
		pFrame = pGlyph->frame;
		ms = pFrame->info.dwTick;
		MakeAbsTime(&(buffer[c].atBegin), sec, ms);

		// move ahead to end of run
		while ((1 < cSt) && ((*piSt + 1) == *(piSt+1)))
		{
			cSt--;
			piSt++;
		}
		if (*piSt != pFrame->iframe)
		{
			pGlyph = IndexGLYPH(pGlyph->next, *piSt);
			ASSERT(pGlyph);
			if (!pGlyph)
				return -1;
			pFrame = pGlyph->frame;
		}
		ms = pFrame->info.dwTick + (10 * CrawxyFRAME(pFrame));
		MakeAbsTime(&(buffer[c].atEnd), sec, ms);
		c++;
		pGlyph = pGlyph->next;
	}

	return c;
}

// Initializes a single interval representing a glyph.

static void mapSingleInterval(GLYPH *pGlyph, INTERVAL *pInt)
{
	FRAME *pFrame;
	unsigned int ms;
	unsigned int sec = 0;

	pFrame = pGlyph->frame;
	ms = pFrame->info.dwTick;
	MakeAbsTime(&(pInt->atBegin), sec, ms);
	while (pGlyph->next)
		pGlyph = pGlyph->next;
	pFrame = pGlyph->frame;
	ms = pFrame->info.dwTick + (10 * CrawxyFRAME(pFrame));
	MakeAbsTime(&(pInt->atEnd), sec, ms);
}

// Mallocs and initializes an InkSet.

static XINKSET *mkInkSet(INTERVAL *buffer, int c)
{
	int i;
	XINKSET *pInk = (XINKSET *)malloc(sizeof(XINKSET) + ((c - 1) * sizeof(INTERVAL)));
	ASSERT(pInk);
	if (!pInk)
		return NULL;

	pInk->count = c;
	for (i = 0; i < c; i++)
		pInk->interval[i] = buffer[i];

	return pInk;
}

// Creates an InkSet to represent the part of pGlyph included within
// a specified WORDMAP.

XINKSET *mkInkSetWORDMAP(GLYPH *pGlyph, WORDMAP *pMap)
{
	INTERVAL *pInterval;
	XINKSET *pInkSet=NULL;
	int c;

	if (!pMap->cStrokes)
		return NULL;

	pInterval = ExternAlloc(pMap->cStrokes * sizeof(INTERVAL));
	if (!pInterval)
		goto exit;

	c = mapIntervals(pGlyph, pMap->piStrokeIndex, pMap->cStrokes, pInterval);
	
	if (c != -1)
	{
	
		pInkSet=mkInkSet(pInterval, c);
		
	}
	
exit:
	
	ExternFree(pInterval);

	return pInkSet;
}

// Creates an InkSet to represent the part of pGlyph included
// within a specified word within a phrase.

// Should probably extend this to allow several words in one gulp.
// Should extend this to allow overlarge cWord
// Verify that piStroke will be in sorted order

XINKSET *mkInkSetPhrase(GLYPH *pGlyph, XRCRESULT *pRes, unsigned int iWord, unsigned int cWord)
{
	WORDMAP *pMap;

	if (pMap = findWORDMAP(pRes, iWord, cWord))  // assignment intended
		return mkInkSetWORDMAP(pGlyph, pMap);
	else
	{
		INTERVAL interval;

		mapSingleInterval(pGlyph, &interval);
		return mkInkSet(&interval, 1);
	}
}


// Search for a frame by frame ID
FRAME *FindFrame(GLYPH *pGlyph, int iFrame)
{
	for  ( ; pGlyph ; pGlyph = pGlyph->next)
	{
		if (pGlyph->frame  && pGlyph->frame->iframe == iFrame)
		{
			return pGlyph->frame;
		}
	}

	return NULL;
}

GLYPH *GlyphFromStrokes(GLYPH *pMainGlyph, int cStroke, int *piStrokeIndex)
{
	int		iStroke;
	GLYPH	*pGlyph = NewGLYPH();

	if (!pGlyph)
		return NULL;

	for (iStroke = 0; iStroke < cStroke; ++iStroke)
	{
		FRAME		*pFrame = FindFrame(pMainGlyph, piStrokeIndex[iStroke]);
		ASSERT(pFrame);
		if (!pFrame)
		{
			goto fail;
		}
		
		if (!AddFrameGLYPH(pGlyph, pFrame))
		{
			goto fail;
		}
	}

	return pGlyph;

fail:
	if (pGlyph)
	{
		DestroyFramesGLYPH(pGlyph);
		DestroyGLYPH(pGlyph);
	}
	return NULL;
}

// given a main glyph and a wordmap, 
// this function returns a pointer to glyph representing the word only
GLYPH *GlyphFromWordMap (GLYPH *pMainGlyph, WORDMAP *pMap)
{
	return GlyphFromStrokes(pMainGlyph, pMap->cStrokes, pMap->piStrokeIndex);
}

// Frees a word alt
void FreeWordAlt (WORD_ALT *pAlt)
{
	if (!pAlt)
		return;

	// free the string
	if (pAlt->pszStr)
	{
		ExternFree (pAlt->pszStr);

		pAlt->pszStr	=	NULL;
	}
}

// Frees a word alt list
void FreeWordAltList (WORD_ALT_LIST *pAltList)
{
	int	iAlt;

	if (!pAltList)
		return;

	if (pAltList->pAlt)
	{
		for (iAlt = 0; iAlt < pAltList->cAlt; iAlt++)
		{
			FreeWordAlt (pAltList->pAlt + iAlt);
		}

		ExternFree (pAltList->pAlt);

		pAltList->pAlt		=	NULL;
	}
}

// Frees a word map
void FreeWordMap (WORD_MAP *pWordMap)
{
	if (!pWordMap)
		return;

	// does it have any strokes
	if (pWordMap->piStrokeIndex)
	{
		ExternFree (pWordMap->piStrokeIndex);

		pWordMap->piStrokeIndex	=	NULL;
	}

	// is the final list is the same as infenro's alt list
	if (pWordMap->pInfernoAltList == pWordMap->pFinalAltList)
	{
		// set this to null to make sure we do not free it twice
		pWordMap->pInfernoAltList	=	NULL;
	}

	if (pWordMap->pBearAltList == pWordMap->pFinalAltList)
	{
		// set this to null to make sure we do not free it twice
		pWordMap->pBearAltList	=	NULL;
	}

	// free inferno's alt list if any
	if (pWordMap->pInfernoAltList)
	{
		FreeWordAltList (pWordMap->pInfernoAltList);
		ExternFree (pWordMap->pInfernoAltList);

		pWordMap->pInfernoAltList	=	NULL;
	}

	// free bear's alt list if any
	if (pWordMap->pBearAltList)
	{
		FreeWordAltList (pWordMap->pBearAltList);
		ExternFree (pWordMap->pBearAltList);

		pWordMap->pBearAltList		=	NULL;
	}

	// free the final alt list if any
	if (pWordMap->pFinalAltList)
	{
		FreeWordAltList (pWordMap->pFinalAltList);
		ExternFree (pWordMap->pFinalAltList);

		pWordMap->pFinalAltList		=	NULL;
	}

	if (pWordMap->pFeat)
	{
		ExternFree (pWordMap->pFeat);

		pWordMap->pFeat				=	NULL;
	}
}

// Frees a specific segmentation
void FreeSegmentation (SEGMENTATION *pSeg)
{
	if (!pSeg)
		return;

	// do we have words
	if (pSeg->ppWord)
	{
		ExternFree (pSeg->ppWord);

		pSeg->ppWord	=	NULL;
	}

	if (pSeg->pFeat)
	{
		ExternFree (pSeg->pFeat);

		pSeg->pFeat		=	NULL;
	}
}

// Frees a specific segmentation
void FreeSegmentationWordMaps (SEGMENTATION *pSeg)
{
	int	iWord;

	if (!pSeg)
		return;

	// do we have words
	if (pSeg->ppWord)
	{
		for (iWord = 0; iWord < pSeg->cWord; iWord++)
		{
			if (pSeg->ppWord[iWord])
			{
				FreeWordMap (pSeg->ppWord[iWord]);

				ExternFree (pSeg->ppWord[iWord]);
			}
		}

		ExternFree (pSeg->ppWord);

		pSeg->ppWord	=	NULL;
	}

	if (pSeg->pFeat)
	{
		ExternFree (pSeg->pFeat);

		pSeg->pFeat		=	NULL;
	}
}

// Frees a segmentation set
void FreeSegCol (SEG_COLLECTION *pSegCol)
{
	int	iSeg;

	if (!pSegCol)
		return;

	// free all segmentations
	if (pSegCol->ppSeg)
	{
		for (iSeg = 0; iSeg < pSegCol->cSeg; iSeg++)
		{
			if (pSegCol->ppSeg[iSeg])
				FreeSegmentation (pSegCol->ppSeg[iSeg]);

			ExternFree (pSegCol->ppSeg[iSeg]);
		}

		ExternFree (pSegCol->ppSeg);

		pSegCol->ppSeg	=	NULL;
	}
}

// Frees an ink line segmentation
void FreeLineSegm (LINE_SEGMENTATION *pResults)
{
	int	iSegCol, iWord;

	if (!pResults)
		return;

	if (pResults->ppSegCol)
	{
		for (iSegCol = 0; iSegCol < pResults->cSegCol; iSegCol++)
		{
			if (pResults->ppSegCol[iSegCol])
			{
				FreeSegCol (pResults->ppSegCol[iSegCol]);

				ExternFree (pResults->ppSegCol[iSegCol]);
			}
		}

		ExternFree (pResults->ppSegCol);

		pResults->ppSegCol	=	NULL;
	}

	if (pResults->ppWord)
	{
		for (iWord = 0; iWord < pResults->cWord; iWord++)
		{
			if (pResults->ppWord[iWord])
			{
				FreeWordMap (pResults->ppWord[iWord]);

				ExternFree (pResults->ppWord[iWord]);
			}
		}

		ExternFree (pResults->ppWord);
	}
}

// compares the stroke contents of two word maps
BOOL IsEqualWordMap (WORD_MAP *pMap1, WORD_MAP *pMap2)
{
	// # of strokes are not equal
	if (pMap1->cStroke != pMap2->cStroke)
	{
		return FALSE;
	}

	// compare stroke IDs
	if (memcmp (pMap1->piStrokeIndex, pMap2->piStrokeIndex,
		pMap1->cStroke * sizeof (*pMap1->piStrokeIndex)))
	{
		return FALSE;
	}

	return TRUE;
}

// compares the stroke contents of two word maps
BOOL IsEqualOldWordMap (WORDMAP *pMap1, WORDMAP *pMap2)
{
	// # of strokes are not equal
	if (pMap1->cStrokes != pMap2->cStrokes)
	{
		return FALSE;
	}

	// compare stroke IDs
	if (memcmp (pMap1->piStrokeIndex, pMap2->piStrokeIndex,
		pMap1->cStrokes * sizeof (*pMap1->piStrokeIndex)))
	{
		return FALSE;
	}

	return TRUE;
}

// compares two segmentations
BOOL IsEqualSegmentation (SEGMENTATION *pSeg1, SEGMENTATION *pSeg2)
{
	int	iWord;

	// is the # of words equal
	if (pSeg1->cWord != pSeg2->cWord)
		return FALSE;

	for (iWord = 0; iWord < pSeg1->cWord; iWord++)
	{
		// if at least one word is not equal, return false
		if (!IsEqualWordMap (pSeg1->ppWord[iWord], pSeg2->ppWord[iWord]))
			return FALSE;
	}

	return TRUE;
}

// clones a wordmap, only copies the stroke, features & confidence part
WORD_MAP *CloneWordMap (WORD_MAP *pOldWordMap)
{
	WORD_MAP	*pWordMap;

	pWordMap	=	(WORD_MAP *)ExternAlloc (sizeof (WORD_MAP));
	if (!pWordMap)
		return NULL;

	memset (pWordMap, 0, sizeof (*pWordMap));

	pWordMap->cStroke		=	pOldWordMap->cStroke;
	pWordMap->iConfidence	=	pOldWordMap->iConfidence;

	pWordMap->piStrokeIndex	=	
		(int *)ExternAlloc (pWordMap->cStroke * sizeof (*pWordMap->piStrokeIndex));

	if (!pWordMap->piStrokeIndex)
		return NULL;

	memcpy (pWordMap->piStrokeIndex, pOldWordMap->piStrokeIndex, 
		pWordMap->cStroke * sizeof (*pWordMap->piStrokeIndex));

	if (pOldWordMap->pFeat)
	{
		pWordMap->pFeat	=	(WORD_FEAT *) ExternAlloc (sizeof (*pWordMap->pFeat));
		if (!pWordMap->pFeat)
			return NULL;

		memcpy (pWordMap->pFeat, pOldWordMap->pFeat, sizeof (*pWordMap->pFeat));
	}

	return pWordMap;
}


// appends the contents of a src altlist to the destination altlist
BOOL AppendAltList (WORD_ALT_LIST *pDestAltList, WORD_ALT_LIST *pSrcAltList)
{
	int	iAlt;

	for (iAlt = 0; iAlt < pSrcAltList->cAlt; iAlt++)
	{
		if (!InsertNewAlternate (pDestAltList, pSrcAltList->pAlt[iAlt].iCost,
			pSrcAltList->pAlt[iAlt].pszStr))
		{
			return FALSE;
		}
	}

	return TRUE;
}

// finds a word_map in pool or wordmaps
// returns the pointer to the word map if found
// if the bAdd parameter is TRUE: adds the new word map if not found a return a pointer
// other wise returns false
WORD_MAP	*FindWordMap (LINE_SEGMENTATION *pResults, WORD_MAP *pWordMap, BOOL bAdd)
{
	int	iWord;

	for (iWord = 0; iWord < pResults->cWord; iWord++)
	{
		// found it: return now
		if (IsEqualWordMap (pResults->ppWord[iWord], pWordMap))
		{
			return pResults->ppWord[iWord];
		}
	}

	// did not find and do not want to add it, so return failure
	if (!bAdd)
		return NULL;

	// we want to add this new word map to our word map pool
	pResults->ppWord	=	(WORD_MAP **) ExternRealloc (pResults->ppWord,
		(pResults->cWord + 1) * sizeof (*pResults->ppWord));

	if (!pResults->ppWord)
		return NULL;

	// copy the word in
	pResults->ppWord[pResults->cWord]	=	CloneWordMap (pWordMap);
	if (!pResults->ppWord[pResults->cWord])
		return NULL;

	pResults->cWord++;

	// update the wordmap altlists
	iWord	=	pResults->cWord - 1;

	return pResults->ppWord[iWord];
}

// adds a new SegCol to a line segmentation
SEG_COLLECTION *AddNewSegCol (LINE_SEGMENTATION *pResults)
{
	SEG_COLLECTION	*pSegCol;

	pResults->ppSegCol	=	(SEG_COLLECTION **) ExternRealloc (pResults->ppSegCol,
		(pResults->cSegCol + 1) * sizeof (SEG_COLLECTION *));

	if (!pResults->ppSegCol)
		return NULL;

	pSegCol				=	(SEG_COLLECTION *) ExternAlloc (sizeof (*pSegCol));
	if (!pSegCol)
		return NULL;
		
	pResults->ppSegCol[pResults->cSegCol]	=	pSegCol;
	pResults->cSegCol++;

	// init it
	memset (pSegCol, 0, sizeof (SEG_COLLECTION));

	return pSegCol;
}

// adds a new segmentation to a SegCol if it is a new one
// returns TRUE: if the segmentation is added to the SegCol (new words are also added to 
// the word map pool in the line segmentation).
// May be it should check that the strokes of the new segmentation are exactly the same
// as the existing ones (if any)
// return FALSE: if no addition was made, TRUE otherwise
BOOL AddNewSegmentation		(	LINE_SEGMENTATION	*pResults, 
								SEG_COLLECTION		*pSegCol, 
								SEGMENTATION		*pNewSeg,
								BOOL				bCheckForDuplicates
							 )
{
	int				iSeg, iWord;
	SEGMENTATION	*pSeg;

	// does the new segmentation match any of the existing ones
	if (bCheckForDuplicates)
	{
		for (iSeg = 0; iSeg < pSegCol->cSeg; iSeg++)
		{
			// found it, update features and exit
			if (IsEqualSegmentation (pSegCol->ppSeg[iSeg], pNewSeg))
			{
				pSeg	=	pSegCol->ppSeg[iSeg];

				// does the new segmentation have features
				if (pNewSeg->pFeat)
				{
					// create a feature vector if does not exist
					if (!pSeg->pFeat)
					{
						pSeg->pFeat	=	(SEG_FEAT *) ExternAlloc (sizeof (*pSeg->pFeat));
						if (!pSeg->pFeat)
							return FALSE;

						memcpy (pSeg->pFeat, pNewSeg->pFeat, sizeof (*pSeg->pFeat));
					}
					else
					{
						pSeg->pFeat->bInfernoTop1	|=	pNewSeg->pFeat->bInfernoTop1;
						pSeg->pFeat->bBearTop1		|=	pNewSeg->pFeat->bBearTop1;
					}		
				}

				ASSERT (pSeg->pSegCol == pSegCol);

				return TRUE;
			}
		}
	}

	// no matches or no check for duplicates required: add the new segmentation
	pSegCol->ppSeg	=	(SEGMENTATION **) ExternRealloc (pSegCol->ppSeg,
		(pSegCol->cSeg + 1) * sizeof (SEGMENTATION *));

	if (!pSegCol->ppSeg)
		return FALSE;

	pSegCol->ppSeg[pSegCol->cSeg]	=	(SEGMENTATION *) ExternAlloc (sizeof (SEGMENTATION));
	if (!pSegCol->ppSeg[pSegCol->cSeg])
		return FALSE;
		
	pSeg			=	pSegCol->ppSeg[pSegCol->cSeg];

	memset (pSeg, 0, sizeof (*pSeg));

	// copy contents
	pSeg->cWord		=	pNewSeg->cWord;

	pSeg->ppWord	=	(WORD_MAP **) ExternAlloc (pSeg->cWord * sizeof (WORD_MAP *));
	if (!pSeg->ppWord)
		return FALSE;

	for (iWord = 0; iWord < pSeg->cWord; iWord++)
	{
		pSeg->ppWord[iWord]	=	FindWordMap (pResults, pNewSeg->ppWord[iWord], TRUE);
		if (!pSeg->ppWord[iWord])
			return FALSE;
	}

	if (pNewSeg->pFeat)
	{
		pSeg->pFeat	=	(SEG_FEAT *) ExternAlloc (sizeof (*pSeg->pFeat));
		if (!pSeg->pFeat)
			return FALSE;

		memcpy (pSeg->pFeat, pNewSeg->pFeat, sizeof (*pSeg->pFeat));
	}
	
	// backward pointer to the SegCol
	pSeg->pSegCol	=	pSegCol;

	pSegCol->cSeg++;

	return TRUE;
}


// adds a new word_map to a segmentation
WORD_MAP *AddNewWordMap (SEGMENTATION *pSeg)
{
	WORD_MAP	*pWordMap;

	pSeg->ppWord	=	(WORD_MAP **) ExternRealloc (pSeg->ppWord, 
		(pSeg->cWord + 1) * sizeof (WORD_MAP));
	
	if (!pSeg->ppWord)
		return NULL;

	pSeg->ppWord[pSeg->cWord]	=	(WORD_MAP *) ExternAlloc (sizeof (WORD_MAP));
	if (!pSeg->ppWord[pSeg->cWord])
		return FALSE;

	pWordMap	=	pSeg->ppWord[pSeg->cWord];
	memset (pWordMap, 0, sizeof (*pWordMap));

	// init confidence value
	pWordMap->iConfidence	=	RECOCONF_NOTSET;

	pSeg->cWord++;

	return pWordMap;
}

// appends the wordmaps of one segmentation to another
// Does not check that there are no wordmaps
// TBD:	
BOOL AppendSegmentation	(	SEGMENTATION	*pSrcSeg, 
							int				iStWrd, 
							int				iEndWrd, 
							SEGMENTATION	*pDestSeg
						)
{
	int		cWrd;
	
	if (iStWrd == -1)
		iStWrd	=	0;
	else
	{
		if (iStWrd < 0 || iStWrd >= pSrcSeg->cWord)
			return FALSE;
	}

	if (iEndWrd == -1)
		iEndWrd	=	pSrcSeg->cWord - 1;
	else
	{
		if (iEndWrd < 0 || iEndWrd >= pSrcSeg->cWord)
			return FALSE;
	}

	cWrd	=	iEndWrd - iStWrd + 1;

	if (cWrd < 0 || cWrd > pSrcSeg->cWord)
		return FALSE;

	if (cWrd == 0)
		return TRUE;

	pDestSeg->ppWord	=	(WORD_MAP **) ExternRealloc (pDestSeg->ppWord,
		(pDestSeg->cWord + cWrd) * sizeof (*pDestSeg->ppWord));

	if (!pDestSeg->ppWord)
		return FALSE;

	memcpy (pDestSeg->ppWord + pDestSeg->cWord, pSrcSeg->ppWord + iStWrd,  
		cWrd * sizeof (*pSrcSeg->ppWord));

	pDestSeg->cWord += cWrd;

	return TRUE;
}

// adds a new stroke to a wordmap
BOOL AddNewStroke (WORD_MAP *pWordMap, int iStrk)
{
	pWordMap->piStrokeIndex	=	(int *) ExternRealloc (pWordMap->piStrokeIndex,
		(pWordMap->cStroke + 1) * sizeof (int));

	if (!pWordMap->piStrokeIndex)
		return FALSE;

	pWordMap->cStroke++;
	pWordMap->piStrokeIndex[pWordMap->cStroke - 1] = iStrk;

	return TRUE;
}

// reverses the order of words maps with a segmentation
void ReverseSegmentationWords (SEGMENTATION *pSeg)
{
	WORD_MAP	*pWrdTemp;
	int			i;

	if (pSeg->cWord <= 1)
		return;

	for (i = 0; i < (pSeg->cWord / 2); i++)
	{
		pWrdTemp							=	pSeg->ppWord[i];
		pSeg->ppWord[i]						=	pSeg->ppWord[pSeg->cWord - i - 1];
		pSeg->ppWord[pSeg->cWord - i - 1]	=	pWrdTemp;
	}
}

// insert an alternate, assumes the alt list is sorted by cost
BOOL InsertNewAlternate (WORD_ALT_LIST *pAltList, int iCost, unsigned char *pszWord)
{
	int	iAlt, iPos;

	// find the proper position to insert the alternate
	iPos	=	pAltList->cAlt;
	for (iAlt = 0; iAlt < pAltList->cAlt; iAlt++)
	{
		// if the alternate already exist, just update the score
		if (!strcmp (pAltList->pAlt[iAlt].pszStr, pszWord))
		{
			pAltList->pAlt[iAlt].iCost	=	min (pAltList->pAlt[iAlt].iCost, iCost);
			return TRUE;
		}

		if (pAltList->pAlt[iAlt].iCost > iCost)
		{
			iPos	=	min (iAlt, iPos);
		}
	}

	// do we need to extend the list
	if (iPos >= pAltList->cAlt)
	{
		pAltList->pAlt	=	(WORD_ALT *) ExternRealloc (pAltList->pAlt,
			(pAltList->cAlt + 1) * sizeof (*pAltList->pAlt));

		if (!pAltList->pAlt)
			return FALSE;

		pAltList->cAlt++;
	}

	// shift the rest of the alternates
	for (iAlt = pAltList->cAlt - 1; iAlt > iPos; iAlt--)
	{
		pAltList->pAlt[iAlt] = pAltList->pAlt[iAlt - 1];
	}

	// allocate memory for the new string
	pAltList->pAlt[iPos].pszStr	=	
		(unsigned char *) ExternAlloc ((strlen (pszWord) + 1) * 
		sizeof (*pAltList->pAlt[iPos].pszStr));

	if (!pAltList->pAlt[iPos].pszStr)
		return FALSE;

	strcpy (pAltList->pAlt[iPos].pszStr, pszWord);

	// set the cost
	pAltList->pAlt[iPos].iCost	=	iCost;

	// success
	return TRUE;
}


// determines the min & max value for a strokeID in a wordmap
int GetMinMaxStrokeID (WORD_MAP *pWord, int *piMin, int *piMax)
{
	int	i, iMin, iMax;

	if (!piMin && !piMax)
	{
		return pWord->cStroke;
	}

	if (pWord->cStroke < 1)
	{
		if (piMin)
		{
			(*piMin)	=	-1;
		}

		if (piMax)
		{
			(*piMax)	=	-1;
		}

		return 0;
	}

	iMin	=	iMax	=	pWord->piStrokeIndex[0];

	for (i  = 1; i < pWord->cStroke; i++)
	{
		iMin	=	min(iMin, pWord->piStrokeIndex[i]);
		iMax	=	max(iMax, pWord->piStrokeIndex[i]);
	}

	if (piMin)
	{
		(*piMin)	=	iMin;
	}

	if (piMax)
	{
		(*piMax)	=	iMax;
	}

	return pWord->cStroke;
}



// This function finds the range on wordmaps in the search segmentation that
// use exactly the same strokes in the specified wordmap map range in the matching
// segmentation
// The passed bEnd flag specified whether piEndWordMap has to be the last wordmap
// of the search segmentation or not. 
// The return value will be FALSE if no wordmap range with the required specification
// is found
BOOL GetMatchingWordMapRange	(	SEGMENTATION	*pMatchSeg,
									int				iStartWordMap,
									int				iEndWordMap,
									SEGMENTATION	*pSearchSeg,
									int				*piStartWordMap,
									int				*piEndWordMap,
									BOOL			bBegin,
                                    BOOL            bEnd
								)
{
	int			iWordMap, iMinStroke, iMaxStroke, iStrk;
	int			iByte, iBit, iStrkID;
	int			cStrk, cByte, cWordMap, cStrkEnabled, cStrkSearch;
	int			iSearchStartWordMap, iSearchEndWordMap;
	WORD_MAP	**ppStartWordMap, **ppSearchWordMap;
	BOOL		bEnabled;

	BYTE		*pBitMap	=	NULL;
	BOOL		bRet		=	FALSE;

	// init out params
	(*piStartWordMap)	=	(*piEndWordMap)	=	-1;

	// chache some vars
	cWordMap		=	iEndWordMap - iStartWordMap + 1;
	ppStartWordMap	=	pMatchSeg->ppWord + iStartWordMap;

	// find out the min and max stroke IDs of the input word range
	iMinStroke		=	iMaxStroke	=	(*ppStartWordMap)->piStrokeIndex[0];

	for (iWordMap = 0; iWordMap < cWordMap; iWordMap++)
	{
		int	iMin, iMax;

		if (GetMinMaxStrokeID (ppStartWordMap[iWordMap], &iMin, &iMax) < 1)
		{
			goto exit;
		}

		iMinStroke	=	min (iMin, iMinStroke);
		iMaxStroke	=	max (iMax, iMaxStroke);
	}

	// allocate & init the necessry buffer t hold the stroke bitmap
	cStrk	=	iMaxStroke - iMinStroke + 1;
	cByte	=	(cStrk / 8) + ((cStrk %8) ? 1 : 0);

	pBitMap	=	(BYTE *) ExternAlloc (cByte * sizeof (*pBitMap));
	if (!pBitMap)
	{
		goto exit;
	}

	cStrkEnabled	=	0;
	ZeroMemory (pBitMap, cByte * sizeof (*pBitMap));

	// now enable the necessary bits
	for (iWordMap = 0; iWordMap < cWordMap; iWordMap++)
	{
		for (iStrk = 0; iStrk < ppStartWordMap[iWordMap]->cStroke; iStrk++)
		{

			iStrkID	=	ppStartWordMap[iWordMap]->piStrokeIndex[iStrk];

			iByte	=	(iStrkID - iMinStroke) / 8;
			iBit	=	(iStrkID - iMinStroke) % 8;

			pBitMap[iByte]	|=	(1 << iBit);
		}	

		cStrkEnabled	+=	ppStartWordMap[iWordMap]->cStroke;
	}

	// now find the possible wordmap range in the search seg
	iSearchStartWordMap	=	iSearchEndWordMap = -1;
	ppSearchWordMap		=	pSearchSeg->ppWord;
	cStrkSearch			=	0;

	for (iWordMap = 0; iWordMap < pSearchSeg->cWord; iWordMap++)
	{
		if (!ppSearchWordMap[iWordMap]->cStroke)
			continue;

		iStrkID		=	ppSearchWordMap[iWordMap]->piStrokeIndex[0];
		iByte		=	(iStrkID - iMinStroke) / 8;
		iBit		=	(iStrkID - iMinStroke) % 8;
		bEnabled	=	(pBitMap[iByte] & (1 << iBit));

		// have we found the starting word or not
		if (iSearchStartWordMap == -1)
		{
			// find the 1st wordmap that has a stroke (the 1st stroke for example)
			// that is enabled
			
			if (bEnabled)
			{
				iSearchStartWordMap	=	iWordMap;
			}
		}

		// we already found the start, lets search for the end
		if (iSearchStartWordMap != -1)
		{
			// is this the 1st word after the end, let's exit
			if (!bEnabled)
			{
				iSearchEndWordMap	=	iWordMap - 1;
				break;
			}
		

			// this is not the end, we need to make sure that all the
			// stroke IDs have thier bits enabled in the bitmap
			// also we need to count the strokes to make sure that only
			// these stroke IDs who have thier bits enabled in the bitmap are present
			for (iStrk = 1; iStrk < ppSearchWordMap[iWordMap]->cStroke; iStrk++)
			{
				iStrkID		=	ppSearchWordMap[iWordMap]->piStrokeIndex[iStrk];
				iByte		=	(iStrkID - iMinStroke) / 8;
				iBit		=	(iStrkID - iMinStroke) % 8;
				bEnabled	=	(pBitMap[iByte] & (1 << iBit));
		
				// if one single stroke is not enabled, you are out
				if (!bEnabled)
				{
					goto exit;
				}
			}

			cStrkSearch	+=	ppSearchWordMap[iWordMap]->cStroke;
		}
	}
	
	// make sure that onlythese stroke IDs who have thier bits enabled 
	// in the bitmap are present
	if (cStrkSearch != cStrkEnabled)
	{
		goto exit;
	}

	// if the end flag is ON and you did not actually end at the end of the segmentation
	// we are not happy
	if (bEnd && iSearchEndWordMap != -1)
	{
		goto exit;
	}

    // if the Begin flag is ON and you did not actually start at the 
    // beginning of the segmentation we are not happy
	if (bBegin && iSearchStartWordMap != 0)
	{
		goto exit;
	}


	// set the ending word if we had reached the end without finding it
	if (iSearchEndWordMap == -1)
	{
		iSearchEndWordMap =	pSearchSeg->cWord - 1;
	}

	bRet	=	TRUE;

exit:
	if (pBitMap)
	{
		ExternFree (pBitMap);
	}

	if (bRet)
	{
		(*piStartWordMap)	=	iSearchStartWordMap;
		(*piEndWordMap)		=	iSearchEndWordMap;
	}

	return bRet;
}


// TEMPORARY: Convert from the new style wordmap to the old one
BOOL WordMapNew2Old (WORD_MAP *pNewWordMap, WORDMAP *pWordMap, BOOL bClone)
{
	pWordMap->cStrokes		=	pNewWordMap->cStroke;

	if (bClone)
	{
		pWordMap->piStrokeIndex	=	
			(int *) ExternAlloc (pNewWordMap->cStroke * sizeof(*pWordMap->piStrokeIndex));

		if (!pWordMap->piStrokeIndex)
			return FALSE;

		memcpy (pWordMap->piStrokeIndex, pNewWordMap->piStrokeIndex,
			pNewWordMap->cStroke * sizeof(*pWordMap->piStrokeIndex));

	}
	else
		pWordMap->piStrokeIndex	=	pNewWordMap->piStrokeIndex;

	memset (&pWordMap->alt, 0, sizeof (pWordMap->alt));

	pWordMap->start				=	0;
	pWordMap->len				=	1;

	return TRUE;
}

// Temporary: Converts from the old style alt list to the new one
BOOL AltListOld2New (ALTERNATES *pOldAltList, WORD_ALT_LIST *pAltList, BOOL bClone)
{
	int	iAlt;

	pAltList->cAlt	=	pOldAltList->cAlt;

	pAltList->pAlt	=	(WORD_ALT *) ExternAlloc (pAltList->cAlt * sizeof (*pAltList->pAlt));
	if (!pAltList->pAlt)
		return FALSE;

	for (iAlt = 0; iAlt < pAltList->cAlt; iAlt++)
	{
		if (!bClone)
		{
			pAltList->pAlt[iAlt].pszStr		=	pOldAltList->aAlt[iAlt].szWord;

			// set this to null so that it will not be freed
			pOldAltList->aAlt[iAlt].szWord	=	NULL;
		}
		else
		{
			pAltList->pAlt[iAlt].pszStr		=	(unsigned char *) 
				Externstrdup (pOldAltList->aAlt[iAlt].szWord);

			if (!pAltList->pAlt[iAlt].pszStr)
				return FALSE;
		}

		pAltList->pAlt[iAlt].iCost		=	pOldAltList->aAlt[iAlt].cost;
		pAltList->pAlt[iAlt].ll		=	pOldAltList->all[iAlt];
	}

	return TRUE;
}

// Temporary: Converts from the new style alt list to the old one
BOOL AltListNew2Old (	HRC				hrc, 
						WORD_MAP		*pNewWordMap,
						WORD_ALT_LIST	*pAltList, 
						ALTERNATES		*pOldAltList, 
						BOOL			bClone
					)
{
	unsigned int	iAlt;

	memset (pOldAltList, 0, sizeof (*pOldAltList));

	pOldAltList->cAltMax	=	MAXMAXALT;
	pOldAltList->cAlt		=	min (MAXMAXALT, pAltList->cAlt);
	
	for (iAlt = 0; iAlt < pOldAltList->cAlt; iAlt++)
	{
		if (bClone)
		{
			pOldAltList->aAlt[iAlt].szWord	=	
				Externstrdup (pAltList->pAlt[iAlt].pszStr);

			if (!pOldAltList->aAlt[iAlt].szWord)
				return FALSE;
		}
		else
		{
			pOldAltList->aAlt[iAlt].szWord	=	pAltList->pAlt[iAlt].pszStr;
		}

		pOldAltList->aAlt[iAlt].cost	=	pAltList->pAlt[iAlt].iCost;

		pOldAltList->aAlt[iAlt].pXRC	=	hrc;
		pOldAltList->aAlt[iAlt].cWords	=	1;

		pOldAltList->all[iAlt]			=	pAltList->pAlt[iAlt].ll;

		if (bClone)
		{
			pOldAltList->aAlt[iAlt].pMap	=	
				(WORDMAP *) ExternAlloc (sizeof (*pOldAltList->aAlt[iAlt].pMap));

			if (!pOldAltList->aAlt[iAlt].pMap)
				return FALSE;

			if (!WordMapNew2Old (pNewWordMap, pOldAltList->aAlt[iAlt].pMap, TRUE))
				return FALSE;
		}
		else
		{
			pOldAltList->aAlt[iAlt].pMap	=	NULL;
		}
		
	}

	return TRUE;
}

// Frees an ink line
void FreeInkLine (INKLINE *pInkLine)
{
	if (pInkLine->pcPt)
		ExternFree (pInkLine->pcPt);

	if (pInkLine->ppPt)
		ExternFree (pInkLine->ppPt);

	if (pInkLine->pGlyph)
		DestroyGLYPH (pInkLine->pGlyph);

	if (pInkLine->pResults)
	{
		FreeLineSegm (pInkLine->pResults);
		ExternFree (pInkLine->pResults);
	}
}

// Free the contents of an existing line breaking structure
void FreeLines (LINEBRK *pLineBrk)
{
	int	i;

	// free lines
	if (pLineBrk->pLine)
	{
		for (i = 0; i < pLineBrk->cLine; i++)
		{
			FreeInkLine (pLineBrk->pLine + i);
		}
	
		ExternFree (pLineBrk->pLine);
	}

	pLineBrk->cLine		=	0;
	pLineBrk->pLine		=	NULL;
}

// given a main glyph and a wordmap, 
// this function returns a pointer to glyph representing the word only
GLYPH *GlyphFromNewWordMap (GLYPH *pMainGlyph, WORD_MAP *pMap)
{
	int		iStroke;
	GLYPH	*pGlyph = NewGLYPH();

	if (!pGlyph)
		return NULL;

	// create a glyph correspnding to the word mapping
	for (iStroke = 0 ; iStroke < pMap->cStroke ; ++iStroke)
	{
		FRAME		*pFrame = FindFrame(pMainGlyph, pMap->piStrokeIndex[iStroke]);
		ASSERT(pFrame);
		if (!pFrame)
		{
			goto fail;
		}
		
		if (!AddFrameGLYPH(pGlyph, pFrame))
		{
			goto fail;
		}
	}

	return pGlyph;

fail:
	if (pGlyph)
	{
		DestroyFramesGLYPH(pGlyph);
		DestroyGLYPH(pGlyph);
	}
	return NULL;
}

// find word map in 
int	FindWordMapInXRCRESULT (XRCRESULT *pRes, WORDMAP *pMap)
{
	unsigned int	iWord;
	
	for (iWord = 0; iWord < pRes->cWords; iWord++)
	{
		if (IsEqualOldWordMap (pRes->pMap + iWord, pMap))
		{
			return iWord;
		}
	}

	// could not find it
	return -1;
}

short AbsoluteToLatinLayout(int y, RECT *pRect)
{
	int norm = pRect->bottom - pRect->top + pRect->right - pRect->left;
	int center = (pRect->bottom + pRect->top)/2;
	int i, ady, dy;

	dy = y - center;
	ady = dy < 0 ? -dy : dy;
	if (ady > 3*norm)
		i = dy < 0 ? -30000 : 30000;
	else
		i = (y - center)*10000/norm;

	//if (y < pRect->bottom && y >= pRect->top)
	//{
	//	ASSERT(i >= -10000);
	//	ASSERT(i <= 10000);
	//}
	//else
	//{
	//	ASSERT(i >= -30000);
	//	ASSERT(i <= 30000);
	//}

	return (short)i;
}

int LatinLayoutToAbsolute(short y, RECT *pRect)
{
	int norm = pRect->bottom - pRect->top + pRect->right - pRect->left;
	int center = (pRect->bottom + pRect->top)/2;

	ASSERT(y <= 30000);
	ASSERT(y >= -30000);
	return (int)y*norm/10000 + center;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\api\tpghandle.c ===
/****************************************************************
*
* NAME: tpgHandle.c
*
*   Set of routines to manage dispensing of handles to the outside
*	world. This means it manages only the WISP handles. Essentially
*   these routines manage the mapping from a handle to a real pointer
*
*   HRECOALT
*	HRECOCONTEXT
*	HRECOGNIZER
*	HRECOLATTICE
*	HRECOWORDLIST
*
* HISTORY
*
*   Created: Feb 2002 - mrevow 
***************************************************************/
#include <common.h>
#include <winbase.h>
#include "TpgHandle.h"


typedef struct tagHandleTab
{
	int					type;
	void				*pBuf;

} HANDLE_TAB;

// Main table is allocated in chuncks
static const unsigned long	s_iExtend = 4;

static HANDLE_TAB		*s_handleTab = NULL;			// Actual Table of handles
static unsigned long	s_cHandleTab = 0;				// Maximum size of the table	

// difference between a handle's value and the index into the handle table
#define		TPG_HANDLE_OFFSET		(unsigned long)(0x1)


static CRITICAL_SECTION HandleCriticalSection = {0}; 
static long	s_cCrticalSectionInitialize = -1;



/**************************************************************
 *
 *
 * NAME: extendTable
 *
 * DESCRIPTION:
 *
 *  Grow the table to allow for more handles
 *
 * CAVEATES
 *
 *  
 * RETURNS:
 *
 * Next entry in the enlarged table. NULL if a failure occurred 
 *
 *************************************************************/
static HANDLE_TAB * extendTable()
{
	ULONG			iNewSize;
	ULONG			idx;
	HANDLE_TAB		*pTab;

	iNewSize = s_cHandleTab + s_iExtend;
	pTab = (HANDLE_TAB *)ExternRealloc(s_handleTab, sizeof(*s_handleTab) * iNewSize);

	if (NULL == pTab)
	{
		return NULL;
	}

	// Succeeded update the real pointer
	s_handleTab = pTab;	

	pTab = s_handleTab + s_cHandleTab;
	for (idx = s_cHandleTab ; idx < iNewSize ; ++idx, ++pTab)
	{
		pTab->type = TPG_RESERVED_HANDLE_TYPE;
		pTab->pBuf = NULL;
	}

	pTab = s_handleTab + s_cHandleTab;
	s_cHandleTab = iNewSize;

	return pTab;
}

/**************************************************************
 *
 *
 * NAME: CreateTpgHandle
 *
 * DESCRIPTION:
 *
 *  Called from outside to create a new handle. Caller passes in
 * both the type and pointer that is to be associated with the
 * new handle
 *
 * CAVEATES
 *
 *  Only one thread can have access at a time
 *
 * RETURNS:
 *
 * The new handle 
 *
 *************************************************************/
HANDLE	CreateTpgHandle(int type, void *pBuf)
{
	HANDLE				hRet = 0;
	unsigned int		idx;			// i64 so can exchange handles and indices
	HANDLE_TAB			*pTab;

	if (type == TPG_RESERVED_HANDLE_TYPE || NULL == pBuf)
	{
		return hRet;
	}

	if (FALSE == validateTpgHandle(pBuf, type))
	{
		ASSERT("ERROR: Attempt to create RECO handle for bad pointer"  
				&& TRUE == validateTpgHandle(pBuf, type));
		return hRet;
	}

	EnterCriticalSection(&HandleCriticalSection);
	{
		if (    NULL == s_handleTab
			&&  NULL == extendTable() )
		{
			goto exit;
		}

		pTab = s_handleTab;
		for ( idx = 0 ; idx < s_cHandleTab ; ++ idx, ++pTab)
		{
			// For now we are warning if same pointer is used twice
			ASSERT("Warning attempt to create a RECO handle twice on same pointer"
					&& pTab->pBuf != pBuf);

			if (TPG_RESERVED_HANDLE_TYPE == pTab->type)
			{
				break;
			}
		}

		if (idx >= s_cHandleTab)
		{
			pTab = extendTable();
		}

		if (pTab)
		{
			ASSERT(TPG_RESERVED_HANDLE_TYPE == pTab->type);
			ASSERT(NULL == pTab->pBuf);
			ASSERT(idx == pTab - s_handleTab);

			pTab->type = type;
			pTab->pBuf = pBuf;
			hRet = (HANDLE)(TPG_HANDLE_OFFSET + idx);
		}
		// LEFT FOR A RAINY DAY: check rest of table that pointer is not already set
	}
exit:

	 LeaveCriticalSection(&HandleCriticalSection);

	return hRet;
}

/**************************************************************
 *
 *
 * NAME: FindTpgHandle
 *
 * DESCRIPTION:
 *
 *  Locate the pointer associated with a handle and its type
 *
 * CAVEATES
 *
 *  Only one thread can have access at a time
 *
 * RETURNS:
 *
 *  The pointer or NULL if not found  
 *
 *************************************************************/
void *FindTpgHandle(HANDLE hHand, int type)
{
	void				*pRet = NULL;
	unsigned int		idx;

	idx = (unsigned int)hHand;

	ASSERT(idx >= TPG_HANDLE_OFFSET);
	if (idx < TPG_HANDLE_OFFSET )
	{
		return pRet;
	}

	idx -= TPG_HANDLE_OFFSET;

	if (idx >= s_cHandleTab)
	{
		return pRet;
	}

	EnterCriticalSection(&HandleCriticalSection);
	{
		if (NULL != s_handleTab)
		{
			HANDLE_TAB		*pTabEntry;

			pTabEntry = s_handleTab + idx;
			if (type == pTabEntry->type)
			{
				pRet = pTabEntry->pBuf;
			}
		}
	} LeaveCriticalSection(&HandleCriticalSection);

	if (NULL != pRet)
	{
		if (FALSE == validateTpgHandle(pRet, type))
		{
			ASSERT("ERROR: Invalid pointer found in RECO handle table" 
					&& TRUE == validateTpgHandle(pRet, type));
			pRet = NULL;
		}
	}

	return pRet;
}

/**************************************************************
 *
 *
 * NAME: DestroyTpgHandle
 *
 * DESCRIPTION:
 *
 *  Destroy a handle
 *
 * CAVEATES
 *
 *  Destroys the handle NOT its associated pointer
 *  The caller must take care of the pointer
 *
 * RETURNS:
 *
 *  The pointer that was associated with the handel
 *
 *************************************************************/

void *DestroyTpgHandle(HANDLE hHand, int type)
{
	void				*pRet = NULL;
	unsigned int		idx;			// i64 so can exchange handles and indices

	idx = (unsigned int)hHand;

	ASSERT(idx >= TPG_HANDLE_OFFSET);
	if (idx < TPG_HANDLE_OFFSET )
	{
		return pRet;
	}

	EnterCriticalSection(&HandleCriticalSection);
	{
		idx -= TPG_HANDLE_OFFSET;

		if (   NULL != s_handleTab
			&& idx < s_cHandleTab)
		{
			HANDLE_TAB		*pTabEntry;

			pTabEntry = s_handleTab + idx;
			if (type == pTabEntry->type)
			{
				pRet = pTabEntry->pBuf;
				pTabEntry->type = TPG_RESERVED_HANDLE_TYPE;
				pTabEntry->pBuf = NULL;
			}
		}
	} LeaveCriticalSection(&HandleCriticalSection);

	if (NULL != pRet)
	{
		if (FALSE == validateTpgHandle(pRet, type))
		{
			//ASSERT("ERROR: Invalid pointer in handle table" == NULL);
			ASSERT(TRUE == validateTpgHandle(pRet, type));
			pRet = NULL;
		}
	}
	return pRet;
}

/**************************************************************
 *
 *
 * NAME: initTpgHandleManager
 *
 * DESCRIPTION:
 *
 * Initializes the handle manager by allocating the thread sync stuff
 *
 * CAVEATES
 *
 *  Call before using the handle manager
 *
 * RETURNS:
 *
 *  FALSE if cannot initialize
 *
 *************************************************************/
BOOL initTpgHandleManager()
{
	BOOL		bRet = TRUE;

	if (0 == InterlockedIncrement(&s_cCrticalSectionInitialize))
	{
		// Use a low spin count purely to avoid having to handle an exception with the older
		// InitializeCriticalSection
		bRet = InitializeCriticalSectionAndSpinCount(&HandleCriticalSection, 4000); 
	}
	else
	{
		InterlockedDecrement(&s_cCrticalSectionInitialize);
	}

	return bRet;

}

/**************************************************************
 *
 *
 * NAME: closeTpgHandleManager
 *
 * DESCRIPTION:
 *
 *  Free all memory associated with the handle manager
 *
 * CAVEATES
 *
 *  Call when unloading the DLL
 *  In DBG mode will check for leaking handles
 *
 * RETURNS:
 *
 *  None  
 *
 *************************************************************/
void closeTpgHandleManager()
{

#ifdef DBG
	ULONG				idx;
	HANDLE_TAB			*pTab;

	// Check for leaking handles
	if (NULL != s_handleTab)
	{
		pTab = s_handleTab;
		for ( idx = 0 ; idx < s_cHandleTab ; ++idx, ++pTab)
		{
			ASSERT(("WARNING: Calling application is leaking Handles ") && (TPG_RESERVED_HANDLE_TYPE == pTab->type) );		// Check for a leaking handle in recognizer
		}
	}
#endif


	if (NULL != s_handleTab)
	{
		ExternFree(s_handleTab);
	}

	// Only delete it if it was initialized
	if (0 != InterlockedIncrement(&s_cCrticalSectionInitialize))
	{
		DeleteCriticalSection(&HandleCriticalSection);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\api\tpghandle.h ===
/****************************************************************
*
* NAME: tpgHandle.h
*
*
* DESCRIPTION:
*
*   Set of routines to manage dispensing of handles to the outside
*	world. This means it manages only the WISP handles. Essentially
*   these routines manage the mapping from a handle to a real pointer
*
*   HRECOALT
*	HRECOCONTEXT
*	HRECOGNIZER
*	HRECOLATTICE
*	HRECOWORDLIST
*
* HISTORY
*
*   Created: Feb 2002 - mrevow 
*
***************************************************************/
#ifndef _TPG_HANDLE_H
#define _TPG_HANDLE_H

// This is a reserved handle type make sure none of your handle types
// conflict with this value
#define TPG_RESERVED_HANDLE_TYPE		(0xBEEFDEAD)


// Create a new handle. 
// Caller supplies the type and the pointer that should be 
// associated with the new handle
// Returns: The new handle
HANDLE	CreateTpgHandle(int type, void *pBuf);

// Destroy a handle. Note this only destroys the mapping
// it does not destroy the actual pointer
// Returns: The pointer that was associated with the handle
void *DestroyTpgHandle(HANDLE hHand, int type);


// Returns the pointer assocated with the handle or 
// NULL if there is no association
void *FindTpgHandle(HANDLE hHand, int type);

// Initialize the handle manager. 
// Returns: False if manager could not initialize
BOOL initTpgHandleManager();

// Shut down the handle manage. Should be closed to release memory associated
// with the manager. Typically called when the DLL is unloaded
void closeTpgHandleManager();


// Must be implemented in the caller
extern BOOL validateTpgHandle(void *pPtr, int type);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\api\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif

!if $(FREEBUILD)
HWXBIN=$(_TPG_ROOT)\hwx\release
!else
HWXBIN=$(_TPG_ROOT)\hwx\debug
!endif

hwxbin: $(O)\$(TARGETNAME).$(TARGETEXT)
    mkdir $(HWXBIN)
    copy $(O)\$(TARGETNAME).$(TARGETEXT) $(HWXBIN)
    copy $(O)\$(TARGETNAME).pdb $(HWXBIN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\nni\nniio.h ===
/*****************************************************
*
* FILE: nniIO.h
*
* Common routines for reading/writing NNI files
*
*  Oct 1999 mrevow
*    nni file format (version 100)
*
* Version number_of_samples Number_of_features_perSeg Number_of_targets_perFeat
* number_ofSegments Targets Features
*
* If number_ofSegments < 0 then target is prompt else hard targets
* 
*
*******************************************************/

#ifndef H_NNI_IO_H
#define H_NNI_IO_H

#ifdef __cplusplus
extern "C"
{
#endif

#define NNI_VERSION		400
#define MAX_TARGET_TYPE 10

typedef struct tagNNI_HEADER
{
	int			version;					// Version umber
	int			cExample;					// Number of examples
	int			cFeat;						// Number of input features per segment
	int			cTargetType;				// number of types of targets eg. space, accent, regular characters
	int			cTargets;					// Min number of numbers required to completly specify all target values
	int			acTarget[MAX_TARGET_TYPE];	// Number of targets for each type per segment
} NNI_HEADER;

extern int readNNIheader(NNI_HEADER *pNni, FILE *fp);
extern int writeNNIheader(NNI_HEADER *pNni, FILE *fp);
extern int cmpNNIheader(NNI_HEADER *pHdr1, NNI_HEADER *pHdr2);
extern BOOL readNextNNIrecord(FILE *pfRead, NNI_HEADER *pHdr, BOOL bEuro, short *pcSeg, short *piWeight, unsigned short ***pprTargets, unsigned short **ppInputs);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif

!if $(FREEBUILD)
HWXBIN=$(_TPG_ROOT)\hwx\release
!else
HWXBIN=$(_TPG_ROOT)\hwx\debug
!endif

hwxbin: $(O)\$(TARGETNAME).$(TARGETEXT)
    mkdir $(HWXBIN)
    copy $(O)\$(TARGETNAME).$(TARGETEXT) $(HWXBIN)
    copy $(O)\$(TARGETNAME).pdb $(HWXBIN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\common\src\nni\nniio.c ===
/*****************************************************
*
* FILE: nniIO.c
*
* Common routines for reading/writing NNI files
*
*******************************************************/
#include <stdio.h>
#include <common.h>
#include "nniIO.h"
#include <memory.h>


// Read a header Returns version number or 0 if an error occurs

int readNNIheader(NNI_HEADER *pHead, FILE *fp)
{
	int		version, cExample, cFeat, cTargetType, acTarget[MAX_TARGET_TYPE];
	int		i;

	if (   (1 == fread(&version, sizeof(version), 1, fp))
		&& (version == NNI_VERSION)
		&& (1 == fread(&cExample, sizeof(cExample), 1, fp))
		&& (1 == fread(&cFeat, sizeof(cFeat), 1, fp))
		&& (1 == fread(&cTargetType, sizeof(cTargetType), 1, fp))
		&& (1 == fread(acTarget, sizeof(acTarget), 1, fp)) )
	{
		pHead->version = version;
		pHead->cExample = cExample;
		pHead->cTargetType = cTargetType;
		pHead->cFeat = cFeat;
		memcpy(pHead->acTarget, acTarget, sizeof(acTarget));

		pHead->cTargets = 0;
		// Count mini number of number required to specify all tragtes
		// The last group of targets is assumed to be 1-of-N
		for (i = 0 ; i < pHead->cTargetType - 1 ; ++i)
		{
			pHead->cTargets += pHead->acTarget[i];
		}

		pHead->cTargets++;			// For the last group which is assumed to be 1-of-N

		return version;
	}
	else
	{
		return 0;
	}
}

int writeNNIheader(NNI_HEADER *pHead, FILE *fp)
{
	int version = NNI_VERSION;

	if (   (1 == fwrite(&version, sizeof(pHead->version), 1, fp))
		&& (1 == fwrite(&pHead->cExample, sizeof(pHead->cExample), 1, fp))
		&& (1 == fwrite(&pHead->cFeat, sizeof(pHead->cFeat), 1, fp))
		&& (1 == fwrite(&pHead->cTargetType, sizeof(pHead->cTargetType), 1, fp))
		&& (1 == fwrite(pHead->acTarget, sizeof(pHead->acTarget), 1, fp)) )
	{
		pHead->version = version;
		return version;
	}
	else
	{
		return 0;
	}
}

// Returns 0 if the 2 headers are for same type of nni file
int cmpNNIheader(NNI_HEADER *pHdr1, NNI_HEADER *pHdr2)
{
	int		iRet = 1;

	if (   pHdr1->version == pHdr2->version
		&& pHdr1->cFeat == pHdr2->cFeat
		&& pHdr1->cTargetType == pHdr2->cTargetType
		&& pHdr1->cTargets == pHdr2->cTargets )
	{
		int		i;
	
		// looks like they are compatible - Do final check
		iRet = 0;

		for (i = 0 ; i< pHdr1->cTargetType ; ++i)
		{
			if (pHdr1->acTarget[i] != pHdr2->acTarget[i])
			{
				// Fails
				iRet = 1;
				break;
			}
		}
	}

	return iRet;
}

/////////////////////////////////////////////////////////
//                                          
// Name: allocRecordMem
// 
// DESCRIPTION:
//
// Allocates extra memory for the target array bug=fers and the input buffer
//
// Parameters:
//
//		pHdr	- IN: Header structure filled in by call to readNNIheader
//		cSize	- IN: Requested number of segments to allocate
//		prTargets - IN/OUT: Array of target buffer pointers. Each buffer is resized
//		pInput	- IN/OUT Buffer for inputs
//
//
// Return Values:
//
//	TRUE / FALSE if memory allocation failed -
//    WARNING: No cleanup is done on failure
//
/////////////////////////////////////////////////////////
static BOOL allocRecordMem(NNI_HEADER *pHdr, int cSize, unsigned short ***prTargets, unsigned short **ppInputs)
{
	int			i;

	if (!(*prTargets))
	{
		*prTargets =  (unsigned short **)realloc(*prTargets, sizeof(**prTargets)*pHdr->cTargetType);
		if (! *prTargets)
		{
			return FALSE;
		}

		memset((*prTargets), 0, sizeof(**prTargets) * pHdr->cTargetType);
	}
	
	
	for (i = 0 ; i < pHdr->cTargetType-1 ; ++i)
	{
		(*prTargets)[i] = (unsigned short *) realloc((*prTargets)[i], sizeof(*(*prTargets)[i]) * cSize * pHdr->acTarget[i]);
		if (!(*prTargets)[i])
		{
			return FALSE;
		}
	}
	
	// 1 - of N Allocation
	(*prTargets)[i] = (unsigned short *) realloc((*prTargets)[i], sizeof(*(*prTargets)[i]) * ((cSize-1)*pHdr->cTargets + 1));
	*ppInputs = (unsigned short *)realloc(*ppInputs, sizeof(**ppInputs) * cSize * pHdr->cFeat);
	
	if (! *ppInputs)
	{
		return FALSE;
	}
	
	return TRUE;

}

/////////////////////////////////////////////////////////
//                                          
// Name: readNextNNIrecord
// 
// DESCRIPTION:
//
// Reads the next record from the file descriptor. Assumes that file pointer
// is correctly positioned to read the record. This will occur if an
// app follows the sequence
//		fopen();
//		readNNIheader();
//		for all records
//			readNextNNIrecord()
//
//		fclose();
//
// Parameters:
//		pfRead	- IN: file desriptor
//		pHdr	- IN: Header structure filled in by call to readNNIheader
//		cSeg	- IN/OUT: Number of segments. On input it specifies the largest number of segments
//						  that can be accomodated by the target and input buffers
//		iWeight	- OUT: Weight assigned to sample (Almost always will be 1)
//		prTargets - IN/OUT: An array of targets pointers. Each buffer should be large enough to hold cSeg
//						  data targets. If the buffers are too small the routine will resize them using realloc()
//		pInput	- IN/OUT Buffer with all the inputs
//
// Return Values:
//
//		TRUE/ FALSE if an error (unrecoverable) occured
/////////////////////////////////////////////////////////
BOOL readNextNNIrecord(FILE *pfRead, NNI_HEADER *pHdr, BOOL bEuro, short *pcSeg, short *piWeight, unsigned short ***pprTargets, unsigned short **ppInputs)
{
	int					cSize;
	short				cSeg;
	unsigned short		**prTargets;

	if (!pfRead)
	{
		return FALSE;
	}

	if (1 != fread(&cSeg, sizeof(cSeg), 1, pfRead))
	{
		return FALSE;
	}


	if (1 != fread(piWeight, sizeof(*piWeight), 1, pfRead))
	{
		return FALSE;
	}

	cSize = (cSeg < 0) ? -cSeg : cSeg;

	if (cSize > *pcSeg)
	{
		if (FALSE == allocRecordMem(pHdr, cSize, pprTargets, ppInputs))
		{
			return FALSE;
		}
	}

	prTargets = *pprTargets;

	if (cSeg < 0)
	{
		int		j;

		if (bEuro)
		{
			for (j = 0 ; j < pHdr->cTargetType-1 ; ++j)
			{
				fread(prTargets[j], sizeof(**prTargets), pHdr->acTarget[j], pfRead);
			}
			fread(prTargets[j], sizeof(**prTargets), (cSize-1)* pHdr->cTargets + 1, pfRead);
		}
		else
		{
			j = pHdr->cTargetType-1;
			fread(prTargets[j], sizeof(**prTargets), cSize* pHdr->cTargets, pfRead);
		}
	}
	else
	{
		int		iSeg, i;

		for (iSeg = 0 ; iSeg < cSeg ; ++iSeg)
		{
			// Read all the target Types Note the last one is special
			// as it is a defined as a 0ne-of-N
			for (i = 0  ; i < pHdr->cTargetType ; ++i)
			{
				int		cTarget;

				// Handle the last target type specially as a one of N type
				cTarget = (i == pHdr->cTargetType-1) ? 1 : pHdr->acTarget[i];
				fread(prTargets[i] + iSeg * cTarget, sizeof(*prTargets[i]), cTarget, pfRead);
			}
		}

	}

	if (cSize * pHdr->cFeat != (int)fread(*ppInputs, sizeof(**ppInputs), cSize * pHdr->cFeat, pfRead))
	{
		return FALSE;
	}

	*pcSeg = cSeg;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\errsys.h ===
/******************************Module*Header*******************************\
* Module Name: errsys.h
*
* This provides the ASSERT and VERIFY macros for all apps in all the
* recognition apps.
*
* Created: 04-Oct-1995 16:17:00
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#ifndef _INC_ERRSYS_H
#define _INC_ERRSYS_H

#include <TabInc.h>

#if (defined(DBG) || defined(DBG) || defined(DEBUGINTERNAL))

extern int giDebugLevel;
#define JUST_DEBUG_MSG (giDebugLevel = 1)  // Add to program init if desired.

#ifdef __cplusplus
extern "C" {
#endif

int HwxAssertFn(int, char *, char *);
int HwxWarning(int, char *, char *);

#ifdef __cplusplus
}
#endif

#ifndef VERIFY
#define VERIFY(cond) ((cond) || HwxAssertFn(__LINE__,__FILE__,#cond))
#endif
#ifndef PANIC
#define PANIC        ASSERT(0)
#endif
#ifndef WARNING
#define WARNING(cond) ((cond) || HwxWarning(__LINE__,__FILE__,#cond))
#endif


#else

#ifndef VERIFY
#define	VERIFY(x)	(x)
#endif
#ifndef PANIC
#define PANIC
#endif
#ifndef WARNING
#define WARNING(x)
#endif

#endif // DBG

#endif // _INC_ERRSYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\confsetfl.h ===
#if !defined (__COMMON_CONF_SET__)

#define __COMMON_CONF_SET__

int ReadConfSetEntry	(	FILE	*fp, 
							wchar_t *pType, 
							int		*pCnt, 
							wchar_t **ppCodePoint,
							wchar_t	*pwExtraInfo
						);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\bigram.h ===
/******************************************************************************\
 *	FILE:	bigram.h
 *
 *	Public structures and functions library that are used to access the 
 *	bigram information.
 *
 *	Note that the code to create the binary file is in mktable, not in the
 *	common library.
\******************************************************************************/
#ifndef __INCLUDE_BIGRAM
#define	__INCLUDE_BIGRAM

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************************************\
 *	Public interface to bigram data.
\************************************************************************************************/

//
// Structures and types
//

// Structure to hold second character and probability for bigram.
typedef struct tagBIGRAM_CHAR_PROB {
	wchar_t		dch;			// Second char of bigram, in dense coding.
	WORD		prob;			// Probability as a score (-10 * log2(prob)).
} BIGRAM_CHAR_PROB;

// Structure giving access to a loaded copy of the bigram tables.
typedef struct tagBIGRAM_INFO {
	WORD				cInitialCodes;		// Number of entries in initial code table.
	WORD				cRareCodes;			// Number of entries in rare table.
	WORD				cSecondaryTable;	// Number of entries in secondary table.
	WORD				*pInitialOffsets;	// Pointer to offsets indexed by initial codes.
	WORD				*pRareOffsets;		// Pointer to offsets indexed by rare (initial) codes.
	BIGRAM_CHAR_PROB	*pSecondaryTable;	// Pointer to secondary table of char and prob.

	void				*pLoadInfo1;		// Handles needed to unload the data
	void				*pLoadInfo2;
	void				*pLoadInfo3;
} BIGRAM_INFO;

//
// Functions.
//

// Load bigram information from a file.
BOOL	BigramLoadFile(LOCRUN_INFO *pLocRunInfo, BIGRAM_INFO *pBigramInfo, wchar_t *pPath);

// Unload runtime localization information that was loaded from a file.
BOOL	BigramUnloadFile(BIGRAM_INFO *pBigramInfo);

// Load bigram information from a resource.
// Note, don't need to unload resources.
BOOL	BigramLoadRes(
	LOCRUN_INFO *pLocRunInfo, 
	BIGRAM_INFO	*pBigramInfo,
	HINSTANCE	hInst,
	int			nResID,
	int			nType
);

// Load runtime localization information from an image already loaded into
// memory.
BOOL	BigramLoadPointer(LOCRUN_INFO *pLocRunInfo, BIGRAM_INFO *pBigramInfo, void *pData);

// Get bigram probability for selected characters.  Characters must be passed in as
// dense coded values.
FLOAT	BigramTransitionCost(
	LOCRUN_INFO		*pLocRunInfo,
	BIGRAM_INFO		*pBigramInfo,
	wchar_t			dchPrev,
	wchar_t			dchCur
);

/************************************************************************************************\
 *	Stuff to access binary bigram file, only used by common and mktable.
\************************************************************************************************/

// The format for the bigram file is:
//		Header:
//			DWORD				File type indicator.
//			DWORD				Size of header.
//			BYTE				Lowest version this code that can read this file.
//			BYTE				Version of this code that wrote this file.
//			wchar_t[4]			Locale ID (3 characters plus null).
//			DWORD * 3			Locale signature
//			WORD				Number of entries in initial code table.
//			WORD				Number of entries in rare table.
//			WORD				Number of entries in secondary table.
//			DWORD * 2			Reserved for future use.
//		Initial code table:
//			WORD				Index to second table for dense code 0.
//			WORD				Index to second table for dense code 1.
//				.
//				.
//				.
//			WORD				Index to second table for dense code N.
//		Rare (initial) code table:
//			WORD				Index to second table for first class code.
//			WORD				Index to second table for second class code.
//				.
//				.
//				.
//			WORD				Index to second table for Nth class code.
//			WORD				Index to end of table, so we can check range of last code.
//		Secondary table:
//			BIGRAM_CHAR_PROB	Character and probability.
//				.
//				.
//				.
//			BIGRAM_CHAR_PROB	Character and probability.
//
// NOTE: all characters are stored as dense coded values, and values with the type byte set
// to 0xFF are summary codes for groups of codes.

//
// Constants
//

// Magic key the identifies the Local Runtime files
#define	BIGRAM_FILE_TYPE	0x879AB8DF

// Version information for file.
#define	BIGRAM_MIN_FILE_VERSION		0	// First version of code that can read this file
#define BIGRAM_CUR_FILE_VERSION		0	// Current version of code.
#define	BIGRAM_OLD_FILE_VERSION		0	// Oldest file version this code can read.

// Character class code values
// Note that BIGRAM_MAX_CLASS_CODES, is just an upper limit, there may not actually be
// that many classes.
#define BIGRAM_FIRST_CLASS_CODE		0xFF00	// Value to start class codes at.
#define BIGRAM_MAX_CLASS_CODES		0x20	// Upper limit on number of class codes.
#define	BIGRAM_LAST_CLASS_CODE		(BIGRAM_FIRST_CLASS_CODE + 	BIGRAM_MAX_CLASS_CODES - 1)
											// Highest class code that can be returned.

// Probability to use if no bigram entry found.
#define BIGRAM_DEFAULT_PROB			255			// JRB: Figure a good value for this ???

//
// Structures and types
//

// Structure to hold file header.
typedef struct tagBIGRAM_HEADER {
	DWORD		fileType;		// This should always be set to BIGRAM_FILE_TYPE.
	DWORD		headerSize;		// Size of the header.
	BYTE		minFileVer;		// Earliest version of code that can read this file
	BYTE		curFileVer;		// Current version of code that wrote the file.
	wchar_t		locale[4];		// Locale ID string.
	DWORD		adwSignature[3];	// Locale signature
	WORD		cInitialCodes;	// Number of entries in initial code table.
	WORD		cRareCodes;		// Number of entries in rare table.
	WORD		cSecondaryTable;// Number of entries in secondary table.
	DWORD		reserved[2];
} BIGRAM_HEADER;

//
// Functions
//

// Convert a dense coded character to its character class.
wchar_t		BigramDense2Class(LOCRUN_INFO *pLocRunInfo, wchar_t dch);

#ifdef __cplusplus
}
#endif

#endif	// __INCLUDE_BIGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\filemgr.h ===
// System dependency file
//
// This contains the code to deal with UNICODE/ANSI file/string access.
// More cross platform functionality will be added here later

#ifdef __cplusplus
extern "C" 
{
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\frame.h ===
// frame.h

#ifndef __INCLUDE_FRAME
#define __INCLUDE_FRAME

#ifdef __cplusplus
extern "C" 
{
#endif

typedef	POINT	XY;

typedef struct tagFRAME
{
	void	   *pvData;		// Recognizer specific private data
	STROKEINFO	info;		// Physical info about ink (Penwin.h)
	UINT        csmoothxy;	// points in smoothed strokes
	XY		   *rgrawxy;	// tablet coords of all the points in the stroke
	XY		   *rgsmoothxy;	// array of points after smoothing
	RECT        rect;		// bounding box of this stroke
	int         iframe;		// pos of this frame in linked list of glyphs
} FRAME;

FRAME	   *NewFRAME(void);
void		DestroyFRAME(FRAME *self);
RECT	   *RectFRAME(FRAME *self);
void TranslateFrame (FRAME *pFrame, int dx, int dy);

#define SetIFrameFRAME(frame,i)		((frame)->iframe = (i))
#define IFrameFRAME(frame)			((frame)->iframe)
#define DeInitRectFRAME(frame)		((frame)->rect.left = -1)
#define IsVisibleSTROKE(info)		(((info)->wPdk) & PDK_TIPMASK)
#define IsVisibleFRAME(frame)		(IsVisibleSTROKE(&(frame)->info))
#define RgrawxyFRAME(frame)			((frame)->rgrawxy)
#define CrawxyFRAME(frame)			((frame)->info.cPnt)
#define RawxyAtFRAME(frame,i)		((frame)->rgrawxy[i])
#define LppointFRAME(frame)			((LPPOINT)(frame)->rgrawxy)
#define CpointFRAME(frame)			((frame)->info.cPnt)
#define CpointSmoothFRAME(frame)	((frame)->csmoothxy)
#define LpframeinfoFRAME(frame)		(&(frame)->info)


#ifdef __cplusplus
};
#endif

#endif	//__INCLUDE_FRAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\langtax.h ===
// langtax.h
// rsarac & aguha
// July 10, 2000

#ifndef _LANGTAX
#define _LANGTAX

#ifdef __cplusplus
extern "C" {
#endif

extern int GetIndexFromLANG(WORD wIDLanguage);
extern int GetIndexFromLocale(wchar_t *wszLang);
extern int GetClassCountLANG(int iLangIndex);
extern wchar_t *GetClassNameLANG(int iLangIndex, int iClassIndex);
extern int GetClassFromLANG(int iLangIndex, wchar_t wChar);
extern BOOL IsLatinLANG(int iLangIndex);
extern wchar_t *GetNameLANG(int iLangIndex);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\glyph.h ===
// glyph.h

#ifndef __INCLUDE_GLYPH
#define __INCLUDE_GLYPH

#ifdef __cplusplus
extern "C" 
{
#endif

#include "frame.h"

typedef struct tagGLYPH GLYPH;

typedef struct tagGLYPH
{
	FRAME  *frame;
	GLYPH  *next;
} GLYPH;

GLYPH  *NewGLYPH(void);
void	DestroyGLYPH(GLYPH *self);
void	DestroyFramesGLYPH(GLYPH *self);
int		CframeGLYPH(GLYPH * self);
FRAME  *FrameAtGLYPH(GLYPH * self, int iframe);
void	GetRectGLYPH(GLYPH * self, LPRECT rect);
BOOL	AddFrameGLYPH(GLYPH * self, FRAME * frame);
GLYPH  *MergeGlyphGLYPH(GLYPH * self, GLYPH * merge);
GLYPH  *GlyphFromHpendata(HPENDATA hpendata);
XY     *SaveRawxyGLYPH(GLYPH *self);
void    RestoreRawxyGLYPH(GLYPH *self, XY *xy);
void TranslateGlyph (GLYPH *pGlyph, int dx, int dy);
void TranslateGuide (GUIDE *pGuide, int dx, int dy);

#define  GlyphCopyGLYPH(self) MergeGlyphGLYPH(self, 0)

#ifdef __cplusplus
};
#endif

#endif	//__INCLUDE_GLYPH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\clbigram.h ===
#ifndef __CLASSBIGRAM__
#define __CLASSBIGRAM__

/******************************************************************************\
 *	FILE:	clbigram.h
 *
 *	Public structures and functions library that are used to access the 
 *	class bigram information.
 *
 *	Note that the code to create the binary file is in clbigram, not in the
 *	common library.
\******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************************************\
 *	Public interface to class bigram data.
\************************************************************************************************/

//
// Structures and types
//

// Structure giving access to a loaded copy of the class bigram tables.
typedef struct tagCLASS_BIGRAM_INFO {
	WORD				cNumClasses;		// Number of classes
	BYTE				*pProbTable;		// Probability table

	void				*pLoadInfo1;		// Handles needed to unload the data
	void				*pLoadInfo2;
	void				*pLoadInfo3;
} CLASS_BIGRAM_INFO;

//
// Functions.
//

// Load class bigram information from a file.
BOOL	ClassBigramLoadFile(LOCRUN_INFO *pLocRunInfo, CLASS_BIGRAM_INFO *pBigramInfo, wchar_t *pPath);

// Unload runtime localization information that was loaded from a file.
BOOL	ClassBigramUnloadFile(CLASS_BIGRAM_INFO *pBigramInfo);

// Load class bigram information from a resource.
// Note, don't need to unload resources.
BOOL	ClassBigramLoadRes(
	LOCRUN_INFO *pLocRunInfo,
	CLASS_BIGRAM_INFO	*pBigramInfo,
	HINSTANCE			hInst,
	int					nResID,
	int					nType
);

// Load runtime localization information from an image already loaded into
// memory.
BOOL	ClassBigramLoadPointer(LOCRUN_INFO *pLocRunInfo, CLASS_BIGRAM_INFO *pBigramInfo, void *pData);

// Get class bigram probability for selected characters.  Characters must be passed in as
// dense coded values.
FLOAT ClassBigramTransitionCost(
	LOCRUN_INFO				*pLocRunInfo,
	CLASS_BIGRAM_INFO		*pBigramInfo,
	wchar_t					dchPrev,
	wchar_t					dchCur
);

/************************************************************************************************\
 *	Stuff to access binary class bigram file, only used by common and clbigram.
\************************************************************************************************/

// The format for the class bigram file is:
//		Header:
//			DWORD				File type indicator.
//			DWORD				Size of header.
//			BYTE				Lowest version this code that can read this file.
//			BYTE				Version of this code that wrote this file.
//			wchar_t[4]			Locale ID (3 characters plus null).
//			DWORD * 3			Locale signature
//			WORD				Number of classes.
//			DWORD[3]			reserved
//		Prop table 0:
//			BYTE				Prob of Trans between class 0 and to class 0.
//			BYTE				Prob of Trans between class 0 and to class 1.
//				.
//				.
//				.
//			BYTE				Prob of Trans between class 0 and to class N-1.
//		Prop table 1:
//			BYTE				Prob of Trans between class 1 and to class 0.
//			BYTE				Prob of Trans between class 1 and to class 1.
//				.
//				.
//				.
//			BYTE				Prob of Trans between class 1 and to class N-1.//			WORD				Index to second table for first class code.
//				.
//				.
//				.
//		Prop table N-1:
//			BYTE				Prob of Trans between class N-1 and to class 0.
//			BYTE				Prob of Trans between class N-1 and to class 1.
//				.
//				.
//				.
//			BYTE				Prob of Trans between class N-1 and to class N-1.//			WORD				Index to second table for first class code.
//				.
//				.
//				.

//
// Constants
//

// Magic key the identifies the Local Runtime files
#define	CLASS_BIGRAM_FILE_TYPE		0x7A30C362

// Version information for file.
#define	CLASS_BIGRAM_MIN_FILE_VERSION		1	// First version of code that can read this file
#define CLASS_BIGRAM_CUR_FILE_VERSION		1	// Current version of code.
#define	CLASS_BIGRAM_OLD_FILE_VERSION		0	// Oldest file version this code can read.

// Probability to use if no bigram entry found.
#define CLASS_BIGRAM_DEFAULT_PROB			255			// JRB: Figure a good value for this ???

//
// Structures and types
//

// Structure to hold file header.
typedef struct tagCLASS_BIGRAM_HEADER {
	DWORD		fileType;			// This should always be set to BIGRAM_FILE_TYPE.
	DWORD		headerSize;			// Size of the header.
	BYTE		minFileVer;			// Earliest version of code that can read this file
	BYTE		curFileVer;			// Current version of code that wrote the file.
	wchar_t		locale[4];			// Locale ID string.
	DWORD		adwSignature [3];	// Locale signature
	WORD		cNumClasses;		// Number of classes
	DWORD		reserved [3];		// reserved
} CLASS_BIGRAM_HEADER;

//
// Functions
//

#ifdef __cplusplus
}
#endif

#endif //__CLASSBIGRAM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\guide.h ===
#ifdef __cplusplus
extern "C" {
#endif

// Convert from Old to New GUIDE structure
void ConvertToHWXGuide (HWXGUIDE *pTo, GUIDE *pFrom);

// Convert from New to Old GUIDE structure
void ConvertFromHWXGuide (GUIDE *pTo, HWXGUIDE *pFrom);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\quicktrie.h ===
// FILE: QuickTrie.h
//
// Definitions for QuickTrie program and access code.

// Flag values.
#define	QT_FLAG_VALID	0x01
#define	QT_FLAG_END		0x02

// Basic node in trie.
typedef struct tagQT_NODE {
	BYTE	label;
	BYTE	flags;
	WORD	oDown;
} QT_NODE;

// Table name generated by QuickTrie.
extern const QT_NODE	g_aQuickTrie[];

// Functions to access the QuickTrie.
extern WCHAR	FirstChildQuickTrie(DWORD *hState);
extern WCHAR	NextSiblingQuickTrie(DWORD *hState);
extern BOOL		IsValidQuickTrie(DWORD state);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\common.h ===
// This include file is to be shared among all exe's and dll's of Rodan.

#ifndef __INCLUDE_COMMON
#define __INCLUDE_COMMON

// And of course, DBG

#ifdef DBG
#ifndef DBG
#define DBG 1
#endif //!DBG
#endif //!DBG

#ifdef DBG
#ifndef DBG
#define DBG 1
#endif //!DBG
#endif //!DBG

// Include WINDOWS headers

#include <windows.h>
#include <windowsx.h>

// We really don't want these defines to mean anything

#define INLINE
#define EXPORT
#define _loadds
#define _far
#define _pascal
#define PUBLIC 
#define PRIVATE 
#define BLOCK

// Name of function changes between Windows and WindowCE
#ifdef	WINCE
#	define	CreateMappingCall	CreateFileForMapping 
#else
#	define	CreateMappingCall	CreateFile
#endif

// Include support for TCHAR functions

#include <tchar.h>

// Include the memory management functions

#include "memmgr.h"

// Include the system dependent file management layer

#ifndef HWX_PRODUCT
#	include <stdio.h>
#	include "util.h"
	BOOL	LoadDynamicNumberOfSamples(wchar_t *pFileName, FILE *pFileLog);
	int		DynamicNumberOfSamples(wchar_t);

	BOOL	LoadNatualFrequency(wchar_t *pName, FILE *pFileLog);
	DWORD	DenseCodeNumberOfSamples(wchar_t);
	BOOL	GetFrequencyInfo(DWORD,wchar_t *,DWORD *);
	DWORD	GetTotalDenseCodeSamples();
	DWORD	GetMaxDenseCodeSamples();
	DWORD	GetNatualFrequencyTableSize();
	void	UnloadNatualFrequency();
#endif
#include "filemgr.h"

// Include the common error handling stuff

#include "errsys.h"

// Include 'pen' stuff

#include "recogp.h"

// Include the math code

#include "math.h"
#include "mathx.h"

#ifndef abs
#define abs(x)  ((x) < 0 ? -(x) : (x))
#endif

// Unicode information.
#define	C_UNICODE_CODE_POINTS	0x10000			// Number of Unicode code points

// Include the 'Mars' stuff

#include "frame.h"
#include "glyph.h"

// Include the stuff to access locale dependent information.

#include "locale.h"

// Some additional declarations for natural and training frequencies that
// depend on the locale code.
#ifndef HWX_PRODUCT
	int		DynamicNumberOfSamplesFolded(LOCRUN_INFO *pLocRunInfo, wchar_t dch);
	DWORD	DenseCodeNumberOfSamplesFolded(LOCRUN_INFO *pLocRunInfo, wchar_t dch);
#endif

// Include the stuff to access the unigram bigram tables.

#include "unigram.h"
#include "bigram.h"
#include "clbigram.h"

// Fundemental types and structures everybody needs to know about

typedef ALC		RECMASK;
typedef WORD	SYM;
typedef SYM		*LPSYM;

typedef struct tagCHARSET
{
	ALC		recmask;			// Specifies which character types are to be returned
	ALC		recmaskPriority;	// Specifies which character types are preferred
    BYTE    *pbAllowedChars;    // Mask of allowed characters
    BYTE    *pbPriorityChars;   // Mask of characters that are preferred
} CHARSET;

// Accessor functions to see if the given dense or folded code is allowed.
BOOL IsAllowedChar(LOCRUN_INFO *pLocRunInfo, const CHARSET *pCS, wchar_t dch);
BOOL IsPriorityChar(LOCRUN_INFO *pLocRunInfo, const CHARSET *pCS, wchar_t dch);

// Sets characters in the bitmasks defined above in CHARSET.
// If it is given a code which can be folded, takes care of setting
// both the folded and unfolded versions.  Also takes care of allocating
// the bitmask if it is not already allocated.
BOOL SetAllowedChar(LOCRUN_INFO *pLocRunInfo, BYTE **ppbAllowedChars, wchar_t dch);

// Allocate and copy bitmask
BYTE *CopyAllowedChars(LOCRUN_INFO *pLocRunInfo, BYTE *pbAllowedChars);

#define	MAX_ALT_LIST	20

typedef struct tagALT_LIST
{
	UINT	cAlt;						// Count of valid alternatives
	FLOAT	aeScore[MAX_ALT_LIST];		// Scores for each alternatives
	wchar_t	awchList[MAX_ALT_LIST];		// List of alternatives
} ALT_LIST;

extern void SortAltList(ALT_LIST *pAltList);

#define	HWX_SUCCESS		0
#define	HWX_FAILURE		1
#define	HWX_ERROR		2

#ifdef __cplusplus
extern "C"
{
#endif

// Utility functions for tools.

// Smart generation of the path given directory, locale.
// Both the directory and locale are optional.
void	FormatPath(
	wchar_t *pPath,
	wchar_t *pRoot,
	wchar_t *pBaseDir,
	wchar_t *pLocaleName,
	wchar_t *pConfigName,
	wchar_t *pFileName
);

#ifdef __cplusplus
}
#endif

// Functions for loading/mapping databases from files or resources

// Structure to store information about the mapped region
typedef struct tagLOAD_INFO {
	HANDLE hFile;		// Handle to the file
	HANDLE hMap;		// Handle to the map
	BYTE *pbMapping;	// Pointer to the mapped region
	int iSize;			// Size in bytes
} LOAD_INFO;

// Initialize the mapped information structure
void InitLoadInfo(LOAD_INFO *pInfo);

// Map a file into memory
BYTE *DoOpenFile(LOAD_INFO *pInfo, wchar_t *pFileName);

// Unmap a file from memory
BOOL DoCloseFile(LOAD_INFO *pInfo);

// Map a resource into memory
BYTE *DoLoadResource(LOAD_INFO *pInfo, HINSTANCE hInst, int nResID, int nType);

#endif // !__INCLUDE_COMMON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\nnet.h ===
#ifndef	__NNET_H__
#define	__NNET_H__

#include "common.h"

// generic header for any neural net data
typedef struct tagNNET_HEADER
{
	DWORD		dwFileType;			// This should be set to type of the net data.
	INT 		iFileVer;			// Version of code that wrote the data.
	INT 		iMinCodeVer;		// Earliest version of code that can read this file
	wchar_t		awchLocale[4];		// Locale
	DWORD		adwSignature [3];	// locale signature
	INT			cSpace;				// # of spaces
}
NNET_HEADER;

// generic space header for neural net data
typedef struct tagNNET_SPACE_HEADER
{
	INT			iSpace;				// space ID
	long		iDataOffset;		// offset to data from beginning of file
	INT			cMap;				// size of mapping table
	long		iMapOffset;			// offset to mapping table from beginning of file
}
NNET_SPACE_HEADER;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\mathx.h ===
// mathx.h

#ifndef __INCLUDE_MATHX
#define __INCLUDE_MATHX

#ifdef __cplusplus
extern "C" 
{
#endif

int Arctan2(int y, int x);
int Distance(int dX, int dY);

#define	DISTANCE_POINT(a,b)	Distance((a).x - (b).x, (a).y - (b).y)
#define	CROSS_PRODUCT(a,b) (((long) (a).x) * ((long) (b).y) - ((long) (a).y) * ((long) (b).x))

// Calculate difference between two angles and bring into range -180 < angle <= 180.

#define ANGLEDIFF(a,b,c)  {	\
	c	= b - a;			\
	if (c > 180) {			\
		c	-= 360;			\
	} else if (c <= -180) {	\
		c	+= 360;			\
	}						\
}

// Calc d = the angle betw (the extension of rgxy[a]:rgxy[b]) and
//          (rgxy[b]:rgxy[c]).  The sign of d reflects clockwise vs
//          counterclockwise turns.
// LEFT FOR A RAINY DAY: make this more efficient

#define CALCANGLE(a,b,c,d)  \
    ANGLEDIFF(Arctan2(rgxy[b].y - rgxy[a].y, rgxy[b].x - rgxy[a].x),    \
              Arctan2(rgxy[c].y - rgxy[b].y, rgxy[c].x - rgxy[b].x),    \
              d);

#define CALCANGLEPT(a,b,c,d)  \
    ANGLEDIFF(Arctan2(b.y - a.y, b.x - a.x),    \
              Arctan2(c.y - b.y, c.x - b.x),    \
              d);

#ifdef __cplusplus
};
#endif

#endif	//__INCLUDE_MATHX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\memmgr.h ===
// memmgr.h
//
// This file contains declarations and macros for memory management.  
// Implementation details may change so beware of relying on internal details.


#ifndef __INCLUDE_MEMMGR
#define __INCLUDE_MEMMGR

#ifdef __cplusplus
extern "C" 
{
#endif

void *ExternAlloc(DWORD cb);
void *ExternRealloc(void *pv, DWORD cb);
void  ExternFree(void *pv);

char *Externstrdup( const char *strSource );
wchar_t *Externwcsdup(const wchar_t *wszSource);

#ifdef DBG

typedef struct MEMORY_MANAGER {
    int iCookie;       // Tag to verify pointer to memory manager
    int cAllocMem;     // Amount of memory alloced
    int cAlloc;        // Count of allocs outstanding
    int cAllocMaxMem;  // Max amount of memory ever alloced.
} MEMORY_MANAGER;

extern MEMORY_MANAGER g_theMemoryManager;

#endif

#ifdef __cplusplus
};
#endif

#endif //__INCLUDE_MEMMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\recogp.h ===
/******************************Module*Header*******************************\
* Module Name: recogp.h
*
* Contains all the API for the full functionality of the recognizer for
* training, testing, tuning.
*
* Created: 18-Feb-1996 16:34:00
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef _INC_RECOGP
#define _INC_RECOGP

#include "recog.h"   // Contains just recognizer stuff.

#ifndef _WIN32
#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */
#endif //!_WIN32

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/**************************************************************************\
 *		Old API declerations from recog.h
 *		This stuff should go away as soon as we can convert all to code
 *		to work directly with the new API.
\**************************************************************************/

/* Special Symbol Values potentially returned by HwxGetResults. */

#define SYV_NULL                0x00000000L	// Filler when list is not full

/* Possible High Words of SYVs */

#define SYVHI_FIRST             0        // first valid value
#define SYVHI_SPECIAL           0
#define SYVHI_ANSI              1
#define SYVHI_GESTURE           2
#define SYVHI_KANJI             3	// This is the only one actually used
#define SYVHI_SHAPE             4
#define SYVHI_UNICODE           5
#define SYVHI_VKEY              6
#define SYVHI_LAST              6        // last valid value

/* Used in HwxInput in the STROKEINFO structure */

#define PDK_UP                  0x0000  // PDK_NULL alias
#define PDK_DOWN                0x0001  // pentip switch ON due to contact
#define PDK_TRANSITION          0x0010  // set by GetPenHwData

#define PDK_TIPMASK             0x0001  // mask for testing PDK_DOWN

// General HRC API return values (HRCR_xx):
#define HRCR_COMPLETE           3       // finished recognition
#define HRCR_OK                 1       // success
#define HRCR_ERROR              (-1)    // invalid param or unspecified error
#define HRCR_MEMERR             (-2)    // memory error

// SYV macros:
#define FIsSpecial(syv)         (HIWORD((syv))==SYVHI_SPECIAL)
#define FIsAnsi(syv)            (HIWORD((syv))==SYVHI_ANSI)
#define FIsGesture(syv)         (HIWORD((syv))==SYVHI_GESTURE)
#define FIsKanji(syv)           (HIWORD((syv))==SYVHI_KANJI)
#define FIsShape(syv)           (HIWORD((syv))==SYVHI_SHAPE)
#define FIsUniCode(syv)         (HIWORD((syv))==SYVHI_UNICODE)
#define FIsVKey(syv)            (HIWORD((syv))==SYVHI_VKEY)

#define ChSyvToAnsi(syv)        ((BYTE) (LOBYTE(LOWORD((syv)))))
#define WSyvToKanji(syv)        ((WORD) (LOWORD((syv))))
#define SyvToUnicode(syv)       ((WORD) (LOWORD((syv))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c)     ((LONG)(UINT)(c) | 0x00030000)

typedef LONG                    SYV;    // Symbol Value
typedef SYV FAR*                PSYV;        // ptr to SYV
DECLARE_HANDLE(HINKSET);        // handle to an inkset
typedef HINKSET FAR* LPHINKSET;

typedef struct tagSTROKEINFO    // 1.0 stroke header
{
    UINT cPnt;                   // count of points in stroke
    UINT cbPnts;                 // size of stroke in bytes
    UINT wPdk;                   // state of stroke
    DWORD dwTick;                // time at beginning of stroke
} STROKEINFO, *PSTROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagBOXRESULTS    // 2.0
{
    UINT indxBox;		// zero-based index in guide structure where char was written
    HINKSET hinksetBox;	// unused
	SYV rgSyv[1];		// variable-sized array of characters returned
} BOXRESULTS, *PBOXRESULTS, FAR *LPBOXRESULTS;

/* Passed in to HwxSetGuide.  Specifies where the boxes are on the screen */

typedef struct tagGUIDE         // 1.0 guide structure
{
	int xOrigin;                 // left edge of first box (screen coord)
	int yOrigin;                 // top edge of first box (screen coord)
	int cxBox;                   // width of a single box
	int cyBox;                   // height of a single box
	int cxBase;                  // in-box x-margin to guideline
	int cyBase;                  // in-box y offset from top to baseline
	int cHorzBox;                // count of boxed columns
	int cVertBox;                // count of boxed rows
	int cyMid;                   // 0 or distance from baseline to midline
} GUIDE, *PGUIDE, FAR *LPGUIDE;

//////////////////
//	Mappings to deal with names that changed during cleanup.
//////////////////

#define	ALC_COMMON_KANJI	ALC_KANJI_COMMON
#define	ALC_RARE_KANJI		ALC_KANJI_RARE
#define	ALC_COMMON_HANGUL	ALC_HANGUL_COMMON
#define	ALC_RARE_HANGUL		ALC_HANGUL_RARE


/**************************************************************************\
 *		END Old API declerations from recog.h
\**************************************************************************/

// Gesture sets for EnableGestureSetHRC (bit flags):
#define GST_SEL                 0x00000001L   // sel & lasso
#define GST_CLIP                0x00000002L   // cut copy paste
#define GST_WHITE               0x00000004L   // sp tab ret
#define GST_KKCONVERT           0x00000008L   // kkconvert
#define GST_EDIT                0x00000010L   // insert correct undo clear
#define GST_SYS                 0x00000017L   // all of the above
#define GST_CIRCLELO            0x00000100L   // lowercase circle
#define GST_CIRCLEUP            0x00000200L   // uppercase circle
#define GST_CIRCLE              0x00000300L   // all circle
#define GST_ALL                 0x00000317L   // all of the above

// SetWordlistCoercionHRC options:
#define SCH_FIRST               0       // first valid value     /* ;Internal */
#define SCH_NONE                0       // turn off coercion
#define SCH_ADVISE              1       // macro is hint only
#define SCH_FORCE               2       // some result is forced from macro
#define SCH_LAST                2       // last value            /* ;Internal */

// SetInternationalHRC options:
#define SSH_FIRST               1       // first valid value        /* ;Internal */
#define SSH_RD                  1       // to right and down (English)
#define SSH_RU                  2       // to right and up
#define SSH_LD                  3       // to left and down (Hebrew)
#define SSH_LU                  4       // to left and up
#define SSH_DL                  5       // down and to the left (Chinese)
#define SSH_DR                  6       // down and to the right (Chinese)
#define SSH_UL                  7       // up and to the left
#define SSH_UR                  8       // up and to the right
#define SSH_LAST                8       // last valid value      /* ;Internal */

#define SIH_ALLANSICHAR         1       // use all ANSI

// ConfigRecognizer and ConfigHREC options:
#define WCR_RECOGNAME           0       // ConfigRecognizer 1.0
#define WCR_QUERY               1
#define WCR_CONFIGDIALOG        2
#define WCR_DEFAULT             3
#define WCR_RCCHANGE            4
#define WCR_VERSION             5
#define WCR_TRAIN               6
#define WCR_TRAINSAVE           7
#define WCR_TRAINMAX            8
#define WCR_TRAINDIRTY          9
#define WCR_TRAINCUSTOM         10
#define WCR_QUERYLANGUAGE       11
#define WCR_USERCHANGE          12

// Misc RC Definitions:
#define CL_NULL                 0
#define CL_MINIMUM              1       // minimum confidence level
#define CL_MAXIMUM              100     // max (require perfect recog)
#define cwRcReservedMax         8       // rc.rgwReserved[cwRcReservedMax]
#define ENUM_MINIMUM            1
#define ENUM_MAXIMUM            4096

#define HKP_SETHOOK             0       // SetRecogHook()
#define HKP_UNHOOK              0xFFFF

#define HWR_FIRST               0       // first valid value     /* ;Internal */
#define HWR_RESULTS             0
#define HWR_APPWIDE             1
#define HWR_LAST                1       // last valid value      /* ;Internal */

#define iSycNull                (-1)
#define MAXDICTIONARIES         16      // rc.rglpdf[MAXDICTIONARIES]
#define wPntAll                 (UINT)0xFFFF
#define cbRcLanguageMax         44      // rc.lpLanguage[cbRcLanguageMax]
#define cbRcUserMax             32      // rc.lpUser[cbRcUserMax]
#define cbRcrgbfAlcMax          32      // rc.rgbfAlc[cbRcrgbfAlcMax]
#define RC_WDEFAULT             0xffff
#define RC_LDEFAULT             0xffffffffL
#define RC_WDEFAULTFLAGS        0x8000
#define RC_LDEFAULTFLAGS        0x80000000L

// ALC macros:

#define MpAlcB(lprc,i)          ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)                ((BYTE)(1 << ((i) & 7)))
#define SetAlcBitAnsi(lprc,i)   do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i) do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)   ((MpAlcB(lprc,i) & MpIbf(i)) != 0)

// Intervals:

typedef struct tagABSTIME       // 2.0 absolute date/time
{
	DWORD sec;      // number of seconds since 1/1/1970, ret by CRTlib time() fn
	UINT ms;        // additional offset in ms, 0..999
} ABSTIME, *PABSTIME, FAR *LPABSTIME;

// difference of two absolute times (at2 > at1 for positive result):
#define dwDiffAT(at1, at2)\
    (1000L*((at2).sec - (at1).sec) - (DWORD)(at1).ms + (DWORD)(at2).ms)

// comparison of two absolute times (TRUE if at1 < at2):
#define FLTAbsTime(at1, at2)\
    ((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms < (at2).ms))

#define FLTEAbsTime(at1, at2)\
    ((at1).sec < (at2).sec || ((at1).sec == (at2).sec && (at1).ms <= (at2).ms))

#define FEQAbsTime(at1, at2)\
    ((at1).sec == (at2).sec && (at1).ms == (at2).ms)

// test if abstime is within an interval:
#define FAbsTimeInInterval(at, lpi)\
    (FLTEAbsTime((lpi)->atBegin, at) && FLTEAbsTime(at, (lpi)->atEnd))

// test if interval (lpiT) is within an another interval (lpiS):
#define FIntervalInInterval(lpiT, lpiS)\
    (FLTEAbsTime((lpiS)->atBegin, (lpiT)->atBegin)\
    && FLTEAbsTime((lpiT)->atEnd, (lpiS)->atEnd))

// test if interval (lpiT) intersects another interval (lpiS):
#define FIntervalXInterval(lpiT, lpiS)\
    (!(FLTAbsTime((lpiT)->atEnd, (lpiS)->atBegin)\
    || FLTAbsTime((lpiS)->atEnd, (lpiT)->atBegin)))

// duration of an LPINTERVAL in ms:
#define dwDurInterval(lpi)  dwDiffAT((lpi)->atBegin, (lpi)->atEnd)

// fill a pointer to an ABSTIME structure from a count of seconds and ms:
#define MakeAbsTime(lpat, isec, ims) do {\
    (lpat)->sec = isec + ((ims) / 1000);\
    (lpat)->ms = (ims) % 1000;\
    } while (0)

// This should not be used any more.
/*
#define SYV_UNKNOWN             0x00000001L
#define SYV_EMPTY               0x00000003L	// no longer used
#define SYV_BEGINOR             0x00000010L	// no longer used
#define SYV_ENDOR               0x00000011L	// no longer used
#define SYV_OR                  0x00000012L	// no longer used
#define SYV_SOFTNEWLINE         0x00000020L	// no longer used
#define SYV_SPACENULL           0x00010000L // no longer used
*/

// SYV values for gestures:
/* Not used any more
#define SYV_SELECTFIRST         0x0002FFC0L   // . means circle in following
#define SYV_LASSO               0x0002FFC1L   // lasso o-tap
#define SYV_SELECTLEFT          0x0002FFC2L   // no glyph
#define SYV_SELECTRIGHT         0x0002FFC3L   // no glyph
#define SYV_SELECTLAST          0x0002FFCFL   // 16 SYVs reserved for selection

#define SYV_CLEARCHAR           0x0002FFD2L   // d.
#define SYV_HELP                0x0002FFD3L   // no glyph
#define SYV_KKCONVERT           0x0002FFD4L   // k.
#define SYV_CLEAR               0x0002FFD5L   // d.
#define SYV_INSERT              0x0002FFD6L   // ^.
#define SYV_CONTEXT             0x0002FFD7L   // m.
#define SYV_EXTENDSELECT        0x0002FFD8L   // no glyph
#define SYV_UNDO                0x0002FFD9L   // u.
#define SYV_COPY                0x0002FFDAL   // c.
#define SYV_CUT                 0x0002FFDBL   // x.
#define SYV_PASTE               0x0002FFDCL   // p.
#define SYV_CLEARWORD           0x0002FFDDL   // no glyph
#define SYV_USER                0x0002FFDEL   // reserved
#define SYV_CORRECT             0x0002FFDFL   // check.

#define SYV_BACKSPACE           0x00020008L   // no glyph
#define SYV_TAB                 0x00020009L   // t.
#define SYV_RETURN              0x0002000DL   // n.
#define SYV_SPACE               0x00020020L   // s.
*/

// Application specific gestures, Circle a-z and Circle A-Z:
/* Not used any more
#define SYV_APPGESTUREMASK      0x00020000L
#define SYV_CIRCLEUPA           0x000224B6L   // map into Unicode space
#define SYV_CIRCLEUPZ           0x000224CFL   //  for circled letters
#define SYV_CIRCLELOA           0x000224D0L
#define SYV_CIRCLELOZ           0x000224E9L
*/

// SYV definitions for shapes:
/* Not used any more
#define SYV_SHAPELINE           0x00040001L
#define SYV_SHAPEELLIPSE        0x00040002L
#define SYV_SHAPERECT           0x00040003L
#define SYV_SHAPEMIN            SYV_SHAPELINE // alias
#define SYV_SHAPEMAX            SYV_SHAPERECT // alias
*/

/* Not used any more
#define FIsSelectGesture(syv)   \
   ((syv) >= SYVSELECTFIRST && (syv) <= SYVSELECTLAST)

#define FIsStdGesture(syv)      \
   (                            \
   FIsSelectGesture(syv)        \
   || (syv)==SYV_CLEAR          \
   || (syv)==SYV_HELP           \
   || (syv)==SYV_EXTENDSELECT   \
   || (syv)==SYV_UNDO           \
   || (syv)==SYV_COPY           \
   || (syv)==SYV_CUT            \
   || (syv)==SYV_PASTE          \
   || (syv)==SYV_CLEARWORD      \
   || (syv)==SYV_KKCONVERT      \
   || (syv)==SYV_USER           \
   || (syv)==SYV_CORRECT        \
   )

#define FIsAnsiGesture(syv) \
   (                            \
   (syv) == SYV_BACKSPACE       \
   || (syv) == SYV_TAB          \
   || (syv) == SYV_RETURN       \
   || (syv) == SYV_SPACE        \
   )
*/

// GetPenDataAttributes options (GPA_xx):
#define GPA_FIRST               1   // first valid value         /* ;Internal */
#define GPA_MAXLEN              1   // length of longest stroke
#define GPA_POINTS              2   // total number of points
#define GPA_PDTS                3   // PDTS_xx bits
#define GPA_RATE                4   // get sampling rate
#define GPA_RECTBOUND           5   // bounding rect of all points
#define GPA_RECTBOUNDINK        6   // ditto, adj for fat ink
#define GPA_SIZE                7   // size of pendata in bytes
#define GPA_STROKES             8   // total number of strokes
#define GPA_TIME                9   // absolute time at creation of pendata
#define GPA_USER                10  // number of user bytes available: 0, 1, 2, 4
#define GPA_VERSION             11  // version number of pendata
#define GPA_LAST                11  // last valid value          /* ;Internal */
#define GPA_VERCHKINTERNAL      98  // to validate pendata       /* ;Internal */
#define GPA_TICKREFINTERNAL     99  // to get tickref            /* ;Internal */

// GetStrokeAttributes options (GSA_xx):
#define GSA_FIRST               1   // first valid value         /* ;Internal */
#define GSA_PENTIP              1   // get stroke pentip (color, width, nib)
#define GSA_PENTIPCLASS         2   // same as GSA_PENTIP
#define GSA_USER                3   // get stroke user value
#define GSA_USERCLASS           4   // get stroke's class user value
#define GSA_TIME                5   // get time of stroke
#define GSA_SIZE                6   // get size of stroke in points and bytes
#define GSA_SELECT              7   // get selection status of stroke
#define GSA_DOWN                8   // get up/down state of stroke
#define GSA_RECTBOUND           9   // get the bounding rectangle of the stroke
#define GSA_LAST                9   // last valid value          /* ;Internal */

// GetStrokeTableAttributes options (GSA_xx):
#define GSA_PENTIPTABLE         10  // get table-indexed pentip
#define GSA_SIZETABLE           11  // get count of Stroke Class Table entries
#define GSA_USERTABLE           12  // get table-indexed user value

// General PenData API return values (PDR_xx):
#define PDR_NOHIT               3       // hit test failed
#define PDR_HIT                 2       // hit test succeeded
#define PDR_OK                  1       // success
#define PDR_CANCEL              0       // callback cancel or impasse

#define PDR_ERROR               (-1)    // parameter or unspecified error
#define PDR_PNDTERR             (-2)    // bad pendata
#define PDR_VERSIONERR          (-3)    // pendata version error
#define PDR_COMPRESSED          (-4)    // pendata is compressed
#define PDR_STRKINDEXERR        (-5)    // stroke index error
#define PDR_PNTINDEXERR         (-6)    // point index error
#define PDR_MEMERR              (-7)    // memory error
#define PDR_INKSETERR           (-8)    // bad inkset
#define PDR_ABORT               (-9)    // pendata has become invalid, e.g.
#define PDR_NA                  (-10)   // option not available (pw kernel)

#define PDR_USERDATAERR         (-16)   // user data error
#define PDR_SCALINGERR          (-17)   // scale error
#define PDR_TIMESTAMPERR        (-18)   // timestamp error
#define PDR_OEMDATAERR          (-19)   // OEM data error
#define PDR_SCTERR              (-20)   // SCT error (full)

// PenData Scaling (PDTS):
#define PDTS_FIRST              0       // first valid value     /* ;Internal */
#define PDTS_LOMETRIC           0       // 0.01mm
#define PDTS_HIMETRIC           1       // 0.001mm
#define PDTS_HIENGLISH          2       // 0.001"
#define PDTS_STANDARDSCALE      2       // PDTS_HIENGLISH   alias
#define PDTS_DISPLAY            3       // display pixel
#define PDTS_ARBITRARY          4       // app-specific scaling
#define PDTS_SCALEMASK          0x000F  // scaling values in low nibble
#define PDTS_LAST               4       // last valid value      /* ;Internal */
#define PDTS_SCALEMAX           3       // largest scaling type  /* ;Internal */

#define MAXOEMDATAWORDS         6             // rgwOemData[MAXOEMDATAWORDS]

// Handwriting Recognizer:

// GetResultsHRC options:
#define GRH_FIRST               0       // first valid value     /* ;Internal */
#define GRH_ALL                 0       // get all results
#define GRH_GESTURE             1       // get only gesture results
#define GRH_NONGESTURE          2       // get all but gesture results
#define GRH_LAST                2       // last valid value      /* ;Internal */

// system wordlist for AddWordsHWL:
#define HWL_SYSTEM              ((HWL)1)   // magic value means system wordlist

// TrainHREC options:
#define TH_FIRST                0       // first valid value     /* ;Internal */
#define TH_QUERY                0       // query the user if conflict
#define TH_FORCE                1       // ditto no query
#define TH_SUGGEST              2       // abandon training if conflict
#define TH_LAST                 2       // last valid value      /* ;Internal */

// Return values for WCR_TRAIN Function
#define TRAIN_NONE              0x0000
#define TRAIN_DEFAULT           0x0001
#define TRAIN_CUSTOM            0x0002
#define TRAIN_BOTH              (TRAIN_DEFAULT | TRAIN_CUSTOM)

// Control values for TRAINSAVE
#define TRAIN_FIRST             0       // first valid value     /* ;Internal */
#define TRAIN_SAVE              0       // save changes that have been made
#define TRAIN_REVERT            1       // discard changes that have been made
#define TRAIN_RESET             2       // use factory settings
#define TRAIN_LAST              3       // last valid value      /* ;Internal */

// ConfigHREC options:
#define WCR_PWVERSION           13      // ver of PenWin recognizer supports
#define WCR_GETALCPRIORITY      14      // get recognizer's ALC priority
#define WCR_SETALCPRIORITY      15      // set recognizer's ALC priority
#define WCR_GETANSISTATE        16      // get ALLANSICHAR state
#define WCR_SETANSISTATE        17      // set ALLANSICHAR if T
#define WCR_GETHAND             18      // get writing hand
#define WCR_SETHAND             19      // set writing hand
#define WCR_GETDIRECTION        20      // get writing direction
#define WCR_SETDIRECTION        21      // set writing direction
#define WCR_INITRECOGNIZER      22      // init recognizer and set user name
#define WCR_CLOSERECOGNIZER     23      // close recognizer
#define WCR_LAST                23      // last valid std value  /* ;Internal */

#define WCR_PRIVATE             1024

// sub-functions of WCR_USERCHANGE
#define CRUC_FIRST              0       // first valid value     /* ;Internal */
#define CRUC_NOTIFY             0       // user name change
#define CRUC_REMOVE             1       // user name deleted
#define CRUC_LAST               1       // last valid value      /* ;Internal */

// Word List Types:
#define WLT_FIRST               0       // first valid value     /* ;Internal */
#define WLT_STRING              0       // one string
#define WLT_STRINGTABLE         1       // array of strings
#define WLT_EMPTY               2       // empty wordlist
#define WLT_WORDLIST            3       // handle to a wordlist
#define WLT_LAST                3       // last valid value      /* ;Internal */

// RC Direction:
#define RCD_FIRST               0       // first valid value     /* ;Internal */
#define RCD_DEFAULT             0       // def none
#define RCD_LR                  1       // left to right like English
#define RCD_RL                  2       // right to left like Arabic
#define RCD_TB                  3       // top to bottom like Japanese
#define RCD_BT                  4       // bottom to top like some Chinese
#define RCD_LAST                4       // last valid value      /* ;Internal */

// ProcessHRC time constants:
#define PH_DEFAULT              0xFFFFFFFEL   // reasonable time
#define PH_MIN                  0xFFFFFFFDL   // minimum time

//////////////////////////////////////////////////////////////////////////////
/****** Typedefs ************************************************************/

typedef int                     CL;     // Confidence Level
typedef UINT                    HKP;    // Hook Parameter
typedef int                     REC;    // recognition result

// ;Internal comment: DECLARE_HANDLE32 is not defined in 32-bit windows.h
#ifndef DECLARE_HANDLE32
#define DECLARE_HANDLE32(name)\
    struct name##__ { int unused; };\
    typedef const struct name##__ FAR* name
#endif //!DECLARE_HANDLE32

DECLARE_HANDLE(HPENDATA);               // handle to ink
DECLARE_HANDLE(HREC);                   // handle to recognizer
typedef ALC FAR*                LPALC;       // ptr to ALC
typedef SYV FAR*                LPSYV;       // ptr to SYV

// Pointer Types:
typedef LPVOID                  LPOEM;        // alias
typedef HPENDATA FAR*           LPHPENDATA;   // ptr to HPENDATA

// Structures:

#define cbABSTIME32             (4+4)                            /* ;Internal */

typedef struct tagPENDATAHEADER // 1.0 main pen data header
   {
   UINT wVersion;               // pen data format version
   UINT cbSizeUsed;             // size of pendata mem block in bytes
   UINT cStrokes;               // number of strokes (incl up-strokes)
   UINT cPnt;                   // count of all points
   UINT cPntStrokeMax;          // length (in points) of longest stroke
   RECT rectBound;              // bounding rect of all down points
   UINT wPndts;                 // PDTS_xx bits
   int  nInkWidth;              // ink width in pixels
   DWORD rgbInk;                // ink color
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

#define cbPENDATAHEADER32       (4+4+4+4+4+16+4+4+4)             /* ;Internal */

#define cbSTROKEINFO32          (4+4+4+4)                        /* ;Internal */

typedef struct tagOEMPENINFO    // 1.0 OEM pen/tablet hdwe info
   {
   UINT wPdt;                   // pen data type
   UINT wValueMax;              // largest val ret by device
   UINT wDistinct;              // number of distinct readings possible
   }
   OEMPENINFO, FAR *LPOEMPENINFO;
#define cbOEMPENINFO32          (4+4+4)                          /* ;Internal */

typedef struct tagPENINFO       // 1.0 pen/tablet hdwe info
   {
   UINT cxRawWidth;             // max x coord and tablet width in 0.001"
   UINT cyRawHeight;            // ditto y, height
   UINT wDistinctWidth;         // number of distinct x values tablet ret
   UINT wDistinctHeight;        // ditto y
   int nSamplingRate;           // samples / second
   int nSamplingDist;           // min distance to move before generating event
   LONG lPdc;                   // Pen Device Capabilities
   int cPens;                   // number of pens supported
   int cbOemData;               // width of OEM data packet
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS]; // supported OEM data types
   UINT rgwReserved[7];         // for internal use
   UINT fuOEM;                  // which OEM data, timing, PDK_xx to report
   }
   PENINFO, FAR *LPPENINFO;
#define cbPENINFO32 (4+4+4+4+4+4+4+4+4+cbOEMPENINFO32*MAXOEMDATAWORDS+4*7+4) /* ;Internal */

// Handwriting Recognizer:

DECLARE_HANDLE32(HRCRESULT);    // HRC result
DECLARE_HANDLE32(HWL);          // Handwriting wordlist

typedef HRCRESULT               FAR *LPHRCRESULT;
typedef HWL                     FAR *LPHWL;

typedef struct tagINTERVAL      // 2.0 interval structure for inksets
    {
    ABSTIME atBegin;            // begining of 1-ms granularity interval
    ABSTIME atEnd;              // 1 ms past end of interval
    }
    INTERVAL, FAR *LPINTERVAL;

#define cbINTERVAL32            (cbABSTIME32*2)                  /* ;Internal */

#define cbBOXRESULTS32          (4+4+4)                          /* ;Internal */

#define cbGUIDE32               (4+4+4+4+4+4+4+4+4)              /* ;Internal */

#define HRCR_NORESULTS          4       // No possible results to be found
#define HRCR_GESTURE            2       // recognized gesture
#define HRCR_INCOMPLETE         0       // recognizer is processing input
#define HRCR_INVALIDGUIDE       (-3)    // invalid GUIDE struct
#define HRCR_INVALIDPNDT        (-4)    // invalid pendata
#define HRCR_UNSUPPORTED        (-5)    // recognizer does not support feature
#define HRCR_CONFLICT           (-6)    // training conflict
#define HRCR_HOOKED             (-8)    // hookasaurus ate the result

// PenData:
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA);
LPPENDATA WINAPI EndEnumStrokes(HPENDATA);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT);
BOOL      WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR*,
                                  LPVOID FAR*, LPSTROKEINFO);

HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
BOOL      WINAPI DestroyPenData(HPENDATA);
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
int       WINAPI GetPenDataAttributes(HPENDATA, LPVOID, UINT);
BOOL      WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
int       WINAPI GetStrokeAttributes(HPENDATA, UINT, LPVOID, UINT);

// Parameter to GetPrivateRecInfoHRC
#define  PRI_WEIGHT       (WPARAM) 0
#define  PRI_GUIDE        (WPARAM) 1
#define  PRI_GLYPHSYM     (WPARAM) 2
#define  PRI_SIGMA        (WPARAM) 3

// Private version of HwxConfig used to load recognizer databases from files instead
// of resources.
BOOL	WINAPI HwxConfigEx(wchar_t *pLocale, wchar_t *pLocaleDir, wchar_t *pRecogDir);

// Private API for training/tuning
int  WINAPI GetPrivateRecInfoHRC(HRC, WPARAM, LPARAM);
int  WINAPI SetPrivateRecInfoHRC(HRC, WPARAM, LPARAM);

// Handwriting Recognizer:
int       WINAPI AddPenDataHRC(HRC, HPENDATA);
int       WINAPI AddPenInputHRC(HRC, LPPOINT, LPVOID, UINT, LPSTROKEINFO);
int       WINAPI AddWordsHWL(HWL, LPSTR, UINT);
HRC       WINAPI CreateCompatibleHRC(HRC, HREC);
HWL       WINAPI CreateHWL(HREC, LPSTR, UINT, DWORD);
HINKSET   WINAPI CreateInksetHRCRESULT(HRCRESULT, UINT, UINT);
HPENDATA  WINAPI CreatePenDataHRC(HRC);
int       WINAPI DestroyHRC(HRC);
int       WINAPI DestroyHRCRESULT(HRCRESULT);
int       WINAPI DestroyHWL(HWL);
int       WINAPI EnableGestureSetHRC(HRC, SYV, BOOL);
int       WINAPI EnableSystemDictionaryHRC(HRC, BOOL);
int       WINAPI EndPenInputHRC(HRC);
int       WINAPI GetAlphabetHRC(HRC, LPALC, LPBYTE);
int       WINAPI GetAlphabetPriorityHRC(HRC, LPALC, LPBYTE);
int       WINAPI GetAlternateWordsHRCRESULT(HRCRESULT, UINT, UINT,
                                            LPHRCRESULT, UINT);
int       WINAPI GetBoxMappingHRCRESULT(HRCRESULT, UINT, UINT, UINT FAR*);
int       WINAPI GetBoxResultsHRC(HRC, UINT, UINT, UINT, LPBOXRESULTS, BOOL);
int       WINAPI GetGuideHRC(HRC, LPGUIDE, UINT FAR*);
int       WINAPI GetHotspotsHRCRESULT(HRCRESULT, UINT, LPPOINT, UINT);
HREC      WINAPI GetHRECFromHRC(HRC);
int       WINAPI GetInternationalHRC(HRC, UINT FAR*, LPSTR, UINT FAR*,
                                     UINT FAR*);
int       WINAPI GetMaxResultsHRC(HRC);
int       WINAPI GetResultsHRC(HRC, UINT, LPHRCRESULT, UINT);
int       WINAPI GetSymbolCountHRCRESULT(HRCRESULT);
int       WINAPI GetSymbolsHRCRESULT(HRCRESULT, UINT, LPSYV, UINT);
int       WINAPI GetWordlistHRC(HRC, LPHWL);
int       WINAPI GetWordlistCoercionHRC(HRC);
int       WINAPI ReadHWL(HWL, HFILE);
int       WINAPI SetAlphabetHRC(HRC, ALC, LPBYTE);
int       WINAPI SetAlphabetPriorityHRC(HRC, ALC, LPBYTE);
int		  WINAPI SetAbortHRC(HRC, DWORD *);
int       WINAPI SetBoxAlphabetHRC(HRC, LPALC, UINT);
int       WINAPI SetGuideHRC(HRC, LPGUIDE, UINT);
int       WINAPI SetInternationalHRC(HRC, UINT, LPCSTR, UINT, UINT);
int       WINAPI SetMaxResultsHRC(HRC, UINT);
int		  WINAPI SetPartialHRC(HRC, DWORD);
int       WINAPI SetWordlistCoercionHRC(HRC, UINT);
int       WINAPI SetWordlistHRC(HRC, HWL);
int       WINAPI TrainHREC(HREC, LPSYV, UINT, HPENDATA, UINT);
int       WINAPI WriteHWL(HWL, HFILE);
int       WINAPI ProcessHRC(HRC, DWORD);

HREC      WINAPI InstallRecognizer(LPSTR);

// Inksets:
BOOL      WINAPI AddInksetInterval(HINKSET, LPINTERVAL);
HINKSET   WINAPI CreateInkset(UINT);
BOOL      WINAPI DestroyInkset(HINKSET);
int       WINAPI GetInksetInterval(HINKSET, UINT, LPINTERVAL);
int       WINAPI GetInksetIntervalCount(HINKSET);

// Symbol Values:
int       WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
BOOL      WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);

UINT      WINAPI ConfigRecognizer(UINT, WPARAM, LPARAM);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#ifndef _WIN32
#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */
#endif //!_WIN32

#endif /* #define _INC_RECOGP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\locale.h ===
/******************************************************************************\
 * FILE: locale.h
 *
 * Public structures and functions library that are used to access the 
 * localization information.
 *
 * There are two major pieces of this.  The first deals with stuff available
 * to the runtime of shipped products (e.g. the recognizer).  The second is
 * stuff needed at train time that we do not want in the shipped product
 * (usually for size reasons).
\******************************************************************************/

#if !defined (__HWX_LOCALE__)

#define __HWX_LOCALE__

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************\
 *	Stuff for the product runtime, also used by all the other code.
\******************************************************************************/

//
// Constants
//

// Masks to get at baseline and height values from a BLINE_HEIGHT value.
#define LOCBH_BASE_MASK		((BYTE)0x0F)
#define LOCBH_HEIGHT_MASK	((BYTE)0xF0)

//
// Structures and types
//

// define the types needed for ClassBigrams and BaseLine Height
typedef unsigned char	CODEPOINT_CLASS;
typedef unsigned char	BLINE_HEIGHT;

// CodePointClass Header describes:
// - how the CodePointClass codes for a certain subrange are stored (Array vs ExceptionList)
// - The size of the Array/(Exception Lists)
// - Offset to the Array/the 1st Exception List
typedef struct tagCODEPOINT_CLASS_HEADER
{
	WORD	iFlags;			// Bit15 indicates the format of the data 
							// 0:Array (Full array is supplied)
							// 1:Exception (A default and exception list(s) are supplied
							// if Bit0=0
							// Bits 0-14 Number of Array Entries (up 32768)
							// if Bit15=1
							// Bits 8-14 Number of Exceptions
							// Bits 1-8	 Default BigramClass code
							
	WORD	iOffset;		// Offset in bytes in the ArrayBuffer (Bit15=0) or ExceptionsBuffer (Bit0=1)
}CODEPOINT_CLASS_HEADER;

// BLHeight Header describes:
// - how the BLHeight codes for a certain subrange are stored (Array vs ExceptionList)
// - The size of the Array/(Exception Lists)
// - Offset to the Array/the 1st Exception List
typedef struct tagBLINE_HEIGHT_HEADER
{
	WORD	iFlags;			// Bit15 indicates the format of the data 
							// 0:Array (Full array is supplied)
							// 1:Exception (A default and exception list(s) are supplied
							// if Bit15=0
							// Bits 1-14 Number of Array Entries (up 32768)
							// if Bit15=1
							// Bits 8-14 Number of exceptions
							// Bits 1-8 Default BLHeight code
	WORD	iOffset;		// Offset in bytes in the ArrayBuffer (Bit15=0) or ExceptionsBuffer (Bit0=1)
}BLINE_HEIGHT_HEADER;

// CodePointClass Exception describes the Class Bigram exception structure 
typedef struct tagCODEPOINT_CLASS_EXCEPTION
{
	CODEPOINT_CLASS	clCode;			// The CodePointClass Code for this list
	BYTE			cNumEntries;	// Number of entries in the exception list
	wchar_t			wDenseCode[1];		// an Array of CodePoint Indices in the subrange
}CODEPOINT_CLASS_EXCEPTION;

// BLineHgt Exception describes the Class Bigram exception structure 
typedef struct tagBLINE_HEIGHT_EXCEPTION
{
	BLINE_HEIGHT	blhCode;		// The BLineHgt Code for this list
	BYTE			cNumEntries;	// Number of entries in the exception list
	wchar_t			wDenseCode[1];		// an Array of CodePoint Indices in the subrange
}BLINE_HEIGHT_EXCEPTION;
	
// Range specification for ALC subranges of Dense coding of the character set.
// Giving both the first code and the number of codes is redundent, but we
// would waste the space anyway to keep DWORD alignment, and it makes some
// coding easier.  Note that the ALC bits for the first range are zero because
// you need to use the ALC table for individual ALC values for each code in
// the range.
typedef struct tagLOCRUN_ALC_SUBRANGE {
	WORD					iFirstCode;		// First code in range.
	WORD					cCodesInRange;	// Number of codes in this range.
	ALC						alcRange;		// The ALC bits for all code points in this range.
	CODEPOINT_CLASS_HEADER	clHeader;		// Class Bigram Header
	BLINE_HEIGHT_HEADER		blhHeader;		// BaseLine Header
} LOCRUN_ALC_SUBRANGE;

// Defines to make it easy to have pointers to folding sets.
#define LOCRUN_FOLD_MAX_ALTERNATES	8		// Max alternates in the folding table
typedef	WORD	LOCRUN_FOLDING_SET[LOCRUN_FOLD_MAX_ALTERNATES];

// Structure giving access to a loaded copy of the localization runtime tables.
// NOTE: The arrays pointed to by pClassExcpts and pBLineHgtExcpts contain 
// word data that is only byte aligned, and can cause data misalignment faults
// in CE.  Search for the string "UNALIGNED" in locrun.c to see how this is worked
// around.
typedef struct tagLOCRUN_INFO {
	DWORD				adwSignature [3];	// A signature computed from the loc info
											// DWORD0:	Date/Time Stamp (time_t)
											// DWORD1:	XORING ALC values for all CPs
											// DWORD2	HIWORD: XORING ALL Valid CPs
											//			LOWORD: XORING ALL BasLn,Hgt Info
	WORD				cCodePoints;		// Number of supported code points.
	BYTE				cALCSubranges;		// Number of subranges defined
											// across Dense coding
	BYTE				cFoldingSets;		// Number of folding sets defined

	WORD				cClassesArraySize;	// size in bytes of classes arrays
	WORD				cClassesExcptSize;	// size in bytes of classes exception lists

	WORD				cBLineHgtArraySize;	// size in bytes of BLineHgt arrays
	WORD				cBLineHgtExcptSize;	// size in bytes of BLineHgt exception lists

	wchar_t				*pDense2Unicode;	// Map from Dense coding to Unicode.
	LOCRUN_ALC_SUBRANGE	*pALCSubranges;		// Subranges of Dense coding, and
											// their ALC values.
	ALC					*pSubrange0ALC;		// The ALC values for the first
											// subrange
	LOCRUN_FOLDING_SET	*pFoldingSets;		// List of folding sets
	ALC					*pFoldingSetsALC;	// The merged ALCs for the folded
											// characters.

	CODEPOINT_CLASS		*pClasses;			// Array of Codepoint classes for all subranges
	BYTE				*pClassExcpts;		// classes Exception lists for all subranges

	BLINE_HEIGHT		*pBLineHgtCodes;	// Array of BLineHgt codes for all subranges
	BYTE				*pBLineHgtExcpts;	// BLineHgt Exception lists for all subranges

	void				*pLoadInfo1;		// Handles needed to unload the data
	void				*pLoadInfo2;
	void				*pLoadInfo3;
} LOCRUN_INFO;

//
// Macros to access the runtime localization information
//

// Is value a valid Dense code
#define	LocRunIsDenseCode(pLocRunInfo,dch)		\
	((dch) < (pLocRunInfo)->cCodePoints)

// Is value a valid folded code.  Folded codes are placed directly after
// the Dense codes.
#define	LocRunIsFoldedCode(pLocRunInfo,dch)		(							\
	((pLocRunInfo)->cCodePoints <= (dch)) &&  								\
	((dch) < ((pLocRunInfo)->cCodePoints + (pLocRunInfo)->cFoldingSets))	\
)

// Convert Dense code to Unicode.
#define	LocRunDense2Unicode(pLocRunInfo,dch)	\
	((pLocRunInfo)->pDense2Unicode[dch])

// Get pointer to folding set for a folded code.
#define	LocRunFolded2FoldingSet(pLocRunInfo,fch)	(							\
	(wchar_t *)(pLocRunInfo)->pFoldingSets[(fch) - (pLocRunInfo)->cCodePoints]	\
)

// Convert Folded code to Dense code.
#define	LocRunFolded2Dense(pLocRunInfo,fch)	(							\
	(pLocRunInfo)->pFoldingSets[(fch) - (pLocRunInfo)->cCodePoints][0]	\
)

// Get ALC from either dense or folded code.
#define	LocRun2ALC(pLocRunInfo, dch)	(		\
	LocRunIsFoldedCode(pLocRunInfo,dch)			\
		? LocRunFolded2ALC(pLocRunInfo, dch)	\
		: LocRunDense2ALC(pLocRunInfo, dch)		\
)

// Value returned when GetDensecodeClass is unable to determine the class
#define	LOC_RUN_NO_CLASS						0xFE

// Value returned when LocRunDense2BLineHgt is unable to determine the BlineHgt
#define	LOC_RUN_NO_BLINEHGT						0xFE

// Value returned by LocRunUnicode2Dense and LocTrainUnicode2Dense when there is
// no dense code for the supplied Unicode character.
// JRB: Should really rename this LOC_RUN_NO_DENSE_CODE
#define	LOC_TRAIN_NO_DENSE_CODE		L'\xFFFF'

//
//Functions to access the runtime localization information
//

// Load runtime localization information from a file.
BOOL	LocRunLoadFile(LOCRUN_INFO *pLocRunInfo, wchar_t *pPath);

// Unload runtime localization information that was loaded from a file.
BOOL	LocRunUnloadFile(LOCRUN_INFO *pLocRunInfo);

// Load runtime localization information from a resource.
// Note, don't need to unload resources.
BOOL	LocRunLoadRes(
	LOCRUN_INFO	*pLocRunInfo,
	HINSTANCE	hInst,
	int			nResID,
	int			nType
);

// Load runtime localization information from an image already loaded into
// memory.
BOOL	LocRunLoadPointer(LOCRUN_INFO *pLocRunInfo, void *pData);

// Write a properly formated binary file containing the runtime localization
// information.
#ifndef HWX_PRODUCT		// Hide this when compiling product 
BOOL	LocRunWriteFile(LOCRUN_INFO *pLocRunInfo, FILE *pFile);
#endif

// Get ALC value for a Dense coded character
ALC		LocRunDense2ALC(LOCRUN_INFO *pLocRunInfo, wchar_t dch);

// Get ALC value for a folded character
ALC		LocRunFolded2ALC(LOCRUN_INFO *pLocRunInfo, wchar_t dch);

// Convert Dense code to Folded code.
wchar_t	LocRunDense2Folded(LOCRUN_INFO *pLocRunInfo, wchar_t dch);

// Convert from Dense coding to Unicode.  If no dense code for the Unicode
// value, 0xFFFF is returned.
// WARNING: this is expensive.  For code outside the runtime recognizer, use
// the LocTranUnicode2Dense function.  For the recognizer, you have to use
// this, but use it as little as possable.
wchar_t	LocRunUnicode2Dense(LOCRUN_INFO *pLocRunInfo, wchar_t wch);

// Get the BLineHgt code for a specific dense code
BLINE_HEIGHT 
LocRunDense2BLineHgt(LOCRUN_INFO *pLocRunInfo, wchar_t dch);

// Convert a dense coded character to its character class.
CODEPOINT_CLASS 
LocRunDensecode2Class(LOCRUN_INFO *pLocRunInfo, wchar_t dch);

/******************************************************************************\
 *	Stuff for the training programs, not to be used by product code.
\******************************************************************************/

#ifndef HWX_PRODUCT		// Hide this when compiling product 

//
// Structures and types
//

// Information on min and max stroke counts for a code point.
typedef struct tagSTROKE_COUNT_INFO {
	BYTE		minStrokes;			// Min legal strokes for char.
	BYTE		maxStrokes;			// Max legal strokes for char.
} STROKE_COUNT_INFO;

// Structure giving access to a loaded copy of the localization training time
// tables.
typedef struct tagLOCTRAIN_INFO {
	// Convsion from unicode to dense.
	WORD				cCodePoints;		// Number of supported code points.
	wchar_t				*pUnicode2Dense;	// Map from Unicode to Dense coding.

	// Stroke count info per character.  Indexed by dense code.
	WORD				cStrokeCountInfo;	// Number of entries array.
	STROKE_COUNT_INFO	*pStrokeCountInfo;	// Stoke count info array.
	
	void				*pLoadInfo1;		// Handles needed to unload the
	void				*pLoadInfo2;		// data.
	void				*pLoadInfo3;
} LOCTRAIN_INFO;


//
// Constants
//

// Values to set min and max stroke counts to when they are not known.
#define	LOC_TRAIN_UNKNOWN_MIN_STROKE_COUNT		0x00
#define	LOC_TRAIN_UNKNOWN_MAX_STROKE_COUNT		0xFF

//
// Macros to access the train time localization information
//

// Convert Unicode to Dense code.
#define	LocTrainUnicode2Dense(pLocTrainInfo,wch)	\
	((pLocTrainInfo)->pUnicode2Dense[wch])

//
//Functions to access the train time localization information
//

// Load train time localization information from a file.
BOOL	LocTrainLoadFile(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, wchar_t *pPath);

// Unload train time localization information that was loaded from a file.
BOOL	LocTrainUnloadFile(LOCTRAIN_INFO *pLocTrainInfo);

// Load train time localization information from a resource.
BOOL	LocTrainLoadRes(
	LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, HINSTANCE hInst, int nResID, int nType
);

// Load train time localization information from an image already loaded into
// memory.
BOOL	LocTrainLoadPointer(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, void *pData);

// Write a properly formated binary file containing the train time
// localization information.
BOOL	LocTrainWriteFile(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, FILE *pFile);

// Check if valid stroke count for character.  Takes dense code.
BOOL	LocTrainValidStrokeCount(
	LOCTRAIN_INFO *pLocTrainInfo, wchar_t dch, int cStrokes
);

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\math16.h ===
#ifndef __MATH16_H__
#define __MATH16_H__

#ifdef __cplusplus
extern "C" {
#endif 

// Type for fixed point 16.16 numbers.  I used LONG as the base type because it is the only
// type I could find guarantied to stay a 32 bit signed number, even when we convert to
// 64 bit machines.
typedef LONG	FIXED16_16;

// Constants for dealing with shifting the bits around in the 16.16 format.
#define	SHFTBITS    16

#define LOWMASK	    ((1 << SHFTBITS)-1)
#define HGHMASK	    (~LOWMASK)
#define LOWBITS(x)  ((x) & LOWMASK)
#define HGHBITS(x)  ((x) & HGHMASK)
#define	LSHFT(x)    ((x) << SHFTBITS)
#define RSHFT(x)    ((x) >> SHFTBITS)

// Useful constants in 16.16 form
#define	PI				(3373259427 >> (30-SHFTBITS))
#define TWOPI			(PI << 1)
#define PIOVER2			(PI >> 1)
#define	ONE_POINT_ZERO	0x00010000		// (1 << SHFTBITS), but prefast complains when cast to double

// How many bits needed to store a number.
#define Need(dw) (dw & 0xFF000000 ? 32 : (dw & 0x00FF0000 ? 24 : (dw & 0x0000FF00 ? 16 : 8)))

// Convert number to 16.16 form.
#define	IntToFix16(val)		(((FIXED16_16)(val)) << SHFTBITS)
#define	FloatToFix16(val)	((FIXED16_16)((val) * (double)ONE_POINT_ZERO))

// Convert 16.16 form to a number.
#define	Fix16ToInt(val)		RSHFT(val)
#define	Fix16ToFloat(val)	((val) / (double)ONE_POINT_ZERO)

// Convert other fixed point forms to a double.
// If the value of N (number of fractional bits) is a constant, this is much faster then shifting 
// and using Fix16ToFloat.  If N is a variable, the 64 bit shift is very expensive.
#define	FixNToFloat(val, n)	((val) / (double)((_int64)1 << n))

// Compute a sigmoid on a 16.16 number.
FIXED16_16	Sigmoid16(FIXED16_16 iX);

// Add two 16.16 numbers.  We just do the macro for clearity and documentation, because
// add just works.
#define	Add16(iX, iY)	(iX + iY)

// The same for subtraction.
#define	Sub16(iX, iY)	(iX - iY)

// Dived two 16.16 numbers.
FIXED16_16	Div16(FIXED16_16 iX, FIXED16_16 iY);

// Multiply two 16.16 numbers.  This uses Greg's multiplication algorithm:
typedef struct {
	unsigned short frac;
	short whole;
} FIX1616, *PFIX1616;

#define Mul16(a,b,c) {	\
	FIXED16_16 i1, i2;									\
	FIX1616 fix1, fix2;									\
	i1=(a);												\
	i2=(b);												\
	fix1 = *(PFIX1616)&i1;								\
	fix2 = *(PFIX1616)&i2;								\
	c = (DWORD)(fix1.frac*fix2.frac) >> 16;				\
	c += fix1.frac*fix2.whole + fix1.whole*fix2.frac;	\
	c += (fix1.whole*fix2.whole) << 16;					\
}

#ifdef __cplusplus
}
#endif

#endif // __MATH16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\results.h ===
#ifdef __cplusplus
extern "C" {
#endif

void ConvertToOldResults (int cAlt, int cBoxRes, PVOID pData);

void ConvertToNewResults (int cAlt, int cBoxRes, HWXRESULTS	*pTo, BOXRESULTS *pFrom);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\recog.h ===
/***************************************************************************\
*
* RECOG.H - Handwriting functions, types, and definitions
*
*	Version 1.1
*
*	Copyright (c) 1992-1998 Microsoft Corp. All rights reserved.
*
\***************************************************************************/

#ifndef _INC_RECOG
#define _INC_RECOG

// @CESYSGEN IF CE_MODULES_HWXUSA || CE_MODULES_HWXJPN

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Suggested sequence for using these APIs:
 *
 *	HwxConfig (once only)
 *		HwxCreate (once per recognition panel)
 *		HwxSetGuide
 *		HwxALCValid
 *		HwxSetContext	(if there is a previous character)
 *			HwxInput	(as the user writes)
 *			HwxProcess  (to process the ink input)
 *			HwxResultsAvailable (find out if new results are available)
 *				HwxGetResults   (every time there are any results available)
 *		HwxEndInput (when user is done inputting ink)
 *		HwxProcess  (to process the ink input)
 *		HwxGetResults (to get the last characters)
 *		HwxDestroy
 */

// The constants below are used with HWXSetAlphabet().  These specify which
// character groupings to recognize.
#define ALC_WHITE			0x00000001	// White space.
#define ALC_LCALPHA			0x00000002	// a..z
#define ALC_UCALPHA			0x00000004	// A..Z
#define ALC_NUMERIC			0x00000008	// 0..9
#define ALC_PUNC			0x00000010	// Standard punc., language dependent.
#define	ALC_NUMERIC_PUNC	0x00000020	// Non digit characters in numbers.
#define ALC_MATH			0x00000040	// %^*()-+={}<>,/.  (??? language dependent ???)
#define ALC_MONETARY		0x00000080	// Punct. in local monetary expressions.
#define	ALC_COMMON_SYMBOLS	0x00000100	// Commonly used symbols from all categories.
#define ALC_OTHER			0x00000200	// Other punctuation not typically used.
#define ALC_ASCII			0x00000400	// 7-bit chars 20..7F
#define ALC_HIRAGANA		0x00000800	// Hiragana (JPN)
#define ALC_KATAKANA		0x00001000	// Katakana (JPN)
#define ALC_KANJI_COMMON	0x00002000	// Common Kanji (JPN, CHS, CHT and KOR)
#define ALC_KANJI_RARE		0x00004000	// Common Kanji (JPN, CHS, CHT and KOR)
#define	ALC_HANGUL_COMMON	0x00008000	// Common Hangul used in Korea.
#define	ALC_HANGUL_RARE		0x00010000	// The rest of the Hangul used in Korea.
#define ALC_UNUSED			0x00F80000	// Reserved for future use.
#define ALC_OEM				0xFF000000	// OEM recognizer-specific.
#define ALC_BOPOMOFO		0x00020000	// Bopomofo used in Taiwan (CHT traditional chinese)
#define ALC_JAMO			0x00040000	// Jamos used in Korea.

// Useful groupings

#define ALC_ALPHA			(ALC_LCALPHA | ALC_UCALPHA)
#define ALC_ALPHANUMERIC	(ALC_ALPHA | ALC_NUMERIC)
#define	ALC_KANA			(ALC_HIRAGANA | ALC_KATAKANA)
#define	ALC_KANJI_ALL		(ALC_KANJI_COMMON | ALC_KANJI_RARE)
#define	ALC_HANGUL_ALL		(ALC_HANGUL_COMMON | ALC_HANGUL_RARE)
#define	ALC_EXTENDED_SYM	(ALC_MATH | ALC_MONETARY | ALC_OTHER)
#define ALC_SYS_MINIMUM		(ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE)
#define ALC_SYS_DEFAULT		(ALC_SYS_MINIMUM | ALC_COMMON_SYMBOLS)

// Standard configurations for various languages.

#define	ALC_USA_COMMON		(ALC_SYS_DEFAULT)
#define	ALC_USA_EXTENDED	(ALC_USA_COMMON | ALC_EXTENDED_SYM)

#define	ALC_JPN_COMMON		(ALC_SYS_DEFAULT | ALC_KANA | ALC_KANJI_COMMON)
#define	ALC_JPN_EXTENDED	(ALC_JPN_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_CHS_COMMON		(ALC_SYS_DEFAULT | ALC_KANJI_COMMON)
#define	ALC_CHS_EXTENDED	(ALC_CHS_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_CHT_COMMON		(ALC_SYS_DEFAULT | ALC_KANJI_COMMON)
#define	ALC_CHT_EXTENDED	(ALC_CHT_COMMON | ALC_EXTENDED_SYM | ALC_KANJI_RARE)

#define	ALC_KOR_COMMON		(ALC_SYS_DEFAULT | ALC_HANGUL_COMMON | ALC_JAMO)
#define	ALC_KOR_EXTENDED	(ALC_KOR_COMMON | ALC_EXTENDED_SYM | ALC_HANGUL_RARE | ALC_KANJI_COMMON | ALC_KANJI_RARE)

// Define ALC mask type.
typedef LONG				ALC;		// Enabled Alphabet
typedef ALC					*PALC;		// ptr to ALC

// Handwriting Recognizer:
DECLARE_HANDLE(HRC);			// Handwriting Recognition Context

typedef HRC			*PHRC;

// Filled in by HwxGetResults().
// The rgChar array is actually a variable sized array of alternate results.  The number of
// alternates is passed into HwxGetResults().
typedef struct tagHWXRESULTS {
    USHORT	indxBox;		// zero-based index into guide structure where char was written
	WCHAR	rgChar[1];		// variable-sized array of characters returned
} HWXRESULTS, *PHWXRESULTS;

// Passed in to HwxSetGuide().  Specifies where the boxes are on the screen.
// All positions are in scaled screen coordinates.  You should do the scaling so
// that cyWriting is around 1000.  To avoid speed and rounding problems you should
// use an integral multiple of your actual size.
// JRB: FIXME: Check description above is correct!!!
// NOTE: the current code requires that the writing area be centered.  E.g. You
// need to set cxBox, cxOffset and cxWriting such that:
//		cxBox == 2 * cxOffset + cxWriting
typedef struct tagHWXGUIDE {
	// Number of input boxes in each direction.
	UINT	cHorzBox;
	UINT	cVertBox;

	// Upper left corner of input area.
	INT		xOrigin;
	INT		yOrigin;

	// Width and height of a single box.
	UINT	cxBox;
	UINT	cyBox;

	// Offset within a box to the upper left of the writing area.
	UINT	cxOffset;
	UINT	cyOffset;

	// Width and height of writing area.
	UINT	cxWriting;
	UINT	cyWriting;

	// Baseline and midline information for western alphabets.  They are measured from
	// the top of the writing area.  These fields are not used and must be set to zero
	// for the Far East languages (Japanese, Chinese, and Korean).  They must be set to
	// the correct values for English or any other language based on Latin letters.
	UINT	cyMid;
	UINT	cyBase;

	// Writing direction
	UINT	nDir;
} HWXGUIDE, *PHWXGUIDE;

// The following are the currently planned handwriting directions.  Note that a given recognizer
// may not support the requested direction, if this is the case, HwxSetGuide will return an error.

#define	HWX_HORIZONTAL		0
#define	HWX_BIDIRECTIONAL	1
#define	HWX_VERTICAL		2

// For FE recognizers we would like to be able to enter partial characters and have the recognizer
// attempt to 'fill in the gaps'.  This is most useful for difficult or rare characters with many
// strokes.  The following values can be passed to HwxSetPartial

#define	HWX_PARTIAL_ALL			0			// The whole character must be written (default)
#define	HWX_PARTIAL_ORDER		1			// The stroke order does matter 
#define	HWX_PARTIAL_FREE		2			// The stroke order doesn't matter

// Called once to initialize DLL.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxConfig();

// Called to create an HRC before any ink is collected. You can pass in NULL
// for the parameter, but if you pass in an old HRC, it copies the old settings (such
// as alphabet, guide structure, previous context, etc.)
// JRB: FIXME: Make above description of what's copied clearer.
// On failure, use GetLastError() to identify the cause of the error.
HRC		WINAPI HwxCreate(HRC);

// Called to destroy an HRC after recognition is complete.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxDestroy(HRC);

// Tells the HRC where the boxes on the screen are.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetGuide(HRC, HWXGUIDE *);

// Limits the set of characters the recognizer can return.  (See ALC values above.)
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxALCValid(HRC, ALC);

// Reorders the characters the recognizer returns so that selected characters
// appear at the top of the list.  (See ALC values above.)
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxALCPriority(HRC, ALC);

// Sets parameter for partial recognition.
// On failure, use GetLastError() to identify the cause of the error.
// JRB: FIXME: Need to define the legal values for second argument.
BOOL	WINAPI HwxSetPartial(HRC, UINT);

// Sets abort address.  If the number of strokes currently doesn't match the value
// written at the address, the current recognition is halted.  This only works for
// HwxSetPartial modes HWX_PARTIAL_FRONT and HWX_PARTIAL_ANY
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetAbort(HRC, UINT *);

// Adds ink to the HRC.
// Takes the HRC, the array of points, the count of points, and 
// the time stamp of the first mouse event in the stroke.  The
// time stamp should be taken directly from the MSG structure
// for the mouse down event.  The points should be scaled to
// match the guide structure.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxInput(HRC, POINT *, UINT, DWORD);

// Called after last ink is added.  You cannot add anymore ink
// to the HRC after this has been called.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxEndInput(HRC);

// Recognizes as much ink as it can.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxProcess(HRC);

// Retrieves the results from an HRC. This may be called repeatedly. This allows you
// to get results for several characters at a time. The return value is the number of
// characters actually returned.  The results for those characters are put in the
// rgBoxResults buffer that was passed in.
// Returns -1 on error.
// On failure, use GetLastError() to identify the cause of the error.
INT		WINAPI HwxGetResults(
	HRC			hrc,			// HRC containing results
	UINT		cAlt,			// number of alternates
	UINT		iFirst,			// index of first character to return
	UINT		cBoxRes,		// number of characters to return
	HWXRESULTS	*rgBoxResults	// array of cBoxRes ranked lists
);

// Tells the HRC what the previous character was for context purposes.
// On failure, use GetLastError() to identify the cause of the error.
BOOL	WINAPI HwxSetContext(HRC, WCHAR);

// Tells you how many results can be retrieved from HwxGetResults.
// Returns -1 on error.
// On failure, use GetLastError() to identify the cause of the error.
INT		WINAPI HwxResultsAvailable(HRC);

#ifdef __cplusplus
}
#endif // __cplusplus

// @CESYSGEN ENDIF
 
#endif // #define _INC_RECOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\util.h ===
#ifndef	__INCLUDE_UTIL
#define	__INCLUDE_UTIL

#ifdef	__cplusplus
extern "C" {
#endif

/* Attempt to fopen pszFileName in mode pszMode. If that fails, try it in the subdirectory
above the current one.  Continue up the directory tree until you reach the top.  Return
NULL only if ALL attempts fail.  In case of success, return the actual path to the
opened file in pszFullPath.  cchFullPathMax is the size of the buffer pszFullPath
points to. */

FILE *
UtilOpen(
	TCHAR *pszFileName,		// File to open 
	TCHAR *pszMode, 		// stdio mode string
	TCHAR *pszFullPath,		// Out: path to file opened, if any
	int    cchFullPathMax	// size in bytes of pszFullPath
);

/* Same as UtilOpen except current directory is not used.  Instead, search starts in  
directory named by pszPath */

FILE *
UtilOpenPath(
	TCHAR *pszPath,			// Path to start looking for file
	TCHAR *pszFileName,		// File to open 
	TCHAR *pszMode, 		// stdio mode string
	TCHAR *pszFullPath,		// Out: path to file opened, if any
	int    cchFullPathMax	// size in bytes of pszFullPath
);

#ifdef	__cplusplus
};
#endif

#endif	//__INCLUDE_UTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\altlist.c ===
// altlist.c

#include "common.h"

// Sort the alternate list.
// We do a bubble sort.  The list is small and we can't use qsort because the data is stored in
// two parallel arrays.
void SortAltList(ALT_LIST *pAltList)
{
	int		pos1, pos2;
	int		limit1, limit2;
	FLOAT	* const peScore		= pAltList->aeScore;
	wchar_t	* const pwchList	= pAltList->awchList;

	limit2	= pAltList->cAlt;
	limit1	= limit2 - 1;
	for (pos1 = 0; pos1 < limit1; ++pos1) {
		for (pos2 = pos1 + 1; pos2 < limit2; ++pos2) {
			// Are elements pos1 and pos2 out of order?
			if (peScore[pos1] < peScore[pos2]) {
				FLOAT			eTemp;
				wchar_t			wchTemp;

				// Swap scores and swap characters.
				eTemp			= peScore[pos1];
				peScore[pos1]	= peScore[pos2];
				peScore[pos2]	= eTemp;

				wchTemp			= pwchList[pos1];
				pwchList[pos1]	= pwchList[pos2];
				pwchList[pos2]	= wchTemp;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\score.h ===
#ifndef SCORE_H
#define SCORE_H

/* Log Prob manipulation library */

/* Our scores are Log Probs.  If p is a probability in [0-1] then we define s(p) = -k*log(p)/log(b) where
k is a scaleing factor and b is the base of the logarithm. The idea is that scaled logprobs can be stored in
integers for more efficient manipulation.  Also, probs are usually multiplied, so logs probs can just be added.
Finally, several algorithm produce log probs as a more or less natural output, so there's no real conversion
happening. */

/* If you change any of these four constants, you must run MakeScoreData again! */

#define SCORE_BASE		2					// Our logs are to the base 2
#define SCORE_SCALE		256					// and we scale by 256
#define	SCORE_GAUSS_SCALE	10				// Our gaussian calculations have a granularity of 1/10 sigma
#define SCORE_GAUSS_RANGE	40				// and range from -4 to +4 sigmas

/* The following five constants must match the ones in scoredata.c; if not, copy and paste
from scoredata.c to here -- not the other way around */

#define SCORE_BASE_LOG	0.693147
#define SCORE_SCALE_BASE_LOG	369
#define SCORE_GAUSS_SCALE_LOG	850
#define MAX_DIFF_SCORE_SUM	2440
#define MAX_DIFF_SCORE_DIFF	2441

#define SCORE_MAX	((SCORE)65535)		// Largest possible score -- change if typedef changes
#define SCORE_ZERO	SCORE_MAX			// We treat SCORE_MAX as equivalent to probability zero
#define	SCORE_ONE	((SCORE)0)			// and score(1.0) == 0 of course

typedef unsigned short SCORE;

typedef struct SCORE_GAUSSIAN {
	int mean;
	int sigma;			// Standard Deviation
	SCORE scoreNormal;	// ProbToScore(1/sqrt(2*pi*sigma))
} SCORE_GAUSSIAN;

/* Use these macros to multiply and divide probs and overflow is handled automatically */

#define ScoreMulProbs(s1,s2)	((SCORE)((int)s1+(int)s2 < (int)SCORE_MAX ? (int)s1+(int)s2 : SCORE_ZERO))
#define ScoreDivProbs(s1,s2)	((SCORE)(s1 == SCORE_ZERO ? SCORE_ZERO : (int)s1-(int)s2 > (int)SCORE_ONE ? (int)s1-(int)s2 : SCORE_ONE))

/* Some old stuff for dealing with log probs.  Probably can be merged with SCORE stuff, but
   not sure, so keeping them as is. */

#define	INTEGER_LOG_SCALE	256

int	AddLogProb(int a, int b);

/* Convert a probabilty to a score */

SCORE
ProbToScore(
	double eProb
);

/* Convert a score back to a probability */

double
ScoreToProb(
	SCORE score
);

/* Use this when you want to add two probabilities but you have two scores.
Computes ProbToScore(ScoreToProb(score1)+ScoreToProb(score2)) but much, much faster. */

SCORE
ScoreAddProbs(
	SCORE score1,
	SCORE score2
);

/* Use this when you want to subtract one probability from another but you have two scores.
Computes ProbToScore(ScoreToProb(score1)-ScoreToProb(score2)) but much, much faster. */

SCORE
ScoreSubProbs(
	SCORE score1,
	SCORE score2
);

/* Given a count of data points, a su, of values at those points, and a sum of the squares of the values at
those points, compute the mean and standard deviation plus the log-prob of the normal denominator for use in 
further gaussian calculations.  All returned numbers are ints, so the input values should be pre-scaled to
avoid loss of precision */

void
ScoreGaussianCalc(
	int cx,
	double eSumX,
	double eSumX2,
	SCORE_GAUSSIAN *pScoreGaussian
);

/* Given a value and a gaussian, compute the probability.  This is really the 
probability of the granular slice, since obviously the probability of that exact
point would be zero. This is equivalent to "the probability that a point fell in
this zone" where there are SCORE_GAUSS_SCALE zones per sigma */

SCORE
ScoreGaussianPoint(
	int x,
	SCORE_GAUSSIAN *pScoreGaussian
);

/* Computes the probability that a value was x or less */

SCORE
ScoreGaussianTail(
	int x,
	SCORE_GAUSSIAN *pScoreGaussian
);

/* Computes the probability that a value was < -|x| or > |x| */

SCORE
ScoreGaussianTail2(
	int x,
	SCORE_GAUSSIAN *pScoreGaussian
);

#endif // SCORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\tabllocl.h ===
#ifndef __TABLLOCL__
#define __TABLLOCL__

#ifdef __cplusplus
extern "C" {
#endif

// Class Bigram constants
#define BICLASS_INVALID       -1
#define BICLASS_ENGLISH       0
#define BICLASS_NUM_PUNC      1
#define BICLASS_NUMBERS       2
#define BICLASS_KANJI         3
#define BICLASS_KATAKANA      4
#define BICLASS_HIRAGANA      5
#define BICLASS_JPN_PUNC      6
#define BICLASS_OTH_PUNC      7
#define BICLASS_BOSEN	      8
#define BICLASS_UNKNOWN       9
#define BICLASS_TOTAL         10

// Base Line constants
#define BASE_NORMAL		0x00	// kanji, kana, numbers, etc
#define BASE_QUOTE		0x01	// upper punctuation, etc
#define BASE_DASH       0x02    // middle punctuation, etc
#define BASE_DESCENDER  0x03    // gy, anything that descends.
#define BASE_THIRD      0x04    // something that starts a third way up.

// height constants
#define XHEIGHT_NORMAL	0x00	// lower-case, small kana, etc
#define XHEIGHT_KANJI	0x10	// upper-case, kana, kanji, numbers, etc
#define XHEIGHT_PUNC		0x20	// comma, quote, etc
#define XHEIGHT_DASH        0x30    // dash, period, etc


// Maximum number of codepoint classes
// should always be less than 0xFF 
// which is reserved for invalid code, see LOC_RUN_NO_CLASS
#define MAX_CODEPOINT_CLASSES			BICLASS_TOTAL

// Max size of buffer storing all Class Arrays in all sub-ranges
#define MAX_CLASS_ARRAY_SIZE			1024	// 1K

// Max size of buffer string all Class Exceptions in all sub-ranges
#define MAX_CLASS_EXCEPT_SIZE			1024	// 1K

// maximum number of array entries for codepoint classes
#define	MAX_CLASS_ARRAY_ENTRIES			0x7FFF

// maximum number of exceptions in class exception list
#define MAX_CLASS_EXCEPTIONS_PERLIST	0x7F

// Maximum number of BLineHgt codes
// 0xFF is used for invalid code, see LOC_RUN_NO_BLINEHGT
#define MAX_BLINEHGT_CODE				0xFF

// Max size of buffer storing all BLIneHgt Arrays in all sub-ranges
#define MAX_BLINHGT_ARRAY_SIZE			1024	// 1K

// Max size of buffer storing all BLIneHgt Exceptions in all sub-ranges
#define MAX_BLINHGT_EXCEPT_SIZE			1024	// 1K

// maximum number of array entries for codepoint classes
#define	MAX_BLINEHGT_ARRAY_ENTRIES		0x7FFF	

// maximum number of exceptions in BLineHgt exception list
#define MAX_BLINEHGT_EXCEPTIONS_PERLIST	0x7F

// Max number of class exceptions in a subrange after which we use arrays
#define MAX_CLSEXCPT					10

// Min class exception list size reduction (percentage) below which we use arrays
#define MIN_CLSEXCPT_REDUCT				10

// Max number of BLineHgt exceptions in a subrange after which we use arrays
#define MAX_BLHEXCPT					10

// Min BLineHgt exception list size reduction (percentage) below which we use arrays
#define MIN_BLHEXCPT_REDUCT				10

#ifdef __cplusplus
extern "C" }
#endif

#endif //__TABLLOCL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\valid.h ===
/******************************************************************************\
 *	FILE:	valid.h
 *
 *	Functions to verify stroke count by code point.
\******************************************************************************/
#ifndef __INCLUDE_VALID
#define	__INCLUDE_VALID

#ifdef __cplusplus
extern "C" {
#endif

// Checks for stroke counts that are known to be invalid.  Returns
// Returns true unless we are sure that the stroke count is bad.
extern int ValidStrokeCount(wchar_t wch, short iStroke);

// Check for suspisious stroke counts.  Return false if we think the
// stroke count my be bad.
extern int NotSuspStrokeCount(wchar_t wch, short iStroke);

#ifdef __cplusplus
}
#endif

#endif	// __INCLUDE_VALID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\runnet.h ===
/************************************************************
 *
 * runNet.h
 *
 * Bare bones net. 
 * Use this implementation to build and run a net
 * (Not for training)
 *
 * mrevow
 *
 ***********************************************************/
#ifndef H_RUN_NET_H
#define H_RUN_NET_H

// Versioning infrmation
//   December 2001 Introduced versioning information. Prior to this the version
//					number did not exist. The first element was eNetType which had value < 10
//
//		Changes introduce lossType, txfer and unitType into runNet description
//
// March 2002
//		Incompatible changes:
//		Add upfront scaling of features (Added the range vector for input vars)
//		Also add data-type sizes for all weight, bias and range vectors
//
#define RUN_NET_VER_START	(10)	// First version number introduced December 2001
#define RUN_NET_VER_10		(10)	// December 2001 - March 2002
#define RUN_NET_VER_11		(11)	// March 2002 Current Version Number

//#define NET_FLOAT
typedef int				RREAL;					// Used for intermediate calculation and unit activations
typedef short			RREAL_WEIGHT;			// Used for Net weights (excluding bias)
typedef int				RREAL_BIAS;				// Used for bias weights
typedef __int64			RREAL_INPUT;			// Used for scaling inputs which are of type RREAL

// This types is shared between the train and run time nets
// It is defined here and in netTypes.h - kkep them in sync
#ifndef CAMEL_NET_TYPE_DEFINED
typedef enum tagNET_TYPE		{NO_NET_TYPE, FULLY_CONNECTED, LOCALLY_CONNECTED} NET_TYPE;
typedef enum tagLOSS_TYPE		{SUMSQUARE, SUMSQUARE_CLASS, CROSSENTROPY, CROSSENTROPY_FULL, C_LOSS_TYPE} LOSS_TYPE;
typedef enum tagTXF_TYPE		{TXF_LINEAR, TXF_INT_SIGMOID, TXF_SIGMOID, TXF_TANH, TXF_SOFTMAX, CTXF_TYPE} TXF_TYPE;
typedef enum tagLAYER_TYPE		{INPUT_LAYER, HIDDEN_LAYER, OUTPUT_LAYER, BIAS_LAYER, CLAYER_TYPE} LAYER_TYPE;
#define CAMEL_NET_TYPE_DEFINED
#endif

#define		MIN_PREC_VAL		0
#define		SOFT_MAX_UNITY		10000			// Value of 1.0 in the softMax

// Describes a net. In a running net the description
// up to and including the weight vector will be loaded
// from a resource
typedef struct tagRUN_NET
{
	WORD			iVer;			    // Added December 2001 - Versioning information -> 0 implies none present
	WORD			cLayer;				// Number of layers in net
	LOSS_TYPE		lossType;			// Added December 2001 - Type of output loss - only present for net versions > 10
	TXF_TYPE		*txfType;			// Added December 2001 - Txfer type for each layer - only present for net versions > 10
	LAYER_TYPE		*layerType;			// Added December 2001 - Unit type of eachlayer - only present for net versions > 10
	WORD			cWeight;			// Total # of weights in network
	WORD			cTotUnit;			// Total number of units in network
	WORD			*cUnitsPerLayer;	// # of units per layer
	WORD			*bUseBias;			// Use bias units? per layer
	WORD			*pWeightScale;		// Amount by which each layers incoming weights are scaled
	WORD			iInputScaledMeanDataSize;	// Data type size for pInputMean (Introduced March 2002)
	WORD			iInputRangeDataSize;// Data type size for Input Range Vector (Introduced March 2002)
	WORD			iWeightDataSize;		// Data Type size for weight vector (Introduced March 2002)
	RREAL			*pInputRange;		// Ranges for each input variable > 0 (Introduced March 2002)
	RREAL_INPUT		*pInputScaledMean;	// Scaled Means for input data (Introduced March 2002 to replace pInputMean)
	RREAL			*pInputMean;		// Means for input data 
	UINT			cWeightByte;		// Count of bytes used for weights
	RREAL_WEIGHT	*pWeight;			// All network weights.
} RUN_NET;


// describes the outgoing connections of a unit
// as the start and end unit offsets to which it connects
typedef struct tagOUT_CONNECTIONS
{
	WORD		iUnit;					// The unit in question
	WORD		iStartUnitOffset;
	WORD		iEndUnitOffset;
} OUT_CONNECTIONS;

// Describes a locally connected network
typedef struct tagLOCAL_NET
{
	WORD			iVer;					// Version Number (Started December 2001, Before all nets had eNetType as the first element set to LOCALLY_CONNECT (
	WORD			eNetType;				// Must be of type LOCALLY_CONNECTED
	RUN_NET			runNet;					// How to run the Net
	int				cConnect;				// Number of connections
	OUT_CONNECTIONS	*pOutConnect;
} LOCAL_NET;


#ifdef __cplusplus
extern "C"
{
#endif


// API functions

extern BYTE			*restoreRunNet( BYTE *pBuf, BYTE *pBCurr, RUN_NET *pNet, WORD iVer) ;
extern LOCAL_NET *	restoreLocalConnectNet( void *pBuf, wchar_t wNetId,  LOCAL_NET *pNet  ) ;
extern RREAL		*runFullConnectNet( RUN_NET *pNet,  RREAL *pfUnits,  UINT *piWinner  ) ;
extern RREAL		*runLocalConnectNet( LOCAL_NET *pNet,  RREAL *pfUnits,  UINT *piWinner, UINT *pcOut  ) ;
extern int			getRunTimeNetMemoryRequirements(void *pBuf);

extern LOCAL_NET	*loadNet(HINSTANCE hInst, int iKey, int *iNetSize, LOCAL_NET *pNet);
extern void			*loadNetFromResource(HINSTANCE hInst, int iKey, int *iSize);

#ifdef NET_FLOAT
	#define SIGMOID fsigmoid
	#define EXP(x) exp((x)/65536.0F) * 65536.0F
	RREAL * fsigmoid(RREAL *pVec, int cVec, WORD	scale);
#else
	#define SIGMOID isigmoid
	#define EXP(x)      iexp(x)
	RREAL * isigmoid(RREAL *pVec, int cVec, WORD	scale);
	RREAL iexp(RREAL val);
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\charset.c ===
#include <stdlib.h>
#include "common.h"

BOOL IsAllowedChar(LOCRUN_INFO *pLocRunInfo, const CHARSET *pCS, wchar_t dch)
{
    if (pCS->recmask & LocRun2ALC(pLocRunInfo, dch)) 
    {
        return TRUE;
    }
    if (pCS->pbAllowedChars != NULL) 
    {
        return (pCS->pbAllowedChars[dch / 8] & (1 << (dch % 8)));
    }
    return FALSE;
}

BOOL IsPriorityChar(LOCRUN_INFO *pLocRunInfo, const CHARSET *pCS, wchar_t dch)
{
    if (pCS->recmaskPriority & LocRun2ALC(pLocRunInfo, dch)) 
    {
        return TRUE;
    }
    if (pCS->pbPriorityChars != NULL) 
    {
        return (pCS->pbPriorityChars[dch / 8] & (1 << (dch % 8)));
    }
    return FALSE;
}

BOOL SetAllowedChar(LOCRUN_INFO *pLocRunInfo, BYTE **ppbAllowedChars, wchar_t dch)
{
    // Allocate the bitmask
    if (*ppbAllowedChars == NULL)
    {
        int iSize = (pLocRunInfo->cCodePoints + pLocRunInfo->cFoldingSets + 7) / 8;
        *ppbAllowedChars = ExternAlloc(iSize);
        if (*ppbAllowedChars == NULL) 
        {
            return FALSE;
        }
        memset(*ppbAllowedChars, 0, iSize);
    }

    // Set the character
    (*ppbAllowedChars)[dch / 8] |= (1 << (dch % 8));

    // Set the folded code, if any
    dch = LocRunDense2Folded(pLocRunInfo, dch);
    if (dch != 0) 
    {
        (*ppbAllowedChars)[dch / 8] |= (1 << (dch % 8));
    }
    return TRUE;
}

BYTE *CopyAllowedChars(LOCRUN_INFO *pLocRunInfo, BYTE *pbAllowedChars)
{
    BYTE *pbNew;
    int iSize;
    if (pbAllowedChars == NULL)
    {
        return NULL;
    }
    iSize = (pLocRunInfo->cCodePoints + pLocRunInfo->cFoldingSets + 7) / 8;
    pbNew = ExternAlloc(iSize);
    if (pbNew != NULL)
    {
        memcpy(pbNew, pbAllowedChars, iSize);
    }
    return pbNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\errsys.c ===
/******************************Module*Header*******************************\
* Module Name: errsys.c
*
* This provides the output functions that log the debug output.  Don't
* stick any crap or dependencies in here so this can be put in any
* project without modification.  errsys.h errsys.c are an independent
* set of files for generic use anywhere.
*
* Created: 04-Oct-1995 16:17:00
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#if (defined(DBG) || defined(DBG) || defined(DEBUGINTERNAL))

#include <windows.h>

#if (defined(_CONSOLE_) || defined(_CONSOLE) || defined(CONSOLE))
#include <stdlib.h>
#include <stdio.h>
#else
#define sprintf wsprintf
#endif

#include "tchar.h"

/******************************Public*Routine******************************\
* HwxAssertFn
*
* Standard debug routine that ASSERT calls.
*
* History:
*  17-Feb-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int giDebugLevel = 0;  // Setting this to 1 makes the debug output get
                       // registered but the app won't stop running.
                       // Use the JUST_DEBUG_MSG macro at app init.

int HwxAssertFn(int iLine, char *pchFile, char *pchExp)
{
    TCHAR achBuffer[256];
    sprintf(achBuffer, TEXT("ASSERT %hs : %d : %hs\n"), pchFile, iLine, pchExp);

#if (defined(_CONSOLE_) || defined(_CONSOLE) || defined(CONSOLE))

    fprintf(stderr, achBuffer);

    if (giDebugLevel == 0)
    {
        exit(1);
    }

#else

    OutputDebugString(achBuffer);

    if (giDebugLevel == 0)
    {
        MessageBox(NULL, achBuffer, TEXT("ASSERT"), MB_OK | MB_APPLMODAL | MB_ICONSTOP);
    }

#endif

    return(1);
}

/******************************Public*Routine******************************\
* HwxWarning
*
* Print out diagnostic messages about abnormal conditions.  In windows mode
* it just sends the message to the debugger.
*
* History:
*  09-Oct-1995 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int HwxWarning(int iLine, char *pchFile, char *pchExp)
{
    TCHAR achBuffer[256];
    sprintf(achBuffer, TEXT("WARNING %hs : %d : %hs\n"), pchFile, iLine, pchExp);

#if (defined(_CONSOLE_) || defined(_CONSOLE) || defined(CONSOLE))

    fprintf(stderr, achBuffer);

#else

    OutputDebugString(achBuffer);

#endif

    return(1);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\unigram.h ===
/******************************************************************************\
 *	FILE:	unigram.h
 *
 *	Public structures and functions library that are used to access the 
 *	unigram information.
 *
 *	Note that the code to create the binary file is in mkuni, not in the
 *	common library.
\******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************************************\
 *	Public interface to unigram data.
\************************************************************************************************/

//
// Structures and types
//

// Structure giving access to a loaded copy of the unigram tables.  We store the 
// frequencies as scores that are -10 * log2(prob).
// Note we do a hack to keep the score values in one byte.  We subtract an
// offset from the values.  Values that overflow that range are truncated to fit.
typedef struct tagUNIGRAM_INFO {
	WORD				cScores;			// Number of entries in score table.
	WORD				iRareScore;			// Frequency of items not in freq. table.
	BYTE				iOffset;			// Offset to add to scores.
	BYTE				spare[3];			// keep alignment.
	BYTE				*pScores;			// Pointer to scores.

	void				*pLoadInfo1;		// Handles needed to unload the data
	void				*pLoadInfo2;
	void				*pLoadInfo3;
} UNIGRAM_INFO;

//
// Functions.
//

// Load unigram information from a file.
BOOL	UnigramLoadFile(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, wchar_t *pPath);

// Unload runtime localization information that was loaded from a file.
BOOL	UnigramUnloadFile(UNIGRAM_INFO *pUnigramInfo);

// Load unigram information from a resource.
// Note, don't need to unload resources.
BOOL	UnigramLoadRes(
	LOCRUN_INFO *pLocRunInfo,
	UNIGRAM_INFO	*pUnigramInfo,
	HINSTANCE		hInst,
	int				nResID,
	int				nType
);

// Load runtime localization information from an image already loaded into
// memory.
BOOL	UnigramLoadPointer(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, void *pData);

// Get unigram probability for a character.  Character must be passed in as
// dense coded value.   Warning: value returned as log2(prob)/10. I don't know
// why, but this is what the old code did!
float	UnigramCost(
	UNIGRAM_INFO	*pUnigramInfo,
	wchar_t			dch
);

#ifdef ZTRAIN
// Takes a character (possibly folded) and returns the probability of that
// character occurring.
float	UnigramCostFolded(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, wchar_t wFold);
#endif

/************************************************************************************************\
 *	Stuff to access binary unigram file, only used by common and mktable.
\************************************************************************************************/

// The format for the unigram file is:
//		Header:
//			DWORD				File type indicator.
//			DWORD				Size of header.
//			BYTE				Lowest version this code that can read this file.
//			BYTE				Version of this code that wrote this file.
//			wchar_t[4]			Locale ID (3 characters plus null).
//			DWORD * 3			Locale signature
//			WORD				Number of entries in frequency table.
//			WORD				Frequency of items not in freq. table.
//			WORD				Reserved for future use.
//			DWORD * 2			Reserved for future use.
//		Frequency table:
//			BYTE				Frequency for dense code 0.
//			BYTE				Frequency for dense code 1.
//				.
//				.
//				.
//			BYTE				Frequency for dense code N.
//
// NOTE: Frequencies are stored as -10 * log2(prob)

//
// Constants
//

// Magic key the identifies the Local Runtime files
#define	UNIGRAM_FILE_TYPE	0xFD8BA978

// Version information for file.
#define	UNIGRAM_MIN_FILE_VERSION		0	// First version of code that can read this file
#define UNIGRAM_CUR_FILE_VERSION		0	// Current version of code.
#define	UNIGRAM_OLD_FILE_VERSION		0	// Oldest file version this code can read.

//
// Structures and types
//

// Structure to hold file header.
typedef struct tagUNIGRAM_HEADER {
	DWORD		fileType;			// This should always be set to UNIGRAM_FILE_TYPE.
	DWORD		headerSize;			// Size of the header.
	BYTE		minFileVer;			// Earliest version of code that can read this file
	BYTE		curFileVer;			// Current version of code that wrote the file.
	wchar_t		locale[4];			// Locale ID string.
	DWORD		adwSignature [3];	// Locale signature
	WORD		cScores;		// Number of entries in score table.
	WORD		iRareScore;		// Frequency of items not in freq. table.
	BYTE		iOffset;		
	BYTE		reserved1;		
	DWORD		reserved2[2];
} UNIGRAM_HEADER;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\bigram.c ===
/************************************************************************************************
 * FILE: bigram.c
 *
 *	Code to use the bigram tables.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"

// Table of ALCs to to group togather for low sample count bigrams.
// For charactes with multiple ALC values, we take the first bin with
// any ALC for the character.
// WARNING: cALCGroupings MUST be less than or equal to BIGRAM_MAX_CLASS_CODES!!!
static const ALC	aALCGroupings[]	= {
	ALC_NUMERIC,
	ALC_LCALPHA,
	ALC_UCALPHA,
	ALC_KATAKANA,
	ALC_HIRAGANA,
	ALC_OTHER,
	ALC_PUNC,
	ALC_COMMON_KANJI | ALC_RARE_KANJI,
	ALC_COMMON_HANGUL | ALC_RARE_HANGUL,
	0xFFFF			// If it gets this far, always match.
};
#define	cALCGroupings	(sizeof(aALCGroupings) / sizeof(aALCGroupings[0]))

// Load bigram information from an image already loaded into memory.
BOOL
BigramLoadPointer(LOCRUN_INFO *pLocRunInfo, BIGRAM_INFO *pBigramInfo, void *pData)
{
	const BIGRAM_HEADER	*pHeader	= (BIGRAM_HEADER *)pData;
	BYTE				*pScan;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != BIGRAM_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > BIGRAM_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < BIGRAM_OLD_FILE_VERSION)
		|| memcmp (pHeader->adwSignature, pLocRunInfo->adwSignature,sizeof(pHeader->adwSignature))
	) {
		goto error;
	}

	// Fill in information from header.
	pBigramInfo->cInitialCodes		= pHeader->cInitialCodes;
	pBigramInfo->cRareCodes			= pHeader->cRareCodes;
	pBigramInfo->cSecondaryTable	= pHeader->cSecondaryTable;

	// Fill in pointers to the other data in the file
	pScan							= (BYTE *)pData + pHeader->headerSize;
	pBigramInfo->pInitialOffsets	= (WORD *)pScan;
	pScan							+= sizeof(WORD) * pHeader->cInitialCodes;
	pBigramInfo->pRareOffsets		= (WORD *)pScan;
	pScan							+= sizeof(WORD) * (pHeader->cRareCodes + 1);
	pBigramInfo->pSecondaryTable	= (BIGRAM_CHAR_PROB *)pScan;
	pScan							+= sizeof(BIGRAM_CHAR_PROB) * pHeader->cSecondaryTable;

	// Default unused values for file handle information
	pBigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pBigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pBigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

error:
	return FALSE;
}

// Get bigram probability for selected characters.  Characters must be passed in as
// dense coded values.
FLOAT
BigramTransitionCost(
	LOCRUN_INFO		*pLocRunInfo,
	BIGRAM_INFO		*pBigramInfo,
	wchar_t			dchPrev,
	wchar_t			dchCur
) {
	WORD		offset, limit;

	// Does prev character have entry in intial table?
	if (dchPrev < pBigramInfo->cInitialCodes) {
		// It's in the initial table, get its value and next value for limit.
		offset	= pBigramInfo->pInitialOffsets[dchPrev];
		limit	= pBigramInfo->pInitialOffsets[dchPrev + 1];
	} else {
		goto defaultProb;
	}

	// Scan list for match.  Entries are sorted so class entries are last so we can
	// just look for first match of character or its class.
	for ( ; offset < limit; ++offset) {
		BIGRAM_CHAR_PROB	*pCurCharProb;

		pCurCharProb	= pBigramInfo->pSecondaryTable + offset;
		if (pCurCharProb->dch == dchCur) {
			// We have a match.
			return ((FLOAT) (-pCurCharProb->prob)) / 256;
		}
	}

	// No match, return default.
defaultProb:
	return ((FLOAT) (-BIGRAM_DEFAULT_PROB)) / 256;
}

// Convert a dense character code to a character class code.
wchar_t
BigramDense2Class(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	ALC		alc;
	int		ii;

	// Get the ALC mask for the character.
	alc		= LocRunDense2ALC(pLocRunInfo, dch);

	// Now loop over our choices and find a match.
	for (ii = 0; ii < cALCGroupings; ++ii) {
		if (alc & aALCGroupings[ii]) {
			// Match, return it.
			return BIGRAM_FIRST_CLASS_CODE + ii;
		}
	}

	// Character with no ALC bits set?!!?, well act like we matched the last one anyway.
	return BIGRAM_FIRST_CLASS_CODE + cALCGroupings - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\glyphtrn.c ===
/******************************Module*Header*******************************\
* Module Name: glyphtrn.c
*
* Glyph functions only needed during training or tuning.
*
* Created: 13-Feb-1997 15:14:55
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "common.h"

GLYPH *MergeGlyphGLYPH(GLYPH *self, GLYPH *merge)
{
	GLYPH *result, *source, *glyph;

	ASSERT(self && self->frame && self != merge);
	ASSERT(merge == 0 || self->frame != merge->frame);

	result = NewGLYPH();
	glyph   = result;

	for (source = self; source; source = source->next)
	{
		glyph->next = NewGLYPH();
		glyph = glyph->next;
		glyph->frame = source->frame;
	}

	for (source = merge; source; source = source->next)
	{
		glyph->next = NewGLYPH();
		glyph = glyph->next;
		glyph->frame = source->frame;
	}

	glyph  = result;			// dummy node heading list
	result = glyph->next;		// first node in merged glyph
	glyph->next = 0;			// terminate dummy
	DestroyGLYPH(glyph);		// free dummy

	return result;
}

GLYPH *GlyphFromHpendata(HPENDATA hpendata)
{
	int			istroke = 0;
	LPPENDATA	lppendata;
	STROKEINFO	strokeinfo;
	GLYPH	   *glyph = NULL;
	XY		   *rgrawxy = NULL;
	void	   *rgrawoem = NULL;
	FRAME	   *frame;

	lppendata = BeginEnumStrokes(hpendata);

	ASSERT(lppendata != NULL);

	while (GetPenDataStroke(lppendata, istroke, (POINT **) &rgrawxy,  (void **) &rgrawoem, &strokeinfo))
	{
		if ((strokeinfo.wPdk & PDK_DOWN))       // ignore up strokes
		{
			if (!glyph)
				glyph = NewGLYPH();

			frame = NewFRAME();

			frame->info = strokeinfo;
			frame->info.wPdk |= PDK_TRANSITION;           // its a complete stroke
			frame->rgrawxy = (XY *) ExternAlloc((unsigned) ((long) strokeinfo.cPnt * sizeof(XY)));
			memmove(frame->rgrawxy, rgrawxy, strokeinfo.cPnt * sizeof(XY));

			// add stroke to glyph
			AddFrameGLYPH(glyph, frame);
		}
		istroke++;
	}

	EndEnumStrokes(hpendata);
	return(glyph);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\inc\toolmain.h ===
/******************************************************************************
 *	FILE:	toolmain.h
 *
 *	This is a header for the code that provides a standard main and argument
 *	parsing for command line tools.  To use this, you need to copy toolmain.c
 *	from \hwx\common\template and edit it to specify the parameters needed by
 *	your application.  You will also need to call your main function ToolMain
 *	(as declared below) so that the standard code can call it.
 *
 *	NOTE: It may be necessary to support additional switch and argument types.
 *	To do this, you will need to edit this file and toolprs.c.  See comments
 *	with "EXTEND:" in them for notes on where to do this.
 ******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////////////
//	Stuff tool code needs to provide.
////////////////////////////////////////////////////////////////////////////////

// Decleration for the main processing the tool does.
extern BOOL	ToolMain(void);

////////////////////////////////////////////////////////////////////////////////
//	Declerations relating to command line switches.
////////////////////////////////////////////////////////////////////////////////

// Types of switches supported.
// EXTEND: You can add more switch types here.
typedef enum tagSWITCH_TYPES {
	SWITCH_HELP,			// Print out help message and exit.
	SWITCH_BOOL,			// Boolean, set to TRUE if specified.
	SWITCH_STRING,			// A string.
	SWITCH_UNSIGNED,		// An unsigned integer value.
	SWITCH_INT,				// An integer value,
	SWITCH_DOUBLE,			// A floating point value stored in a double.
} SWITCH_TYPES;

// Structure to hold spec for a switch.
typedef struct tagSWITCH_SPEC {
	wchar_t			wchSwitch;		// Switch character
	SWITCH_TYPES	switchType;		// What type is it.
	void			*pSwitch;		// Where to put results.
} SWITCH_SPEC;

////////////////////////////////////////////////////////////////////////////////
//	Declerations relating to command line arguments.
////////////////////////////////////////////////////////////////////////////////

// Magic names to use for standard IO files.
#define	ARG_STDIN		L"<stdin>"
#define	ARG_STDOUT		L"<stdout>"
#define	ARG_STDERR		L"<stderr>"

// Types of arguments supported.
// EXTEND: You can add more argument types here.
typedef enum tagARG_TYPES {
	ARG_STRING,				// Any old string
	ARG_FILE,				// File to open with specified mode.
	ARG_FILE_UTIL,			// File to open with UtilOpen
	ARG_UNSIGNED,			// An unsigned integer value.
	ARG_DOUBLE,				// A floating point value stored in a double.
} ARG_TYPES;

// Struct to hold spec for an argument.
typedef struct tagARG_SPEC {
	wchar_t			*pName;		// Argument name, used in log file.
	ARG_TYPES		argType;	// Type of argument.
	wchar_t			*pMode;		// Mode for file opens.
	wchar_t			*pDefault;	// Optional default value.
	wchar_t			**ppText;	// Where to put text of argument.
	void			*pValue;	// Where to put value (if needed).
} ARG_SPEC;

////////////////////////////////////////////////////////////////////////////////
//	Public interface types and functions.
////////////////////////////////////////////////////////////////////////////////

// Structure to pull togather all the configuration pieces so that we only
// have to pass one thing to the functions.
typedef struct tagPARSE_INFO {
	int			cUsageStrings;					// Number of usage strings.
	wchar_t		const * const *ppUsageStrings;	// Text for usage message.
	int			cSwitchSpecs;					// Number of switch spec.
	SWITCH_SPEC	const *pSwitchSpecs;			// Switch specifications.
	int			cArgSpecs;						// Number of program arguments.
	ARG_SPEC	const *pArgSpecs;				// Argument specifications.
	FILE		**ppLogFile;					// File to log output too.
	wchar_t		**ppTreeRoot;					// Root of build tree
	wchar_t		**ppConfigName;					// Name of configuration directory
	wchar_t		**ppLocale;						// Locale ID
} PARSE_INFO;

// Actually parses command line.
BOOL	ToolMainParseArguments(
	PARSE_INFO	const *pParseInfo,
	int			argc,
	wchar_t		**argv
);

// Load in locale information.
BOOL	ToolMainLoadLocale(
	PARSE_INFO		const *pParseInfo,
	LOCRUN_INFO		*pLocRunInfo,
	LOCTRAIN_INFO	*pLocTrainInfo
);

// Load in locale information.
BOOL	ToolMainLoadLocaleEx(
	PARSE_INFO		const *pParseInfo,
	LOCRUN_INFO		*pLocRunInfo,
	LOCTRAIN_INFO	*pLocTrainInfo,
	wchar_t			*pRecognizer
);

// Print out usage message.
void	ToolMainUsage(PARSE_INFO const *pParseInfo);

// Log standard header information.
void	ToolMainLogHeader(
	PARSE_INFO	const *pParseInfo,
	int			argc,
	wchar_t		**argv
);

// Log standard trailer information
void	ToolMainLogTrailer(PARSE_INFO const *pParseInfo);

// Cleanup, close files etc.
BOOL	ToolMainCleanup(
	PARSE_INFO		const *pParseInfo,
	LOCRUN_INFO		*pLocRunInfo,
	LOCTRAIN_INFO	*pLocTrainInfo
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\frame.c ===
// frame.c

#include "common.h"

/******************************Public*Routine******************************\
* NewFRAME
*
* Allocates a FRAME object out of the heap.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

FRAME *NewFRAME(void)
{
// We know ExternMalloc returns zeroed out memory

    FRAME *self = ExternAlloc(sizeof(FRAME));

	if (self != (FRAME *) NULL)
	{
		memset(self, '\0', sizeof(FRAME));
	    self->rect.left = -1;					// uninitialized rectangle
	}

	return self;
}

/******************************Public*Routine******************************\
* DestroyFRAME
*
* Frees a FRAME object
* Effects:
*
* Warnings:
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void DestroyFRAME(FRAME *self)
{
	if (!self) return;
	if (self->pvData) ExternFree(self->pvData);
	if (self->rgrawxy) ExternFree(self->rgrawxy); 
	if (self->rgsmoothxy) ExternFree(self->rgsmoothxy);

	ExternFree(self);
}

/******************************Public*Routine******************************\
* RectFRAME
*
* Returns the bounding rectangle of the frame, inclusive top left,
* exclusive bottom right.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

RECT *RectFRAME(FRAME *self)
{
	XY	   *xy, *xyMax;
	RECT   *rect;

	rect = &(self->rect);

	if (rect->left == -1) // Uninitialized
	{
		xy = self->rgrawxy;
		xyMax = xy + CrawxyFRAME(self);

		rect->left = rect->right = xy->x;
		rect->top = rect->bottom = xy->y;

		for (++xy; xy < xyMax; xy++)
		{
			if (xy->x < rect->left)
				rect->left = xy->x;
			else if (xy->x > rect->right)
				rect->right = xy->x;

			if (xy->y < rect->top)
				rect->top = xy->y;
			else if (xy->y > rect->bottom)
				rect->bottom = xy->y;
		}

        rect->right++;      // Make it lower right exclusive.
		rect->bottom++;
	}

	return(rect);
}

// Translate a frame by dx & dy
void TranslateFrame (FRAME *pFrame, int dx, int dy)
{
	UINT	i;
	
	for (i = 0; i < pFrame->info.cPnt; i++)
	{
		pFrame->rgrawxy[i].x	+=	dx;
		pFrame->rgrawxy[i].y	+=	dy;
	}

	// Adjust the Bounding rect if it has been computed
	if ( !(pFrame->rect.left == -1 && pFrame->rect.right == 0 && pFrame->rect.top == 0 && pFrame->rect.bottom == 0))
	{
		pFrame->rect.left	+=	dx;
		pFrame->rect.right	+=	dx;

		pFrame->rect.top	+=	dy;
		pFrame->rect.bottom	+=	dy;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\glyph.c ===
// glyph.c

#include "common.h"

/******************************Public*Routine******************************\
* NewGLYPH
*
* Creates a GLYPH from the heap.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

GLYPH *NewGLYPH(void)
{
    GLYPH *self = (GLYPH *) ExternAlloc(sizeof(GLYPH));

	if (self != (GLYPH *) NULL)
		memset(self, '\0', sizeof(GLYPH));

    return self;
}

/******************************Public*Routine******************************\
* DestroyGLYPH
*
* Frees a GLYPH.  Note this doesn't free the frames allocated as they
* may belong to many glyphs, especially in free input mode where each
* frame is put in all possible glyphs that could be constructed with it.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void DestroyGLYPH(GLYPH *glyph)
{
	GLYPH *glyphNext;

	ASSERT(glyph);

	// Note the frames are destroyed somewhere else !

	while (glyph)
	{
		glyphNext = glyph->next;

		ExternFree(glyph);

		glyph = glyphNext;
	}
}

BOOL AddFrameGLYPH(GLYPH *self, FRAME *frame)
{
    GLYPH *glyph;

    ASSERT(self);
	if (!self)
	{
		return FALSE;
	}

    for (glyph = self; glyph->next; glyph = glyph->next)
    {
        ;
    }

    if (glyph->frame)
    {
        if ((glyph->next = NewGLYPH()) == (GLYPH *) NULL)
			return FALSE;

        glyph = glyph->next;
        glyph->next = 0;
    }

    glyph->frame = frame;

	return TRUE;
}

void DestroyFramesGLYPH(GLYPH *self)
{
   GLYPH *glyph;

   ASSERT(self);

    for (glyph = self; glyph; glyph = glyph->next)
    {
        DestroyFRAME(glyph->frame);
    }
}

int CframeGLYPH(GLYPH *self)
{
    GLYPH *glyph;
    int     cframe = 0;

    for (glyph = self; glyph; glyph = glyph->next)
      if ((glyph->frame) && (IsVisibleFRAME(glyph->frame)))
         ++cframe;

    return cframe;
}

FRAME *FrameAtGLYPH(GLYPH *self, int iframe)
{
	GLYPH *glyph;

	ASSERT(iframe >= 0);
	ASSERT(self && self->frame);

	for (glyph = self; glyph && iframe; glyph = glyph->next)
		if (glyph->frame && IsVisibleFRAME(glyph->frame))
			--iframe;

	for (; glyph && (NULL==glyph->frame || !IsVisibleFRAME(glyph->frame)); glyph = glyph->next);

	ASSERT(glyph == 0 || IsVisibleFRAME(glyph->frame));

	return glyph ? glyph->frame : (FRAME *) NULL;
}


/******************************Public*Routine******************************\
* GetRectGLYPH
*
* Returns the inclusive top left / exclusive bottom right bounding
* rectangle of the visible points in the glyph.
*
* History:
*  18-Mar-1996 -by- Patrick Haluptzok patrickh
* Comment it.
\**************************************************************************/

void GetRectGLYPH(GLYPH *self, LPRECT rectUnion)
{
    RECT     *rect;
    GLYPH    *glyph;

	if (!rectUnion)
	{
		return;
	}
    // Get to first visible glyph.

    for (glyph = self; glyph; glyph = glyph->next)
    {
       if (glyph->frame && IsVisibleFRAME(glyph->frame))
          break;
    }

    // Set the rect initially to the bounding rect
    // of the first frame.

	if (!glyph)
	{
		memset(rectUnion, 0, sizeof(*rectUnion));
		return;
	}

    *rectUnion = *RectFRAME(glyph->frame);

    // Now "or" in the rest of the rectangles
    // for the visible frames.

    for (glyph = glyph->next; glyph; glyph = glyph->next)
    {
        if (IsVisibleFRAME(glyph->frame))
        {
            rect = RectFRAME(glyph->frame);
            rectUnion->left   = min(rectUnion->left,  rect->left);
            rectUnion->right  = max(rectUnion->right, rect->right);
            rectUnion->top    = min(rectUnion->top,   rect->top);
            rectUnion->bottom = max(rectUnion->bottom, rect->bottom);
        }
    }
}

XY *SaveRawxyGLYPH(GLYPH *self)
{
	int cXY = 0;
	GLYPH *glyph;
	XY *xy, *pXY;

	glyph = self;
	while (glyph)
	{
		cXY += CrawxyFRAME(glyph->frame);
		glyph = glyph->next;
	}

	if (cXY <= 0)
		return NULL;

	pXY = xy = (XY *) ExternAlloc(cXY * sizeof(XY));
	if (!xy)
		return NULL;

	glyph = self;
	while (glyph)
	{
		cXY = CrawxyFRAME(glyph->frame);
		memcpy(pXY, RgrawxyFRAME(glyph->frame), cXY*sizeof(XY));
		pXY += cXY;
		glyph = glyph->next;
	}

	return xy;
}

void RestoreRawxyGLYPH(GLYPH *self, XY *xy)
{
	while (self)
	{
		int cXY = CrawxyFRAME(self->frame);
		memcpy(RgrawxyFRAME(self->frame), xy, cXY*sizeof(XY));
		xy += cXY;
		self = self->next;
	}
}

// Translate a Glyph by dx & dy
void TranslateGlyph (GLYPH *pGlyph, int dx, int dy)
{
	for (; pGlyph; pGlyph = pGlyph->next)
	{
		FRAME	*pFrame	=	pGlyph->frame;
		
		TranslateFrame (pFrame, dx, dy);
	}
}

// Translate a Glyph by dx & dy
void TranslateGuide (GUIDE *pGuide, int dx, int dy)
{
	pGuide->xOrigin += dx;
	pGuide->yOrigin += dy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\clbigram.c ===
/************************************************************************************************
 * FILE: clbigram.c
 *
 *	Code to use the class bigram tables.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "tabllocl.h"

// Load Class Bigram information from an image already loaded into memory.
BOOL
ClassBigramLoadPointer(LOCRUN_INFO *pLocRunInfo, CLASS_BIGRAM_INFO *pClassBigramInfo, void *pData)
{
	const CLASS_BIGRAM_HEADER	*pHeader	= (CLASS_BIGRAM_HEADER *)pData;
	BYTE						*pScan;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != CLASS_BIGRAM_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > CLASS_BIGRAM_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < CLASS_BIGRAM_OLD_FILE_VERSION)
		|| memcmp (pHeader->adwSignature, pLocRunInfo->adwSignature,sizeof(pHeader->adwSignature))
	) {
		goto error;
	}

	// Fill in information from header.
	pClassBigramInfo->cNumClasses		= pHeader->cNumClasses;

	// Fill in pointers to the other data in the file
	pScan							= (BYTE *)pData + pHeader->headerSize;
	pClassBigramInfo->pProbTable	= (BYTE *)pScan;
	pScan							+= (pClassBigramInfo->cNumClasses
		* pClassBigramInfo->cNumClasses * sizeof(CODEPOINT_CLASS)
	);
	
	// Default unused values for file handle information
	pClassBigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pClassBigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pClassBigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

error:
	return FALSE;
}

// Get bigram probability for selected characters.  Characters must be passed in as
// dense coded values.
FLOAT
ClassBigramTransitionCost(
	LOCRUN_INFO			*pLocRunInfo,
	CLASS_BIGRAM_INFO	*pBigramInfo,
	wchar_t				dchPrev,
	wchar_t				dchCur
) {
	CODEPOINT_CLASS	dchPrevClass, dchCurClass;
	BYTE			iScore;
	wchar_t	ucur, uprev;

	// find the Class of each of the two dense codes
	dchPrevClass	= LocRunDensecode2Class(pLocRunInfo, dchPrev);
	if (LocRunDense2Unicode(pLocRunInfo, dchPrev) == 0x3007)
	{
		dchPrevClass = BICLASS_KANJI;
	}
	// unknown class
	if (dchPrevClass==LOC_RUN_NO_CLASS) {
		goto defaultProb;
	}

	dchCurClass		= LocRunDensecode2Class(pLocRunInfo, dchCur);
	if (LocRunDense2Unicode(pLocRunInfo, dchCur) == 0x3007)
	{
		dchCurClass = BICLASS_KANJI;
	}
	// invalid class
	if (dchCurClass==LOC_RUN_NO_CLASS) {
		goto defaultProb;
	}

	iScore=pBigramInfo->pProbTable[dchPrevClass*pBigramInfo->cNumClasses+dchCurClass];

	// JRB: MAJOR HACK!!!
	ucur	= LocRunDense2Unicode(pLocRunInfo, dchCur);
	uprev	= LocRunDense2Unicode(pLocRunInfo, dchPrev);
	if ((ucur == L'\x4E00' || ucur == L'\x2010' || ucur == L'\x2015') && dchPrevClass == BICLASS_NUMBERS) {
		iScore = 255;
	}
	if ((ucur == L'T' || ucur == L'J')
		&& (dchPrevClass == BICLASS_NUMBERS
		 || uprev == L'\x4E00' || uprev == L'\x4E03'
		 || uprev == L'\x4E09' || uprev == L'\x4E8C')) {
		iScore = 255;
	}

	return ((FLOAT) (-iScore)) / 256;
	
	// No match, return default.
defaultProb:
	return ((FLOAT) (-CLASS_BIGRAM_DEFAULT_PROB)) / 256;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\guide.c ===
#include "recogp.h"
#include "recog.h"

// Convert from New to Old GUIDE structure
void ConvertFromHWXGuide (GUIDE *pTo, HWXGUIDE *pFrom)
{
	pTo->xOrigin		=	pFrom->xOrigin ;
	pTo->yOrigin		=	pFrom->yOrigin ;

	pTo->cxBox			=	pFrom->cxBox ;
	pTo->cyBox			=	pFrom->cyBox ;

	pTo->cxBase			=	pFrom->cxOffset ; 

	// Special case for far east
	if (pFrom->cyBase == 0)
		pTo->cyBase		=	pFrom->cyBox;
	else
		pTo->cyBase		=	pFrom->cyOffset + pFrom->cyBase ; 

	pTo->cHorzBox		=	pFrom->cHorzBox ;
	pTo->cVertBox		=	pFrom->cVertBox ;

	// Special case for far east because no base or mid line exist
	if (pFrom->cyBase == 0 || pFrom->cyMid == 0)
		pTo->cyMid		=	0;
	else
		pTo->cyMid		=	pFrom->cyBase - pFrom->cyMid ;
}

// Convert from Old to New GUIDE structure
void ConvertToHWXGuide (HWXGUIDE *pTo, GUIDE *pFrom)
{
	pTo->cHorzBox		=	pFrom->cHorzBox ;
	pTo->cVertBox		=	pFrom->cVertBox ;
	
	pTo->xOrigin		=	pFrom->xOrigin ;
	pTo->yOrigin		=	pFrom->yOrigin ;

	pTo->cxBox			=	pFrom->cxBox ;
	pTo->cyBox			=	pFrom->cyBox ;

	pTo->cxOffset		=	pFrom->cxBase ;
	pTo->cyOffset		=	0;

	pTo->cxWriting		=	pFrom->cxBox - (2 * pFrom->cxBase) ;

	/* Some new code sets cyBase to zero, but for older code (and FFF Files) cyBase is correct */

	if (pFrom->cyBase > 0) {
		pTo->cyWriting		=	pFrom->cyBase ;
	} else {
		pTo->cyWriting		=	pFrom->cyBox ;
	}

	pTo->cyMid			=	pFrom->cyBase - pFrom->cyMid ;
	pTo->cyBase			=	pFrom->cyBase ;	

	pTo->nDir			=	HWX_HORIZONTAL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\langtax.c ===
// langtax.c
// Radmila Sarac, rsarac & Angshuman Guha, aguha
// July 11, 2000

// Language Taxonomy file
// Given any language and a unicode value, this code attempts
// to define a "class" for that codepoint.

#include <windows.h>
#include "langtax.h"

#define CLANG 7

typedef struct {
	wchar_t	startCodePoint;
	int		Class;
	wchar_t	stopCodePoint;
}ENTRY;

typedef struct {
	WORD	wLangID;
	wchar_t *wszLanguage;
	int		cClass;
	int		cEntry;
	ENTRY	*pEntry;
	wchar_t	**aClassNames;
}PARTITION;

#include "usatax.ci"
#include "chstax.ci"
#include "chttax.ci"
#include "jpntax.ci"
#include "kortax.ci"

#define USA_ID MAKELANGID(LANG_ENGLISH,  SUBLANG_DEFAULT)
#define FRA_ID MAKELANGID(LANG_FRENCH,   SUBLANG_DEFAULT)
#define DEU_ID MAKELANGID(LANG_GERMAN,   SUBLANG_DEFAULT)
#define CHS_ID MAKELANGID(LANG_CHINESE,  SUBLANG_CHINESE_SIMPLIFIED)
#define CHT_ID MAKELANGID(LANG_CHINESE,  SUBLANG_CHINESE_TRADITIONAL)
#define JPN_ID MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)
#define KOR_ID MAKELANGID(LANG_KOREAN,   SUBLANG_DEFAULT)

static PARTITION aPartition[CLANG] = {
	{USA_ID,  L"USA", 6,  32, USATable, USA_CLASSES},
	{FRA_ID,  L"FRA", 6,  30, USATable, USA_CLASSES},
	{DEU_ID,  L"DEU", 6,  30, USATable, USA_CLASSES},
	{CHS_ID,  L"CHS", 6,  42, CHSTable, CHS_CLASSES},
	{CHT_ID,  L"CHT", 4,  20, CHTTable, CHT_CLASSES},
	{JPN_ID,  L"JPN", 6,  32, JPNTable, JPN_CLASSES},
	{KOR_ID,  L"KOR", 7, 4117, KORTable, KOR_CLASSES}
};

int GetIndexFromLANG(WORD wIDLanguage)
{
	int i;
	for (i = 0; i < CLANG; i++)
		if (aPartition[i].wLangID == wIDLanguage)
				return i;
	return -1;
}

int GetIndexFromLocale(wchar_t *wszLang)
{
	int i;
	for (i = 0; i < CLANG; i++)
		if (wcscmp(_wcsupr(aPartition[i].wszLanguage), _wcsupr(wszLang)) == 0)
			return i;
	return -1;
}

int GetClassCountLANG(int iLangIndex)
{
	return (aPartition[iLangIndex].cClass);
}

wchar_t *GetNameLANG(int iLangIndex)
{
	return aPartition[iLangIndex].wszLanguage;
}

wchar_t *GetClassNameLANG(int iLangIndex, int iClassIndex)
{
	return (aPartition[iLangIndex].aClassNames[iClassIndex]);
}

int __cdecl cmpEntry(const void *v1, const void *v2)
{
	if (*(wchar_t *)v1 < (*(ENTRY *)v2).startCodePoint)
		return -1;
	else if (*(wchar_t *)v1 > (*(ENTRY *)v2).stopCodePoint)
		return 1;
	else return 0;
}

int GetClassFromLANG(int iLangIndex, wchar_t wChar)

{
	ENTRY *pEntry;
	pEntry = (ENTRY *)bsearch(&wChar, aPartition[iLangIndex].pEntry, aPartition[iLangIndex].cEntry,
		      sizeof(ENTRY), cmpEntry);
	if (!pEntry)
		return -1;
	else 
		return (pEntry->Class);
}

BOOL IsLatinLANG(int iLangIndex)
{
	return iLangIndex < 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\dnlblcnt.c ===
/******************************Module*Header*******************************\
* Module Name: dnlblcnt.c
*
* At train time we want to dynamically load the label count information
* from the data.  This module contains the code and data structures to do
* this.
*
* The code contained is train time only code, it should not be included
* to build hwxjpn.dll
*
* Created: 11-Apr-1997 15:15:39
* Author: Patrick Haluptzok patrickh
*
* Major rewrite to not read .c format
* Author: John Bennett jbenn
\**************************************************************************/

#include <stdlib.h>
#include "common.h"

typedef struct tagLABEL_CNT {
	wchar_t		dch;
	DWORD		count;
} LABEL_CNT;

static LABEL_CNT	*gpDynamicLabelCnt;
static int			giDynamicLabelCnt;

/******************************Public*Routine******************************\
* LoadDynamicNumberOfSamples
*
* Loads the count of samples from a C file.
*
* History:
*  14-Mar-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
*  04-Dec-1997 -by- John Bennett jbenn
* Major rewrite to not read .c format
\**************************************************************************/

BOOL
LoadDynamicNumberOfSamples(wchar_t *pFileName, FILE *pFileLog)
{
    FILE *fp;
    int iTemp,iTemp1,iTemp2;
    int iRet;

   	wchar_t	wszFullPath[_MAX_PATH];

	// Open label count file.
    fp = UtilOpen(pFileName, L"r", wszFullPath, _MAX_PATH);
    if (fp == NULL) {
        if (pFileLog) {
            fwprintf(pFileLog, L"FAILED to load %s !!!\n", pFileName);
        }

        return FALSE;
    }

	// Get count of labels.
    iRet = fwscanf(fp, L"%d\n", &giDynamicLabelCnt);
    if (iRet != 1) {
        fwprintf(pFileLog, L"Error reading %s\n", pFileName);
        return FALSE;
    }

	// Allocate memory for label counts.
    gpDynamicLabelCnt	= malloc(giDynamicLabelCnt * sizeof(LABEL_CNT));
	if (!gpDynamicLabelCnt) {
        fwprintf(pFileLog, L"Out of memory reading %s\n", pFileName);
        return FALSE;
    }

    for (iTemp = 0; iTemp < giDynamicLabelCnt; iTemp++) {
        iRet = fwscanf(fp, L"%x %d\n", &iTemp1, &iTemp2);
        if (iRet != 2) {
			fwprintf(pFileLog, L"Error reading %s\n", pFileName);
			return FALSE;
        }

        gpDynamicLabelCnt[iTemp].dch	= (wchar_t)iTemp1;
        gpDynamicLabelCnt[iTemp].count	= iTemp2;
    }

    fclose(fp);

    if (pFileLog) {
		if (giDynamicLabelCnt > 0) 
		{
			fwprintf(pFileLog, L"Loaded label counts: first %04X %d last %04X %d\n", 
				gpDynamicLabelCnt[0].dch,
				gpDynamicLabelCnt[0].count,
				gpDynamicLabelCnt[giDynamicLabelCnt - 1].dch,
				gpDynamicLabelCnt[giDynamicLabelCnt - 1].count
			);
		}
		else
		{
			fwprintf(pFileLog, L"Didn't load label counts.\n"); 
		}
    }

	return TRUE;
}

/******************************Public*Routine******************************\
* DynamicNumberOfSamples
*
* Returns the number of samples on which we trained for each glyph
*
* History:
*  Fri 14-Mar-1997 -by- Patrick Haluptzok [patrickh]
* Wrote it.
*  04-Dec-1997 -by- John Bennett jbenn
* Updated to use struct.  Also now takes dense code.
\**************************************************************************/
int
DynamicNumberOfSamples(wchar_t wCurrent)
{
    int     iMin;
    int     iMax;
    int     iNew;
    WORD    wNew;

    iMin = 0;
    iMax = giDynamicLabelCnt - 1;

    while (iMin < iMax)
    {
        iNew = (iMin + iMax) / 2;

        wNew = gpDynamicLabelCnt[iNew].dch;

        if (wNew < wCurrent) {
            iMin = iNew + 1;
            continue;
        } else if (wNew > wCurrent) {
            iMax = iNew - 1;
            continue;
        }

        return	gpDynamicLabelCnt[iNew].count;
    }

    return gpDynamicLabelCnt[iMin].dch == wCurrent ? gpDynamicLabelCnt[iMin].count : 1;
}

// Look up the given (possibly folded) dense code in the table, returning
// the count if it is found, or -1 if it is not found.
int
DynamicNumberOfSamplesInternal(wchar_t wCurrent)
{
    int     iMin;
    int     iMax;
    int     iNew;
    WORD    wNew;

    iMin = 0;
    iMax = giDynamicLabelCnt - 1;

    while (iMin < iMax)
    {
        iNew = (iMin + iMax) / 2;

        wNew = gpDynamicLabelCnt[iNew].dch;

        if (wNew < wCurrent) {
            iMin = iNew + 1;
            continue;
        } else if (wNew > wCurrent) {
            iMax = iNew - 1;
            continue;
        }

        return	gpDynamicLabelCnt[iNew].count;
    }

    return gpDynamicLabelCnt[iMin].dch == wCurrent ? gpDynamicLabelCnt[iMin].count : -1;
}

/******************************Public*Routine******************************\
* DynamicNumberOfSamplesFolded
*
* Returns the number of trainign samples for a dense code.  If the dense code is a folded
* code, then the counts for each component of the folding set are added.
\**************************************************************************/
int
DynamicNumberOfSamplesFolded(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	// First try to just look up the code in the table.
	int	c = DynamicNumberOfSamplesInternal(dch);

	// If we didn't find it, the cause may be that dch is a folded code,
	// and the table has not been updated with folded codes yet.
	if (c == -1 && LocRunIsFoldedCode(pLocRunInfo, dch)) {
		// If it is a folded code, look up the folding set
		wchar_t *pFoldingSet = LocRunFolded2FoldingSet(pLocRunInfo, dch);
		int i;

		// Run through the folding set, adding counts
		c = 0;
		for (i = 0; i < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[i] != 0; i++) {
			int cThis = DynamicNumberOfSamplesInternal(pFoldingSet[i]);
			if (cThis != -1) 
				c += cThis;
		}
	}

	// Return, and make sure the result is non-zero (for compatibility with the old code).
	return __max(c, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\confsetfl.c ===
#include "common.h"

#define		MAX_ENTRY_SIZE		1024
#define		COMMENT_STRING		L"//"

int ReadConfSetEntry	(	FILE	*fp, 
							wchar_t *pType, 
							int		*pCnt, 
							wchar_t **ppCodePoint,
							wchar_t	*pExtraInfo
						)
{
	wchar_t	wBuffer[MAX_ENTRY_SIZE], wTemp[10];
	wchar_t	*pwBuf;
	int		i, j, k, iLen;
	wchar_t	CodePoint;

	// EOF
	if (feof(fp))
		return 0;
	
	do
	{
		// read whole line
		if (!fgetws(wBuffer, MAX_ENTRY_SIZE - 1, fp))
		{
			swprintf(pExtraInfo, L"Failed to read line.");
			return -1;
		}

		// remove CR-LF
		if ( L'\n' != wBuffer[iLen-1] )
		{
			swprintf(pExtraInfo, L"Line too long.");
			return -1;
		}
		
		wBuffer[iLen-1] = L'\0';

		pwBuf = wBuffer;
		
		// Skip Commented lines or Blank Lines
		if	(	!pwBuf || !(*pwBuf) ||
				!wcsncmp(pBuf, COMMENT_STRING, wcslen(COMMENT_STRING))
			)
			continue;
		
		// skip white space
		while ((*pwBuf) && iswspace(*pwBuf))
			++pwBuf;

		// Skip Blank Lines
		if	(!pwBuf || !(*pwBuf))
			continue;
		
		// get set type
		switch (*pwBuf)
		{
			// valid set types
			case 'I':
			case 'S':
			case 'W':
			case 'A':
			case 'i':
			case 's':
			case 'w':
			case 'a':

				*pType = towupper (*pwBuf);
				pwBuf++;

			break

			default:
			{
				swprintf(pExtraInfo, L"Invalid set type.");
				return -1;
			}
		}

		// skip white space
		while ((*pwBuf) && iswspace(*pwBuf))
			++pwBuf;

		// incomplete line
		if	(!pwBuf || (*pwBuf) != L'{')
		{
			swprintf(pExtraInfo, L"Invalid format.");
			return -1;
		}

		++pwBuf;

		// init counter
		(*pCnt)		=	0;
		pExtraInfo	=	NULL;

		// read code points
		do
		{
			// skip white space
			while ((*pwBuf) && iswspace(*pwBuf))
				++pwBuf;

			// is this the end of the list
			if (*pwBuf == L'}')
			{
				// End of List
				++pwBuf;
				break;
			}

			// read the codepoint
			swscanf (pwBuf, L"%s ", aTemp);
			CodePoint	=	0;
			swscanf (aTemp, "%hx", &CodePoint);
			if (!CodePoint)
			{
				if ((*ppCodePoint))
					free ((*ppCodePoint));

				swprintf(pExtraInfo, L"Invalid codepoint.");
				return -1;
			}

			pwBuf += strlen (aTemp);

			// add to buffer
			(*ppCodePoint)	=	(wchar_t *)realloc ((*ppCodePoint), ((*pCnt) + 1) * sizeof (wchar_t));
			if (!(*ppCodePoint)
			{
				swprintf(pExtraInfo, L"Invalid codepoint.");
				return -1;
			}

			(*ppCodePoint)[(*pCnt)++] = CodePoint;
		}
		
		// set is empty
		if (!(*pCnt))
		{
			if ((*ppCodePoint))
				free ((*ppCodePoint));

			swprintf(pExtraInfo, L"Empty confusion set.");
			return -1;
		}

		// Bubble Sort the Codepoint list
		for (i = 0; i < ((*pCnt) - 1); i++)
		{
			for (j = i + 1; j < (*pCnt); j++)
			{
				if ((*ppCodePoint)[i] < (*ppCodePoint)[j])
				{
					k					= (*ppCodePoint)[i];
					(*ppCodePoint)[i]	= (*ppCodePoint)[j];
					(*ppCodePoint)[j]	= k;
				}
			}
		}

		// skip white space
		while ((*pwBuf) && iswspace(*pwBuf))
			++pwBuf;

		// point to extra info
		pwExtraInfo	= pwBuf;

		// success: an entry was read
		return 1;
	}
	while (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\header.c ===
/************************************************************************************************
 * FILE: header.c
 *
 * This is just a stub file prior to version 1 of locale
 *
 **********************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\loadfl.c ===
// Functions to map and unmap files from memory

#include <sys/stat.h>
#include "common.h"

// Open a file and map it into memory.  Return a pointer to
// the memory region
BYTE *DoOpenFile(LOAD_INFO *pInfo, wchar_t *pFileName)
{
	struct _stat buf;

	InitLoadInfo(pInfo);

    if (_wstat(pFileName, &buf) < 0) {
//        ASSERT(("Could not stat database file", FALSE));
        return NULL;
    }

	// Try to open the file.
	pInfo->hFile = CreateMappingCall(
		pFileName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (pInfo->hFile == INVALID_HANDLE_VALUE) {
//        ASSERT(("Error in CreateMappingCall", FALSE));
        return (BYTE *)0;
	}

	// Create a mapping handle
	pInfo->hMap = CreateFileMapping(pInfo->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (pInfo->hMap == NULL) {
		CloseHandle(pInfo->hFile);
		pInfo->hFile = INVALID_HANDLE_VALUE;
//        ASSERT(("Error in CreateFileMapping", FALSE));
        return (BYTE *)0;
	}

	// Map the entire file starting at the first byte
	pInfo->pbMapping = (BYTE *) MapViewOfFile(pInfo->hMap, FILE_MAP_READ, 0, 0, 0);
	if (pInfo->pbMapping == NULL) {
		CloseHandle(pInfo->hFile);
		CloseHandle(pInfo->hMap);
		pInfo->hFile = INVALID_HANDLE_VALUE;
		pInfo->hMap = INVALID_HANDLE_VALUE;
//        ASSERT(("Error in MapViewOfFile", FALSE));
        return NULL;
	}

	pInfo->iSize = buf.st_size;

	return pInfo->pbMapping;
}

BOOL DoCloseFile(LOAD_INFO *pInfo)
{
	if (pInfo->hFile == INVALID_HANDLE_VALUE ||
		pInfo->hMap == INVALID_HANDLE_VALUE ||
		pInfo->pbMapping == INVALID_HANDLE_VALUE) {
        ASSERT(("Attempted to unmap a file that is not mapped", FALSE));
        return FALSE;
	}

	UnmapViewOfFile(pInfo->pbMapping);
	CloseHandle(pInfo->hMap);
	CloseHandle(pInfo->hFile);

	pInfo->pbMapping = INVALID_HANDLE_VALUE;
	pInfo->hMap = INVALID_HANDLE_VALUE;
	pInfo->hFile = INVALID_HANDLE_VALUE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\locrungn.c ===
/************************************************************************************************
 * FILE: LocRunGn.c
 *
 *	Code to generate runtime localization tables in a binary file.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"


// Write a properly formated binary file containing the runtime localization information.
BOOL
LocRunWriteFile(LOCRUN_INFO *pLocRunInfo, FILE *pFile)
{
	LOCRUN_HEADER		header;
	DWORD				count;

	// Setup the header
	memset(&header, 0, sizeof(header));
	header.fileType				= LOCRUN_FILE_TYPE;
	header.headerSize			= sizeof(header);
	header.minFileVer			= LOCRUN_MIN_FILE_VERSION;
	header.curFileVer			= LOCRUN_CUR_FILE_VERSION;
	memcpy (header.adwSignature, pLocRunInfo->adwSignature, sizeof(pLocRunInfo->adwSignature));
	header.cCodePoints			= pLocRunInfo->cCodePoints;
	header.cALCSubranges		= pLocRunInfo->cALCSubranges;
	header.cFoldingSets			= pLocRunInfo->cFoldingSets;
	header.cClassesArraySize	= pLocRunInfo->cClassesArraySize;
	header.cClassesExcptSize	= pLocRunInfo->cClassesExcptSize;
	header.cBLineHgtArraySize	= pLocRunInfo->cBLineHgtArraySize;
	header.cBLineHgtExcptSize	= pLocRunInfo->cBLineHgtExcptSize;

	// Write it out.
	if (fwrite(&header, sizeof(header), 1, pFile) != 1) {
		goto error;
	}

	// Write out the Dense to Unicode map.  Note round up to even number of codes so data
	// stays word aligned.
	count	= header.cCodePoints;
	if (count & 1) {
		++count;
	}
	if (fwrite(pLocRunInfo->pDense2Unicode, sizeof(wchar_t), count, pFile) != count) {
		goto error;
	}
	
	// Write out the ALC Subrange specifications.
	count	= header.cALCSubranges;
	if (fwrite(pLocRunInfo->pALCSubranges, sizeof(LOCRUN_ALC_SUBRANGE), count, pFile) != count) {
		goto error;
	}
	
	// Write out the ALC values for first range.
	count	= pLocRunInfo->pALCSubranges[0].cCodesInRange;
	if (fwrite(pLocRunInfo->pSubrange0ALC, sizeof(ALC), count, pFile) != count) {
		goto error;
	}
	
	// Write out the Folding sets.
	count	= header.cFoldingSets;
	if (fwrite(pLocRunInfo->pFoldingSets, sizeof(WORD[LOCRUN_FOLD_MAX_ALTERNATES]), count, pFile)
		!= count
	) {
		goto error;
	}
	
	// Write out the merged ALCs for Folding sets.
	count	= header.cFoldingSets;
	if (fwrite(pLocRunInfo->pFoldingSetsALC, sizeof(ALC), count, pFile)
		!= count
	) {
		goto error;
	}

	// write the class and BLineHgt Array and Exception List buffers
	count	= header.cClassesArraySize;
	if (fwrite(pLocRunInfo->pClasses,1,count,pFile) != count) {
		goto error;
	}

	count	= header.cClassesExcptSize;
	if (fwrite(pLocRunInfo->pClassExcpts,1,count,pFile) != count) {
		goto error;
	}

	count	= header.cBLineHgtArraySize;
	if (fwrite(pLocRunInfo->pBLineHgtCodes,1,count,pFile) != count) {
		goto error;
	}

	count	= header.cBLineHgtExcptSize;
	if (fwrite(pLocRunInfo->pBLineHgtExcpts,1,count,pFile) != count) {
		goto error;
	}
	
	return TRUE;
error:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\locrunrs.c ===
/************************************************************************************************
 * FILE: LocRunRs.c
 *
 *	Code to load runtime localization tables from resources.
 *
 *	Also Code to load unigram and bigram tables from resources.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"

// Load runtime localization information from a resource.
BOOL
LocRunLoadRes(LOCRUN_INFO *pLocRunInfo, HINSTANCE hInst, int nResID, int nType)
{
	HRSRC			hres;
	HGLOBAL			hglb;
	void			*pRes;

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR)nResID, (LPCTSTR)nType);
	if (!hres) {
		goto error;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
		goto error;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (!pRes) {
		goto error;
	}

	return LocRunLoadPointer(pLocRunInfo, pRes);

error:
	return FALSE;
}

// Load unigram information from a resource.
BOOL
UnigramLoadRes(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, HINSTANCE hInst, int nResID, int nType)
{
	HRSRC			hres;
	HGLOBAL			hglb;
	void			*pRes;

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR)nResID, (LPCTSTR)nType);
	if (!hres) {
		goto error;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
		goto error;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (!pRes) {
		goto error;
	}

	return UnigramLoadPointer(pLocRunInfo, pUnigramInfo, pRes);

error:
	return FALSE;
}

// Load bigram information from a resource.
BOOL
BigramLoadRes(LOCRUN_INFO *pLocRunInfo, BIGRAM_INFO *pBigramInfo, HINSTANCE hInst, int nResID, int nType)
{
	HRSRC			hres;
	HGLOBAL			hglb;
	void			*pRes;

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR)nResID, (LPCTSTR)nType);
	if (!hres) {
		goto error;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
		goto error;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (!pRes) {
		goto error;
	}

	return BigramLoadPointer(pLocRunInfo, pBigramInfo, pRes);

error:
	return FALSE;
}


// Load Class bigram information from a resource.
BOOL
ClassBigramLoadRes(LOCRUN_INFO *pLocRunInfo, CLASS_BIGRAM_INFO *pBigramInfo, HINSTANCE hInst, int nResID, int nType)
{
	HRSRC			hres;
	HGLOBAL			hglb;
	void			*pRes;

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR)nResID, (LPCTSTR)nType);
	if (!hres) {
		goto error;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
		goto error;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (!pRes) {
		goto error;
	}

	return ClassBigramLoadPointer(pLocRunInfo, pBigramInfo, pRes);

error:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\loadrs.c ===
// Functions to locate resources in memory

#include "common.h"

// Initialize the structure holding mapping information
void InitLoadInfo(LOAD_INFO *pInfo)
{
	pInfo->hFile = INVALID_HANDLE_VALUE;
	pInfo->hMap = INVALID_HANDLE_VALUE;
	pInfo->pbMapping = INVALID_HANDLE_VALUE;
	pInfo->iSize = 0;
}

// Code to load and lock a resource.
BYTE *DoLoadResource(LOAD_INFO *pInfo, HINSTANCE hInst, int nResID, int nType)
{
	HRSRC		hres;
	HGLOBAL		hglb;
	void		*pRes;

	if (pInfo != NULL) {
    	InitLoadInfo(pInfo);
	}

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR)nResID, (LPCTSTR)nType);
	if (!hres) {
//        ASSERT(("Error in FindResource", FALSE));
        return (void *)0;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
//        ASSERT(("Error in LoadResource", FALSE));
        return (void *)0;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (!pRes) {
//        ASSERT(("Error in LockResource", FALSE));
        return (void *)0;
	}

	if (pInfo != NULL) {
		pInfo->pbMapping = pRes;
		pInfo->iSize = SizeofResource(hInst, hres);
	}

	return pRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\loctrn.c ===
/************************************************************************************************
 * FILE: LocTrn.c
 *
 *	Code to use the train time localization tables.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"

// Load train time localization information from an image already loaded into memory.
BOOL
LocTrainLoadPointer(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, void *pData)
{
	const LOCTRAIN_HEADER	*pHeader	= (LOCTRAIN_HEADER *)pData;
	BYTE					*pScan;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != LOCTRAIN_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > LOCTRAIN_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < LOCTRAIN_OLD_FILE_VERSION)
		|| memcmp (pHeader->adwSignature, pLocRunInfo->adwSignature,sizeof(pHeader->adwSignature))
	) {
		goto error;
	}

	// Fill in information from header.
	pLocTrainInfo->cCodePoints		= pHeader->cCodePoints;
	pLocTrainInfo->cStrokeCountInfo	= pHeader->cStrokeCountInfo;

	// Fill in pointers to the other data in the file
	pScan							= (BYTE *)pData + pHeader->headerSize;
	pLocTrainInfo->pUnicode2Dense	= (wchar_t *)pScan;
	pScan							= (BYTE *)pData + C_UNICODE_CODE_POINTS * sizeof(wchar_t);
	pLocTrainInfo->pStrokeCountInfo	= (STROKE_COUNT_INFO *)pScan;

	// Default unused values for file handle information
	pLocTrainInfo->pLoadInfo1		= INVALID_HANDLE_VALUE;
	pLocTrainInfo->pLoadInfo2		= INVALID_HANDLE_VALUE;
	pLocTrainInfo->pLoadInfo3		= INVALID_HANDLE_VALUE;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

error:
	return FALSE;
}

// Check if valid stroke count for character.  Takes dense code.
BOOL
LocTrainValidStrokeCount(LOCTRAIN_INFO *pLocTrainInfo, wchar_t dch, int cStrokes)
{
	STROKE_COUNT_INFO	*pSCI;

	// Check if we have an entry in the table.
	if (dch >= pLocTrainInfo->cStrokeCountInfo) {
		// No, assume OK.
		return TRUE;
	}

	// OK, look it up in the table.  We could put in special checks for the unknown
	// min and max values, but they are set up so that they just work.
	pSCI	= pLocTrainInfo->pStrokeCountInfo + dch;
	return (pSCI->minStrokes <= cStrokes && cStrokes <= pSCI->maxStrokes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\localep.h ===
// FILE: LocaleP.h
//
// Structures and functions internal to the library that are used to access the 
// localization information.
//
// There are two major pieces of this.  The first deals with stuff available to the runtime of
// shipped products (e.g. the recognizer).  The second is stuff needed at train time that we do
// not want in the shipped product (usually for size reasons).


/************************************************************************************************\
 *	Stuff for the product runtime, also used by all the other code.
\************************************************************************************************/

// The format of the runtime localizartion file is:
//		Header:
//			DWORD		File type indicator
//			DWORD		Size of header
//			BYTE		Lowest version this code that can read this file
//			BYTE		Version of this code that wrote this file
//			DWORD * 3	Signature of the source LOC file (see description below)
//			WORD		Number of supported code points (and size of Dense To Unicode map table).
//			BYTE		Number of subranges defined across Dense coding
//			BYTE		Number of folding sets defined
//			WORD		Size of the classes Array buffer
//			WORD		Size of the classes Exception list buffer
//			WORD		Size of the BLineHgt Array buffer
//			WORD		Size of the BLineHgt Exception list buffer
//			WORD		Reserved for future use
//			DWORD * 2	Reserved for future use
//		Dense to Unicode map:
//			wchar_t		One entry for each supported character as specified in header
//				.
//				.
//				.
//			wchar_t		If there is an odd number of entries, there is a 0 pad added to force alignment
//		ALC Subrange specifications:
//			{
//				WORD		first code in range
//				WORD		number of code points in range
//				ALC			ALC bits for range
//			}			One specifier for each range as specified in header
//				.
//				.
//				.
//		ALC values for first range (this overrides the ALC value specified for it):
//			ALC			ALC value for each code point in first range as specified above
//				.
//				.
//				.
//		Folding sets:
//			WORD * 6		Lists of characters to fold to gather.
//			WORD * 6		One list per folding set as specified in header
//			WORD * 6		Characters stored as Dense coded values.
//				.
//				.
//				.
//		Merged ALCs for folding sets:
//			DWORD			One ALC per folding set as specified in header	
//				.
//				.
//				.
//

//
// Constants
//

// Magic key the identifies the Local Runtime files
#define	LOCRUN_FILE_TYPE	0x82980561

// Version information for file.
#define	LOCRUN_MIN_FILE_VERSION		0		// First version of code that can read this file
#define LOCRUN_CUR_FILE_VERSION		0		// Current version of code.
#define	LOCRUN_OLD_FILE_VERSION		0		// Oldest file version this code can read.

//
// Structures and types
//

// The header of the locrun.bin file
typedef struct tagLOCRUN_HEADER {
	DWORD		fileType;			// This should always be set to LOCRUN_FILE_TYPE.
	DWORD		headerSize;			// Size of the header.
	BYTE		minFileVer;			// Earliest version of code that can read this file
	BYTE		curFileVer;			// Current version of code that wrote the file.
	DWORD		adwSignature [3];	// A signature computed form the loc info
									// DWORD0:	Date/Time Stamp (time_t)
									// DWORD1:	XORING ALC values for all CPs
									// DWORD2	HIWORD: XORING ALL Valid CPs
									//			LOWORD: XORING ALL BasLn,Hgt Info
	WORD		cCodePoints;		// Number of supported code points.
	BYTE		cALCSubranges;		// Number of subranges defined across Dense coding
	BYTE		cFoldingSets;		// Number of folding sets defined
	WORD		cClassesArraySize;	// The size of the classes Array buffer
	WORD		cClassesExcptSize;	// The size of the classes Exception list buffer
	WORD		cBLineHgtArraySize;	// The size of the BLineHgt Array buffer
	WORD		cBLineHgtExcptSize;	// The size of the BLineHgt Exception list buffer
	WORD		reserved1;
	DWORD		reserved2[2];
} LOCRUN_HEADER;

/************************************************************************************************\
 *	Stuff for the training programs, not to be used by product code.
\************************************************************************************************/

// The format of the train time localizartion file is:
//		Header:
//			DWORD				File type indicator
//			DWORD				Size of header
//			BYTE				Lowest version this code that can read this file
//			BYTE				Version of this code that wrote this file
//			DWORD * 3	Signature of the source LOC file (see locale.h for description)
//			WORD				Number of supported code points.
//			WORD				Number of stroke info structures
//			WORD				Reserved for future use
//			DWORD * 4			Reserved for future use
//		Unicode to Dense map:
//			wchar_t				64K entries FFFF indicates an invalid entry.
//				.
//				.
//				.
//		Stroke infomation:
//			STROKE_COUNT_INFO	Min and max stroke counts for code 0.
//			STROKE_COUNT_INFO	Min and max stroke counts for code 1.
//				.
//				.
//				.

//
// Constants
//

// Magic key the identifies the Localization training time files
#define	LOCTRAIN_FILE_TYPE	0x16508928

// Version information for file.
#define	LOCTRAIN_MIN_FILE_VERSION		0		// First version of code that can read this file
#define LOCTRAIN_CUR_FILE_VERSION		1		// Current version of code.
#define LOCTRAIN_OLD_FILE_VERSION		1		// Oldest version current code can read.

// Macros needed for CODEPOINT_CLASSes
// Determine whether the CODEPOINT CLASS Info for that subrange
// is stored as any Exception or not
#define	LocRunIsClassException(pLocRunInfo, iRange) (				\
	(pLocRunInfo->pALCSubranges[iRange].clHeader.iFlags & 0x8000)	\
)

// Get the number of excptions for CODEPOINT classes
// for a subrange
#define	LocRunClassNumExceptions(pLocRunInfo, iRange)	(				\
	((pLocRunInfo)->pALCSubranges[iRange].clHeader.iFlags & 0x7F00)>>8	\
)

// Get the default code for CODEPOINT classes
// for a subrange
#define	LocRunClassDefaultCode(pLocRunInfo, iRange)	(				\
	(pLocRunInfo)->pALCSubranges[iRange].clHeader.iFlags & 0x00FF	\
)

// Macros needed for BLINEGHGT
// Determine whether the BLINE_HEIGHT Info for that subrange
// is stored as an Exception or not
#define	LocRunIsRangeBLineHgtException(pLocRunInfo, iRange)	(		\
	(pLocRunInfo)->pALCSubranges[iRange].blhHeader.iFlags & 0x8000	\
)

// Get the number of excptions for BLINE_HEIGHT
// for a subrange
#define	LocRunBLineHgtNumExceptions(pLocRunInfo, iRange)	(			\
	((pLocRunInfo)->pALCSubranges[iRange].blhHeader.iFlags & 0x7F00)>>8 \
)

// Get the default code for BLINE_HEIGHT
// for a subrange
#define	LocRunBLineHgtDefaultCode(pLocRunInfo, iRange)	(			\
	(pLocRunInfo)->pALCSubranges[iRange].blhHeader.iFlags & 0x00FF	\
)


//
// Structures and types
//

// The header of the loctrain.bin file
typedef struct tagLOCTRAIN_HEADER {
	DWORD		fileType;			// This should always be set to LOCTRAIN_FILE_TYPE.
	DWORD		headerSize;			// Size of the header.
	BYTE		minFileVer;			// Earliest version of code that can read this file
	BYTE		curFileVer;			// Current version of code that wrote the file.
	DWORD		adwSignature[3];	// The current signature of the file (see above description)
	WORD		cCodePoints;		// Number of supported code points.
	WORD		cStrokeCountInfo;	// Number of stroke info structures.
	WORD		reserved1;
	DWORD		reserved2[4];
} LOCTRAIN_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\locrun.c ===
/************************************************************************************************
 * FILE: LocRun.c
 *
 *	Code to use the runtime localization tables.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"

// Load runtime localization information from an image already loaded into memory.
BOOL
LocRunLoadPointer(LOCRUN_INFO *pLocRunInfo, void *pData)
{
	const LOCRUN_HEADER	*pHeader	= (LOCRUN_HEADER *)pData;
	BYTE				*pScan;
	DWORD				count;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != LOCRUN_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > LOCRUN_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < LOCRUN_OLD_FILE_VERSION)
	) {
		goto error;
	}

	// copy signature
	memcpy (pLocRunInfo->adwSignature , pHeader->adwSignature, sizeof(pLocRunInfo->adwSignature));

	// Fill in information from header.
	pLocRunInfo->cCodePoints		= pHeader->cCodePoints;
	pLocRunInfo->cALCSubranges		= pHeader->cALCSubranges;
	pLocRunInfo->cFoldingSets		= pHeader->cFoldingSets;
	pLocRunInfo->cClassesArraySize	= pHeader->cClassesArraySize;
	pLocRunInfo->cClassesExcptSize	= pHeader->cClassesExcptSize;
	pLocRunInfo->cBLineHgtArraySize	= pHeader->cBLineHgtArraySize;
	pLocRunInfo->cBLineHgtExcptSize	= pHeader->cBLineHgtExcptSize;

	// Fill in pointers to the other data in the file
	pScan							= (BYTE *)pData + pHeader->headerSize;
	pLocRunInfo->pDense2Unicode		= (wchar_t *)pScan;

	// Note round up to even number of codes so data
	// stays word aligned. We did that during writing, so we do it here
	count	= pHeader->cCodePoints;
	if (count & 1) {
		++count;
	}
	
	pScan							+= sizeof(wchar_t) * count;
	pLocRunInfo->pALCSubranges		= (LOCRUN_ALC_SUBRANGE *)pScan;
	pScan							+= sizeof(LOCRUN_ALC_SUBRANGE) * pHeader->cALCSubranges;
	pLocRunInfo->pSubrange0ALC		= (ALC *)pScan;
	pScan							+= sizeof(ALC) * pLocRunInfo->pALCSubranges[0].cCodesInRange;
	pLocRunInfo->pFoldingSets		= (LOCRUN_FOLDING_SET *)pScan;
	pScan							+= sizeof(LOCRUN_FOLDING_SET) * pHeader->cFoldingSets;
	pLocRunInfo->pFoldingSetsALC	= (ALC *)pScan;
	pScan							+= sizeof(ALC) * pHeader->cFoldingSets;
	pLocRunInfo->pClasses			= (CODEPOINT_CLASS *)pScan;
	pScan							+= pHeader->cClassesArraySize;
	pLocRunInfo->pClassExcpts		= (BYTE *)pScan;
	pScan							+= pHeader->cClassesExcptSize;
	pLocRunInfo->pBLineHgtCodes		= (BLINE_HEIGHT *)pScan;
	pScan							+= pHeader->cBLineHgtArraySize;
	pLocRunInfo->pBLineHgtExcpts	= (BYTE *)pScan;
	pScan							+= pHeader->cBLineHgtExcptSize;

	// Default unused values for file handle information
	pLocRunInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pLocRunInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pLocRunInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

error:
	return FALSE;
}


// Get ALC value for a Dence coded character
ALC
LocRunDense2ALC(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	int		ii;
	ALC		ascii = 0;
	wchar_t	wch;

	// Make sure we have a valid code.
	if (dch >= pLocRunInfo->cCodePoints) {
		goto error;
	}

	wch = LocRunDense2Unicode(pLocRunInfo, dch);
	if (wch >= 0x20 && wch <= 0x7e) {
		ascii = ALC_ASCII;
	}

	// See if it is in the first range.
	if (dch < pLocRunInfo->pALCSubranges[1].iFirstCode) {
		// OK, answer is in the table.
		return pLocRunInfo->pSubrange0ALC[dch] | ascii;
	}

	// OK, which range is it in.
	for (ii = pLocRunInfo->cALCSubranges - 1; ii > 1 ; --ii) {
		if (pLocRunInfo->pALCSubranges[ii].iFirstCode <= dch) {
			break;
		}
	}

	// Now return ALC for that range.
	return pLocRunInfo->pALCSubranges[ii].alcRange | ascii;

error:
	return (ALC)0;
}

// Get ALC value for a folded character
ALC
LocRunFolded2ALC(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	wchar_t		fch;
	ALC			ascii = 0;
	int			kndex;
	wchar_t		*pFoldingSet;

	fch		= dch - pLocRunInfo->cCodePoints;

	// Make sure we have a valid code.
	if (dch < pLocRunInfo->cCodePoints || pLocRunInfo->cFoldingSets < fch) {
		goto error;
	}

	// If it is a folded code, look up the folding set
	pFoldingSet = LocRunFolded2FoldingSet(pLocRunInfo, dch);

	// Run through the folding set, checking the unicode values of non-NUL items
	for (kndex = 0; kndex < LOCRUN_FOLD_MAX_ALTERNATES; kndex++)
		if (pFoldingSet[kndex]) {
			wchar_t wch = LocRunDense2Unicode(pLocRunInfo, pFoldingSet[kndex]);
			if (wch >= 0x20 && wch <= 0x7e) {
				ascii = ALC_ASCII;
				break;
			}
		}

	// Ok pull value out of the table.
	return pLocRunInfo->pFoldingSetsALC[fch] | ascii;

error:
	return (ALC)0;
}

// Convert Unicode to Dense code.
wchar_t	LocRunDense2Folded(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	WORD	iMatch, iToken;

	for (iToken = 0; iToken < pLocRunInfo->cFoldingSets; iToken++)
	{
		for (iMatch = 0; iMatch < LOCRUN_FOLD_MAX_ALTERNATES; iMatch++)
		{
			if (pLocRunInfo->pFoldingSets[iToken][iMatch] == 0) {
				break;
			} else if (pLocRunInfo->pFoldingSets[iToken][iMatch] == dch) {
				return pLocRunInfo->cCodePoints + iToken;
			}
		}
	}

	return 0;
}

// Convert from Dense coding to Unicode.  
// WARNING: this is expensive.  For code outside the runtime recognizer, use the 
// LocTranUnicode2Dense function.  For the recognizer, you have to use this, but use
// it as little as possable.
wchar_t
LocRunUnicode2Dense(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	int		ii;

	for (ii = 0; ii < pLocRunInfo->cCodePoints; ++ii) {
		if (pLocRunInfo->pDense2Unicode[ii] == dch) {
			return (wchar_t)ii;
		}
	}

	return LOC_TRAIN_NO_DENSE_CODE;
}

// Convert a dense coded character to its character class.
CODEPOINT_CLASS 
LocRunDensecode2Class(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	int							iRange,iCode;
	int							iExcpt,cNumExcpt;
	CODEPOINT_CLASS_EXCEPTION	*pExcpt;
	BYTE						*ptr;
	WORD						cOffset;
	UNALIGNED WORD				*pw;

	// Find the subrange that densecode belongs to
	for (iRange = pLocRunInfo->cALCSubranges - 1; iRange >= 0 ; --iRange) {
		if (pLocRunInfo->pALCSubranges[iRange].iFirstCode <= dch) {
			break;
		}
	}

	// could not find range , return error
	if (iRange<0) {
		return LOC_RUN_NO_CLASS;
	}

	// Determine whether the class info is stored as arrays or exception
	// check the 1st bit of the flag
	// Array
	if (!LocRunIsClassException(pLocRunInfo,iRange)) {
		// determine offset in bytes
		cOffset=dch-pLocRunInfo->pALCSubranges[iRange].iFirstCode
			+pLocRunInfo->pALCSubranges[iRange].clHeader.iOffset;
		
		// check that the offset is bot beyond the sizeof the array
		if (cOffset>=pLocRunInfo->cClassesArraySize) {
			return LOC_RUN_NO_CLASS;
		}

		// type cast the offset pointer to the CODEPOINT_CLASS
		// we do not always gurantee CODEPOINT_CLASS is a BYTE
		ptr=pLocRunInfo->pClasses+cOffset;
		return *((CODEPOINT_CLASS *)ptr);
	}// Array
	// exception List
	else {
		// point to the beginning of the buffer
		ptr=pLocRunInfo->pClassExcpts
			+pLocRunInfo->pALCSubranges[iRange].clHeader.iOffset;

		// number of exceptions
		cNumExcpt=LocRunClassNumExceptions(pLocRunInfo,iRange);

		// try to find the code in the exception list
		for (iExcpt=0;iExcpt<cNumExcpt;iExcpt++) {
			// point to the exception structure
			pExcpt=(CODEPOINT_CLASS_EXCEPTION *)ptr;
			pw = pExcpt->wDenseCode;

			// go thru all codes
			for (iCode=0;iCode<pExcpt->cNumEntries;iCode++) {
				// found it
				if (pw[iCode]==dch) {
					return pExcpt->clCode;
				}
			}// iCode

			// incr ptr
			ptr=(BYTE *)(pExcpt->wDenseCode+(pExcpt->cNumEntries*sizeof(wchar_t)));
		}// iExcpt

		// if it was not found in any exception list return default
		return (CODEPOINT_CLASS)LocRunClassDefaultCode(pLocRunInfo,iRange);
	}// Exception List
}

// Get the BLineHgt code for a specific dense code
BLINE_HEIGHT 
LocRunDense2BLineHgt (LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	int							iRange,iCode;
	int							iExcpt,cNumExcpt;
	BLINE_HEIGHT_EXCEPTION		*pExcpt;
	BYTE						*ptr;
	WORD						cOffset;
	UNALIGNED WORD				*pw;

	// Find the subrange that densecode belongs to
	for (iRange = pLocRunInfo->cALCSubranges - 1; iRange >= 0 ; --iRange) {
		if (pLocRunInfo->pALCSubranges[iRange].iFirstCode <= dch) {
			break;
		}
	}

	// could not find range , return error
	if (iRange<0) {
		return LOC_RUN_NO_BLINEHGT;
	}

	// Determine whether the BLineHgt info is stored as arrays or exception
	// check the 1st bit of the flag
	// Array
	if (!LocRunIsRangeBLineHgtException(pLocRunInfo,iRange)) {
		// determine offset in bytes
		cOffset=dch-pLocRunInfo->pALCSubranges[iRange].iFirstCode
			+pLocRunInfo->pALCSubranges[iRange].blhHeader.iOffset;
		
		// check that the offset is bot beyond the sizeof the array
		if (cOffset>=pLocRunInfo->cBLineHgtArraySize) {
			return LOC_RUN_NO_BLINEHGT;
		}

		// type cast the offset pointer to the BLINE_HEIGHT
		// we do not always gurantee BLINE_HEIGHT is a BYTE
		ptr=pLocRunInfo->pBLineHgtCodes+cOffset;
		return *((BLINE_HEIGHT *)ptr);
	}// Array
	// exception List
	else {
		// point to the beginning of the buffer
		ptr=pLocRunInfo->pBLineHgtExcpts
			+pLocRunInfo->pALCSubranges[iRange].blhHeader.iOffset;

		// number of exceptions
		cNumExcpt=LocRunBLineHgtNumExceptions (pLocRunInfo,iRange);

		// try to find the code in the exception list
		for (iExcpt=0;iExcpt<cNumExcpt;iExcpt++) {
			// point to the exception structure
			pExcpt=(BLINE_HEIGHT_EXCEPTION *)ptr;
			ptr+=(sizeof(BLINE_HEIGHT_EXCEPTION)-sizeof(wchar_t));
			pw = pExcpt->wDenseCode;

			// go thru all codes
			for (iCode=0;iCode<pExcpt->cNumEntries;iCode++) {
				// found it
				if (pw[iCode]==dch) {
					return pExcpt->blhCode;
				}

				// incr ptr
				ptr+=sizeof(wchar_t);
			}// iCode
		}// iExcpt

		// if it was not found in any exception list return default
		return (BLINE_HEIGHT)LocRunBLineHgtDefaultCode(pLocRunInfo,iRange);
	}// Exception List
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\locrunfl.c ===
/***********************************************************************************************\
 * FILE: LocRunFl.c
 *
 *	Code to load and unload runtime localization tables from files.
 *
 *	Also includes code to load and unload unigram and bigram tables from files.
 *
\***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"

// Copy a Unicode string, returning the pointer to the null at the end of the destination str.
static wchar_t *
WStrCpyPtr(wchar_t *pDest, wchar_t *pSrc)
{
	while (*pDest++ = *pSrc++)
		;
	
	return pDest - 1;
}

// This does the smart generation of the path for a file in the configuration directory.
// It takes the path to the root of the build trie, the base path in the build tree,
// the locale, the configuration and the filename.  This drops any part not specified.
void
FormatPath(
	wchar_t *pPath,
	wchar_t *pRoot,
	wchar_t *pBaseDir,
	wchar_t *pLocaleName,
	wchar_t *pConfigName,
	wchar_t *pFileName
) {
	BOOL	fNeedSep = FALSE;
	wchar_t	*pScan;

	// Conditionaly copy over each part, adding a '\' between each part.
	pScan		= pPath;
	if (pRoot) {
		pScan		= WStrCpyPtr(pScan, pRoot);
		fNeedSep	= TRUE;
	}
	if (pBaseDir) {
		if (fNeedSep) {
			*pScan++	= L'\\';
		}
		pScan		= WStrCpyPtr(pScan, pBaseDir);
		fNeedSep	= TRUE;
	}
	if (pLocaleName) {
		if (fNeedSep) {
			*pScan++	= L'\\';
		}
		pScan		= WStrCpyPtr(pScan, pLocaleName);
		fNeedSep	= TRUE;
	}
	if (pConfigName) {
		if (fNeedSep) {
			*pScan++	= L'\\';
		}
		pScan		= WStrCpyPtr(pScan, pConfigName);
		fNeedSep	= TRUE;
	}
	if (pFileName) {
		if (fNeedSep) {
			*pScan++	= L'\\';
		}
		pScan		= WStrCpyPtr(pScan, pFileName);
		fNeedSep	= TRUE;
	}
	*pScan	= L'\0';	// Terminate the string.
}

// Load runtime localization information from a file.
BOOL
LocRunLoadFile(LOCRUN_INFO *pLocRunInfo, wchar_t *pPath)
{
	wchar_t			aFullName[128];
	HANDLE			hFile, hMap;
	BYTE			*pByte;

	// Generate path to file.
	FormatPath(aFullName, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"locrun.bin");

	// Try to open the file.
	hFile = CreateMappingCall(
		aFullName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		// DWORD		errCode;

		// errCode	= GetLastError();
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		goto error3;
	}

	// Extract info from mapped data.
	if (!LocRunLoadPointer(pLocRunInfo, pByte)) {
		goto error3;
	}

	// Save away the pointers so we can close up cleanly latter
	pLocRunInfo->pLoadInfo1 = hFile;
	pLocRunInfo->pLoadInfo2 = hMap;
	pLocRunInfo->pLoadInfo3 = pByte;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	memset(pLocRunInfo, 0, sizeof(*pLocRunInfo));
	pLocRunInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pLocRunInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pLocRunInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return FALSE;
}

// Unload runtime localization information that was loaded from a file.
BOOL
LocRunUnloadFile(LOCRUN_INFO *pLocRunInfo)
{
	if (
		(pLocRunInfo->pLoadInfo1 == INVALID_HANDLE_VALUE)
		|| (pLocRunInfo->pLoadInfo2 == INVALID_HANDLE_VALUE)
		|| (pLocRunInfo->pLoadInfo3 == INVALID_HANDLE_VALUE)
	) {
		return FALSE;
	}

	UnmapViewOfFile((BYTE *)pLocRunInfo->pLoadInfo3);
	CloseHandle((HANDLE)pLocRunInfo->pLoadInfo2);
	CloseHandle((HANDLE)pLocRunInfo->pLoadInfo1);

	pLocRunInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pLocRunInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pLocRunInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return TRUE;
}

// Load unigram information from a file.
BOOL
UnigramLoadFile(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, wchar_t *pPath)
{
	wchar_t			aFullName[128];
	HANDLE			hFile, hMap;
	BYTE			*pByte;

	// Generate path to file.
	FormatPath(aFullName, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"unigram.bin");

	// Try to open the file.
	hFile = CreateMappingCall(
		aFullName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		// DWORD		errCode;

		// errCode	= GetLastError();
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		goto error3;
	}

	// Extract info from mapped data.
	if (!UnigramLoadPointer(pLocRunInfo, pUnigramInfo, pByte)) {
		goto error3;
	}

	// Save away the pointers so we can close up cleanly latter
	pUnigramInfo->pLoadInfo1 = hFile;
	pUnigramInfo->pLoadInfo2 = hMap;
	pUnigramInfo->pLoadInfo3 = pByte;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	memset(pUnigramInfo, 0, sizeof(*pUnigramInfo));
	pUnigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pUnigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pUnigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return FALSE;
}

// Unload runtime localization information that was loaded from a file.
BOOL
UnigramUnloadFile(UNIGRAM_INFO *pUnigramInfo)
{
	if (
		(pUnigramInfo->pLoadInfo1 == INVALID_HANDLE_VALUE)
		|| (pUnigramInfo->pLoadInfo2 == INVALID_HANDLE_VALUE)
		|| (pUnigramInfo->pLoadInfo3 == INVALID_HANDLE_VALUE)
	) {
		return FALSE;
	}

	UnmapViewOfFile((BYTE *)pUnigramInfo->pLoadInfo3);
	CloseHandle((HANDLE)pUnigramInfo->pLoadInfo2);
	CloseHandle((HANDLE)pUnigramInfo->pLoadInfo1);

	pUnigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pUnigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pUnigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return TRUE;
}

// Load bigram information from a file.
BOOL
BigramLoadFile(LOCRUN_INFO *pLocRunInfo, BIGRAM_INFO *pBigramInfo, wchar_t *pPath)
{
	wchar_t			aFullName[128];
	HANDLE			hFile, hMap;
	BYTE			*pByte;

	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	FormatPath(aFullName, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"bigram.bin");

	// Try to open the file.
	hFile = CreateMappingCall(
		aFullName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		// DWORD		errCode;

		// errCode	= GetLastError();
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		goto error3;
	}

	// Extract info from mapped data.
	if (!BigramLoadPointer(pLocRunInfo, pBigramInfo, pByte)) {
		goto error3;
	}

	// Save away the pointers so we can close up cleanly latter
	pBigramInfo->pLoadInfo1 = hFile;
	pBigramInfo->pLoadInfo2 = hMap;
	pBigramInfo->pLoadInfo3 = pByte;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	memset(pBigramInfo, 0, sizeof(*pBigramInfo));
	pBigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pBigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pBigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return FALSE;
}

// Unload runtime localization information that was loaded from a file.
BOOL
BigramUnloadFile(BIGRAM_INFO *pBigramInfo)
{
	if (
		(pBigramInfo->pLoadInfo1 == INVALID_HANDLE_VALUE)
		|| (pBigramInfo->pLoadInfo2 == INVALID_HANDLE_VALUE)
		|| (pBigramInfo->pLoadInfo3 == INVALID_HANDLE_VALUE)
	) {
		return FALSE;
	}

	UnmapViewOfFile((BYTE *)pBigramInfo->pLoadInfo3);
	CloseHandle((HANDLE)pBigramInfo->pLoadInfo2);
	CloseHandle((HANDLE)pBigramInfo->pLoadInfo1);

	pBigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pBigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pBigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return TRUE;
}

// Load class bigram information from a file.
BOOL
ClassBigramLoadFile(LOCRUN_INFO *pLocRunInfo, CLASS_BIGRAM_INFO *pClBigramInfo, wchar_t *pPath)
{
	wchar_t			aFullName[128];
	HANDLE			hFile, hMap;
	BYTE			*pByte;

	// Generate path to file.  By passing in name as "locale" we can get FormatPath
	// to do what we want.
	FormatPath(aFullName, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"clbigram.bin");

	// Try to open the file.
	hFile = CreateMappingCall(
		aFullName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		// DWORD		errCode;

		// errCode	= GetLastError();
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		goto error3;
	}

	// Extract info from mapped data.
	if (!ClassBigramLoadPointer(pLocRunInfo, pClBigramInfo, pByte)) {
		goto error3;
	}

	// Save away the pointers so we can close up cleanly latter
	pClBigramInfo->pLoadInfo1 = hFile;
	pClBigramInfo->pLoadInfo2 = hMap;
	pClBigramInfo->pLoadInfo3 = pByte;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	memset(pClBigramInfo, 0, sizeof(*pClBigramInfo));
	pClBigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pClBigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pClBigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return FALSE;
}

// Unload class bigram information that was loaded from a file.
BOOL 
ClassBigramUnloadFile(CLASS_BIGRAM_INFO *pClBigramInfo)
{
	if (
		(pClBigramInfo->pLoadInfo1 == INVALID_HANDLE_VALUE)
		|| (pClBigramInfo->pLoadInfo2 == INVALID_HANDLE_VALUE)
		|| (pClBigramInfo->pLoadInfo3 == INVALID_HANDLE_VALUE)
	) {
		return FALSE;
	}

	UnmapViewOfFile((BYTE *)pClBigramInfo->pLoadInfo3);
	CloseHandle((HANDLE)pClBigramInfo->pLoadInfo2);
	CloseHandle((HANDLE)pClBigramInfo->pLoadInfo1);

	pClBigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pClBigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pClBigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\loctrnrs.c ===
/************************************************************************************************
 * FILE: LocTrnRs.c
 *
 *	Code to load and unload train time localization tables from resources.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"

// Load train time localization information from a resource.
BOOL
LocTrainLoadRes(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, HINSTANCE hInst, int nResID, int nType)
{
	HRSRC			hres;
	HGLOBAL			hglb;
	void			*pRes;

	// Find the resource
	hres = FindResource(hInst, (LPCTSTR) nResID, (LPCTSTR) nType);
	if (!hres) {
		goto error;
	}

	// Load it
	hglb = LoadResource(hInst, hres);
	if (!hglb) {
		goto error;
	}

	// Lock it in memory
	pRes = LockResource(hglb);
	if (pRes) {
		goto error;
	}

	return LocTrainLoadPointer(pLocRunInfo, pLocTrainInfo, pRes);

error:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\math16.c ===
#include "common.h"
#include "math16.h"

/* Wecker's div; debugged by AGuha */
FIXED16_16 Div16(FIXED16_16 iX, FIXED16_16 iY)
{
    BOOL    fSign;
    DWORD   dwX;
    DWORD   dwY;
    int     iXShft;
    int     iYShft;
    int     iShiftLeft;
    DWORD   dwVal;

    // Handle 0
    if (iY == 0) 
	{
		if (iX == 0)	    return 0;
		else if (iX < 0)    return 0x80000000;
		else				return 0x7FFFFFFF;
    }
	
    // Remember sign

    fSign    = FALSE;
    if (iX < 0) 
	{
		iX					= -iX;
		if (iY > 0)	fSign   = TRUE;
		else		iY		= -iY;
    }
    else if (iY < 0) 
	{
		iY	 = -iY;
		fSign	 = TRUE;
    }

    dwX          = (DWORD) iX;
    dwY          = (DWORD) iY;

    // Guess at avail bits

    iXShft       = 32 - Need(dwX);
    iYShft       = Need(dwY);
    iShiftLeft   = SHFTBITS;
    
    // Move numerator as far as we can (and need)
    //int	    iXShft	     = 32 - iXNeed;
    if (iXShft >= iShiftLeft)	
		iXShft		     = iShiftLeft;

    iShiftLeft		    -= iXShft;

    if (iYShft > iShiftLeft) 
	{
		iYShft		     = iShiftLeft;
		iShiftLeft	     = 0;
    }
	else
		iYShft = 0;
    
    if (iXShft)	    dwX	   <<= iXShft;
    if (iYShft)	    dwY	   >>= iYShft;
    dwVal          = dwX / dwY;
    if (iShiftLeft) dwVal <<= iShiftLeft;
    
    if (fSign)	
        return -((int) dwVal);
    else	
        return  ((int) dwVal);
}


#define	NUMSIG	256
const int piSigmoid[NUMSIG+1] = {			// From 0.0 to 9.0
    32768, 33344, 33920, 34494, 35068, 35641, 36211, 36780, 37346, 37909,
    38469, 39026, 39579, 40128, 40673, 41213, 41748, 42279, 42803, 43322,
    43836, 44343, 44844, 45338, 45826, 46307, 46782, 47249, 47709, 48161,
    48606, 49044, 49474, 49897, 50311, 50718, 51118, 51509, 51893, 52269,
    52637, 52997, 53350, 53695, 54032, 54362, 54684, 54998, 55306, 55605,
    55898, 56183, 56462, 56733, 56998, 57255, 57506, 57751, 57989, 58220,
    58446, 58665, 58878, 59086, 59287, 59483, 59674, 59858, 60038, 60213,
    60382, 60547, 60706, 60861, 61012, 61157, 61299, 61436, 61569, 61698,
    61823, 61944, 62062, 62176, 62286, 62393, 62497, 62597, 62694, 62788,
    62879, 62967, 63053, 63135, 63215, 63293, 63368, 63440, 63510, 63578,
    63644, 63707, 63769, 63828, 63886, 63941, 63995, 64047, 64098, 64146,
    64193, 64239, 64283, 64325, 64366, 64406, 64444, 64481, 64517, 64552,
    64585, 64618, 64649, 64679, 64709, 64737, 64764, 64790, 64816, 64841,
    64864, 64887, 64910, 64931, 64952, 64972, 64991, 65010, 65028, 65045,
    65062, 65078, 65094, 65109, 65124, 65138, 65152, 65165, 65178, 65190,
    65202, 65213, 65224, 65235, 65245, 65255, 65265, 65274, 65283, 65292,
    65300, 65309, 65316, 65324, 65331, 65338, 65345, 65352, 65358, 65364,
    65370, 65376, 65381, 65387, 65392, 65397, 65402, 65406, 65411, 65415,
    65419, 65423, 65427, 65431, 65435, 65438, 65441, 65445, 65448, 65451,
    65454, 65457, 65459, 65462, 65465, 65467, 65469, 65472, 65474, 65476,
    65478, 65480, 65482, 65484, 65486, 65487, 65489, 65491, 65492, 65494,
    65495, 65497, 65498, 65499, 65501, 65502, 65503, 65504, 65505, 65506,
    65507, 65508, 65509, 65510, 65511, 65512, 65513, 65514, 65514, 65515,
    65516, 65517, 65517, 65518, 65518, 65519, 65520, 65520, 65521, 65521,
    65522, 65522, 65523, 65523, 65524, 65524, 65525, 65525, 65525, 65526,
    65526, 65526, 65527, 65527, 65527, 65528, 65535,
};

FIXED16_16 Sigmoid16(FIXED16_16 iX)
{
    BOOL    fNeg;
    int iIdx;
    int iFrc;
    int iY1;
    int iY2;
    int iY;

    if (iX < 0)	{
	fNeg	 = TRUE;
	iX	 = -iX;
    }
    else fNeg	 = FALSE;
	
    // End of the range?
    if (iX >= LSHFT(9)) {
	if (fNeg)   return 0;
	else	    return LSHFT(1);
    }
    
    iX			    *= NUMSIG;
    iX			    /= 9;
    iIdx             = RSHFT(iX);
    iFrc             = LOWBITS(iX) >> 8;
    iY1          = piSigmoid[iIdx++];
    iY2          = piSigmoid[iIdx];
    iY   = (iY1 * (256-iFrc) + iY2 * iFrc) >> 8;
    if (fNeg)	return LSHFT(1) - iY;
    else	return iY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\mathx.c ===
#include "mathx.h"
#include <math.h>

//	Array of angles in degrees associated with arctan values

const char arctan_array[] =
{
    0,	 1,	 1,	 2,	 2,	 3,	 3,	 4,	 5,	 5,
	6,	 6,	 7,	 7,	 8,	 9,	 9,	10,	10,	11,
	11, 12,	12,	13,	13,	14,	15,	15,	16,	16,
	17,	17,	18,	18,	19,	19,	20,	20,	21,	21,
	22,	22,	23,	23,	24,	24,	25,	25,	26,	26,
	27,	27,	27,	28,	28,	29,	29,	30,	30,	31,
	31,	31,	32,	32,	33,	33,	33,	34,	34,	35,
	35,	35,	36,	36,	37,	37,	37,	38,	38,	38,
	39,	39,	39,	40,	40,	40,	41,	41,	41,	42,
	42,	42,	43,	43,	43,	44,	44,	44,	44,	45
};

#define INTEGER_ARCTAN		100

// 	Rough integer approximation (fast) of arctan2 based on table for 0-45 degrees
//	Return degrees, base on integer y and x inputs to arctan

int Arctan2(int y, int x)
{
	int xneg=0,yneg=0;
    int index,angle=45;

    if (x < 0)
	{ 
        xneg = 1;
        x = -x;
   	}

    if (y < 0)
	{
        yneg = 1;
        y = -y;
   	}

    if (x == 0 && y == 0) return 0;

    if (y == 0)
        return(xneg ? 180 : 0);

    if (x == 0)
        return(yneg ? 270 : 90);

    if (x > y)
	{
        index = (int)(((long)y * INTEGER_ARCTAN) / (long)x);
        angle = arctan_array[index];
   	}
	else if (y > x)
	{
        index = (int)(((long)x * INTEGER_ARCTAN) / (long)y);
        angle = 90 - arctan_array[index];
   	}
    
    if (xneg)
        if (yneg) 
            return(180 + angle);
        else
            return(180 - angle);
    else
        if (yneg) 
            return(360 - angle);
        else
            return(angle);
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\loctrnfl.c ===
/************************************************************************************************
 * FILE: LocTrnFl.c
 *
 *	Code to load and unload train time localization tables from files.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include <tchar.h>
#include "common.h"
#include "localep.h"

// Load train time localization information from a file.
BOOL
LocTrainLoadFile(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, wchar_t *pPath)
{
	wchar_t			aFullName[128];
	HANDLE			hFile, hMap;
	BYTE			*pByte;

	// Generate path to file.
	FormatPath(aFullName, pPath, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"loctrn.bin");

	// Try to open the file.
	hFile = CreateMappingCall(
		aFullName, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) {
		// DWORD		errCode;

		// errCode	= GetLastError();
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) {
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (LPBYTE) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if (pByte == NULL) {
		goto error3;
	}

	// Extract info from mapped data.
	if (!LocTrainLoadPointer(pLocRunInfo, pLocTrainInfo, pByte)) {
		goto error3;
	}

	// Save away the pointers so we can close up cleanly latter
	pLocTrainInfo->pLoadInfo1 = hFile;
	pLocTrainInfo->pLoadInfo2 = hMap;
	pLocTrainInfo->pLoadInfo3 = pByte;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

	// Error handling
error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	memset(pLocTrainInfo, 0, sizeof(*pLocTrainInfo));
	pLocTrainInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pLocTrainInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pLocTrainInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return FALSE;
}

// Unload train time localization information that was loaded from a file.
BOOL
LocTrainUnloadFile(LOCTRAIN_INFO *pLocTrainInfo)
{
	if (
		(pLocTrainInfo->pLoadInfo1 == INVALID_HANDLE_VALUE)
		|| (pLocTrainInfo->pLoadInfo2 == INVALID_HANDLE_VALUE)
		|| (pLocTrainInfo->pLoadInfo3 == INVALID_HANDLE_VALUE)
	) {
		return FALSE;
	}

	UnmapViewOfFile((BYTE *)pLocTrainInfo->pLoadInfo3);
	CloseHandle((HANDLE)pLocTrainInfo->pLoadInfo2);
	CloseHandle((HANDLE)pLocTrainInfo->pLoadInfo1);

	pLocTrainInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pLocTrainInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pLocTrainInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\loctrngn.c ===
/************************************************************************************************
 * FILE: LocTrnGn.c
 *
 *	Code to generate train time localization tables in a binary file.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"
#include "localep.h"


// Write a properly formated binary file containing the runtime localization information.
BOOL
LocTrainWriteFile(LOCRUN_INFO *pLocRunInfo, LOCTRAIN_INFO *pLocTrainInfo, FILE *pFile)
{
	LOCTRAIN_HEADER		header;
	DWORD				count;

	// Setup the header
	memset(&header, 0, sizeof(header));
	header.fileType			= LOCTRAIN_FILE_TYPE;
	header.headerSize		= sizeof(header);
	header.minFileVer		= LOCTRAIN_MIN_FILE_VERSION;
	header.curFileVer		= LOCTRAIN_CUR_FILE_VERSION;
	memcpy (header.adwSignature, pLocRunInfo->adwSignature, sizeof(pLocRunInfo->adwSignature));
	header.cCodePoints		= pLocTrainInfo->cCodePoints;
	header.cStrokeCountInfo	= pLocTrainInfo->cStrokeCountInfo;


	// Write it out.
	if (fwrite(&header, sizeof(header), 1, pFile) != 1) {
		goto error;
	}

	// Write out the Unicode to Densemap.
	count	= 0x10000;
	if (fwrite(pLocTrainInfo->pUnicode2Dense, sizeof(wchar_t), count, pFile) != count) {
		goto error;
	}
		
	// Write out the stroke count info.
	count	= header.cStrokeCountInfo;
	if (fwrite(pLocTrainInfo->pStrokeCountInfo, sizeof(STROKE_COUNT_INFO), count, pFile) != count) {
		goto error;
	}
		
	return TRUE;
error:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\memmgr.c ===
// memmgr.c
//
// This file contains definitions for the memory management.
// Implementation details may change so beware of relying on internal details.
//

#include <stdlib.h>
#include "common.h"

// Structure to hold debugging information for the memory manager
#define MEMORY_MANAGER_COOKIE 0xC001BEEF
#define MEMORY_BOUNDARY 0xDEADBEEF

#ifdef DBG
int	gFailure = 0;
MEMORY_MANAGER g_theMemoryManager = {MEMORY_MANAGER_COOKIE, 0, 0, 0};
#endif

// Format for allocated blocks:
// 4 bytes giving the length of the *requested* block
// 4 bytes giving the pointer to the memory manager used to allocate the block
// 4 bytes saying MEMORY_BOUNDARY
// bytes of the block, rounded up to a multiple of 4
// 4 bytes saying MEMORY_BOUNDARY

/******************************Public*Routine******************************\
* ExternAlloc
*
* This guy keeps the size in the first long so we can fake a realloc.  Lot's
* of debug checking for heap overwrites.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternAlloc(DWORD cb)
{
    long   *pl;
	DWORD	cbAlloc;

#ifdef  DBG
#ifndef WINCE
    //
    // If gFailure is 0 nothing happens, if it's non-zero we
    // fail 1 in gFailure allocations.
    //

    if (gFailure)
    {
        if (((rand() * gFailure) / (RAND_MAX + 1)) == 0)
        {
            return (void *) NULL;
        }
    }
#endif
#endif

// Since we can't use realloc on WINCE, we need to save the original size for memcpy
// in our own realloc function.

	cbAlloc = cb + 4;

#ifdef DBG
    cbAlloc +=  3;	// round it up to DWORD boundary
    cbAlloc &= ~3;
    cbAlloc += 12;	// write pointer to memory manager and buffer at start, and buffer at end
#endif

	pl = (long *) malloc(cbAlloc);
	if (pl == (long *) NULL)
		return pl;

// Stamp this baby full of invalid bytes so code that relies on 0's in it are sniffed out.

#ifdef DBG
	memset(pl,0xff,cbAlloc);
    pl[1] = (long) &g_theMemoryManager;
    pl[2] = MEMORY_BOUNDARY;
    pl[(cbAlloc / 4) - 1] = MEMORY_BOUNDARY;
#endif

// OK, tuck the object size away at the begining

    *(pl++) = cb;

#ifdef DBG
    pl += 2;
    g_theMemoryManager.cAlloc++;
    g_theMemoryManager.cAllocMem += cb;

// JPittman: The OutputDebugString() call here is commented out because
// of complaints from Word about spewing of tons of output to the
// debug window hiding their own debug output.  This caused us to be
// excluded from Cicero's TIP profiling.

	if (g_theMemoryManager.cAllocMem > g_theMemoryManager.cAllocMaxMem)
	{
//		TCHAR szDebug[128];
		g_theMemoryManager.cAllocMaxMem = g_theMemoryManager.cAllocMem;
//		wsprintf(szDebug, TEXT("cAllocMaxMem = %d \r\n"), cAllocMaxMem);
//		OutputDebugString(szDebug);
	}
#endif

    return pl;
}

/******************************Public*Routine******************************\
* ExternRealloc
*
* Well this sucks buts we want the same exact code on NT and WINCE and
* we can't find a way to use the flags and have Realloc work the same on
* both.  Realloc is a very infrequent event so this work for us.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternRealloc(void *pv, DWORD cbNew)
{
    void   *pvNew = ExternAlloc(cbNew);

    if (pv && pvNew)
    {
        long   *pl;
        DWORD	cb;

        pl = (long *) pv;

#ifdef	DBG
		pl -= 2;
#endif

        cb = (DWORD) *(--pl);
		memcpy(pvNew, pv, min(cbNew, cb));
        ExternFree(pv);
    }

	return pvNew;
}

/******************************Public*Routine******************************\
* ExternFree
*
* Free up the memory, in debug mode check for heap corruption !
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void ExternFree(void *pv)
{
    long   *pl;

// We now allow freeing of null pointers

	if (pv == (void *) NULL)
		return;

    pl = (long *) pv;
    pl--;

#ifdef DBG
{
    MEMORY_MANAGER *pMemoryManager;
    int		cbAlloc;
#if defined(HWX_INTERNAL) && defined(HWX_HEAPCHECK)
	HANDLE	hHeap = GetProcessHeap();
	BOOL	bHeapState;

	if (hHeap)
	{
		bHeapState = HeapValidate(hHeap, 0, NULL);
		ASSERT(bHeapState);
	}
#endif // #if defined(HWX_INTERNAL) && defined(HWX_HEAPCHECK)
// Check nothing has been stepped on.

    ASSERT(*pl == MEMORY_BOUNDARY);
    pl--;
    pMemoryManager = (MEMORY_MANAGER *)(*pl);
    ASSERT(pMemoryManager->iCookie == MEMORY_MANAGER_COOKIE);
    pl--;
    cbAlloc = *pl;
    pMemoryManager->cAllocMem -= cbAlloc;
    ASSERT(pMemoryManager->cAllocMem >= 0);
    cbAlloc +=  4;  // to save the size
    cbAlloc +=  3;	// round it up to DWORD boundary
    cbAlloc &= ~3;
    cbAlloc += 12;	// write pointer to memory manager and buffer at start, and buffer at end
    ASSERT(pl[(cbAlloc / 4) - 1] == MEMORY_BOUNDARY);
    pMemoryManager->cAlloc--;
}
#endif

	free(pl);
}

char *Externstrdup( const char *strSource )
{
	int		nLen = 0;
	char*	pszOut = NULL;

	// fail immediately on a null pointer
	if (NULL == strSource)
		return NULL;

	// get the length of the ansi string 
	nLen = strlen(strSource) * sizeof(char);

	// fail on a 0 length string 
	//  @todo(petewil) - is this right, or return 0 length string instead?
	if (0 == nLen)
		return NULL;

	// allow room for a trailing null
	nLen += sizeof(char);

	// allocate space for the string
	pszOut = ExternAlloc(nLen);

	if (NULL == pszOut)
		return NULL;

	// copy the string into the buffer provided
	strcpy(pszOut, strSource);

    return pszOut;
}

wchar_t *Externwcsdup(const wchar_t *wszSource)
{
	int	nLen = 0;
	wchar_t* wszOut = NULL;

	// fail immediately on a null pointer
	if (NULL == wszSource)
		return NULL;

	// get the length of the ansi string 
	nLen = (wcslen(wszSource) + 1) * sizeof(wchar_t);

	// allocate space for the string
	wszOut = ExternAlloc(nLen);

	if (NULL == wszOut)
		return NULL;

	// copy the string into the buffer provided
	wcscpy(wszOut, wszSource);

    return wszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\natufreq.c ===
/******************************Module*Header*******************************\
* Module Name: natfreq.c
*
* At train time we want to dynamically load the natual frequency information
* from the data.  This module contains the code and data structures to do
* this.
*
* The code contained is train time only code, it should not be included
* to build hwxXXX.dll
*
\**************************************************************************/

#include <stdlib.h>
#include "common.h"

typedef struct tagFREQ_INFO
{
	wchar_t		dch;
	DWORD		frequency;
} FREQ_INFO;

static DWORD		gtotalSamples;
static DWORD		gmaxNaturalFequency;
static DWORD		gFreqInfoSize;
static FREQ_INFO	*gpaNaturalFrequencies = NULL;

/******************************Public*Routine******************************\
* LoadNatualFrequency
*
* Loads the natual frequency information from a text file generated by mkuni.exe.
*
\**************************************************************************/

BOOL LoadNatualFrequency(wchar_t *pFile, FILE *pFileLog)
{
    FILE *fp;
    DWORD iTemp,iTemp1,iTemp2;
    int iRet;
	wchar_t	aFileInput[256];

	// Open frequency file.
    fp = UtilOpen(pFile, L"r", aFileInput, 256);
    if (fp == NULL) {
        fwprintf(pFileLog, L"FAILED to load %s !!!\n", pFile);
		return FALSE;
    } else {
        fwprintf(pFileLog, L"Loaded frequency file: %s\n", aFileInput);
	}

	// Get count of labels.
    iRet = fwscanf(fp, L"%d %d %d\n", &gtotalSamples,&gmaxNaturalFequency,&gFreqInfoSize);
    if (iRet != 3) {
        fwprintf(pFileLog, L"Error reading %s\n", pFile);
        return FALSE;
    }

	// Allocate memory for frequency table.
    gpaNaturalFrequencies	= malloc(gFreqInfoSize * sizeof(FREQ_INFO));
	if (!gpaNaturalFrequencies) {
        fwprintf(pFileLog, L"Out of memory reading %s\n", pFile);
        return FALSE;
    }

    for (iTemp = 0; iTemp < gFreqInfoSize; iTemp++) {
        iRet = fwscanf(fp, L"%x %d\n", &iTemp1, &iTemp2);
        if (iRet != 2) {
			fwprintf(pFileLog, L"Error reading %s\n", pFile);
			return FALSE;
        }

        gpaNaturalFrequencies[iTemp].dch	= (wchar_t)iTemp1;
        gpaNaturalFrequencies[iTemp].frequency	= iTemp2;
    }

    fclose(fp);

    if (pFileLog) {
        fwprintf(pFileLog, L"Loaded natual frequency: first %04X %d last %04X %d\n", 
			gpaNaturalFrequencies[0].dch,
			gpaNaturalFrequencies[0].frequency,
			gpaNaturalFrequencies[gFreqInfoSize - 1].dch,
			gpaNaturalFrequencies[gFreqInfoSize - 1].frequency);
    }

	return TRUE;
}

/******************************Public*Routine******************************\
* DenseCodeNumberOfSamples
*
* Returns the number frequency of a dense code
*
\**************************************************************************/
DWORD	DenseCodeNumberOfSamples(wchar_t wCurrent)
{
    int     iMin;
    int     iMax;
    int     iNew;
    WORD    wNew;

    iMin = 0;
    iMax = gFreqInfoSize - 1;

    while (iMin < iMax)
    {
        iNew = (iMin + iMax) / 2;

        wNew = gpaNaturalFrequencies[iNew].dch;

        if (wNew < wCurrent) {
            iMin = iNew + 1;
            continue;
        } else if (wNew > wCurrent) {
            iMax = iNew - 1;
            continue;
        }

        return	gpaNaturalFrequencies[iNew].frequency;
    }

    return gpaNaturalFrequencies[iMin].dch == wCurrent ? gpaNaturalFrequencies[iMin].frequency : 0;
}

BOOL GetFrequencyInfo(DWORD index,wchar_t * pdch,DWORD * pFrequency)
{
	*pdch = 0xFFFF;
	*pFrequency = 0;
	if ( !gpaNaturalFrequencies || index >= gFreqInfoSize )
	{
		return FALSE;
	}
	*pdch = gpaNaturalFrequencies[index].dch;
	*pFrequency = gpaNaturalFrequencies[index].frequency;
	return TRUE;
}

DWORD	GetTotalDenseCodeSamples()
{
	return gtotalSamples;
}

DWORD	GetMaxDenseCodeSamples()
{
	return gmaxNaturalFequency;
}

DWORD	GetNatualFrequencyTableSize()
{
	return gFreqInfoSize;
}

void UnloadNatualFrequency()
{
	if ( gpaNaturalFrequencies )
	{
		free(gpaNaturalFrequencies);
	}
}

// Look up the "natural" frequency of a (possibly folded) code, and return -1 if it
// is not found in the table.
int	DenseCodeNumberOfSamplesInternal(wchar_t wCurrent)
{
    int     iMin;
    int     iMax;
    int     iNew;
    WORD    wNew;

    iMin = 0;
    iMax = gFreqInfoSize - 1;

    while (iMin < iMax)
    {
        iNew = (iMin + iMax) / 2;

        wNew = gpaNaturalFrequencies[iNew].dch;

        if (wNew < wCurrent) {
            iMin = iNew + 1;
            continue;
        } else if (wNew > wCurrent) {
            iMax = iNew - 1;
            continue;
        }

        return	gpaNaturalFrequencies[iNew].frequency;
    }

    return gpaNaturalFrequencies[iMin].dch == wCurrent ? gpaNaturalFrequencies[iMin].frequency : -1;
}

/******************************Public*Routine******************************\
* DenseCodeNumberOfSamplesFolded
*
* Returns the natural frequency of a dense code.  If the dense code is a folded
* code, then the counts for each component of the folding set are added.
*
\**************************************************************************/
DWORD
DenseCodeNumberOfSamplesFolded(LOCRUN_INFO *pLocRunInfo, wchar_t dch)
{
	// First try to just look up the code in the table.
	int	c = DenseCodeNumberOfSamplesInternal(dch);

	// If we didn't find it, the cause may be that dch is a folded code,
	// and the table has not been updated with folded codes yet.
	if (c == -1 && LocRunIsFoldedCode(pLocRunInfo, dch)) {
		// If it is a folded code, look up the folding set
		wchar_t *pFoldingSet = LocRunFolded2FoldingSet(pLocRunInfo, dch);
		int i;

		// Run through the folding set, adding counts
		c = 0;
		for (i = 0; i < LOCRUN_FOLD_MAX_ALTERNATES && pFoldingSet[i] != 0; i++) 
			c += DenseCodeNumberOfSamples(pFoldingSet[i]);
	}

	// Return
	return __max(c, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\logprob.c ===
/******************************Module*Header*******************************\
* Module Name: logprob.c
*
* Tables and code used to manipulate log probabilities.
*
* Created: 07-Nov-1997
* Author: John Bennett	jbenn
*
* This was created from the old file xjis.c.
*
* Copyright (c) 1996,1997 Microsoft Corporation
\**************************************************************************/

#include "common.h"
#include "score.h"

// Integer Log Table

const static unsigned short logdiff[] =
{
    2440, 2033, 1844, 1719, 1626, 1551, 1489, 1436,
    1389, 1348, 1310, 1276, 1245, 1216, 1189, 1164,
    1140, 1118, 1097, 1077, 1058, 1040, 1023, 1006,
     990,  975,  960,  946,  932,  919,  906,  894,
     882,  870,  859,  848,  837,  826,  816,  806,
     796,  787,  778,  769,  760,  751,  742,  734,
     726,  718,  710,  702,  694,  687,  680,  672,
     665,  658,  651,  645,  638,  631,  625,  619,
     612,  606,  600,  594,  588,  582,  576,  571,
     565,  559,  554,  548,  543,  538,  532,  527,
     522,  517,  512,  507,  502,  497,  493,  488,
     483,  478,  474,  469,  465,  460,  456,  451,
     447,  443,  438,  434,  430,  426,  421,  417,
     413,  409,  405,  401,  397,  393,  390,  386,
     382,  378,  374,  371,  367,  363,  360,  356,
     352,  349,  345,  342,  338,  335,  331,  328,
     324,  321,  318,  314,  311,  308,  304,  301,
     298,  295,  291,  288,  285,  282,  279,  276,
     272,  269,  266,  263,  260,  257,  254,  251,
     248,  245,  242,  240,  237,  234,  231,  228,
     225,  222,  220,  217,  214,  211,  208,  206,
     203,  200,  197,  195,  192,  189,  187,  184,
     181,  179,  176,  174,  171,  168,  166,  163,
     161,  158,  156,  153,  151,  148,  146,  143,
     141,  138,  136,  133,  131,  129,  126,  124,
     121,  119,  117,  114,  112,  110,  107,  105,
     103,  100,   98,   96,   93,   91,   89,   86,
      84,   82,   80,   78,   75,   73,   71,   69,
      66,   64,   62,   60,   58,   56,   53,   51,
      49,   47,   45,   43,   41,   38,   36,   34,
      32,   30,   28,   26,   24,   22,   20,   18,
      16,   14,   12,   10,    8,    6,    4,    2
};

int Distance(int a, int b)
{
    return ((int) sqrt((double) (a * a + b * b)));
}

int AddLogProb(int a, int b)
{
    int diff = a - b;

// We will compute a function from the difference between the max of the two
// and the min and we will add that back to the max.  We only need the larger
// of the two values for the remainder of the computation.  We pick 'a' for this.

    if (diff < 0)
    {
        diff = -diff;
        a = b;
    }

// If the difference is too large, the result is simply the max of the two

    if (diff >= logdiff[0])
        return a;

// Otherwise, we have to find it in the table.  Use a binary search to convert
// the difference to an index value.

    {
        const unsigned short *pLow = &logdiff[0];
        const unsigned short *pTop = &logdiff[INTEGER_LOG_SCALE];
        const unsigned short *pMid = (const unsigned short *) 0L;

        while (1)
        {
            pMid = pLow + (pTop - pLow) / 2;

            if (pMid == pLow)
                break;

            if (diff < *pMid)
                pLow = pMid;
            else
                pTop = pMid;
        }

        a += pLow - &logdiff[0] + 1;
    }

    return a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\results.c ===
#include "recogp.h"
#include "recog.h"


// converts from new results buffer to the old results buffer,
// we are assuming that the caller has allocated the buffer to big enough for the
// bigger buffer (the older in this case)
void ConvertToOldResults (int cAlt, int cBoxRes, PVOID pData)
{
	int			ii, jj;
	int			cFromBytes, cToBytes; 
	int			cFromSize, cToSize;
	HWXRESULTS	*pFrom;
	BOXRESULTS	*pTo;

	// point to the last structure in each buffers
	cFromSize		= sizeof(HWXRESULTS) + (cAlt - 1) * sizeof (WCHAR);
	cToSize			= sizeof(BOXRESULTS) + (cAlt - 1) * sizeof (SYV);

	cFromBytes		= (cBoxRes - 1) * cFromSize;
	cToBytes		= (cBoxRes - 1) * cToSize;

	for (ii = cBoxRes - 1; ii >=0 ; ii--, cFromBytes -= cFromSize, cToBytes -= cToSize) {

		pFrom	= (HWXRESULTS *)((BYTE *)pData + cFromBytes);
		pTo		= (BOXRESULTS *)((BYTE *)pData + cToBytes);

		for (jj = cAlt - 1; jj >=0 ; jj--) {

			// No result
			if (pFrom->rgChar[jj] == L'\0')
				pTo->rgSyv[jj] = SYV_NULL;
			else
				pTo->rgSyv[jj] = ((DWORD)pFrom->rgChar[jj] | ((DWORD) SYVHI_UNICODE << 16));
		}

		pTo->hinksetBox	= 0;
		pTo->indxBox	= pFrom->indxBox;
	}
}

// converts from old results to new results
// have to provide both buffers because Dest is smaller than Src
void ConvertToNewResults (int cAlt, int cBoxRes, HWXRESULTS	*pTo, BOXRESULTS *pFrom)
{
	int			ii, jj;
	int			cFromSize, cToSize;

	// point to the last structure in each buffers
	cFromSize		= sizeof(BOXRESULTS) + (cAlt - 1) * sizeof (SYV);
	cToSize			= sizeof(HWXRESULTS) + (cAlt - 1) * sizeof (WCHAR);

	for (ii = 0; ii < cBoxRes ; ii++) {

		for (jj = 0; jj < cAlt ; jj++) {

			// No result
			if (pFrom->rgSyv[jj] == SYV_NULL)
				pTo->rgChar[jj] = L'\0';
			else
				pTo->rgChar[jj] = (WORD) (pFrom->rgSyv[jj] & 0xFFFF);
		}

		pTo->indxBox	= (USHORT)pFrom->indxBox;

		pFrom	= (BOXRESULTS *)((BYTE *)pFrom + cFromSize);
		pTo		= (HWXRESULTS *)((BYTE *)pTo + cToSize);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\scoredata.c ===
/* This File is automatically generated by MakeScoreData.exe and should not be hand-modified */

#include <score.h>

/* If the following five constants don't match the ones in score.h,
   copy and paste these manually into score.h */

#define SCORE_BASE_LOG	0.693147
#define SCORE_SCALE_BASE_LOG	369
#define SCORE_GAUSS_SCALE_LOG	850
#define MAX_DIFF_SCORE_SUM	2440
#define MAX_DIFF_SCORE_DIFF	2441

SCORE rgScoreSum[MAX_DIFF_SCORE_SUM] = {
	256,
	256,
	255,
	255,
	254,
	254,
	253,
	253,
	252,
	252,
	251,
	251,
	250,
	250,
	249,
	249,
	248,
	248,
	247,
	247,
	246,
	246,
	245,
	245,
	244,
	244,
	243,
	243,
	242,
	242,
	241,
	241,
	240,
	240,
	239,
	239,
	238,
	238,
	237,
	237,
	237,
	236,
	236,
	235,
	235,
	234,
	234,
	233,
	233,
	232,
	232,
	231,
	231,
	230,
	230,
	230,
	229,
	229,
	228,
	228,
	227,
	227,
	226,
	226,
	225,
	225,
	224,
	224,
	224,
	223,
	223,
	222,
	222,
	221,
	221,
	220,
	220,
	220,
	219,
	219,
	218,
	218,
	217,
	217,
	216,
	216,
	215,
	215,
	215,
	214,
	214,
	213,
	213,
	212,
	212,
	212,
	211,
	211,
	210,
	210,
	209,
	209,
	209,
	208,
	208,
	207,
	207,
	206,
	206,
	206,
	205,
	205,
	204,
	204,
	203,
	203,
	203,
	202,
	202,
	201,
	201,
	200,
	200,
	200,
	199,
	199,
	198,
	198,
	198,
	197,
	197,
	196,
	196,
	195,
	195,
	195,
	194,
	194,
	193,
	193,
	193,
	192,
	192,
	191,
	191,
	191,
	190,
	190,
	189,
	189,
	189,
	188,
	188,
	187,
	187,
	187,
	186,
	186,
	185,
	185,
	185,
	184,
	184,
	183,
	183,
	183,
	182,
	182,
	181,
	181,
	181,
	180,
	180,
	180,
	179,
	179,
	178,
	178,
	178,
	177,
	177,
	176,
	176,
	176,
	175,
	175,
	175,
	174,
	174,
	173,
	173,
	173,
	172,
	172,
	172,
	171,
	171,
	170,
	170,
	170,
	169,
	169,
	169,
	168,
	168,
	168,
	167,
	167,
	166,
	166,
	166,
	165,
	165,
	165,
	164,
	164,
	164,
	163,
	163,
	163,
	162,
	162,
	161,
	161,
	161,
	160,
	160,
	160,
	159,
	159,
	159,
	158,
	158,
	158,
	157,
	157,
	157,
	156,
	156,
	156,
	155,
	155,
	154,
	154,
	154,
	153,
	153,
	153,
	152,
	152,
	152,
	151,
	151,
	151,
	150,
	150,
	150,
	149,
	149,
	149,
	148,
	148,
	148,
	147,
	147,
	147,
	146,
	146,
	146,
	145,
	145,
	145,
	144,
	144,
	144,
	144,
	143,
	143,
	143,
	142,
	142,
	142,
	141,
	141,
	141,
	140,
	140,
	140,
	139,
	139,
	139,
	138,
	138,
	138,
	138,
	137,
	137,
	137,
	136,
	136,
	136,
	135,
	135,
	135,
	134,
	134,
	134,
	134,
	133,
	133,
	133,
	132,
	132,
	132,
	131,
	131,
	131,
	131,
	130,
	130,
	130,
	129,
	129,
	129,
	128,
	128,
	128,
	128,
	127,
	127,
	127,
	126,
	126,
	126,
	126,
	125,
	125,
	125,
	124,
	124,
	124,
	124,
	123,
	123,
	123,
	122,
	122,
	122,
	122,
	121,
	121,
	121,
	120,
	120,
	120,
	120,
	119,
	119,
	119,
	119,
	118,
	118,
	118,
	117,
	117,
	117,
	117,
	116,
	116,
	116,
	116,
	115,
	115,
	115,
	114,
	114,
	114,
	114,
	113,
	113,
	113,
	113,
	112,
	112,
	112,
	112,
	111,
	111,
	111,
	111,
	110,
	110,
	110,
	109,
	109,
	109,
	109,
	108,
	108,
	108,
	108,
	107,
	107,
	107,
	107,
	106,
	106,
	106,
	106,
	105,
	105,
	105,
	105,
	104,
	104,
	104,
	104,
	103,
	103,
	103,
	103,
	102,
	102,
	102,
	102,
	102,
	101,
	101,
	101,
	101,
	100,
	100,
	100,
	100,
	99,
	99,
	99,
	99,
	98,
	98,
	98,
	98,
	98,
	97,
	97,
	97,
	97,
	96,
	96,
	96,
	96,
	95,
	95,
	95,
	95,
	95,
	94,
	94,
	94,
	94,
	93,
	93,
	93,
	93,
	93,
	92,
	92,
	92,
	92,
	91,
	91,
	91,
	91,
	91,
	90,
	90,
	90,
	90,
	89,
	89,
	89,
	89,
	89,
	88,
	88,
	88,
	88,
	88,
	87,
	87,
	87,
	87,
	87,
	86,
	86,
	86,
	86,
	85,
	85,
	85,
	85,
	85,
	84,
	84,
	84,
	84,
	84,
	83,
	83,
	83,
	83,
	83,
	82,
	82,
	82,
	82,
	82,
	81,
	81,
	81,
	81,
	81,
	80,
	80,
	80,
	80,
	80,
	79,
	79,
	79,
	79,
	79,
	78,
	78,
	78,
	78,
	78,
	78,
	77,
	77,
	77,
	77,
	77,
	76,
	76,
	76,
	76,
	76,
	75,
	75,
	75,
	75,
	75,
	75,
	74,
	74,
	74,
	74,
	74,
	73,
	73,
	73,
	73,
	73,
	73,
	72,
	72,
	72,
	72,
	72,
	72,
	71,
	71,
	71,
	71,
	71,
	70,
	70,
	70,
	70,
	70,
	70,
	69,
	69,
	69,
	69,
	69,
	69,
	68,
	68,
	68,
	68,
	68,
	68,
	67,
	67,
	67,
	67,
	67,
	67,
	66,
	66,
	66,
	66,
	66,
	66,
	65,
	65,
	65,
	65,
	65,
	65,
	64,
	64,
	64,
	64,
	64,
	64,
	64,
	63,
	63,
	63,
	63,
	63,
	63,
	62,
	62,
	62,
	62,
	62,
	62,
	61,
	61,
	61,
	61,
	61,
	61,
	61,
	60,
	60,
	60,
	60,
	60,
	60,
	60,
	59,
	59,
	59,
	59,
	59,
	59,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	57,
	57,
	57,
	57,
	57,
	57,
	57,
	56,
	56,
	56,
	56,
	56,
	56,
	56,
	55,
	55,
	55,
	55,
	55,
	55,
	55,
	55,
	54,
	54,
	54,
	54,
	54,
	54,
	54,
	53,
	53,
	53,
	53,
	53,
	53,
	53,
	52,
	52,
	52,
	52,
	52,
	52,
	52,
	52,
	51,
	51,
	51,
	51,
	51,
	51,
	51,
	51,
	50,
	50,
	50,
	50,
	50,
	50,
	50,
	50,
	49,
	49,
	49,
	49,
	49,
	49,
	49,
	49,
	48,
	48,
	48,
	48,
	48,
	48,
	48,
	48,
	47,
	47,
	47,
	47,
	47,
	47,
	47,
	47,
	46,
	46,
	46,
	46,
	46,
	46,
	46,
	46,
	46,
	45,
	45,
	45,
	45,
	45,
	45,
	45,
	45,
	45,
	44,
	44,
	44,
	44,
	44,
	44,
	44,
	44,
	44,
	43,
	43,
	43,
	43,
	43,
	43,
	43,
	43,
	43,
	42,
	42,
	42,
	42,
	42,
	42,
	42,
	42,
	42,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
};

SCORE rgScoreDiff[MAX_DIFF_SCORE_DIFF] = {
	-1,
	2184,
	1928,
	1779,
	1673,
	1591,
	1525,
	1468,
	1419,
	1376,
	1338,
	1303,
	1272,
	1243,
	1216,
	1191,
	1167,
	1145,
	1125,
	1105,
	1087,
	1069,
	1053,
	1037,
	1022,
	1007,
	993,
	980,
	967,
	954,
	942,
	930,
	919,
	908,
	898,
	888,
	878,
	868,
	859,
	850,
	841,
	832,
	824,
	816,
	808,
	800,
	792,
	785,
	777,
	770,
	763,
	756,
	750,
	743,
	737,
	730,
	724,
	718,
	712,
	707,
	701,
	695,
	690,
	684,
	679,
	674,
	669,
	663,
	658,
	654,
	649,
	644,
	639,
	635,
	630,
	626,
	621,
	617,
	613,
	608,
	604,
	600,
	596,
	592,
	588,
	584,
	580,
	577,
	573,
	569,
	566,
	562,
	558,
	555,
	551,
	548,
	545,
	541,
	538,
	535,
	531,
	528,
	525,
	522,
	519,
	516,
	513,
	510,
	507,
	504,
	501,
	498,
	495,
	492,
	490,
	487,
	484,
	482,
	479,
	476,
	474,
	471,
	468,
	466,
	463,
	461,
	458,
	456,
	454,
	451,
	449,
	446,
	444,
	442,
	439,
	437,
	435,
	433,
	430,
	428,
	426,
	424,
	422,
	420,
	418,
	415,
	413,
	411,
	409,
	407,
	405,
	403,
	401,
	399,
	397,
	395,
	394,
	392,
	390,
	388,
	386,
	384,
	382,
	381,
	379,
	377,
	375,
	373,
	372,
	370,
	368,
	367,
	365,
	363,
	362,
	360,
	358,
	357,
	355,
	353,
	352,
	350,
	349,
	347,
	346,
	344,
	342,
	341,
	339,
	338,
	336,
	335,
	333,
	332,
	331,
	329,
	328,
	326,
	325,
	323,
	322,
	321,
	319,
	318,
	317,
	315,
	314,
	313,
	311,
	310,
	309,
	307,
	306,
	305,
	303,
	302,
	301,
	300,
	298,
	297,
	296,
	295,
	293,
	292,
	291,
	290,
	289,
	287,
	286,
	285,
	284,
	283,
	282,
	281,
	279,
	278,
	277,
	276,
	275,
	274,
	273,
	272,
	271,
	269,
	268,
	267,
	266,
	265,
	264,
	263,
	262,
	261,
	260,
	259,
	258,
	257,
	256,
	255,
	254,
	253,
	252,
	251,
	250,
	249,
	248,
	247,
	246,
	245,
	244,
	243,
	243,
	242,
	241,
	240,
	239,
	238,
	237,
	236,
	235,
	234,
	233,
	233,
	232,
	231,
	230,
	229,
	228,
	227,
	227,
	226,
	225,
	224,
	223,
	222,
	222,
	221,
	220,
	219,
	218,
	217,
	217,
	216,
	215,
	214,
	214,
	213,
	212,
	211,
	210,
	210,
	209,
	208,
	207,
	207,
	206,
	205,
	204,
	204,
	203,
	202,
	201,
	201,
	200,
	199,
	199,
	198,
	197,
	196,
	196,
	195,
	194,
	194,
	193,
	192,
	192,
	191,
	190,
	190,
	189,
	188,
	188,
	187,
	186,
	186,
	185,
	184,
	184,
	183,
	182,
	182,
	181,
	181,
	180,
	179,
	179,
	178,
	177,
	177,
	176,
	176,
	175,
	174,
	174,
	173,
	173,
	172,
	171,
	171,
	170,
	170,
	169,
	168,
	168,
	167,
	167,
	166,
	166,
	165,
	164,
	164,
	163,
	163,
	162,
	162,
	161,
	161,
	160,
	159,
	159,
	158,
	158,
	157,
	157,
	156,
	156,
	155,
	155,
	154,
	154,
	153,
	153,
	152,
	152,
	151,
	151,
	150,
	150,
	149,
	149,
	148,
	148,
	147,
	147,
	146,
	146,
	145,
	145,
	144,
	144,
	143,
	143,
	142,
	142,
	141,
	141,
	140,
	140,
	140,
	139,
	139,
	138,
	138,
	137,
	137,
	136,
	136,
	136,
	135,
	135,
	134,
	134,
	133,
	133,
	132,
	132,
	132,
	131,
	131,
	130,
	130,
	129,
	129,
	129,
	128,
	128,
	127,
	127,
	127,
	126,
	126,
	125,
	125,
	125,
	124,
	124,
	123,
	123,
	123,
	122,
	122,
	121,
	121,
	121,
	120,
	120,
	119,
	119,
	119,
	118,
	118,
	118,
	117,
	117,
	116,
	116,
	116,
	115,
	115,
	115,
	114,
	114,
	114,
	113,
	113,
	112,
	112,
	112,
	111,
	111,
	111,
	110,
	110,
	110,
	109,
	109,
	109,
	108,
	108,
	108,
	107,
	107,
	107,
	106,
	106,
	106,
	105,
	105,
	105,
	104,
	104,
	104,
	103,
	103,
	103,
	102,
	102,
	102,
	101,
	101,
	101,
	100,
	100,
	100,
	100,
	99,
	99,
	99,
	98,
	98,
	98,
	97,
	97,
	97,
	96,
	96,
	96,
	96,
	95,
	95,
	95,
	94,
	94,
	94,
	94,
	93,
	93,
	93,
	92,
	92,
	92,
	92,
	91,
	91,
	91,
	90,
	90,
	90,
	90,
	89,
	89,
	89,
	89,
	88,
	88,
	88,
	87,
	87,
	87,
	87,
	86,
	86,
	86,
	86,
	85,
	85,
	85,
	85,
	84,
	84,
	84,
	84,
	83,
	83,
	83,
	83,
	82,
	82,
	82,
	82,
	81,
	81,
	81,
	81,
	80,
	80,
	80,
	80,
	79,
	79,
	79,
	79,
	78,
	78,
	78,
	78,
	77,
	77,
	77,
	77,
	77,
	76,
	76,
	76,
	76,
	75,
	75,
	75,
	75,
	74,
	74,
	74,
	74,
	74,
	73,
	73,
	73,
	73,
	72,
	72,
	72,
	72,
	72,
	71,
	71,
	71,
	71,
	71,
	70,
	70,
	70,
	70,
	70,
	69,
	69,
	69,
	69,
	68,
	68,
	68,
	68,
	68,
	67,
	67,
	67,
	67,
	67,
	66,
	66,
	66,
	66,
	66,
	66,
	65,
	65,
	65,
	65,
	65,
	64,
	64,
	64,
	64,
	64,
	63,
	63,
	63,
	63,
	63,
	62,
	62,
	62,
	62,
	62,
	62,
	61,
	61,
	61,
	61,
	61,
	60,
	60,
	60,
	60,
	60,
	60,
	59,
	59,
	59,
	59,
	59,
	59,
	58,
	58,
	58,
	58,
	58,
	58,
	57,
	57,
	57,
	57,
	57,
	57,
	56,
	56,
	56,
	56,
	56,
	56,
	55,
	55,
	55,
	55,
	55,
	55,
	54,
	54,
	54,
	54,
	54,
	54,
	53,
	53,
	53,
	53,
	53,
	53,
	53,
	52,
	52,
	52,
	52,
	52,
	52,
	52,
	51,
	51,
	51,
	51,
	51,
	51,
	50,
	50,
	50,
	50,
	50,
	50,
	50,
	49,
	49,
	49,
	49,
	49,
	49,
	49,
	48,
	48,
	48,
	48,
	48,
	48,
	48,
	47,
	47,
	47,
	47,
	47,
	47,
	47,
	47,
	46,
	46,
	46,
	46,
	46,
	46,
	46,
	45,
	45,
	45,
	45,
	45,
	45,
	45,
	45,
	44,
	44,
	44,
	44,
	44,
	44,
	44,
	44,
	43,
	43,
	43,
	43,
	43,
	43,
	43,
	43,
	42,
	42,
	42,
	42,
	42,
	42,
	42,
	42,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	40,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	39,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	36,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	35,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	34,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	31,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	30,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	29,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	28,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	27,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	26,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	24,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	23,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	22,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	21,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	20,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	19,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	18,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	17,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	15,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	14,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	12,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	11,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	9,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	8,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	7,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	6,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	4,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	3,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	2,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
};

SCORE rgScoreGauss[] = {
	4144,
	3999,
	3856,
	3718,
	3583,
	3452,
	3325,
	3201,
	3081,
	2964,
	2852,
	2743,
	2638,
	2536,
	2438,
	2344,
	2253,
	2167,
	2084,
	2004,
	1928,
	1856,
	1788,
	1723,
	1663,
	1605,
	1552,
	1502,
	1456,
	1413,
	1374,
	1339,
	1308,
	1280,
	1256,
	1236,
	1219,
	1206,
	1197,
	1192,
	1190,
	1192,
	1197,
	1206,
	1219,
	1236,
	1256,
	1280,
	1308,
	1339,
	1374,
	1413,
	1456,
	1502,
	1552,
	1605,
	1663,
	1723,
	1788,
	1856,
	1928,
	2004,
	2084,
	2167,
	2253,
	2344,
	2438,
	2536,
	2638,
	2743,
	2852,
	2964,
	3081,
	3201,
	3325,
	3452,
	3583,
	3718,
	3856,
	3999,
	4144,
};

SCORE rgScoreGaussArea[] = {
	3824,
	3669,
	3518,
	3370,
	3226,
	3086,
	2949,
	2816,
	2687,
	2560,
	2437,
	2318,
	2202,
	2090,
	1980,
	1875,
	1772,
	1673,
	1577,
	1485,
	1396,
	1310,
	1227,
	1148,
	1072,
	998,
	929,
	862,
	798,
	737,
	679,
	625,
	573,
	524,
	478,
	434,
	393,
	355,
	320,
	287,
	256,
	228,
	202,
	178,
	156,
	136,
	118,
	102,
	88,
	75,
	64,
	54,
	45,
	38,
	31,
	26,
	21,
	17,
	14,
	11,
	9,
	7,
	5,
	4,
	3,
	2,
	2,
	1,
	1,
	1,
	1,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\sources.inc ===
TARGETNAME=commonu
TARGETTYPE=LIBRARY

NTTARGETFILES= $(NTTARGETFILES) hwxbin

USE_MSVCRT=1

C_DEFINES= $(C_DEFINES) -DZTRAIN

INCLUDES= $(INCLUDES) \
          $(_TPG_ROOT)\hwx\commonu\inc; \
          $(_TPG_ROOT)\hwx\wisp\inc; \

TARGETLIBS= $(TARGETLIBS) \

SOURCES= \
         ..\altlist.c \
         ..\bigram.c \
         ..\clbigram.c \
         ..\charset.c \
         ..\dnlblcnt.c \
         ..\errsys.c \
         ..\frame.c \
         ..\glyph.c \
         ..\glyphtrn.c \
         ..\guide.c \
         ..\loadfl.c \
         ..\loadrs.c \
         ..\locrun.c \
         ..\locrunfl.c \
         ..\locrungn.c \
         ..\locrunrs.c \
         ..\loctrn.c \
         ..\loctrnfl.c \
         ..\loctrngn.c \
         ..\loctrnrs.c \
         ..\logprob.c \
         ..\mathx.c \
         ..\memmgr.c \
         ..\natufreq.c \
         ..\results.c \
         ..\score.c \
         ..\scoredata.c \
         ..\toolprs.c \
         ..\unigram.c \
         ..\util.c \
         ..\valid.c \
         ..\runnet.c\
         ..\math16.c\
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\score.c ===
#include <math.h>
#include <score.h>

#define PI 3.1415926535

extern SCORE rgScoreSum[];
extern SCORE rgScoreDiff[];
extern SCORE rgScoreGaussArea[];

/* Convert a probabilty to a score */

SCORE
ProbToScore(
	double eProb
) {
	SCORE score;

	if (eProb == 0.0) {
		return (SCORE_ZERO);
	}

	if (eProb <= 0.0) {
		return (SCORE_ZERO);
	}

	eProb = floor(-SCORE_SCALE*log(eProb)/SCORE_BASE_LOG + 0.5);
 	if (eProb > SCORE_MAX) {
		return (SCORE_ZERO);
	}
	if (eProb < 0) {
		return (SCORE_ONE);
	}
	score = (SCORE)eProb;

	return (score);

} // ProbToScore

/* Convert a score back to a probability */

double
ScoreToProb(
	SCORE score
) {
	double eProb;

	if (score == SCORE_ZERO) {
		return (0.0);
	}

	eProb = exp(-SCORE_BASE_LOG*(double)score/(double)SCORE_SCALE);

	return (eProb);

} // ScoreToProb

/* Use this when you want to add two probabilities but you have two scores.
Computes ProbToScore(ScoreToProb(score1)+ScoreToProb(score2)) but much, much faster. */

SCORE
ScoreAddProbs(
	SCORE score1,
	SCORE score2
) {
	int scoreAddend, scoreAugend, scoreDiff;

	/* Special check for zero */

	if (score1 == SCORE_ZERO) {
		return (score2);
	}

	if (score2 == SCORE_ZERO) {
		return (score1);
	}

	/* The idea here is that we add the addend to the augend.  For our purposes, we need the
	Augend to be strictly smaller than the addend */

	scoreAugend = score1;
	scoreAddend = score2;
	scoreDiff = scoreAddend - scoreAugend;

	if (scoreDiff < 0) {
		scoreAugend = score2;
		scoreAddend = score1;
		scoreDiff = -scoreDiff;
	}

	/* If the difference between the two exceeds a certain amount, the result is identical to the 
	larger of the two parameters */

	if (scoreDiff >= MAX_DIFF_SCORE_SUM) {
		return (SCORE)(scoreAugend);
	}

	/* Otherwise, we can look up the exact amount we need from a table */

	scoreAugend -= rgScoreSum[scoreDiff];

	/* Be sure they don't add to more than 100% */

	if (scoreAugend < 0) {
		return (SCORE_ONE);
	}

	return (SCORE)(scoreAugend);

} // ScoreAddProbs

/* Use this when you want to subtract one probability from another but you have two scores.
Computes ProbToScore(ScoreToProb(score1)-ScoreToProb(score2)) but much, much faster. */

SCORE
ScoreSubProbs(
	SCORE score1,
	SCORE score2
) {
	int scoreDiff;
	int scoreSubtrahend = score1;
	int scoreMinuend = score2;

	if (scoreMinuend == SCORE_ZERO) {
		return (SCORE)(scoreSubtrahend);
	}

	/* The idea here is that we subtract the minuend from the subtrahend, and we require a positive result.
	However, the larger prob means a smaller logprob, so the sign is backwards */

	scoreDiff = -(scoreSubtrahend - scoreMinuend);

	/* Cant represent the log of a negative number or zero */

	if (scoreDiff <= 0) {
		return (SCORE_ZERO);
	}

 	/* If the minuend (prob) is small enough, it has no effect on the subtrahend */

	if (scoreDiff >= MAX_DIFF_SCORE_DIFF) {
		return (SCORE)(scoreSubtrahend);
	}

	/* Otherwise, we can look up the exact amount we need from a table */

	scoreSubtrahend += rgScoreDiff[scoreDiff];

	if (scoreSubtrahend > SCORE_MAX) {
		return (SCORE_ZERO);
	}

	return (SCORE)(scoreSubtrahend);
} // ScoreSubProbs

/* Given a count of data points, a sum, of values at those points, and a sum of the squares of the values at
those points, compute the mean and standard deviation plus the log-prob of the normal denominator for use in 
further gaussian calculations.  All returned numbers are ints, so the input values should be pre-scaled to
avoid loss of precision */

void
ScoreGaussianCalc(
	int cx,
	double eSumX,
	double eSumX2,
	SCORE_GAUSSIAN *pScoreGaussian
) {
	double eMean, eVar, eSigma, eNorm;

	eMean = eSumX/cx;
	eVar = eSumX2 - eMean*eMean;
	eSigma = sqrt(eVar);
	eNorm = sqrt(2.0*PI*eSigma);

	pScoreGaussian->mean = (SCORE)(eMean + 0.5);
	pScoreGaussian->sigma = (SCORE)(eSigma + 0.5);
	if (eNorm > 0.0) {
		pScoreGaussian->scoreNormal = ProbToScore(1.0/eNorm);
	} else {
		pScoreGaussian->scoreNormal = SCORE_ONE;
	}

} // ScoreGaussianCalc

/* Given a value and a gaussian, compute the probability.  This is really the 
probability of the granular slice, since obviously the probability of that exact
point would be zero. This is equivalent to "the probability that a point fell in
this zone" where there are SCORE_GAUSS_SCALE zones per sigma */

SCORE
ScoreGaussianPoint(
	int x,
	SCORE_GAUSSIAN *pScoreGaussian
) {
	int diff, temp;
	int lscore;
	SCORE score;

	/* Compute the difference between X and the Mean in decisigmas, handling roundoff */

	diff = x - pScoreGaussian->mean;

	diff *= SCORE_GAUSS_SCALE;
	if (diff >= 0) {
		diff += pScoreGaussian->sigma/2;
	} else {
		diff -= pScoreGaussian->sigma/2;
	}

	/* If there is no standard deviation, treat as a delta function */

	if (pScoreGaussian->sigma == 0) {
		if (diff == 0) {
			return (SCORE_ONE);
		} 
		return (SCORE_ZERO);
	}

	diff /= pScoreGaussian->sigma;

	temp = SCORE_SCALE_BASE_LOG*diff*diff;
	temp += SCORE_GAUSS_SCALE*SCORE_GAUSS_SCALE;
	temp /= 2*SCORE_GAUSS_SCALE*SCORE_GAUSS_SCALE;
	lscore = temp + pScoreGaussian->scoreNormal + SCORE_GAUSS_SCALE_LOG;
	if (lscore > SCORE_MAX) {
		lscore = SCORE_MAX;
	}
	score = (SCORE)lscore;

	return (score);

} // ScoreGaussianPoint

/* Computes the probability that a value was x or less */

SCORE
ScoreGaussianTail(
	int x,
	SCORE_GAUSSIAN *pScoreGaussian
) {

	int iSigma;

	/* Convert x to sigmas from the mean, scaling by our scale and rounding properly, 
	defeating	C's desire to round negative numbers up. */

	iSigma = (x - pScoreGaussian->mean)*SCORE_GAUSS_SCALE;
	if (iSigma >= 0) {
		iSigma += pScoreGaussian->sigma/2;
	} else {
		iSigma -= pScoreGaussian->sigma/2;
	}

	/* If there is no standard deviation, treat as a delta function */

	if (pScoreGaussian->sigma == 0) {
		if (iSigma >= 0) {
			return (SCORE_ONE);
		} 
		return (SCORE_ZERO);
	}

	iSigma /= pScoreGaussian->sigma;

	/* If iSigma is too big, we have the whole curve, and the area under the whole curve is 1.0 */

	if (iSigma > SCORE_GAUSS_RANGE) {
		return (SCORE_ONE);
	}

	/* If iSigma is too small, the area is just zero */

	if (iSigma < -SCORE_GAUSS_RANGE) {
		return (SCORE_ZERO);
	}

	iSigma += SCORE_GAUSS_RANGE;

	return (rgScoreGaussArea[iSigma]);

} // ScoreGaussianTail

/* Computes the probability that a value was < -|x| or > |x| */

SCORE
ScoreGaussianTail2(
	int x,
	SCORE_GAUSSIAN *pScoreGaussian
) {

	int iSigma;
	SCORE score;

	/* Convert x to negative sigmas from the mean, scaling by our scale and rounding properly, 
	defeating	C's desire to round negative numbers up. */

	iSigma = (x - pScoreGaussian->mean)*SCORE_GAUSS_SCALE;
	if (iSigma >= 0) {
		iSigma = -iSigma;
	}
	iSigma -= pScoreGaussian->sigma/2;

	/* If there is no standard deviation, treat as a delta function */

	if (pScoreGaussian->sigma == 0) {
		if (iSigma == 0) {
			return (SCORE_ONE);
		} 
		return (SCORE_ZERO);
	}

	iSigma /= pScoreGaussian->sigma;

	/* If iSigma is too small, the area is just zero */

	if (iSigma < -SCORE_GAUSS_RANGE) {
		return (SCORE_ZERO);
	}

	iSigma += SCORE_GAUSS_RANGE;

	/* Otherwise, we want the area under both tails, so get the area under one tail and
	double it. */

	score = rgScoreGaussArea[iSigma];
	score = ScoreAddProbs(score,score);

	return (score);

} // ScoreGaussianTail2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\runnet.c ===
/************************************************************
 *
 * runNet.c
 *
 * Bare bones net. 
 * Use this implementation to build and run a net
 *
 * mrevow
 *
 ***********************************************************/
#include <common.h>
#include <runNet.h>
#include <math.h>
#include <math16.h>
#include <limits.h>

// Adjust pBuf to ensure it is an integral multiple of size offset from pStart. 
#define SYNC_BUFF_PNT(pStart, pBuf, size, type) {int cRem; ASSERT((BYTE *)pBuf > (BYTE *)pStart); \
						 if ( (cRem = (((BYTE *)pBuf - (BYTE *)pStart)%size)) > 0) 	pBuf = (type)((BYTE *)pBuf + size - cRem);	}

// Restore a RUN net by assigning members from a
// memory image. Avoid copying where possible
// Returns pointer to next memory location passed the
// last used
BYTE *restoreRunNet(
BYTE		*pBuf,				// IN: Start of memory image
BYTE		*pBCurr,			// IN: Next entry into memory image
RUN_NET		*pNet,				// OUT: Run net structure 
WORD		iVer				// IN: Version number
)
{
	WORD		*pB = (WORD *)pBCurr;
	int			i;

	if (!pBuf || !pNet || !pB)
	{
		return NULL;
	}

	pNet->iVer = iVer;

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cLayer), WORD*)
	pNet->cLayer = *(pB++);
	if (pNet->iVer >= RUN_NET_VER_10)
	{
		// Loss Unit and Txfer Types present
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->lossType), WORD*)
		pNet->lossType = *(LOSS_TYPE *)pB;
		pB += sizeof(pNet->lossType) / sizeof(*pB);
	
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->txfType), WORD*);
		pNet->txfType = (TXF_TYPE *)pB;
		pB += sizeof(*pNet->txfType) / sizeof(*pB) * pNet->cLayer;

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->layerType), WORD*);
		pNet->layerType = (LAYER_TYPE *)pB;
		pB += sizeof(*pNet->layerType) / sizeof(*pB) * pNet->cLayer;
	}

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cWeight), WORD*)
	pNet->cWeight = *(pB++);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cTotUnit), WORD*)
	pNet->cTotUnit = *(pB++);
	
	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cWeight), WORD*)
	pNet->cUnitsPerLayer = pB;
	pB += pNet->cLayer;

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->bUseBias), WORD*)
	pNet->bUseBias = pB;
	pB += pNet->cLayer;

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pWeightScale), WORD*)
	pNet->pWeightScale = pB;
	pB += pNet->cLayer;

	if (pNet->iVer >= RUN_NET_VER_11)
	{
		// Some Integrity checks
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->iInputScaledMeanDataSize), WORD*)
		pNet->iInputScaledMeanDataSize =*(pB++);
		if (pNet->iInputScaledMeanDataSize != sizeof(*pNet->pInputScaledMean))
		{
			return NULL;
		}

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->iInputRangeDataSize), WORD*)
		pNet->iInputRangeDataSize =*(pB++);
		if (pNet->iInputRangeDataSize != sizeof(*pNet->pInputRange))
		{
			return NULL;
		}

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->iWeightDataSize), WORD*)
		pNet->iWeightDataSize =*(pB++);
		if (pNet->iWeightDataSize != sizeof(*pNet->pWeight))
		{
			return NULL;
		}

		SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pInputRange), WORD*)
		pNet->pInputRange = (RREAL *)pB;
		// It is bad news if any of these are not positive
		for (i = 0 ; i < *pNet->cUnitsPerLayer ; ++i)
		{
			if (pNet->pInputRange[i] <= 0)
			{
				return NULL;
			}
		}
		pB += *pNet->cUnitsPerLayer * sizeof(*pNet->pInputRange) / sizeof(*pB);

		SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pInputScaledMean), WORD*)
		pNet->pInputScaledMean = (RREAL_INPUT *)pB;
		pB += *pNet->cUnitsPerLayer * sizeof(*pNet->pInputScaledMean) / sizeof(*pB);

	}

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pInputMean), WORD*)
	pNet->pInputMean = (RREAL *)pB;
	pB += *pNet->cUnitsPerLayer * sizeof(*pNet->pInputMean) / sizeof(*pB);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cWeightByte), WORD*)
	pNet->cWeightByte = *((UINT *)pB);
	pB += sizeof(pNet->cWeightByte) / sizeof(*pB);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(*pNet->pWeight), WORD*)
	pNet->pWeight = (RREAL_WEIGHT *)pB;
	
	return ((void *)((BYTE *)pNet->pWeight + pNet->cWeightByte));
}


// Restore a Locally connected network by assigning members from a
//	memory image. Avoid copying where possible
LOCAL_NET * restoreLocalConnectNet(
void		*pBuf,				// IN: Start of memory image
wchar_t		wNetId,
LOCAL_NET	*pNet				// OUT: Run net structure
)
{
	BYTE		*pB = (BYTE *)pBuf;
	int			iSizeLoad;

	pNet->iVer = *(WORD *)pBuf;

	if (pNet->iVer < RUN_NET_VER_START)
	{
		// No Version information present
		pNet->eNetType = pNet->iVer;
	}
	else
	{
		pB += sizeof(pNet->iVer);
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->eNetType), BYTE*)
		pNet->eNetType = *(WORD *)pB;
	}

	// By definition strong nets are fully connected
	if (pNet->eNetType != (WORD)LOCALLY_CONNECTED)
	{
		return NULL;
	}
	pB += sizeof(pNet->eNetType);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(wNetId), BYTE*)
	if (wNetId != *(wchar_t *)pB)
	{
		return NULL;
	}
	pB += sizeof(wNetId);

	SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->runNet.cWeight), BYTE*)
	if (pB = restoreRunNet(pBuf, pB, &(pNet->runNet), pNet->iVer) )
	{
		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->cConnect), BYTE*)
		pNet->cConnect = * (int *)pB;
		pB += sizeof(pNet->cConnect);

		SYNC_BUFF_PNT(pBuf, pB, sizeof(pNet->pOutConnect->iUnit), BYTE*)
		pNet->pOutConnect = (OUT_CONNECTIONS *)pB;

		if (pNet->iVer >= RUN_NET_VER_10)
		{
			// After VER_10 an integrity check was added

			pB += sizeof(*pNet->pOutConnect) * pNet->cConnect;

			SYNC_BUFF_PNT(pBuf, pB, sizeof(iSizeLoad), BYTE*)
			iSizeLoad = *(int *)pB;
			pB += sizeof(iSizeLoad);
			ASSERT( iSizeLoad == (pB - (BYTE *)pBuf));
		}
		else
		{
			// No integrity check in these files
			iSizeLoad = (pB - (BYTE *)pBuf);
		}

		if (iSizeLoad == (pB - (BYTE *)pBuf))
		{
			return pNet;
		}
		else
		{
			return NULL;
		}
	}
	return NULL;
}
// Ask how much memory a network requires to run. Returns
// memory units required
int getRunTimeNetMemoryRequirements(
void		*pBuf					// IN: Start of net memory image
)
{
	BYTE		*pB = (BYTE *)pBuf;
	RUN_NET		runNet;
	int			iRet = 0, iInc;
	WORD		iVer;

	if (!pBuf)
	{
		return 0;
	}

	if ( (iVer = *(WORD *)pBuf) >= RUN_NET_VER_START)
	{
		// Version Information present
		pB += sizeof(WORD);
		SYNC_BUFF_PNT(pBuf, pB, sizeof(iVer), BYTE*)
	}
	else
	{
		iVer = 0;
	}

	if (   (WORD)FULLY_CONNECTED == *(WORD *)pB 
		|| (WORD)LOCALLY_CONNECTED == *(WORD *)pB)
	{
		pB += sizeof(WORD) + sizeof(wchar_t);;
		SYNC_BUFF_PNT(pBuf, pB, sizeof(wchar_t), BYTE*)

		if (  (pB = restoreRunNet(pBuf, pB, &runNet, iVer) ))
		{
			int		i;

			for (i = 0 ; i < runNet.cLayer ; ++i)
			{
				if ((iInc = runNet.cUnitsPerLayer[i]) > 0)
				{
					if (   i == runNet.cLayer - 1 
						&& iInc == 1)
					{
						// Ok what goes on here??
						// As an efficiency hack we have trained the 2 class
						// recognizer using a single sigmoid output unit.
						// After it runs we break out the single output unit into
						// 2 values (p  and (1-p)) so need to make sure an extra 
						// unit is available
						++iInc;
					}

					iRet += iInc;
				}
				else
				{
					return -1;
				}
			}

		}
	}

	return (iRet > 0 ? iRet : -1);
}
/****************************************************************
*
* NAME: scaleInputs
*
*
* DESCRIPTION:
* Scale all the Inputs (first layer) using stored "bias" and ranges
* This function ensures inputs are in range [0-USHRT_MAX]
* No checking done on input range - assumed this was done at load time (in restoreNet())
* 
* HISTORY
*
* Introduced March 2002 (mrevow) with VER_12
***************************************************************/
static void scaleInputs(RREAL *pInput, RUN_NET *pNet)
{
	int						cUnit;
	RREAL					*pRange, *pMean;
	RREAL_INPUT				*pScaleMean, iTmp;

	pRange		= pNet->pInputRange;
	pScaleMean	= pNet->pInputScaledMean;
	pMean		= pNet->pInputMean;

	for (cUnit = 0 ; cUnit < *pNet->cUnitsPerLayer ; ++cUnit, ++pInput, ++pMean, ++pScaleMean, ++pRange)
	{
		// Special case Invalid features indicated by INT_MAX and INT_MIN
		if (INT_MIN == *pInput)
		{
			*pInput = -(*pMean);
		}
		else if (INT_MAX == *pInput)
		{
			*pInput = USHRT_MAX - *pMean;
		}
		else
		{
			// Normal case scale and clip to range [-USHRT_MAX;USHRT_MAX]
			iTmp	= (RREAL_INPUT)*pInput * (RREAL_INPUT)USHRT_MAX;
			iTmp	-= (RREAL_INPUT)*pScaleMean;
			iTmp	/= *pRange;
			iTmp	= (iTmp > -USHRT_MAX) ? iTmp : -USHRT_MAX;
			*pInput	= (RREAL)((iTmp < USHRT_MAX) ? iTmp : USHRT_MAX);
		}
	}

}
/****************************************************************
*
* NAME: subtractMeans
*
*
* DESCRIPTION:
*
*   Subtract the input means. 
* HISTORY
*
* March 2002 (mrevow) Older version of scaleInputs() above. Code used to be inline
* the runNet() code - just pulled it out into its own function toi make it clean
* deprecated for VER_11 and later
***************************************************************/
static void subtractMeans(RREAL *pInput, RUN_NET *pNet)
{
	int						cUnit;
	RREAL					*pMean;

	pMean	= pNet->pInputMean;

	for (cUnit = 0 ; cUnit < *pNet->cUnitsPerLayer ; ++cUnit, ++pInput, ++pMean)
	{
		*pInput	= *pInput - *pMean;
	}

}

// Run a fully connected classification net. The input units
// are assumed to be initialized with input data
// We adopt the convention that if there is only a single output
// unit (Binary decision) use a sigmoid. For more than 1
// output unit do a softMax
RREAL *runFullConnectNet(
RUN_NET		*pNet,			// In The net to run
RREAL		*pfUnits,		// IN: RAM memory block for the units
UINT		*piWinner		// OUT: Winning output 
)
{

	if (   pNet	&& pfUnits)
	{
		int				iLayer;
		RREAL			*pLow, *pUp;			// Start from input layer	
		RREAL_WEIGHT	*pW;
		int				cUnit = 0;


		if (pNet->iVer >= RUN_NET_VER_11)
		{
			scaleInputs(pfUnits, pNet);
		}
		else
		{
			subtractMeans(pfUnits, pNet);
		}

		pLow = pfUnits;
		pUp = pfUnits + *pNet->cUnitsPerLayer;
		pW = pNet->pWeight;

		// Iterate and  propogate between a "lower" and "upper" layer
		for (iLayer = 1  ; iLayer < pNet->cLayer ; ++iLayer)
		{
			RREAL		*pUpMax;											// Last unit in upper layer
			RREAL		*pLowMax = pLow + pNet->cUnitsPerLayer[iLayer-1];	// Last unit in lower layer

			cUnit = pNet->cUnitsPerLayer[iLayer];
			pUpMax = pUp + cUnit;

			// Initialization depends if Bias units are used
			if (pNet->bUseBias[iLayer])
			{
				RREAL_BIAS	*pwBias;
				int			i, cRem;

				cRem = ((BYTE *)pW - (BYTE*)pNet->pWeight) % sizeof(RREAL_BIAS);
				pwBias = (RREAL_BIAS *)((BYTE *)pW + cRem);

				for (i = 0 ; i < cUnit ; ++i, ++pwBias)
				{
					pUp[i] = (RREAL)*pwBias;
				}
				pW = (RREAL_WEIGHT *)pwBias;
			}
			else
			{
				memset(pUp, 0, sizeof(*pUp) * cUnit);
			}

			// Dot Product with layer below
			for ( ; pLow < pLowMax ; ++pLow)
			{
				RREAL	*pUnit = pUp;

				for ( ; pUnit < pUpMax ; ++pUnit, ++pW)
				{
					*pUnit += *pLow * *pW;
				}


			}

			pLow = pUp;

			// Now Pass through transfer function
			// For the output layer the transfer function
			// depends on how many units
			if (iLayer != pNet->cLayer - 1)
			{
				SIGMOID(pUp, cUnit, pNet->pWeightScale[iLayer]);
			}

			pUp = pUpMax;

		}

		// Now do transfer function on the output units
		if (cUnit == 1)
		{
			// Use sigmoid for binary decisions
			if (*pLow > 0.0F)
			{
				*piWinner = 1;
			}
			else
			{
				*piWinner = 0;
			}
			SIGMOID(pLow, cUnit, pNet->pWeightScale[iLayer]);

			// Simulate having 2 output units
			pLow[1]		= *pLow;
#ifdef FLOAT_NET
			*pLow		= 1.0F - pLow[1];
#else
			*pLow		 = 65536 - pLow[1];
#endif
		}
		else if (pNet->iVer < RUN_NET_VER_START || pNet->lossType >= CROSSENTROPY)
		{
			// Do the softmax
			RREAL		fSum, fMax, *pfO = pLow;
			int			i;

			fMax = *(pfO++);
			*piWinner = 0;

			for (i = 1 ; i < cUnit ; ++i, ++pfO)
			{
				if (*pfO > fMax)
				{
					fMax = *pfO;
					*piWinner = i;
				}
			}

			pfO = pLow;
			fSum = 0;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO = (RREAL)EXP(*pfO - fMax);
				fSum += *pfO;
			}

			if (fSum <= MIN_PREC_VAL)
			{
				return NULL;
			}

			// Normalize;
			pfO = pLow;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO /= fSum;
			}
		}
		else if (pNet->lossType == SUMSQUARE || pNet->lossType  == SUMSQUARE_CLASS)
		{
			RREAL		*pfO = pLow;

			SIGMOID(pLow, cUnit, pNet->pWeightScale[iLayer]);
		}
		
		return (pLow);
	}
	else
	{
		return NULL;
	}

}


// Run a  connected classification net. The input units
// are assumed to be initialized with input data
// We adopt the convention that if there is only a single output
// unit (Binary decision) use a sigmoid. For more than 1
// output unit do a softMax
RREAL *runLocalConnectNet(
LOCAL_NET		*pNet,			// In The net to run
RREAL			*pfUnits,		// IN: RAM memory block for the units
UINT			*piWinner,		// OUT: Winning output 
UINT			*pcOut			// Number of outputs
)
{
	RREAL		*pRange;

	pRange = pNet->runNet.pInputRange;

	if (   pNet	&& pfUnits)
	{
		int				iLayer;
		RREAL			*pLow, *pUp;					// Start from input layer	
		RREAL_WEIGHT	*pW;						// Start of upper layer
		OUT_CONNECTIONS	*pOutConnect;				// Outgoing connections
		int				cUnit = 0, iConnect = 0;

		if (pNet->iVer >= RUN_NET_VER_11)
		{
			scaleInputs(pfUnits, &(pNet->runNet));
		}
		else
		{
			subtractMeans(pfUnits, &(pNet->runNet));
		}


		pLow		= pfUnits;
		pUp			= pfUnits + *pNet->runNet.cUnitsPerLayer;
		pW			= pNet->runNet.pWeight;
		pOutConnect	= pNet->pOutConnect;

		// Initialize all units in the net
		memset(pUp, 0, sizeof(*pUp) * (pNet->runNet.cTotUnit - *pNet->runNet.cUnitsPerLayer));

		// Iterate and  propogate between a "lower" and "upper" layer
		for (iLayer = 1  ; iLayer < pNet->runNet.cLayer ; ++iLayer)
		{
			RREAL		*pLowMax = pLow + pNet->runNet.cUnitsPerLayer[iLayer-1];	// Last unit in lower layer

			cUnit = pNet->runNet.cUnitsPerLayer[iLayer];

			// Add in Bias if used
			if (pNet->runNet.bUseBias[iLayer])
			{
				int			j, cRem;
				RREAL_BIAS	*pwBias;

				cRem = ((BYTE *)pW - (BYTE*)pNet->runNet.pWeight) % sizeof(RREAL_BIAS);
				pwBias = (RREAL_BIAS *)((BYTE *)pW + cRem);

				for (j = 0 ; j < cUnit ; ++j, ++pwBias)
				{
					*(pUp + j) += *pwBias;
				}

				pW = (RREAL_WEIGHT *)pwBias;
			}

			// Dot Product with layer below
			for ( ; pLow < pLowMax ; ++pLow)
			{
				DWORD		i;
				int			iStartUnit = pOutConnect->iUnit;

				while (iStartUnit == pOutConnect->iUnit)
				{
					// Do all outgoing connections from this unit
					for ( i = pOutConnect->iStartUnitOffset; i <= pOutConnect->iEndUnitOffset ; ++i, ++pW)
					{
						*(pfUnits + i) += *pLow * *pW;
					}
					
					++pOutConnect;
					++iConnect;
				}

			}


			// Now Pass through transfer function
			// For the output layer the transfer function
			// depends on how many units
			if (iLayer != pNet->runNet.cLayer - 1)
			{
				SIGMOID(pUp, cUnit, pNet->runNet.pWeightScale[iLayer]);
			}

			pLow = pUp;
			pUp += cUnit;

		}

		if (pcOut)
		{
			*pcOut = cUnit;
		}

		// Now do transfer function on the output units
		if (cUnit == 1)
		{
			// Use sigmoid for binary decisions
			if (*pLow > 0.0F)
			{
				*piWinner = 1;
			}
			else
			{
				*piWinner = 0;
			}
			SIGMOID(pLow, cUnit, pNet->runNet.pWeightScale[iLayer-1]);

			// Simulate having 2 output units
			pLow[1]		= *pLow;
#ifdef FLOAT_NET
			*pLow		= 1.0F - pLow[1];
#else
			*pLow		 = 65536 - pLow[1];
#endif
		}
		else if (pNet->iVer < RUN_NET_VER_START || pNet->runNet.lossType >= CROSSENTROPY)
		{
			// Do the softmax
			RREAL		fSum, fMax, *pfO = pLow;
			int			i;
			RREAL		scale = (RREAL)pNet->runNet.pWeightScale[iLayer-1];

			*pfO /= scale;
			fMax = *(pfO++);
			*piWinner = 0;

			for (i = 1 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO /= scale;

				if (*pfO > fMax)
				{
					fMax = *pfO;
					*piWinner = i;
				}
			}

			fSum = 0;
			pfO = pLow;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO = (RREAL)EXP(*pfO - fMax);
				fSum += *pfO;
			}

			if (fSum <= MIN_PREC_VAL)
			{
				return NULL;
			}

			// Normalize;
			pfO = pLow;
			for (i = 0 ; i < cUnit ; ++i, ++pfO)
			{
				*pfO = (*pfO * SOFT_MAX_UNITY) / fSum;
			}
		}
		else if (pNet->runNet.lossType == SUMSQUARE || pNet->runNet.lossType  == SUMSQUARE_CLASS)
		{
			RREAL		*pfO = pLow;

			SIGMOID(pLow, cUnit, pNet->runNet.pWeightScale[iLayer-1]);
		}
		
		return (pLow);
	}
	else
	{
		return NULL;
	}

}

void * loadNetFromResource(HINSTANCE hInst, int iKey, int *iSize)
{
	HGLOBAL hglb;
	HRSRC hres;
	LPBYTE lpByte;

	*iSize = 0;
	hres = FindResource(hInst, (LPCTSTR)MAKELONG(iKey, 0), (LPCTSTR)TEXT("Net"));

	if (!hres)
	{
		return NULL;
	}

	hglb = LoadResource(hInst, hres);
	if (!hglb)
	{
		return NULL;
	}

	*iSize = SizeofResource(hInst, hres);
	lpByte = LockResource(hglb);
	return (void *)lpByte;
}


LOCAL_NET * loadNet(HINSTANCE hInst, int iKey, int *iNetSize, LOCAL_NET *pNet)
{
	void		*pRet = NULL;
	int			iResSize;

	
	*iNetSize = 0;
	pRet = loadNetFromResource(hInst, iKey, &iResSize);

	if ( !pRet || !(pNet = restoreLocalConnectNet(pRet, 0, pNet)) )
	{
		return NULL;
	}

	*iNetSize = getRunTimeNetMemoryRequirements(pRet);

	if (*iNetSize <= 0)
	{
		return NULL;
	}

	return pNet;
}

#ifdef NET_FLOAT
// Pass a vector through a transfer function. Replaces vector
// Here we use sigmoid
// Warning Does not check sanity of pVec
RREAL * fsigmoid(
RREAL		*pVec,			// IN vector of Values Not checked for NULL
int			cVec,			// IN: Size of vector
WORD		scale
)
{
	RREAL	*pVmax = pVec + cVec;
	RREAL	tmp;
	for (; pVec < pVmax ; ++pVec)
	{
		*pVec /= (RREAL)scale;
		tmp = *pVec / 65536.0F;
		tmp = (1.0F + exp(-tmp));
		tmp = 1.0F / tmp;
		*pVec = tmp * 65536.0F;
	}

	return pVec;
}
#else
// Quick integer versions

RREAL * isigmoid(
RREAL		*pVec,			// IN vector of Values Not checked for NULL
int			cVec,			// IN: Size of vector
WORD		scale
)
{
	RREAL	*pVmax = pVec + cVec;

	for (; pVec < pVmax ; ++pVec)
	{
		*pVec /= (RREAL)scale;
		*pVec = Sigmoid16(*pVec);
	}

	return pVec;
}

// Exponential for val <= 0
RREAL iexp(RREAL val)
{
	UINT		iV;
	int		iSigMax = ( 1 << 16);

	ASSERT(val <= 0);

	if (val < 0)
	{
		iV = Sigmoid16(val);
		val = (iV << 16) / ( iSigMax - iV);
	}
	else
	{
		val = iSigMax;
	}

	return val;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\toolprs.c ===
/******************************************************************************\
 *	FILE:	toolprs.c
 *
 *	This is the command line argument parsing code called by the template
 *	toolmain.c, which is used in all the command line tools.  Since it may
 *	be necessary to supp
\******************************************************************************/

// Standard Headers.
// SETUP: all tools need common.h, some need other headers as well, 
// add any needed ones.
#include <stdlib.h>
#include <direct.h>		// For _wgetcwd()
#include <time.h>		// For time() & ctime()
#include <fcntl.h>
#include <io.h>
#include "common.h"
#include "toolmain.h"

// Place to store program name.
static wchar_t		g_pProgram[_MAX_FNAME];

// Timing information used by start and end status procedures.
static time_t		g_timeStart, g_timeEnd;

// Code to actually process a switch.
// SETUP: You only need to change this if you have a new switch type.
// Return of -1 is error, otherwise, this specifies how many extra
// parameters were used.
static int
ProcessSwitch(
	SWITCH_SPEC	const *pSwitchSpec,	// Selected switch spec.
	int			argc,				// Number of remaining arguments
	wchar_t		**argv				// Pointer to remaining arguments
) {
	switch (pSwitchSpec->switchType) {
		case SWITCH_HELP :		// Return error, whitch prints help.
			return -1;

		case SWITCH_BOOL :		// Boolean,
			*(BOOL *)pSwitchSpec->pSwitch	= TRUE;
			break;

		case SWITCH_STRING :	// A string.
			// Make sure value exists.
			if (argc < 1) {
				fwprintf(stderr, L"Missing value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			*(wchar_t **)pSwitchSpec->pSwitch	= argv[0];
			return 1;

		case SWITCH_UNSIGNED :	{	// An unsigned number.
			unsigned int		iValue;
			wchar_t				*pEnd;

			// Make sure value exists.
			if (argc < 1) {
				fwprintf(stderr, L"Missing value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			// Convert number
			iValue	= wcstoul(argv[0], &pEnd, 10);
			if (*pEnd != L'\0' || pEnd == argv[0]) {
				fwprintf(stderr, L"Invalid switch value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			*(unsigned int *)pSwitchSpec->pSwitch	= iValue;
			return 1;
		}

		case SWITCH_INT :	{	// An integer
			int			iValue;
			wchar_t		*pEnd;

			// Make sure value exists.
			if (argc < 1) {
				fwprintf(stderr, L"Missing value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			// Convert number
			iValue	= wcstol(argv[0], &pEnd, 10);
			if (*pEnd != L'\0' || pEnd == argv[0]) {
				fwprintf(stderr, L"Invalid switch value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			*(int *)pSwitchSpec->pSwitch	= iValue;
			return 1;
		}

		case SWITCH_DOUBLE :	{	// A floating point number.
			float				eValue;
			int					count;
			int					length;
			wchar_t				*pEnd;

			if (argc < 1) {
				fwprintf(stderr, L"Missing value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			// Convert number
			count	= swscanf(argv[0], L"%f%n", &eValue, &length);
			pEnd	= argv[0] + length;
			if (count != 1 || *pEnd != L'\0' || pEnd == argv[0]) {
				fwprintf(stderr, L"Invalid switch value for switch '%c'\n",
					pSwitchSpec->wchSwitch
				);
				return -1;
			}

			*(double *)pSwitchSpec->pSwitch	= (double)eValue;
			return 1;
		}

		default:
			fwprintf(stderr, L"Program error in switch parser!\n");
			exit(-2);
	}

	return 0;  // Default, no extra args used.
}

// Return a string representing the value of the passed in switch.
// SETUP: You only need to change this if you added a new type above.
static wchar_t *
SwitchToString(SWITCH_SPEC	const *pSwitchSpec)
{
	static wchar_t		aRetBuf[256];

	switch (pSwitchSpec->switchType) {
		case SWITCH_HELP :		// Don't bother showing state for help.
			return (wchar_t *)0;;

		case SWITCH_BOOL :		// Boolean,
			if (*(BOOL *)pSwitchSpec->pSwitch) {
				return L"TRUE";
			} else {
				return L"FALSE";
			}
			break;	// Should never get here.

		case SWITCH_STRING :	// A string.
			return *(wchar_t **)pSwitchSpec->pSwitch;

		case SWITCH_UNSIGNED :	// An unsigned number.
			swprintf(aRetBuf, L"%u", *(unsigned int *)pSwitchSpec->pSwitch);
			return aRetBuf;

		case SWITCH_INT :	// An integer.
			swprintf(aRetBuf, L"%d", *(int *)pSwitchSpec->pSwitch);
			return aRetBuf;

		case SWITCH_DOUBLE :	// An unsigned number.
			swprintf(aRetBuf, L"%f", *(double *)pSwitchSpec->pSwitch);
			return aRetBuf;

		default:
			fwprintf(stderr, L"Program error in switch printing!\n");
			exit(-2);
	}

	// Should never get here, but don't fail if we do.
	return (wchar_t *)0;;
}

// Code to actually process an argument.
// SETUP: You only need to change this if you have a new argument type.
// Return of FALSE is error, TRUE is success.
static BOOL
ProcessArgument(ARG_SPEC const *pArgSpec, wchar_t *pArgText)
{
	BOOL	fFixMode;
	FILE	*pFile;
	wchar_t	pError[256];
	wchar_t	pFileInput[256];

	// Record text of argument.
	*pArgSpec->ppText	= pArgText;

	// Now process based on type of argument.
	switch (pArgSpec->argType) {
		case ARG_STRING :		// Any old string
			// Saving the string is all we needed to do.
			break;

		case ARG_FILE :			// File to open with specified mode.
			// Check for special names for standard IO files.
			fFixMode	= FALSE;
			if (wcscmp(pArgText, ARG_STDIN) == 0) {
				pFile		= stdin;
				fFixMode	= TRUE;
			} else if (wcscmp(pArgText, ARG_STDOUT) == 0) {
				pFile		= stdout;
				fFixMode	= TRUE;
			} else if (wcscmp(pArgText, ARG_STDERR) == 0) {
				pFile		= stderr;
				fFixMode	= TRUE;
			} else {
				// Normal open code.
				pFile = _wfopen(pArgText, pArgSpec->pMode);
				if (!pFile) {
					swprintf(pError, L"Couldn't open %s with mode %s", 
						pArgText, pArgSpec->pMode
					);
					_wperror(pError);
					return FALSE;;
				}
			}

			// For already opened files, we may need to make them binary.
			if (fFixMode 
				&& (pArgSpec->pMode[wcscspn(pArgSpec->pMode, L"bB")] != '\0')
			) {
				int		result;

				result = _setmode(_fileno(pFile), _O_BINARY);
				if( result == -1 ) {
					swprintf(pError, L"Couldn't set %s to binary mode",pArgText);
					_wperror(pError);
				}
			}
			*(FILE **)pArgSpec->pValue	= pFile;
			break;

		case ARG_FILE_UTIL :	// File to open with UtilOpen
			// Do the open.
			pFile = UtilOpen(
				pArgText, pArgSpec->pMode, 
				pFileInput, 256
			);

			// Did it work?
			if (!pFile) {
				swprintf(pError, L"Couldn't open %s with mode %s", 
					pArgText, pArgSpec->pMode
				);
				_wperror(pError);
				return FALSE;;
			}

			// Return results, note that the path is never freed.
			*pArgSpec->ppText	= _wcsdup(pFileInput);
			*(FILE **)pArgSpec->pValue	= pFile;
			break;

		case ARG_UNSIGNED :	{	// An unsigned number.
			unsigned int		iValue;
			wchar_t				*pEnd;

			// Convert number
			iValue	= wcstol(pArgText, &pEnd, 10);
			if (*pEnd != L'\0' || pEnd == pArgText) {
				fwprintf(stderr, L"Not a valid unsigned number: %s\n", pArgText);
				return FALSE;
			}

			*(unsigned int *)pArgSpec->pValue	= iValue;
			break;
		}

		case ARG_DOUBLE :	{	// A floating point number.
			float				eValue;
			int					count;
			int					length;
			wchar_t				*pEnd;

			// Convert number
			count	= swscanf(pArgText, L"%f%n", &eValue, &length);
			pEnd	= pArgText + length;
			if (count != 1 || *pEnd != L'\0' || pEnd == pArgText) {
				fwprintf(stderr, L"Not a valid floating point number: %s\n", pArgText);
				return FALSE;
			}

			*(double *)pArgSpec->pValue	= (double)eValue;
			break;
		}

		default:
			fwprintf(stderr, L"Program error in argument parser!\n");
			exit(-2);
	}

	return TRUE;  // Default, success.
}

// Code to cleanup anything related to an argument just before the
// program exits.  Typically this is where we close the files we
// opened at startup time.
// SETUP: You only need to change this if you have a new argument type.
// Return of FALSE is error, TRUE is success.
static BOOL
CleanupArgument(ARG_SPEC const *pArgSpec)
{
	// Now process based on type of argument.
	switch (pArgSpec->argType) {
		case ARG_FILE :			// File to open with specified mode.
		case ARG_FILE_UTIL :	// File to open with UtilOpen
			// Close up the file.
			if (fclose(*(FILE **)pArgSpec->pValue) != 0) {
				return FALSE;
			}
			break;

		case ARG_STRING :		// Any old string
		default:
			// No processing needed before exit.
			break;
	}

	return TRUE;  // Default, success.
}

// Code to parse the arguments.
BOOL
ToolMainParseArguments(PARSE_INFO const *pParseInfo, int argc, wchar_t **argv)
{
	int		cArgsParsed;
	wchar_t	pDrive[_MAX_DRIVE], pDir[_MAX_DIR], pExt[_MAX_EXT];

	// Deal with program name.
	_wsplitpath(argv[0], pDrive, pDir, g_pProgram, pExt); 
	--argc;
	++argv;

	// Scan all the arguments.
	cArgsParsed		= 0;
	while (argc > 0) {
		// Check for switches
		if (argv[0][0] == L'-') {
			// We have a switch list
			wchar_t		*pScan;
			int			cSwitchValues;

			pScan			= argv[0] + 1;
			--argc;
			++argv;
			for (; *pScan; ++pScan) {
				SWITCH_SPEC		const *pScanSS;
				SWITCH_SPEC		const *pLimitSS;

				// Figure out which switch it is.
				pLimitSS  = pParseInfo->pSwitchSpecs + pParseInfo->cSwitchSpecs;
				for (
					pScanSS = pParseInfo->pSwitchSpecs;
					pScanSS < pLimitSS;
					++pScanSS
				) {
					if (*pScan == pScanSS->wchSwitch) {
						// Found switch
						break;
					}
				}

				// Check for falling off end of list.
				if (pScanSS >= pLimitSS) {
					fwprintf(stderr, L"Unknown switch '%c'\n", *pScan);
					return FALSE;
				}

				// Found switch, process it.
				cSwitchValues	= ProcessSwitch(pScanSS, argc, argv);
				if (cSwitchValues < 0) {
					return FALSE;
				}
				argc			-= cSwitchValues;
				argv			+= cSwitchValues;
			}
		} else {
			// We have an argument.  Have we run out of known ones?
			if (cArgsParsed >= pParseInfo->cArgSpecs) {
				fwprintf(stderr, L"Too many arguments provided.\n");
				return FALSE;
			}

			// OK, it is expected, process it.
			if (!ProcessArgument(
				pParseInfo->pArgSpecs + cArgsParsed, argv[0]
			)) {
				return FALSE;
			}

			// Argument successfully processed.
			++cArgsParsed;
			--argc;
			++argv;
		}
	}
	
	// Handle defaulted arguments.
	while (cArgsParsed < pParseInfo->cArgSpecs) {
		if (!pParseInfo->pArgSpecs[cArgsParsed].pDefault) {
			fwprintf(stderr, L"Too few arguments specified.\n");
			return FALSE;
		}

		// Handle default value.
		if (!ProcessArgument(
			pParseInfo->pArgSpecs + cArgsParsed,
			pParseInfo->pArgSpecs[cArgsParsed].pDefault
		)) {
			return FALSE;
		}

		// Argument successfully defaulted.
		++cArgsParsed;
	}

	return TRUE;
}

// Load in locale information.
BOOL
ToolMainLoadLocale(
	PARSE_INFO		const *pParseInfo,
	LOCRUN_INFO		*pLocRunInfo,
	LOCTRAIN_INFO	*pLocTrainInfo
) {
	wchar_t			aPath[128];
	FILE			*pLogTo		= *pParseInfo->ppLogFile ? *pParseInfo->ppLogFile : stderr;

	// Generate path for locale files.
	FormatPath(aPath, *pParseInfo->ppTreeRoot, L"tsunami\\dll",
		*pParseInfo->ppLocale, *pParseInfo->ppConfigName, (wchar_t *)0
	);

	// Load runtime localization information from a file.
	if (!LocRunLoadFile(pLocRunInfo, aPath)) {
		fwprintf(pLogTo, L"Can't open runtime localization file.\n");
		return FALSE;
	}

	// Load runtime localization information from a file.
	if (!LocTrainLoadFile(pLocRunInfo, pLocTrainInfo, aPath)) {
		fwprintf(pLogTo, L"Can't open train time localization file.\n");
		return FALSE;
	}

	return TRUE;
}

// Load in locale information.
BOOL
ToolMainLoadLocaleEx(
	PARSE_INFO		const *pParseInfo,
	LOCRUN_INFO		*pLocRunInfo,
	LOCTRAIN_INFO	*pLocTrainInfo,
	wchar_t			*pRecognizer
) {
	wchar_t			aPath[128];
	FILE			*pLogTo		= *pParseInfo->ppLogFile ? *pParseInfo->ppLogFile : stderr;

	// Generate path for locale files.
	FormatPath(aPath, *pParseInfo->ppTreeRoot, pRecognizer, L"dll",
		*pParseInfo->ppLocale, *pParseInfo->ppConfigName
	);

	// Load runtime localization information from a file.
	if (!LocRunLoadFile(pLocRunInfo, aPath)) {
		fwprintf(pLogTo, L"Can't open runtime localization file.\n");
		return FALSE;
	}

	// Load runtime localization information from a file.
	if (!LocTrainLoadFile(pLocRunInfo, pLocTrainInfo, aPath)) {
		fwprintf(pLogTo, L"Can't open train time localization file.\n");
		return FALSE;
	}

	return TRUE;
}

// Code to print out usage message.
void
ToolMainUsage(PARSE_INFO const *pParseInfo)
{
	int		ii;

	fwprintf(stderr, L"Usage: %s %s\n",
		g_pProgram, pParseInfo->ppUsageStrings[0]
	);

	for (ii = 1; ii < pParseInfo->cUsageStrings; ++ii) {
		fwprintf(stderr, L" %s\n", pParseInfo->ppUsageStrings[ii]);
	}
}

// Output header for log file.
void
ToolMainLogHeader(PARSE_INFO const *pParseInfo, int argc, wchar_t **argv)
{
	FILE	* const pLogFile	= *pParseInfo->ppLogFile;
	int			ii;
	int			maxName;
	wchar_t		pWorkingDir[256];

	// Log name of program and the command line.
	fwprintf(pLogFile, L"Application: %s\n", g_pProgram);

	fwprintf(pLogFile, L"Command line: ");
	for (ii = 0; ii < argc; ++ii) {
		fwprintf(pLogFile, L"%s ", argv[ii]);
	}
	putwc('\n',pLogFile);

	// Log directory we are running from.
	_wgetcwd(pWorkingDir, 256);
	fwprintf(pLogFile, L"Working Directory: %s\n", pWorkingDir);

	// Log the values for each switch.
	fwprintf(pLogFile, L"Program switch values:\n");
	for (ii = 0; ii < pParseInfo->cSwitchSpecs; ++ii) {
		wchar_t		*pValueStr;

		// Make sure we have a value worth printing.
		pValueStr	= SwitchToString(pParseInfo->pSwitchSpecs + ii);
		if (pValueStr) {
			fwprintf(pLogFile, L"  -%c is %s\n",
				pParseInfo->pSwitchSpecs[ii].wchSwitch, pValueStr
			);
		}
	}

	// Figure out longest label to use in formating list.
	maxName	= 0;
	for (ii = 0; ii < pParseInfo->cArgSpecs; ++ii) {
		int		cName;

		cName	= wcslen(pParseInfo->pArgSpecs[ii].pName);
		if (maxName < cName) {
			maxName	= cName;
		}
	}

	// Log values for each parameter
	fwprintf(pLogFile, L"Program argument values:\n");
	for (ii = 0; ii < pParseInfo->cArgSpecs; ++ii) {
		fwprintf(pLogFile, L"%*s: %s\n",
			maxName + 2, pParseInfo->pArgSpecs[ii].pName,
			*pParseInfo->pArgSpecs[ii].ppText
		);
	}

	// Log the time we started.
	time(&g_timeStart);
	fwprintf(pLogFile, L"Start Time: %s", _wctime(&g_timeStart));

	// Blank line to seperate this from anything the program logs.
	putwc('\n', pLogFile);
}

// Output Trailer for log file.
void
ToolMainLogTrailer(PARSE_INFO const *pParseInfo)
{
	FILE	* const pLogFile	= *pParseInfo->ppLogFile;

	// A Blank line to seperate from any logged messages.
	putwc('\n', pLogFile);

	// When did we finish, and how long did we run?
	time(&g_timeEnd);
	fwprintf(pLogFile, L"End Time: %s", _wctime(&g_timeEnd));
	fwprintf(pLogFile, L"Elapsed Time: %d seconds\n", g_timeEnd - g_timeStart);
}

// Close all the files we opened up.
BOOL
ToolMainCleanup(
	PARSE_INFO		const *pParseInfo,
	LOCRUN_INFO		*pLocRunInfo,
	LOCTRAIN_INFO	*pLocTrainInfo
) {
	BOOL	status;
	int		ii;

	// Default to success.
	status	= TRUE;

	// Close up the arguments.
	for (ii = 0; ii < pParseInfo->cArgSpecs; ++ii) {
		if (!CleanupArgument(pParseInfo->pArgSpecs + ii)) {
			status	= FALSE;
		}
	}

	// Close up locale files if needed.
	if (pLocRunInfo && !LocRunUnloadFile(pLocRunInfo)) {
		status	= FALSE;
	}
	if (pLocTrainInfo && !LocTrainUnloadFile(pLocTrainInfo)) {
		status	= FALSE;
	}

	// Give some indication of a problem to the outside world if cleanup
	// was not successfull.
	if (!status) {
		fwprintf(stderr, L"Error during cleanup?!?\n");
	}

	// Let caller know status.
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\unigram.c ===
/************************************************************************************************
 * FILE: unigram.c
 *
 *	Code to use the unigram tables.
 *
 ***********************************************************************************************/

#include <stdio.h>
#include "common.h"

// Load unigram information from an image already loaded into memory.
BOOL
UnigramLoadPointer(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, void *pData)
{
	const UNIGRAM_HEADER	*pHeader	= (UNIGRAM_HEADER *)pData;
	BYTE					*pScan;

	// Verify that it is a valid file.
	if (
		(pHeader->fileType != UNIGRAM_FILE_TYPE)
		|| (pHeader->headerSize < sizeof(*pHeader))
		|| (pHeader->minFileVer > UNIGRAM_CUR_FILE_VERSION)
		|| (pHeader->curFileVer < UNIGRAM_OLD_FILE_VERSION)
		|| memcmp (pHeader->adwSignature, pLocRunInfo->adwSignature,sizeof(pHeader->adwSignature))
	) {
		goto error;
	}

	// Fill in information from header.
	pUnigramInfo->cScores		= pHeader->cScores;
	pUnigramInfo->iRareScore	= pHeader->iRareScore;

	// Fill in pointers to the other data in the file
	pScan						= (BYTE *)pData + pHeader->headerSize;
	pUnigramInfo->pScores		= (BYTE *)pScan;

	// Default unused values for file handle information
	pUnigramInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pUnigramInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pUnigramInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	// ?? Should verify that we don't point past end of file ??

	return TRUE;

error:
	return FALSE;
}

// Get unigram probability for selected characters.  Characters must be passed in as
// dense coded values.
FLOAT
UnigramCost(
	UNIGRAM_INFO	*pUnigramInfo,
	wchar_t			dch
) {
	int		score;

	if (dch < pUnigramInfo->cScores) {
		score	= pUnigramInfo->pScores[dch] + pUnigramInfo->iOffset;
	} else {
		score	= pUnigramInfo->iRareScore;
	}

	// Copied from old code, don't know why we do it this way.  The score is
	// (-10 * Log2(prob)) so we are returning (log2(prob) / 10).
	return (-score) / (FLOAT) 100.0;
}

#ifdef ZTRAIN
// Takes a character (possibly folded) and returns the probability of that
// character occurring.  The probability is computed from the unigrams
// we have collected from Japanese newspaper text.
//
// This was created from SpecialUnigramCost that was in several programs.
float
UnigramCostFolded(LOCRUN_INFO *pLocRunInfo, UNIGRAM_INFO *pUnigramInfo, wchar_t wFold)
{
    const wchar_t	*pwmatch;
    double			eMin, eMinNew;
    int				iFold;
	int				cSamples;

    //
    // If it's a folded character, use the score that has the best
    // probability.
    //

    if (LocRunIsFoldedCode(pLocRunInfo, wFold)) {
        pwmatch		= LocRunFolded2FoldingSet(pLocRunInfo, wFold);
        eMin		= 0.0;
		cSamples	= 0;

        for (iFold = 0; (pwmatch[iFold] != 0)
			&& (iFold < LOCRUN_FOLD_MAX_ALTERNATES); iFold++
		) {
            eMinNew		 = UnigramCost(pUnigramInfo, pwmatch[iFold]);
            eMinNew		*= -100.0;
            eMinNew		 = exp(((double) eMinNew) * log(2.0) / -10.0);
			cSamples	+= DynamicNumberOfSamples(pwmatch[iFold]);

            eMin	+= eMinNew;
        }
    } else {
        eMin	 = UnigramCost(pUnigramInfo, wFold);
        eMin	*= -100.0;
        eMin	 = exp(((double) eMin) * log(2.0) / -10.0);
		cSamples = DynamicNumberOfSamples(wFold);
    }

    //
    // Ok we have the probability of that character occurring in eMin.
    // Normalize this for the trainset distribution.
    //

    eMin /= (double)cSamples;

	return (float)eMin;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\util.c ===
/* This file contain some common functions used by many of the Rodan utilities */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <direct.h>
#include <strsafe.h>
#include "common.h"

// Attempt to fopen pszFileName in mode pszMode. If that fails, try it in the subdirectory
// above the current one.  Continue up the directory tree until you reach the top.  Return
// NULL only if ALL attempts fail.  In case of success, return the actual path to the
// opened file in pszFullPath.  cchFullPathMax is the size of the buffer pszFullPath
// points to. 
// [donalds] 10-13-96 Made UNICODE/ANSI safe.

FILE *UtilOpenPath(TCHAR *pszPath, TCHAR *pszFileName, TCHAR *pszMode, TCHAR  *pszFullPath, int cchFullPathMax) 
{
	TCHAR  *pszT;
	FILE   *pFile;
	int		i;

// Make a copy of the path to start from so we can modify it
// and return the one we really used

	if (pszFullPath != pszPath) 
	{
		if (StringCchCopy(pszFullPath, cchFullPathMax, pszPath) != S_OK)
		{
			return (FILE *)0;
		}
	}

// Make sure the directory path ends with a backslash '\'
	
	i = _tcslen(pszFullPath);
	if (i == 0 || (pszFullPath[i-1] != '\\' && pszFullPath[i-1] != '/')) 
	{
		pszFullPath[i] = '\\';
		pszFullPath[i+1] = '\0';
	}

	while (TRUE) 
	{
		
	// Tack the filename onto the current directory name

		if (StringCchCat(pszFullPath, cchFullPathMax, pszFileName) != S_OK)
		{
			return (FILE *)0;
		}

	// If we can open this, return successfully

		if (pFile = _tfopen(pszFullPath,pszMode))
			return pFile;

	// See if we can back up one directory.  First remove the file at the end

		pszT = _tcsrchr(pszFullPath,'\\');
	   *pszT = '\0';

	// Now look for the previous directory, if any

		if ((pszT = _tcsrchr(pszFullPath,'\\')) == (TCHAR *) NULL)
			return (FILE *) NULL;

	// Drop the directory name but keep the slash

		pszT[1] = '\0';
	}
}

// The basic UtilOpen call, uses the UtilOpenPath to traverse up the tree.
// [donalds] 10-13-96 Made UNICODE/ANSI safe.

FILE *UtilOpen(TCHAR *pszFileName, TCHAR *pszMode, TCHAR *pszFullPath, int cchFullPathMax) 
{
	FILE *pFile;

	// Check for null file name, or a file name that is too long to fit.
	if (!pszFileName || !*pszFileName || _tcslen(pszFileName) + 1 > (unsigned) cchFullPathMax) {
		return (FILE *)NULL;
	}

	// Try it once as is
    if (pFile = _tfopen(pszFileName,pszMode)) {
		_tcsncpy(pszFullPath, pszFileName, cchFullPathMax);
		return pFile;
	}

	// Check for a path.  We can't try our normal search if it is anything but a simple file name.
	if (_tcschr(pszFileName, _T('\\')) || _tcschr(pszFileName, _T('/')
		|| (_tcslen(pszFileName) > 2 && pszFileName[1] == _T(':')))
	) {
		return (FILE *)NULL;
	}

	// Find the directory we're currently in.  If the directory doesn't fit in the output
	// variable, or of adding the file name on to the path doesn't fit, return an error.
	if (_tgetcwd(pszFullPath, cchFullPathMax) == NULL ||
		_tcslen(pszFullPath) + 1 + _tcslen(pszFileName) + 1 > (unsigned) cchFullPathMax)
	{
		return (FILE *)NULL;
	}

	return UtilOpenPath(pszFullPath, pszFileName, pszMode, pszFullPath, cchFullPathMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\algo.h ===
/*
** algo.h:	Header file for algorithm related macros & constants.
**
**
*/

#ifndef _INC_ALGO
#define _INC_ALGO

/********************** Constants ***************************/

#define CODE_NULL 				20

#define CPRIMMAX                30
#define CFEATMAX                CPRIMMAX
#define GEOM_DIST_MAX           900  // maximum geometric distance for 1 prim
#define CMATCHMAX               20

#define STEP_CALLOC             128
#define STEP_CREALLOC 			32

#define DIST_GEOM_PRUNE 		225
#define DIST_GEOM_PRUNE_SQRT 	15
#define DIST_MAX                9999

#define COORD_MAX               0x7fff
#define	SLOPE_MAX				0x7FFFFFFF

// Featureization codes used.
#define	FEAT_RIGHT				0	// Straight to the right. Major feature
#define FEAT_DOWN_RIGHT			1	// Straight in area between RIGHT and DOWN
#define	FEAT_DOWN				2	// Straight down. Major feature
#define	FEAT_OTHER				3	// Straight in other direction. Catchall feature
#define FEAT_COMPLEX			4	// Catchall for complex features.
#define FEAT_CLOCKWISE_4		5	// 4 different amounts of clockwise curve
#define FEAT_CLOCKWISE_3		6	//	higher number -> more curve
#define FEAT_CLOCKWISE_2		7
#define FEAT_CLOCKWISE_1		8
#define FEAT_C_CLOCKWISE_1		9	// 4 different amounts of counter clockwise curve
#define FEAT_C_CLOCKWISE_2		10  //	higher number -> more curve
#define FEAT_C_CLOCKWISE_3		11
#define FEAT_C_CLOCKWISE_4		12
#define	FEAT_2F_RI_CW			13	// 'two feature' features, uses abbreviations:
#define	FEAT_2F_RI_CC			14	//		RI	FEAT_RIGHT
#define	FEAT_2F_DR_CW			15	//		DR	FEAT_DOWN_RIGHT
#define	FEAT_2F_DR_CC			16	//		DN	FEAT_DOWN
#define	FEAT_2F_DN_CW			17	//		OT	FEAT_OTHER
#define	FEAT_2F_DN_CC			18	//		CW	FEAT_CLOCKWISE_*
#define	FEAT_2F_OT_CW			19	//		CC	FEAT_C_CLOCKWISE_*
#define	FEAT_2F_OT_CC			20	//		XX	Any feature.
#define	FEAT_2F_CW_RI			21	
#define	FEAT_2F_CW_DR			22	
#define	FEAT_2F_CW_DN			23	
#define	FEAT_2F_CW_OT			24	
#define	FEAT_2F_CW_CW			25	
#define	FEAT_2F_CW_CC			26	
#define	FEAT_2F_CC_DR			27		
#define	FEAT_2F_CC_DN			28	
#define	FEAT_2F_CC_OT			29	
#define	FEAT_2F_CC_CW			30	
#define	FEAT_2F_CC_CC			31	
#define	FEAT_2F_OTHER			32	
#define	FEAT_3F_RI_DN_CW		33	// 'three feature' features, same abbreviations
#define	FEAT_3F_RI_CW_DN		34	
#define	FEAT_3F_RI_CC_DN		35	
#define	FEAT_3F_RI_CC_CW		36	
#define	FEAT_3F_DN_RI_CC		37	
#define	FEAT_3F_DN_CW_RI		38	
#define	FEAT_3F_DN_CW_CW		39	
#define	FEAT_3F_DN_CW_CC		40	
#define	FEAT_3F_CW_XX_CW		41	
#define	FEAT_3F_CC_CW_RI		42			
#define CPRIM_DIFF              43   // number of different primitives

// Check if a line is long enought to trust its direction.  Used in dehooking and
// in smoothing.
#define MAX_DELTA	2
#define MAX_SPLASH	10
#define	LineSmall(dx, dy)		\
	((dx) >= -MAX_DELTA && (dx) <= MAX_DELTA && (dy) >= -MAX_DELTA && (dy) <= MAX_DELTA)
#define	LineInSplash(dx, dy)		\
	((dx) >= -MAX_SPLASH && (dx) <= MAX_SPLASH && (dy) >= -MAX_SPLASH && (dy) <= MAX_SPLASH)

#pragma pack(1)
// NOTE: code is a byte, otherwise compiler packs it into 32 bits!
typedef struct tagPRIMITIVE
{
    BYTE code;              /* 0-15 stroke fpendown, 4 unused bits. */

    union
    {
      struct
      {
	      short x1; 		   /* start x-coord */
	      short x2; 		   /* end x */
	      short y1; 		   /* start y-coord */
	      short y2; 		   /* end y */
      };

      unsigned char rgch[2];      // now used for storing codewords, JWG 6/29/94

    };

	// JRB: New information for CART
	BYTE	cSteps;			// Number of steps we split the stroke into.
	BYTE	cFeatures;		// Number of features we initially parsed the stroke into.
	BYTE	fDakuTen;		// Does it look like a dakuten?  Only set on last two strokes!?!?
							// Could make this a non-crisp value.
	int		netAngle;		// Net angle traversed by stroke (sum of step angles)
	int		absAngle;		// Total angle traversed by stroke (sum of abs. val. of step angles)
	int		nLength;		// Total length of stroke
	RECT	boundingBox;	// Bounding box of the stroke.
} PRIMITIVE;
#pragma pack()

typedef PRIMITIVE *PPRIMITIVE;

// A level range
typedef struct LEVEL_RANGE {
	BYTE	start;
	BYTE	end;
} LEVEL_RANGE;

// Item in proto array.
typedef union PROTO_ITEM {
	WORD		dbcs;		// Code point

	BYTE		code;		// Feature code

	LEVEL_RANGE	level;		// Level info for X or Y of one coordinate
} PROTO_ITEM;

typedef struct tagPROTO_HEADER
{
	DWORD			cAlloc;			// Number prototypes we have allocated space for.
    DWORD           cProto;			// Number of prototypes
	PROTO_ITEM 		*pPrototypes;	// Prototypes one after another.
									// Each prototype has a code point followed by 
									// numStokes * (code x1 y1 x2 y2)
} PROTO_HEADER;

typedef struct tagSTEP
{
	int		x;
	int		y;
	short	length;
	short	angle;
	short	deltaAngle;		// Delta Angle from previous step or 0 if no previous.
} STEP;

typedef struct tagKPROTO
{
	RECT		rect;
	WORD		cfeat;
	PRIMITIVE	*rgfeat;
} KPROTO;

typedef struct tagMATCH
{
	SYM		sym;
	WORD 	dist;
} MATCH;

/********************** Macros ***************************/
#define SetStepXRGSTEP(rg, i, bx)	((rg)[i].x = (bx))
#define SetStepYRGSTEP(rg, i, by)	((rg)[i].y = (by))
#define GetStepXRGSTEP(rg, i)			((rg)[i].x)
#define GetStepYRGSTEP(rg, i)			((rg)[i].y)

#define SetXmaxFEAT(f, mx)		((f)->rect.right = (mx))
#define SetYmaxFEAT(f, my)		((f)->rect.bottom = (my))
#define SetXminFEAT(f, mx)		((f)->rect.left = (mx))
#define SetYminFEAT(f, my)		((f)->rect.top = (my))
#define GetXmaxFEAT(f)			((f)->rect.right)
#define GetYmaxFEAT(f)			((f)->rect.bottom)
#define GetXminFEAT(f)			((f)->rect.left)
#define GetYminFEAT(f)			((f)->rect.top)

#define SetXbeginFEAT(f, bx)	((f)->ptBegin.x = (bx))
#define SetYbeginFEAT(f, by)	((f)->ptBegin.y = (by))
#define SetXendFEAT(f, ex)		((f)->ptEnd.x = (ex))
#define SetYendFEAT(f, ey)		((f)->ptEnd.y = (ey))
#define GetXbeginFEAT(f)		((f)->ptBegin.x)
#define GetYbeginFEAT(f)		((f)->ptBegin.y)
#define GetXendFEAT(f)			((f)->ptEnd.x)
#define GetYendFEAT(f)			((f)->ptEnd.y)

#define ProtoheaderFromMpcfeatproto(cprim)	&(mpcfeatproto[cprim])

#define SetCprotoRomPROTOHEADER(pprotohdr, cproto)			\
			((pprotohdr)->cprotoRom = (cproto))
#define GetCprotoRomPROTOHEADER(pprotohdr)					\
			((pprotohdr)->cprotoRom)
#define GetCprotoPROTOHEADER(pprotohdr)						\
			((pprotohdr)->cprotoRom)

#define IsMaskedPROTOTYPE(pproto, cs, iBox)	\
(((cs)->rgrecmaskBox != NULL && (UINT)(iBox) < (cs)->crecmaskBox) ?	\
	(((pproto)->recmask & (cs)->rgrecmaskBox[iBox] && (pproto)->langmask & (cs)->langmask) ?	\
		FALSE :	\
		TRUE) :	\
	(((pproto)->recmask & (cs)->recmask && (pproto)->langmask & (cs)->langmask) ?	\
		FALSE : TRUE))

#define CProtoFromMpcfeatproto(ifeat)		(mpcfeatproto[ifeat].cproto)


/********************** Public Prototypes ***************************/

#endif // !_INC_ALGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\valid.c ===
/******************************Module*Header*******************************\
* Module Name: valid.c
*
* Used during training of tsunami and seperation of data for tsunami.
*
* Created: 17-Apr-1996 09:05:14
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include "windows.h"
#include "winnls.h"

#define	FALSE	0
#define	TRUE	1

typedef	struct	tagVALID
{
	unsigned short	wxjis;
	char			nMin;
	char			nMax;
} VALID;

// Table that is the inclusive inclusive range of valid stroke counts
// for a character.

VALID	aiValid[] =
{
	{0x0020, 0, 0},
	{0x0021, 2, 2},
	{0x0022, 2, 2},
	{0x0023, 4, 4},
	{0x0024, 2, 3},
	{0x0025, 1, 3},
	{0x0026, 1, 2},
	{0x0027, 1, 1},
	{0x0028, 1, 1},
	{0x0029, 1, 1},
	{0x002A, 3, 4},
	{0x002B, 2, 2},
	{0x002C, 1, 1}, 
	{0x002D, 1, 1},
	{0x002E, 1, 1}, 
	{0x002F, 1, 1},
	{0x0030, 1, 2},
	{0x0031, 1, 3},
	{0x0032, 1, 1},
	{0x0033, 1, 1},
	{0x0034, 1, 3},
	{0x0035, 1, 3},
	{0x0036, 1, 2},
	{0x0037, 1, 3},
	{0x0038, 1, 2},
	{0x0039, 1, 2},
	{0x003A, 2, 2},
	{0x003B, 2, 2},
	{0x003C, 1, 1},
	{0x003D, 2, 2},
	{0x003E, 1, 1},
	{0x003F, 1, 2},
	{0x0040, 1, 2},
	{0x0041, 1, 3},
	{0x0042, 1, 3},
	{0x0043, 1, 1},
	{0x0044, 1, 2},
	{0x0045, 1, 4},
	{0x0046, 1, 3},
	{0x0047, 1, 3},
	{0x0048, 1, 3},
	{0x0049, 1, 3},
	{0x004A, 1, 2},
	{0x004B, 1, 3},
	{0x004C, 1, 2},
	{0x004D, 1, 4},
	{0x004E, 1, 3},
	{0x004F, 1, 1},
	{0x0050, 1, 2},
	{0x0051, 1, 2},
	{0x0052, 1, 3},
	{0x0053, 1, 1},
	{0x0054, 1, 2},
	{0x0055, 1, 2},
	{0x0056, 1, 2},
	{0x0057, 1, 4},
	{0x0058, 1, 2},
	{0x0059, 1, 3},
	{0x005A, 1, 3},
	{0x005B, 1, 3},
	{0x005C, 1, 1},
	{0x005D, 1, 3},
	{0x005E, 1, 1},
	{0x0061, 1, 3},
	{0x0062, 1, 2},
	{0x0063, 1, 1},
	{0x0064, 1, 2},
	{0x0065, 1, 3},
	{0x0066, 1, 2},
	{0x0067, 1, 3},
	{0x0068, 1, 2},
	{0x0069, 1, 2},
	{0x006A, 1, 2},
	{0x006B, 1, 3},
	{0x006C, 1, 1},
	{0x006D, 1, 3},
	{0x006E, 1, 2},
	{0x006F, 1, 1},
	{0x0070, 1, 2},
	{0x0071, 1, 2},
	{0x0072, 1, 2},
	{0x0073, 1, 1},
	{0x0074, 1, 2},
	{0x0075, 1, 2},
	{0x0076, 1, 2},
	{0x0077, 1, 4},
	{0x0078, 1, 2},
	{0x0079, 1, 2},
	{0x007A, 1, 3},
	{0x007B, 1, 1},
	{0x007C, 1, 2},
	{0x007D, 1, 1},
	{0x007E, 1, 1},
	{0x00A2, 2, 2},
	{0x00A3, 1, 4},
	{0x00A5, 1, 5},
	{0x00A7, 1, 2},
	{0x00B4, 1, 1},
	{0x00B6, 1, 4},
	{0x00D7, 2, 2},
	{0x00F7, 3, 3},
	{0x2010, 1, 1},
	{0x2015, 1, 1},
	{0x2016, 2, 2},
	{0x2017, 2, 2},
	{0x2018, 1, 1},
	{0x2019, 1, 1},
	{0x201C, 2, 2},
	{0x201D, 2, 2},
	{0x2020, 2, 2},
	{0x2021, 3, 3},
	{0x2025, 2, 2},
	{0x2026, 3, 3},
	{0x2030, 3, 4},
	{0x2032, 1, 1},
	{0x2033, 2, 2},
	{0x203B, 6, 6},
	{0x2103, 2, 2},
	{0x212B, 2, 4},
	{0x2191, 1, 3},
	{0x21D2, 2, 4},
	{0x21D4, 3, 6},
	{0x2460, 2, 4},
	{0x2461, 2, 2},
	{0x2462, 2, 2},
	{0x2463, 2, 4},
	{0x2464, 2, 4},
	{0x2465, 2, 2},
	{0x2466, 2, 4},
	{0x2467, 2, 3},
	{0x2468, 2, 3},
	{0x2469, 3, 6},
	{0x246A, 3, 7},
	{0x246B, 3, 5},
	{0x246C, 3, 5},
	{0x246D, 3, 7},
	{0x246E, 3, 7},
	{0x246F, 3, 5},
	{0x2470, 3, 7},
	{0x2471, 3, 6},
	{0x2472, 3, 6},
	{0x2473, 3, 5},
	{0x25C7, 1, 4},
	{0x3000, 0, 0}, 
	{0x3001, 1, 1}, 
	{0x3002, 1, 1}, 
	{0x3003, 2, 2},
	{0x3005, 1, 4},
	{0x3006, 1, 2},
	{0x3007, 1, 1},
	{0x300A, 2, 2},
	{0x300B, 2, 2},
	{0x300C, 1, 2},
	{0x300D, 1, 2},
	{0x300F, 1, 6},
	{0x3010, 0, 0},	// JBENN: FIXME: disable all samples until we support filled areas.
	{0x3011, 0, 0},	// JBENN: FIXME: disable all samples until we support filled areas.
	{0x3012, 3, 3},
	{0x3014, 1, 1},
	{0x3015, 1, 1},
	{0x3041, 1, 3},
	{0x3042, 1, 3},
	{0x3043, 1, 2},
	{0x3044, 1, 2},
	{0x3045, 1, 2},
	{0x3046, 1, 2},
	{0x3047, 2, 2},
	{0x3048, 2, 2},
	{0x3049, 1, 4},
	{0x304A, 1, 4},
	{0x304B, 1, 3},
	{0x304C, 2, 5},
	{0x304D, 1, 4},
	{0x304E, 1, 6},
	{0x304F, 1, 1},
	{0x3050, 1, 3},
	{0x3051, 1, 3},
	{0x3052, 1, 5},
	{0x3053, 1, 2},
	{0x3054, 1, 4},
	{0x3055, 1, 3},
	{0x3056, 1, 5},
	{0x3057, 1, 1},
	{0x3058, 2, 3},
	{0x3059, 1, 2},
	{0x305A, 1, 4},
	{0x305B, 1, 3},
	{0x305C, 2, 5},
	{0x305D, 1, 3},
	{0x305E, 1, 5},
	{0x305F, 1, 4},
	{0x3060, 1, 6},
	{0x3061, 1, 2},
	{0x3062, 1, 4},
	{0x3063, 1, 1},
	{0x3064, 1, 1},
	{0x3065, 1, 3},
	{0x3066, 1, 1},
	{0x3067, 1, 3},
	{0x3068, 1, 2},
	{0x3069, 1, 4},
	{0x306A, 1, 4},
	{0x306B, 1, 3},
	{0x306C, 1, 2},
	{0x306D, 1, 2},
	{0x306E, 1, 1},
	{0x306F, 1, 3},
	{0x3070, 1, 5},
	{0x3071, 1, 4},
	{0x3072, 1, 1},
	{0x3073, 2, 3},
	{0x3074, 2, 2},
	{0x3075, 1, 4},
	{0x3076, 1, 6},
	{0x3077, 2, 5},
	{0x3078, 1, 1},
	{0x3079, 2, 3},
	{0x307A, 2, 2},
	{0x307B, 1, 4},
	{0x307C, 1, 6},
	{0x307D, 2, 5},
	{0x307E, 1, 3},
	{0x307F, 1, 2},
	{0x3080, 1, 3},
	{0x3081, 1, 2},
	{0x3082, 1, 3},
	{0x3083, 1, 3},
	{0x3084, 1, 3},
	{0x3085, 1, 2},
	{0x3086, 1, 2},
	{0x3087, 1, 2},
	{0x3088, 1, 2},
	{0x3089, 1, 2},
	{0x308A, 1, 2},
	{0x308B, 1, 1},
	{0x308C, 1, 3},
	{0x308D, 1, 2},
	{0x308E, 1, 3},
	{0x308F, 1, 3},
	{0x3090, 1, 1},
	{0x3091, 1, 1},
	{0x3092, 1, 3},
	{0x3093, 1, 1},
	{0x309B, 1, 2},
	{0x309C, 1, 1},
	{0x309D, 1, 2},
	{0x309E, 2, 4},
	{0x30A1, 1, 2},
	{0x30A2, 1, 2},
	{0x30A3, 1, 2},
	{0x30A4, 1, 2},
	{0x30A5, 1, 3},
	{0x30A6, 1, 3},
	{0x30A7, 1, 3},
	{0x30A8, 1, 3},
	{0x30A9, 1, 3},
	{0x30AA, 1, 3},
	{0x30AB, 1, 2},
	{0x30AC, 1, 5},
	{0x30AD, 1, 3},
	{0x30AE, 1, 5},
	{0x30AF, 1, 2},
	{0x30B0, 1, 4},
	{0x30B1, 1, 3},
	{0x30B2, 1, 5},
	{0x30B3, 1, 2},
	{0x30B4, 1, 4},
	{0x30B5, 1, 3},
	{0x30B6, 1, 5},
	{0x30B7, 1, 3},
	{0x30B8, 1, 5},
	{0x30B9, 1, 2},
	{0x30BA, 1, 4},
	{0x30BB, 1, 2},
	{0x30BC, 1, 5},
	{0x30BD, 1, 2},
	{0x30BE, 1, 4},
	{0x30BF, 1, 3},
	{0x30C0, 1, 5},
	{0x30C1, 1, 3},
	{0x30C2, 1, 5},
	{0x30C3, 1, 3},
	{0x30C4, 1, 3},
	{0x30C5, 1, 5},
	{0x30C6, 1, 3},
	{0x30C7, 1, 5},
	{0x30C8, 1, 2},
	{0x30C9, 1, 4},
	{0x30CA, 1, 2},
	{0x30CB, 1, 2},
	{0x30CC, 2, 2},
	{0x30CD, 1, 4},
	{0x30CE, 1, 1},
	{0x30CF, 1, 2},
	{0x30D0, 1, 4},
	{0x30D1, 1, 3},
	{0x30D2, 1, 2},
	{0x30D3, 1, 4},
	{0x30D4, 1, 3},
	{0x30D5, 1, 1},
	{0x30D6, 1, 3},
	{0x30D7, 1, 2},
	{0x30D8, 1, 1},
	{0x30D9, 1, 3},
	{0x30DA, 1, 2},
	{0x30DB, 1, 4},
	{0x30DC, 1, 6},
	{0x30DD, 1, 5},
	{0x30DE, 1, 2},
	{0x30DF, 1, 3},
	{0x30E0, 1, 2},
	{0x30E1, 1, 2},
	{0x30E2, 1, 3},
	{0x30E3, 1, 2},
	{0x30E4, 1, 2},
	{0x30E5, 1, 2},
	{0x30E6, 1, 2},
	{0x30E7, 1, 3},
	{0x30E8, 1, 3},
	{0x30E9, 1, 2},
	{0x30EA, 1, 2},
	{0x30EB, 1, 2},
	{0x30EC, 1, 1},
	{0x30ED, 1, 3},
	{0x30EE, 1, 2},
	{0x30EF, 1, 2},
	{0x30F0, 1, 4},
	{0x30F1, 1, 3},
	{0x30F2, 1, 3},
	{0x30F3, 1, 2},
	{0x30F4, 1, 5},
	{0x30F5, 1, 2},
	{0x30F6, 1, 3},
	{0x30FB, 1, 1}, 
	{0x30FC, 1, 1},
	{0x30FD, 1, 1},
	{0x30FE, 2, 3},
	{0x4E00, 1, 1},
	{0x4E03, 2, 2},
	{0x4E08, 3, 3},
	{0x4E09, 1, 3},
	{0x4E0A, 1, 3},
	{0x4E0B, 1, 3},
	{0x4E0E, 3, 3},
	{0x4E11, 4, 5},
	{0x4E15, 4, 5},
	{0x4E18, 4, 5},
	{0x4E26, 6, 8},
	{0x4E2D, 2, 4},
	{0x4E2E, 3, 4},
	{0x4E32, 3, 7},
	{0x4E38, 2, 3},
	{0x4E3B, 4, 5},
	{0x4E4D, 4, 5},
	{0x4E4E, 3, 5},
	{0x4E56, 3, 8},
	{0x4E59, 1, 1},
	{0x4E8C, 1, 2},
	{0x4EBA, 1, 2},
	{0x516B, 1, 2},
	{0x5341, 1, 2},
	{0x53E3, 1, 3},
	{0x58EB, 1, 3},
    {0x5927, 1, 3},
	{0x5DE5, 1, 3},
	{0x5E72, 2, 3},
	{0x66AE, 3, 14},
	{0x72AC, 1, 4},
	{0x7BDD, 7, 16},
	{0x83EB, 2, 11},
	{0x8972, 13,22},
	{0x89E6, 9, 14},
	{0x970A, 10,15},
};

/******************************Public*Routine******************************\
* ValidStrokeCount
*
* This function is very conservative about calling a character invalid
* and is used in training to throw characters that we know have to be
* bad.
*
* Returns 1 if the character has a valid number of strokes or if it
* doesn't find the character in the table.
*
* Returns 0 if the character has an invalid number of strokes according
* to the table.
*
* History:
*  17-Apr-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define VALID_TAB_SIZE (sizeof(aiValid) / sizeof(VALID))

int ValidStrokeCount(wchar_t wch, short iStroke)
{
	short	iLow  = 0;
	short	iPick = VALID_TAB_SIZE / 2;
	short	iHigh = VALID_TAB_SIZE - 1;

	while (TRUE)
	{
	// If we found the character in the table, return its validity

		if (aiValid[iPick].wxjis == wch)
            return (iStroke >= aiValid[iPick].nMin) && (iStroke <= aiValid[iPick].nMax);

	// If we didn't find the character in the table, return TRUE

		if (iLow >= iHigh)
			return TRUE;

	// Adjust the low/high/pick values and try again

		if (aiValid[iPick].wxjis < wch)
			iLow = iPick + 1;				// We need to move up
		else
			iHigh = iPick - 1;				// We need to move down

		iPick = (iLow + iHigh) / 2;
	}
}

// Table that is the inclusive inclusive range of non-suspicious stroke counts
// for a character.

VALID aiNotSusp[] =
{
	{0x0021, 2, 2},
	{0x0023, 4, 4},
	{0x0024, 2, 3},
	{0x0025, 2, 3},
	{0x0026, 1, 2},
	{0x0028, 1, 1},
	{0x0029, 1, 1},
	{0x002A, 3, 4},
	{0x002B, 2, 2},
	{0x002C, 1, 1},
	{0x002D, 1, 1},
	{0x002E, 1, 1},
	{0x002F, 1, 1},
	{0x0030, 1, 1},
	{0x0031, 1, 2},
	{0x0032, 1, 1},
	{0x0033, 1, 1},
	{0x0034, 2, 2},
	{0x0035, 1, 2},
	{0x0036, 1, 1},
	{0x0037, 1, 2},
	{0x0038, 1, 2},
	{0x0039, 1, 1},
	{0x003A, 2, 2},
	{0x003B, 2, 2},
	{0x003C, 1, 1},
	{0x003D, 2, 2},
	{0x003E, 1, 1},
	{0x003F, 2, 2},
	{0x0040, 1, 2},
	{0x0041, 1, 3},
	{0x0042, 1, 2},
	{0x0043, 1, 1},
	{0x0044, 1, 2},
	{0x0045, 1, 4},
	{0x0046, 2, 4},
	{0x0047, 1, 3},
	{0x0048, 2, 3},
	{0x0049, 1, 3},
	{0x004A, 1, 2},
	{0x004B, 2, 3},
	{0x004C, 1, 1},
	{0x004D, 1, 4},
	{0x004E, 1, 3},
	{0x004F, 1, 1},
	{0x0050, 1, 2},
	{0x0051, 1, 2},
	{0x0052, 1, 3},
	{0x0053, 1, 1},
	{0x0054, 1, 2},
	{0x0055, 1, 1},
	{0x0056, 1, 1},
	{0x0057, 1, 1},
	{0x0058, 2, 2},
	{0x0059, 1, 3},
	{0x005A, 1, 2},
	{0x005B, 1, 2},
	{0x005C, 1, 1},
	{0x005D, 1, 2},
	{0x005E, 1, 1},
	{0x0061, 1, 2},
	{0x0062, 1, 2},
	{0x0063, 1, 1},
	{0x0064, 1, 2},
	{0x0065, 1, 1},
	{0x0066, 1, 2},
	{0x0067, 1, 1},
	{0x0068, 1, 1},
	{0x0069, 2, 2},
	{0x006A, 1, 2},
	{0x006B, 1, 3},
	{0x006C, 1, 1},
	{0x006D, 1, 1},
	{0x006E, 1, 1},
	{0x006F, 1, 1},
	{0x0070, 1, 2},
	{0x0071, 1, 2},
	{0x0072, 1, 1},
	{0x0073, 1, 1},
	{0x0074, 2, 2},
	{0x0075, 1, 1},
	{0x0076, 1, 1},
	{0x0077, 1, 1},
	{0x0078, 2, 2},
	{0x0079, 1, 2},
	{0x007A, 1, 2},
	{0x007B, 1, 1},
	{0x007C, 1, 1},
	{0x007D, 1, 2},
	{0x007E, 1, 1},
	{0x00A2, 2, 2},
	{0x00A3, 2, 3},
	{0x00A5, 3, 5},
	{0x00D7, 2, 2},
	{0x00F7, 3, 3},
	{0x2010, 1, 1},
	{0x2015, 1, 1},
	{0x2018, 1, 1},
	{0x2019, 1, 1},
	{0x201C, 2, 2},
	{0x201D, 2, 2},
	{0x2026, 3, 3},
	{0x2030, 4, 4},
	{0x2103, 2, 2},
	{0x21D2, 3, 3},
	{0x21D4, 4, 4},
	{0x3001, 1, 1},
	{0x3002, 1, 1},
	{0x3003, 2, 2},
	{0x3005, 1, 3},
	{0x3006, 1, 1},
	{0x300A, 2, 2},
	{0x300B, 2, 2},
	{0x300C, 1, 2},
	{0x300D, 1, 2},
	{0x300F, 4, 4},
	{0x3012, 3, 3},
	{0x3041, 2, 3},
	{0x3042, 2, 3},
	{0x3043, 1, 2},
	{0x3044, 1, 2},
	{0x3045, 2, 2},
	{0x3046, 2, 2},
	{0x3047, 2, 2},
	{0x3048, 2, 2},
	{0x3049, 2, 3},
	{0x304A, 2, 3},
	{0x304B, 2, 3},
	{0x304C, 3, 5},
	{0x304D, 3, 4},
	{0x304E, 5, 6},
	{0x304F, 1, 1},
	{0x3050, 2, 3},
	{0x3051, 3, 3},
	{0x3052, 4, 5},
	{0x3053, 2, 2},
	{0x3054, 3, 4},
	{0x3055, 1, 3},
	{0x3056, 3, 5},
	{0x3057, 1, 1},
	{0x3058, 2, 3},
	{0x3059, 1, 2},
	{0x305A, 3, 4},
	{0x305B, 2, 3},
	{0x305C, 4, 5},
	{0x305D, 1, 2},
	{0x305E, 2, 4},
	{0x305F, 3, 4},
	{0x3060, 5, 6},
	{0x3061, 1, 2},
	{0x3062, 3, 4},
	{0x3063, 1, 1},
	{0x3064, 1, 1},
	{0x3065, 3, 3},
	{0x3066, 1, 1},
	{0x3067, 2, 3},
	{0x3068, 1, 2},
	{0x3069, 3, 4},
	{0x306A, 1, 4},
	{0x306B, 1, 3},
	{0x306C, 2, 2},
	{0x306D, 2, 2},
	{0x306E, 1, 1},
	{0x306F, 2, 3},
	{0x3070, 4, 5},
	{0x3071, 3, 4},
	{0x3072, 1, 1},
	{0x3073, 2, 3},
	{0x3074, 2, 2},
	{0x3075, 2, 4},
	{0x3076, 4, 6},
	{0x3077, 3, 5},
	{0x3078, 1, 1},
	{0x3079, 2, 3},
	{0x307A, 2, 2},
	{0x307B, 3, 4},
	{0x307C, 5, 6},
	{0x307D, 4, 6},
	{0x307E, 2, 3},
	{0x307F, 1, 2},
	{0x3080, 2, 3},
	{0x3081, 2, 2},
	{0x3082, 1, 3},
	{0x3083, 1, 3},
	{0x3084, 1, 3},
	{0x3085, 1, 2},
	{0x3086, 1, 2},
	{0x3087, 1, 2},
	{0x3088, 1, 2},
	{0x3089, 2, 2},
	{0x308A, 2, 2},
	{0x308B, 1, 1},
	{0x308C, 1, 3},
	{0x308D, 1, 1},
	{0x308E, 2, 2},
	{0x308F, 2, 2},
	{0x3090, 1, 1},
	{0x3091, 1, 5},
	{0x3092, 1, 3},
	{0x3093, 1, 1},
	{0x309B, 2, 2},
	{0x309C, 1, 2},
	{0x309D, 1, 1},
	{0x309E, 3, 3},
	{0x30A1, 1, 2},
	{0x30A2, 1, 2},
	{0x30A3, 1, 2},
	{0x30A4, 1, 2},
	{0x30A5, 2, 3},
	{0x30A6, 2, 3},
	{0x30A7, 1, 3},
	{0x30A8, 1, 3},
	{0x30A9, 1, 3},
	{0x30AA, 2, 3},
	{0x30AB, 1, 2},
	{0x30AC, 3, 4},
	{0x30AD, 3, 3},
	{0x30AE, 4, 5},
	{0x30AF, 1, 2},
	{0x30B0, 3, 4},
	{0x30B1, 2, 3},
	{0x30B2, 4, 5},
	{0x30B3, 1, 2},
	{0x30B4, 3, 4},
	{0x30B5, 3, 3},
	{0x30B6, 5, 5},
	{0x30B7, 3, 3},
	{0x30B8, 4, 5},
	{0x30B9, 2, 2},
	{0x30BA, 3, 4},
	{0x30BB, 2, 2},
	{0x30BC, 3, 4},
	{0x30BD, 2, 2},
	{0x30BE, 4, 4},
	{0x30BF, 2, 3},
	{0x30C0, 4, 5},
	{0x30C1, 2, 3},
	{0x30C2, 4, 5},
	{0x30C3, 2, 3},
	{0x30C4, 3, 3},
	{0x30C5, 5, 5},
	{0x30C6, 3, 3},
	{0x30C7, 4, 5},
	{0x30C8, 2, 2},
	{0x30C9, 3, 4},
	{0x30CA, 2, 2},
	{0x30CB, 2, 2},
	{0x30CC, 2, 2},
	{0x30CD, 3, 4},
	{0x30CE, 1, 1},
	{0x30CF, 2, 2},
	{0x30D0, 4, 4},
	{0x30D1, 3, 4},
	{0x30D2, 2, 2},
	{0x30D3, 3, 4},
	{0x30D4, 3, 3},
	{0x30D5, 1, 1},
	{0x30D6, 2, 3},
	{0x30D7, 2, 2},
	{0x30D8, 1, 1},
	{0x30D9, 2, 3},
	{0x30DA, 2, 2},
	{0x30DB, 3, 4},
	{0x30DC, 5, 6},
	{0x30DD, 4, 5},
	{0x30DE, 1, 2},
	{0x30DF, 3, 3},
	{0x30E0, 1, 2},
	{0x30E1, 2, 2},
	{0x30E2, 3, 3},
	{0x30E3, 1, 2},
	{0x30E4, 1, 2},
	{0x30E5, 1, 2},
	{0x30E6, 1, 2},
	{0x30E7, 2, 3},
	{0x30E8, 3, 3},
	{0x30E9, 2, 2},
	{0x30EA, 2, 2},
	{0x30EB, 2, 2},
	{0x30EC, 1, 1},
	{0x30ED, 2, 3},
	{0x30EE, 2, 2},
	{0x30EF, 1, 2},
	{0x30F0, 3, 4},
	{0x30F1, 1, 3},
	{0x30F2, 2, 3},
	{0x30F3, 2, 2},
	{0x30F4, 4, 5},
	{0x30F5, 1, 3},
	{0x30F6, 1, 3},
	{0x30FB, 1, 1},
	{0x30FC, 1, 1},
	{0x4E00,  1,  1},
	{0x4E01,  2,  2},
	{0x4E03,  2,  2},
	{0x4E07,  2,  3},
	{0x4E08,  3,  3},
	{0x4E09,  3,  3},
	{0x4E0A,  2,  3},
	{0x4E0B,  3,  3},
	{0x4E0D,  3,  4},
	{0x4E0E,  3,  3},
	{0x4E10,  5,  5},
	{0x4E11,  4,  6},
	{0x4E14,  4,  5},
	{0x4E15,  5,  5},
	{0x4E16,  3,  5},
	{0x4E17,  4,  5},
	{0x4E18,  3,  5},
	{0x4E19,  5,  5},
	{0x4E1E,  4,  6},
	{0x4E21,  5,  6},
	{0x4E26,  6,  8},
	{0x4E2A,  3,  3},
	{0x4E2D,  2,  4},
	{0x4E31,  4,  5},
	{0x4E32,  5,  7},
	{0x4E36,  1,  1},
	{0x4E38,  3,  3},
	{0x4E39,  4,  5},
	{0x4E3B,  4,  5},
	{0x4E3C,  5,  5},
	{0x4E3F,  1,  1},
	{0x4E42,  2,  2},
	{0x4E43,  2,  2},
	{0x4E45,  2,  3},
	{0x4E4B,  2,  3},
	{0x4E4D,  5,  5},
	{0x4E4E,  4,  5},
	{0x4E4F,  3,  4},
	{0x4E55,  6,  7},
	{0x4E56,  7,  8},
	{0x4E57,  8,  9},
	{0x4E58,  9, 11},
	{0x4E2D,  3,  4},
	{0x4E32,  5,  7},
	{0x4E59,  1,  1},
	{0x4E5D,  2,  2},
	{0x4E5E,  3,  3},
	{0x4E5F,  3,  3},
	{0x4E62,  3,  4},
	{0x4E71,  4,  7},
	{0x4E73,  6,  8},
	{0x4E7E, 10, 11},
	{0x4E80, 10, 12},
	{0x4E82, 10, 13},
	{0x4E85,  1,  1},
	{0x4E86,  1,  2},
	{0x4E88,  2,  4},
	{0x4E89,  4,  6},
	{0x4E8A,  7,  7},
	{0x4E8B,  6,  8},
	{0x4E8C,  2,  2},
	{0x4E8E,  3,  3},
	{0x4E91,  2,  4},
	{0x4E92,  3,  5},
	{0x4E94,  3,  4},
	{0x4E95,  4,  4},
	{0x4E98,  6,  6},
	{0x4E99,  5,  6},
	{0x4E9B,  7,  8},
	{0x4E9C,  6,  7},
	{0x4E9E,  4, 10},
	{0x4E9F,  6,  8},
	{0x4EA0,  2,  2},
	{0x4EA1,  3,  3},
	{0x4EA2,  4,  4},
	{0x4EA4,  5,  6},
	{0x4EA5,  5,  7},
	{0x4EA6,  6,  6},
	{0x4EA8,  5,  7},
	{0x4EAB,  6,  8},
	{0x4EAC,  5,  8},
	{0x4EAD,  7,  9},
	{0x4EAE,  7,  9},
	{0x4EB0,  9,  9},
	{0x4EB3,  8, 10},
	{0x4EB6, 11, 13},
	{0x4EBA,  2,  2},
	{0x4EC0,  4,  4},
	{0x4EC1,  3,  4},
	{0x4EC2,  4,  4},
	{0x4EC4,  4,  4},
	{0x4EC6,  4,  4},
	{0x4EC7,  3,  4},
	{0x4ECA,  4,  4},
	{0x4ECB,  4,  4},
	{0x4ECD,  4,  4},
	{0x4ECE,  4,  4},
	{0x4ECF,  2,  4},
	{0x4ED4,  3,  5},
	{0x4ED5,  3,  5},
	{0x4ED6,  3,  5},
	{0x4ED7,  5,  5},
	{0x4ED8,  4,  5},
	{0x4ED9,  4,  5},
	{0x4EDE,  5,  5},
	{0x4EDF,  4,  5},
	{0x4EE3,  4,  5},
	{0x4EE4,  4,  5},
	{0x4EE5,  4,  5},
	{0x4EED,  5,  5},
	{0x4EEE,  4,  6},
	{0x4EF0,  4,  6},
	{0x4EF2,  4,  6},
	{0x4EF6,  5,  6},
	{0x4EF7,  6,  6},
	{0x4EFB,  4,  6},
	{0x4F01,  5,  6},
	{0x4F09,  6,  6},
	{0x4F0A,  6,  6},
	{0x4F0D,  5,  6},
	{0x4F0E,  5,  6},
	{0x4F0F,  5,  6},
	{0x4F10,  5,  6},
	{0x4F11,  5,  6},
	{0x4F1A,  4,  6},
	{0x4F1C,  6,  6},
	{0x4F1D,  4,  6},
	{0x4F2F,  6,  7},
	{0x4F30,  6,  7},
	{0x4F34,  5,  7},
	{0x4F36,  6,  7},
	{0x4F38,  5,  7},
	{0x4F3A,  5,  7},
	{0x4F3C,  6,  7},
	{0x4F3D,  6,  7},
	{0x4F43,  6,  7},
	{0x4F46,  6,  7},
	{0x4F47,  6,  7},
	{0x4F4D,  4,  7},
	{0x4F4E,  5,  7},
	{0x4F4F,  6,  7},
	{0x4F50,  6,  7},
	{0x4F51,  6,  7},
	{0x4F53,  6,  7},
	{0x4F55,  5,  7},
	{0x4F57,  6,  7},
	{0x4F59,  6,  7},
	{0x4F5A,  7,  7},
	{0x4F5B,  5,  7},
	{0x4F5C,  5,  7},
	{0x4F5D,  5,  7},
	{0x4F5E,  6,  7},
	{0x4F69,  8,  8},
	{0x4F6F,  7,  8},
	{0x4F70,  6,  8},
	{0x4F73,  6,  8},
	{0x4F75,  7,  8},
	{0x4F76,  7,  8},
	{0x4F7B,  7,  8},
	{0x4F7C,  7,  8},
	{0x4F7F,  6,  8},
	{0x4F83,  7,  8},
	{0x4F86,  8,  8},
	{0x4F88,  6,  8},
	{0x4F8B,  5,  8},
	{0x4F8D,  7,  8},
	{0x4F8F,  8,  8},
	{0x4F91,  8,  8},
	{0x4F96,  8,  8},
	{0x4F98,  8,  8},
	{0x4F9B,  7,  8},
	{0x4F9D,  6,  9},
	{0x4FA0,  7,  8},
	{0x4FA1,  6,  8},
	{0x4FAB,  8,  8},
	{0x4FAD,  7,  8},
	{0x4FAE,  6,  9},
	{0x4FAF,  8,  9},
	{0x4FB5,  8,  9},
	{0x4FB6,  4,  9},
	{0x4FBF,  7,  9},
	{0x4FC2,  6,  9},
	{0x4FC3,  7,  9},
	{0x4FC4,  7,  9},
	{0x4FCA,  7, 10},
	{0x4FCE,  9,  9},
	{0x4FD0,  8,  9},
	{0x4FD1,  8,  9},
	{0x4FD4,  8,  9},
	{0x4FD7,  6,  9},
	{0x4FD8,  7,  8},
	{0x4FDA,  9,  9},
	{0x4FDB,  9, 10},
	{0x4FDD,  7,  9},
	{0x4FDF,  8,  9},
	{0x4FE1,  7,  9},
	{0x4FE3,  7,  9},
	{0x4FE4,  7,  9},
	{0x4FE5,  9,  9},
	{0x4FEE,  8, 10},
	{0x4FEF, 10, 10},
	{0x4FF3,  9, 10},
	{0x4FF5,  8, 10},
	{0x4FF6, 10, 10},
	{0x4FF8, 10, 11},
	{0x4FFA,  9, 11},
	{0x4FFE,  9, 11},
	{0x5005, 10, 10},
	{0x5006, 10, 10},
	{0x5009,  8, 10},
	{0x500B,  7, 10},
	{0x500D,  8, 10},
	{0x500F,  9, 10},
	{0x5011, 10, 10},
	{0x5012,  6, 10},
	{0x5014,  6, 10},
	{0x5016,  9, 10},
	{0x5019,  8, 10},
	{0x501A,  8, 10},
	{0x501F,  9, 10},
	{0x5021, 10, 10},
	{0x5023,  8, 10},
	{0x5024,  8, 10},
	{0x5025, 10, 10},
	{0x5026,  9, 11},
	{0x5028,  8, 10},
	{0x5029, 10, 10},
	{0x502A,  8, 10},
	{0x502B,  9, 10},
	{0x502C, 10, 10},
	{0x502D,  9, 10},
	{0x5036,  9, 10},
	{0x5039,  9, 10},
	{0x5043, 11, 12},	// Min of 6 per Noriko
	{0x5047, 10, 11},
	{0x5048, 10, 11},
	{0x5049, 10, 12},
	{0x504F, 10, 11},
	{0x5050, 11, 11},
	{0x5055, 10, 11},
	{0x5056, 10, 11},
	{0x505A,  9, 11},
	{0x505C,  7, 11},
	{0x5065,  9, 11},
	{0x506C, 10, 11},
	{0x5072, 10, 11},
	{0x5074,  9, 11},
	{0x5075,  9, 11},
	{0x5076,  9, 11},
	{0x5078, 11, 11},
	{0x507D, 10, 12},
	{0x5080, 10, 12},
	{0x5085, 12, 12},
	{0x508D, 11, 12},
	{0x5091, 11, 13},
	{0x5098, 12, 12},
	{0x5099, 11, 12},
	{0x509A, 11, 12},
	{0x50AC, 10, 13},
	{0x50AD, 13, 14},
	{0x50B2, 11, 13},
	{0x50B3, 11, 14},
	{0x50B4,  6, 13},
	{0x50B5, 11, 13},
	{0x50B7, 11, 13},
	{0x50BE,  8, 13},
	{0x50C2, 12, 13},
	{0x50C5, 11, 12},
	{0x50C9,  9, 13},
	{0x50CA, 13, 14},
	{0x50CD, 11, 13},
	{0x50CF, 10, 14},
	{0x50D1, 10, 14},
	{0x50D5, 10, 14},
	{0x50D6, 13, 14},
	{0x50DA, 13, 14},
	{0x50DE, 13, 15},
	{0x50E3, 13, 14},
	{0x50E5, 14, 14},
	{0x50E7, 11, 13},
	{0x50ED, 15, 16},
	{0x50EE, 14, 14},
	{0x50F5, 15, 15},
	{0x50F9, 13, 15},
	{0x50FB, 13, 15},
	{0x5100, 12, 15},
	{0x5101, 11, 14},
	{0x5102, 13, 15},
	{0x5104, 13, 15},
	{0x5109, 11, 15},
	{0x5112, 14, 16},
	{0x5114, 13, 16},
	{0x5115, 14, 14},
	{0x5116, 15, 17},
	{0x5118, 16, 17},
	{0x511A, 15, 15},
	{0x511F, 14, 17},
	{0x5121, 17, 17},
	{0x512A, 12, 17},
	{0x5132, 15, 17},
	{0x5137, 21, 22},
	{0x513A, 19, 21},
	{0x513B, 21, 22},
	{0x513C, 20, 22},
	{0x513F,  2,  2},
	{0x5140,  3,  3},
	{0x5141,  3,  4},
	{0x5143,  3,  4},
	{0x5144,  2,  5},
	{0x5145,  4,  6},
	{0x5146,  5,  6},
	{0x5147,  6,  6},
	{0x5148,  5,  6},
	{0x5149,  4,  6},
	{0x514B,  5,  7},
	{0x514C,  5,  7},
	{0x514D,  4,  8},
	{0x514E,  7,  8},
	{0x5150,  6,  7},
	{0x5152,  7,  9},
	{0x5154,  8,  9},
	{0x515A,  7, 10},
	{0x515C,  8, 11},
	{0x5162, 13, 14},
	{0x5165,  2,  2},
	{0x5168,  5,  6},
	{0x5169,  8,  8},
	{0x516A,  9,  9},
	{0x516B,  2,  2},
	{0x516C,  3,  4},
	{0x516D,  4,  4},
	{0x516E,  4,  4},
	{0x5171,  5,  6},
	{0x5175,  5,  7},
	{0x5176,  8,  8},
	{0x5177,  7,  8},
	{0x5178,  7,  9},
	{0x517C,  9, 10},
	{0x5180, 16, 16},
	{0x5182,  2,  2},
	{0x5185,  4,  4},
	{0x5186,  3,  4},
	{0x5189,  5,  5},
	{0x518A,  5,  5},
	{0x518C,  5,  5},
	{0x518D,  6,  6},
	{0x518F,  5,  7},
	{0x5190,  8,  8},
	{0x5191,  9,  9},
	{0x5192,  9,  9},
	{0x5193, 10, 10},
	{0x5195, 11, 12},
	{0x5196,  2,  2},
	{0x5197,  3,  4},
	{0x5199,  4,  5},
	{0x51A0,  8,  9},
	{0x51A2,  9, 10},
	{0x51A4, 10, 11},
	{0x51A5, 10, 10},
	{0x51A6, 10, 10},
	{0x51A8, 10, 11},
	{0x51A9, 12, 13},
	{0x51AA, 14, 15},
	{0x51AB,  2,  2},
	{0x51AC,  4,  5},
	{0x51B0,  5,  5},
	{0x51B1,  6,  7},
	{0x51B2,  5,  6},
	{0x51B3,  6,  6},
	{0x51B4,  6,  8},
	{0x51B5,  7,  7},
	{0x51B6,  5,  7},
	{0x51B7,  6,  7},
	{0x51BD,  7,  8},
	{0x51C4,  9, 10},
	{0x51C5,  8, 10},
	{0x51C6,  8, 10},
	{0x51C9,  8, 10},
	{0x51CB,  8, 10},
	{0x51CC,  9, 10},
	{0x51CD,  9, 11},
	{0x51D6, 11, 12},
	{0x51DB, 13, 15},
	{0x51DC, 11, 15},
	{0x51DD, 13, 16},
	{0x51E0,  2,  2},
	{0x51E1,  3,  3},
	{0x51E6,  3,  5},
	{0x51E7,  4,  5},
	{0x51E9,  6,  6},
	{0x51EA,  5,  6},
	{0x51ED,  7,  8},
	{0x51F0, 10, 11},
	{0x51F1,  9, 12},
	{0x51F5,  2,  2},
	{0x51F6,  3,  5},
	{0x51F8,  2,  6},
	{0x51F9,  1,  6},
	{0x51FA,  3,  5},
	{0x51FD,  6,  8},
	{0x51FE,  6,  9},
	{0x5200,  1,  2},
	{0x5203,  3,  3},
	{0x5204,  3,  3},
	{0x5206,  3,  4},
	{0x5207,  3,  4},
	{0x5208,  4,  4},
	{0x520A,  5,  5},
	{0x520B,  5,  5},
	{0x520E,  6,  6},
	{0x5211,  6,  6},
	{0x5214,  6,  6},
	{0x5217,  4,  6},
	{0x521D,  5,  7},
	{0x5224,  6,  7},
	{0x5225,  4,  7},
	{0x5227,  5,  7},
	{0x5229,  5,  7},
	{0x522A,  7,  7},
	{0x522E,  6,  8},
	{0x5230,  5,  8},
	{0x5233,  7,  8},
	{0x5236,  7,  8},
	{0x5237,  6,  8},
	{0x5238,  7,  8},
	{0x5239,  8,  8},
	{0x523A,  7,  8},
	{0x523B,  7,  8},
	{0x5243,  7, 10},
	{0x5244,  8,  9},
	{0x5247,  7,  9},
	{0x524A,  8,  9},
	{0x524B,  7,  9},
	{0x524C,  7,  9},
	{0x524D,  7,  9},
	{0x524F,  8,  9},
	{0x5254,  9, 10},
	{0x5256,  9, 10},
	{0x525B,  8, 10},
	{0x525E,  8, 10},
	{0x5263,  9, 10},
	{0x5264,  9, 11},
	{0x5265,  8, 10},
	{0x5269, 11, 12},
	{0x526A, 11, 11},
	{0x526F,  8, 11},
	{0x5270, 10, 11},
	{0x5271,  9, 12},
	{0x5272, 10, 12},
	{0x5273,  9, 11},
	{0x5274,  9, 12},
	{0x5275, 10, 12},
	{0x527D, 12, 13},
	{0x527F, 13, 13},
	{0x5283, 13, 14},
	{0x5287, 11, 15},
	{0x5288, 13, 15},
	{0x5289, 12, 14},
	{0x528D, 11, 15},
	{0x5291, 14, 15},
	{0x5292, 12, 16},
	{0x5294, 11, 17},
	{0x529B,  1,  2},
	{0x529F,  3,  5},
	{0x52A0,  3,  5},
	{0x52A3,  5,  6},
	{0x52A9,  6,  7},
	{0x52AA,  6,  7},
	{0x52AB,  4,  7},
	{0x52AC,  5,  7},
	{0x52AD,  5,  7},
	{0x52B1,  6,  7},
	{0x52B4,  6,  7},
	{0x52B5,  7,  8},
	{0x52B9,  7,  8},
	{0x52BC,  7,  8},
	{0x52BE,  7,  8},
	{0x52C1,  8,  9},
	{0x52C3,  8,  9},
	{0x52C5,  7,  9},
	{0x52C7,  7,  9},
	{0x52C9,  5, 10},
	{0x52CD,  8, 10},
	{0x52D2,  9, 11},
	{0x52D5,  9, 11},
	{0x52D7, 11, 12},
	{0x52D8, 11, 12},
	{0x52D9,  6, 11},
	{0x52DD, 10, 12},
	{0x52DE, 12, 12},
	{0x52DF, 11, 12},
	{0x52E0, 12, 13},
	{0x52E2, 11, 13},
	{0x52E3, 12, 13},
	{0x52E4,  9, 12},
	{0x52E6, 13, 13},
	{0x52E7, 10, 13},
	{0x52F2, 14, 16},
	{0x52F3, 15, 16},
	{0x52F5, 15, 16},
	{0x52F8, 14, 19},
	{0x52F9,  2,  2},
	{0x52FA,  3,  3},
	{0x52FE,  3,  4},
	{0x52FF,  3,  4},
	{0x5301,  4,  4},
	{0x5302,  3,  4},
	{0x5305,  3,  5},
	{0x5306,  5,  5},
	{0x5308,  6,  6},
	{0x530D,  8,  9},
	{0x530F,  9, 11},
	{0x5310,  9, 11},
	{0x5315,  2,  2},
	{0x5316,  3,  4},
	{0x5317,  4,  5},
	{0x5319, 11, 11},
	{0x531A,  2,  2},
	{0x531D,  5,  6},
	{0x5320,  5,  7},
	{0x5321,  6,  7},
	{0x5323,  7,  7},
	{0x532A, 10, 11},
	{0x532F, 12, 13},
	{0x5331, 13, 14},
	{0x5333, 11, 15},
	{0x5338,  2,  2},
	{0x5339,  4,  5},
	{0x533A,  3,  5},
	{0x533B,  6,  8},
	{0x533F,  9, 11},
	{0x5340,  5, 11},
	{0x5341,  2,  2},
	{0x5343,  2,  3},
	{0x5345,  4,  4},
	{0x5346,  4,  4},
	{0x5347,  3,  4},
	{0x5348,  3,  4},
	{0x5349,  5,  5},
	{0x534A,  4,  5},
	{0x534D,  2,  5},
	{0x5351,  7,  9},
	{0x5352,  7,  8},
	{0x5353,  8,  8},
	{0x5354,  5,  8},
	{0x5357,  7,  9},
	{0x5358,  9,  9},
	{0x535A, 11, 12},
	{0x535C,  2,  2},
	{0x535E,  3,  4},
	{0x5360,  4,  5},
	{0x5366,  5,  8},
	{0x5369,  2,  2},
	{0x536E,  4,  5},
	{0x536F,  3,  5},
	{0x5370,  4,  6},
	{0x5371,  4,  6},
	{0x5373,  5,  7},
	{0x5374,  5,  7},
	{0x5375,  6,  8},
	{0x5377,  8,  8},
	{0x5378,  6,  9},
	{0x537B,  8,  9},
	{0x537F,  7, 10},
	{0x5382,  2,  2},
	{0x5384,  3,  4},
	{0x5396,  9,  9},
	{0x5398,  9,  9},
	{0x539A,  7,  9},
	{0x539F,  9, 10},
	{0x53A0, 10, 11},
	{0x53A5,  9, 12},
	{0x53A6,  9, 12},
	{0x53A8, 10, 12},
	{0x53A9, 10, 12},
	{0x53AD, 14, 14},
	{0x53AE, 13, 14},
	{0x53B0, 13, 14},
	{0x53B3, 14, 17},
	{0x53B6,  2,  2},
	{0x53BB,  3,  5},
	{0x53C2,  7,  8},
	{0x53C3,  8, 11},
	{0x53C8,  2,  2},
	{0x53C9,  3,  3},
	{0x53CA,  3,  3},
	{0x53CB,  4,  4},
	{0x53CC,  4,  4},
	{0x53CD,  4,  4},
	{0x53CE,  3,  5},
	{0x53D4,  7,  9},
	{0x53D6,  7,  8},
	{0x53D7,  7,  8},
	{0x53D9,  8,  9},
	{0x53DB,  7,  9},
	{0x53DF,  7,  8},
	{0x53E1, 15, 17},
	{0x53E2, 17, 19},
	{0x53E3,  2,  3},
	{0x53E4,  3,  5},
	{0x53E5,  2,  5},
	{0x53E8,  4,  5},
	{0x53E9,  3,  5},
	{0x53EA,  4,  5},
	{0x53EB,  4,  6},
	{0x53EC,  3,  5},
	{0x53ED,  4,  5},
	{0x53EE,  4,  5},
	{0x53EF,  3,  5},
	{0x53F0,  2,  5},
	{0x53F1,  4,  5},
	{0x53F2,  4,  5},
	{0x53F3,  3,  5},
	{0x53F6,  4,  5},
	{0x53F7,  3,  5},
	{0x53F8,  3,  5},
	{0x53FA,  4,  5},
	{0x5401,  5,  6},
	{0x5403,  5,  6},
	{0x5404,  3,  6},
	{0x5408,  4,  6},
	{0x5409,  5,  6},
	{0x540A,  4,  6},
	{0x540B,  5,  6},
	{0x540C,  4,  6},
	{0x540D,  3,  6},
	{0x540E,  4,  6},
	{0x540F,  5,  6},
	{0x5410,  4,  6},
	{0x5411,  3,  6},
	{0x541B,  5,  7},
	{0x541D,  5,  7},
	{0x541F,  6,  7},
	{0x5420,  6,  7},
	{0x5426,  6,  7},
	{0x5429,  6,  7},
	{0x542B,  5,  7},
	{0x542C,  5,  7},
	{0x542D,  6,  7},
	{0x542E,  6,  7},
	{0x5436,  6,  7},
	{0x5438,  4,  6},
	{0x5439,  4,  7},
	{0x543B,  6,  7},
	{0x543C,  5,  6},
	{0x543D,  6,  7},
	{0x543E,  5,  7},
	{0x5440,  8,  8},
	{0x5442,  3,  7},
	{0x5446,  6,  7},
	{0x5448,  6,  7},
	{0x5449,  6,  7},
	{0x544A,  5,  7},
	{0x544E,  6,  7},
	{0x5451,  6,  7},
	{0x545F,  6,  8},
	{0x5468,  5,  8},
	{0x546A,  5,  8},
	{0x5470,  7,  9},
	{0x5471,  7,  9},
	{0x5473,  6,  8},
	{0x5475,  5,  8},
	{0x5476,  8,  8},
	{0x5477,  7,  8},
	{0x547B,  7,  8},
	{0x547C,  5,  8},
	{0x547D,  5,  8},
	{0x5480,  7,  8},
	{0x5484,  5,  8},
	{0x5486,  7,  8},
	{0x548B,  6,  8},
	{0x548C,  5,  8},
	{0x548E,  7,  8},
	{0x548F,  6,  8},
	{0x5490,  7,  8},
	{0x5492,  5,  8},
	{0x54A2,  5,  9},
	{0x54A4,  8,  9},
	{0x54A5,  7,  9},
	{0x54A8,  7,  9},
	{0x54AB,  7,  9},
	{0x54AC,  8,  9},
	{0x54AF,  6,  9},
	{0x54B2,  6,  9},
	{0x54B3,  8,  9},
	{0x54B8,  7,  9},
	{0x54BC,  7,  9},
	{0x54BD,  8,  9},
	{0x54BE,  8,  9},
	{0x54C0,  6,  9},
	{0x54C1,  3,  9},
	{0x54C2,  9,  9},
	{0x54C4,  9,  9},
	{0x54C7,  8,  9},
	{0x54C8,  7,  9},
	{0x54C9,  8,  9},
	{0x54D8,  7,  9},
	{0x54E1,  7, 10},
	{0x54E2,  9, 10},
	{0x54E5,  6, 10},
	{0x54E6,  8, 10},
	{0x54E8,  9, 10},
	{0x54E9,  9, 10},
	{0x54ED,  7, 10},
	{0x54EE,  8,  9},
	{0x54F2,  7, 10},
	{0x54FA,  9, 10},
	{0x54FD,  9, 10},
	{0x5504,  8, 11},
	{0x5506,  7, 10},
	{0x5507,  8, 10},
	{0x550F,  9, 10},
	{0x5510,  8, 10},
	{0x5514,  7, 10},
	{0x5516,  8, 10},
	{0x552E,  9, 11},
	{0x552F,  8, 11},
	{0x5531, 10, 11},
	{0x5533,  8, 10},
	{0x5538, 10, 11},
	{0x5539, 10, 11},
	{0x553E,  8, 12},
	{0x5540, 10, 11},
	{0x5544,  7, 10},
	{0x5545, 10, 11},
	{0x5546,  9, 11},
	{0x554C,  9, 11},
	{0x554F,  6, 11},
	{0x5553,  8, 11},
	{0x5556, 10, 11},
	{0x5557,  9, 11},
	{0x555C, 10, 11},
	{0x555D,  8, 11},
	{0x5563, 11, 12},
	{0x557B, 11, 12},
	{0x557C, 11, 12},
	{0x557E, 10, 12},
	{0x5580, 10, 12},
	{0x5583, 11, 12},
	{0x5584,  8, 13},
	{0x5587,  9, 12},
	{0x5589, 10, 12},
	{0x558A, 10, 12},
	{0x558B, 10, 12},
	{0x5598,  9, 12},
	{0x5599, 11, 12},
	{0x559A, 11, 12},
	{0x559C,  7, 12},
	{0x559D,  9, 11},
	{0x559E, 10, 12},
	{0x559F, 11, 12},
	{0x55A7, 11, 12},
	{0x55A8,  9, 12},
	{0x55A9, 12, 12},
	{0x55AA,  7, 13},
	{0x55AB, 11, 13},
	{0x55AC,  8, 12},
	{0x55AE,  8, 12},
	{0x55B0, 10, 12},
	{0x55B6,  7, 12},
	{0x55C4, 10, 12},
	{0x55C5, 11, 13},
	{0x55C7, 12, 13},
	{0x55D4, 12, 14},
	{0x55DA, 11, 13},
	{0x55DC, 12, 13},
	{0x55DF, 10, 13},
	{0x55E3, 10, 13},
	{0x55E4, 13, 13},
	{0x55F7, 12, 14},
	{0x55F9, 12, 13},
	{0x55FD, 11, 14},
	{0x55FE, 11, 14},
	{0x5606, 12, 13},
	{0x5609, 11, 14},
	{0x5614, 11, 15},	// Min of 6 per Noriko
	{0x5616, 13, 14},
	{0x5617, 13, 14},
	{0x5618, 13, 14},
	{0x561B, 12, 14},
	{0x5629, 12, 13},
	{0x562F, 14, 16},
	{0x5631, 10, 15},
	{0x5632, 13, 15},
	{0x5634, 14, 16},
	{0x5636, 12, 15},
	{0x5638, 14, 15},
	{0x5642, 12, 15},
	{0x564C, 12, 14},
	{0x564E, 15, 15},
	{0x5650, 12, 15},
	{0x565B, 12, 16},
	{0x5664, 16, 16},
	{0x5668,  7, 15},
	{0x566A, 11, 16},
	{0x566B, 15, 16},
	{0x566C, 13, 16},
	{0x5674, 13, 15},
	{0x5678, 12, 16},
	{0x567A, 14, 16},
	{0x5680, 16, 17},
	{0x5686, 11, 16},
	{0x5687, 15, 18},
	{0x568A, 15, 17},
	{0x568F, 16, 17},
	{0x5694, 17, 18},
	{0x56A0, 14, 17},
	{0x56A2, 16, 18},
	{0x56A5, 17, 19},
	{0x56AE, 14, 18},
	{0x56B4, 18, 20},
	{0x56B6, 18, 20},
	{0x56BC, 19, 21},
	{0x56C0, 20, 21},
	{0x56C1, 20, 21},
	{0x56C2, 17, 21},
	{0x56C3, 19, 21},
	{0x56C8, 19, 21},
	{0x56CE, 21, 22},
	{0x56D1, 24, 24},
	{0x56D3, 24, 24},
	{0x56D7,  3,  3},
	{0x56D8,  5,  5},
	{0x56DA,  5,  5},
	{0x56DB,  4,  5},
	{0x56DE,  4,  6},
	{0x56E0,  6,  6},
	{0x56E3,  6,  6},
	{0x56EE,  7,  7},
	{0x56F0,  6,  7},
	{0x56F2,  7,  7},
	{0x56F3,  6,  7},
	{0x56F9,  7,  8},
	{0x56FA,  6,  8},
	{0x56FD,  7,  8},
	{0x56FF,  9,  9},
	{0x5700,  9,  9},
	{0x5703, 10, 10},
	{0x5704,  8, 10},
	{0x5708, 11, 12},
	{0x5709, 10, 11},
	{0x570B,  8, 11},
	{0x570D, 11, 13},
	{0x570F,  9, 12},
	{0x5712,  9, 13},
	{0x5713, 10, 13},
	{0x5716, 11, 14},
	{0x5718, 12, 14},
	{0x571C, 14, 16},
	{0x571F,  2,  3},
	{0x5726,  5,  5},
	{0x5727,  4,  5},
	{0x5728,  5,  6},
	{0x572D,  5,  6},
	{0x5730,  5,  6},
	{0x5737,  5,  6},
	{0x5738,  5,  6},
	{0x573B,  5,  7},
	{0x5740,  7,  7},
	{0x5742,  5,  7},
	{0x5747,  6,  7},
	{0x574A,  5,  7},
	{0x574E,  5,  7},
	{0x574F,  6,  7},
	{0x5750,  6,  7},
	{0x5751,  6,  7},
	{0x5761,  8,  8},
	{0x5764,  7,  8},
	{0x5766,  7,  8},
	{0x5769,  7,  8},
	{0x576A,  6,  8},
	{0x577F,  7,  8},
	{0x5782,  8,  9},
	{0x5788,  8,  8},
	{0x5789,  8,  8},
	{0x578B,  8,  9},
	{0x5793,  9, 10},
	{0x57A0,  9,  9},
	{0x57A2,  6,  9},
	{0x57A3,  7, 10},
	{0x57A4,  7,  9},
	{0x57AA,  9,  9},
	{0x57B0,  8,  9},
	{0x57B3,  8,  9},
	{0x57C0,  9, 11},
	{0x57C3,  9, 10},
	{0x57C6,  8, 10},
	{0x57CB,  9, 10},
	{0x57CE,  7,  9},
	{0x57D2,  9, 10},
	{0x57D3,  9, 10},
	{0x57D4,  9, 10},
	{0x57D6, 10, 10},
	{0x57DC, 10, 11},
	{0x57DF,  8, 11},
	{0x57E0,  8, 11},
	{0x57E3, 11, 11},
	{0x57F4, 10, 12},
	{0x57F7, 10, 11},
	{0x57F9,  8, 11},
	{0x57FA,  9, 11},
	{0x57FC,  8, 11},
	{0x5800,  7, 11},
	{0x5802,  8, 11},
	{0x5805,  9, 12},
	{0x5806,  9, 11},
	{0x580A,  7,  9},
	{0x580B, 11, 11},
	{0x5815,  9, 11},
	{0x5819, 10, 12},
	{0x581D,  8, 12},
	{0x5821, 11, 12},
	{0x5824, 10, 12},
	{0x582A, 11, 13},
	{0x582F, 11, 12},
	{0x5830, 11, 13},
	{0x5831, 10, 12},
	{0x5834,  9, 12},
	{0x5835,  9, 11},
	{0x583A,  9, 12},
	{0x583D, 13, 13},
	{0x5840,  9, 12},
	{0x5841, 10, 12},
	{0x584A, 10, 13},
	{0x584B, 12, 13},
	{0x5851, 11, 13},
	{0x5852, 12, 13},
	{0x5854, 10, 12},
	{0x5857, 11, 13},
	{0x5858, 11, 13},
	{0x5859, 10, 13},
	{0x585A,  8, 12},
	{0x585E, 12, 13},
	{0x5862, 12, 13},
	{0x5869,  9, 13},
	{0x586B, 12, 13},
	{0x5870, 13, 13},
	{0x5872, 13, 15},
	{0x5875, 12, 15},
	{0x5879, 13, 14},
	{0x587E, 11, 13},
	{0x5883, 11, 14},
	{0x5885, 11, 14},
	{0x5893, 12, 13},
	{0x5897, 11, 14},
	{0x589C, 10, 15},
	{0x589F, 14, 15},
	{0x58A8, 13, 15},
	{0x58AB, 15, 15},
	{0x58AE, 13, 14},
	{0x58B3, 14, 16},
	{0x58B8, 14, 15},
	{0x58B9, 14, 15},
	{0x58BA, 14, 16},
	{0x58BB, 16, 16},
	{0x58BE, 14, 17},
	{0x58C1, 13, 16},
	{0x58C5, 14, 16},
	{0x58C7, 15, 16},
	{0x58CA, 12, 16},
	{0x58CC, 12, 17},
	{0x58D1, 15, 17},
	{0x58D3, 17, 17},
	{0x58D5, 13, 17},
	{0x58D7, 16, 17},
	{0x58D8, 16, 18},
	{0x58D9, 16, 18},
	{0x58DC, 17, 19},
	{0x58DE, 18, 19},
	{0x58DF, 17, 19},
	{0x58E4, 18, 20},
	{0x58E5, 20, 20},
	{0x58EB,  2,  3},
	{0x58EC,  4,  4},
	{0x58EE,  5,  6},
	{0x58EF,  6,  7},
	{0x58F0,  6,  7},
	{0x58F1,  6,  7},
	{0x58F2,  5,  7},
	{0x58F7,  9, 11},
	{0x58F9,  8, 12},
	{0x58FA,  8, 12},
	{0x58FB, 11, 12},
	{0x58FC,  9, 12},
	{0x58FD, 12, 15},
	{0x5902,  3,  3},
	{0x5909,  8,  9},
	{0x590A,  3,  3},
	{0x590F,  7, 10},
	{0x5910, 13, 14},
	{0x5915,  2,  3},
	{0x5916,  4,  5},
	{0x5918,  5,  5},
	{0x5919,  4,  6},
	{0x591A,  4,  6},
	{0x591B,  6,  6},
	{0x591C,  6,  8},
	{0x5922, 11, 13},
	{0x5925, 12, 14},
	{0x5927,  3,  3},
	{0x5929,  4,  4},
	{0x592A,  4,  4},
	{0x592B,  4,  4},
	{0x592C,  4,  4},
	{0x592D,  4,  4},
	{0x592E,  3,  5},
	{0x5931,  4,  5},
	{0x5932,  5,  5},
	{0x5937,  5,  7},
	{0x5938,  6,  6},
	{0x593E,  7,  7},
	{0x5944,  8,  9},
	{0x5947,  6,  8},
	{0x5948,  7,  8},
	{0x5949,  7,  9},
	{0x594E,  9,  9},
	{0x594F,  8,  9},
	{0x5950,  9,  9},
	{0x5951,  9,  9},
	{0x5954,  8,  9},
	{0x5955,  9,  9},
	{0x5957,  9, 11},
	{0x5958,  9, 10},
	{0x595A,  9, 10},
	{0x5960, 12, 12},
	{0x5962, 12, 12},
	{0x5965, 10, 12},
	{0x5967, 11, 13},
	{0x5968, 12, 13},
	{0x5969,  8, 14},
	{0x596A, 12, 14},
	{0x596C, 13, 15},
	{0x596E, 13, 16},
	{0x5973,  3,  3},
	{0x5974,  5,  5},
	{0x5978,  6,  6},
	{0x597D,  4,  6},
	{0x5981,  5,  7},
	{0x5982,  4,  6},
	{0x5983,  4,  6},
	{0x5984,  6,  6},
	{0x598A,  6,  7},
	{0x598D,  7,  7},
	{0x5993,  6,  7},
	{0x5996,  6,  7},
	{0x5999,  6,  7},
	{0x599B,  6,  7},
	{0x599D,  7,  7},
	{0x59A3,  7,  8},
	{0x59A5,  6,  7},
	{0x59A8,  6,  7},
	{0x59AC,  6,  8},
	{0x59B2,  8,  8},
	{0x59B9,  7,  8},
	{0x59BB,  7,  8},
	{0x59BE,  8,  8},
	{0x59C6,  8,  8},
	{0x59C9,  6,  8},
	{0x59CB,  5,  8},
	{0x59D0,  8,  8},
	{0x59D1,  7,  8},
	{0x59D3,  6,  8},
	{0x59D4,  7,  8},
	{0x59D9,  8,  9},
	{0x59DA,  8,  9},
	{0x59DC,  8,  9},
	{0x59E5,  8,  9},
	{0x59E6,  9,  9},
	{0x59E8,  7,  9},
	{0x59EA,  6,  9},
	{0x59EB,  6, 10},
	{0x59F6,  8,  9},
	{0x59FB,  9,  9},
	{0x59FF,  8,  9},
	{0x5A01,  8,  9},
	{0x5A03,  7,  9},
	{0x5A09, 10, 10},
	{0x5A11,  9, 10},
	{0x5A18,  8, 10},
	{0x5A1A, 10, 10},
	{0x5A1C,  8,  9},
	{0x5A1F,  9, 10},
	{0x5A20,  8, 10},
	{0x5A25,  9, 10},
	{0x5A29,  9, 11},
	{0x5A2F,  9, 10},
	{0x5A35, 11, 11},
	{0x5A36, 11, 11},
	{0x5A3C, 11, 11},
	{0x5A40,  8, 10},
	{0x5A41, 11, 12},
	{0x5A46,  9, 11},
	{0x5A49, 11, 11},
	{0x5A5A,  9, 11},
	{0x5A62, 10, 12},
	{0x5A66,  8, 11},
	{0x5A6A, 11, 11},
	{0x5A6C, 10, 12},
	{0x5A7F, 11, 12},
	{0x5A92, 10, 12},
	{0x5A9A, 12, 12},
	{0x5A9B, 11, 12},
	{0x5ABC, 13, 13},
	{0x5ABD, 13, 13},
	{0x5ABE, 13, 13},
	{0x5AC1, 10, 13},
	{0x5AC2, 11, 11},
	{0x5AC9, 11, 13},
	{0x5ACB,  9, 13},
	{0x5ACC, 12, 13},
	{0x5AD0, 13, 14},
	{0x5AD6, 13, 14},
	{0x5AD7, 14, 14},
	{0x5AE1, 11, 14},
	{0x5AE3, 14, 14},
	{0x5AE6, 13, 14},
	{0x5AE9, 12, 14},
	{0x5AFA, 15, 15},
	{0x5AFB, 14, 15},
	{0x5B09, 11, 15},
	{0x5B0B, 13, 15},
	{0x5B0C, 10, 15},
	{0x5B16, 15, 16},
	{0x5B22, 14, 16},
	{0x5B2A, 10, 17},
	{0x5B2C, 14, 17},
	{0x5B30, 15, 17},
	{0x5B32, 17, 18},
	{0x5B36, 15, 17},
	{0x5B3E, 18, 19},
	{0x5B40, 19, 20},
	{0x5B43, 14, 20},
	{0x5B45, 19, 20},
	{0x5B50,  2,  3},
	{0x5B51,  2,  3},
	{0x5B54,  3,  4},
	{0x5B55,  4,  5},
	{0x5B57,  4,  6},
	{0x5B58,  4,  6},
	{0x5B5A,  5,  7},
	{0x5B5B,  6,  6},
	{0x5B5C,  4,  7},
	{0x5B5D,  5,  7},
	{0x5B5F,  5,  8},
	{0x5B63,  6,  8},
	{0x5B64,  5,  9},
	{0x5B65,  7,  8},
	{0x5B66,  6,  8},
	{0x5B69,  8,  9},
	{0x5B6B,  6, 10},
	{0x5B70, 10, 11},
	{0x5B71,  7,  9},
	{0x5B73,  7, 11},
	{0x5B75, 11, 12},
	{0x5B78, 14, 15},
	{0x5B7A, 14, 16},
	{0x5B80,  3,  3},
	{0x5B83,  5,  5},
	{0x5B85,  5,  6},
	{0x5B87,  5,  6},
	{0x5B88,  5,  6},
	{0x5B89,  5,  6},
	{0x5B8B,  7,  7},
	{0x5B8C,  5,  7},
	{0x5B8D,  7,  7},
	{0x5B8F,  6,  7},
	{0x5B95,  7,  8},
	{0x5B97,  7,  8},
	{0x5B98,  6,  8},
	{0x5B99,  7,  8},
	{0x5B9A,  6,  8},
	{0x5B9B,  7,  8},
	{0x5B9C,  8,  8},
	{0x5B9D,  6,  8},
	{0x5B9F,  7,  8},
	{0x5BA2,  6,  9},
	{0x5BA3,  9,  9},
	{0x5BA4,  6,  9},
	{0x5BA5,  9, 10},
	{0x5BA6,  9, 10},
	{0x5BAE,  6, 10},
	{0x5BB0,  9, 10},
	{0x5BB3,  8, 10},
	{0x5BB4,  9, 11},
	{0x5BB5, 10, 10},
	{0x5BB6,  7, 10},
	{0x5BB8,  9, 10},
	{0x5BB9,  8, 10},
	{0x5BBF,  8, 11},
	{0x5BC2, 10, 11},
	{0x5BC3, 11, 12},
	{0x5BC4,  8, 11},
	{0x5BC5, 10, 11},
	{0x5BC6,  9, 11},
	{0x5BC7, 10, 12},
	{0x5BC9, 10, 11},
	{0x5BCC,  9, 12},
	{0x5BD0, 11, 13},
	{0x5BD2, 11, 12},
	{0x5BD3, 11, 12},
	{0x5BD4, 12, 12},
	{0x5BDB, 12, 13},
	{0x5BDD, 11, 13},
	{0x5BDE, 13, 13},
	{0x5BDF, 12, 14},
	{0x5BE1, 12, 15},
	{0x5BE2, 13, 14},
	{0x5BE4, 12, 14},
	{0x5BE5, 14, 14},
	{0x5BE6, 13, 15},
	{0x5BE7, 13, 14},
	{0x5BE8, 13, 14},
	{0x5BE9, 13, 15},
	{0x5BEB, 14, 14},
	{0x5BEE, 15, 15},
	{0x5BF0, 14, 16},
	{0x5BF3, 18, 19},
	{0x5BF5, 18, 20},
	{0x5BF6, 19, 20},
	{0x5BF8,  3,  3},
	{0x5BFA,  5,  6},
	{0x5BFE,  6,  7},
	{0x5BFF,  6,  7},
	{0x5C01,  6,  9},
	{0x5C02,  8, 10},
	{0x5C04,  7, 10},
	{0x5C05, 10, 10},
	{0x5C06,  8, 10},
	{0x5C07, 10, 11},
	{0x5C08, 11, 11},
	{0x5C09, 10, 12},
	{0x5C0A, 11, 12},
	{0x5C0B, 10, 12},
	{0x5C0D, 14, 14},
	{0x5C0E, 10, 15},
	{0x5C0F,  3,  3},
	{0x5C11,  3,  4},
	{0x5C13,  5,  5},
	{0x5C16,  6,  6},
	{0x5C1A,  6,  8},
	{0x5C20, 13, 13},
	{0x5C22,  3,  3},
	{0x5C24,  4,  4},
	{0x5C28,  7,  7},
	{0x5C2D,  8,  8},
	{0x5C31,  9, 12},
	{0x5C38,  2,  3},
	{0x5C39,  4,  4},
	{0x5C3A,  3,  4},
	{0x5C3B,  4,  5},
	{0x5C3C,  5,  5},
	{0x5C3D,  5,  6},
	{0x5C3E,  5,  7},
	{0x5C3F,  5,  7},
	{0x5C40,  4,  7},
	{0x5C41,  6,  8},
	{0x5C45,  5,  8},
	{0x5C46,  6,  8},
	{0x5C48,  6,  8},
	{0x5C4A,  6,  8},
	{0x5C4B,  5,  9},
	{0x5C4D,  8,  9},
	{0x5C4E,  8,  9},
	{0x5C4F,  8, 10},
	{0x5C50, 10, 10},
	{0x5C51,  9, 10},
	{0x5C53,  9, 10},
	{0x5C55,  7, 11},
	{0x5C5E,  8, 12},
	{0x5C60,  9, 11},
	{0x5C61, 10, 12},
	{0x5C64, 13, 14},
	{0x5C65, 10, 15},
	{0x5C6C, 18, 21},
	{0x5C6E,  2,  3},
	{0x5C6F,  3,  4},
	{0x5C71,  2,  3},
	{0x5C76,  4,  5},
	{0x5C79,  5,  6},
	{0x5C8C,  6,  7},
	{0x5C90,  6,  7},
	{0x5C91,  6,  7},
	{0x5C94,  6,  7},
	{0x5CA1,  6,  8},
	{0x5CA8,  7,  8},
	{0x5CA9,  5,  8},
	{0x5CAB,  7,  8},
	{0x5CAC,  7,  8},
	{0x5CB1,  7,  8},
	{0x5CB3,  6,  8},
	{0x5CB6,  6,  8},
	{0x5CB7,  6,  8},
	{0x5CB8,  7,  8},
	{0x5CBB,  6,  8},
	{0x5CBC,  7,  8},
	{0x5CBE,  7,  8},
	{0x5CC5,  7,  9},
	{0x5CC7,  7,  9},
	{0x5CD9,  8,  9},
	{0x5CE0,  7,  9},
	{0x5CE1,  7,  9},
	{0x5CE8,  8, 10},
	{0x5CE9,  8, 10},
	{0x5CEA,  8, 10},
	{0x5CED,  9, 10},
	{0x5CEF,  7, 10},
	{0x5CF0,  7, 10},
	{0x5CF6,  7, 10},
	{0x5CFA,  9, 10},
	{0x5CFB,  6, 10},
	{0x5CFD,  9, 10},
	{0x5D07,  9, 11},
	{0x5D0B,  9, 10},
	{0x5D0E,  8, 11},
	{0x5D11, 11, 12},
	{0x5D14, 10, 11},
	{0x5D15, 10, 11},
	{0x5D16,  8, 11},
	{0x5D17,  9, 11},
	{0x5D18, 10, 11},
	{0x5D19, 10, 11},
	{0x5D1A, 10, 11},
	{0x5D1B,  7, 11},
	{0x5D1F, 10, 11},
	{0x5D22,  9, 11},
	{0x5D29, 10, 11},
	{0x5D4B, 11, 12},
	{0x5D4C, 10, 12},
	{0x5D4E, 10, 12},
	{0x5D50,  8, 12},
	{0x5D52,  9, 12},
	{0x5D5C,  9, 12},
	{0x5D69,  9, 13},
	{0x5D6C, 10, 13},
	{0x5D6F, 10, 13},
	{0x5D73, 12, 13},
	{0x5D76, 10, 13},
	{0x5D82, 13, 14},
	{0x5D84, 11, 13},
	{0x5D87, 10, 14},
	{0x5D8B, 12, 14},
	{0x5D8C, 12, 14},
	{0x5D90, 12, 14},
	{0x5D9D, 11, 15},
	{0x5DA2, 14, 15},
	{0x5DAC, 12, 16},
	{0x5DAE, 11, 16},
	{0x5DB7, 15, 17},
	{0x5DBA, 12, 17},
	{0x5DBC, 15, 16},
	{0x5DBD, 15, 17},
	{0x5DC9, 21, 21},
	{0x5DCC, 17, 20},
	{0x5DCD, 18, 21},
	{0x5DD2, 15, 22},
	{0x5DD3, 17, 22},
	{0x5DD6, 19, 23},
	{0x5DDB,  3,  3},
	{0x5DDD,  3,  3},
	{0x5DDE,  6,  6},
	{0x5DE1,  4,  6},
	{0x5DE3, 11, 11},
	{0x5DE5,  2,  3},
	{0x5DE6,  3,  5},
	{0x5DE7,  4,  5},
	{0x5DE8,  3,  5},
	{0x5DEB,  7,  7},
	{0x5DEE,  7, 10},
	{0x5DF1,  2,  3},
	{0x5DF2,  3,  3},
	{0x5DF3,  2,  3},
	{0x5DF4,  3,  4},
	{0x5DF5,  6,  7},
	{0x5DF7,  7,  9},
	{0x5DFB,  6,  9},
	{0x5DFD,  8, 12},
	{0x5DFE,  3,  3},
	{0x5E02,  3,  5},
	{0x5E03,  3,  5},
	{0x5E06,  5,  6},
	{0x5E0B,  6,  7},
	{0x5E0C,  5,  7},
	{0x5E11,  8,  8},
	{0x5E16,  7,  8},
	{0x5E19,  8,  8},
	{0x5E1A,  8,  8},
	{0x5E1B,  7,  8},
	{0x5E1D,  7,  9},
	{0x5E25,  8,  9},
	{0x5E2B,  6, 10},
	{0x5E2D,  7, 10},
	{0x5E2F,  7, 10},
	{0x5E30,  7, 10},
	{0x5E33,  8, 11},
	{0x5E36,  9, 11},
	{0x5E37, 10, 11},
	{0x5E38,  7, 11},
	{0x5E3D,  9, 12},
	{0x5E40, 11, 12},
	{0x5E43, 12, 13},
	{0x5E44,  9, 12},
	{0x5E45,  9, 12},
	{0x5E47, 12, 12},
	{0x5E4C, 11, 13},
	{0x5E4E, 13, 13},
	{0x5E54, 14, 14},
	{0x5E55, 11, 13},
	{0x5E57, 12, 14},
	{0x5E5F, 14, 15},
	{0x5E61, 14, 15},
	{0x5E62, 14, 15},
	{0x5E63, 12, 15},
	{0x5E64, 11, 15},
	{0x5E72,  3,  3},
	{0x5E73,  4,  5},
	{0x5E74,  4,  6},
	{0x5E75,  6,  6},
	{0x5E76,  6,  7},
	{0x5E78,  7,  8},
	{0x5E79, 12, 13},
	{0x5E7A,  2,  3},
	{0x5E7B,  2,  4},
	{0x5E7C,  2,  5},
	{0x5E7D,  5,  9},
	{0x5E7E,  7, 12},
	{0x5E7F,  3,  3},
	{0x5E81,  4,  5},
	{0x5E83,  4,  5},
	{0x5E84,  5,  6},
	{0x5E87,  7,  8},
	{0x5E8A,  6,  7},
	{0x5E8F,  4,  7},
	{0x5E95,  6,  8},
	{0x5E96,  6,  9},
	{0x5E97,  6,  8},
	{0x5E9A,  8,  9},
	{0x5E9C,  7,  8},
	{0x5EA0,  8,  9},
	{0x5EA6,  7,  9},
	{0x5EA7,  8, 10},
	{0x5EAB, 10, 10},
	{0x5EAD,  7,  9},
	{0x5EB5, 10, 11},
	{0x5EB6, 10, 11},
	{0x5EB7,  8, 11},
	{0x5EB8, 11, 12},
	{0x5EC1, 11, 12},
	{0x5EC2, 12, 12},
	{0x5EC3, 11, 12},
	{0x5EC8, 10, 13},
	{0x5EC9, 12, 13},
	{0x5ECA,  8, 11},
	{0x5ECF, 12, 13},
	{0x5ED0, 13, 14},
	{0x5ED3, 10, 13},
	{0x5ED6, 14, 14},
	{0x5EDA, 15, 15},
	{0x5EDB, 15, 15},
	{0x5EDD, 13, 15},
	{0x5EDF, 15, 15},
	{0x5EE0, 13, 15},
	{0x5EE1, 15, 16},
	{0x5EE2, 15, 15},
	{0x5EE3, 13, 15},
	{0x5EE8, 16, 16},
	{0x5EE9, 15, 16},
	{0x5EEC, 18, 19},
	{0x5EF0, 18, 20},
	{0x5EF1, 18, 21},
	{0x5EF3, 24, 27},
	{0x5EF4,  2,  2},
	{0x5EF6,  6,  7},
	{0x5EF7,  5,  6},
	{0x5EF8,  7,  7},
	{0x5EFA,  7,  9},
	{0x5EFB,  7,  8},
	{0x5EFC,  8,  9},
	{0x5EFE,  3,  3},
	{0x5EFF,  3,  4},
	{0x5F01,  4,  5},
	{0x5F03,  6,  7},
	{0x5F04,  7,  7},
	{0x5F09,  9, 10},
	{0x5F0A, 13, 15},
	{0x5F0B,  3,  3},
	{0x5F0C,  4,  4},
	{0x5F0D,  5,  5},
	{0x5F0F,  4,  6},
	{0x5F10,  6,  6},
	{0x5F11, 11, 12},
	{0x5F13,  1,  3},
	{0x5F14,  2,  5},
	{0x5F15,  2,  4},
	{0x5F16,  2,  4},
	{0x5F17,  3,  5},
	{0x5F18,  3,  5},
	{0x5F1B,  4,  6},
	{0x5F1F,  4,  7},
	{0x5F25,  5,  8},
	{0x5F26,  5,  8},
	{0x5F27,  4,  9},
	{0x5F29,  6,  8},
	{0x5F2D,  7,  9},
	{0x5F2F,  7,  9},
	{0x5F31,  6, 10},
	{0x5F35,  7, 11},
	{0x5F37,  5, 11},
	{0x5F38,  9, 11},
	{0x5F3C,  7, 12},
	{0x5F3E, 10, 12},
	{0x5F41,  7, 13},
	{0x5F48, 10, 15},
	{0x5F4A, 14, 16},
	{0x5F4C, 15, 18},
	{0x5F4E, 17, 22},
	{0x5F51,  3,  4},
	{0x5F53,  5,  6},
	{0x5F56,  8,  9},
	{0x5F57, 11, 11},
	{0x5F59, 13, 13},
	{0x5F5C, 16, 17},
	{0x5F5D, 18, 18},
	{0x5F61,  3,  3},
	{0x5F62,  5,  7},
	{0x5F66,  8,  9},
	{0x5F69,  9, 11},
	{0x5F6A, 10, 11},
	{0x5F6B,  8, 11},
	{0x5F6C, 10, 11},
	{0x5F6D,  9, 12},
	{0x5F70, 14, 14},
	{0x5F71, 11, 15},
	{0x5F73,  3,  3},
	{0x5F77,  7,  7},
	{0x5F79,  6,  7},
	{0x5F7C,  6,  8},
	{0x5F7F,  6,  8},
	{0x5F80,  7,  8},
	{0x5F81,  6,  8},
	{0x5F82,  8,  8},
	{0x5F83,  7,  8},
	{0x5F84,  7,  8},
	{0x5F85,  7,  9},
	{0x5F87,  9,  9},
	{0x5F88,  8,  9},
	{0x5F8A,  8,  9},
	{0x5F8B,  8,  9},
	{0x5F8C,  5,  9},
	{0x5F90, 10, 10},
	{0x5F91,  9, 10},
	{0x5F92,  9, 10},
	{0x5F93,  8, 10},
	{0x5F97,  9, 11},
	{0x5F98, 11, 11},
	{0x5F99, 11, 11},
	{0x5F9E, 11, 11},
	{0x5FA0, 11, 11},
	{0x5FA1,  7, 12},
	{0x5FA8, 11, 12},
	{0x5FA9, 10, 12},
	{0x5FAA, 11, 12},
	{0x5FAD, 12, 13},
	{0x5FAE, 10, 13},
	{0x5FB3, 10, 14},
	{0x5FB4, 11, 14},
	{0x5FB9, 11, 15},
	{0x5FBC, 14, 15},
	{0x5FBD, 13, 16},
	{0x5FC3,  3,  4},
	{0x5FC5,  5,  5},
	{0x5FCC,  5,  7},
	{0x5FCD,  6,  7},
	{0x5FD6,  6,  6},
	{0x5FD7,  5,  7},
	{0x5FD8,  5,  7},
	{0x5FD9,  6,  6},
	{0x5FDC,  6,  7},
	{0x5FDD,  7,  8},
	{0x5FE0,  6,  8},
	{0x5FE4,  7,  7},
	{0x5FEB,  6,  7},
	{0x5FF0,  7,  7},
	{0x5FF1,  7,  7},
	{0x5FF5,  6,  8},
	{0x5FF8,  7,  7},
	{0x5FFB,  6,  7},
	{0x5FFD,  8,  8},
	{0x5FFF,  7,  8},
	{0x600E,  8,  9},
	{0x600F,  8,  9},
	{0x6010,  6,  8},
	{0x6012,  8,  9},
	{0x6015,  7,  8},
	{0x6016,  7,  8},
	{0x6019,  7,  8},
	{0x601B,  8,  8},
	{0x601C,  7,  8},
	{0x601D,  7,  9},
	{0x6020,  7,  9},
	{0x6021,  6,  8},
	{0x6025,  7,  9},
	{0x6026,  8,  8},
	{0x6027,  6,  8},
	{0x6028,  8,  9},
	{0x6029,  7,  8},
	{0x602A,  7,  8},
	{0x602B,  8,  8},
	{0x602F,  6,  8},
	{0x6031,  9,  9},
	{0x603A,  7,  8},
	{0x6041,  9, 10},
	{0x6042,  9,  9},
	{0x6043,  9,  9},
	{0x6046,  8, 10},
	{0x604A,  9,  9},
	{0x604B,  9, 10},
	{0x604D,  7,  9},
	{0x6050,  8, 10},
	{0x6052,  8,  9},
	{0x6055, 10, 10},
	{0x6059,  9, 10},
	{0x605A, 10, 10},
	{0x605F,  8,  9},
	{0x6060,  8,  9},
	{0x6062,  9,  9},
	{0x6063,  9, 10},
	{0x6064,  8,  9},
	{0x6065, 10, 10},
	{0x6068,  7,  9},
	{0x6069,  9, 10},
	{0x606A,  6,  9},
	{0x606B,  7,  9},
	{0x606C,  7,  9},
	{0x606D,  9, 10},
	{0x606F,  8, 10},
	{0x6070,  8,  9},
	{0x6075,  9, 10},
	{0x6077, 10, 10},
	{0x6081,  9, 10},
	{0x6083, 10, 10},
	{0x6084,  9, 10},
	{0x6089, 10, 11},
	{0x608B,  9, 10},
	{0x608C,  8, 10},
	{0x608D,  9, 10},
	{0x6092,  9, 10},
	{0x6094,  7, 10},
	{0x6096,  9, 10},
	{0x6097,  9, 11},
	{0x609A,  9, 10},
	{0x609B,  8, 10},
	{0x609F,  8, 10},
	{0x60A0,  8, 11},
	{0x60A3,  7, 11},
	{0x60A6,  8, 10},
	{0x60A7,  9, 10},
	{0x60A9,  9, 10},
	{0x60AA,  9, 11},
	{0x60B2, 11, 12},
	{0x60B3, 11, 12},
	{0x60B4, 11, 11},
	{0x60B5, 10, 11},
	{0x60B6, 12, 12},
	{0x60B8,  9, 11},
	{0x60BC, 11, 11},
	{0x60BD, 11, 11},
	{0x60C5,  9, 11},
	{0x60C6,  9, 11},
	{0x60C7,  8, 11},
	{0x60D1,  8, 12},
	{0x60D3, 10, 11},
	{0x60D8, 10, 11},
	{0x60DA, 10, 11},
	{0x60DC, 10, 11},
	{0x60DF,  9, 11},
	{0x60E0, 11, 12},
	{0x60E1,  8, 14},
	{0x60E3, 10, 12},
	{0x60E7, 10, 11},
	{0x60E8, 10, 11},
	{0x60F0, 10, 12},
	{0x60F1, 11, 12},
	{0x60F3, 12, 13},
	{0x60F4, 10, 12},
	{0x60F6, 10, 12},
	{0x60F7, 13, 13},
	{0x60F9, 10, 12},
	{0x60FA, 11, 12},
	{0x60FB, 11, 12},
	{0x6100, 11, 12},
	{0x6101, 12, 13},
	{0x6103, 12, 12},
	{0x6106, 12, 13},
	{0x6108, 13, 13},
	{0x6109, 12, 12},
	{0x610D, 12, 13},
	{0x610E,  9, 12},
	{0x610F, 10, 13},
	{0x6115,  8, 12},
	{0x611A, 11, 13},
	{0x611B, 10, 13},
	{0x611F,  9, 13},
	{0x6121, 11, 12},
	{0x6127, 11, 13},
	{0x6128, 14, 14},
	{0x612C, 12, 14},
	{0x6134, 13, 13},
	{0x613C, 12, 13},
	{0x613D, 13, 13},
	{0x613E, 12, 13},
	{0x613F, 13, 14},
	{0x6142, 13, 14},
	{0x6144, 12, 13},
	{0x6147, 13, 14},
	{0x6148,  9, 13},
	{0x614A, 13, 13},
	{0x614B, 11, 14},
	{0x614C, 12, 12},
	{0x614D, 13, 13},
	{0x614E, 12, 13},
	{0x6153, 14, 15},
	{0x6155, 13, 15},
	{0x6158, 14, 14},
	{0x6159, 13, 15},
	{0x615A, 13, 14},
	{0x615D, 12, 15},
	{0x615F, 13, 14},
	{0x6162, 13, 14},
	{0x6163, 11, 15},
	{0x6165, 12, 13},
	{0x6167, 13, 15},
	{0x6168, 11, 13},
	{0x616B, 14, 15},
	{0x616E, 13, 15},
	{0x616F, 13, 14},
	{0x6170, 13, 15},
	{0x6171, 13, 14},
	{0x6173, 13, 15},
	{0x6174, 13, 14},
	{0x6175, 14, 14},
	{0x6176, 13, 16},
	{0x6177, 12, 14},
	{0x617E, 14, 15},
	{0x6182, 13, 15},
	{0x6187, 12, 15},
	{0x618A, 16, 16},
	{0x618E, 13, 14},
	{0x6190, 12, 16},
	{0x6191, 14, 16},
	{0x6194, 14, 15},
	{0x6196, 15, 16},
	{0x6199, 15, 16},
	{0x619A, 11, 15},
	{0x61A4, 14, 15},
	{0x61A7, 13, 15},
	{0x61A9, 14, 16},
	{0x61AB, 14, 15},
	{0x61AC, 12, 15},
	{0x61AE, 14, 15},
	{0x61B2, 14, 16},
	{0x61B6, 14, 16},
	{0x61BA, 14, 16},
	{0x61BE, 14, 16},
	{0x61C3, 15, 17},
	{0x61C6, 13, 16},
	{0x61C7, 15, 17},
	{0x61C8, 15, 16},
	{0x61C9, 14, 17},
	{0x61CA, 14, 16},
	{0x61CB, 15, 17},
	{0x61CC, 15, 16},
	{0x61CD, 14, 16},
	{0x61D0, 13, 16},
	{0x61E3, 17, 18},
	{0x61E6, 16, 17},
	{0x61F2, 15, 18},
	{0x61F4, 17, 18},
	{0x61F6, 17, 19},
	{0x61F7, 17, 21},
	{0x61F8, 16, 20},
	{0x61FA, 20, 21},
	{0x61FC, 20, 21},
	{0x61FD, 18, 20},
	{0x61FE, 21, 21},
	{0x61FF, 19, 22},
	{0x6200, 17, 23},
	{0x6208,  4,  4},
	{0x6209,  5,  6},
	{0x620A,  5,  5},
	{0x620C,  5,  6},
	{0x620D,  6,  6},
	{0x620E,  6,  6},
	{0x6210,  5,  6},
	{0x6211,  6,  7},
	{0x6212,  7,  7},
	{0x6214,  7,  8},
	{0x6216,  7,  8},
	{0x621A,  9, 11},
	{0x621B,  9, 11},
	{0x621D, 10, 11},
	{0x621E, 11, 12},
	{0x621F, 11, 12},
	{0x6221, 13, 13},
	{0x6226, 12, 13},
	{0x622A, 13, 14},
	{0x622E, 15, 15},
	{0x622F, 14, 15},
	{0x6230, 13, 16},
	{0x6232, 14, 17},
	{0x6233, 16, 18},
	{0x6234, 14, 17},
	{0x6238,  2,  4},
	{0x623B,  6,  7},
	{0x623F,  6,  8},
	{0x6240,  5,  8},
	{0x6241,  9,  9},
	{0x6247,  9, 10},
	{0x6248,  8, 11},
	{0x6249, 10, 12},
	{0x624B,  3,  4},
	{0x624D,  2,  3},
	{0x624E,  4,  4},
	{0x6253,  3,  5},
	{0x6255,  3,  5},
	{0x6258,  5,  6},
	{0x625B,  6,  6},
	{0x625E,  6,  6},
	{0x6260,  6,  6},
	{0x6263,  5,  6},
	{0x6268,  6,  6},
	{0x626E,  6,  8},
	{0x6271,  5,  6},
	{0x6276,  6,  7},
	{0x6279,  6,  8},
	{0x627C,  7,  7},
	{0x627E,  7,  7},
	{0x627F,  6,  8},
	{0x6280,  5,  7},
	{0x6282,  7,  7},
	{0x6283,  6,  7},
	{0x6284,  6,  7},
	{0x6289,  7,  7},
	{0x628A,  5,  7},
	{0x6291,  5,  7},
	{0x6292,  6,  7},
	{0x6293,  6,  7},
	{0x6294,  7,  7},
	{0x6295,  6,  7},
	{0x6296,  7,  7},
	{0x6297,  6,  7},
	{0x6298,  4,  7},
	{0x629B,  7,  7},
	{0x629C,  6,  7},
	{0x629E,  5,  7},
	{0x62AB,  7,  8},
	{0x62AC,  6,  8},
	{0x62B1,  5,  8},
	{0x62B5,  6,  8},
	{0x62B9,  7,  8},
	{0x62BB,  8,  8},
	{0x62BC,  6,  8},
	{0x62BD,  7,  8},
	{0x62C2,  6,  8},
	{0x62C5,  7,  8},
	{0x62C6,  7,  8},
	{0x62C7,  8,  8},
	{0x62C8,  8,  8},
	{0x62C9,  6,  8},
	{0x62CA,  8,  8},
	{0x62CC,  8,  8},
	{0x62CD,  7,  8},
	{0x62CF,  8,  9},
	{0x62D0,  6,  8},
	{0x62D1,  7,  8},
	{0x62D2,  7,  8},
	{0x62D3,  6,  8},
	{0x62D4,  8,  8},
	{0x62D7,  6,  8},
	{0x62D8,  6,  8},
	{0x62D9,  5,  9},
	{0x62DB,  7,  8},
	{0x62DC,  9,  9},
	{0x62DD,  8,  8},
	{0x62E0,  6,  9},
	{0x62E1,  6,  8},
	{0x62EC,  7,  9},
	{0x62ED,  8,  9},
	{0x62EE,  9,  9},
	{0x62EF,  7,  8},
	{0x62F1,  9,  9},
	{0x62F3,  9, 10},
	{0x62F5,  8,  8},
	{0x62F6,  8,  9},
	{0x62F7,  8,  9},
	{0x62FE,  7,  9},
	{0x62FF,  8, 10},
	{0x6301,  8,  9},
	{0x6302,  9,  9},
	{0x6307,  7,  9},
	{0x6308,  9, 10},
	{0x6309,  8,  9},
	{0x630C,  8,  9},
	{0x6311,  8,  9},
	{0x6319,  8, 10},
	{0x631F,  8,  9},
	{0x6327,  9,  9},
	{0x6328,  8, 10},
	{0x632B,  9, 10},
	{0x632F,  7, 10},
	{0x633A,  7, 10},
	{0x633D, 10, 11},
	{0x633E, 10, 11},
	{0x633F,  9, 10},
	{0x6349,  8, 10},
	{0x634C,  8, 10},
	{0x634D, 10, 10},
	{0x634F,  9, 10},
	{0x6350,  9, 10},
	{0x6355,  9, 10},
	{0x6357,  9, 12},
	{0x635C,  9, 10},
	{0x6367, 10, 12},
	{0x6368,  8, 11},
	{0x6369,  9, 10},
	{0x636B, 11, 11},
	{0x636E,  9, 11},
	{0x6372, 10, 12},
	{0x6376, 10, 11},
	{0x6377, 11, 11},
	{0x637A, 10, 11},
	{0x637B, 10, 11},
	{0x6380,  9, 10},
	{0x6383,  9, 11},
	{0x6388,  9, 11},
	{0x6389, 11, 11},
	{0x638C,  9, 12},
	{0x638E,  9, 11},
	{0x638F, 10, 11},
	{0x6392, 11, 11},
	{0x6396, 11, 11},
	{0x6398,  8, 11},
	{0x639B,  9, 11},
	{0x639F, 11, 11},
	{0x63A0, 10, 11},
	{0x63A1,  9, 11},
	{0x63A2, 10, 11},
	{0x63A3, 10, 12},
	{0x63A5,  9, 11},
	{0x63A7,  9, 11},
	{0x63A8,  9, 11},
	{0x63A9, 11, 12},
	{0x63AA, 10, 11},
	{0x63AB, 11, 11},
	{0x63AC, 10, 11},
	{0x63B2, 10, 12},
	{0x63B4, 10, 11},
	{0x63B5,  9, 11},
	{0x63BB,  8, 11},
	{0x63BE, 11, 12},
	{0x63C0, 12, 12},
	{0x63C3, 11, 12},
	{0x63C4, 11, 12},
	{0x63C6, 11, 12},
	{0x63C9, 11, 12},
	{0x63CF, 10, 11},
	{0x63D0, 11, 12},
	{0x63D2, 10, 12},
	{0x63D6, 11, 12},
	{0x63DA, 10, 12},
	{0x63DB, 11, 12},
	{0x63E1,  8, 12},
	{0x63E3, 10, 12},
	{0x63E9, 11, 12},
	{0x63EE, 11, 12},
	{0x63F4, 11, 12},
	{0x63F6, 11, 11},
	{0x63FA, 10, 12},
	{0x6406, 13, 13},
	{0x640D, 10, 13},
	{0x640F, 13, 13},
	{0x6413, 11, 13},
	{0x6416, 11, 14},
	{0x6417, 11, 13},
	{0x641C, 10, 13},
	{0x6426, 11, 13},
	{0x6428, 13, 13},
	{0x642C, 11, 13},
	{0x642D, 11, 12},
	{0x6434, 12, 14},
	{0x6436, 12, 13},
	{0x643A, 11, 13},
	{0x643E, 12, 13},
	{0x6442, 12, 13},
	{0x644E, 14, 14},
	{0x6458, 11, 14},
	{0x6467, 12, 14},
	{0x6469, 14, 15},
	{0x646F, 13, 15},
	{0x6476, 14, 15},
	{0x6478,  7, 14},
	{0x647A, 11, 14},
	{0x6483, 13, 15},
	{0x6488, 14, 15},
	{0x6492, 14, 15},
	{0x6493, 14, 15},
	{0x6495, 14, 15},
	{0x649A, 14, 15},
	{0x649E, 14, 15},
	{0x64A4, 12, 15},
	{0x64A5, 13, 15},
	{0x64A9, 14, 15},
	{0x64AB, 14, 15},
	{0x64AD, 13, 15},
	{0x64AE, 13, 15},
	{0x64B0, 13, 15},
	{0x64B2, 14, 15},
	{0x64B9, 13, 15},
	{0x64BB, 14, 15},
	{0x64BC, 13, 16},
	{0x64C1, 12, 16},
	{0x64C2, 15, 16},
	{0x64C5, 15, 16},
	{0x64C7, 15, 16},
	{0x64CD, 10, 16},
	{0x64D2, 13, 15},
	{0x64D4, 16, 16},
	{0x64D8, 12, 17},
	{0x64DA, 14, 16},
	{0x64E0, 15, 15},
	{0x64E1, 15, 17},
	{0x64E2, 15, 17},
	{0x64E3, 16, 17},
	{0x64E6, 14, 17},
	{0x64E7, 15, 16},
	{0x64EC, 14, 17},
	{0x64EF,  9, 17},
	{0x64F1, 15, 17},
	{0x64F2, 16, 18},
	{0x64F4, 16, 18},
	{0x64F6, 16, 18},
	{0x64FA, 17, 18},
	{0x64FD, 14, 17},
	{0x64FE, 15, 18},
	{0x6500, 18, 19},
	{0x6505, 17, 18},
	{0x6518, 16, 20},
	{0x651C, 17, 21},
	{0x651D, 21, 21},
	{0x6523, 16, 23},
	{0x6524, 19, 22},
	{0x652A, 21, 22},
	{0x652B, 22, 23},
	{0x652C, 21, 25},
	{0x652F,  3,  4},
	{0x6534,  4,  4},
	{0x6535,  4,  4},
	{0x6536,  4,  7},
	{0x6537,  5,  6},
	{0x6538,  5,  7},
	{0x6539,  3,  7},
	{0x653B,  4,  7},
	{0x653E,  6,  8},
	{0x653F,  6,  9},
	{0x6545,  6,  9},
	{0x6548,  9, 10},
	{0x654D, 10, 11},
	{0x654F,  8, 11},
	{0x6551,  8, 11},
	{0x6555, 10, 11},
	{0x6556, 10, 11},
	{0x6557,  8, 11},
	{0x6558,  9, 11},
	{0x6559,  7, 11},
	{0x655D, 11, 12},
	{0x655E,  9, 12},
	{0x6562, 10, 12},
	{0x6563, 10, 12},
	{0x6566,  8, 12},
	{0x656C,  7, 12},
	{0x6570, 10, 13},
	{0x6572, 11, 14},
	{0x6574, 11, 16},
	{0x6575, 11, 15},
	{0x6577, 11, 15},
	{0x6578, 14, 15},
	{0x6582, 15, 17},
	{0x6583, 17, 17},
	{0x6587,  3,  4},
	{0x6588,  6,  7},
	{0x6589,  7,  8},
	{0x658C, 10, 12},
	{0x658E,  8, 11},
	{0x6590, 12, 12},
	{0x6591, 10, 12},
	{0x6597,  4,  4},
	{0x6599,  8, 10},
	{0x659B, 10, 11},
	{0x659C,  9, 11},
	{0x659F, 12, 13},
	{0x65A1, 14, 14},
	{0x65A4,  3,  4},
	{0x65A5,  4,  5},
	{0x65A7,  7,  8},
	{0x65AB,  6,  9},
	{0x65AC, 10, 11},
	{0x65AD,  8, 11},
	{0x65AF, 10, 12},
	{0x65B0, 10, 13},
	{0x65B7,  9, 18},
	{0x65B9,  3,  4},
	{0x65BC,  7,  8},
	{0x65BD,  8,  9},
	{0x65C1,  9, 10},
	{0x65C3,  9, 10},
	{0x65C4,  9, 10},
	{0x65C5,  6, 10},
	{0x65C6,  8, 10},
	{0x65CB, 10, 11},
	{0x65CC, 10, 11},
	{0x65CF,  8, 11},
	{0x65D2, 11, 13},
	{0x65D7, 13, 14},
	{0x65D9, 15, 16},
	{0x65DB, 16, 18},
	{0x65E0,  4,  4},
	{0x65E1,  3,  4},
	{0x65E2,  9, 10},
	{0x65E5,  4,  4},
	{0x65E6,  5,  5},
	{0x65E7,  5,  5},
	{0x65E8,  6,  6},
	{0x65E9,  5,  6},
	{0x65EC,  6,  6},
	{0x65ED,  6,  6},
	{0x65F1,  7,  7},
	{0x65FA,  8,  8},
	{0x65FB,  8,  8},
	{0x6602,  6,  8},
	{0x6603,  8,  8},
	{0x6606,  8,  9},
	{0x6607,  7,  8},
	{0x660A,  8,  8},
	{0x660C,  8,  8},
	{0x660E,  7,  8},
	{0x660F,  7,  8},
	{0x6613,  6,  8},
	{0x6614,  8,  8},
	{0x661C,  8,  9},
	{0x661F,  8,  9},
	{0x6620,  8,  9},
	{0x6625,  8,  9},
	{0x6627,  9,  9},
	{0x6628,  8,  9},
	{0x662D,  7,  9},
	{0x662F,  9,  9},
	{0x6634,  7,  9},
	{0x6635,  8,  9},
	{0x6636,  8,  9},
	{0x663C,  8,  9},
	{0x663F,  8,  9},
	{0x6641,  9, 10},
	{0x6642,  8, 10},
	{0x6643,  8, 10},
	{0x6644,  8, 10},
	{0x6649,  8, 10},
	{0x664B,  9, 10},
	{0x664F,  9, 10},
	{0x6652, 10, 11},
	{0x665D, 11, 11},
	{0x665E, 10, 11},
	{0x665F, 10, 11},
	{0x6662, 10, 11},
	{0x6664,  9, 11},
	{0x6666,  9, 11},
	{0x6667, 10, 11},
	{0x6668,  9, 11},
	{0x6669,  9, 12},
	{0x666E, 10, 12},
	{0x666F,  9, 12},
	{0x6670, 11, 12},
	{0x6674, 11, 12},
	{0x6676, 12, 12},
	{0x667A, 10, 12},
	{0x6681, 11, 12},
	{0x6683, 12, 13},
	{0x6684, 11, 13},
	{0x6687, 11, 13},
	{0x6688, 13, 13},
	{0x6689, 12, 13},
	{0x668E, 12, 12},
	{0x6691, 11, 12},
	{0x6696, 11, 13},
	{0x6697, 11, 13},
	{0x6698, 11, 13},
	{0x669D, 14, 14},
	{0x66A2, 12, 14},
	{0x66A6, 12, 14},
	{0x66AB, 14, 15},
	{0x66AE, 13, 14},
	{0x66B4, 12, 15},
	{0x66B8, 16, 16},
	{0x66B9, 14, 15},
	{0x66BC, 15, 15},
	{0x66BE, 11, 15},
	{0x66C1, 15, 16},
	{0x66C4, 14, 14},
	{0x66C7, 13, 16},
	{0x66C9, 14, 16},
	{0x66D6, 14, 17},
	{0x66D9, 17, 17},
	{0x66DA, 14, 17},
	{0x66DC, 15, 18},
	{0x66DD, 17, 19},
	{0x66E0, 17, 19},
	{0x66E6, 20, 20},
	{0x66E9, 15, 21},
	{0x66F0,  4,  4},
	{0x66F2,  5,  6},
	{0x66F3,  6,  7},
	{0x66F4,  7,  7},
	{0x66F5,  7,  7},
	{0x66F7,  9,  9},
	{0x66F8,  9, 10},
	{0x66F9, 11, 13},
	{0x66FC, 11, 11},
	{0x66FD, 10, 11},
	{0x66FE, 11, 13},
	{0x66FF, 12, 12},
	{0x6700, 11, 12},
	{0x6703, 13, 13},
	{0x6708,  3,  4},
	{0x6709,  5,  6},
	{0x670B,  7,  8},
	{0x670D,  7,  8},
	{0x670F,  7,  9},
	{0x6714,  9, 10},
	{0x6715,  9, 10},
	{0x6716, 10, 11},
	{0x6717,  8, 11},
	{0x671B,  9, 11},
	{0x671D, 10, 12},
	{0x671E, 12, 12},
	{0x671F, 11, 12},
	{0x6726, 14, 17},
	{0x6727, 17, 20},
	{0x6728,  4,  4},
	{0x672A,  4,  5},
	{0x672B,  4,  5},
	{0x672C,  5,  5},
	{0x672D,  4,  5},
	{0x672E,  5,  5},
	{0x6731,  5,  6},
	{0x6734,  6,  7},
	{0x6736,  6,  6},
	{0x6737,  6,  6},
	{0x6738,  6,  6},
	{0x673A,  6,  6},
	{0x673D,  6,  6},
	{0x673F,  5,  6},
	{0x6741,  6,  6},
	{0x6746,  7,  7},
	{0x6749,  4,  7},
	{0x674E,  6,  7},
	{0x674F,  6,  7},
	{0x6750,  6,  7},
	{0x6751,  6,  7},
	{0x6753,  6,  7},
	{0x6756,  7,  7},
	{0x6759,  7,  8},
	{0x675C,  6,  7},
	{0x675E,  6,  7},
	{0x675F,  5,  7},
	{0x6760,  6,  7},
	{0x6761,  6,  7},
	{0x6762,  7,  7},
	{0x6763,  6,  7},
	{0x6764,  6,  7},
	{0x6765,  5,  7},
	{0x676A,  7,  8},
	{0x676D,  8,  9},
	{0x676F,  7,  8},
	{0x6770,  8,  8},
	{0x6771,  7,  8},
	{0x6772,  8,  8},
	{0x6773,  8,  8},
	{0x6775,  7,  8},
	{0x6777,  7,  8},
	{0x677C,  6,  8},
	{0x677E,  7,  8},
	{0x677F,  6,  8},
	{0x6785,  8,  8},
	{0x6787,  8,  9},
	{0x6789,  8,  8},
	{0x678B,  8,  8},
	{0x678C,  8,  8},
	{0x6790,  6,  8},
	{0x6795,  7,  8},
	{0x6797,  8,  8},
	{0x679A,  6,  8},
	{0x679C,  7,  9},
	{0x679D,  6,  8},
	{0x67A0,  8,  8},
	{0x67A1,  7,  8},
	{0x67A2,  7,  9},
	{0x67A6,  7,  8},
	{0x67A9,  7,  8},
	{0x67AF,  8,  9},
	{0x67B3,  8,  9},
	{0x67B4,  8,  9},
	{0x67B6,  7,  9},
	{0x67B7,  7,  9},
	{0x67B8,  7,  9},
	{0x67B9,  7,  9},
	{0x67C1,  8,  9},
	{0x67C4,  8,  9},
	{0x67C6,  8,  9},
	{0x67CA,  8,  9},
	{0x67CE,  8,  9},
	{0x67CF,  8,  9},
	{0x67D0,  8,  9},
	{0x67D1,  8,  9},
	{0x67D3,  8, 10},
	{0x67D4,  6,  9},
	{0x67D8,  6,  9},
	{0x67DA,  9,  9},
	{0x67DD,  8,  9},
	{0x67DE,  8,  9},
	{0x67E2,  8,  9},
	{0x67E4,  9,  9},
	{0x67E7,  7, 10},
	{0x67E9,  8,  9},
	{0x67EC,  9,  9},
	{0x67EE,  7,  9},
	{0x67EF,  7,  9},
	{0x67F1,  7,  9},
	{0x67F3,  6,  9},
	{0x67F4,  9, 10},
	{0x67F5,  8,  9},
	{0x67FB,  8,  9},
	{0x67FE,  8,  9},
	{0x67FF,  7,  9},
	{0x6802,  9, 10},
	{0x6803,  7,  9},
	{0x6804,  8,  9},
	{0x6813,  9, 10},
	{0x6816, 10, 11},
	{0x6817,  9, 10},
	{0x681E, 10, 10},
	{0x6821,  8, 10},
	{0x6822,  8, 10},
	{0x6829, 10, 10},
	{0x682A,  7, 10},
	{0x682B,  8,  9},
	{0x6832, 10, 10},
	{0x6834,  9, 10},
	{0x6838,  9, 10},
	{0x6839,  8, 10},
	{0x683C,  7, 10},
	{0x683D,  9, 10},
	{0x6840, 10, 11},
	{0x6841,  9, 10},
	{0x6842,  8, 10},
	{0x6843,  9, 10},
	{0x6846, 10, 10},
	{0x6848,  9, 10},
	{0x684D,  9, 10},
	{0x684E,  7, 10},
	{0x6850,  8, 10},
	{0x6851,  9, 10},
	{0x6853, 10, 10},
	{0x6854,  9, 10},
	{0x6859,  9, 10},
	{0x685C, 10, 11},
	{0x685D,  9, 11},
	{0x685F, 10, 10},
	{0x6863,  9, 10},
	{0x6867,  8, 10},
	{0x6874,  9, 10},
	{0x6876, 10, 11},
	{0x6877, 10, 11},
	{0x687E, 10, 11},
	{0x687F, 11, 11},
	{0x6881, 11, 11},
	{0x6883,  9, 10},
	{0x6885,  9, 11},
	{0x688D, 10, 11},
	{0x688F, 11, 11},
	{0x6893, 10, 11},
	{0x6894,  9, 11},
	{0x6897, 10, 11},
	{0x689B, 10, 10},
	{0x689D,  9, 11},
	{0x689F, 10, 11},
	{0x68A0,  9, 11},
	{0x68A2, 10, 11},
	{0x68A6, 10, 11},
	{0x68A7,  9, 11},
	{0x68A8, 10, 11},
	{0x68AD,  9, 11},
	{0x68AF,  9, 11},
	{0x68B0, 10, 11},
	{0x68B1, 10, 11},
	{0x68B3,  9, 11},
	{0x68B5, 11, 11},
	{0x68B6,  9, 11},
	{0x68B9, 10, 11},
	{0x68BA, 11, 11},
	{0x68BC, 10, 12},
	{0x68C4, 10, 13},
	{0x68C6, 12, 12},
	{0x68C9,  8, 12},
	{0x68CA, 11, 12},
	{0x68CB, 11, 12},
	{0x68CD, 12, 13},
	{0x68D2, 11, 12},
	{0x68D4, 10, 12},
	{0x68D5, 12, 12},
	{0x68D7, 11, 12},
	{0x68D8, 11, 12},
	{0x68DA, 12, 12},
	{0x68DF, 12, 13},
	{0x68E0, 11, 12},
	{0x68E1, 10, 12},
	{0x68E3, 10, 12},
	{0x68E7, 12, 12},
	{0x68EE, 11, 12},
	{0x68EF, 11, 12},
	{0x68F2, 11, 12},
	{0x68F9, 12, 12},
	{0x68FA, 10, 12},
	{0x6900, 11, 12},
	{0x6901,  9, 11},
	{0x6904, 11, 12},
	{0x6905, 10, 12},
	{0x6908, 11, 12},
	{0x690B, 10, 12},
	{0x690C, 11, 12},
	{0x690D, 11, 12},
	{0x690E, 10, 12},
	{0x690F,  8, 10},
	{0x6912, 12, 12},
	{0x6919, 12, 12},
	{0x691A, 11, 12},
	{0x691B, 10, 11},
	{0x691C, 10, 12},
	{0x6921, 10, 12},
	{0x6922, 12, 12},
	{0x6923, 12, 12},
	{0x6925,  9, 12},
	{0x6926, 11, 12},
	{0x6928, 12, 12},
	{0x692A,  9, 12},
	{0x6930, 11, 12},
	{0x6934, 11, 13},
	{0x6936, 12, 13},
	{0x6939, 13, 13},
	{0x693D, 12, 13},
	{0x693F, 11, 13},
	{0x694A, 12, 13},
	{0x6953, 10, 13},
	{0x6954, 12, 13},
	{0x6955, 12, 13},
	{0x6959, 11, 13},
	{0x695A, 12, 14},
	{0x695C, 12, 13},
	{0x695D, 13, 13},
	{0x695E, 12, 13},
	{0x6960, 12, 13},
	{0x6961, 13, 13},
	{0x6962, 12, 13},
	{0x696A, 12, 13},
	{0x696B, 12, 13},
	{0x696D, 10, 13},
	{0x696E, 13, 13},
	{0x696F, 11, 13},
	{0x6973, 12, 13},
	{0x6974, 12, 13},
	{0x6975,  8, 12},
	{0x6977, 12, 14},
	{0x6978, 12, 13},
	{0x6979, 13, 13},
	{0x697C, 12, 13},
	{0x697D,  9, 13},
	{0x697E, 11, 13},
	{0x6981, 11, 13},
	{0x6982, 12, 14},
	{0x698A, 12, 13},
	{0x698E, 10, 14},
	{0x6991, 14, 14},
	{0x6994, 10, 12},
	{0x6995, 12, 14},
	{0x699B, 13, 14},
	{0x699C, 13, 14},
	{0x69A0, 14, 14},
	{0x69A7, 14, 14},
	{0x69AE, 14, 14},
	{0x69B1, 13, 14},
	{0x69B2, 14, 14},
	{0x69B4, 12, 13},
	{0x69BB, 14, 14},
	{0x69BE, 14, 14},
	{0x69BF, 12, 14},
	{0x69C1, 11, 14},
	{0x69C3, 12, 14},
	{0x69C7, 14, 14},
	{0x69CA, 13, 14},
	{0x69CB, 13, 14},
	{0x69CC,  8, 13},
	{0x69CD, 13, 14},
	{0x69CE, 12, 14},
	{0x69D0, 12, 14},
	{0x69D3, 13, 14},
	{0x69D8,  9, 15},
	{0x69D9, 13, 14},
	{0x69DD, 12, 14},
	{0x69DE, 13, 14},
	{0x69E7, 14, 15},
	{0x69E8, 12, 14},
	{0x69EB, 15, 16},
	{0x69ED, 15, 15},
	{0x69F2, 15, 15},
	{0x69F9, 14, 15},
	{0x69FB, 12, 15},
	{0x69FD, 14, 16},
	{0x69FF, 14, 15},
	{0x6A02, 11, 14},
	{0x6A05, 15, 15},
	{0x6A0A, 15, 15},
	{0x6A0B, 11, 14},
	{0x6A0C, 14, 16},
	{0x6A12, 14, 15},
	{0x6A13, 14, 15},
	{0x6A14, 15, 15},
	{0x6A17, 14, 15},
	{0x6A19, 13, 15},
	{0x6A1B, 15, 15},
	{0x6A1E,  6, 16},
	{0x6A1F, 14, 15},
	{0x6A21, 13, 14},
	{0x6A22, 14, 15},
	{0x6A23, 13, 15},
	{0x6A29, 12, 15},
	{0x6A2A, 13, 15},
	{0x6A2B, 13, 16},
	{0x6A2E, 13, 14},
	{0x6A35, 14, 16},
	{0x6A36, 16, 16},
	{0x6A38, 16, 16},
	{0x6A39, 12, 16},
	{0x6A3A, 13, 14},
	{0x6A3D, 15, 16},
	{0x6A44, 15, 16},
	{0x6A47, 13, 16},
	{0x6A48, 14, 16},
	{0x6A4B, 11, 16},
	{0x6A58, 14, 16},
	{0x6A59, 13, 16},
	{0x6A5F, 11, 16},
	{0x6A61, 13, 16},
	{0x6A62, 14, 15},
	{0x6A66, 14, 16},
	{0x6A72, 12, 16},
	{0x6A78, 16, 16},
	{0x6A7F, 16, 17},
	{0x6A80, 15, 17},
	{0x6A84, 14, 17},
	{0x6A8D, 16, 17},
	{0x6A8E, 15, 17},
	{0x6A90, 15, 17},
	{0x6A97, 15, 17},
	{0x6A9C, 17, 17},
	{0x6AA0, 13, 16},
	{0x6AA2, 13, 17},
	{0x6AA3, 13, 17},
	{0x6AAA, 15, 17},
	{0x6AAC, 15, 17},
	{0x6AAE, 16, 18},
	//{0x6AB3,  0,  0},
	{0x6AB8, 16, 18},
	{0x6ABB, 16, 19},
	{0x6AC1, 18, 18},
	{0x6AC2, 17, 18},
	{0x6AC3, 16, 19},	// Min 10 per Noriko
	{0x6AD1, 18, 19},
	{0x6AD3, 18, 19},
	{0x6ADA, 14, 19},
	{0x6ADB, 14, 17},
	{0x6ADE, 16, 18},
	{0x6ADF, 14, 18},
	{0x6AE8, 19, 20},
	{0x6AEA, 17, 20},
	{0x6AFA, 19, 21},
	{0x6AFB, 18, 21},
	{0x6B04, 15, 21},
	{0x6B05, 19, 20},
	{0x6B0A, 17, 21},
	{0x6B12, 19, 23},
	{0x6B16, 25, 25},
	{0x6B1D, 23, 25},
	{0x6B1F, 24, 27},
	{0x6B20,  3,  4},
	{0x6B21,  5,  6},
	{0x6B23,  6,  8},
	{0x6B27,  7,  9},
	{0x6B32,  8, 11},
	{0x6B37, 10, 11},
	{0x6B38, 10, 11},
	{0x6B39,  9, 12},
	{0x6B3A, 11, 12},
	{0x6B3D, 10, 12},
	{0x6B3E, 10, 12},
	{0x6B43, 12, 12},
	{0x6B47, 13, 14},
	{0x6B49, 13, 14},
	{0x6B4C,  9, 14},
	{0x6B4E, 13, 15},
	{0x6B50, 12, 15},
	{0x6B53, 13, 15},
	{0x6B54, 14, 15},
	{0x6B59, 14, 16},
	{0x6B5B, 13, 17},
	{0x6B5F, 15, 16},
	{0x6B61, 18, 21},
	{0x6B62,  3,  4},
	{0x6B63,  4,  5},
	{0x6B64,  5,  6},
	{0x6B66,  6,  8},
	{0x6B69,  7,  8},
	{0x6B6A,  7,  9},
	{0x6B6F, 10, 13},
	{0x6B73, 12, 14},
	{0x6B74, 12, 14},
	{0x6B78, 16, 18},
	{0x6B79,  4,  4},
	{0x6B7B,  5,  6},
	{0x6B7F,  8,  8},
	{0x6B80,  8,  8},
	{0x6B83,  8,  9},
	{0x6B84,  8,  9},
	{0x6B86,  6,  9},
	{0x6B89,  8, 10},
	{0x6B8A,  8, 10},
	{0x6B8B,  8, 10},
	{0x6B8D,  9, 11},
	{0x6B95, 10, 12},
	{0x6B96, 10, 12},
	{0x6B98, 10, 12},
	{0x6B9E, 10, 14},
	{0x6BA4, 12, 15},
	{0x6BAA, 11, 16},
	{0x6BAB, 13, 16},
	{0x6BAF, 18, 18},
	{0x6BB1, 18, 19},
	{0x6BB2, 19, 21},
	{0x6BB3,  4,  4},
	{0x6BB4,  8,  9},
	{0x6BB5,  7,  9},
	{0x6BB7,  9, 10},
	{0x6BBA,  9, 10},
	{0x6BBB, 10, 12},
	{0x6BBC, 11, 12},
	{0x6BBF, 11, 13},
	{0x6BC0, 11, 12},
	{0x6BC5, 13, 15},
	{0x6BC6, 11, 11},
	{0x6BCB,  4,  4},
	{0x6BCD,  4,  6},
	{0x6BCE,  5,  7},
	{0x6BD2,  8,  9},
	{0x6BD3, 12, 14},
	{0x6BD4,  4,  5},
	{0x6BD8,  8, 10},
	{0x6BDB,  3,  4},
	{0x6BDF,  7,  8},
	{0x6BEB,  9, 11},
	{0x6BEC,  9, 11},
	{0x6BEF, 11, 12},
	{0x6BF3,  9, 12},
	{0x6C08, 14, 17},
	{0x6C0F,  2,  4},
	{0x6C11,  3,  5},
	{0x6C13,  7,  8},
	{0x6C14,  4,  4},
	{0x6C17,  5,  6},
	{0x6C1B,  8,  8},
	{0x6C23,  9, 11},
	{0x6C24,  9, 10},
	{0x6C34,  3,  4},
	{0x6C37,  4,  5},
	{0x6C38,  4,  6},
	{0x6C3E,  5,  5},
	{0x6C40,  4,  5},
	{0x6C41,  4,  5},
	{0x6C42,  5,  7},
	{0x6C4E,  6,  6},
	{0x6C50,  5,  6},
	{0x6C55,  6,  6},
	{0x6C57,  6,  6},
	{0x6C5A,  6,  6},
	{0x6C5D,  6,  6},
	{0x6C5E,  6,  7},
	{0x6C5F,  5,  6},
	{0x6C60,  5,  6},
	{0x6C62,  5,  6},
	{0x6C68,  7,  7},
	{0x6C6A,  7,  7},
	{0x6C70,  6,  7},
	{0x6C72,  6,  7},
	{0x6C73,  7,  7},
	{0x6C7A,  6,  7},
	{0x6C7D,  6,  7},
	{0x6C7E,  7,  7},
	{0x6C81,  7,  7},
	{0x6C82,  6,  7},
	{0x6C83,  6,  7},
	{0x6C88,  6,  7},
	{0x6C8C,  6,  7},
	{0x6C8D,  7,  7},
	{0x6C90,  7,  7},
	{0x6C92,  7,  7},
	{0x6C93,  7,  8},
	{0x6C96,  6,  7},
	{0x6C99,  6,  7},
	{0x6C9A,  6,  7},
	{0x6C9B,  7,  8},
	{0x6CA1,  6,  7},
	{0x6CA2,  6,  7},
	{0x6CAB,  8,  8},
	{0x6CAE,  8,  8},
	{0x6CB1,  7,  8},
	{0x6CB3,  6,  8},
	{0x6CB8,  6,  8},
	{0x6CB9,  7,  8},
	{0x6CBA,  7,  8},
	{0x6CBB,  5,  8},
	{0x6CBC,  7,  8},
	{0x6CBD,  7,  8},
	{0x6CBE,  7,  8},
	{0x6CBF,  7,  8},
	{0x6CC1,  6,  8},
	{0x6CC4,  6,  8},
	{0x6CC5,  8,  8},
	{0x6CC9,  6,  9},
	{0x6CCA,  6,  8},
	{0x6CCC,  7,  8},
	{0x6CD3,  7,  8},
	{0x6CD5,  6,  8},
	{0x6CD7,  8,  8},
	{0x6CD9,  7,  8},
	{0x6CDB,  6,  7},
	{0x6CDD,  7,  8},
	{0x6CE1,  6,  8},
	{0x6CE2,  7,  8},
	{0x6CE3,  7,  8},
	{0x6CE5,  7,  8},
	{0x6CE8,  7,  8},
	{0x6CEA,  8,  8},
	{0x6CEF,  7,  8},
	{0x6CF0,  8, 10},
	{0x6CF1,  8,  8},
	{0x6CF3,  7,  8},
	{0x6D0B,  8,  9},
	{0x6D0C,  7,  9},
	{0x6D12,  9, 10},
	{0x6D17,  7,  9},
	{0x6D19,  8,  9},
	{0x6D1B,  8,  9},
	{0x6D1E,  7,  9},
	{0x6D1F,  9,  9},
	{0x6D25,  8,  9},
	{0x6D29,  9, 10},
	{0x6D2A,  8,  9},
	{0x6D2B,  8,  9},
	{0x6D32,  9,  9},
	{0x6D33,  9,  9},
	{0x6D35,  7,  9},
	{0x6D36,  8,  9},
	{0x6D38,  7, 10},
	{0x6D3B,  6,  9},
	{0x6D3D,  8,  9},
	{0x6D3E,  6,  9},
	{0x6D41,  8, 10},
	{0x6D44,  8,  9},
	{0x6D45,  9,  9},
	{0x6D59,  9, 10},
	{0x6D5A,  9, 10},
	{0x6D5C,  8, 10},
	{0x6D63,  9, 10},
	{0x6D64,  9, 10},
	{0x6D66,  9, 10},
	{0x6D69,  8, 10},
	{0x6D6A,  8, 10},
	{0x6D6C, 10, 10},
	{0x6D6E,  8, 10},
	{0x6D74,  8, 10},
	{0x6D77,  8, 10},
	{0x6D78, 10, 10},
	{0x6D79, 10, 10},
	{0x6D85, 10, 10},
	{0x6D88,  9, 10},
	{0x6D8C,  9, 10},
	{0x6D8E,  9, 10},
	{0x6D93,  9, 10},
	{0x6D95,  9, 10},
	{0x6D99,  8, 10},
	{0x6D9B,  9, 11},
	{0x6D9C,  9, 10},
	{0x6DAF,  9, 11},
	{0x6DB2,  9, 11},
	{0x6DB5, 10, 11},
	{0x6DB8,  9, 11},
	{0x6DBC,  9, 11},
	{0x6DC0, 10, 11},
	{0x6DC5, 10, 11},
	{0x6DC6, 11, 12},
	{0x6DC7, 11, 11},
	{0x6DCB, 10, 11},
	{0x6DCC, 10, 11},
	{0x6DD1, 11, 12},
	{0x6DD2, 11, 11},
	{0x6DD5, 11, 11},
	{0x6DD8, 10, 11},
	{0x6DD9, 11, 11},
	{0x6DDE, 10, 11},
	{0x6DE1, 11, 11},
	{0x6DE4, 10, 11},
	{0x6DE6, 10, 11},
	{0x6DE8, 10, 11},
	{0x6DEA, 11, 12},
	{0x6DEB, 10, 11},
	{0x6DEC, 10, 11},
	{0x6DEE,  9, 11},
	{0x6DF1, 10, 11},
	{0x6DF3,  9, 11},
	{0x6DF5, 10, 12},
	{0x6DF7,  9, 12},
	{0x6DF9, 11, 11},
	{0x6DFA, 11, 11},
	{0x6DFB,  9, 11},
	{0x6E05,  9, 11},
	{0x6E07,  9, 11},
	{0x6E08,  9, 11},
	{0x6E09, 10, 11},
	{0x6E0A, 10, 11},
	{0x6E0B,  8, 11},
	{0x6E13, 11, 12},
	{0x6E15, 10, 11},
	{0x6E19, 12, 12},
	{0x6E1A, 11, 12},
	{0x6E1B,  9, 12},
	{0x6E1D, 11, 12},
	{0x6E1F, 10, 12},
	{0x6E20, 11, 12},
	{0x6E21, 10, 12},
	{0x6E23, 12, 12},
	{0x6E24, 11, 12},
	{0x6E25,  9, 12},
	{0x6E26, 10, 12},
	{0x6E29, 11, 12},
	{0x6E2B, 11, 12},
	{0x6E2C, 10, 12},
	{0x6E2D, 12, 12},
	{0x6E2E,  9, 11},
	{0x6E2F, 10, 12},
	{0x6E38, 11, 11},
	{0x6E3A, 11, 12},
	{0x6E3E, 12, 12},
	{0x6E43, 12, 12},
	{0x6E4A, 12, 12},
	{0x6E4D, 10, 12},
	{0x6E4E, 11, 12},
	{0x6E56, 10, 12},
	{0x6E58, 12, 12},
	{0x6E5B, 12, 13},
	{0x6E5F, 11, 12},
	{0x6E67, 11, 12},
	{0x6E6B, 11, 12},
	{0x6E6E, 10, 12},
	{0x6E6F,  9, 12},
	{0x6E72, 11, 13},
	{0x6E76, 10, 12},
	{0x6E7E, 10, 13},
	{0x6E7F, 11, 12},
	{0x6E80, 10, 12},
	{0x6E82, 11, 12},
	{0x6E8C, 11, 12},
	{0x6E8F, 12, 13},
	{0x6E90, 12, 13},
	{0x6E96, 10, 13},
	{0x6E98, 12, 13},
	{0x6E9C,  9, 13},
	{0x6E9D, 12, 13},
	{0x6E9F, 13, 14},
	{0x6EA2, 12, 14},
	{0x6EA5, 13, 13},
	{0x6EAA, 11, 13},
	{0x6EAF, 11, 13},
	{0x6EB2, 12, 13},
	{0x6EB6, 10, 13},
	{0x6EB7, 11, 13},
	{0x6EBA,  9, 13},
	{0x6EBD, 12, 13},
	{0x6EC2, 12, 13},
	{0x6EC4, 12, 13},
	{0x6EC5, 12, 13},
	{0x6EC9, 11, 13},
	{0x6ECB,  8, 12},
	{0x6ECC, 12, 14},
	{0x6ED1, 12, 13},
	{0x6ED3, 12, 13},
	{0x6ED4, 11, 13},
	{0x6ED5, 13, 15},
	{0x6EDD, 12, 13},
	{0x6EDE, 10, 13},
	{0x6EEC, 13, 14},
	{0x6EEF, 12, 14},
	{0x6EF2, 12, 14},
	{0x6EF4, 10, 14},
	{0x6EF7, 14, 14},
	{0x6EF8, 13, 14},
	{0x6EFE, 12, 14},
	{0x6EFF, 13, 14},
	{0x6F01, 13, 14},
	{0x6F02, 12, 14},
	{0x6F06, 13, 14},
	{0x6F09, 13, 15},
	{0x6F0F, 13, 15},
	{0x6F11, 13, 15},
	{0x6F13, 12, 14},
	{0x6F14, 12, 14},
	{0x6F15, 14, 15},
	{0x6F20, 13, 13},
	{0x6F22, 12, 14},
	{0x6F23, 12, 13},
	{0x6F2B, 11, 14},
	{0x6F2C,  9, 14},
	{0x6F31, 11, 14},
	{0x6F32, 12, 14},
	{0x6F38, 13, 14},
	{0x6F3E, 12, 14},
	{0x6F3F, 14, 15},
	{0x6F41, 12, 15},
	{0x6F45, 12, 14},
	{0x6F54, 12, 15},
	{0x6F58, 13, 15},
	{0x6F5B, 17, 17},
	{0x6F5C, 14, 15},
	{0x6F5F, 13, 16},
	{0x6F64, 14, 15},
	{0x6F66, 15, 15},
	{0x6F6D, 15, 15},
	{0x6F6E, 13, 15},
	{0x6F6F, 14, 15},
	{0x6F70,  8, 16},
	{0x6F74, 14, 15},
	{0x6F78, 15, 16},
	{0x6F7A, 12, 15},
	{0x6F7C, 14, 15},
	{0x6F80, 16, 17},
	{0x6F81, 12, 15},
	{0x6F82, 13, 15},
	{0x6F84, 13, 15},
	{0x6F86, 15, 15},
	{0x6F8E, 13, 15},
	{0x6F91, 14, 15},
	{0x6F97, 14, 15},
	{0x6FA1, 13, 16},
	{0x6FA3, 16, 16},
	{0x6FA4, 14, 16},
	{0x6FAA, 16, 16},
	{0x6FB1, 14, 16},
	{0x6FB3, 14, 16},
	{0x6FB9, 14, 17},
	{0x6FC0, 13, 16},
	{0x6FC1, 13, 16},
	{0x6FC2, 15, 16},
	{0x6FC3, 13, 16},
	{0x6FC6, 14, 15},
	{0x6FD4, 17, 17},
	{0x6FD5, 13, 17},
	{0x6FD8, 16, 17},
	{0x6FDB, 14, 16},
	{0x6FDF, 15, 16},
	{0x6FE0, 14, 17},
	{0x6FE1, 16, 17},
	{0x6FE4, 15, 17},
	{0x6FEB, 15, 18},
	{0x6FEC, 17, 18},
	{0x6FEE, 16, 17},
	{0x6FEF, 15, 17},
	{0x6FF1, 17, 17},
	{0x6FF3, 17, 19},
	{0x6FF6, 14, 17},
	{0x6FFA, 17, 18},
	{0x6FFE, 16, 18},
	{0x7001, 16, 19},
	{0x7009, 17, 17},
	{0x700B, 17, 18},
	{0x700F, 15, 18},
	{0x7011, 16, 18},
	{0x7015, 16, 20},
	{0x7018, 18, 19},
	{0x701A, 19, 19},
	{0x701B, 18, 19},
	{0x701D, 17, 19},
	{0x701E, 16, 17},
	{0x701F, 17, 19},
	{0x7026, 16, 19},
	{0x7027, 17, 20},
	{0x702C, 14, 19},
	{0x7030, 20, 20},
	{0x7032, 19, 19},
	{0x703E, 19, 20},
	{0x704C, 15, 20},
	{0x7051, 21, 24},
	{0x7058, 19, 21},
	{0x7063, 16, 25},
	{0x706B,  4,  4},
	{0x706F,  5,  6},
	{0x7070,  6,  6},
	{0x7078,  6,  7},
	{0x707C,  6,  7},
	{0x707D,  7,  7},
	{0x7089,  7,  8},
	{0x708A,  7,  8},
	{0x708E,  8,  8},
	{0x7092,  8,  8},
	{0x7099,  7,  8},
	{0x70AC,  8,  9},
	{0x70AD,  8,  9},
	{0x70AE,  8,  9},
	{0x70AF,  8,  9},
	{0x70B3,  9,  9},
	{0x70B8,  8,  9},
	{0x70B9,  7,  9},
	{0x70BA,  6, 10},
	{0x70C8,  8, 10},
	{0x70CB, 10, 10},
	{0x70CF,  8, 10},
	{0x70D9,  9, 10},
	{0x70DD,  8, 10},
	{0x70DF, 10, 10},
	{0x70F1,  9, 11},
	{0x70F9,  9, 11},
	{0x70FD, 10, 11},
	{0x7109, 11, 11},
	{0x7114, 10, 11},
	{0x7119, 11, 12},
	{0x711A, 11, 12},
	{0x711C, 12, 13},
	{0x7121, 11, 12},
	{0x7126, 10, 12},
	{0x7136, 11, 12},
	{0x713C, 11, 12},
	{0x7149, 12, 12},
	{0x714C, 12, 13},
	{0x714E, 13, 13},
	{0x7155, 12, 15},
	{0x7156, 12, 13},
	{0x7159, 11, 13},
	{0x7162, 13, 13},
	{0x7164, 12, 13},
	{0x7165, 12, 13},
	{0x7166, 11, 13},
	{0x7167, 11, 13},
	{0x7169, 10, 13},
	{0x716C, 12, 13},
	{0x716E,  9, 12},
	{0x717D, 13, 14},
	{0x7184, 12, 14},
	{0x7188, 14, 15},
	{0x718A, 12, 14},
	{0x718F, 14, 15},
	{0x7194, 13, 14},
	{0x7195, 13, 14},
	{0x7199, 10, 15},
	{0x719F,  9, 15},
	{0x71A8, 14, 15},
	{0x71AC, 14, 15},
	{0x71B1, 12, 15},
	{0x71B9, 14, 16},
	{0x71BE, 14, 16},
	{0x71C3, 11, 16},
	{0x71C8, 12, 16},
	{0x71C9, 14, 16},
	{0x71CE, 15, 16},
	{0x71D0, 13, 17},
	{0x71D2, 14, 17},
	{0x71D4, 15, 16},
	{0x71D5, 14, 17},
	{0x71D7, 16, 16},
	{0x71DF, 15, 17},
	{0x71E0, 15, 17},
	{0x71E5, 13, 17},
	{0x71E6, 16, 17},
	{0x71E7, 14, 16},
	{0x71EC, 15, 17},
	{0x71ED, 14, 17},
	{0x71EE, 15, 17},
	{0x71F5, 15, 16},
	{0x71F9, 15, 18},
	{0x71FB, 17, 18},
	{0x71FC, 18, 19},
	{0x71FF, 16, 18},
	{0x7206, 15, 19},
	{0x720D, 16, 19},
	{0x7210, 19, 20},
	{0x721B, 19, 21},
	{0x7228, 29, 29},
	{0x722A,  3,  4},
	{0x722C,  7,  8},
	{0x722D,  7,  8},
	{0x7230,  8,  9},
	{0x7232, 11, 12},
	{0x7235, 14, 18},
	{0x7236,  4,  4},
	{0x723A, 11, 12},
	{0x723B,  4,  4},
	{0x723C,  9,  9},
	{0x723D, 11, 12},
	{0x723E, 14, 15},
	{0x723F,  4,  4},
	{0x7240,  7,  8},
	{0x7246, 16, 17},
	{0x7247,  4,  5},
	{0x7248,  7,  8},
	{0x724B, 11, 12},
	{0x724C, 11, 13},
	{0x7252, 12, 14},
	{0x7258, 18, 19},
	{0x7259,  3,  5},
	{0x725B,  3,  4},
	{0x725D,  3,  6},
	{0x725F,  4,  6},
	{0x7261,  5,  7},
	{0x7262,  6,  7},
	{0x7267,  5,  8},
	{0x7269,  6,  8},
	{0x7272,  6,  9},
	{0x7274,  8,  9},
	{0x7279,  8, 10},
	{0x727D, 10, 13},
	{0x727E, 10, 11},
	{0x7280, 11, 12},
	{0x7281, 10, 11},
	{0x7282, 12, 12},
	{0x7287, 12, 12},
	{0x7292, 12, 14},
	{0x7296, 14, 14},
	{0x72A0, 15, 17},
	{0x72A2, 18, 20},
	{0x72A7, 19, 20},
	{0x72AC,  4,  4},
	{0x72AF,  4,  5},
	{0x72B2,  6,  6},
	{0x72B6,  7,  7},
	{0x72B9,  7,  7},
	{0x72C2,  6,  7},
	{0x72C3,  7,  7},
	{0x72C4,  7,  7},
	{0x72C6,  6,  7},
	{0x72CE,  8,  8},
	{0x72D0,  6,  9},
	{0x72D2,  7,  8},
	{0x72D7,  6,  8},
	{0x72D9,  8,  8},
	{0x72DB,  7,  8},
	{0x72E0,  8,  9},
	{0x72E1,  9,  9},
	{0x72E2,  8,  9},
	{0x72E9,  7,  9},
	{0x72EC,  6,  9},
	{0x72ED,  7,  9},
	{0x72F7,  9, 10},
	{0x72F8, 10, 10},
	{0x72F9,  9, 10},
	{0x72FC,  8, 10},
	{0x72FD,  9, 11},
	{0x730A, 10, 11},
	{0x7316, 11, 11},
	{0x7317,  9, 11},
	{0x731B,  8, 11},
	{0x731C, 11, 11},
	{0x731D, 11, 11},
	{0x731F, 10, 11},
	{0x7325, 12, 12},
	{0x7329, 11, 12},
	{0x732A, 10, 11},
	{0x732B, 10, 11},
	{0x732E, 11, 13},
	{0x732F, 10, 12},
	{0x7334, 11, 12},
	{0x7336, 11, 12},
	{0x7337, 13, 14},
	{0x733E, 12, 13},
	{0x733F,  9, 13},
	{0x7344, 11, 14},
	{0x7345, 11, 13},
	{0x734E, 13, 15},
	{0x734F, 13, 13},
	{0x7357, 13, 15},
	{0x7363, 14, 16},
	{0x7368, 13, 16},
	{0x736A, 15, 16},
	{0x7370, 17, 17},
	{0x7372, 14, 16},
	{0x7375, 20, 20},
	{0x7378, 13, 19},
	{0x737A, 17, 19},
	{0x737B, 19, 20},
	{0x7384,  3,  5},
	{0x7387,  7, 11},
	{0x7389,  4,  5},
	{0x738B,  3,  4},
	{0x7396,  6,  7},
	{0x73A9,  7,  8},
	{0x73B2,  8,  9},
	{0x73B3,  9,  9},
	{0x73BB,  8,  9},
	{0x73C0,  8,  9},
	{0x73C2,  7,  9},
	{0x73C8,  8,  9},
	{0x73CA,  9,  9},
	{0x73CD,  8,  9},
	{0x73CE,  8,  9},
	{0x73DE,  8, 10},
	{0x73E0,  7, 10},
	{0x73E5, 10, 10},
	{0x73EA,  8, 10},
	{0x73ED,  9, 10},
	{0x73EE, 10, 10},
	{0x73F1, 10, 10},
	{0x73F8, 10, 11},
	{0x73FE,  9, 11},
	{0x7403,  8, 11},
	{0x7405, 10, 11},
	{0x7406, 10, 11},
	{0x7409,  9, 11},
	{0x7422,  8, 11},
	{0x7425, 12, 12},
	{0x7432, 12, 12},
	{0x7433, 11, 12},
	{0x7434, 12, 12},
	{0x7435, 11, 13},
	{0x7436, 11, 12},
	{0x743A, 10, 12},
	{0x743F, 13, 13},
	{0x7441, 13, 13},
	{0x7455, 12, 13},
	{0x7459, 12, 13},
	{0x745A, 11, 13},
	{0x745B, 11, 12},
	{0x745C, 13, 13},
	{0x745E, 10, 13},
	{0x745F, 13, 13},
	{0x7460, 11, 14},
	{0x7463, 13, 14},
	{0x7464, 13, 14},
	{0x7469, 15, 16},
	{0x746A, 11, 14},
	{0x746F, 10, 13},
	{0x7470, 12, 14},
	{0x7473, 12, 14},
	{0x7476, 12, 13},
	{0x747E, 13, 15},
	{0x7483, 13, 15},
	{0x748B, 14, 15},
	{0x749E, 16, 16},
	{0x74A2, 15, 16},
	{0x74A7, 16, 18},
	{0x74B0, 12, 17},
	{0x74BD, 18, 19},
	{0x74CA, 17, 17},
	{0x74CF, 19, 20},
	{0x74D4, 19, 21},
	{0x74DC,  3,  6},
	{0x74E0, 11, 12},
	{0x74E2, 13, 17},
	{0x74E3, 19, 20},
	{0x74E6,  4,  5},
	{0x74E7,  6,  7},
	{0x74E9,  7,  8},
	{0x74EE,  8,  9},
	{0x74F0,  8,  9},
	{0x74F1,  8,  9},
	{0x74F2,  8,  9},
	{0x74F6,  9, 12},
	{0x74F7, 10, 11},
	{0x74F8, 10, 11},
	{0x7503, 13, 14},
	{0x7504, 13, 14},
	{0x7505, 13, 15},
	{0x750C,  8, 16},
	{0x750D, 15, 15},
	{0x750E, 14, 16},
	{0x7511, 15, 16},
	{0x7513, 16, 18},
	{0x7515, 16, 18},
	{0x7518,  4,  5},
	{0x751A,  9,  9},
	{0x751C,  9, 11},
	{0x751E, 12, 13},
	{0x751F,  4,  5},
	{0x7523,  9, 11},
	{0x7525, 10, 12},
	{0x7526, 11, 12},
	{0x7528,  4,  5},
	{0x752B,  7,  7},
	{0x752C,  6,  7},
	{0x7530,  4,  5},
	{0x7531,  4,  5},
	{0x7532,  4,  5},
	{0x7533,  5,  5},
	{0x7537,  6,  7},
	{0x7538,  6,  7},
	{0x753A,  6,  7},
	{0x753B,  7,  8},
	{0x753C,  7,  7},
	{0x7544,  8,  8},
	{0x7546,  8,  9},
	{0x7549,  8,  9},
	{0x754A,  9,  9},
	{0x754B,  8,  9},
	{0x754C,  8,  9},
	{0x754D,  9, 10},
	{0x754F,  7, 10},
	{0x7551,  8,  9},
	{0x7554,  9, 10},
	{0x7559,  7, 10},
	{0x755A,  9, 10},
	{0x755B,  9, 10},
	{0x755C,  8, 10},
	{0x755D,  9, 10},
	{0x7560,  8, 10},
	{0x7562, 10, 12},
	{0x7564, 11, 11},
	{0x7565,  7, 11},
	{0x7566,  9, 11},
	{0x7567, 10, 11},
	{0x7569, 11, 11},
	{0x756A,  9, 12},
	{0x756B, 12, 13},
	{0x756D, 12, 12},
	{0x7570, 10, 11},
	{0x7573, 11, 12},
	{0x7574, 11, 12},
	{0x7576, 12, 13},
	{0x7577, 12, 13},
	{0x7578, 11, 13},
	{0x757F, 10, 15},
	{0x7582, 15, 16},
	{0x7586, 18, 19},
	{0x7587, 18, 19},
	{0x7589, 22, 22},
	{0x758A, 20, 22},
	{0x758B,  5,  5},
	{0x758E,  9, 12},
	{0x758F,  8, 12},
	{0x7591, 10, 14},
	{0x7594,  7,  7},
	{0x759A,  7,  8},
	{0x759D,  7,  8},
	{0x75A3,  9,  9},
	{0x75A5,  9,  9},
	{0x75AB,  9,  9},
	{0x75B1,  9, 10},
	{0x75B2,  8, 10},
	{0x75B3,  9, 11},
	{0x75B5, 10, 11},
	{0x75B8, 10, 10},
	{0x75B9, 10, 10},
	{0x75BC,  9, 10},
	{0x75BD, 10, 10},
	{0x75BE,  9, 10},
	{0x75C2,  9, 10},
	{0x75C3,  9, 10},
	{0x75C5,  9, 10},
	{0x75C7,  9, 10},
	{0x75CA, 11, 11},
	{0x75CD, 11, 11},
	{0x75D2, 10, 11},
	{0x75D4, 11, 11},
	{0x75D5,  9, 11},
	{0x75D8, 10, 12},
	{0x75D9, 11, 12},
	{0x75DB, 10, 12},
	{0x75DE, 11, 12},
	{0x75E2, 11, 12},
	{0x75E3, 12, 12},
	{0x75E9, 12, 14},
	{0x75F0, 13, 13},
	{0x75F2, 13, 14},
	{0x75F3, 13, 13},
	{0x75F4, 11, 13},
	{0x75FA, 13, 14},
	{0x75FC, 10, 13},
	{0x75FE,  9, 12},
	{0x75FF, 12, 13},
	{0x7601, 13, 13},
	{0x7609, 14, 14},
	{0x760B, 12, 14},
	{0x760D, 13, 14},
	{0x761F, 15, 15},
	{0x7620, 15, 15},
	{0x7621, 13, 15},
	{0x7622, 13, 15},
	{0x7624, 13, 15},
	{0x7627, 14, 15},
	{0x7630, 14, 16},
	{0x7634, 15, 16},
	{0x763B, 16, 16},
	{0x7642, 16, 17},
	{0x7646, 17, 17},
	{0x7647, 17, 17},
	{0x7648, 15, 17},
	{0x764C, 13, 17},
	{0x7652, 17, 18},
	{0x7656, 14, 18},
	{0x7658, 17, 17},
	{0x765C, 17, 18},
	{0x7661, 19, 19},
	{0x7662, 16, 20},
	{0x7667, 18, 21},
	{0x7668, 19, 21},
	{0x7669, 20, 21},
	{0x766A, 19, 21},
	{0x766C, 21, 22},
	{0x7670, 19, 23},
	{0x7672, 22, 23},
	{0x7676,  5,  5},
	{0x7678,  9,  9},
	{0x767A,  8,  9},
	{0x767B,  9, 12},
	{0x767C, 11, 12},
	{0x767D,  4,  5},
	{0x767E,  4,  6},
	{0x7680,  6,  7},
	{0x7683,  6,  7},
	{0x7684,  5,  8},
	{0x7686,  7, 10},
	{0x7687,  6,  9},
	{0x7688,  8,  9},
	{0x768B,  9, 10},
	{0x768E, 10, 11},
	{0x7690, 10, 11},
	{0x7693, 10, 12},
	{0x7696, 10, 12},
	{0x7699, 11, 13},
	{0x769A, 12, 15},
	{0x76AE,  4,  5},
	{0x76B0,  8, 10},
	{0x76B4, 11, 12},
	{0x76B7, 12, 14},
	{0x76B8, 13, 14},
	{0x76B9, 13, 14},
	{0x76BA, 14, 15},
	{0x76BF,  5,  5},
	{0x76C2,  8,  8},
	{0x76C3,  8,  9},
	{0x76C6,  8,  9},
	{0x76C8,  9, 10},
	{0x76CA,  8, 10},
	{0x76CD,  9, 10},
	{0x76D2,  9, 11},
	{0x76D6, 10, 11},
	{0x76D7, 10, 11},
	{0x76DB, 10, 11},
	{0x76DC, 11, 12},
	{0x76DE, 13, 13},
	{0x76DF, 11, 13},
	{0x76E1, 14, 15},
	{0x76E3, 13, 16},
	{0x76E4, 13, 15},
	{0x76E5, 14, 15},
	{0x76E7, 16, 16},
	{0x76EA, 16, 17},
	{0x76EE,  5,  5},
	{0x76F2,  8,  8},
	{0x76F4,  7,  8},
	{0x76F8,  8,  9},
	{0x76FB,  9,  9},
	{0x76FE,  6,  9},
	{0x7701,  8,  9},
	{0x7704,  9, 10},
	{0x7707,  9,  9},
	{0x7708,  9,  9},
	{0x7709,  8,  9},
	{0x770B,  8,  9},
	{0x770C,  8, 10},
	{0x771B, 10, 10},
	{0x771E,  9, 10},
	{0x771F,  9, 10},
	{0x7720,  9, 10},
	{0x7724,  9, 10},
	{0x7725, 10, 11},
	{0x7726, 10, 11},
	{0x7729,  9, 10},
	{0x7737, 11, 11},
	{0x7738, 10, 11},
	{0x773A, 10, 11},
	{0x773C,  9, 11},
	{0x7740, 10, 12},
	{0x7747, 11, 12},
	{0x775A, 12, 14},
	{0x775B, 13, 13},
	{0x7761, 11, 14},
	{0x7763, 12, 13},
	{0x7765, 12, 14},
	{0x7766, 11, 13},
	{0x7768, 11, 13},
	{0x776B, 13, 13},
	{0x7779, 13, 14},
	{0x777E, 12, 14},
	{0x777F, 14, 14},
	{0x778B, 15, 15},
	{0x778E, 14, 15},
	{0x7791, 14, 15},
	{0x779E, 15, 16},
	{0x77A0, 14, 16},
	{0x77A5, 14, 17},
	{0x77AC, 15, 18},
	{0x77AD, 17, 17},
	{0x77B0, 16, 17},
	{0x77B3, 15, 17},
	{0x77B6, 16, 17},
	{0x77B9, 16, 18},
	{0x77BB, 17, 18},
	{0x77BC, 14, 18},
	{0x77BD, 17, 18},
	{0x77BF, 17, 18},
	{0x77C7, 16, 18},
	{0x77CD, 18, 20},
	{0x77D7, 23, 24},
	{0x77DA, 24, 26},
	{0x77DB,  2,  5},
	{0x77DC,  7,  9},
	{0x77E2,  4,  5},
	{0x77E3,  6,  7},
	{0x77E5,  6,  8},
	{0x77E7,  7,  9},
	{0x77E9,  8, 10},
	{0x77ED,  8, 12},
	{0x77EE, 12, 13},
	{0x77EF, 13, 17},
	{0x77F3,  3,  5},
	{0x77FC,  7,  8},
	{0x7802,  6,  9},
	{0x780C,  7,  9},
	{0x7812,  8, 10},
	{0x7814,  7,  9},
	{0x7815,  7,  9},
	{0x7820,  9, 10},
	{0x7825,  8, 10},
	{0x7826,  9, 11},
	{0x7827,  8, 10},
	{0x7832,  5, 10},
	{0x7834,  7, 10},
	{0x783A,  8, 10},
	{0x783F,  7, 10},
	{0x7845, 10, 11},
	{0x785D, 10, 12},
	{0x786B,  8, 12},
	{0x786C,  9, 12},
	{0x786F, 10, 12},
	{0x7872, 10, 12},
	{0x7874, 11, 12},
	{0x787C, 11, 13},
	{0x7881, 11, 13},
	{0x7886, 12, 13},
	{0x7887,  9, 13},
	{0x788C, 10, 13},
	{0x788D, 11, 13},
	{0x788E, 10, 13},
	{0x7891, 10, 14},
	{0x7893, 10, 13},
	{0x7895,  9, 13},
	{0x7897, 10, 13},
	{0x789A, 10, 13},
	{0x78A3, 13, 14},
	{0x78A7, 11, 14},
	{0x78A9, 11, 14},
	{0x78AA, 13, 14},
	{0x78AF, 12, 14},
	{0x78B5, 13, 14},
	{0x78BA, 11, 15},
	{0x78BC, 14, 15},
	{0x78BE, 15, 15},
	{0x78C1,  9, 14},
	{0x78C5, 14, 15},
	{0x78C6, 13, 15},
	{0x78CA, 12, 15},
	{0x78CB, 12, 15},
	{0x78D0, 13, 15},
	{0x78D1, 12, 15},
	{0x78D4, 14, 16},
	{0x78DA, 16, 16},
	{0x78E7, 14, 16},
	{0x78E8, 14, 16},
	{0x78EC, 14, 16},
	{0x78EF, 11, 17},
	{0x78F4, 13, 17},
	{0x78FD, 15, 17},
	{0x7901, 13, 17},
	{0x7907, 15, 18},
	{0x790E, 16, 18},
	{0x7911, 15, 18},
	{0x7912, 15, 18},
	{0x7919, 16, 19},
	{0x7926, 17, 20},
	{0x792A, 17, 19},
	{0x792B, 15, 19},
	{0x792C, 19, 20},
	{0x793A,  4,  5},
	{0x793C,  4,  5},
	{0x793E,  6,  7},
	{0x7940,  8,  8},
	{0x7941,  5,  6},
	{0x7947,  7,  8},
	{0x7948,  7,  8},
	{0x7949,  7,  9},
	{0x7950,  7,  9},
	{0x7953, 10, 10},
	{0x7955, 10, 10},
	{0x7956,  8, 10},
	{0x7957,  9, 10},
	{0x795A, 10, 10},
	{0x795D,  7,  9},
	{0x795E,  8,  9},
	{0x795F,  9, 10},
	{0x7960,  9, 10},
	{0x7962,  8,  9},
	{0x7965,  8, 10},
	{0x7968, 10, 11},
	{0x796D,  8, 11},
	{0x7977, 10, 12},
	{0x797A, 13, 13},
	{0x797F, 11, 14},
	{0x7980, 11, 13},
	{0x7981, 12, 13},
	{0x7984,  9, 12},
	{0x7985, 12, 13},
	{0x798A, 14, 14},
	{0x798D, 11, 13},
	{0x798E, 10, 13},
	{0x798F, 11, 13},
	{0x799D, 14, 15},
	{0x79A6, 14, 17},
	{0x79A7, 16, 17},
	{0x79AA, 15, 17},
	{0x79AE, 16, 18},
	{0x79B0, 18, 19},
	{0x79B3, 17, 22},
	{0x79B9,  7,  9},
	{0x79BA,  8,  9},
	{0x79BD, 10, 13},
	{0x79BE,  4,  5},
	{0x79BF,  7,  7},
	{0x79C0,  6,  7},
	{0x79C1,  5,  7},
	{0x79C9,  7,  8},
	{0x79CB,  7,  9},
	{0x79D1,  8,  9},
	{0x79D2,  7,  9},
	{0x79D5,  9, 10},
	{0x79D8,  9, 10},
	{0x79DF,  9, 10},
	{0x79E1,  9, 10},
	{0x79E3,  9, 10},
	{0x79E4,  9, 10},
	{0x79E6,  9, 10},
	{0x79E7,  9, 10},
	{0x79E9,  9, 10},
	{0x79EC,  9, 10},
	{0x79F0,  7, 10},
	{0x79FB,  8, 11},
	{0x7A00,  9, 12},
	{0x7A08, 11, 12},
	{0x7A0B,  9, 12},
	{0x7A0D, 12, 12},
	{0x7A0E,  8, 12},
	{0x7A14, 12, 13},
	{0x7A17, 11, 14},
	{0x7A18, 12, 13},
	{0x7A19, 13, 13},
	{0x7A1A, 11, 13},
	{0x7A1C, 11, 13},
	{0x7A1F, 11, 13},
	{0x7A20, 11, 13},
	{0x7A2E, 10, 14},
	{0x7A31, 14, 14},
	{0x7A32, 13, 14},
	{0x7A37, 14, 15},
	{0x7A3B, 13, 15},
	{0x7A3C, 10, 15},
	{0x7A3D, 14, 16},
	{0x7A3E, 11, 15},
	{0x7A3F, 10, 15},
	{0x7A40, 12, 14},
	{0x7A42, 13, 16},
	{0x7A43, 13, 15},
	{0x7A46, 14, 16},
	{0x7A49, 17, 17},
	{0x7A4D, 13, 16},
	{0x7A4E, 13, 16},
	{0x7A4F, 14, 16},
	{0x7A50, 15, 17},
	{0x7A57, 16, 17},
	{0x7A61, 18, 18},
	{0x7A62, 17, 18},
	{0x7A63, 15, 18},
	{0x7A69, 18, 19},
	{0x7A6B, 16, 18},
	{0x7A70, 18, 22},
	{0x7A74,  4,  5},
	{0x7A76,  6,  7},
	{0x7A79,  7,  8},
	{0x7A7A,  7,  8},
	{0x7A7D,  9,  9},
	{0x7A7F,  8, 11},
	{0x7A81,  7,  8},
	{0x7A83,  8,  9},
	{0x7A84,  9, 10},
	{0x7A88,  8, 10},
	{0x7A92,  8, 11},
	{0x7A93,  9, 11},
	{0x7A95, 11, 11},
	{0x7A96, 11, 12},
	{0x7A97, 11, 12},
	{0x7A98, 11, 12},
	{0x7A9F, 10, 13},
	{0x7AA9, 13, 14},
	{0x7AAA, 13, 14},
	{0x7AAE, 12, 15},
	{0x7AAF, 14, 15},
	{0x7AB0, 13, 15},
	{0x7AB6, 15, 16},
	{0x7ABA, 15, 16},
	{0x7ABF, 14, 15},
	{0x7AC3, 14, 17},
	{0x7AC4, 13, 18},
	{0x7AC5, 15, 18},
	{0x7AC7, 18, 21},
	//{0x7AC8,  0,  0},
	{0x7ACA, 21, 22},
	{0x7ACB,  3,  5},
	{0x7ACD,  7,  7},
	{0x7ACF,  7,  8},
	{0x7AD2,  7,  9},
	{0x7AD3,  8,  9},
	{0x7AD5,  8,  9},
	{0x7AD9, 10, 10},
	{0x7ADA,  9, 10},
	{0x7ADC,  9, 10},
	{0x7ADD,  8, 10},
	{0x7ADF, 10, 11},
	{0x7AE0,  9, 11},
	{0x7AE1,  9, 11},
	{0x7AE2, 10, 12},
	{0x7AE3,  9, 13},
	{0x7AE5,  9, 12},
	{0x7AE6, 10, 12},
	{0x7AEA, 12, 14},
	{0x7AED, 14, 14},
	{0x7AEF, 11, 14},
	{0x7AF0, 14, 14},
	{0x7AF6, 14, 20},
	{0x7AF8, 22, 22},
	{0x7AF9,  4,  6},
	{0x7AFA,  6,  8},
	{0x7AFF,  7,  9},
	{0x7B02,  8,  9},
	{0x7B04,  9, 10},
	{0x7B06,  8, 10},
	{0x7B08,  7, 10},
	{0x7B0A,  8, 10},
	{0x7B0B,  9, 10},
	{0x7B0F,  8, 10},
	{0x7B11,  6, 10},
	{0x7B18,  9, 11},
	{0x7B19,  9, 11},
	{0x7B1B,  9, 11},
	{0x7B1E, 10, 11},
	{0x7B20,  9, 11},
	{0x7B25,  8, 11},
	{0x7B26,  9, 11},
	{0x7B28,  9, 11},
	{0x7B2C,  7, 11},
	{0x7B33, 10, 11},
	{0x7B35,  9, 11},
	{0x7B36, 10, 11},
	{0x7B39,  7, 11},
	{0x7B45, 11, 12},
	{0x7B46,  9, 12},
	{0x7B48, 10, 12},
	{0x7B49,  7, 12},
	{0x7B4B,  8, 12},
	{0x7B4C, 10, 12},
	{0x7B4D, 10, 12},
	{0x7B4F, 10, 12},
	{0x7B50, 12, 12},
	{0x7B51,  8, 12},
	{0x7B52,  9, 12},
	{0x7B54,  8, 12},
	{0x7B56,  8, 12},
	{0x7B5D, 12, 12},
	{0x7B65, 10, 13},
	{0x7B67, 11, 13},
	{0x7B6C, 12, 12},
	{0x7B6E, 13, 13},
	{0x7B70, 10, 13},
	{0x7B71, 13, 13},
	{0x7B74, 12, 13},
	{0x7B75, 11, 13},
	{0x7B7A, 13, 13},
	{0x7B86, 12, 16},
	{0x7B87, 10, 14},
	{0x7B8B, 12, 14},
	{0x7B8D, 13, 14},
	{0x7B8F, 12, 14},
	{0x7B92, 12, 14},
	{0x7B94, 11, 14},
	{0x7B95, 12, 14},
	{0x7B97, 10, 14},
	{0x7B98, 12, 14},
	{0x7B99, 14, 14},
	{0x7B9A, 12, 14},
	{0x7B9C, 12, 14},
	{0x7B9D, 12, 14},
	{0x7B9F, 13, 15},
	{0x7BA1, 11, 14},
	{0x7BAA, 13, 15},
	{0x7BAD, 13, 15},
	{0x7BB1, 11, 15},
	{0x7BB4, 13, 15},
	{0x7BB8, 11, 14},
	{0x7BC0,  9, 13},
	{0x7BC1, 14, 15},
	{0x7BC4, 12, 15},
	{0x7BC6, 14, 15},
	{0x7BC7, 13, 17},
	{0x7BC9, 13, 16},
	{0x7BCB,  8, 16},
	{0x7BCC, 15, 15},
	{0x7BCF, 12, 15},
	{0x7BDD, 14, 16},
	{0x7BE0, 14, 17},
	{0x7BE4, 13, 16},
	{0x7BE5, 15, 16},
	{0x7BE6, 15, 17},
	{0x7BE9, 13, 16},
	{0x7BED, 14, 16},
	{0x7BF3, 16, 16},
	{0x7BF6, 17, 18},
	{0x7BF7, 15, 16},
	{0x7C00, 14, 17},
	{0x7C07, 15, 17},
	{0x7C0D, 15, 17},
	{0x7C11, 14, 16},
	{0x7C12, 16, 17},
	{0x7C13, 15, 17},
	{0x7C14, 16, 17},
	{0x7C17, 17, 17},
	{0x7C1F, 17, 18},
	{0x7C21, 16, 18},
	{0x7C23, 17, 18},
	{0x7C27, 15, 18},
	{0x7C2A, 18, 20},
	{0x7C2B, 17, 17},
	{0x7C37, 17, 19},
	{0x7C38, 16, 19},
	{0x7C3D, 15, 19},
	{0x7C3E, 16, 19},
	{0x7C3F, 17, 19},
	{0x7C40, 17, 18},
	{0x7C43, 20, 21},
	{0x7C4C, 18, 20},
	{0x7C4D, 16, 20},
	{0x7C4F, 18, 20},
	{0x7C50, 19, 21},
	{0x7C54, 21, 21},
	{0x7C56, 19, 21},
	{0x7C58, 19, 22},
	{0x7C5F, 19, 22},
	{0x7C60, 19, 22},
	{0x7C64, 21, 23},
	{0x7C65, 17, 23},
	{0x7C6C, 20, 24},
	{0x7C73,  5,  6},
	{0x7C75,  8,  8},
	{0x7C7E,  8,  9},
	{0x7C81,  8,  9},
	{0x7C82,  8,  9},
	{0x7C83,  9, 11},
	{0x7C89,  8, 10},
	{0x7C8B,  9, 10},
	{0x7C8D,  9, 10},
	{0x7C90,  8, 10},
	{0x7C92,  9, 11},
	{0x7C95,  9, 11},
	{0x7C97,  9, 11},
	{0x7C98,  9, 11},
	{0x7C9B, 10, 11},
	{0x7C9F, 11, 12},
	{0x7CA1, 10, 12},
	{0x7CA2, 10, 12},
	{0x7CA4,  9, 12},
	{0x7CA5, 10, 12},
	{0x7CA7, 10, 12},
	{0x7CA8, 10, 12},
	{0x7CAB, 10, 12},
	{0x7CAD, 10, 12},
	{0x7CAE, 11, 13},
	{0x7CB1, 12, 13},
	{0x7CB2, 12, 13},
	{0x7CB3, 12, 13},
	{0x7CB9, 13, 14},
	{0x7CBD, 13, 14},
	{0x7CBE, 12, 14},
	{0x7CC0, 12, 13},
	{0x7CC2, 14, 15},
	{0x7CC5, 13, 15},
	{0x7CCA, 13, 15},
	{0x7CCE, 14, 15},
	{0x7CD2, 15, 16},
	{0x7CD6, 14, 16},
	{0x7CD8, 12, 15},
	{0x7CDC, 16, 17},
	{0x7CDE, 15, 17},
	{0x7CDF, 16, 17},
	{0x7CE0, 13, 17},
	{0x7CE2, 15, 16},
	{0x7CE7, 14, 18},
	{0x7CEF, 18, 20},
	{0x7CF2, 19, 20},
	{0x7CF4, 19, 22},
	{0x7CF6, 22, 25},
	{0x7CF8,  4,  6},
	{0x7CFA,  5,  7},
	{0x7CFB,  4,  7},
	{0x7CFE,  6,  9},
	{0x7D00,  5,  9},
	{0x7D02,  7,  9},
	{0x7D04,  6,  9},
	{0x7D05,  5,  9},
	{0x7D06,  7,  9},
	{0x7D0A,  8, 10},
	{0x7D0B,  8, 10},
	{0x7D0D,  8, 10},
	{0x7D10,  8, 11},
	{0x7D14,  6, 10},
	{0x7D15,  8, 11},
	{0x7D17,  8, 10},
	{0x7D18,  7, 11},
	{0x7D19,  6, 10},
	{0x7D1A,  6,  9},
	{0x7D1B,  7, 10},
	{0x7D1C,  7, 10},
	{0x7D20,  7, 10},
	{0x7D21,  8, 10},
	{0x7D22,  6, 10},
	{0x7D2B,  9, 12},
	{0x7D2C,  6, 11},
	{0x7D2E,  9, 11},
	{0x7D2F,  9, 11},
	{0x7D30,  8, 11},
	{0x7D32,  9, 11},
	{0x7D33,  9, 11},
	{0x7D35,  9, 11},
	{0x7D39,  8, 11},
	{0x7D3A,  9, 11},
	{0x7D3F,  8, 11},
	{0x7D42,  8, 11},
	{0x7D43,  7, 12},
	{0x7D44,  8, 11},
	{0x7D45,  8, 11},
	{0x7D46,  9, 11},
	{0x7D4B,  8, 11},
	{0x7D4C,  8, 11},
	{0x7D4E,  9, 12},
	{0x7D4F, 10, 13},
	{0x7D50,  8, 12},
	{0x7D56, 10, 12},
	{0x7D5B, 10, 13},
	{0x7D5E,  9, 12},
	{0x7D61,  8, 12},
	{0x7D62,  9, 12},
	{0x7D63, 10, 12},
	{0x7D66,  8, 12},
	{0x7D68, 10, 12},
	{0x7D6E, 10, 12},
	{0x7D71,  7, 12},
	{0x7D72,  8, 12},
	{0x7D73, 11, 13},
	{0x7D75,  8, 12},
	{0x7D76,  8, 12},
	{0x7D79, 10, 13},
	{0x7D7D,  9, 13},
	{0x7D89, 10, 13},
	{0x7D8F, 10, 13},
	{0x7D93, 11, 13},
	{0x7D99,  9, 13},
	{0x7D9A,  9, 13},
	{0x7D9B, 11, 13},
	{0x7D9C, 11, 14},
	{0x7D9F, 10, 13},
	{0x7DA2, 11, 14},
	{0x7DA3, 12, 14},
	{0x7DAB, 12, 14},
	{0x7DAC, 11, 14},
	{0x7DAD, 10, 14},
	{0x7DAE, 11, 14},
	{0x7DAF, 13, 14},
	{0x7DB0, 12, 14},
	{0x7DB1, 10, 14},
	{0x7DB2, 11, 14},
	{0x7DB4, 10, 14},
	{0x7DB5, 11, 14},
	{0x7DB8, 12, 14},
	{0x7DBA, 10, 14},
	{0x7DBB, 11, 14},
	{0x7DBD, 11, 14},
	{0x7DBE, 11, 14},
	{0x7DBF,  2, 14},
	{0x7DC7, 12, 14},
	{0x7DCA, 11, 15},
	{0x7DCB, 12, 14},
	{0x7DCF, 10, 14},
	{0x7DD1,  9, 14},
	{0x7DD2, 11, 14},
	{0x7DD5, 11, 14},
	{0x7DD8, 11, 15},
	{0x7DDA,  9, 14},
	{0x7DDC, 12, 15},
	{0x7DDD, 13, 15},
	{0x7DDE, 12, 15},
	{0x7DE0, 11, 15},
	{0x7DE1, 13, 15},
	{0x7DE4, 13, 15},
	{0x7DE8, 11, 15},
	{0x7DE9, 13, 15},
	{0x7DEC,  6, 15},
	{0x7DEF, 11, 16},
	{0x7DF2, 12, 15},
	{0x7DF4,  9, 14},
	{0x7DFB, 11, 16},
	{0x7E01, 10, 15},
	{0x7E04, 13, 15},
	{0x7E05, 13, 15},
	{0x7E09, 12, 16},
	{0x7E0A, 14, 16},
	{0x7E0B, 11, 14},
	{0x7E12, 14, 16},
	{0x7E1B, 13, 16},
	{0x7E1E, 12, 16},
	{0x7E1F, 12, 16},
	{0x7E21, 14, 16},
	{0x7E22, 14, 16},
	{0x7E23, 14, 16},
	{0x7E26, 11, 16},
	{0x7E2B, 10, 16},
	{0x7E2E,  9, 17},
	{0x7E31, 15, 17},
	{0x7E32, 13, 17},
	{0x7E35, 15, 17},
	{0x7E37, 15, 16},
	{0x7E39, 15, 17},
	{0x7E3A, 13, 16},
	{0x7E3B, 15, 17},
	{0x7E3D, 14, 17},
	{0x7E3E, 14, 17},
	{0x7E41, 12, 16},
	{0x7E43, 14, 17},
	{0x7E46, 16, 17},
	{0x7E4A, 14, 18},
	{0x7E4B, 15, 18},
	{0x7E4D, 15, 18},
	{0x7E54, 14, 18},
	{0x7E55, 14, 18},
	{0x7E56, 15, 18},
	{0x7E59, 15, 18},
	{0x7E5A, 16, 18},
	{0x7E5D, 16, 18},
	{0x7E5E, 15, 18},
	{0x7E66, 13, 18},
	{0x7E67, 15, 18},
	{0x7E69, 18, 18},
	{0x7E6A, 17, 19},
	{0x7E6D, 15, 18},
	{0x7E70, 11, 19},
	{0x7E79, 16, 19},
	{0x7E7B, 17, 19},
	{0x7E7C, 11, 11},
	{0x7E7D,  9, 20},
	{0x7E7F, 18, 21},
	{0x7E82, 16, 20},
	{0x7E83, 18, 18},
	{0x7E88, 16, 20},
	{0x7E89, 18, 21},
	{0x7E8C, 18, 21},
	{0x7E8E, 19, 21},
	{0x7E8F, 17, 21},
	{0x7E90, 15, 20},
	{0x7E92, 20, 22},
	{0x7E93, 19, 23},
	{0x7E94, 24, 25},
	{0x7E96, 21, 24},
	{0x7E9B, 21, 24},
	{0x7E9C, 24, 25},
	{0x7F36,  5,  6},
	{0x7F38,  8,  9},
	{0x7F3A,  9, 10},
	{0x7F45, 15, 17},
	{0x7F4C, 18, 20},
	{0x7F4D, 20, 21},
	{0x7F4E, 20, 22},
	{0x7F50, 18, 23},
	{0x7F51,  6,  6},
	{0x7F54,  7,  8},
	{0x7F55,  7,  7},
	{0x7F58,  8,  9},
	{0x7F5F,  9, 10},
	{0x7F60,  8, 10},
	{0x7F67, 13, 13},
	{0x7F68, 13, 13},
	{0x7F69, 13, 13},
	{0x7F6A, 11, 13},
	{0x7F6B, 11, 13},
	{0x7F6E, 11, 13},
	{0x7F70, 12, 14},
	{0x7F72, 12, 13},
	{0x7F75, 14, 15},
	{0x7F77, 14, 15},
	{0x7F78, 13, 15},
	{0x7F79, 15, 16},
	{0x7F82, 14, 18},
	{0x7F83, 17, 18},
	{0x7F85, 16, 19},
	{0x7F86, 17, 19},
	{0x7F87, 18, 22},
	{0x7F88, 19, 24},
	{0x7F8A,  5,  6},
	{0x7F8C,  8,  9},
	{0x7F8E,  7,  9},
	{0x7F94,  9, 10},
	{0x7F9A, 10, 11},
	{0x7F9D, 10, 11},
	{0x7F9E, 11, 11},
	{0x7FA3, 11, 13},
	{0x7FA4, 10, 13},
	{0x7FA8, 12, 13},
	{0x7FA9, 10, 13},
	{0x7FAE, 14, 15},
	{0x7FAF, 15, 15},
	{0x7FB2, 14, 16},
	{0x7FB6, 16, 19},
	{0x7FB8, 17, 19},
	{0x7FB9, 17, 19},
	{0x7FBD,  5,  6},
	{0x7FC1,  9, 10},
	{0x7FC5, 10, 10},
	{0x7FC6, 10, 10},
	{0x7FCA, 11, 11},
	{0x7FCC, 10, 11},
	{0x7FD2,  9, 11},
	{0x7FD4, 11, 12},
	{0x7FD5, 11, 12},
	{0x7FE0, 13, 14},
	{0x7FE1, 14, 14},
	{0x7FE6, 14, 15},
	{0x7FE9, 13, 15},
	{0x7FEB, 12, 15},
	{0x7FF0, 14, 17},
	{0x7FF3, 16, 18},
	{0x7FF9, 17, 18},
	{0x7FFB, 15, 18},
	{0x7FFC, 16, 17},
	{0x8000, 18, 20},
	{0x8001,  5,  6},
	{0x8003,  5,  6},
	{0x8004,  9, 10},
	{0x8005,  7,  8},
	{0x8006, 10, 10},
	{0x800B, 10, 12},
	{0x800C,  5,  6},
	{0x8010,  8,  9},
	{0x8012,  6,  6},
	{0x8015, 10, 10},
	{0x8017,  9, 10},
	{0x8018,  9, 10},
	{0x8019, 10, 10},
	{0x801C, 10, 11},
	{0x8021, 13, 13},
	{0x8028, 15, 16},
	{0x8033,  5,  6},
	{0x8036,  6,  8},
	{0x803B,  9, 10},
	{0x803D, 10, 11},
	{0x803F, 10, 10},
	{0x8046, 11, 11},
	{0x804A,  9, 11},
	{0x8052, 10, 12},
	{0x8056, 11, 13},
	{0x8058, 13, 13},
	{0x805A, 13, 14},
	{0x805E,  9, 14},
	{0x805F, 12, 14},
	{0x8061, 13, 14},
	{0x8062, 13, 14},
	{0x8068, 11, 15},
	{0x806F, 12, 17},
	{0x8070, 15, 17},
	{0x8072, 16, 17},
	{0x8073, 17, 17},
	{0x8074, 16, 17},
	{0x8076, 18, 18},
	{0x8077, 15, 18},
	{0x8079, 19, 20},
	{0x807D, 21, 23},
	{0x807E, 20, 22},
	{0x807F,  6,  6},
	{0x8084, 13, 13},
	{0x8085, 11, 13},
	{0x8086, 12, 13},
	{0x8087, 12, 14},
	{0x8089,  6,  6},
	{0x808B,  6,  7},
	{0x808C,  5,  6},
	{0x8093,  7,  7},
	{0x8096,  6,  7},
	{0x8098,  7,  7},
	{0x809A,  6,  7},
	{0x809B,  6,  7},
	{0x809D,  6,  7},
	{0x80A1,  8,  8},
	{0x80A2,  7,  8},
	{0x80A5,  7,  8},
	{0x80A9,  6,  8},
	{0x80AA,  8,  8},
	{0x80AC,  8,  8},
	{0x80AD,  8,  8},
	{0x80AF,  7,  8},
	{0x80B1,  7,  9},
	{0x80B2,  6,  8},
	{0x80B4,  8,  8},
	{0x80BA,  8,  9},
	{0x80C3,  9,  9},
	{0x80C4,  9,  9},
	{0x80C6,  9,  9},
	{0x80CC,  8,  9},
	{0x80CE,  7,  9},
	{0x80D6,  9,  9},
	{0x80D9,  8,  9},
	{0x80DA,  9,  9},
	{0x80DB,  9,  9},
	{0x80DD,  8,  9},
	{0x80DE,  7,  9},
	{0x80E1,  8,  9},
	{0x80E4,  7,  9},
	{0x80E5,  8,  9},
	{0x80EF, 10, 10},
	{0x80F1,  9, 10},
	{0x80F4,  8, 10},
	{0x80F8,  8, 10},
	{0x80FC,  9, 10},
	{0x80FD,  7, 10},
	{0x8102, 10, 10},
	{0x8105,  7, 10},
	{0x8106,  9, 10},
	{0x8107, 10, 10},
	{0x8108,  7, 10},
	{0x8109,  8,  8},
	{0x810A, 10, 11},
	{0x811A,  8, 11},
	{0x811B, 10, 11},
	{0x8123,  9, 11},
	{0x8129,  9, 11},
	{0x812F, 11, 11},
	{0x8131,  7, 11},
	{0x8133, 10, 11},
	{0x8139, 10, 12},
	{0x813E, 11, 12},
	{0x8146, 12, 12},
	{0x814B, 11, 12},
	{0x814E, 11, 14},
	{0x8150, 13, 14},
	{0x8151, 11, 12},
	{0x8153, 12, 12},
	{0x8154, 11, 12},
	{0x8155, 10, 12},
	{0x815F, 11, 13},
	{0x8165, 12, 13},
	{0x8166, 12, 13},
	{0x816B, 13, 13},
	{0x816E, 12, 13},
	{0x8170, 12, 13},
	{0x8171, 12, 12},
	{0x8174, 11, 13},
	{0x8178, 12, 13},
	{0x8179, 10, 13},
	{0x817A, 11, 13},
	{0x817F, 10, 13},
	{0x8180, 13, 14},
	{0x8182, 12, 14},
	{0x8183, 14, 14},
	{0x8188, 13, 14},
	{0x818A, 14, 14},
	{0x818F, 12, 14},
	{0x8193, 13, 15},
	{0x8195, 13, 15},
	{0x819A, 10, 15},
	{0x819C, 14, 15},
	{0x819D, 13, 15},
	{0x81A0, 15, 15},
	{0x81A3, 13, 15},
	{0x81A4, 15, 15},
	{0x81A8, 13, 16},
	{0x81A9, 15, 17},
	{0x81B0, 15, 16},
	{0x81B3, 13, 16},
	{0x81B5, 14, 15},
	{0x81B8, 15, 16},
	{0x81BA, 15, 17},
	{0x81BD, 16, 17},
	{0x81BE, 17, 17},
	{0x81BF, 15, 17},
	{0x81C0, 15, 17},
	{0x81C2, 13, 17},
	{0x81C6, 16, 17},
	{0x81C8, 16, 16},
	{0x81C9, 14, 17},
	{0x81CD, 16, 16},
	{0x81D1, 17, 18},
	{0x81D3, 15, 20},
	{0x81D8, 19, 21},
	{0x81D9, 19, 20},
	{0x81DA, 18, 20},
	{0x81DF, 20, 22},
	{0x81E0, 21, 21},
	{0x81E3,  5,  7},
	{0x81E5,  7,  9},
	{0x81E7, 12, 15},
	{0x81E8, 14, 18},
	{0x81EA,  5,  6},
	{0x81ED,  8,  9},
	{0x81F3,  3,  6},
	{0x81F4,  4, 10},
	{0x81FA, 12, 14},
	{0x81FB, 14, 16},
	{0x81FC,  4,  7},
	{0x81FE,  7,  9},
	{0x8201,  7,  8},
	{0x8202, 10, 11},
	{0x8205, 11, 12},
	{0x8207, 12, 13},
	{0x8208, 13, 16},
	{0x8209, 14, 16},
	{0x820A, 15, 16},
	{0x820C,  5,  6},
	{0x820D,  7,  8},
	{0x820E,  5,  8},
	{0x8210,  7, 10},
	{0x8212, 10, 12},
	{0x8216, 14, 15},
	{0x8217, 13, 15},
	{0x8218, 15, 16},
	{0x821B,  6,  7},
	{0x821C, 11, 13},
	{0x821E, 12, 15},
	{0x821F,  5,  6},
	{0x8229,  8, 10},
	{0x822A,  7, 10},
	{0x822B,  8, 10},
	{0x822C,  8, 10},
	{0x822E,  9, 10},
	{0x8233, 10, 11},
	{0x8235,  9, 12},
	{0x8236,  8, 11},
	{0x8237,  8, 11},
	{0x8238,  8, 11},
	{0x8239,  7, 11},
	{0x8240, 10, 12},
	{0x8247, 10, 12},
	//{0x8258,  0,  0},
	{0x8259, 14, 16},
	{0x825A, 16, 17},
	{0x825D, 16, 17},
	{0x825F, 17, 18},
	{0x8262, 18, 18},
	{0x8264, 16, 18},
	{0x8266, 18, 21},
	{0x8268, 16, 19},
	{0x826A, 19, 21},
	{0x826B, 21, 22},
	{0x826E,  4,  6},
	{0x826F,  4,  7},
	{0x8271, 15, 17},
	{0x8272,  4,  6},
	{0x8276, 16, 19},
	{0x8277, 16, 19},
	{0x8278,  6,  6},
	{0x827E,  5,  5},
	{0x828B,  6,  6},
	{0x828D,  6,  6},
	{0x8292,  6,  6},
	{0x8299,  7,  7},
	{0x829D,  5,  6},
	{0x829F,  6,  7},
	{0x82A5,  7,  7},
	{0x82A6,  6,  7},
	{0x82AB,  7,  7},
	{0x82AC,  7,  7},
	{0x82AD,  6,  7},
	{0x82AF,  7,  7},
	{0x82B1,  6,  7},
	{0x82B3,  6,  7},
	{0x82B8,  5,  7},
	{0x82B9,  6,  7},
	{0x82BB,  8, 10},
	{0x82BD,  6,  9},
	{0x82C5,  7,  7},
	{0x82D1,  7,  9},
	{0x82D2,  8,  8},
	{0x82D3,  7,  8},
	{0x82D4,  6,  8},
	{0x82D7,  7,  8},
	{0x82D9,  8,  8},
	{0x82DB,  7,  8},
	{0x82DC,  8,  8},
	{0x82DE,  7,  8},
	{0x82DF,  6,  8},
	{0x82E1,  7,  8},
	{0x82E3,  8,  8},
	{0x82E5,  6,  8},
	{0x82E6,  6,  8},
	{0x82E7,  7,  8},
	{0x82EB,  7,  8},
	{0x82F1,  7,  8},
	{0x82F3,  7,  8},
	{0x82F4,  8,  8},
	{0x82F9,  7,  8},
	{0x82FA,  8,  8},
	{0x82FB,  8,  8},
	{0x8302,  8,  8},
	{0x8303,  8,  8},
	{0x8304,  7,  8},
	{0x8305,  6,  8},
	{0x8306,  7,  8},
	{0x8309,  8,  8},
	{0x830E,  7,  8},
	{0x8316,  8,  9},
	{0x8317,  8,  9},
	{0x8318,  7,  9},
	{0x831C,  8, 10},
	{0x8323,  9, 10},
	{0x8328,  8,  9},
	{0x832B,  9,  9},
	{0x832F,  9,  9},
	{0x8331,  9, 10},
	{0x8332,  6,  9},
	{0x8334,  8,  9},
	{0x8335,  9,  9},
	{0x8336,  8,  9},
	{0x8338,  9,  9},
	{0x8339,  8, 10},
	{0x8340,  9,  9},
	{0x8345,  8,  9},
	{0x8349,  8,  9},
	{0x834A,  9,  9},
	{0x834F,  8,  9},
	{0x8350,  8,  9},
	{0x8352,  8, 10},
	{0x8358,  8,  9},
	{0x8373,  8, 10},
	{0x8375,  9, 11},
	{0x8377,  7, 10},
	{0x837B, 10, 10},
	{0x837C, 10, 10},
	{0x8385,  9, 10},
	{0x8387, 10, 10},
	{0x8389,  8, 10},
	{0x838A,  9, 10},
	{0x838E, 10, 11},
	{0x8393, 10, 10},
	{0x8396, 10, 10},
	{0x839A,  9, 10},
	{0x839E,  9, 10},
	{0x839F,  9, 10},
	{0x83A0,  9, 10},
	{0x83A2,  9, 10},
	{0x83A8,  8, 10},
	{0x83AA,  9, 10},
	{0x83AB, 10, 10},
	{0x83B1,  9, 10},
	{0x83B5, 10, 11},
	{0x83BD,  9,  9},
	{0x83C1, 11, 11},
	{0x83C5,  8, 11},
	{0x83CA, 10, 11},
	{0x83CC, 10, 11},
	{0x83CE, 11, 12},
	{0x83D3, 11, 12},
	{0x83D6, 11, 11},
	{0x83D8, 10, 11},
	{0x83DC, 10, 11},
	{0x83DF,  9, 12},
	{0x83E0, 10, 11},
	{0x83E9, 10, 11},
	{0x83EB, 10, 11},
	{0x83EF,  9, 11},
	{0x83F0,  8, 12},
	{0x83F1,  8, 11},
	{0x83F2, 11, 11},
	{0x83F4, 11, 11},
	{0x83F7,  9, 11},
	{0x83FB, 11, 11},
	{0x83FD, 11, 11},
	{0x8403, 11, 11},
	{0x8404, 10, 11},
	{0x8407, 10, 11},
	{0x840B, 11, 11},
	{0x840C, 11, 11},
	{0x840D, 10, 11},
	{0x840E, 10, 11},
	{0x8413, 11, 11},
	{0x8420, 11, 11},
	{0x8422,  9, 11},
	{0x8429, 11, 12},
	{0x842A, 11, 12},
	{0x842C, 11, 12},
	{0x8431, 12, 12},
	{0x8435, 10, 12},
	{0x8438, 11, 12},
	{0x843C,  9, 12},
	{0x843D,  9, 12},
	{0x8446, 10, 12},
	{0x8449, 10, 12},
	{0x844E, 12, 12},
	{0x8457, 11, 11},
	{0x845B, 10, 11},
	{0x8461, 12, 12},
	{0x8462, 12, 12},
	{0x8463, 11, 12},
	{0x8466, 11, 14},
	{0x8469, 10, 11},
	{0x846B, 10, 12},
	{0x846C, 11, 12},
	{0x846D, 10, 12},
	{0x846E, 10, 12},
	{0x846F,  9, 10},
	{0x8471, 11, 12},
	{0x8475, 11, 12},
	{0x8477, 12, 12},
	{0x8479, 11, 12},
	{0x847A, 11, 12},
	{0x8482, 11, 12},
	{0x8484, 12, 12},
	{0x848B, 12, 13},
	{0x8490, 10, 13},
	{0x8494, 12, 13},
	{0x8499,  8, 13},
	{0x849C, 12, 13},
	{0x849F, 10, 13},
	{0x84A1, 12, 13},
	{0x84AD, 11, 13},
	{0x84B2, 13, 13},
	{0x84B8, 11, 13},
	{0x84B9, 12, 13},
	{0x84BB,  9, 13},
	{0x84BC, 12, 13},
	{0x84BF,  9, 13},
	{0x84C1, 12, 13},
	{0x84C4, 10, 13},
	{0x84C6, 11, 13},
	{0x84C9, 12, 13},
	{0x84CA, 12, 13},
	{0x84CB, 11, 13},
	{0x84CD, 13, 13},
	{0x84D0, 11, 13},
	{0x84D1, 11, 13},
	{0x84D6, 13, 14},
	{0x84D9, 12, 13},
	{0x84DA, 11, 13},
	{0x84EC, 11, 13},
	{0x84EE, 12, 13},
	{0x84F4, 13, 14},
	{0x84FC, 13, 14},
	{0x84FF, 12, 14},
	{0x8500, 11, 14},
	{0x8506, 13, 14},
	{0x8511, 14, 14},
	{0x8513, 13, 14},
	{0x8514, 11, 14},
	{0x8515, 12, 14},
	{0x8517, 12, 14},
	{0x8518, 11, 14},
	{0x851A, 13, 15},
	{0x851F, 13, 14},
	{0x8521, 13, 14},
	{0x8526,  7, 14},
	{0x852C, 12, 15},
	{0x852D, 10, 14},
	{0x8535, 12, 15},
	{0x853D, 13, 15},
	{0x8540, 13, 15},
	{0x8541, 13, 15},
	{0x8543, 14, 15},
	{0x8548, 15, 15},
	{0x8549, 13, 15},
	{0x854A, 15, 15},
	{0x854B, 12, 15},
	{0x854E, 11, 15},
	{0x8555, 15, 15},
	{0x8557, 13, 16},
	{0x8558, 15, 15},
	{0x855A,  9, 15},
	{0x8563, 14, 16},
	{0x8568, 13, 15},
	{0x8569, 13, 15},
	{0x856A, 14, 15},
	{0x856D, 14, 15},
	{0x8577, 13, 16},
	{0x857E, 16, 16},
	{0x8580, 16, 16},
	{0x8584, 14, 16},
	{0x8587, 15, 16},
	{0x8588, 16, 16},
	{0x858A, 13, 16},
	{0x8590, 15, 16},
	{0x8591, 16, 16},
	{0x8594, 14, 16},
	{0x8597, 13, 16},
	{0x8599, 14, 16},
	{0x859B, 14, 16},
	{0x859C, 13, 16},
	{0x85A4, 15, 16},
	{0x85A6, 15, 17},
	{0x85A8, 14, 16},
	{0x85A9, 14, 16},
	{0x85AA, 14, 16},
	{0x85AB, 16, 16},
	{0x85AC, 12, 16},
	{0x85AE, 13, 16},
	{0x85AF, 15, 17},
	{0x85B9, 14, 17},
	{0x85BA, 15, 15},
	{0x85C1, 15, 17},
	{0x85C9, 17, 17},
	{0x85CD, 16, 18},
	{0x85CF, 16, 19},
	{0x85D0, 15, 17},
	{0x85D5, 16, 18},
	{0x85DC, 14, 18},
	{0x85DD, 16, 18},
	{0x85E4, 14, 18},
	{0x85E5, 13, 19},
	{0x85E9, 16, 19},
	{0x85EA, 17, 18},
	{0x85F7, 17, 18},
	{0x85F9, 17, 19},
	{0x85FA, 18, 19},
	{0x85FB, 15, 19},
	{0x85FE, 17, 19},
	{0x8602, 14, 19},
	{0x8606, 18, 19},
	{0x8607, 18, 19},
	{0x860A, 17, 19},
	{0x860B, 17, 19},
	{0x8613, 16, 19},
	{0x8616, 19, 20},
	{0x8617, 17, 20},
	{0x861A, 17, 20},
	{0x8622, 19, 19},
	{0x862D, 14, 19},
	{0x862F, 19, 20},
	{0x8630, 17, 20},
	{0x863F, 19, 21},
	{0x864D,  6,  6},
	{0x864E,  8,  8},
	{0x8650,  9, 10},
	{0x8654,  9, 10},
	{0x8655, 10, 11},
	{0x865A, 10, 11},
	{0x865C, 12, 13},
	{0x865E, 12, 13},
	{0x865F, 12, 13},
	{0x8667, 15, 17},
	{0x866B,  3,  6},
	{0x8671,  5,  8},
	{0x8679,  7,  9},
	{0x867B,  6,  9},
	{0x868A,  6, 10},
	{0x868B,  8, 10},
	{0x868C,  8, 10},
	{0x8693,  6, 10},
	{0x8695,  8, 10},
	{0x86A3,  7, 10},
	{0x86A4,  7, 10},
	{0x86A9,  5, 10},
	{0x86AA,  8, 10},
	{0x86AB,  9, 11},
	{0x86AF,  7, 11},
	{0x86B0,  9, 11},
	{0x86B6,  9, 11},
	{0x86C4,  8, 11},
	{0x86C6,  9, 11},
	{0x86C7,  8, 11},
	{0x86C9,  9, 11},
	{0x86CB,  8, 11},
	{0x86CD,  8, 11},
	{0x86CE,  8, 11},
	{0x86D4,  8, 12},
	{0x86D9,  8, 12},
	{0x86DB,  9, 12},
	{0x86DE,  9, 12},
	{0x86DF, 10, 12},
	{0x86E4,  8, 12},
	{0x86E9,  9, 12},
	{0x86EC, 10, 12},
	{0x86ED,  9, 12},
	{0x86EE, 10, 12},
	{0x86EF, 10, 12},
	{0x86F8, 10, 13},
	{0x86F9, 10, 13},
	{0x86FB, 10, 13},
	{0x86FE,  8, 13},
	{0x8700,  9, 13},
	{0x8702,  9, 13},
	{0x8703,  8, 13},
	{0x8706,  9, 13},
	{0x8708, 10, 13},
	{0x8709,  9, 12},
	{0x870A,  9, 13},
	{0x870D, 11, 13},
	{0x8711, 10, 13},
	{0x8712,  9, 13},
	{0x8718, 10, 14},
	{0x871A, 12, 14},
	{0x871C, 11, 14},
	{0x8725, 11, 14},
	{0x8729, 12, 14},
	{0x8734, 11, 14},
	{0x8737, 12, 15},
	{0x873B, 11, 14},
	{0x873F, 11, 14},
	{0x8749, 12, 15},
	{0x874B, 12, 14},
	{0x874C, 12, 15},
	{0x874E, 13, 15},
	{0x8753, 13, 15},
	{0x8755, 10, 14},
	{0x8757, 12, 15},
	{0x8759, 12, 15},
	{0x875F, 13, 15},
	{0x8760, 11, 15},
	{0x8763, 13, 15},
	{0x8766, 13, 15},
	{0x8768, 11, 15},
	{0x876A, 11, 15},
	{0x876E, 11, 15},
	{0x8774, 10, 15},
	{0x8776, 11, 15},
	{0x8778, 12, 15},
	{0x877F, 13, 15},
	{0x8782, 10, 14},
	{0x878D, 13, 16},
	{0x879F, 13, 16},
	{0x87A2, 13, 16},
	{0x87AB, 13, 17},
	{0x87AF, 12, 16},
	{0x87B3, 13, 17},
	{0x87BA, 15, 17},
	{0x87BB, 15, 17},
	{0x87BD, 12, 17},
	{0x87C0, 12, 15},
	{0x87C4, 14, 17},
	{0x87C6, 14, 16},
	{0x87C7, 13, 16},
	{0x87CB, 14, 17},
	{0x87D0, 13, 17},
	{0x87D2, 12, 15},
	{0x87E0, 16, 18},
	{0x87EF, 14, 18},
	{0x87F2, 10, 18},
	{0x87F6, 15, 19},
	{0x87F7, 15, 19},
	{0x87F9, 16, 19},
	{0x87FB, 15, 19},
	{0x87FE, 15, 19},
	//{0x8805,  0,  0},
	{0x880D, 16, 18},
	{0x880E, 14, 17},
	{0x880F, 18, 19},
	{0x8811, 17, 20},
	{0x8815, 17, 20},
	{0x8816, 15, 18},
	{0x8821, 14, 20},
	{0x8822, 15, 19},
	{0x8823, 17, 18},
	{0x8827, 14, 22},
	{0x8831, 14, 23},
	{0x8836, 24, 26},
	{0x8839, 20, 24},
	{0x883B, 16, 23},
	{0x8840,  4,  6},
	{0x8842,  8,  9},
	{0x8844,  9,  9},
	{0x8846,  9, 12},
	{0x884C,  4,  6},
	{0x884D,  9,  9},
	{0x8852,  8, 11},
	{0x8853,  9, 11},
	{0x8857, 10, 12},
	{0x8859, 10, 13},
	{0x885B, 12, 16},
	{0x885D, 14, 15},
	{0x885E, 13, 16},
	{0x8861, 13, 16},
	{0x8862, 21, 24},
	{0x8863,  4,  7},
	{0x8868,  5,  8},
	{0x886B,  7,  8},
	{0x8870,  8, 12},
	{0x8872,  8, 10},
	{0x8875,  8,  9},
	{0x8877,  7,  9},
	{0x887D,  7,  9},
	{0x887E,  8, 10},
	{0x887F,  8,  9},
	{0x8881,  8, 10},
	{0x8882,  8,  9},
	{0x8888,  7, 11},
	{0x888B,  8, 11},
	{0x888D,  8, 10},
	{0x8892,  9, 10},
	{0x8896,  8, 10},
	{0x8897,  9, 10},
	{0x8899,  8, 10},
	{0x889E,  9, 11},
	{0x88A2,  9, 10},
	{0x88A4, 10, 10},
	{0x88AB,  8, 10},
	{0x88AE,  9, 10},
	{0x88B0, 10, 11},
	{0x88B1, 10, 11},
	{0x88B4,  9, 11},
	{0x88B5,  9, 11},
	{0x88B7, 10, 11},
	{0x88BF,  9, 11},
	{0x88C1,  8, 12},
	{0x88C2,  9, 12},
	{0x88C3, 10, 11},
	{0x88C4, 10, 11},
	{0x88C5,  8, 13},
	{0x88CF, 10, 13},
	{0x88D4, 10, 13},
	{0x88D5, 10, 12},
	{0x88D8, 10, 12},
	{0x88D9, 11, 12},
	{0x88DC, 10, 12},
	{0x88DD, 10, 13},
	{0x88DF, 10, 13},
	{0x88E1, 11, 12},
	{0x88E8, 11, 13},
	{0x88F2, 12, 13},
	{0x88F3, 12, 14},
	{0x88F4, 12, 14},
	{0x88F8, 12, 13},
	{0x88F9, 14, 15},
	{0x88FC, 11, 13},
	{0x88FD,  8, 14},
	{0x88FE,  9, 13},
	{0x8902, 11, 13},
	{0x8904, 12, 13},
	{0x8907, 11, 14},
	{0x890A, 11, 14},
	{0x890C, 13, 14},
	{0x8910, 10, 13},
	{0x8912, 13, 16},
	{0x8913, 11, 14},
	{0x891D, 13, 14},
	{0x891E, 14, 15},
	{0x8925, 12, 15},
	{0x892A, 12, 14},
	{0x892B, 14, 15},
	{0x8936, 14, 16},
	{0x8938, 14, 15},
	{0x893B, 16, 17},
	{0x8941,  9, 16},
	{0x8943, 14, 16},
	{0x8944, 12, 17},
	{0x894C, 12, 17},
	{0x894D, 15, 17},
	{0x8956, 14, 17},
	{0x895E, 14, 16},
	{0x895F, 17, 19},
	{0x8960, 15, 18},
	{0x8964, 17, 20},
	{0x8966, 17, 19},
	{0x896A, 16, 18},
	{0x896D, 15, 19},
	{0x896F, 18, 21},
	{0x8972, 17, 22},
	{0x8974, 20, 22},
	{0x8977, 21, 21},
	{0x897E,  5,  6},
	{0x897F,  5,  6},
	{0x8981,  8,  9},
	{0x8983, 10, 12},
	{0x8986, 15, 18},
	{0x8987, 17, 20},
	{0x8988, 15, 17},
	{0x898A, 21, 25},
	{0x898B,  5,  7},
	{0x898F,  9, 11},
	{0x8993,  9, 11},
	{0x8996,  9, 11},
	{0x8997, 10, 12},
	{0x8998,  9, 12},
	{0x899A, 10, 12},
	{0x89A1, 12, 14},
	{0x89A6, 15, 16},
	{0x89A7, 15, 17},
	{0x89A9, 15, 16},
	{0x89AA, 13, 16},
	{0x89AC, 15, 17},
	{0x89AF, 16, 17},
	{0x89B2, 15, 17},
	{0x89B3, 14, 18},
	{0x89BA, 18, 19},
	{0x89BD, 20, 22},
	{0x89BF, 20, 22},
	{0x89C0, 19, 24},
	{0x89D2,  5,  7},
	{0x89DA, 10, 13},
	{0x89DC, 11, 13},
	{0x89DD, 11, 12},
	{0x89E3, 10, 13},
	{0x89E6,  9, 13},
	{0x89E7, 12, 13},
	{0x89F4, 16, 18},
	{0x89F8, 17, 20},
	{0x8A00,  5,  7},
	{0x8A02,  7,  9},
	{0x8A03,  7,  9},
	{0x8A08,  7,  9},
	{0x8A0A,  8, 10},
	{0x8A0C,  8, 10},
	{0x8A0E,  6, 10},
	{0x8A10,  8, 10},
	{0x8A13,  8, 10},
	{0x8A16,  8, 10},
	{0x8A17,  7, 10},
	{0x8A18,  6, 10},
	{0x8A1B,  9, 11},
	{0x8A1D, 11, 12},
	{0x8A1F,  8, 11},
	{0x8A23, 10, 11},
	{0x8A25, 10, 11},
	{0x8A2A,  8, 11},
	{0x8A2D,  8, 11},
	{0x8A31,  8, 11},
	{0x8A33,  8, 11},
	{0x8A34,  9, 12},
	{0x8A36,  8, 12},
	{0x8A3A, 10, 12},
	{0x8A3B,  9, 12},
	{0x8A3C,  8, 12},
	{0x8A41,  9, 12},
	{0x8A46, 10, 11},
	{0x8A48, 10, 12},
	{0x8A50,  9, 12},
	{0x8A51, 11, 12},
	{0x8A52,  8, 12},
	{0x8A54, 11, 12},
	{0x8A55,  8, 12},
	{0x8A5B, 10, 12},
	{0x8A5E,  8, 12},
	{0x8A60, 10, 12},
	{0x8A62,  8, 13},
	{0x8A63, 12, 13},
	{0x8A66,  9, 13},
	{0x8A69, 10, 13},
	{0x8A6B, 11, 13},
	{0x8A6C, 10, 13},
	{0x8A6D, 11, 13},
	{0x8A6E, 11, 13},
	{0x8A70,  9, 13},
	{0x8A71,  8, 13},
	{0x8A72, 11, 13},
	{0x8A73, 12, 13},
	{0x8A7C, 11, 13},
	{0x8A82, 10, 13},
	{0x8A84, 12, 13},
	{0x8A85, 11, 13},
	{0x8A87, 11, 13},
	{0x8A89, 12, 13},
	{0x8A8C, 10, 14},
	{0x8A8D, 11, 14},
	{0x8A91, 12, 14},
	{0x8A93, 12, 14},
	{0x8A95, 10, 14},
	{0x8A98, 10, 14},
	{0x8A9A, 12, 14},
	{0x8A9E,  9, 14},
	{0x8AA0, 11, 13},
	{0x8AA1, 13, 14},
	{0x8AA3, 12, 14},
	{0x8AA4, 10, 14},
	{0x8AA5, 12, 14},
	{0x8AA6, 12, 14},
	{0x8AA8, 12, 14},
	{0x8AAC,  9, 14},
	{0x8AAD, 10, 14},
	{0x8AB0, 12, 15},
	{0x8AB2, 13, 16},
	{0x8AB9, 13, 15},
	{0x8ABC, 13, 15},
	{0x8ABF, 10, 15},
	{0x8AC2, 13, 14},
	{0x8AC4, 10, 14},
	{0x8AC7, 12, 15},
	{0x8ACB, 13, 15},
	{0x8ACC, 14, 15},
	{0x8ACD, 13, 15},
	{0x8ACF, 14, 15},
	{0x8AD2, 11, 16},
	{0x8AD6, 12, 15},
	{0x8ADA, 12, 15},
	{0x8ADB, 13, 14},
	{0x8ADC, 14, 16},
	{0x8ADE, 12, 16},
	{0x8AE0, 14, 16},
	{0x8AE1, 14, 16},
	{0x8AE2, 15, 16},
	{0x8AE4, 11, 16},
	{0x8AE6, 13, 16},
	{0x8AE7, 15, 17},
	{0x8AEB, 14, 16},
	{0x8AED, 15, 16},
	{0x8AEE, 14, 16},
	{0x8AF1, 14, 17},
	{0x8AF3, 13, 16},
	{0x8AF7, 12, 16},
	{0x8AF8, 12, 15},
	{0x8AFA, 14, 17},
	{0x8AFE, 13, 15},
	{0x8B00, 14, 16},
	{0x8B01, 14, 15},
	{0x8B02, 15, 16},
	{0x8B04, 14, 17},
	{0x8B07, 15, 17},
	{0x8B0C, 11, 17},
	{0x8B0E, 12, 16},
	{0x8B10, 15, 17},
	{0x8B14, 16, 17},
	{0x8B16, 15, 17},
	{0x8B17, 15, 17},
	{0x8B19, 15, 17},
	{0x8B1A, 15, 18},
	{0x8B1B, 15, 17},
	{0x8B1D, 13, 17},
	{0x8B20, 13, 17},
	{0x8B21, 13, 16},
	{0x8B26, 16, 18},
	{0x8B28, 15, 17},
	{0x8B2B, 15, 18},
	{0x8B2C, 17, 18},
	{0x8B33, 13, 19},	// Min 8 per Noriko
	{0x8B39, 13, 17},
	{0x8B3E, 16, 18},
	{0x8B41, 15, 17},
	{0x8B49, 16, 19},
	{0x8B4C, 18, 19},
	{0x8B4E, 14, 18},
	{0x8B4F, 14, 18},
	{0x8B56, 20, 21},
	{0x8B58, 14, 19},
	{0x8B5A, 17, 19},
	{0x8B5B, 17, 19},
	{0x8B5C, 16, 19},
	{0x8B5F, 12, 20},
	{0x8B66, 12, 19},
	{0x8B6B, 16, 20},
	{0x8B6C, 16, 20},
	{0x8B6F, 19, 20},
	{0x8B70, 15, 20},
	{0x8B71, 16, 20},
	{0x8B72, 16, 21},
	{0x8B74, 17, 20},
	{0x8B77, 16, 20},
	{0x8B7D, 17, 19},
	{0x8B80, 20, 22},
	{0x8B83, 20, 22},
	{0x8B8A, 18, 23},
	{0x8B8C, 20, 23},
	{0x8B8E, 19, 23},
	{0x8B90, 19, 23},
	{0x8B92, 24, 25},
	{0x8B93, 18, 25},
	{0x8B96, 20, 24},
	{0x8B99, 18, 23},
	{0x8B9A, 23, 25},
	{0x8C37,  5,  7},
	{0x8C3A, 10, 12},
	{0x8C3F, 13, 17},
	{0x8C41, 14, 17},
	{0x8C46,  4,  7},
	{0x8C48,  7, 10},
	{0x8C4A, 10, 13},
	{0x8C4C, 13, 15},
	{0x8C4E, 13, 16},
	{0x8C50, 18, 18},
	{0x8C55,  6,  7},
	{0x8C5A,  9, 11},
	{0x8C61,  8, 12},
	{0x8C62, 11, 13},
	{0x8C6A, 10, 14},
	{0x8C6B, 12, 16},
	{0x8C6C, 13, 16},
	{0x8C78,  7,  7},
	{0x8C79,  9, 11},
	{0x8C7A,  9, 10},
	{0x8C7C, 11, 12},
	{0x8C82, 10, 12},
	{0x8C85, 12, 13},
	{0x8C89, 12, 13},
	{0x8C8A, 11, 13},
	{0x8C8C, 12, 14},
	{0x8C8D, 13, 14},
	{0x8C8E, 13, 14},
	{0x8C94, 16, 18},
	{0x8C98, 16, 17},
	{0x8C9D,  6,  7},
	{0x8C9E,  6,  9},
	{0x8CA0,  7,  9},
	{0x8CA1,  8, 10},
	{0x8CA2,  9, 10},
	{0x8CA7, 10, 11},
	{0x8CA8,  9, 11},
	{0x8CA9,  9, 11},
	{0x8CAA, 10, 11},
	{0x8CAB, 10, 12},
	{0x8CAC,  9, 11},
	{0x8CAD,  9, 11},
	{0x8CAE, 10, 12},
	{0x8CAF, 11, 12},
	{0x8CB0, 10, 12},
	{0x8CB2, 11, 13},
	{0x8CB3, 12, 12},
	{0x8CB4,  9, 12},
	{0x8CB6,  9, 11},
	{0x8CB7,  9, 12},
	{0x8CB8,  9, 12},
	{0x8CBB,  8, 12},
	{0x8CBC, 10, 12},
	{0x8CBD, 10, 12},
	{0x8CBF,  9, 12},
	{0x8CC0, 10, 12},
	{0x8CC1, 11, 12},
	{0x8CC2, 10, 13},
	{0x8CC3,  8, 13},
	{0x8CC4, 12, 13},
	{0x8CC7, 10, 13},
	{0x8CC8, 12, 13},
	{0x8CCA, 12, 13},
	{0x8CCD, 12, 13},
	{0x8CCE, 12, 13},
	{0x8CD1, 11, 14},
	{0x8CD3, 13, 15},
	{0x8CDA, 14, 15},
	{0x8CDB, 13, 15},
	{0x8CDC, 13, 15},
	{0x8CDE, 12, 15},
	{0x8CE0, 12, 15},
	{0x8CE2, 13, 17},
	{0x8CE3, 13, 15},
	{0x8CE4, 14, 15},
	{0x8CE6, 13, 15},
	{0x8CEA, 10, 15},
	{0x8CED, 13, 15},
	{0x8CFA, 16, 17},
	{0x8CFB, 17, 17},
	{0x8CFC, 15, 17},
	{0x8CFD, 16, 17},
	{0x8D04, 17, 18},
	{0x8D05, 15, 18},
	{0x8D07, 16, 19},
	{0x8D08, 17, 18},
	{0x8D0A, 17, 19},
	{0x8D0B, 15, 19},
	{0x8D0D, 17, 20},
	{0x8D0F, 18, 20},
	{0x8D10, 20, 22},
	{0x8D13, 18, 22},
	{0x8D14, 18, 21},
	{0x8D16, 20, 22},
	{0x8D64,  7,  7},
	{0x8D66,  9, 11},
	{0x8D67, 10, 12},
	{0x8D6B, 12, 14},
	{0x8D6D, 14, 16},
	{0x8D70,  6,  7},
	{0x8D71,  7,  7},
	{0x8D73,  9, 10},
	{0x8D74,  8,  9},
	{0x8D77,  8, 10},
	{0x8D81, 11, 12},
	{0x8D85, 10, 12},
	{0x8D8A, 10, 13},
	{0x8D99, 14, 14},
	{0x8DA3, 14, 15},
	{0x8DA8, 15, 17},
	{0x8DB3,  4,  7},
	{0x8DBA,  9, 11},
	{0x8DBE,  8, 11},
	{0x8DC2,  8, 11},
	{0x8DCB,  9, 12},
	{0x8DCC, 10, 12},
	{0x8DCF,  9, 12},
	{0x8DD6,  9, 12},
	{0x8DDA,  9, 12},
	{0x8DDB, 10, 12},
	{0x8DDD,  8, 12},
	{0x8DDF, 10, 13},
	{0x8DE1,  9, 13},
	{0x8DE3, 11, 13},
	{0x8DE8, 10, 14},
	{0x8DEA, 10, 13},
	{0x8DEB,  9, 13},
	{0x8DEF,  7, 13},
	{0x8DF3,  9, 13},
	{0x8DF5, 11, 13},
	{0x8DFC,  9, 14},
	{0x8DFF, 11, 14},
	{0x8E08, 10, 14},
	{0x8E09, 11, 14},
	{0x8E0A, 10, 14},
	{0x8E0F, 10, 15},
	{0x8E10, 12, 15},
	{0x8E1D, 13, 15},
	{0x8E1E, 11, 15},
	{0x8E1F, 11, 15},
	{0x8E2A, 13, 15},
	{0x8E30, 13, 16},
	{0x8E34, 12, 16},
	{0x8E35, 13, 16},
	{0x8E42, 13, 16},
	{0x8E44, 13, 16},
	{0x8E47, 15, 17},
	{0x8E48, 12, 15},
	{0x8E49, 15, 17},
	{0x8E4A, 13, 17},
	{0x8E4C, 15, 17},
	{0x8E50, 15, 17},
	{0x8E55, 15, 18},
	{0x8E59, 16, 18},
	{0x8E5F, 14, 18},
	{0x8E60, 15, 18},
	{0x8E63, 16, 18},
	{0x8E64, 15, 18},
	{0x8E72, 17, 19},
	{0x8E74, 14, 19},
	{0x8E76, 15, 19},
	{0x8E7C, 17, 19},
	{0x8E81, 14, 20},
	{0x8E84, 18, 20},
	{0x8E85, 15, 20},
	{0x8E87, 17, 19},
	{0x8E8A, 15, 21},
	//{0x8E8B,  0,  0},
	{0x8E8D, 16, 21},
	{0x8E91, 19, 21},
	{0x8E93, 17, 20},
	{0x8E94, 21, 22},
	{0x8E99, 19, 23},
	{0x8EA1, 22, 25},
	{0x8EAA, 24, 26},
	{0x8EAB,  5,  7},
	{0x8EAC,  7, 10},
	{0x8EAF, 10, 12},
	{0x8EB0, 10, 12},
	{0x8EB1, 11, 13},
	{0x8EBE, 13, 16},
	{0x8EC5, 15, 18},
	{0x8EC6, 17, 19},
	{0x8EC8, 19, 23},
	{0x8ECA,  6,  7},
	{0x8ECB,  8,  8},
	{0x8ECC,  9,  9},
	{0x8ECD,  8,  9},
	{0x8ED2, 10, 10},
	{0x8EDB, 11, 11},
	{0x8EDF, 10, 11},
	{0x8EE2,  9, 11},
	{0x8EE3, 10, 11},
	{0x8EEB, 12, 12},
	{0x8EF8, 12, 12},
	{0x8EFB, 10, 12},
	{0x8EFC, 12, 12},
	{0x8EFD, 10, 12},
	{0x8EFE, 12, 13},
	{0x8F03, 10, 13},
	{0x8F05, 11, 13},
	{0x8F09, 12, 13},
	{0x8F0A, 12, 13},
	{0x8F0C, 12, 13},
	{0x8F12, 14, 14},
	{0x8F13, 13, 15},
	{0x8F14, 14, 15},
	{0x8F15, 13, 14},
	{0x8F19, 15, 15},
	{0x8F1B, 15, 15},
	{0x8F1C, 14, 15},
	{0x8F1D, 13, 15},
	{0x8F1F, 15, 15},
	{0x8F26, 15, 15},
	{0x8F29, 14, 15},
	{0x8F2A, 12, 15},
	{0x8F2F, 15, 16},
	{0x8F33, 16, 16},
	{0x8F38, 15, 16},
	{0x8F39, 14, 16},
	{0x8F3B, 13, 16},
	{0x8F3E, 16, 17},
	{0x8F3F, 16, 17},
	{0x8F42, 16, 17},
	{0x8F44, 16, 17},
	{0x8F45, 14, 17},
	{0x8F46, 18, 19},
	{0x8F49, 17, 18},
	{0x8F4C, 18, 18},
	{0x8F4D, 15, 19},
	{0x8F4E, 15, 19},
	{0x8F57, 18, 19},
	{0x8F5C, 20, 21},
	{0x8F5F, 21, 21},
	{0x8F61, 18, 22},
	{0x8F62, 18, 21},
	{0x8F63, 21, 23},
	{0x8F64, 22, 23},
	{0x8F9B,  6,  7},
	{0x8F9C, 12, 12},
	{0x8F9E, 10, 13},
	{0x8F9F, 10, 13},
	{0x8FA3, 12, 14},
	{0x8FA7, 15, 16},
	{0x8FA8, 15, 16},
	{0x8FAD, 16, 19},
	{0x8FAE, 18, 20},
	{0x8FAF, 19, 21},
	{0x8FB0,  5,  7},
	{0x8FB1,  7, 10},
	{0x8FB2, 10, 13},
	{0x8FB7,  4,  4},
	{0x8FBA,  3,  5},
	{0x8FBB,  3,  5},
	{0x8FBC,  3,  5},
	{0x8FBF,  4,  6},
	{0x8FC2,  5,  6},
	{0x8FC4,  4,  6},
	{0x8FC5,  5,  6},
	{0x8FCE,  4,  7},
	{0x8FD1,  4,  6},
	{0x8FD4,  5,  7},
	{0x8FDA,  6,  7},
	{0x8FE2,  7,  8},
	{0x8FE5,  6,  8},
	{0x8FE6,  6,  8},
	{0x8FE9,  6,  8},
	{0x8FEA,  7,  8},
	{0x8FEB,  5,  8},
	{0x8FED,  6,  8},
	{0x8FEF,  7,  8},
	{0x8FF0,  5,  8},
	{0x8FF4,  6,  9},
	{0x8FF7,  7,  9},
	{0x8FF8,  8,  9},
	{0x8FF9,  8, 10},
	{0x8FFA,  9,  9},
	{0x8FFD,  5,  9},
	{0x9000,  6,  9},
	{0x9001,  6,  9},
	{0x9003,  7,  9},
	{0x9005,  7,  9},
	{0x9006,  6,  9},
	{0x900B, 10, 11},
	{0x900D, 10, 10},
	{0x900E,  9, 10},
	{0x900F,  7, 10},
	{0x9010,  6, 10},
	{0x9011,  8, 10},
	{0x9013,  7, 10},
	{0x9014,  8, 10},
	{0x9015,  9, 11},
	{0x9016,  9, 10},
	{0x9017,  8, 10},
	{0x9019,  8, 10},
	{0x901A,  7,  9},
	{0x901D,  7, 10},
	{0x901E,  9, 10},
	{0x901F,  6, 10},
	{0x9020,  6, 10},
	{0x9021,  9, 11},
	{0x9022,  8, 10},
	{0x9023,  8, 10},
	{0x9027,  8, 10},
	{0x902E,  8, 11},
	{0x9031,  6, 10},
	{0x9032,  7, 11},
	{0x9035, 10, 11},
	{0x9036, 10, 12},
	{0x9038,  8, 11},
	{0x9039, 10, 12},
	{0x903C, 10, 12},
	{0x903E, 11, 12},
	{0x9041, 10, 12},
	{0x9042,  8, 11},
	{0x9045,  9, 12},
	{0x9047,  9, 12},
	{0x9049, 11, 12},
	{0x904A,  8, 11},
	{0x904B,  9, 12},
	{0x904D, 10, 12},
	{0x904E,  8, 11},
	{0x904F, 11, 12},
	{0x9050, 10, 12},
	{0x9051, 11, 12},
	{0x9052, 12, 12},
	{0x9053,  8, 12},
	{0x9054,  8, 12},
	{0x9055,  8, 12},
	{0x9056, 11, 12},
	{0x9058, 13, 13},
	{0x9059, 12, 13},
	{0x905C,  9, 12},
	{0x905E, 12, 13},
	{0x9060,  7, 12},
	{0x9061, 11, 13},
	{0x9063,  9, 13},
	{0x9065, 10, 12},
	{0x9068, 13, 14},
	{0x9069, 10, 14},
	{0x906D, 13, 14},
	{0x906E, 12, 14},
	{0x906F, 12, 13},
	{0x9072, 15, 15},
	{0x9075, 13, 15},
	{0x9076, 14, 15},
	{0x9077, 12, 15},
	{0x9078,  9, 15},
	{0x907A, 11, 15},
	{0x907C, 13, 15},
	{0x907D, 12, 15},
	{0x907F, 11, 16},
	{0x9080, 13, 15},
	{0x9081, 14, 15},
	{0x9082, 15, 16},
	{0x9083, 15, 17},
	{0x9084, 11, 16},
	{0x9087, 17, 17},
	{0x9089, 14, 15},
	{0x908A, 15, 16},
	{0x908F, 18, 21},
	{0x9091,  6,  7},
	{0x90A3,  5,  7},
	{0x90A6,  5,  6},
	{0x90A8,  4,  6},
	{0x90AA,  5,  8},
	{0x90AF,  6,  7},
	{0x90B1,  5,  7},
	{0x90B5,  6,  7},
	{0x90B8,  5,  7},
	{0x90C1,  7,  8},
	{0x90CA,  5,  8},
	{0x90CE,  6,  8},
	{0x90DB,  7,  8},
	{0x90E1,  7,  9},
	{0x90E2,  7,  9},
	{0x90E4,  8,  9},
	{0x90E8,  6, 10},
	{0x90ED,  7,  9},
	{0x90F5,  7, 11},
	{0x90F7,  6, 11},
	{0x90FD,  8, 10},
	{0x9102,  8, 11},
	{0x9112, 10, 12},
	{0x9119,  8, 13},
	{0x912D, 13, 15},
	{0x9130, 12, 15},
	{0x9132, 12, 14},
	{0x9149,  7,  7},
	{0x914A,  9,  9},
	{0x914B,  9,  9},
	{0x914C,  9, 10},
	{0x914D,  8, 10},
	{0x914E, 10, 10},
	{0x9152,  9, 10},
	{0x9154, 11, 11},
	{0x9156, 11, 11},
	{0x9158, 11, 11},
	{0x9162, 11, 12},
	{0x9163, 11, 12},
	{0x9165, 11, 12},
	{0x9169, 11, 13},
	{0x916A, 11, 13},
	{0x916C, 13, 13},
	{0x9172, 12, 14},
	{0x9173, 12, 14},
	{0x9175, 12, 14},
	{0x9177, 13, 14},
	{0x9178, 12, 14},
	{0x9182, 15, 15},
	{0x9187, 13, 15},
	{0x9189, 14, 15},
	{0x918B, 14, 15},
	{0x918D, 16, 16},
	{0x9190, 14, 16},
	{0x9192, 15, 16},
	{0x9197, 15, 16},
	{0x919C, 14, 17},
	{0x91A2, 15, 17},
	{0x91A4, 16, 18},
	{0x91AA, 18, 18},
	{0x91AB, 18, 19},
	{0x91AF, 17, 19},
	{0x91B4, 17, 20},
	{0x91B5, 18, 19},
	{0x91B8, 17, 20},
	{0x91BA, 20, 21},
	{0x91C0, 19, 24},
	//{0x91C1,  0,  0},
	{0x91C6,  6,  7},
	{0x91C7,  7,  8},
	{0x91C8,  9, 11},
	{0x91C9, 12, 12},
	{0x91CB, 19, 20},
	{0x91CC,  6,  7},
	{0x91CD,  7,  9},
	{0x91CE,  8, 11},
	{0x91CF, 11, 12},
	{0x91D0, 16, 18},
	{0x91D1,  6,  8},
	{0x91D6,  9, 10},
	{0x91D8,  8, 10},
	{0x91DB,  9, 10},
	{0x91DC,  9, 11},
	{0x91DD,  8, 10},
	{0x91DF,  9, 10},
	{0x91E1,  9, 10},
	{0x91E3, 10, 11},
	{0x91E6,  9, 11},
	{0x91E7, 10, 11},
	{0x91F5, 10, 11},
	{0x91F6, 10, 11},
	{0x91FC, 10, 12},
	{0x91FF, 10, 12},
	{0x920D,  9, 12},
	{0x920E, 10, 12},
	{0x9211, 10, 12},
	{0x9214, 11, 12},
	{0x9215, 11, 12},
	{0x921E, 11, 12},
	{0x9229, 10, 12},
	{0x922C, 10, 12},
	{0x9234, 11, 13},
	{0x9237, 11, 13},
	{0x923F, 11, 13},
	{0x9244, 10, 13},
	{0x9245, 11, 13},
	{0x9248, 12, 13},
	{0x9249, 10, 13},
	{0x924B, 10, 13},
	{0x9250, 11, 13},
	{0x9257, 12, 13},
	{0x925A, 11, 12},
	{0x925B, 10, 13},
	{0x925E, 12, 13},
	{0x9262, 11, 13},
	{0x9264, 10, 13},
	{0x9266, 11, 13},
	{0x9271,  9, 13},
	{0x927E, 11, 14},
	{0x9280, 11, 14},
	{0x9283, 11, 14},
	{0x9285, 11, 14},
	{0x9291, 12, 15},
	{0x9293, 13, 14},
	{0x9295, 11, 14},
	{0x9296, 13, 14},
	{0x9298,  8, 14},
	{0x929A, 13, 14},
	{0x929B, 11, 14},
	{0x929C, 12, 14},
	{0x92AD, 12, 14},
	{0x92B7, 14, 15},
	{0x92B9, 13, 15},
	{0x92CF, 14, 15},
	{0x92D2, 13, 15},
	{0x92E4, 13, 15},
	{0x92E9, 13, 14},
	{0x92EA, 14, 16},
	{0x92ED, 12, 15},
	{0x92F2, 13, 15},
	{0x92F3, 14, 16},
	{0x92F8, 13, 16},
	{0x92FA, 15, 16},
	{0x92FC, 13, 16},
	{0x9306, 14, 16},
	{0x930F, 11, 14},
	{0x9310, 14, 16},
	{0x9318, 14, 17},
	{0x9319, 15, 16},
	{0x931A, 14, 16},
	{0x9320, 14, 16},
	{0x9322, 15, 16},
	{0x9323, 15, 16},
	{0x9326, 14, 16},
	{0x9328, 15, 16},
	{0x932B, 14, 17},
	{0x932C, 15, 16},
	{0x932E, 13, 16},
	{0x932F, 14, 16},
	{0x9332, 12, 16},
	{0x9335, 14, 15},
	{0x933A, 13, 15},
	{0x933B, 14, 16},
	{0x9344, 14, 16},
	{0x934B, 14, 17},
	{0x934D, 14, 17},
	{0x9354, 13, 17},
	{0x9356, 16, 17},
	{0x935B, 15, 17},
	{0x935C, 16, 17},
	{0x9360, 14, 16},
	{0x936C, 15, 17},
	{0x936E, 16, 17},
	{0x9375, 14, 16},
	{0x937C, 14, 17},
	{0x937E, 16, 17},
	{0x938C, 16, 18},
	{0x9394, 17, 18},
	{0x9396, 16, 18},
	{0x9397, 16, 18},
	{0x939A, 12, 17},
	{0x93A7, 14, 18},
	{0x93AC, 15, 18},
	{0x93AD, 17, 18},
	{0x93AE, 14, 18},
	{0x93B0, 17, 18},
	{0x93B9, 15, 17},
	{0x93C3, 17, 19},
	{0x93C8, 16, 18},
	{0x93D0, 18, 19},
	{0x93D1, 17, 19},
	{0x93D6, 17, 20},
	{0x93D7, 17, 20},
	{0x93D8, 18, 19},
	{0x93DD, 18, 19},
	{0x93E1, 16, 19},
	{0x93E4, 17, 19},
	{0x93E5, 16, 18},
	{0x93E8, 17, 19},
	{0x9403, 19, 20},
	{0x9407, 18, 20},
	{0x9410, 19, 20},
	{0x9413, 15, 19},
	{0x9414, 19, 20},
	{0x9418, 17, 20},
	{0x9419, 17, 20},
	{0x941A, 16, 16},
	{0x9421, 18, 20},
	{0x942B, 17, 20},
	{0x9435, 19, 21},
	{0x9436, 18, 21},
	{0x9438, 19, 22},
	{0x943A, 19, 21},
	{0x9441, 19, 21},
	{0x9444, 20, 23},
	{0x9451, 16, 23},
	{0x9452, 22, 23},
	{0x9453, 16, 21},
	{0x945A, 21, 23},
	{0x945B, 22, 23},
	{0x945E, 22, 25},	// Min of 12 per Noriko
	{0x9460, 17, 22},
	{0x9462, 20, 23},
	{0x946A, 22, 24},
	{0x9470, 20, 21},
	{0x9475, 21, 24},
	{0x9477, 24, 26},
	{0x947C, 23, 26},
	{0x947D, 21, 27},
	{0x947E, 21, 25},
	{0x947F, 20, 27},	// Min of 12 per Noriko
	{0x9481, 26, 28},
	{0x9577,  6,  8},
	{0x9580,  3,  8},
	{0x9582,  9,  9},
	{0x9583,  9, 10},
	{0x9587, 11, 11},
	{0x9589,  6, 11},
	{0x958A, 10, 11},
	{0x958B,  7, 12},
	{0x958F, 12, 13},
	{0x9591, 11, 13},
	{0x9593,  7, 12},
	{0x9594, 11, 12},
	{0x9596, 11, 11},
	{0x9598, 13, 13},
	{0x9599, 12, 13},
	{0x95A0, 13, 13},
	{0x95A2,  9, 14},
	{0x95A3, 11, 14},
	{0x95A4, 12, 14},
	{0x95A5, 13, 14},
	{0x95A7, 13, 14},
	{0x95A8, 14, 14},
	{0x95AD,  9, 15},
	{0x95B2, 12, 15},
	{0x95B9, 15, 16},
	{0x95BB, 15, 16},
	{0x95BC, 15, 16},
	{0x95BE, 14, 16},
	{0x95C3, 17, 17},
	{0x95C7, 12, 17},
	{0x95CA, 13, 17},
	{0x95CC, 16, 17},
	{0x95CD, 17, 17},
	{0x95D4, 17, 18},
	{0x95D5, 17, 18},
	{0x95D6, 15, 18},
	{0x95D8, 11, 18},
	{0x95DC, 15, 18},
	{0x95E1, 17, 20},
	{0x95E2, 17, 21},
	{0x95E5, 20, 20},
	{0x961C,  5,  8},
	{0x9621,  4,  5},
	{0x9628,  5,  6},
	{0x962A,  5,  6},
	{0x962E,  5,  6},
	{0x962F,  5,  6},
	{0x9632,  4,  6},
	{0x963B,  6,  8},
	{0x963F,  5,  7},
	{0x9640,  6,  7},
	{0x9642,  6,  7},
	{0x9644,  5,  7},
	{0x964B,  7,  8},
	{0x964C,  6,  8},
	{0x964D,  6,  9},
	{0x964F,  7,  8},
	{0x9650,  5,  8},
	{0x965B,  7, 10},
	{0x965C,  8,  9},
	{0x965D,  8,  9},
	{0x965E,  8,  9},
	{0x965F,  8, 10},
	{0x9662,  6,  9},
	{0x9663,  8,  9},
	{0x9664,  8,  9},
	{0x9665,  7, 10},
	{0x9666,  8,  9},
	{0x966A,  8, 10},
	{0x966C,  9, 10},
	{0x9670,  7, 10},
	{0x9672,  8, 10},
	{0x9673,  8, 11},
	{0x9675,  7, 10},
	{0x9676,  6, 11},
	{0x9677,  8,  9},
	{0x9678,  7, 10},
	{0x967A,  7, 10},
	{0x967D,  8, 11},
	{0x9685,  9, 11},
	{0x9686,  6, 10},
	{0x9688, 10, 12},
	{0x968A,  7, 11},
	{0x968B, 10, 11},
	{0x968D,  9, 10},
	{0x968E,  7, 12},
	{0x968F,  8, 11},
	{0x9694,  9, 12},
	{0x9695,  8, 12},
	{0x9697,  9, 11},
	{0x9698, 11, 12},
	{0x9699, 11, 12},
	{0x969B,  9, 13},
	{0x969C, 11, 13},
	{0x96A0, 11, 13},
	{0x96A3, 11, 15},
	{0x96A7, 11, 13},
	{0x96A8, 12, 14},
	{0x96AA, 11, 15},
	{0x96B0, 11, 16},
	{0x96B1, 14, 16},
	{0x96B2, 13, 16},
	{0x96B4, 15, 18},
	{0x96B6,  7,  8},
	{0x96B7, 14, 16},
	{0x96B8, 15, 17},
	{0x96B9,  7,  8},
	{0x96BB,  9, 10},
	{0x96BC,  8, 10},
	{0x96C0, 10, 12},
	{0x96C1, 10, 12},
	{0x96C4,  7, 12},
	{0x96C5, 10, 13},
	{0x96C6,  9, 12},
	{0x96C7,  9, 12},
	{0x96C9, 11, 13},
	{0x96CB,  9, 12},
	{0x96CC, 12, 14},
	{0x96CD, 10, 13},
	{0x96CE, 12, 13},
	{0x96D1, 11, 14},
	{0x96D5, 14, 16},
	{0x96D6, 12, 17},
	{0x96D9, 16, 18},
	{0x96DB, 15, 18},
	{0x96DC, 16, 18},
	{0x96E2, 14, 19},
	{0x96E3, 15, 18},
	{0x96E8,  7,  8},
	{0x96EA, 10, 11},
	{0x96EB, 11, 11},
	{0x96F0, 11, 12},
	{0x96F2, 10, 12},
	{0x96F6, 12, 13},
	{0x96F7, 12, 13},
	{0x96F9, 11, 13},
	{0x96FB, 11, 13},
	{0x9700, 12, 14},
	{0x9704, 15, 15},
	{0x9706, 13, 14},
	{0x9707, 12, 15},
	{0x9708, 15, 16},
	{0x970A, 14, 15},
	{0x970D, 15, 16},
	{0x970E, 15, 16},
	{0x970F, 16, 16},
	{0x9711, 16, 16},
	{0x9713, 14, 16},
	{0x9716, 16, 16},
	{0x9719, 16, 16},
	{0x971C, 17, 18},
	{0x971E, 15, 17},
	{0x9724, 15, 17},
	{0x9727, 15, 19},
	{0x972A, 18, 19},
	{0x9730, 19, 20},
	{0x9732, 16, 21},
	{0x9738, 19, 21},
	{0x9739, 16, 21},
	{0x973D, 19, 20},
	{0x973E, 20, 22},
	{0x9742, 20, 24},
	{0x9744, 21, 24},
	{0x9746, 20, 23},
	{0x9748, 18, 24},
	{0x9749, 23, 25},
	{0x9752,  7,  8},
	{0x9756, 12, 13},
	{0x9759, 12, 14},
	{0x975C, 15, 16},
	{0x975E,  8,  8},
	{0x9760, 13, 15},
	{0x9761, 19, 19},
	{0x9762,  7,  9},
	{0x9764, 11, 14},
	{0x9766, 14, 16},
	{0x9768, 22, 23},
	{0x9769,  6,  9},
	{0x976B, 10, 12},
	{0x976D,  9, 12},
	{0x9771, 11, 12},
	{0x9774, 11, 13},
	{0x9779, 11, 13},
	{0x977A, 12, 14},
	{0x977C, 12, 14},
	{0x9781, 13, 14},
	{0x9784, 11, 14},
	{0x9785, 12, 14},
	{0x9786, 12, 14},
	{0x978B, 13, 15},
	{0x978D, 14, 15},
	{0x978F, 13, 15},
	{0x9790, 13, 15},
	{0x9798, 15, 16},
	{0x979C, 14, 16},
	{0x97A0, 15, 17},
	{0x97A3, 16, 18},
	{0x97A6, 15, 18},
	{0x97A8, 16, 18},
	{0x97AB, 14, 18},
	{0x97AD, 16, 18},
	{0x97B3, 16, 18},
	{0x97B4, 17, 19},
	{0x97C3, 19, 20},
	{0x97C6, 21, 23},
	{0x97C8, 21, 23},
	{0x97CB,  8, 10},
	{0x97D3, 15, 18},
	{0x97DC, 17, 19},
	{0x97ED,  9,  9},
	{0x97EE, 12, 12},
	{0x97F2, 17, 17},
	{0x97F3,  8,  9},
	{0x97F5, 12, 13},
	{0x97F6, 13, 14},
	{0x97FB, 16, 19},
	{0x97FF, 12, 19},
	{0x9801,  7,  9},
	{0x9802,  6, 11},
	{0x9803,  8, 11},
	{0x9805,  8, 12},
	{0x9806,  8, 12},
	{0x9808,  9, 12},
	{0x980C, 10, 13},
	{0x980F, 11, 13},
	{0x9810,  8, 13},
	{0x9811, 10, 13},
	{0x9812, 10, 13},
	{0x9813,  9, 13},
	{0x9817, 10, 14},
	{0x9818, 10, 14},
	{0x981A, 11, 14},
	{0x9821, 12, 14},
	{0x9824, 12, 16},
	{0x982C, 12, 15},
	{0x982D, 10, 16},
	{0x9834, 13, 16},
	{0x9837, 13, 16},
	{0x9838, 14, 15},
	{0x983B, 13, 17},
	{0x983C, 11, 16},
	{0x983D, 13, 15},
	{0x9846, 14, 16},
	{0x984B, 15, 17},
	{0x984C, 14, 18},
	{0x984D, 12, 18},
	{0x984E, 13, 18},
	{0x984F, 16, 17},
	{0x9854, 12, 18},
	{0x9855, 14, 18},
	{0x9858, 13, 19},
	{0x985B, 16, 19},
	{0x985E, 13, 18},
	{0x9867, 13, 21},
	{0x986B, 18, 21},
	{0x986F, 15, 23},
	//{0x9870,  0,  0},
	{0x9871, 23, 24},
	{0x9873, 24, 26},
	{0x9874, 20, 25},
	{0x98A8,  5,  9},
	{0x98AA,  9, 12},
	{0x98AF, 11, 14},
	{0x98B1, 10, 14},
	{0x98B6, 14, 15},
	{0x98C3, 17, 20},
	{0x98C4, 16, 20},
	{0x98C6, 18, 21},
	{0x98DB,  6,  9},
	{0x98DC, 18, 22},
	{0x98DF,  6,  9},
	{0x98E2,  9, 10},
	{0x98E9, 12, 13},
	{0x98EB, 13, 13},
	{0x98ED, 13, 13},
	{0x98EE, 12, 13},
	{0x98EF, 11, 12},
	{0x98F2, 10, 12},
	{0x98F4, 10, 13},
	{0x98FC, 10, 13},
	{0x98FD, 10, 13},
	{0x98FE,  8, 13},
	{0x9903, 15, 15},
	{0x9905, 12, 15},
	{0x9909, 12, 14},
	{0x990A, 11, 15},
	{0x990C, 13, 14},
	{0x9910, 15, 16},
	{0x9912, 15, 16},
	{0x9913, 12, 15},
	{0x9914, 16, 16},
	{0x9918, 16, 16},
	{0x991D, 15, 16},
	{0x991E, 16, 17},
	{0x9920, 16, 17},
	{0x9921, 15, 17},
	{0x9924, 17, 17},
	{0x9928, 12, 16},
	{0x992C, 17, 18},
	{0x992E, 16, 18},
	{0x993D, 16, 19},
	{0x993E, 16, 18},
	{0x9942, 18, 19},
	{0x9945, 19, 20},
	{0x9949, 18, 20},
	{0x994B, 19, 21},
	{0x994C, 18, 21},
	{0x9950, 17, 21},
	{0x9951, 17, 18},
	{0x9952, 21, 21},
	{0x9955, 19, 22},
	{0x9957, 13, 19},
	{0x9996,  6,  9},
	{0x9997,  8, 10},
	{0x9998, 13, 16},
	{0x9999,  8,  9},
	{0x99A5, 17, 18},
	{0x99A8, 19, 20},
	{0x99AC,  6, 10},
	{0x99AD,  9, 12},
	{0x99AE,  9, 12},
	{0x99B3, 11, 13},
	{0x99B4, 12, 13},
	{0x99BC, 11, 14},
	{0x99C1, 13, 14},
	{0x99C4, 13, 14},
	{0x99C5, 11, 14},
	{0x99C6, 11, 15},
	{0x99C8, 12, 15},
	{0x99D0, 14, 15},
	{0x99D1, 15, 15},
	{0x99D2, 13, 15},
	{0x99D5, 13, 15},
	{0x99D8, 11, 15},
	{0x99DB, 13, 15},
	{0x99DD, 14, 15},
	{0x99DF, 12, 15},
	{0x99E2, 15, 16},
	{0x99ED, 15, 16},
	{0x99EE, 15, 16},
	{0x99F1, 14, 16},
	{0x99F2, 15, 16},
	{0x99F8, 16, 17},
	{0x99FB, 14, 17},
	{0x99FF, 15, 17},
	{0x9A01, 16, 17},
	{0x9A05, 17, 18},
	{0x9A0E, 16, 18},
	{0x9A0F, 15, 19},
	{0x9A12, 14, 18},
	{0x9A13, 13, 18},
	{0x9A19, 16, 19},
	{0x9A28, 18, 20},
	{0x9A2B, 17, 20},
	{0x9A30, 19, 21},
	{0x9A37, 16, 20},
	{0x9A3E, 18, 21},
	{0x9A40, 17, 20},
	{0x9A42, 16, 21},
	{0x9A43, 20, 21},
	{0x9A45, 14, 15},
	{0x9A4D, 19, 22},
	{0x9A55, 16, 22},
	{0x9A57, 19, 23},
	{0x9A5A, 15, 22},
	{0x9A5B, 20, 23},
	{0x9A5F, 21, 23},
	{0x9A62, 23, 26},
	{0x9A64, 21, 26},
	{0x9A65, 25, 26},
	{0x9A69, 22, 27},
	{0x9A6A, 25, 30},
	{0x9A6B, 21, 30},
	{0x9AA8,  7, 11},
	{0x9AAD, 12, 13},
	{0x9AB0, 13, 14},
	{0x9AB8, 14, 17},
	{0x9ABC, 13, 16},
	{0x9AC0, 18, 18},
	{0x9AC4, 16, 19},
	{0x9ACF, 21, 21},
	{0x9AD1, 21, 23},
	{0x9AD3, 19, 22},
	{0x9AD4, 19, 23},
	{0x9AD8,  6, 10},
	{0x9ADE, 14, 23},
	{0x9ADF,  9, 10},
	{0x9AE2, 12, 13},
	{0x9AE3, 11, 14},
	{0x9AE6, 13, 14},
	{0x9AEA, 10, 15},
	{0x9AEB, 13, 15},
	{0x9AED, 15, 16},
	{0x9AEE, 14, 15},
	{0x9AEF, 12, 15},
	{0x9AF1, 12, 15},
	{0x9AF4, 10, 15},
	{0x9AF7, 14, 16},
	{0x9AFB, 11, 16},
	{0x9B06, 15, 18},
	{0x9B18, 19, 21},
	{0x9B1A, 19, 21},
	{0x9B1F, 19, 23},
	{0x9B22, 14, 24},
	{0x9B23, 24, 27},	// Min of 17 per Noriko
	{0x9B25, 10, 10},
	{0x9B27, 14, 15},
	{0x9B28, 15, 16},
	{0x9B29, 17, 17},
	{0x9B2A, 17, 20},
	{0x9B2E, 22, 26},
	{0x9B2F,  9, 10},
	{0x9B31, 28, 29},
	{0x9B32,  8, 10},
	{0x9B3B, 16, 22},
	{0x9B3C,  6, 10},
	{0x9B41, 11, 14},
	{0x9B42,  9, 14},
	{0x9B43, 13, 15},
	{0x9B44, 11, 14},
	{0x9B45, 12, 15},
	{0x9B4D, 16, 18},
	{0x9B4E, 15, 18},
	{0x9B4F, 15, 17},
	{0x9B51, 16, 19},
	{0x9B54, 13, 21},
	{0x9B58, 20, 23},
	{0x9B5A,  9, 11},
	{0x9B6F, 13, 15},
	{0x9B74, 13, 15},
	{0x9B83, 13, 16},
	{0x9B8E, 13, 16},
	{0x9B91, 13, 16},
	{0x9B92, 15, 16},
	{0x9B93, 13, 16},
	{0x9B96, 14, 16},
	{0x9B97, 13, 16},
	{0x9B9F, 14, 17},
	{0x9BA0, 15, 17},
	{0x9BA8, 14, 17},
	{0x9BAA, 16, 17},
	{0x9BAB, 17, 17},
	{0x9BAD, 12, 17},
	{0x9BAE, 13, 17},
	{0x9BB4, 16, 17},
	{0x9BB9, 17, 18},
	{0x9BC0, 13, 18},
	{0x9BC6, 17, 18},
	{0x9BC9, 16, 18},
	{0x9BCA, 17, 18},
	{0x9BCF, 17, 18},
	{0x9BD1, 17, 18},
	{0x9BD2, 17, 18},
	{0x9BD4, 18, 19},
	{0x9BD6, 17, 20},
	{0x9BDB, 16, 19},
	{0x9BE1, 17, 19},
	{0x9BE2, 16, 18},
	{0x9BE3, 19, 19},
	{0x9BE4, 17, 20},
	{0x9BE8, 16, 19},
	{0x9BF0, 15, 19},
	{0x9BF1, 16, 19},
	{0x9BF2, 18, 19},
	{0x9BF5, 17, 19},
	{0x9C04, 19, 20},
	{0x9C06, 18, 20},
	{0x9C08, 18, 20},
	{0x9C09, 18, 19},
	{0x9C0A, 19, 20},
	{0x9C0C, 19, 20},
	{0x9C0D, 18, 20},
	{0x9C10, 18, 21},
	{0x9C12, 17, 20},
	{0x9C13, 17, 20},
	{0x9C14, 17, 20},
	{0x9C15, 19, 20},
	{0x9C1B, 20, 20},
	{0x9C21, 17, 20},
	{0x9C24, 17, 20},
	{0x9C25, 20, 21},
	{0x9C2D, 19, 21},
	{0x9C2E, 20, 21},
	{0x9C2F, 18, 21},
	{0x9C30, 19, 21},
	{0x9C32, 19, 21},
	{0x9C39, 21, 23},
	{0x9C3A, 18, 22},
	{0x9C3B, 21, 22},
	{0x9C3E, 21, 22},
	{0x9C46, 21, 22},
	{0x9C47, 20, 21},
	{0x9C48, 20, 22},
	{0x9C52, 22, 23},
	{0x9C57, 21, 24},
	{0x9C5A, 22, 23},
	{0x9C60, 24, 24},
	{0x9C67, 21, 24},
	{0x9C76, 21, 26},
	{0x9C78, 27, 27},
	{0x9CE5,  7, 11},
	{0x9CE7, 12, 12},
	{0x9CE9, 12, 13},
	{0x9CEB, 12, 13},
	{0x9CEC,  8,  9},
	{0x9CF0, 12, 13},
	{0x9CF3, 12, 14},
	{0x9CF4, 10, 14},
	{0x9CF6, 13, 15},
	{0x9D03, 13, 15},
	{0x9D06, 13, 15},
	{0x9D07, 13, 15},
	{0x9D08, 13, 15},
	{0x9D09, 14, 15},
	{0x9D0E, 14, 16},
	{0x9D12, 14, 15},
	{0x9D15, 15, 15},
	{0x9D1B, 14, 16},
	{0x9D1F, 14, 15},
	{0x9D23, 15, 16},
	{0x9D26, 15, 16},
	{0x9D28, 15, 16},
	{0x9D2A, 15, 16},
	{0x9D2B, 14, 16},
	{0x9D2C, 15, 16},
	{0x9D3B, 15, 17},
	{0x9D3E, 15, 16},
	{0x9D3F, 15, 17},
	{0x9D41, 14, 16},
	{0x9D44, 15, 16},
	{0x9D46, 15, 16},
	{0x9D48, 16, 17},
	{0x9D50, 14, 18},
	{0x9D51, 15, 17},
	{0x9D59, 16, 18},
	{0x9D5C, 12, 18},
	{0x9D5D, 16, 18},
	{0x9D5E, 16, 18},
	{0x9D60, 15, 18},
	{0x9D61, 17, 19},
	{0x9D64, 16, 17},
	{0x9D6C, 18, 20},
	{0x9D6F, 17, 18},
	{0x9D72, 15, 19},
	{0x9D7A, 17, 19},
	{0x9D87, 18, 19},
	{0x9D89, 15, 18},
	{0x9D8F, 18, 19},
	{0x9D9A, 15, 19},
	{0x9DA4, 18, 19},
	{0x9DA9, 16, 19},
	{0x9DAB, 19, 19},
	{0x9DAF, 20, 21},
	{0x9DB2, 19, 20},
	{0x9DB4, 13, 21},
	{0x9DB8, 16, 20},
	{0x9DBA, 20, 20},
	{0x9DBB, 19, 20},
	{0x9DC1, 20, 21},
	{0x9DC2, 18, 20},
	{0x9DC4, 18, 21},
	{0x9DC6, 20, 21},
	{0x9DCF, 19, 21},
	{0x9DD3, 20, 21},
	{0x9DD9, 19, 21},
	{0x9DE6, 21, 23},
	{0x9DED, 21, 23},
	{0x9DEF, 22, 23},
	{0x9DF2, 20, 23},
	{0x9DF8, 17, 21},
	{0x9DF9, 20, 24},
	{0x9DFA, 16, 24},
	{0x9DFD, 22, 22},
	{0x9E1A, 25, 27},
	{0x9E1B, 22, 26},
	{0x9E1E, 23, 29},
	{0x9E75, 11, 12},
	{0x9E78, 17, 19},
	{0x9E79, 18, 19},
	{0x9E7D, 24, 25},
	{0x9E7F, 10, 12},
	{0x9E81, 12, 13},
	{0x9E88, 15, 16},
	{0x9E8B, 16, 18},
	{0x9E8C, 15, 18},
	{0x9E91, 17, 19},
	{0x9E92, 18, 20},
	{0x9E93, 19, 20},
	{0x9E95, 18, 20},
	{0x9E97, 19, 20},
	{0x9E9D, 20, 22},
	{0x9E9F, 21, 25},
	{0x9EA5, 11, 12},
	{0x9EA6,  6,  7},
	{0x9EA9, 15, 15},
	{0x9EAA, 15, 15},
	{0x9EAD, 16, 16},
	{0x9EB8, 10, 11},
	{0x9EB9, 12, 15},
	{0x9EBA, 11, 16},
	{0x9EBB, 10, 11},
	{0x9EBC, 13, 14},
	{0x9EBE, 14, 15},
	{0x9EBF, 15, 18},
	{0x9EC4,  9, 11},
	{0x9ECC, 23, 25},
	{0x9ECD, 10, 12},
	{0x9ECE, 12, 16},
	{0x9ECF, 15, 17},
	{0x9ED0, 18, 22},
	{0x9ED2, 10, 11},
	{0x9ED4, 16, 16},
	{0x9ED8, 16, 17},
	{0x9ED9, 14, 16},
	{0x9EDB, 15, 16},
	{0x9EDC, 14, 17},
	{0x9EDD, 15, 17},
	{0x9EDE, 16, 17},
	{0x9EE0, 17, 18},
	{0x9EE5, 19, 20},
	{0x9EE8, 19, 20},
	{0x9EEF, 20, 21},
	{0x9EF4, 20, 23},
	{0x9EF6, 26, 26},
	{0x9EF7, 24, 27},
	{0x9EF9, 12, 12},
	{0x9EFB, 17, 17},
	{0x9EFC, 19, 19},
	{0x9EFD, 10, 13},	// Max 14 per Noriko
	{0x9F07, 14, 23},
	{0x9F08, 13, 25},
	{0x9F0E, 10, 14},
	{0x9F13, 10, 13},
	{0x9F15, 17, 18},
	{0x9F20, 12, 15},
	{0x9F21,  8,  8},
	{0x9F2C, 14, 17},
	{0x9F3B, 11, 14},
	{0x9F3E, 16, 17},
	{0x9F4A, 12, 13},
	{0x9F4B, 15, 17},
	{0x9F4E, 18, 19},
	{0x9F4F, 21, 21},
	{0x9F52, 14, 15},
	{0x9F54, 16, 17},
	{0x9F5F, 18, 20},
	{0x9F60, 18, 20},
	{0x9F61, 18, 20},
	{0x9F62, 14, 17},
	{0x9F63, 18, 20},
	{0x9F66, 20, 21},
	{0x9F67, 20, 21},
	{0x9F6A, 19, 22},
	{0x9F6C, 20, 22},
	{0x9F72, 21, 24},
	{0x9F76, 21, 22},
	{0x9F77, 19, 24},
	{0x9F8D, 14, 17},
	{0x9F95, 17, 22},
	{0x9F9C, 14, 16},
	{0x9F9D, 18, 21},
	{0x9FA0, 11, 17},
};

/******************************Public*Routine******************************\
* NoSuspStrokeCount
*
* This function tells whether a character has a suspicion of being a bogus
* character.  This is used by recog to mark chars that are unusual for
* manual verification even if the recognizer gets it.
*
* Returns 1 if the character has a very normal number of strokes or if it
* doesn't find the character in the table.
*
* Returns 0 if the character has a suspicious number of strokes according
* to the table.
*
* History:
*  19-Apr-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define NOTSUSP_TAB_SIZE (sizeof(aiNotSusp) / sizeof(VALID))

int NotSuspStrokeCount(wchar_t wch, short iStroke)
{
	short	iLow  = 0;
	short	iPick = NOTSUSP_TAB_SIZE / 2;
	short	iHigh = NOTSUSP_TAB_SIZE - 1;

	while (TRUE)
	{
	// If we found the character in the table, return its validity

		if (aiNotSusp[iPick].wxjis == wch)
            return (iStroke >= aiNotSusp[iPick].nMin) && (iStroke <= aiNotSusp[iPick].nMax);

	// If we didn't find the character in the table, return TRUE

		if (iLow >= iHigh)
			return TRUE;

	// Adjust the low/high/pick values and try again

		if (aiNotSusp[iPick].wxjis < wch)
			iLow = iPick + 1;				// We need to move up
		else
			iHigh = iPick - 1;				// We need to move down

		iPick = (iLow + iHigh) / 2;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\commonu\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif

!if $(FREEBUILD)
HWXBIN=$(_TPG_ROOT)\hwx\release
!else
HWXBIN=$(_TPG_ROOT)\hwx\debug
!endif

hwxbin: $(O)\$(TARGETNAME).$(TARGETEXT)
    mkdir $(HWXBIN)
    copy $(O)\$(TARGETNAME).$(TARGETEXT) $(HWXBIN)
    copy $(O)\$(TARGETNAME).pdb $(HWXBIN)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\answer.c ===
#include "common.h"
#include "crane.h"

// Convert 0-360 angle to absolute angle from Positive X axis.

__inline int Angle2XAngle(int angle)
{
	return angle <= 180 ? angle : 360 - angle;
}

// Convert 0-360 angle to absolute angle from Positive Y axis.

__inline int Angle2YAngle(int angle)
{
// Convert to angle from Y axis.
	
	angle = (angle + 90) % 360;
	return Angle2XAngle(angle);
}

// Find scaled perpendiculare distance from stroke (end points) to a point.
// Note that cStroke is the point number of the start of the stroke.

int FindPerpDist(int cStoke, int cPoint, short *pX, short *pY)
{
	int             dX, dY;
	int             away;

	// Get delta X and delta Y of (end - start of stroke) for our calculations.

	dX      = pX[cStoke + 1] - pX[cStoke];
	dY      = pY[cStoke + 1] - pY[cStoke];

	// If both dX and dY are 0, force an X distance of 1.

	if (dX == 0 && dY == 0) {
		dX      = 1;
	}

	// First calculate the away offset.

	away    = pY[cPoint] * dX - pX[cPoint] * dY;
	
	// Then normalize the offset.

	away    -= pY[cStoke] * dX - pX[cStoke] * dY;

	// Finally normalize the scale.

	away    *= 1000;
	away    /=      dX * dX + dY * dY;

	return away;
}
// Build up a bounding rectangle from a list of bounding rectangles.
void
BuildBoundingBox(RECTS  *pRectsOut, RECTS       *pRectsList, int first, int last)
{
	short   x1, x2, y1, y2;
	ASSERT (first <= last);

	// Always grab the first rect
	x1      = pRectsList[first].x1;
	x2      = pRectsList[first].x2;
	if (x1 <= x2) {
		pRectsOut->x1   = x1;
		pRectsOut->x2   = x2;
	} else {
		pRectsOut->x1   = x2;
		pRectsOut->x2   = x1;
	}

	y1      = pRectsList[first].y1;
	y2      = pRectsList[first].y2;
	if (y1 <= y2) {
		pRectsOut->y1   = y1;
		pRectsOut->y2   = y2;
	} else {
		pRectsOut->y1   = y2;
		pRectsOut->y2   = y1;
	}

	// Now add in any additional rects
	for (++first ; first <= last; ++first) {
		x1      = pRectsList[first].x1;
		x2      = pRectsList[first].x2;
		if (x1 <= x2) {
			if (pRectsOut->x1 > x1) {
				pRectsOut->x1 = x1;
			}
			if (pRectsOut->x2 < x2) {
				pRectsOut->x2 = x2;
			}
		} else {
			if (pRectsOut->x1 > x2) {
				pRectsOut->x1 = x2;
			}
			if (pRectsOut->x2 < x1) {
				pRectsOut->x2 = x1;
			}
		}

		y1      = pRectsList[first].y1;
		y2      = pRectsList[first].y2;
		if (y1 <= y2) {
			if (pRectsOut->y1 > y1) {
				pRectsOut->y1 = y1;
			}
			if (pRectsOut->y2 < y2) {
				pRectsOut->y2 = y2;
			}
		} else {
			if (pRectsOut->y1 > y1) {
				pRectsOut->y1 = y1;
			}
			if (pRectsOut->y2 < y2) {
				pRectsOut->y2 = y2;
			}
		}
	}
}

// Answer a question
// Check if the answer to a question on the sample is Greater.

void AnswerQuestion(
	WORD            questionType,   // What type of question, delta X, delta Y current choices
	WORD            part1,                  // Question constant part 1
	WORD            part2,                  // Question constant part 2 
	SAMPLE_INFO    *pSamples,
	int             cSamples)
{
	int             ii;
	int             deltaX, deltaY;
	int             cStrokes, cPoints;
	short          *pByPointsX, *pByPointsY;
	END_POINTS	   *pendX, *pendY;
	SAMPLE_INFO    *pLimit;
	RECTS           rects;

	cStrokes        = pSamples->pSample->cstrk;             // All samples have the same stroke count
	cPoints         = cStrokes * 2;
	pLimit          = pSamples + cSamples;
	switch (questionType) 
	{
	case questionX:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = (int) ((short *)(pSamples->pSample->apfeat[FEATURE_XPOS]->data))[part1];
		}
		break;

	case questionY:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = (int) ((short *)(pSamples->pSample->apfeat[FEATURE_YPOS]->data))[part1];
		}
		break;

	case questionXDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pSamples->iAnswer       = (int) pByPointsX[part1] - (int) pByPointsX[part2];
		}
		break;

	case questionYDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);
			pSamples->iAnswer       = (int)pByPointsY[part1] - (int)pByPointsY[part2];
		}
		break;

	case questionXAngle:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			deltaX                          = (int)pByPointsX[part2] - (int)pByPointsX[part1];
			deltaY                          = (int)pByPointsY[part2] - (int)pByPointsY[part1];

			pSamples->iAnswer       = Angle2XAngle(Arctan2(deltaY, deltaX));
		}
		break;

	case questionYAngle:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			deltaX                          = (int)pByPointsX[part2] - (int)pByPointsX[part1];
			deltaY                          = (int)pByPointsY[part2] - (int)pByPointsY[part1];
			pSamples->iAnswer       = Angle2YAngle(Arctan2(deltaY, deltaX));
		}
		break;

	case questionDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			deltaX                          = (int)pByPointsX[part2] - (int)pByPointsX[part1];
			deltaY                          = (int)pByPointsY[part2] - (int)pByPointsY[part1];
			pSamples->iAnswer       = Distance(deltaX, deltaY);
		}
		break;

	case questionDakuTen:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = pSamples->pSample->fDakuten;
		}
		break;

	case questionNetAngle:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = ((short *) (pSamples->pSample->apfeat[FEATURE_ANGLE_NET]->data))[part1];
		}
		break;

	case questionCnsAngle :
		for ( ; pSamples < pLimit; ++pSamples) {
			int             iAbsNetAngle, iAbsAngle;

			// Get absolute value of net angle
			iAbsNetAngle    = ((SHORT *) (pSamples->pSample->apfeat[FEATURE_ANGLE_NET]->data))[part1];
			if (iAbsNetAngle < 0) {
				iAbsNetAngle    = -iAbsNetAngle;
			}

			// Get absolute angle.
			iAbsAngle               = ((USHORT *) (pSamples->pSample->apfeat[FEATURE_ANGLE_ABS]->data))[part1];

			// Answer is the difference
			pSamples->iAnswer       = iAbsAngle - iAbsNetAngle;
		}
		break;

	case questionAbsAngle:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = ((USHORT *) (pSamples->pSample->apfeat[FEATURE_ANGLE_ABS]->data))[part1];
		}
		break;

	case questionCSteps:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = ((BYTE *) (pSamples->pSample->apfeat[FEATURE_STEPS]->data))[part1];
		}
		break;

	case questionCFeatures:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = ((BYTE *) (pSamples->pSample->apfeat[FEATURE_FEATURES]->data))[part1];
		}
		break;

	case questionXPointsRight:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cPoints; ++ii) 
			{
				if (pByPointsX[ii] > pByPointsX[part1]) 
				{
					++pSamples->iAnswer;
				}
			}
		}
		break;

	case questionYPointsBelow:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cPoints; ++ii) 
			{
				if (pByPointsY[ii] > pByPointsY[part1]) 
				{
					++pSamples->iAnswer;
				}
			}
		}
		break;

	case questionPerpDist:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer = 
				FindPerpDist(part1, part2, 
				((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data),
				((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data));
		}
		break;

	case questionSumXDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cPoints; ii += 2) 
			{
				pSamples->iAnswer += (int) pByPointsX[ii + 1] - (int) pByPointsX[ii];
			}
		}
		break;

	case questionSumYDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cPoints; ii += 2) 
			{
				pSamples->iAnswer += (int) pByPointsY[ii + 1] - (int) pByPointsY[ii];
			}
		}
		break;

	case questionSumDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cPoints; ii += 2) 
			{
				deltaX          = (int) pByPointsX[ii + 1] - (int) pByPointsX[ii];
				deltaY          = (int) pByPointsY[ii + 1] - (int) pByPointsY[ii];
				pSamples->iAnswer += Distance(deltaX, deltaY);
			}
		}
		break;

	case questionSumNetAngle:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			short   *pNetAngle;

			pNetAngle                       = (short *) pSamples->pSample->apfeat[FEATURE_ANGLE_NET]->data;
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cStrokes; ++ii) 
			{
				pSamples->iAnswer += (int) pNetAngle[ii];
			}
		}
		break;

	case questionSumAbsAngle:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			WORD    *pAbsAngle;

			pAbsAngle                       = (WORD *) pSamples->pSample->apfeat[FEATURE_ANGLE_ABS]->data;
			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cStrokes; ++ii) 
			{
				pSamples->iAnswer += (int)pAbsAngle[ii];
			}
		}
		break;

	case questionCompareXDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);

			deltaX                          = (int) pByPointsX[part1 + 1] - (int) pByPointsX[part1];
			pSamples->iAnswer       = (deltaX >= 0) ? deltaX : - deltaX;
			deltaX                          = (int) pByPointsX[part2 + 1] - (int) pByPointsX[part2];
			pSamples->iAnswer  -= (deltaX >= 0) ? deltaX : - deltaX;
		}
		break;

	case questionCompareYDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);
			deltaY                          = (int) pByPointsY[part1 + 1] - (int) pByPointsY[part1];
			pSamples->iAnswer       = (deltaY >= 0) ? deltaY : - deltaY;
			deltaY                          = (int) pByPointsY[part2 + 1] - (int) pByPointsY[part2];
			pSamples->iAnswer  -= (deltaY >= 0) ? deltaY : - deltaY;
		}
		break;

	case questionCompareDelta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			deltaX                          = (int) pByPointsX[part1 + 1] - (int) pByPointsX[part1];
			deltaY                          = (int) pByPointsY[part1 + 1] - (int) pByPointsY[part1];
			pSamples->iAnswer       = Distance(deltaX, deltaY);

			deltaX                          = (int) pByPointsX[part2 + 1] - (int) pByPointsX[part2];
			deltaY                          = (int) pByPointsY[part2 + 1] - (int) pByPointsY[part2];
			pSamples->iAnswer  -= Distance(deltaX, deltaY);
		}
		break;

	case questionCompareAngle:
		for ( ; pSamples < pLimit; ++pSamples) {
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			deltaX                          = (int) pByPointsX[part1 + 1] - (int) pByPointsX[part1];
			deltaY                          = (int) pByPointsY[part1 + 1] - (int) pByPointsY[part1];
			pSamples->iAnswer       = Arctan2(deltaY, deltaX);

			deltaX                          = (int) pByPointsX[part1 + 1] - (int) pByPointsX[part1];
			deltaY                          = (int) pByPointsY[part1 + 1] - (int) pByPointsY[part1];
			pSamples->iAnswer  -= Arctan2(deltaY, deltaX);
			if (pSamples->iAnswer < -180) 
			{
				pSamples->iAnswer += 180;
			} 
			else if (pSamples->iAnswer > 180) 
			{
				pSamples->iAnswer -= 180;
			}
		}
		break;

	case questionPointsInBBox:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			int             lowerX, upperX, lowerY, upperY;
			
			pByPointsX                      = ((short *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pByPointsY                      = ((short *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			if (pByPointsX[part1] <= pByPointsX[part2]) 
			{
				lowerX  = pByPointsX[part1];
				upperX  = pByPointsX[part2];
			} 
			else 
			{
				lowerX  = pByPointsX[part2];
				upperX  = pByPointsX[part1];
			}

			if (pByPointsY[part1] <= pByPointsY[part2]) 
			{
				lowerY  = pByPointsY[part1];
				upperY  = pByPointsY[part2];
			} 
			else 
			{
				lowerY  = pByPointsY[part2];
				upperY  = pByPointsY[part1];
			}

			pSamples->iAnswer       = 0;
			for (ii = 0; ii < cPoints; ++ii) 
			{
				if ((lowerX <= pByPointsX[ii]) && 
					(pByPointsX[ii] <= upperX) && 
					(lowerY <= pByPointsY[ii]) && 
					(pByPointsY[ii] <= upperY)) 
				{
					++pSamples->iAnswer;
				}
			}
		}
		break;

	case questionCharLeft:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = pSamples->pSample->drcs.x;
		}
		break;

	case questionCharTop:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = pSamples->pSample->drcs.y;
		}
		break;

	case questionCharWidth:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = pSamples->pSample->drcs.w;
		}
		break;

	case questionCharHeight:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = pSamples->pSample->drcs.h;
		}
		break;

	case questionCharDiagonal:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = Distance(pSamples->pSample->drcs.w, pSamples->pSample->drcs.h);
		}
		break;

	case questionCharTheta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = Arctan2(pSamples->pSample->drcs.h, pSamples->pSample->drcs.w);
		}
		break;

	case questionStrokeLeft:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			pSamples->iAnswer       = rects.x1;
		}
		break;

	case questionStrokeTop:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			pSamples->iAnswer       = rects.y1;
		}
		break;

	case questionStrokeWidth:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			pSamples->iAnswer       = rects.x2 - rects.x1;
		}
		break;

	case questionStrokeHeight:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			pSamples->iAnswer       = rects.y2 - rects.y1;
		}
		break;

	case questionStrokeDiagonal:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			short   w, h;

			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			w                                       = rects.x2 - rects.x1;
			h                                       = rects.y2 - rects.y1;
			pSamples->iAnswer       = Distance(w, h);
		}
		break;

	case questionStrokeTheta:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			short   w, h;

			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			w                                       = rects.x2 - rects.x1;
			h                                       = rects.y2 - rects.y1;
			pSamples->iAnswer       = Arctan2(h, w);
		}
		break;

	case questionStrokeRight:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			pSamples->iAnswer       = rects.x2;
		}
		break;

	case questionStrokeBottom:
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			BuildBoundingBox(&rects, 
				(RECTS *)(pSamples->pSample->apfeat[FEATURE_STROKE_BBOX]->data), part1, part2
			);
			pSamples->iAnswer       = rects.y2;
		}
		break;

	case questionStrokeLength:
		for ( ; pSamples < pLimit; ++pSamples)
		{
			pSamples->iAnswer	= ((USHORT *)(pSamples->pSample->apfeat[FEATURE_LENGTH]->data))[part1];
		}
		break;

	case questionStrokeCurve:
		for ( ; pSamples < pLimit; ++pSamples)
		{
			pendX				= ((END_POINTS *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pendY				= ((END_POINTS *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);
			deltaX				= pendX[part1].end - pendX[part1].start;
			deltaY				= pendY[part1].end - pendY[part1].start;
			pSamples->iAnswer	= ((USHORT *)(pSamples->pSample->apfeat[FEATURE_LENGTH]->data))[part1] - Distance(deltaX, deltaY);
		}
		break;

	case questionCharLength:
		for ( ; pSamples < pLimit; ++pSamples)
		{
			pSamples->iAnswer	= 0;
			for (ii = 0; ii < cStrokes; ii++)
				pSamples->iAnswer  += ((USHORT *)(pSamples->pSample->apfeat[FEATURE_LENGTH]->data))[ii];
		}
		break;

	case questionCharCurve:
		for ( ; pSamples < pLimit; ++pSamples)
		{
			pSamples->iAnswer	= 0;
			pendX				= ((END_POINTS *) pSamples->pSample->apfeat[FEATURE_XPOS]->data);
			pendY				= ((END_POINTS *) pSamples->pSample->apfeat[FEATURE_YPOS]->data);

			for (ii = 0; ii < cStrokes; ii++)
			{
				deltaX				= pendX[ii].end - pendX[ii].start;
				deltaY				= pendY[ii].end - pendY[ii].start;
				pSamples->iAnswer  += ((USHORT *)(pSamples->pSample->apfeat[FEATURE_LENGTH]->data))[ii] - Distance(deltaX, deltaY);
			}
		}
		break;

	case questionAltList :
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer       = MAX_RECOG_ALTS * 2;
			for (ii = 0; ii < MAX_RECOG_ALTS; ++ii) {
				if (pSamples->pSample->awchAlts[ii] == (wchar_t)part1) {
					pSamples->iAnswer       = ii;
					break;
				}
			}
		}
		break;

	default:
		ASSERT(FALSE);  // Should never get here.
		for ( ; pSamples < pLimit; ++pSamples) 
		{
			pSamples->iAnswer               = 0;
		}
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\inc\crane.h ===
// 
// Header file for CRANE.LIB
//

#include "common.h"

#ifdef __cplusplus
extern "C" 
{
#endif

#define MAX_RECOG_ALTS          10

#pragma warning (disable : 4200)
typedef struct  tagFEATURES
{
	DWORD   cElements;
	BYTE    data[0];
} FEATURES;
#pragma warning (default : 4200)

// An 'end-point' is the X or Y component of a line segment. X0,X1 or Y0,Y1

typedef struct tagEND_POINTS 
{
	short   start;
	short   end;
} END_POINTS;

// A RECT is a rectangle, upper-left and lower-right

typedef struct tagRECTS
{
	short   x1;
	short   y1;
	short   x2;
	short   y2;
} RECTS;

// A d-RECT is a delta rectangle, upper-left and width, height

typedef struct tagDRECT 
{
	long    x;
	long    y;
	long    w;
	long    h;
} DRECT;

/*	We over flowed shorts when we past all the panels of
    a file togather.
typedef struct tagDRECTS 
{
	short   x;
	short   y;
	short   w;
	short   h;
} DRECTS;
*/
typedef DRECT	DRECTS;

typedef enum tagFEATURE_TYPE
{
	typeBOOL,
	typeBYTE,
	type8DOT8,
	typeSHORT,
	typeUSHORT,
	type16DOT16,
	typePOINTS,
	typeLONG,
	typeULONG,
	type32DOT32,
	typeRECTS,
	typeDRECTS,
	typePOINT,
	typeDRECT,
	typeCOUNT
} FEATURE_TYPE;

typedef enum tagFEATURE_FREQ
{
	freqSTROKE,                                             
	freqFEATURE,                                    
	freqSTEP,                                               
	freqPOINT                                               
} FEATURE_FREQ;

typedef struct  tagFEATURE_KIND
{
	FEATURE_TYPE    type;
	FEATURE_FREQ    freq;
} FEATURE_KIND;

enum {
	FEATURE_ANGLE_NET,
	FEATURE_ANGLE_ABS,
	FEATURE_STEPS,
	FEATURE_FEATURES,
	FEATURE_XPOS,
	FEATURE_YPOS,
	FEATURE_STROKE_BBOX,
	FEATURE_LENGTH,
	FEATURE_COUNT
};

// Information about the whole sample. The sample is normalized to a 1000 by 1000 square.

typedef struct tagSAMPLE {
	short           cstrk;                                                  // Strokes in this sample
	wchar_t         wchLabel;                                               // The character that labels the sample
	wchar_t            aSampleFile[22];                                // Where sample came from.
	short           ipanel;                                                 // Panel number of character
	short           ichar;                                                  // Index in panel of character
	short           fDakuten;                                               // Does this character have a dakuten?
	DRECTS          drcs;                                                   // Guide bounds
	wchar_t         awchAlts[MAX_RECOG_ALTS];               // List of recognizer alternates.
	FEATURES   *apfeat[FEATURE_COUNT];
} SAMPLE;

#define MIN_STROKE_CNT          3
#define MAX_STROKE_CNT          32
#define MAX_RATIO                       0xFFFF

// Character we want to print information about
// Comment out this line to get full tree printed.

// Number of characters in the whole 16-bit character set

#define cClasses                        0x10000         

// Information about a training sample used while selecting questions.

typedef struct tagSAMPLE_INFO {
	SAMPLE          *pSample;
	int                     iAnswer;                // Answer to question being checked at the moment.
} SAMPLE_INFO;

// Information about each alternate in the alternate list of terminal nodes.

typedef struct tagALT_ENTRY {
	wchar_t         wchLabel;
	WORD            fDataSets;      // Bit zero -> in train, bit one -> in test
	int                     cSamples;
} ALT_ENTRY;

// Information about each question asked.

typedef struct tagCART_NODE 
{
// Samples that make up this node.

	int                                     cSamples;
	SAMPLE_INFO                     *pSamples;

// Pointers making CART tree.

	struct tagCART_NODE     *pLess;
	struct tagCART_NODE     *pGreater;
	struct tagCART_NODE     *pParent;

// Pointer used to build up a list of selected nodes.

	struct tagCART_NODE     *pNextSelected;

// Question used to decide branching to less or greater sub trees.

	WORD            questionType;   // What type of question
	WORD            questionPart1;  // Which question for the type may be specified in one or two
	WORD            questionPart2;  // pieces. The delta X and Y questions use these to identify 
								// the start and end points that the delta is done on.
	int                     questionValue;  // Value that question splits on.  Because of the integer
								// rounding of the value when we compute this, we need to do 
								// a <= test.
	
// These values are set when the tree is first built and are not changed 
// during pruning.  These must be set before calling CARTPrune.

	wchar_t         wchLabelMax;            // max-weight char in this subtree
	double          eLabelMaxWeight;        // total weight of wchLabelMax in this subtree

// These values are set and used by CARTPrune and are meaningless after it returns

	int             cTerminalNodes;         // Number of terminals in this subtree
	double  eTerminalLabelWeights;  // sum of eLabelWeight from terminal nodes
	double  ePruneValue;            // Alpha required to make pruning here a cost/complexity win
	int             iHeap;                          // Used with heap routines to know which elements to sift/delete                                                        
	
// This value is useful after CARTPrune returns

	int             iTreePrunePoint;        // Zero means never prune, otherwise indicates successive pruned
								// trees corresponding to different alphas (See Brieman, ch 3)

// These values must be set for the honest estimate code

	double eHonestLabelWeight;      // total weight of wchLabel in subtree according to test
	double eHonestNodeWeight;       // total weight of all characters in subtree according to test

// The alternate list.  This is set for terminals when we clip the CART tree back to its
// final size.

	int                     cAlternates;
	ALT_ENTRY       *pAlternates;

// Misc. statistics

	int                                     cUniqData;
} CART_NODE;

// Valid types of questions.

typedef enum tagQUESTION_TYPE 
{
	questionNONE,
	questionX,                                              // X position
	questionY,                                              // Y position
	questionXDelta,                                 // Delta between two X positions
	questionYDelta,                                 // Delta between two Y positions
	questionXAngle,                                 // Angle relative to X axis
	questionYAngle,                                 // Angle relative to Y axis
	questionDelta,                                  // Squared distance between two points
	questionDakuTen,                                // Chance this character has a dakuten
	questionNetAngle,                               // Net angle of a stroke
	questionCnsAngle,                               // Difference of net angle and absolute angle
	questionAbsAngle,                               // Absolute angle of a stroke
	questionCSteps,                                 // Count of steps in a stroke
	questionCFeatures,                              // Count of features in a stroke
	questionXPointsRight,                   // # of points to the right of a given X value
	questionYPointsBelow,                   // # of points below a given Y value
	questionPerpDist,                               // Perpendicular distance from a line to a point
	questionSumXDelta,                              // Sum of X deltas of a stroke
	questionSumYDelta,                              // Sum of Y deltas of a stroke
	questionSumDelta,                               // Sum of magnitudes of a stroke
	questionSumNetAngle,                    // Sum of net angles of a stroke
	questionSumAbsAngle,                    // Sum of absolute angles of a stroke
	questionCompareXDelta,                  // Derivative of X deltas
	questionCompareYDelta,                  // Derivative of Y deltas
	questionCompareDelta,                   // Derivative of magnitudes
	questionCompareAngle,                   // Derivatice of angles
	questionPointsInBBox,                   // Points in a particular box
	questionCharLeft,                               // Leftmost position of a character
	questionCharTop,                                // Topmost position of a character
	questionCharWidth,                              // Width of a character
	questionCharHeight,                             // Height of a character
	questionCharDiagonal,                   // Length of character's diagonal
	questionCharTheta,                              // Angle of character's diagonal
	questionStrokeLeft,                             // Left most position of a bounding box of stroke range
	questionStrokeTop,                              // Top most position of a bounding box of stroke range
	questionStrokeWidth,                    // Width of a bounding box of stroke range
	questionStrokeHeight,                   // Height of a bounding box of stroke range
	questionStrokeDiagonal,             // Length of (bounding box of stroke range)'s diagonal
	questionStrokeTheta,                // Angle of (bounding box of stroke range)'s diagonal
	questionStrokeRight,                // Right most position of a bounding box of stroke range
	questionStrokeBottom,               // Bottom most position of a bounding box of stroke range
	questionStrokeLength,				// Total curvilinear length of stroke
	questionStrokeCurve,				// Delta between curvilinear length and straight-line length
	questionCharLength,					// Total curvilinear length of all strokes in character
	questionCharCurve,					// Delta between curvilinear length and straight-line length
	questionAltList,                                // Position in recognizer alternate list.
	questionCount
} QUESTION_TYPE;

#define QART_QUESTION           0xd0
#define QART_NOBRANCH           0x01

typedef struct  tagQART
{
	BYTE    question;
	BYTE    flag;
} QART;

typedef union   tagUNIQART
{
	WORD    unicode;
	QART    qart;
} UNIQART;

// This is the packed binary format of the question tree.  Each node will either be a question
// with it parameters, value and branch offset or a UNICODE character.  If the UNICODE character
// would be in the range 0xd000 - 0xdfff then it's a question node.  Bits 0-3 are then flags 
// about the question.  Since branch offsets are limited to 64K and it's remotely possible to 
// have >64K on a branch, the code 0xffff will represent an ESCAPE code.  The optional DWORD
// in 'extra' will then be the long form of the branch.  A sample file might look like this:
//
// offset       field           comment
// +0000        d0                      This is a question
// +0001        02                      Question #2
// +0002        00                      Parameter 1 is 0
// +0003        01                      Parameter 2 is 1
// +0004        03e8            Value is 1000
// +0006        000a            Branch if greater to current position + 0x000a
// +0008        d1                      This is a question with no branch
// +0009        07                      Question #7
// +000a        03                      Parameter 1 is 3
// +000b        02                      Parameter 2 is 2
// +000c        ffef            Value is -17
// +000e        568a            Return UNICODE value 0x568a if greater then -17
// +0010        887b            Return UNICODE value 0x887b
// +0012        4e00            Return UNICODE value 0x4e00                     

#pragma warning (disable : 4200)
typedef struct  tagQNODE
{
	UNIQART uniqart;
	BYTE    param1;
	BYTE    param2;
	short   value;
	WORD    offset;
	DWORD   extra[0];
} QNODE;

// For UNICODE support, modify awIndex to be 84 long and convert the HIGH_INDEX
// macro to the following:
//
// #define HIGH_INDEX(x) ((((x) < 0x0100 ? (x) - 0x0100 : (x) < 0x4e00 ? (x) - 0x2f00 : (x) - 0x4c00) >> 8) & 0x00ff)
//
// This maps U+0000 to index 0, page U+3000 to index 1 and U+4e00 to index 2.  All other
// Kanji follow.  This uses only 600 bytes more space then the XJIS encoding and is even
// better then loading an 8K table for crushed UNICODE.

#define HIGH_INDEX_LIMIT        64
#define HIGH_INDEX(x)			(((x) >> 8) & 0x00ff)

typedef struct  tagQHEAD
{
	WORD    awIndex[HIGH_INDEX_LIMIT];
	DWORD   aqIndex[0];
} QHEAD;
#pragma warning (default : 4200)

typedef struct tagCRANE_LOAD_INFO
{
	void * pLoadInfo1;
	void * pLoadInfo2;
	void * pLoadInfo3;
} CRANE_LOAD_INFO;

// Exported entry points

#ifndef HWX_PRODUCT
	wchar_t	*LastLineSample(void);
	SAMPLE	*ReadSample(SAMPLE *, FILE *);
	void	ResetReadSampleH();
	SAMPLE	*ReadSampleH(SAMPLE *_this, HANDLE);
	BOOL    WriteSample(SAMPLE *, FILE *);
#endif

BOOL	CraneLoadRes(HINSTANCE, int, int, LOCRUN_INFO *pLocRunInfo);
BOOL	CraneLoadFile(LOCRUN_INFO *pLocRunInfo,CRANE_LOAD_INFO *,wchar_t *);
BOOL	CraneUnLoadFile(CRANE_LOAD_INFO *);
BOOL    CraneMatch(ALT_LIST *pAlt, int cAlt, GLYPH *pGlyph, CHARSET *pCS, DRECTS *pdrcs, FLOAT eCARTWeight,LOCRUN_INFO *pLocRunInfo);
void    InitFeatures(SAMPLE *);
void    FreeFeatures(SAMPLE *);
BOOL    MakeFeatures(SAMPLE *, void *);
void    AnswerQuestion(WORD, WORD, WORD, SAMPLE_INFO *, int);

// Ask all the questions on the passed in data set, calling back after each.
void
AskAllQuestions(
	int cStrokes,           // Number of strokes in each sample (same for all samples)
	int     cSamples,               // Number of samples of data
	SAMPLE_INFO *pSamples,          // Pointer to samples of data
	void (*pfCallBack)(                     // Called after each question
		WORD            questionType,   // e.g. single-point, point/stroke, etc.
		WORD            part1,                  // Question constant part 1
		WORD            part2,                  // Question constant part 2 
		SAMPLE_INFO *pSamples,
		int cSamples,
		void *pvCallBackControl
	),      
	void *pvCallBackControl         // passed to pfCallBack each time
);

/* Array of short codes for question types */

extern const char * const apQuestionTypeCode[];

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\askall.c ===
#include "crane.h"

// Lists of questions to ask.
static const WORD	aQuestionListGlobal[]	= {
	questionDakuTen,
	questionSumXDelta,
	questionSumYDelta,
	questionSumDelta,
	questionSumNetAngle,
	questionSumAbsAngle,
	questionCharLeft,
	questionCharTop,
	questionCharWidth,
	questionCharHeight,
	questionCharDiagonal,
	questionCharTheta,
	questionCharLength,
	questionCharCurve,
	questionNONE	// End of list marker
};
static const WORD	aQuestionListByStroke[]	= {
	questionNetAngle,
	questionCnsAngle,
	questionAbsAngle,
	questionCSteps,
	questionCFeatures,
	questionStrokeLength,
	questionStrokeCurve,
	questionNONE	// End of list marker
};
static const WORD	aQuestionListByStrokeByPoint[]	= {
	questionPerpDist,
	questionNONE	// End of list marker
};
static const WORD	aQuestionListByStrokeByStroke[]	= {
	questionCompareXDelta,
	questionCompareYDelta,
	questionCompareDelta,
	questionCompareAngle,
	questionNONE	// End of list marker
};
static const WORD	aQuestionListByStrokeRange[]	= {
	questionStrokeLeft,
	questionStrokeTop,
	questionStrokeRight,
	questionStrokeBottom,
	questionStrokeWidth,
	questionStrokeHeight,
	questionStrokeDiagonal,
	questionStrokeTheta,
	questionNONE	// End of list marker
};
static const WORD	aQuestionListByPoint[]	= {
	questionX,
	questionY,
	questionXPointsRight,
	questionYPointsBelow,
	questionNONE	// End of list marker
};
static const WORD	aQuestionListByPointByPoint[]	= {
	questionXDelta,
	questionYDelta,
	questionXAngle,
	questionYAngle,
	questionDelta,
	questionPointsInBBox,
	questionNONE	// End of list marker
};

// Short codes for questions.  Use following key.
//	First two letters:
//		A	Angle
//				A	Absolute
//				N	Net
//				D	in Degrees
//				E	between End points
//				X	from X axis
//				Y	from Y axis
//		D	Distance
//				B	in Both x and y (e.g. straight-line distance)
//				C	Curvilinear
//				D	Delta of curvilinear and straight-line distance
//				P	Perpendicular
//				X	in X
//				Y	in Y
//		L	Location (position)
//				X	in X
//				Y	in Y
//		R	lR location (position lower right of box)
//				X	in X
//				Y	in Y
//		F	Feature detector
//				dt	DakaTen
//				pt	ProtoType
//		P	Point count
//				B	Below
//				R	Right of
//				I	Inside bounding box
//		S	Step count
//		Z	Zilla feature
//				D	Dehooked ink
//				A	Alternate list position
//
//	Final letter gives info about data type being messured:
//		B	Between points
//		P	single Point
//		S	Stroke
//		R	bounding box of Range of strokes
//		C	Campare between strokes
//		T	Total across all strokes
//		W	bounding box of Whole character
//		G	Genaral question about character
const char * const apQuestionTypeCode[]   = {
	"???",	// questionNONE,
	"LXP",	// questionX,
	"LYP",	// questionY,
	"DXB",	// questionXDelta,
	"DYB",	// questionYDelta,
	"AXB",	// questionXAngle,
	"AYB",	// questionYAngle,
	"DBB",	// questionDelta,
	"Fdt",	// questionDakaTen,
	"ANS",	// questionNetAngle,
	"ACS",	// questionCnsAngle,
	"AAS",	// questionAbsAngle,
	"SDS",	// questionCSteps,
	"ZDS",	// questionCFeatures,
	"PRP",	// questionXPointsRight,
	"PBP",	// questionYPointsBelow,
	"DPS",	// questionPerpDist,
	"DXT",	// questionSumXDelta,
	"DYT",	// questionSumYDelta,
	"DBT",	// questionSumDelta,
	"ANT",	// questionSumNetAngle,
	"AAT",	// questionSumAbsAngle,
	"DXC",	// questionCompareXDelta,
	"DYC",	// questionCompareYDelta,
	"DBC",	// questionCompareDelta,
	"AEC",	// questionCompareAngle,
	"PIB",	// questionPointsInBBox,
	"LXW",	// questionCharLeft,
	"LYW",	// questionCharTop,
	"DXW",	// questionCharWidth,
	"DYW",	// questionCharHeight,
	"DBW",	// questionCharDiagonal,
	"ADW",	// questionCharTheta,
	"LXR",	// questionStrokeLeft,
	"LYR",	// questionStrokeTop,
	"DXR",	// questionStrokeWidth,
	"DXR",	// questionStrokeHeight,
	"DBR",	// questionStrokeDiagonal,
	"ADR",	// questionStrokeTheta,
	"RXR",	// questionStrokeRight,
	"RYR",	// questionStrokeBottom,
	"DCS",	// questionStrokeLength,
	"DDS",	// questionStrokeCurve
	"DCT",	// questionCharLength,
	"DDT",	// questionCharCurve,
	"ZAG",	// questionAltList
#ifdef PROTOTYPES
	"Fpt",	// questionPrototype
#endif
};

// Ask all the questions on the passed in data set, calling back after each.
void
AskAllQuestions(
	int cStrokes,		// Number of strokes in each sample (all must be the same)
	int	cSamples,		// Number of samples of data
	SAMPLE_INFO *pSamples,		// Pointer to samples of data
	void (*pfCallBack)(			// Called after each question
		WORD		questionType,	// e.g. single-point, point/stroke, etc.
		WORD		part1,			// Question constant part 1
		WORD		part2,			// Question constant part 2 
		SAMPLE_INFO *pSamples,
		int cSamples,
		void *pvCallBackControl
	),	
	void *pvCallBackControl		// passed to pfCallBack each time
) {
	int			cPoints			= cStrokes * 2;
	int			ii, jj;
	WORD const	*pQuestionScan;

#if 0
	// List of characters used in recognizer alternate lists.  Code depends on the compiler to zero them!
	typedef struct tagCHAR_USE_LIST {
		int						count;
		struct tagCHAR_USE_LIST	*pNext;
	} CHAR_USE_LIST;

	CHAR_USE_LIST			*pCur, *pNext;
	static CHAR_USE_LIST	*pCharUseList;
	static CHAR_USE_LIST	aCharUseList[cClasses];
#endif

	// Ask all global questions
	for (pQuestionScan = aQuestionListGlobal; *pQuestionScan; ++pQuestionScan) {
		AnswerQuestion(*pQuestionScan, 0, 0, pSamples, cSamples);
		pfCallBack(*pQuestionScan, 0, 0, pSamples, cSamples, pvCallBackControl);
	}

#if 0	// Disable recognizer alt list question
	// Figure out list of characters needed to be checked for recognizer alt list question
	// Note that we depend on the array starting set all zero, and we clear it when we are done.
	for (ii = 0; ii < cSamples; ++ii) {
		for (jj = 0; jj < MAX_RECOG_ALTS; ++jj) {
			pCur	= aCharUseList + pSamples[ii].pSample->awchAlts[jj];
			if (pCur->count == 0) {
				pCur->pNext		= pCharUseList;
				pCharUseList	= pCur;
			}
			pCur->count++;
		}
	}

	// Process each recognizer alt character.
	for (pCur = pCharUseList; pCur; pCur = pCur->pNext) {
		wchar_t		wch;

		wch		= pCur - aCharUseList;
		AnswerQuestion(questionAltList, (WORD)wch, 0, pSamples, cSamples);
		pfCallBack(questionAltList, (WORD)wch, 0, pSamples, cSamples, pvCallBackControl);
	}

	// Clear the used locations.
	for (pCur = pCharUseList; pCur; pCur = pNext) {
		pNext		= pCur->pNext;
		pCur->count	= 0;
		pCur->pNext	= (CHAR_USE_LIST *)0;
	}
	pCharUseList	= (CHAR_USE_LIST *)0;
#endif

	// Process each stroke.
	for (ii = 0; ii < cStrokes; ++ii) {

		// Ask all single-stroke questions
		for (pQuestionScan = aQuestionListByStroke; *pQuestionScan; ++pQuestionScan) {
			AnswerQuestion(*pQuestionScan, (WORD)ii, 0, pSamples, cSamples);
			pfCallBack(*pQuestionScan, (WORD)ii, 0, pSamples, cSamples, pvCallBackControl);
		}

		// Process each point vs. each stroke.
		for (jj = 0; jj < cPoints; ++jj) {
			int		strokePoint;

			// Check for point in current stroke.
			strokePoint		= ii * 2;
			if (jj == strokePoint) {
				// Skip end point as well
				++jj;
				continue;
			}


			// Ask all point/stroke questions
			for (pQuestionScan = aQuestionListByStrokeByPoint; *pQuestionScan; ++pQuestionScan) {
				AnswerQuestion(*pQuestionScan, (WORD)strokePoint, (WORD)jj, pSamples, cSamples);
				pfCallBack(*pQuestionScan, (WORD)strokePoint, (WORD)jj, pSamples, cSamples, pvCallBackControl);
			}
		}

		// Process each stroke vs. every other stroke.
		for (jj = ii + 1; jj < cStrokes; ++jj) {
			int		stroke1Point, stroke2Point;

			// Convert strokes to first point in each.
			stroke1Point	= ii * 2;
			stroke2Point	= jj * 2;

			// Ask all stroke/stroke questions
			for (pQuestionScan = aQuestionListByStrokeByStroke; *pQuestionScan; ++pQuestionScan) {
				AnswerQuestion(*pQuestionScan, (WORD)stroke1Point, (WORD)stroke2Point, 
					pSamples, cSamples);
				pfCallBack(*pQuestionScan, (WORD)stroke1Point, (WORD)stroke2Point, 
					pSamples, cSamples ,pvCallBackControl);
			}
		}

		// Process each stroke range.
		for (jj = ii; jj < cStrokes; ++jj) {
			// Ask all stroke/stroke questions
			for (pQuestionScan = aQuestionListByStrokeRange; *pQuestionScan; ++pQuestionScan) {
				AnswerQuestion(*pQuestionScan, (WORD)ii, (WORD)jj, pSamples, cSamples);
				pfCallBack(*pQuestionScan, (WORD)ii, (WORD)jj, 
					pSamples, cSamples ,pvCallBackControl);
			}
		}
	}

	// Process each point
	for (ii = 0; ii < cPoints; ++ii) {

		// Ask all single-point questions
		for (pQuestionScan = aQuestionListByPoint; *pQuestionScan; ++pQuestionScan) {
			AnswerQuestion(*pQuestionScan, (WORD)ii, 0, pSamples, cSamples);
			pfCallBack(*pQuestionScan, (WORD)ii, 0, pSamples, cSamples ,pvCallBackControl);
		}

		// Process each point vs. each other point.
		for (jj = ii + 1; jj < cPoints; ++jj) {

			// Ask all point-point questions
			for (pQuestionScan = aQuestionListByPointByPoint; *pQuestionScan; ++pQuestionScan) {
				AnswerQuestion(*pQuestionScan, (WORD)ii, (WORD)jj, pSamples, cSamples);
				pfCallBack(*pQuestionScan, (WORD)ii, (WORD)jj, pSamples, cSamples ,pvCallBackControl);
			}
		}
	}

	return;
} // AskAllQuestions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\win2kunicode\makefile.inc ===
# Rules for compiling .cfgs from .xmls
.SUFFIXES: .cfg .h .xml

{..\}.xml{$(O)}.cfg:
    copy $** $(O)
	$(_TPG_ROOT)\Tools\gc.exe -h $*.h $*.xml

# Automatic Registration
!if defined(MAKEDLL) && defined(AUTOREG)
$(TARGETNAME).cpy: $(O)\$(TARGETNAME).dll
    regsvr32 /s $** > $@
!else
$(TARGETNAME).cpy:
    echo File not registered: $** > $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\cranefl.c ===
/***********************************************************************************************\
 * FILE: CraneFl.c
 *
 *	Code to load crane data ( QHEAD and QNODE ) from a file.
\***********************************************************************************************/
#include <stdio.h>
#include "common.h"
#include "crane.h"
#include "cranep.h"

// Load crane data from a file.
BOOL CraneLoadFile(
	LOCRUN_INFO			*pLocRunInfo,
	CRANE_LOAD_INFO		*pLoadInfo,
	wchar_t				*pwchPathName
) {
	HANDLE			hFile, hMap;
	BYTE			*pByte;
	wchar_t			aPath[128];

	// Generate path to file.
	FormatPath(aPath, pwchPathName, (wchar_t *)0, (wchar_t *)0, (wchar_t *)0, L"cart.dat");

	hFile = CreateMappingCall(
		aPath, 
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (hFile == INVALID_HANDLE_VALUE) 
	{
		goto error1;
	}

	// Create a mapping handle
	hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMap == NULL) 
	{
		goto error2;
	}

	// Map the entire file starting at the first byte
	pByte = (BYTE *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if ( !pByte )
	{
		goto error3;
	}

	if ( !CraneLoadFromPointer(pLocRunInfo, gapqhList, gapqnList, pByte) )
	{
		goto error4;
	}

	// Save away the pointers so we can close up cleanly latter
	pLoadInfo->pLoadInfo1 = hFile;
	pLoadInfo->pLoadInfo2 = hMap;
	pLoadInfo->pLoadInfo3 = pByte;

	return TRUE;

	// Error handling
error4:
	UnmapViewOfFile(pByte);
	pByte = NULL;

error3:
	CloseHandle(hMap);
	hMap	= INVALID_HANDLE_VALUE;

error2:
	CloseHandle(hFile);
	hFile	= INVALID_HANDLE_VALUE;

error1:
	pLoadInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pLoadInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pLoadInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return FALSE;
}

BOOL CraneUnLoadFile(CRANE_LOAD_INFO *pInfo)
{
	if (pInfo->pLoadInfo1 == INVALID_HANDLE_VALUE ||
		pInfo->pLoadInfo2 == INVALID_HANDLE_VALUE ||
		pInfo->pLoadInfo3 == INVALID_HANDLE_VALUE) {
		return FALSE;
	}

	UnmapViewOfFile(pInfo->pLoadInfo3);
	CloseHandle(pInfo->pLoadInfo2);
	CloseHandle(pInfo->pLoadInfo1);

	pInfo->pLoadInfo1	= INVALID_HANDLE_VALUE;
	pInfo->pLoadInfo2	= INVALID_HANDLE_VALUE;
	pInfo->pLoadInfo3	= INVALID_HANDLE_VALUE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\tpg\hwx\crane\src\crane.c ===
#include "crane.h"
#include "algo.h"                       // Must include first to get new definitions
#include "common.h"
#include "cranep.h"

QHEAD  *gapqhList[30];
QNODE  *gapqnList[30];

#define FRAME_MAXSTEPS  128

// Index of the four points that make up the bounds of the line in a self relitive 
// bounding box.  We store the index of each point and its offset.

typedef struct BOUNDS {
	int             dX;                             // Delta X and Y of line segment
	int             dY;
	int             iAlongPlus;             // Along the line in plus direction
	int             oAlongPlus;
	int             iAlongMinus;    // Along to the line in minus direction
	int             oAlongMinus;
	int             iAwayPlus;              // Away from the line in plus direction
	int             oAwayPlus;
	int             iAwayMinus;             // Away from the line in minus direction
	int             oAwayMinus;
} BOUNDS;

// Map simple features into index used for two feature map table

static const aMapFeat[] = 
{
	0,      1,      2,      3,      4,      // FEAT_RIGHT,  FEAT_DOWN_RIGHT,        FEAT_DOWN,      FEAT_OTHER,     FEAT_COMPLEX
	5,      5,      5,      5,              // FEAT_CLOCKWISE_4, FEAT_CLOCKWISE_3, FEAT_CLOCKWISE_2, FEAT_CLOCKWISE_1
	6,      6,      6,      6,              // FEAT_C_CLOCKWISE_1, FEAT_C_CLOCKWISE_2, FEAT_C_CLOCKWISE_3, FEAT_C_CLOCKWISE_4
};

// Map two feature features into correct feature codes

static const aMapTwoFeat[7][7]  = 
{
	//      Right                   Down-Right              Down                    Other           Complex            Clockwise    Counter-Clockwise
	{ FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_COMPLEX, FEAT_2F_RI_CW, FEAT_2F_RI_CC }, // Right
	{ FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_COMPLEX, FEAT_2F_DR_CW, FEAT_2F_DR_CC }, // Down-Right
	{ FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_COMPLEX, FEAT_2F_DN_CW, FEAT_2F_DN_CC }, // Down
	{ FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_2F_OTHER, FEAT_COMPLEX, FEAT_2F_OT_CW, FEAT_2F_OT_CC }, // Other
	{ FEAT_COMPLEX,  FEAT_COMPLEX,  FEAT_COMPLEX,  FEAT_COMPLEX,  FEAT_COMPLEX, FEAT_COMPLEX,  FEAT_COMPLEX  }, // Complex
	{ FEAT_2F_CW_RI, FEAT_2F_CW_DR, FEAT_2F_CW_DN, FEAT_2F_CW_OT, FEAT_COMPLEX, FEAT_2F_CW_CW, FEAT_2F_CW_CC }, // Clockwise
	{ FEAT_2F_OTHER, FEAT_2F_CC_DR, FEAT_2F_CC_DN, FEAT_2F_CC_OT, FEAT_COMPLEX, FEAT_2F_CC_CW, FEAT_2F_CC_CC }, // C-Clockwise
};

// Find the points that define the bounding box reletive to the line between
// the start and end points.

void FindBounds(int cXYStart, int cXYEnd, XY *pXY, BOUNDS *pBounds)
{
	int             iXY;
	int             dX, dY;
	BOUNDS  initial;                // Store initial values for later normalization

	ASSERT(cXYStart <= cXYEnd);

// Get delta X and delta Y of (end - start) for our calculations.

	dX      = pXY[cXYEnd].x - pXY[cXYStart].x;
	dY      = pXY[cXYEnd].y - pXY[cXYStart].y;

	if (dX == 0 && dY == 0) 
	{
		dX      = 1;    // If both dX and dY are 0, force dX to be 1 so we have a real line
	}

// Set initial limits.

	initial.dX                      = dX;
	initial.dY                      = dY;
	initial.iAlongPlus      = cXYEnd;
	initial.oAlongPlus      = pXY[cXYEnd].y * dY + pXY[cXYEnd].x * dX;
	initial.iAlongMinus     = cXYStart;
	initial.oAlongMinus     = pXY[cXYStart].y * dY + pXY[cXYStart].x * dX;
	initial.iAwayPlus       = cXYStart;
	initial.oAwayPlus       = pXY[cXYStart].y * dX - pXY[cXYStart].x * dY;
	initial.iAwayMinus      = cXYStart;
	initial.oAwayMinus      = initial.oAwayPlus;

	*pBounds                = initial;

// Now process all the other points to see how they fall relitive to the line between
// the start and the end.

	for (iXY = cXYStart + 1; iXY < cXYEnd; ++iXY) 
	{
		int             along, away;

	// First calculate the along and away offset.

		along   = pXY[iXY].y * dY + pXY[iXY].x * dX;
		away    = pXY[iXY].y * dX - pXY[iXY].x * dY;
		
	// Now see how it compares to the current limits.

		if (along > pBounds->oAlongPlus) 
		{
			pBounds->oAlongPlus             = along;
			pBounds->iAlongPlus             = iXY;
		} 
		else if (along < pBounds->oAlongMinus) 
		{
			pBounds->oAlongMinus    = along;
			pBounds->iAlongMinus    = iXY;
		}

		if (away > pBounds->oAwayPlus) 
		{
			pBounds->oAwayPlus              = away;
			pBounds->iAwayPlus              = iXY;
		} 
		else if (away < pBounds->oAwayMinus) 
		{
			pBounds->oAwayMinus             = away;
			pBounds->iAwayMinus             = iXY;
		}
	}

// Finally normalize the offsets.

	pBounds->oAlongPlus             -= initial.oAlongPlus;
	pBounds->oAlongMinus    -= initial.oAlongMinus;
	pBounds->oAwayPlus              -= initial.oAwayPlus;
	pBounds->oAwayMinus             -= initial.oAwayMinus;

}

// Recursively step line segements
// iRecursion is available for debug/tunning use, and not otherwise used.

void StepLineSegment(int cXYStart, int cXYEnd, XY *pXY, int *pCStep, STEP *rgStep, int iRecursion)
{
	BOUNDS  bounds;
	int             points[6];
	int             ii;
	int             normalize;
	int             ratio;

	// Check for 1 or two point lines.

	if (cXYEnd - cXYStart < 2) 
	{
		int             dX, dY;
		int             deltaAngle;

		ASSERT(cXYEnd >= cXYStart);
		
		if (cXYEnd == cXYStart) 
		{
			ASSERT(cXYStart == 0);          // Only should be passed one point if stroke is one point.
			ASSERT(*pCStep == 0);

		// We have to fake a feature for one point.

			rgStep[*pCStep].length  = 0;
			rgStep[*pCStep].angle   = 0;
			ANGLEDIFF(0, rgStep[*pCStep].angle, deltaAngle);
			rgStep[*pCStep].deltaAngle      = (short)deltaAngle;   // Delta from 0.


			if (*pCStep < FRAME_MAXSTEPS - 1) 
			{
				++*pCStep;
			} 
			else 
			{
				//ASSERT(*pCStep < FRAME_MAXSTEPS - 1);
			}

			rgStep[*pCStep].x       = pXY[cXYEnd].x;
			rgStep[*pCStep].y       = pXY[cXYEnd].y;

			return;
		}

	// Two points always form a line (as long as they arn't the same point).  
	// So go ahead and add it.  Calculate slope times 10 and the direction of
	// segment.  Also length and angle

		dX                                              = pXY[cXYEnd].x - pXY[cXYStart].x;
		dY                                              = pXY[cXYEnd].y - pXY[cXYStart].y;
		rgStep[*pCStep].length  = (short)Distance(dX, dY);
		rgStep[*pCStep].angle   = (short)Arctan2(dY, dX);
		if (*pCStep == 0) 
		{
			ANGLEDIFF(0, rgStep[*pCStep].angle, deltaAngle);
			rgStep[*pCStep].deltaAngle      = (short)deltaAngle;   // Delta from 0.
		} 
		else 
		{
			ANGLEDIFF(rgStep[*pCStep - 1].angle, rgStep[*pCStep].angle, deltaAngle);
			rgStep[*pCStep].deltaAngle      = (short)deltaAngle;   // Delta from last angle
		}


		if (*pCStep < FRAME_MAXSTEPS - 1) 
		{
			++*pCStep;
		} 
		else 
		{
			//ASSERT(*pCStep < FRAME_MAXSTEPS - 1);
		}

		rgStep[*pCStep].x       = pXY[cXYEnd].x;
		rgStep[*pCStep].y       = pXY[cXYEnd].y;

		return;
	}

// Find initial bounds.

	FindBounds(cXYStart, cXYEnd, pXY, &bounds);

// Figure out which points to use as boundries.  Build them up in an array.

	points[0]       = cXYStart;
	ii                      = 1;

// Start with 'along' points.  We assume any extent in the 'along' direction 
// requires new points.

	if (bounds.iAlongMinus != cXYStart) 
	{
		points[ii++]    = bounds.iAlongMinus;
	}
	if (bounds.iAlongPlus != cXYEnd) 
	{
		points[ii++]    = bounds.iAlongPlus;
	}

// Now the 'away' points.  These require a minimum ratio to be selected.
// Since the ration is usually a fraction, and we want to handle integers,
// multiply by 1000.

	normalize       = bounds.dX * bounds.dX + bounds.dY * bounds.dY;
	normalize		= max(1,normalize);
	ratio           = (bounds.oAwayPlus * 1000) / normalize;
	if (ratio >= 180)               // Ratio > ??
	{
		points[ii++]    = bounds.iAwayPlus;
	}

	ratio           = -(bounds.oAwayMinus * 1000) / normalize;
	if (ratio >= 180)               // Ratio > ??
	{       
		points[ii++]    = bounds.iAwayMinus;
	}

// See if we need to recurse or not.

	if (ii == 1) 
	{
		int             deltaAngle;

	// We have a straight line.  Add the end point, and we are done with this path down.
	// Calculate slope times 10 and the direction of segment

		rgStep[*pCStep].length          = (short)Distance(bounds.dX, bounds.dY);
		rgStep[*pCStep].angle           = (short)Arctan2(bounds.dY, bounds.dX);
		if (*pCStep == 0) 
		{
			ANGLEDIFF(0, rgStep[*pCStep].angle, deltaAngle);
			rgStep[*pCStep].deltaAngle      = (short)deltaAngle;   // Delta from 0.
		} 
		else 
		{
			ANGLEDIFF(rgStep[*pCStep - 1].angle, rgStep[*pCStep].angle, deltaAngle);
			rgStep[*pCStep].deltaAngle      = (short)deltaAngle;   // Delta from last angle
		}

		if (*pCStep < FRAME_MAXSTEPS - 1) 
		{
			++*pCStep;
		} 
		else 
		{
			//ASSERT(*pCStep < FRAME_MAXSTEPS - 1);
		}

		rgStep[*pCStep].x       = pXY[cXYEnd].x;
		rgStep[*pCStep].y       = pXY[cXYEnd].y;
	} 
	else 
	{
		int             jj;

	// Have at least two sub-segments, process them.  First sort into index order.
    // Note that start point is already in the correct position.

        //
        // privsort(points + 1, ii - 1);
        //
        // The following code replaces the call to privsort because
        // it's such a tiny array (5 or less I think) and privsort is so big.
        //

        {
            int bSort;

            do
            {
                bSort = FALSE;

                for (jj = 1; jj < ii - 1; jj++)
                {
                    if (points[jj] > points[jj + 1])
                    {
                        int tmp;

                        tmp = points[jj];
                        points[jj] = points[jj + 1];
                        points[jj + 1] = tmp;
                        bSort = TRUE;
                    }
                }

            } while (bSort);
        }

	// Add end point, it will also be automatically in the correct position.

		points[ii]      = cXYEnd;

	// Sequence through each adjacent pair of point to process the segments.

		for (jj = 0; jj < ii; ++jj) 
		{
			// We can have duplicate points, ignore them.
			if (points[jj] != points[jj + 1]) 
			{
				StepLineSegment(points[jj], points[jj + 1], pXY, pCStep, rgStep, iRecursion + 1);
			}
		}
	}
}

// Remove the 'splash' of random points sometimes caused by pen down or pen up.

UINT RemovePenNoise(XY *rgxy, UINT cxy, BOOL fBegin, UINT ixyStop)
{
	UINT    ixy;
	int             dx, dy;
	BOOL    fSmall;
	UINT    ixyEnd;

	ixyEnd  = cxy - 1;

// Limit splash zone if the stroke is smaller than 4 times the normal splash zone.

	dx      = rgxy[0].x - rgxy[ixyEnd].x;
	dy      = rgxy[0].y - rgxy[ixyEnd].y;
	dx      /= 4;
	dy      /= 4;
	fSmall  = LineInSplash(dx, dy) ? 1 : 0;

	if (fBegin) 
	{
		for (ixy = 0; ixy < ixyStop; ixy++) 
		{
			dx      = rgxy[ixy].x - rgxy[ixy + 1].x;
			dy      = rgxy[ixy].y - rgxy[ixy + 1].y;
			if (!LineSmall(dx, dy)) 
			{
			// Next jump is too big to just remove, check distance from start point.

				dx      = rgxy[0].x - rgxy[ixy + 1].x;
				dy      = rgxy[0].y - rgxy[ixy + 1].y;
				if (fSmall || !LineInSplash(dx, dy)) 
				{
					// Doesn't fall in splash zone.
					break;
				}
			}
		}
	} 
	else 
	{
		for (ixy = ixyEnd; ixy > ixyStop; ixy--) 
		{
			dx      = rgxy[ixy].x - rgxy[ixy - 1].x;
			dy      = rgxy[ixy].y - rgxy[ixy - 1].y;
			if (!LineSmall(dx, dy)) 
			{
			// Next jump is too big to just remove, check distance from end point.

				dx      = rgxy[ixyEnd].x - rgxy[ixy - 1].x;
				dy      = rgxy[ixyEnd].y - rgxy[ixy - 1].y;
				if (fSmall || !LineInSplash(dx, dy)) 
				{
					// Doesn't fall in splash zone.
					break;
				}
			}
		}
	}

	return(ixy);
}

UINT DebounceStrokePoints(XY *rgxy, UINT cxy)
{
	UINT iBounceBegin, iBounceEnd;

	// Verify that we have enough points that we can debounce.
	if (cxy < 3) {
		return(cxy);
	}

	// Remove pen noise from pen-down and pen-up
	iBounceBegin	= RemovePenNoise(rgxy, cxy, TRUE, cxy - 2);
	iBounceEnd		= RemovePenNoise(rgxy, cxy, FALSE, iBounceBegin + 1);

	if (iBounceBegin > 0 || iBounceEnd < cxy - 1) 
	{
		ASSERT(iBounceBegin < iBounceEnd);
		ASSERT(iBounceEnd < cxy);

		cxy = iBounceEnd - iBounceBegin + 1;
		memmove((VOID *)rgxy, (VOID *)(&rgxy[iBounceBegin]), sizeof(XY) * cxy);
	}

	return(cxy);
}

int StepsFromFRAME(FRAME *frame, STEP *rgStep, int cstepmax)
{
	int             cStep;
	int             cXY;
	XY              *pXY;

// Get pointer to data and count of points

	cXY     = frame->info.cPnt;
	pXY     = frame->rgrawxy;

// If a previous recognizer used this buffer, release it first

	if (frame->rgsmoothxy)
		ExternFree(frame->rgsmoothxy);

// Smoothing has been replaced by de-splashing. JRB: Clean up to call de-splash directly.

	frame->rgsmoothxy       = (XY *) ExternAlloc(cXY * sizeof(XY));
	if (frame->rgsmoothxy == (XY *) NULL)
		return 0;

	memcpy(frame->rgsmoothxy, pXY, cXY * sizeof(XY));
	frame->csmoothxy        = cXY;
	frame->csmoothxy = DebounceStrokePoints(frame->rgsmoothxy, frame->csmoothxy);
	cXY     = frame->csmoothxy;
	pXY     = frame->rgsmoothxy;

// Recursivly segment the line. 

	cStep   = 0;
	rgStep[0].x             = pXY[0].x;
	rgStep[0].y             = pXY[0].y;
	StepLineSegment(0, cXY - 1, pXY, &cStep, rgStep, 0);

	return(cStep);
}

// Convert an angle into a feature.

BYTE Code(int angle)
{
	if (angle < 12) 
		return FEAT_RIGHT;
	else if (angle < 70) 
		return FEAT_DOWN_RIGHT;
	else if (angle < 160) 
		return FEAT_DOWN;
	else if (angle < 300) 
		return FEAT_OTHER;      // very rare directions
	else 
		return FEAT_RIGHT;
}

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// We set this to 0xFF, this should be changed if the number of valid codes is excpected
// to be more than 255
#define FEATURE_NULL        0xFF    // avoid any valid code.
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

// Convert steps into first pass at features.
// Note that cFrame is not used.
// JRB: Rewrite so that we just create one feature, instead of creating many and undoing it!!!

VOID AddStepsKPROTO(KPROTO *pKProto, STEP *rgStep, int cStep, int cFrame, FRAME *frame)
{
	int         iStep;          // Step being processed 
	int         cFeat;          // Count of features so far in character
	int         iStartStep;     // Start of current feature.
	int         iEndStep;       // Current quess at end of step.
	int         cumAngle;       // Cumulitive change in angle for the current feature.
	int         netAngle;       // Net angle traversed by stroke (sum of step angles)
	int         absAngle;       // Total angle of stroke (sum of abs. val. of step angles)
	int			nLength;		// Total length of stroke
	int         x, y;
    PRIMITIVE  *pFeat = NULL;

    ASSERT(cStep > 0);

// Spot to add next feature.

	cFeat           = pKProto->cfeat;
	pFeat           = (PRIMITIVE *)0;

// Loop over all the steps finding features and gathering information about them.

	iStartStep      = 0;
	iEndStep        = 0;
	x               = rgStep[0].x;
	y               = rgStep[0].y;
	netAngle        = 0;
	absAngle        = 0;
	nLength			= 0;

	for (iStep = 0; iStep < cStep; iStep++) 
	{
		// Handle start of a feature.

		if (iStep == iEndStep) 
		{
		// Get pointer to feature structure.
	
			pFeat = &(pKProto->rgfeat[cFeat]);

		// The array of primitives is CPRIMMAX in size so
		// the largest index it can handle is (CPRIMMAX-1).

			if (cFeat < (CPRIMMAX - 1)) 
			{
				cFeat++;
			} 
			else 
			{
				//ASSERT(cFeat < (CPRIMMAX - 1));
			}

		// Record start of feature as initial point or end of last feature.

			pFeat->x1       = (short)x;
			pFeat->y1       = (short)y;

		// Feature not known yet

			pFeat->code = FEATURE_NULL;

		// Default to making feature the rest of the line.

			iStartStep      = iStep;
			iEndStep        = cStep;
			cumAngle        = 0;
		}
		
		ASSERT(pFeat);

	// End of current step

		x       = rgStep[iStep + 1].x;
		y       = rgStep[iStep + 1].y;

	// Add the step length to the total length

		nLength += Distance(x - rgStep[iStep].x, y - rgStep[iStep].y);

	// If not first step in this feature, add angle from last step.

		if (iStep > iStartStep) 
		{
			cumAngle        += rgStep[iStep].deltaAngle;
		}

	// If not first step, add angle from last step.

		if (iStep > 0) 
		{
			netAngle        += rgStep[iStep].deltaAngle;
			if (rgStep[iStep].deltaAngle >= 0) 
			{
				absAngle        += rgStep[iStep].deltaAngle;
			} 
			else 
			{
				absAngle        -= rgStep[iStep].deltaAngle;
			}
		}

	// Decide if we need to split and start a new step.  Can only be an inflection
	// if there are at least three segements left.  Also if we are already breaking after
	// this step, we shouldn't check until we are past the break.

		if (cStep - iStep >= 3 && iEndStep != iStep + 1) 
		{
			int             angle1_2, angle2_3;

		// Figure angles between first & second segments and second & third segments.

			angle1_2        = rgStep[iStep + 1].deltaAngle;
			angle2_3        = rgStep[iStep + 2].deltaAngle;

		// Should never have two consecutive steps with exactly the same angle.

//                      ASSERT(angle1_2 != 0);
//                      ASSERT(angle2_3 != 0);

		// Are they in different directions?  E.g. are signs different.
		// JRB: What about 180 or angles close to it?

			if (angle1_2 * angle2_3 < 0) 
			{
				int             abs1_2, abs2_3;

			// We have an inflection, which side do we break on?  First get absolute
			// value of both angles.

				if (angle1_2 < 0) 
				{
					abs1_2  = -angle1_2;
					abs2_3  = angle2_3;
				} 
				else 
				{
					abs1_2  = angle1_2;
					abs2_3  = -angle2_3;
				}

			// Now which is larger (e.g. tighter turn)

				if (abs1_2 >= abs2_3) 
				{
					iEndStep        = iStep + 1;            // First is tighter, break there.
				} 
				else 
				{
					iEndStep        = iStep + 2;            // Second is tighter, break there.
				}
			}

		}

	// Handle end of a feature.

		if (iStep == iEndStep - 1) 
		{
			int             dX, dY;

		// Record end of feature.

			pFeat->x2       = (short)x;
			pFeat->y2       = (short)y;

		// Figure out feature code.

			if (cumAngle == 0) 
			{
				pFeat->code = Code(rgStep[iStep].angle);        // Streight line
			} 
			else if (cumAngle > 0) 
			{
			// Clockwise, how strong?

				if (cumAngle >= 390) 
				{
					pFeat->code     = FEAT_COMPLEX;
				} 
				else if (cumAngle >= 300) 
				{
					pFeat->code     = FEAT_CLOCKWISE_4;
				} 
				else if (cumAngle >= 182) 
				{
					pFeat->code     = FEAT_CLOCKWISE_3;
				} 
				else if (cumAngle >= 120) 
				{
					pFeat->code     = FEAT_CLOCKWISE_2;
				} 
				else if (cumAngle >= 38) 
				{
					pFeat->code     = FEAT_CLOCKWISE_1;
				} 
				else 
				{
					// Close enough to streight.
					dX                              = pFeat->x2 - pFeat->x1;
					dY                              = pFeat->y2 - pFeat->y1;
					pFeat->code     = Code(Arctan2(dY, dX));
				}
			} 
			else    // cumAngle < 0
			{ 
				// Counter clockwise, how strong?
				if (cumAngle <= -360) 
				{
					pFeat->code     = FEAT_COMPLEX;
				} 
				else if (cumAngle <= -182) 
				{
					pFeat->code     = FEAT_C_CLOCKWISE_4;
				} 
				else if (cumAngle <= -115) 
				{
					pFeat->code     = FEAT_C_CLOCKWISE_3;
				} 
				else if (cumAngle <= -60) 
				{
					pFeat->code     = FEAT_C_CLOCKWISE_2;
				} 
				else if (cumAngle <= -38) 
				{
					pFeat->code     = FEAT_C_CLOCKWISE_1;
				} 
				else 
				{
					// Close enough to streight.
					dX                              = pFeat->x2 - pFeat->x1;
					dY                              = pFeat->y2 - pFeat->y1;
					pFeat->code     = Code(Arctan2(dY, dX));
				}
			}
		}
	}
	
	ASSERT(pFeat->code != FEATURE_NULL);

// Map multi-feature strokes down to a single feature.

	pFeat               = &(pKProto->rgfeat[pKProto->cfeat]);
	pFeat->cFeatures    = cFeat - pKProto->cfeat;
	pFeat->cSteps       = (BYTE)cStep;
	pFeat->fDakuTen     = 0;
	pFeat->nLength		= nLength;
	pFeat->netAngle     = netAngle;
	pFeat->absAngle     = absAngle;
	pFeat->boundingBox  = *RectFRAME(frame);
	switch (pFeat->cFeatures) {
		case 0 :        case 1 :
			// Zero or one feature. Zero should not actually happen, but if it does ...
			goto hadSingle;

		case 2 : {
			BYTE    feat0, feat1;

			// Two features, look up what the replacement feature is.
			feat0                   = pFeat[0].code;
			feat1                   = pFeat[1].code;
			pFeat->code     = (BYTE)aMapTwoFeat[aMapFeat[feat0]][aMapFeat[feat1]];
			break;
		}

		case 3 : {
			BYTE    feat0, feat1, feat2;

			// A few special cases, otherwise call it complex.
			feat0   = pFeat[0].code;
			feat1   = pFeat[1].code;
			feat2   = pFeat[2].code;
			switch (aMapFeat[feat0]) {
				case 0 :        // Right
					switch (aMapFeat[feat1]) {
						case 3 :        // Down
							pFeat->code     = (aMapFeat[feat2] == 5) 
								? FEAT_3F_RI_DN_CW : FEAT_COMPLEX;      // Clockwise
							break;

						case 5 :        // Clockwise
							pFeat->code     = (feat2 == FEAT_DOWN) 
								? FEAT_3F_RI_CW_DN : FEAT_COMPLEX;      // Down
							break;

						case 6 :        // Counter clockwise
							pFeat->code     = (feat2 == FEAT_DOWN) // Down
								? FEAT_3F_RI_CC_DN 
								: (aMapFeat[feat2] == 5) 
									? FEAT_3F_RI_CC_CW : FEAT_COMPLEX;      // Clockwise
							break;

						default :
							pFeat->code     = FEAT_COMPLEX;
							break;
					}
					break;

				case 2 :        // Down
					if (feat1 == FEAT_RIGHT) {      // Right
						// Counter clockwise
						pFeat->code     = (aMapFeat[feat2] == 6) 
							? FEAT_3F_DN_RI_CC : FEAT_COMPLEX;
					} else if (aMapFeat[feat1] == 5) {      // Clockwise
						switch (aMapFeat[feat2]) {
							case 0 :        pFeat->code     = FEAT_3F_DN_CW_RI;     break;  // Right
							case 5 :        pFeat->code     = FEAT_3F_DN_CW_CW;     break;  // Clockwise
							case 6 :        pFeat->code     = FEAT_3F_DN_CW_CC;     break;  // Counter clockwise
							default :       pFeat->code     = FEAT_COMPLEX;         break;
						}
					} else {
						pFeat->code     = FEAT_COMPLEX;
					}
					break;

				case 5 :        // Clockwise
					// Any and Clockwise
					pFeat->code     = (aMapFeat[feat2] == 5) 
						? FEAT_3F_CW_XX_CW : FEAT_COMPLEX;
					break;

				case 6 :        // Counter Clockwise
					// Clockwise and Right
					pFeat->code     = (aMapFeat[feat1] == 5 && feat2 == FEAT_RIGHT) 
						? FEAT_3F_CC_CW_RI : FEAT_COMPLEX;
					break;

				default:
					pFeat->code     = FEAT_COMPLEX;
			}
		}

		default:
			// Anything else (> 3) is always complex.
			pKProto->rgfeat[cFeat].code     = FEAT_COMPLEX;
			break;
	}

	// Actually merge the position information and fix cFeat.
	pFeat->x2       = pKProto->rgfeat[cFeat - 1].x2;
	pFeat->y2       = pKProto->rgfeat[cFeat - 1].y2;
	cFeat   = pKProto->cfeat + 1;

hadSingle:      // Jump here to skip merging of features.

	// Record number of features after our additions.
	pKProto->cfeat = (WORD)cFeat;
}

// Clean up the stepped stroke. cFrame is not used.

int CraneSmoothSteps(STEP *rgStep, int cStep, int cFrame)
{
	int             ii;
	int             cRemove;
	int             totalLength, hookLength;
	int             maxLength, maxSegment;
	int             length;
	int             lengths[6];             // First three and last three segment lengths. JRB: already calculated

// Make sure we have enough segments to think about removing some.

	if (cStep < 2) 
	{
		return cStep;   // Only one segment, don't want to remove it.
	} 
	else if (cStep == 2) 
	{
		int             percentLength;
		int             angle;
		int             partA, partB;
		int             experA, experB;

	// Special processing for two step strokes.  The only thing we may do
	// is drop one of the steps.  We calculate the length of the first step
	// as a percent of the total line length. We also calculate the angle
	// between the lines.  This gives us a rectangle with the ranges,
	// percentLength 0 - 100 and angle -179 to 180.  We want to find if
	// this sample falls in one of the four corners of this that indicates 
	// an extranious hook.  The four lines (and there equations) we use are:
	//              Lower left              -180,  40       ->      -30,   0                -- angle, percentLength
	//              Lower right              180,  40       ->       30,   0
	//              Upper left              -180,  60       ->      -30, 100
	//              Upper right              180,  60       ->       30, 100
	//      The matching formulas for the areas beyound the lines are:
	//              Lower left              4 * angle + 15 * percentLength <= - 120
	//              Lower right             4 * angle - 15 * percentLength >=   120
	//              Upper left              4 * angle - 15 * percentLength <= -1620
	//              Upper right             4 * angle + 15 * percentLength >=  1620
		
		totalLength             = rgStep[0].length + rgStep[1].length;
		percentLength   = (rgStep[0].length * 100) / totalLength;
		angle                   = rgStep[1].deltaAngle;

	// Precalculate the pieces.

		partA   = 4 * angle;
		partB   = 15 * percentLength;
		experA  = partA + partB;
		experB  = partA - partB;

	// Looks OK, keep both segments.
	// Test the two corners that indicate the first segment is two small.
	// Then test the other two, to check the second segment.

		if (experA <= -120 || experB >= 120) 
		{ 
		// Delete the first segment.

			rgStep[0]       = rgStep[1];
			rgStep[1]       = rgStep[2];

			return 1;
		} 
		else if (experB <= -1620 || experA >= 1620) 
		{
		// Delete the second segment.

			return 1;                       
		}

		return 2;
	}

// Check for hooks.

	totalLength     = 0;
	maxLength       = 0;
	maxSegment      = -1;
	for (ii = 0; ii < cStep; ++ii) 
	{
		int             fromEnd;

	// Figure segment length

		length                  = rgStep[ii].length;

	// Keep track of longest segment.

		if (maxLength < length) 
		{
			maxLength       = length;
			maxSegment      = ii;
		}

	// Sum all segment lengths.

		totalLength     += length;

	// Record the lengths that we will need later.

		if (ii < 3) 
		{
			lengths[ii]                     = length;
		}
		fromEnd = cStep - 1 - ii;
		if (fromEnd < 3) 
		{
			lengths[5 - fromEnd]            = length;
		}
	}

// Check for a streight line with small curves at one or both ends.

	ASSERT(maxSegment >= 0);
	if ((maxLength * 100) / totalLength > 80) 
	{
	// throw away all other segments.

		rgStep[0]       = rgStep[maxSegment];
		rgStep[1]       = rgStep[maxSegment + 1];

		return 1;
	}

// Try to find hook at the end.  First try to remove two segments.

	cRemove = 0;
	if (cStep >= 3) 
	{
		hookLength      = lengths[5] + lengths[4];

		if (hookLength * 10 < totalLength) 
		{
			cRemove = 2;
		}
	}

// If we couldn't remove two segments, try one.

	if (cRemove == 0 && lengths[5] * 10 < totalLength) 
	{
		cRemove = 1;
	}

// Drop points at the end as needed.  Verify that there are enough points to continue.

	cStep   -= cRemove;
	if (cStep < 2) 
	{
		return cStep;           // Only one segment left.
	} 
	
// Try to find hook at the start.  First try to remove two segments.

	cRemove = 0;
	if (cStep >= 3) 
	{
		hookLength      = lengths[0] + lengths[1];

		if (hookLength * 10 < totalLength) 
		{
			cRemove = 2;
		}
	}

// If we couldn't remove two segments, try one.

	if (cRemove == 0 && lengths[0] * 10 < totalLength) 
	{
		cRemove = 1;
	}

// Remove extra steps from start of array.

	if (cRemove > 0) 
	{
		int             from, to;

		to              = 0;
		from    = cRemove;
		while (from <= cStep) 
		{
			rgStep[to++]    = rgStep[from++];
		}

		cStep           -= cRemove;
	}

	return cStep;
}

int IsDakuten(RECT *pBoundingBox, FRAME *pFrame1, FRAME *pFrame2, KPROTO *pKProto)
{
	int                     cXY;
	XY                      *pXY;
	int                     x1_1, y1_1, x2_1, y2_1;         // Start and end of first stroke.
	int                     x1_2, y1_2, x2_2, y2_2;         // Start and end of second stroke.
	int                     x1Per, y1Per, x2Per, y2Per;
	int                     dX, dY;
	int                     cFeat;
    PRIMITIVE   *pFeat;

	// Figure size of bounding box.
	dX      = pBoundingBox->right - pBoundingBox->left;
	dY      = pBoundingBox->bottom - pBoundingBox->top;

	// Get pointer to data and count of points of first stroke.
	cXY     = pFrame1->info.cPnt;
	pXY     = pFrame1->rgrawxy;

	// Get end points
	x1_1    = pXY[0].x;
	y1_1    = pXY[0].y;
	x2_1    = pXY[cXY - 1].x;
	y2_1    = pXY[cXY - 1].y;

	// Get pointer to data and count of points of second stroke.
	cXY     = pFrame2->info.cPnt;
	pXY     = pFrame2->rgrawxy;

	// Get end points
	x1_2    = pXY[0].x;
	y1_2    = pXY[0].y;
	x2_2    = pXY[cXY - 1].x;
	y2_2    = pXY[cXY - 1].y;

	// Sometimesd strokes are reveresed.
	if (x1_1 > x1_2 && x2_1 > x2_2) {
		// Try switching strokes.
		return IsDakuten(pBoundingBox, pFrame2, pFrame1, pKProto);
	}

	// Get end positions relitive to the upper right corner of the bounding box.
	// Scale by 100 so we can get percents as integers.
	x1Per   = ((pBoundingBox->right - x1_1) * 100) / dX;
	y1Per   = ((y1_1 - pBoundingBox->top) * 100) / dY;
	x2Per   = ((pBoundingBox->right - x2_1) * 100) / dX;
	y2Per   = ((y2_1 - pBoundingBox->top) * 100) / dY;
	
	// Check if end points match expected locations for first stroke.
	if (x1Per > 70 || y1Per > 40 || x2Per > 60 || y2Per > 60) {
		// First stroke wrong position.
		return FALSE;
	}

	// Compare relitive positions of strokes.
	x1Per   = ((x1_2 - x1_1) * 100) / dX;
	y1Per   = ((y1_2 - y1_1) * 100) / dY;
	x2Per   = ((x2_2 - x2_1) * 100) / dX;
	y2Per   = ((y2_2 - y2_1) * 100) / dY;
	if (x1Per <= 0 || 50 <= x1Per || y1Per <= -30 || 25 <= y1Per
		|| x2Per <= 0 || 55 <= x2Per || y2Per <= -35 || 30 <= y2Per
	) {
		// Reletive positions of the strokes wrong.
		return FALSE;
	}

	// Get end positions relitive to the upper right corner of the bounding box.
	// Scale by 100 so we can get percents as integers.
	x1Per   = ((pBoundingBox->right - x1_2) * 100) / dX;
	y1Per   = ((y1_2 - pBoundingBox->top) * 100) / dY;
	x2Per   = ((pBoundingBox->right - x2_2) * 100) / dX;
	y2Per   = ((y2_2 - pBoundingBox->top) * 100) / dY;
		
	// Check if end points match expected locations for second stroke.
	if (x1Per > 40 || y1Per > 45 || x2Per > 25 || y2Per > 55) {
		// Second stroke wrong position.
		return FALSE;
	}

	{
		BOUNDS  bounds;
		int             normalize;
		int             ratioPlus, ratioMinus;

		// End point tests pass, verify that we really have stokes that look mostly like lines.
		// We ignore the along direction because that does not seem to be a problem
		// We keep the away in loose bound since we only need to catch ones way out of line.
		// Since the ratio is usually a fraction, and we want to handle integers,
		// multiply by 1000.
		// Note that for very small lines, we don't care what the look like.
		FindBounds(0, pFrame1->info.cPnt - 1, pFrame1->rgrawxy, &bounds);
		if (bounds.dX > 20 || bounds.dX < -20 || bounds.dY > 20 || bounds.dY < -20) {           // Is it large?
			normalize       = bounds.dX * bounds.dX + bounds.dY * bounds.dY;
			normalize		= max(1,normalize);
			ratioPlus       = (bounds.oAwayPlus * 1000) / normalize;
			ratioMinus      = -(bounds.oAwayMinus * 1000) / normalize;
			if (ratioPlus >= 1000 || ratioMinus >= 1000) {  // Ratio > 1/1
				return FALSE;
			}
		}

		FindBounds(0, pFrame2->info.cPnt - 1, pFrame2->rgrawxy, &bounds);
		if (bounds.dX > 20 || bounds.dX < -20 || bounds.dY > 20 || bounds.dY < -20) {           // Is it large?
			normalize       = bounds.dX * bounds.dX + bounds.dY * bounds.dY;
			normalize		= max(1,normalize);
			ratioPlus       = (bounds.oAwayPlus * 1000) / normalize;
			ratioMinus      = -(bounds.oAwayMinus * 1000) / normalize;
			if (ratioPlus >= 1000 || ratioMinus >= 1000) {  // Ratio > 1/1
				return FALSE;
			}
		}
	}

	// Passes all the test.  So add the two stokes to the feature list.
	cFeat           = pKProto->cfeat;

	//// Handle first stroke

	// The array of primitives is CPRIMMAX in size so
	// the largest index it can handle is (CPRIMMAX-1).
	pFeat           = &(pKProto->rgfeat[cFeat]);
	if (cFeat < (CPRIMMAX - 1)) {
		cFeat++;
	} else {
		//ASSERT(cFeat < (CPRIMMAX - 1));
	}

	// Record start & end of feature.
	pFeat->x1       = (short)x1_1;
	pFeat->y1       = (short)y1_1;
	pFeat->x2       = (short)x2_1;
	pFeat->y2       = (short)y2_2;

	// Feature is small down right.
	pFeat->code = FEAT_DOWN_RIGHT;

	// Record CART info
	pFeat->cFeatures    = 1;
	pFeat->cSteps       = 1;
	pFeat->fDakuTen     = 1;
	pFeat->nLength		= Distance(pFeat->x2 - pFeat->x1, pFeat->y2 - pFeat->y1);
	pFeat->netAngle     = 0;
	pFeat->absAngle     = 0;
	pFeat->boundingBox  = *RectFRAME(pFrame1);

	/// Now on to stroke two 

	// The array of primitives is CPRIMMAX in size so
	// the largest index it can handle is (CPRIMMAX-1).
	pFeat           = &(pKProto->rgfeat[cFeat]);
	if (cFeat < (CPRIMMAX - 1)) {
		cFeat++;
	} else {
		//ASSERT(cFeat < (CPRIMMAX - 1));
	}

	// Record start & end of feature.
	pFeat->x1       = (short)x1_2;
	pFeat->y1       = (short)y1_2;
	pFeat->x2       = (short)x2_2;
	pFeat->y2       = (short)y2_2;

	// Feature is small down right.
	pFeat->code = FEAT_DOWN_RIGHT;

	// Record number of features after our additions.
	pKProto->cfeat = (WORD)cFeat;

	// Record CART info
	pFeat->cFeatures    = 1;
	pFeat->cSteps       = 1;
	pFeat->fDakuTen     = 1;
	pFeat->nLength		= Distance(pFeat->x2 - pFeat->x1, pFeat->y2 - pFeat->y1);
	pFeat->netAngle     = 0;
	pFeat->ab