reserved
    52:48 MVID[4:0] Maximum 5-bit VID
    63:53 reserved

    _PSS Status Field:
    
    Bit   Name
    ----  ----
     4:0  FID current frequency
     9:5  VID current voltage
    31:10 reserved


--*/
{
  PSS_STATUS     pssStatus;
  FID_VID_STATUS fidVidStatus;

  //DebugEnter();
  DebugAssert(FidVidStatusValue);

  fidVidStatus.AsQWord = FidVidStatusValue;
  pssStatus.Fid = fidVidStatus.CFid;
  pssStatus.Vid = fidVidStatus.CVid;
  pssStatus.Reserved = 0;
  
  return pssStatus.AsDWord;
  
}


NTSTATUS
FindCurrentPssPerfState(
  PACPI_PSS_PACKAGE PssPackage,
  PULONG PssState
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  NTSTATUS status = STATUS_UNSUCCESSFUL;
  ULONG    x;
  ULONG    transitionStatus;
  ULONG64  fidVidStatus;

  DebugEnter();
  DebugAssert(PssPackage);
  DebugAssert(PssState);
  
  fidVidStatus = ReadMSR(AMDK7_FID_VID_STATUS_MSR);
  transitionStatus = ConvertFidVidStatusToPssStatus(fidVidStatus);

  for (x=0; x < PssPackage->NumPStates; x++) {
   
    if (transitionStatus == PssPackage->State[x].Status) {
      status = STATUS_SUCCESS;
      *PssState = x;
      break;
    }

  }

  DebugExitStatus(status);
  return status;
  
}


#if DBG
VOID
DumpFidVidStatus(
  IN ULONG64 FidVidStatus
  )
{
  FID_VID_STATUS status;

  status.AsQWord = FidVidStatus;

  DebugPrint((MAXTRACE, "  CFid:         0x%x\n", status.CFid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", status.Reserved1));
  DebugPrint((MAXTRACE, "  SFid:         0x%x\n", status.SFid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", status.Reserved2));
  DebugPrint((MAXTRACE, "  MFid:         0x%x\n", status.MFid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", status.Reserved3));
  DebugPrint((MAXTRACE, "  CVid:         0x%x\n", status.CVid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", status.Reserved4));
  DebugPrint((MAXTRACE, "  SVid:         0x%x\n", status.SVid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", status.Reserved5));
  DebugPrint((MAXTRACE, "  MVid:         0x%x\n", status.MVid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", status.Reserved6));
  DebugPrint((MAXTRACE, "\n"));

}


VOID
DumpFidVidControl(
  IN ULONG64 FidVidControl
  )
{
  FID_VID_CONTROL control;

  control.AsQWord = FidVidControl;

  DebugPrint((MAXTRACE, "  Fid:          0x%x\n", control.Fid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", control.Reserved1));
  DebugPrint((MAXTRACE, "  Vid:          0x%x\n", control.Vid));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", control.Reserved2));
  DebugPrint((MAXTRACE, "  FidControl:   0x%x\n", control.FidControl));
  DebugPrint((MAXTRACE, "  VidControl:   0x%x\n", control.VidControl));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", control.Reserved3));
  DebugPrint((MAXTRACE, "  FidChngRatio: 0x%x\n", control.FidChngRatio));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", control.Reserved4));
  DebugPrint((MAXTRACE, "  SGTC:         0x%x\n", control.SGTC));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", control.Reserved5));
  DebugPrint((MAXTRACE, "\n"));

}


VOID
DumpPssStatus(
  IN ULONG PssStatus
  )
{
  PSS_STATUS status;

  status.AsDWord = PssStatus;

  DebugPrint((MAXTRACE, "  Fid:         0x%x\n", status.Fid));
  DebugPrint((MAXTRACE, "  Vid:         0x%x\n", status.Vid));
  DebugPrint((MAXTRACE, "  Reserved:    0x%x\n", status.Reserved));
  DebugPrint((MAXTRACE, "\n"));
  
}


VOID
DumpPssControl(
  IN ULONG PssControl
  )
{
  PSS_CONTROL control;

  control.AsDWord = PssControl;

  DebugPrint((MAXTRACE, "  Fid:          0x%x\n", control.Fid));
  DebugPrint((MAXTRACE, "  Vid:          0x%x\n", control.Vid));
  DebugPrint((MAXTRACE, "  SGTC:         0x%x\n", control.SGTC));
  DebugPrint((MAXTRACE, "  Reserved:     0x%x\n", control.Reserved));
  DebugPrint((MAXTRACE, "\n"));
  
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk7\amdk7.h ===
/*++

  Copyright (c) 2000  Microsoft Corporation
  
  Module Name:
  
    amdk7.h
  
  Author:
  
    Todd Carpenter (1/30/01) - create file
  
  Environment:
  
    Kernel mode
  
  Notes:
  
  Revision History:

--*/
#ifndef _AMDK7_H
#define _AMDK7_H

#define AMDK7_PARAMETERS_KEY      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\AmdK7\\Parameters"
#define ENABLE_LEGACY_INTERFACE   0x1

#define AMDK7_FID_VID_CONTROL_MSR            0xC0010041
#define AMDK7_FID_VID_STATUS_MSR             0xC0010042

#define AmdK7FidVidTransition(_x_) \
  WriteMSR(AMDK7_FID_VID_CONTROL_MSR, _x_);


typedef struct {
  union {
    struct {
      ULONG  Fid:5;          // 4:0
      ULONG  Reserved1:3;    // 7:5
      ULONG  Vid:5;          // 12:8
      ULONG  Reserved2:3;    // 15:13
      ULONG  FidControl:1;   // 16
      ULONG  VidControl:1;   // 17
      ULONG  Reserved3:2;    // 19:18
      ULONG  FidChngRatio:1; // 20
      ULONG  Reserved4:11;   // 31:21
      ULONG  SGTC:20;        // 51:32
      ULONG  Reserved5:12;   // 63:52
    };
    ULONG64 AsQWord;
  };
} FID_VID_CONTROL, *PFID_VID_CONTROL;

typedef struct {
  union {
    struct {
      ULONG  CFid:5;      // 4:0   - Current FID
      ULONG  Reserved1:3; // 7:5
      ULONG  SFid:5;      // 12:8  - Startup FID
      ULONG  Reserved2:3; // 15:13
      ULONG  MFid:5;      // 20:16 - Maximum FID
      ULONG  Reserved3:11;// 31:21
      ULONG  CVid:5;      // 36:32 - Current VID
      ULONG  Reserved4:3; // 39:37
      ULONG  SVid:5;      // 44:40 - Startup VID
      ULONG  Reserved5:3; // 47:45
      ULONG  MVid:5;      // 52:48 - Maximum VID
      ULONG  Reserved6:11;// 63:53
    };
    ULONG64 AsQWord;
  };
} FID_VID_STATUS, *PFID_VID_STATUS;

typedef struct {
  union {
    struct {
      ULONG  Fid:5;      // 4:0
      ULONG  Vid:5;      // 9:5
      ULONG  SGTC:20;    // 29:10
      ULONG  Reserved:2; // 31:30
    };
    ULONG AsDWord;
  };
} PSS_CONTROL, *PPSS_CONTROL;

typedef struct {
  union {
    struct {
      ULONG  Fid:5;      // 4:0   - Current FID
      ULONG  Vid:5;      // 9:5   - Current VID
      ULONG  Reserved:22; // 31:10
    };
    ULONG AsDWord;
  };
} PSS_STATUS, *PPSS_STATUS;


ULONG64
ConvertPssControlToFidVidControl(
  ULONG PssControlValue,
  BOOLEAN Fid
  );

ULONG
ConvertFidVidStatusToPssStatus(
  ULONG64 FidVidStatus
  );

NTSTATUS
FindCurrentPssPerfState(
  PACPI_PSS_PACKAGE PssPackage,
  PULONG    PssState
  );
  
//
// Debug Routines
//

#if DBG

VOID
DumpFidVidStatus(
  IN ULONG64 FidVidStatus
  );

VOID
DumpFidVidControl(
  IN ULONG64 FidVidControl
  );

VOID
DumpPssStatus(
  IN ULONG PssStatus
  );

VOID
DumpPssControl(
  IN ULONG PssControl
  );

#else

#define DumpFidVidStatus(_x_)
#define DumpFidVidControl(_x_)
#define DumpPssStatus(_x_)
#define DumpPssControl(_x_)

#endif

#endif _AMDK7_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk6\amdk6msr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amdk6msr.c

Abstract:

    This module implements code specific to the AMDK6-2 processor
    

Author:

    Todd Carpenter (7/20/00) - create file

Environment:

    Kernel mode

   
Revision History:


--*/
#include <ntddk.h>
#include <ntacpi.h>
#include "amdk6.h"

extern LEGACY_GEMINI_SMI LegacyInterface;
extern HalpFixedAcpiDescTable;

PUCHAR ProcessorToBusClockRatioStr[] = {

  "4.5x", // 0
  "5.0x", // 1
  "4.0x", // 2
  "5.5x", // 3
  "2.0x", // 4
  "3.0x", // 5
  "6.0x", // 6
  "3.5x", // 7

};


NTSTATUS
GetCurrentCpuSpeedMSR (
  OUT PULONG CpuSpeed
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  NTSTATUS status;
  UCHAR    vidANDbf;
  ULONG    state;
  LARGE_INTEGER msrInfo;

  DebugAssert(LegacyInterface.GBDT);
  DebugAssert(CpuSpeed);

  
  msrInfo.QuadPart = ReadMSR(AMDK6_GEMINI_PSOR_MSR);

  //
  // VID [20:16 ] and BF [ 2:0 ] --> VID [4:0 ] and BF [7:5 ]
  //
  
  vidANDbf = (UCHAR)(((msrInfo.LowPart >> 16) & 0x1f) | ((msrInfo.LowPart & 0x7) << 5));
  status = ConvertVidBfValueToGeminiState(vidANDbf, &state);

  if (NT_SUCCESS(status)) {
    *CpuSpeed = LegacyInterface.GBDT->State[state].CpuFrequency;    
  }
  
  return status;

}


NTSTATUS
SetCurrentStateMSR (
  ULONG State
  )
/*++

  Description:


  Arguments:

    
  Return Value:

    NTSTATUS


--*/
{
#define STOP_GRANT_TIME_OUT  3   // ISSUE: need to check bus clock to gen this number

    LARGE_INTEGER msrInfo;
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned, geminiState;
    UCHAR     vidANDbf = 0;
    ULONG     bvcValue = 0;


    DebugAssert(LegacyInterface.EpmIoAddress);
    

    //
    // Convert to Gemini State
    //
    
    geminiState = CONVERT_PERF_STATE_INDEX(State);

    //
    // Lookup VID and BF values for geminiState
    //
    
    vidANDbf = (LegacyInterface.GBDT->State[geminiState].Vid) | 
               ((LegacyInterface.GBDT->State[geminiState].Bf) << 5);



    //
    // Build BVC value to write to I/O space to initiate transition
    //
    
    bvcValue |= (STOP_GRANT_TIME_OUT << 12);   // Stop Grant Time-out Counter
    bvcValue |= (0x6 << 8);                    // BVF[11:8] == 0110
    bvcValue |= vidANDbf;                      // 

       
    
    _asm {

        // 
        // Disable bus masters
        //
        
        mov     edx, [HalpFixedAcpiDescTable + 72]
        in      al, dx                  // read PM2_CNT_BLK
        mov     cl, al                  // save current PM2_CNT_BLK
        or      al, 0x1                 // set ARB_DIS bit
        out     dx, al                  // write PM2_CNT_BLK
    
     

        //
        // initiate processor transition
        //
        
        mov     edx, LegacyInterface.EpmIoAddress
        mov     eax, bvcValue  
        out     dx, eax


        //
        // Restore bus master access
        //

        mov     edx, [HalpFixedAcpiDescTable + 72]
        mov     al, cl                  
        out     dx, al

    }

    //
    // BUGBUG: Need to figure out error checking. Should probably go read 
    //         see if PSOR reflects our new vid and bf values.
    //
    
    return STATUS_SUCCESS;
    
}


NTSTATUS
ReadEpmInfo (
  OUT PULONG  EpmInfo
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  ULONG  emp;

  _asm {

    mov     eax, AMDK6_GEMINI_CPUID_EPM
    xor     ebx, ebx
    xor     ecx, ecx
    xor     edx, edx    //  will be destroyed by the cpuid
    
    cpuid
    mov     emp, edx

  }

  
  if (ARGUMENT_PRESENT(EpmInfo)) {
    *EpmInfo = emp;
  }

  return STATUS_SUCCESS;
}


NTSTATUS
EnableGeminiTransitionsMSR (
  PULONG BaseAddress
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  ULARGE_INTEGER msrInfo;

  DebugAssert(BaseAddress);
      
 
  //
  // EPMR contains I/O block address for perf transitions
  //
  
  msrInfo.QuadPart = ReadMSR(AMDK6_GEMINI_EPMR_MSR);

  *BaseAddress = (msrInfo.LowPart & ~0xf) + 8;
  DebugPrint((INFO, "EnableGeminiTransitionsMSR: Base Address = 0x%x\n", *BaseAddress));


  //
  // Enable mobile feature base address
  //
  
  msrInfo.LowPart |= 0x1; 
  WriteMSR(AMDK6_GEMINI_EPMR_MSR, msrInfo.QuadPart);

  return STATUS_SUCCESS;

}


VOID
DisplayEPM (
  IN ULONG Epm
  )
{

  DebugPrint((MAXTRACE, "Enhanced Power Management Information (0x%x):\n", Epm));
  DebugPrint((MAXTRACE, "  Temperature Sensor:  %sSupported\n", (Epm & 0x1) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "  Bus Divisor Control: %sSupported\n", (Epm & 0x2) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "  Voltage Id control:  %sSupported\n", (Epm & 0x4) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "\n"));
}


VOID
DisplayEPMR (
  IN ULONG Epmr
  )
{

  DebugPrint((MAXTRACE, "Enhanced Power Management Register (0x%x):\n", Epmr));
  DebugPrint((MAXTRACE, "  Mobile Feature Base Address   = %sEnabled\n", (Epmr & 0x1) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "  Generate Special Bus Cycle    = %sEnabled\n", (Epmr & 0x2) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "  I/O Base Address              = 0x%x\n", ((Epmr >> 4) & 0xffff)));
  DebugPrint((MAXTRACE, "\n"));
  
}


VOID
DisplayPSOR (
  IN ULONG Psor
  )
{

  DebugPrint((MAXTRACE, "Processor State Observability (0x%x):\n", Psor));
  DebugPrint((MAXTRACE, "  Bus Frequency Divisor (Internal) = 0x%x (%s)\n", (Psor & 0x3), 
                                                                            ProcessorToBusClockRatioStr[(Psor & 0x3)]));
  DebugPrint((MAXTRACE, "  Processor Stepping Id            = 0x%x\n", ((Psor >> 4) & 0xf)));
  DebugPrint((MAXTRACE, "  L2 Cache Present                 = %s\n", (Psor & 0x256) ? "No" : "Yes"));
  DebugPrint((MAXTRACE, "  Voltage Id                       = 0x%x\n", ((Psor >> 16) & 0x1f)));
  DebugPrint((MAXTRACE, "  Bus Frequency Divisor (External) = 0x%x (%s)\n", ((Psor >> 21) & 0x3),
                                                                            ProcessorToBusClockRatioStr[((Psor >> 21) & 0x3)]));
  DebugPrint((MAXTRACE, "\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk6\amdk6.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amdk6.h


Author:

    Todd Carpenter (7/20/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#ifndef _AMDK6_H
#define _AMDK6_H

#include "..\lib\processor.h"
#include "..\eventmsg.h"
#include <pshpack1.h>

#define AMDK6_GEMINI_CPUID_EPM      0x80000007

#define AMDK6_GEMINI_EPMR_MSR       0xC0000086
#define AMDK6_GEMINI_PSOR_MSR       0xC0000087



//
// The follow definitions are taken from information the 
// Gemini SMI API Specification, version 0.80
//

#define PLATFORM_AMDK6                  0x6
#define PLATFORM_AMDK7                  0x7

//
// Function 0, Gemini State Change
//
#define IS_GEMINI_SUPPORTED             0x0000   // Function 0, Sub-function 0
#define GET_GEMINI_STATES               0x0001   // Function 0, Sub-function 1
#define GET_MAX_GEMINI_STATE            0x0002   // Function 0, Sub-function 2
#define SET_MAX_GEMINI_STATE            0x0003   // Function 0, Sub-function 3
#define GET_MIN_GEMINI_STATE            0x0004   // Function 0, Sub-function 4
#define SET_MIN_GEMINI_STATE            0x0005   // Function 0, Sub-function 5
#define GET_CURRENT_GEMINI_STATE        0x0006   // Function 0, Sub-function 6
#define SET_CURRENT_GEMINI_STATE        0x0007   // Function 0, Sub-function 7

//
// Function 1, Gemini Thermal Control
//
#define GET_CURRENT_TALERT_MODES        0x0100   // Function 1, Sub-function 0
#define GET_CURRENT_TALERT_SETTINGS     0x0101   // Function 1, Sub-function 1
#define SET_TALERT_CONTROLS             0x0102   // Function 1, Sub-function 2
#define GET_CURRENT_TPANIC_SETTINGS     0x0103   // Function 1, Sub-function 3
#define SET_TPANIC_SETTINGS             0x0104   // Function 1, Sub-function 4
#define GET_CURRENT_TEMPERATURE         0x0105   // Function 1, Sub-function 5

//
// Function 2, Gemini Connect/Disconnect
//
#define GEMINI_CONNECT                  0x0200   // Function 2, Sub-function 0
#define GEMINI_DISCONNECT               0x0201   // Function 2, Sub-function 1




#define GBDT_SIGNATURE                  0x54444247  // "GBDT"
#define GBDT_SEARCH_RANGE_BEGIN         0xC0000
#define GBDT_SEARCH_RANGE_END           0xFFFFF
#define GBDT_SEARCH_RANGE_LENGTH        (GBDT_SEARCH_RANGE_END-GBDT_SEARCH_RANGE_BEGIN+1)
#define GBDT_SEARCH_INTERVAL            16          // search on 16 byte boundaries

#define CONVERT_PERF_STATE_INDEX(_x_) ((LegacyInterface.GBDT->MaxStateSupported) - _x_)

// 
// Gemini Processor Voltage and Frequency information
//
typedef struct _GEMINI_PROCESSOR_STATE {

  USHORT  CpuVoltage;               // format A.BCD
  USHORT  CpuFrequency;             // mhz
  UCHAR   Vid;                      // VID[4:0]
  UCHAR   Bf;                       // BF[2:0]

} GEMINI_PROCESSOR_STATE, *PGEMINI_PROCESSOR_STATE;


typedef struct _AVAILABLE_STATE_INFO {

  UCHAR   Vid;
  UCHAR   Bf;
  UCHAR   State;
  UCHAR   Reserved;                 // should be zero

} AVAILABLE_STATE_INFO, *PAVAILABLE_STATE_INFO;

//
// Gemini BIOS Descriptor Table 
//
typedef struct _GBDT {

  ULONG   Signature;                // "GBDT"
  UCHAR   Length;
  UCHAR   Revsion;
  UCHAR   Checksum;
  UCHAR   Capabilities;
  USHORT  BusSpeed;
  USHORT  MaxCpuSpeed;
  UCHAR   MaxStateSupported;        // Min state always = 0, Max state < 16
  UCHAR   SmiCommandPortType;       // defines type, IO or MEM, and access size
  ULONG   SmiCommandPortAddress;    // IO or MEM address
  ULONG   GeminiSmiCode;            // loaded in ESI before SMI call.

  GEMINI_PROCESSOR_STATE State[0];  // Processor performance states
  
} GBDT, *PGBDT, **PPGBDT;


//
// Auto Performance Table
//
typedef struct _GEMINI_AUTO_PERF_TABLE {

  UCHAR CpuUtilizationThreshold;
  UCHAR GeminiThresholdTargeState;

} GEMINI_AUTO_PERF_TABLE, *PGEMINI_AUTO_PERF_TABLE;


// 
// Gemini Processor Voltage and Frequency information
//
typedef struct _LEGACY_GEMINI_SMI {

  ULONG SmiAccessType;
  ULONG SmiAccessSize;
  ULONG SmiAddress;
  ULONG GeminiCode;
  ULONG CurrentState;
  ULONG MaxSupportedStates;
  ULONG CurrentlyAvailableStates;
  ULONG EpmIoAddress;
  PGBDT GBDT;
  
} LEGACY_GEMINI_SMI, *PLEGACY_GEMINI_SMI;


typedef struct _LEGACY_GEMINI_PERF_STATE {

  ULONG   Frequency;          // in megahertz
  USHORT  Power;              // in milliwatts
  UCHAR   PercentFrequency;   // for quick lookup
  ULONG   GeminiState;
  ULONG   GeminiVID;
  ULONG   GeminiBF;

} LEGACY_GEMINI_PERF_STATE, *PLEGACY_GEMINI_PERF_STATE;


typedef struct _LEGACY_GEMINI_PERF_STATES {

  PSET_PROCESSOR_THROTTLE   TransitionFunction;
  ULONG                     TransitionLatency;  // in milliseconds
  UCHAR                     Current;
  UCHAR                     Count;
  LEGACY_GEMINI_PERF_STATE  State[1]; // sorted from fastest to slowest

} LEGACY_GEMINI_PERF_STATES, *PLEGACY_GEMINI_PERF_STATES;

//
// bios.c
//

NTSTATUS
FindGBDT (
    OUT PPGBDT GeminiInfo  
    );

NTSTATUS
InitializeLegacyInterface (
    VOID
    );
    
NTSTATUS
IsGeminiSupported (
    PULONG Results
    );

NTSTATUS
GetAvailableStatesSmm (
    PULONG Results
    );

NTSTATUS
GetMaxStateSmm (
    PULONG Results
    );

NTSTATUS
SetMaxStateSmm (
    VOID
    );

NTSTATUS
GetMinStateSmm (
    PULONG Results
    );

NTSTATUS
SetMinStateSmm (
    VOID
    );

NTSTATUS
GetCurrentStateSmm (
    PULONG Results
    );

NTSTATUS
SetCurrentStateSmm (
    ULONG State
    );

NTSTATUS
ConnectDisconnectGeminiInterface (
    BOOLEAN  Connect
    );

NTSTATUS
GetCpuFrequency (
  IN  ULONG  State,
  OUT PULONG CpuSpeed
  );

NTSTATUS
GetCpuVoltage (
  IN  ULONG  State,
  OUT PULONG Voltage
  );
  
NTSTATUS
GetLegacyMaxProcFrequency (
  OUT PULONG CpuSpeed
  );

NTSTATUS
ConvertVidBfValueToGeminiState (
  IN  UCHAR  VidBfValue,
  OUT PULONG State
  );
  
//
// amdk6msr.c
//

NTSTATUS
GetCurrentCpuSpeedMSR (
  OUT PULONG CpuSpeed
  );

NTSTATUS
SetCurrentStateMSR (
  ULONG State
  );

NTSTATUS
ReadEpmInfo (
  OUT PULONG  EpmInfo
  );

NTSTATUS
EnableGeminiTransitionsMSR (
  PULONG BaseAddress
  );
  
VOID
DisplayEPM (
  IN ULONG Epm
  );

VOID
DisplayEPMR (
  IN ULONG Epmr
  );

VOID
DisplayPSOR (
  IN ULONG Psor
  );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk7\fidvid.h ===
/*++

  Copyright (c) 2000  Microsoft Corporation
  
  Module Name:
  
    fidvid.h
  
  Author:
  
    Todd Carpenter (4/16/01) - create file
  
  Environment:
  
    Kernel mode
  
  Notes:
  
  Revision History:

--*/

#ifndef _AMDK7_FIDVID_H
#define _AMDK7_FIDVID_H

#include "..\lib\processor.h"


const ULONG FSB100FidToCpuFreq[] = {

  1100,   // 11x   1.1 GHz
  1150,   // 11.5x 1.15 GHz
  1200,   // 12x   1.2 GHz
  1250,   // 12.5x 1.25 GHz 
  500,    // 5x    500 MHz
  550,    // 5.5x  550 MHz
  600,    // 6x    600 MHz
  650,    // 6.5x  650 MHz
  700,    // 7x    700 MHz
  750,    // 7.5x  750 MHz
  800,    // 8x    800 MHz
  850,    // 8.5x  850 MHz
  900,    // 9x    900 MHz
  950,    // 9.5x  950 MHz
  1000,   // 10x   1.0 GHz
  1050,   // 10.5x 1.05 GHz
  300,    // 3x    300 MHz
  1900,   // 19x   reserved
  400,    // 4x    400 MHz
  2000,   // 20x   reserved
  1300,   // 13x   1.3 GHz
  1350,   // 13.5x 1.35 GHz
  1400,   // 14x   1.4 GHz
  2100,   // 21x   reserved
  1500,   // 15x   1.5 GHz
  2250,   // 22.5x reserved
  1600,   // 16x   1.6 GHz
  1650,   // 16.5x 1.65 GHz
  1700,   // 17x   1.7 GHz
  1800,   // 18x   1.8 GHz
  0,
  0  
  
};


//
// listed in milliVolts
//

const ULONG MobileVidToCpuVoltage[] = {

  2000,
  1950,
  1900,
  1850,
  1800,
  1750,
  1700,
  1650,
  1600,
  1550,
  1500,
  1450,
  1400,
  1350,
  1300,
  0,
  1275,
  1250,
  1225,
  1200,
  1175,
  1150,
  1125,
  1100,
  1075,
  1050,
  1025,
  1000,
  975,
  950,
  925,
  0

};

#define INVALID_FID_VALUE  (sizeof(FSB100FidToCpuFreq)/sizeof(ULONG))
#define INVALID_VID_VALUE  (sizeof(MobileVidToCpuVoltage)/sizeof(ULONG))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk6\bios.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bios.c

Abstract:

    This module implements code to make SMI BIOS calls

Author:

    Todd Carpenter (7/20/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#include <ntddk.h>
#include <ntacpi.h>
#include "amdk6.h"

LEGACY_GEMINI_SMI LegacyInterface;

#if DBG
VOID
DisplayGBDT (
  IN PGBDT GBDT
  );
#else 
#define DisplayGBDT(_x_)
#endif 


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FindGBDT)
#pragma alloc_text(PAGE, InitializeLegacyInterface)
#pragma alloc_text(PAGE, IsGeminiSupported)
#endif



NTSTATUS
FindGBDT (
  OUT PPGBDT GeminiInfo  
  )
/*++

  Description:

    This routine looks in the BIOS memory area for the Gemini BIOS Descriptor
    Table.  The signature will be located on a 16-byte bountry in the area from
    0C0000h to 0FFFFFh or within the first 1K of the Extended BIOS Data Area.
  
  Arguments:

    
  Return Value:

    NTSTATUS

--*/
{
  NTSTATUS          status = STATUS_UNSUCCESSFUL;
  PVOID             baseAddress;
  PGBDT             newGBDTTable;
  ULONG_PTR         address;
  ULONG_PTR         limit;
  ULONG             tableLength;
  PHYSICAL_ADDRESS  PhysAddress;
   
  DebugEnter();
  PAGED_CODE();


  PhysAddress.HighPart = 0;
  PhysAddress.LowPart  = GBDT_SEARCH_RANGE_BEGIN;

  //
  // Map memory to search for Gemini Bios table
  //
  baseAddress = MmMapIoSpace(PhysAddress,
                             GBDT_SEARCH_RANGE_LENGTH,
                             0);

  
  if (!baseAddress) {      
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto FindGBDTExit;
  }
  

  //
  // Compute limit for the for loop.  Do not start a scan within 16 bytes of
  // physical address 0xFFFFF
  //
  
  address = (ULONG_PTR) baseAddress;
  limit = address + GBDT_SEARCH_RANGE_LENGTH - GBDT_SEARCH_INTERVAL;
    
  for (; address <= limit; address += GBDT_SEARCH_INTERVAL) {

    if ((((PGBDT)address)->Signature == GBDT_SIGNATURE) &&
        (GetCheckSum((PUCHAR)address, ((PGBDT)address)->Length) == 0)) {  
 
    
      // 
      // We found Gemini BIOS Descriptor Table
      //
      
      DebugPrint((TRACE, "GBDT Pointer found at: %x\n", address));
    
      newGBDTTable = ExAllocatePoolWithTag(NonPagedPool,
                                           ((PGBDT)address)->Length,
                                           PROCESSOR_POOL_TAG);


      if (!newGBDTTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FindGBDTExit;
      }


      //
      // Copy the Gemini BIOS Descriptor Table
      //
      
      RtlCopyMemory(newGBDTTable, 
                   (PVOID) address, 
                   ((PGBDT)address)->Length);
       

      //
      // Unmap mapped memory
      //
      
      MmUnmapIoSpace(baseAddress, GBDT_SEARCH_RANGE_LENGTH);

      if (ARGUMENT_PRESENT(GeminiInfo)) {
        *GeminiInfo = newGBDTTable;
      }

      status = STATUS_SUCCESS;
      goto FindGBDTExit;
      
    }
    
  }


FindGBDTExit:

  DebugExitStatus(status);
  return status;
  
}


NTSTATUS
InitializeLegacyInterface (
  VOID
  )
/*++

  Description:

    

  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/ 
{
    NTSTATUS status;
    ULONG    currentState;
    ULONG    platform = 0;
   
   
    DebugEnter();
    PAGED_CODE();
 
    status = FindGBDT(&LegacyInterface.GBDT);

    if (!NT_SUCCESS(status)) {
      goto InitializeLegacyInterfaceExit;
    }

    DisplayGBDT(LegacyInterface.GBDT);
  
    //
    // Setup LegacyInterface structure
    //
    
    LegacyInterface.SmiAccessType = LegacyInterface.GBDT->SmiCommandPortType & 0x1;
    LegacyInterface.SmiAccessSize = (LegacyInterface.GBDT->SmiCommandPortType >> 0x4) & 0x3;
    LegacyInterface.SmiAddress = LegacyInterface.GBDT->SmiCommandPortAddress;
    LegacyInterface.GeminiCode = LegacyInterface.GBDT->GeminiSmiCode;
    LegacyInterface.MaxSupportedStates = LegacyInterface.GBDT->MaxStateSupported + 1;
    LegacyInterface.CurrentlyAvailableStates = LegacyInterface.GBDT->MaxStateSupported + 1;

    //
    // No perf states, we bail
    //
    
    if (LegacyInterface.CurrentlyAvailableStates == 0) {
      status = STATUS_UNSUCCESSFUL;
      goto InitializeLegacyInterfaceExit;
    }

    
    status = IsGeminiSupported(&platform);

    //
    // if this is not a Gemini System or not of the K6 family, fail.
    // 
    
    if (!NT_SUCCESS(status) || (platform != PLATFORM_AMDK6)) {

      status = STATUS_UNSUCCESSFUL;
      goto InitializeLegacyInterfaceExit;
    }

    
    status = GetCurrentStateSmm(&currentState);

    if (!NT_SUCCESS(status)) {
      goto InitializeLegacyInterfaceExit;
    }

    
    DebugAssert(currentState <= LegacyInterface.GBDT->MaxStateSupported);
    LegacyInterface.CurrentState = CONVERT_PERF_STATE_INDEX(currentState);


    //
    // Use direct transition method instead of SMI method
    //
    
    EnableGeminiTransitionsMSR(&LegacyInterface.EpmIoAddress);


InitializeLegacyInterfaceExit:

    DebugExitStatus(status);
    return status;
   
}


NTSTATUS
IsGeminiSupported (
  PULONG Results
  )
/*++

  Description:

    Input:

      CX  = 0000h
      ESI = Gemini_Code

    Output:

      ESI =  0 SMI was entered successfully
      ESI <> 0 SMI was entered, but function failed.
      ESI =  Gemini Code, SMI was never entered
      
      CF  = 0 SMM Function Successful
      CF  = 1 SMM Function Failed, ESI = error code (see below)
            0x90 requested Gemini State change not supported by hardware
            0x91 the attempted State change failed upon read-back
            0x92 function not supported in current implementation
            0x94 the input parameters were erroneous/invalid
            
      
      AL  = 6 (K6 Gemini platform), 7 (K7 Mustang platform)
      

  Arguments:

    
    
  Return Value:

    NTSTATUS

--*/ 
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned;
    UCHAR     platform;

    PAGED_CODE();
    
    //
    // need to check whether type is I/O or memory mapped
    // need to check access type size
    //


    _asm {

        mov     ecx, IS_GEMINI_SUPPORTED
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

        mov     platform, al
    }
 

    
    if (ARGUMENT_PRESENT(Results)) {
      ASSERT((platform == PLATFORM_AMDK6) || (platform == PLATFORM_AMDK7));
      *Results = (ULONG) platform;
    }
  
    return STATUS_SUCCESS;
    
  
 
 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //
       
    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "IsGeminiSupported() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


#if 0
NTSTATUS
GetAvailableStatesSmm (
  PULONG Results
  )
/*++

  Description:

    Input:

      CX  = 0001h
      ESI = Gemini_Code

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.
      
      BX  = # of vaild entries
    

  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned, bufferSize;
    USHORT    stateEntries;
    PHYSICAL_ADDRESS stateBuffer;
    static AVAILABLE_STATE_INFO AvailableStates[16] = {0};
  
    TRAP();
    PAGED_CODE();


    //
    // Allocate buffer to hold state information for each state
    // LegacyInterface.GBDT->CurrentlyAvailableStates * sizeof(AVAILABLE_STATE_INFO)
    // For now we will just use a global array set to hold max size
    //

    bufferSize = sizeof(AvailableStates);
    stateBuffer = MmGetPhysicalAddress((PVOID)AvailableStates);
    ASSERT(stateBuffer.QuadPart);


    _asm {

        mov     ecx, GET_GEMINI_STATES
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        mov     eax, stateBuffer.LowPart
        mov     ebx, bufferSize
       
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

        mov     stateEntries, bx
    }
 

    if (ARGUMENT_PRESENT(Results)) {

      ASSERT((stateEntries > 0) || (stateEntries <= 16));
      *Results = (ULONG) stateEntries;

    }

    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "GetAvailableStatesSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
GetMaxStateSmm (
  PULONG Results
  )
/*++

  Description:

    Input:

      CX  = 0002h
      ESI = Gemini_Code

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.
      
      AH  = BF
      AL  = VID
      BL  = Gemini State number

  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned;
    UCHAR     state;

    TRAP();
    PAGED_CODE();


    _asm {

        mov     ecx, GET_MAX_GEMINI_STATE
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

        mov     state, bl
    }

    //
    // NOTE: currently we don't do use the VID and BF data returned in
    //       AX as it is a bit redundant because we should already have
    //       that data from the Gemini Bios Descriptor Table.
    //
    if (ARGUMENT_PRESENT(Results)) {
      *Results = (ULONG) state;
    }

    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "GetMaxStateSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
SetMaxStateSmm (
  VOID
  )
/*++

  Description:

    Input:

      CX  = 0003h
      ESI = Gemini_Code

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.
      

  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned;
    UCHAR     maxState;

    TRAP();
    PAGED_CODE();


    _asm {

        mov     ecx, SET_MAX_GEMINI_STATE
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed
        
    }
 
    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "SetMaxStateSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
GetMinStateSmm (
  PULONG Results
  )
/*++

  Description:

    Input:

      CX  = 0004h
      ESI = Gemini_Code

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.
      
      AH  = BF
      AL  = VID
      BL  = Gemini State number

  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned;
    UCHAR     state;

    TRAP();
    PAGED_CODE();


    _asm {

        mov     ecx, GET_MIN_GEMINI_STATE
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

        mov     state, bl
    }
 

    //
    // NOTE: currently we don't do use the VID and BF data returned in
    //       AX as it is a bit redundant because we should already have
    //       that data from the Gemini Bios Descriptor Table.
    //
    if (ARGUMENT_PRESENT(Results)) {
      *Results = (ULONG) state;
    }

    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "GetMinStateSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
SetMinStateSmm (
  VOID
  )
/*++

  Description:

    Input:

      CX  = 0005h
      ESI = Gemini_Code

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.
     

  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned;
    UCHAR     maxState;

    TRAP();
    PAGED_CODE();



    _asm {

        mov     ecx, SET_MIN_GEMINI_STATE
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

    }
 
    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "SetMinStateSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
SetCurrentStateSmm (
  ULONG State
  )
/*++

  Description:



    Input:

      CX  = 0007h
      ESI = Gemini_Code
      AL  = Gemini State Number

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.

      
  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned, geminiState;
    UCHAR     vidANDbf;

    //
    // Convert to Gemini State
    //
    geminiState = CONVERT_PERF_STATE_INDEX(State);

    //
    // Lookup VID and BF values for geminiState
    //
    vidANDbf = (LegacyInterface.GBDT->State[geminiState].Vid) | 
               ((LegacyInterface.GBDT->State[geminiState].Bf) << 5);

    
   _asm {
   
        mov     ecx, SET_CURRENT_GEMINI_STATE
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        mov     al, vidANDbf
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

    }
    
    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "SetCurrentStateSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
ConnectDisconnectGeminiInterface (
  BOOLEAN  Connect
  )
/*++

  Description:


    Input:

      CX  = 0200h connect, 0201h disconnect
      ESI = Gemini_Code
     
    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.

      
  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned, function;
  

    TRAP();
    PAGED_CODE();

   
    function = Connect ? GEMINI_CONNECT : GEMINI_DISCONNECT;


    _asm {

        mov     ecx, function
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed

    }
 

    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "ConnectDisconnectGeminiInterface() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}
#endif


NTSTATUS
GetCurrentStateSmm (
  PULONG Results
  )
/*++

  Description:



    Input:

      CX  = 0006h
      ESI = Gemini_Code

    Output:

      ESI = 0 SMI was entered successfully
      ESI = Gemini Code, SMI was never entered
      CF  = 0 SMM Operation Successful
      CF  = 1 SMM Operation Failed, ESI = error code.
      
      AH  = BF value
      AL  = VID value
      BL  = Gemini State number
      BH[0] = 0 (DC power)
      BH[0] = 1 (AC power)


  Arguments:

    
    
  Return Value:

    NTSTATUS


--*/
{
    NTSTATUS  status = STATUS_NOT_SUPPORTED;
    ULONG     esiReturned, state;
    UCHAR     vidANDbf;

    PAGED_CODE();


    _asm {

        xor     ebx, ebx
        xor     eax, eax
        mov     ecx, GET_CURRENT_GEMINI_STATE
        mov     edx, LegacyInterface.SmiAddress
        mov     esi, LegacyInterface.GeminiCode
        
        out     dx, al
        
        mov     esiReturned, esi
        test    esi, esi
        jnz     SmmFailed
 
        mov     vidANDbf, al
       
    }
 

    //
    // NOTE: currently we don't do use the VID and BF data returned in
    //       AX as it is a bit redundant because we should already have
    //       that data from the Gemini Bios Descriptor Table.
    //
    //       we are not currentingly using the AC / DC indicator either.
    //       this information is returned in BH [0 ].
    //
    

    //
    // Lookup VID and BF values for geminiState
    //
    
    status = ConvertVidBfValueToGeminiState(vidANDbf, &state);
    DebugAssert(status == STATUS_SUCCESS);
    
    
    if (ARGUMENT_PRESENT(Results)) {
      *Results = (ULONG) state;
    }
    
    return STATUS_SUCCESS;
    

 SmmFailed:

    
    if (esiReturned == LegacyInterface.GeminiCode) {

      //
      // SMI failed, SMM was never entered.
      //

    } else {

      // 
      // SMI was successful, but SMM operation failed (esi == failure)
      //
      
    }

    DebugPrint((ERROR, "GetCurrentStateSmm() Failed: ESI = 0x%x\n", esiReturned));
    return STATUS_UNSUCCESSFUL;
    
}


NTSTATUS
GetCpuFrequency (
  IN  ULONG  State,
  OUT PULONG CpuSpeed
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  ULONG geminiState;
  ASSERT(LegacyInterface.GBDT);

  geminiState = CONVERT_PERF_STATE_INDEX(State);
  
  if (ARGUMENT_PRESENT(CpuSpeed)) {
    *CpuSpeed = LegacyInterface.GBDT->State[geminiState].CpuFrequency;
  }

  return STATUS_SUCCESS;

}


NTSTATUS
GetCpuVoltage (
  IN  ULONG  State,
  OUT PULONG Voltage
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  ULONG  geminiState;
  USHORT bcdVoltage;
  ULONG  intVoltage;

  DebugAssert(LegacyInterface.GBDT);

  geminiState = CONVERT_PERF_STATE_INDEX(State);
  
  bcdVoltage = LegacyInterface.GBDT->State[geminiState].CpuVoltage;
  intVoltage = Bcd8ToUlong(bcdVoltage);

  if (ARGUMENT_PRESENT(Voltage)) {
    *Voltage = intVoltage;
  }

  return STATUS_SUCCESS;

}


NTSTATUS
GetLegacyMaxProcFrequency (
  OUT PULONG CpuSpeed
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

    NTSTATUS


--*/ 
{
  DebugAssert(CpuSpeed);
  
  if (LegacyInterface.GBDT) {
    *CpuSpeed = LegacyInterface.GBDT->MaxCpuSpeed;
    return STATUS_SUCCESS;
  }

  return STATUS_UNSUCCESSFUL;
}


NTSTATUS
ConvertVidBfValueToGeminiState (
  IN  UCHAR  VidBfValue,
  OUT PULONG State
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  NTSTATUS status;
  ULONG    state, x;
  UCHAR    vid, bf;

  
  vid = VidBfValue & 0x1f;  // vid[4:0]
  bf  = VidBfValue >> 5;    // bf[7:5]
  
  for (x = 0; x < LegacyInterface.CurrentlyAvailableStates; x++) {

    if ((LegacyInterface.GBDT->State[x].Vid == vid) && 
        (LegacyInterface.GBDT->State[x].Bf == bf)) {

      if (ARGUMENT_PRESENT(State)) {
        *State = x;
      }

      return STATUS_SUCCESS;
      
    }

  }

  DebugPrint((ERROR, "Couldn't find a match for vid=0x%x and bf=0x%x\n", vid, bf));
  return STATUS_UNSUCCESSFUL;
  
}


#if DBG
VOID
DisplayGBDT (
  IN PGBDT GBDT
  )
{

  ULONG x;
  
  DebugPrint((MAXTRACE, "\n"));
  DebugPrint((MAXTRACE, "Gemini BIOS Descriptor Table:\n"));
  DebugPrint((MAXTRACE, "  Signature        = %.4s\n", &GBDT->Signature)); // ULONG
  DebugPrint((MAXTRACE, "  Length           = 0x%x\n", GBDT->Length));     // UCHAR
  DebugPrint((MAXTRACE, "  Bios Revision    = 0x%x\n", GBDT->Revsion));    // UCHAR
  DebugPrint((MAXTRACE, "  Checksum         = 0x%x\n", GBDT->Checksum));   // UCHAR
  DebugPrint((MAXTRACE, "  Capabilities     = 0x%x\n", GBDT->Capabilities));// UCHAR
  DebugPrint((MAXTRACE, "    - TALERT is %ssupported\n",  (GBDT->Capabilities & 0x1) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "    - TPANIC is %ssupported\n",  (GBDT->Capabilities & 0x2) ? "" : "NOT "));
  DebugPrint((MAXTRACE, "  Bus Speed        = %u mhz\n", GBDT->BusSpeed));   // USHORT
  DebugPrint((MAXTRACE, "  Max CPU Speed    = %u mhz\n", GBDT->MaxCpuSpeed));// USHORT
  DebugPrint((MAXTRACE, "  Max CPU State    = %u\n", GBDT->MaxStateSupported)); // UCHAR
  DebugPrint((MAXTRACE, "  SMI Port Type    = 0x%x\n", GBDT->SmiCommandPortType));  // UCHAR
  DebugPrint((MAXTRACE, "    - %s address\n", (GBDT->SmiCommandPortType & 0x1) ? "memory mapped" : "x86 I/O"));
  DebugPrint((MAXTRACE, "    - Data Size = %u bits\n", ((GBDT->SmiCommandPortType >> 0x4) & 0x3) * 8));
  DebugPrint((MAXTRACE, "  SMI Port Address = 0x%x\n", GBDT->SmiCommandPortAddress)); // ULONG
  DebugPrint((MAXTRACE, "  Gemini Code      = 0x%x\n", GBDT->GeminiSmiCode));         // ULONG 
  DebugPrint((MAXTRACE, "  Perf States:\n"));

  for (x=0; x <= GBDT->MaxStateSupported; x++) {

    DebugPrint((MAXTRACE, "    State %u:\n", x));
    DebugPrint((MAXTRACE, "      - Voltage    = 0x%x\n", GBDT->State[x].CpuVoltage));
    DebugPrint((MAXTRACE, "      - Frequency  = %u%\n", GBDT->State[x].CpuFrequency));
    DebugPrint((MAXTRACE, "      - VID        = 0x%x\n", GBDT->State[x].Vid));
    DebugPrint((MAXTRACE, "      - BF         = 0x%x\n", GBDT->State[x].Bf));
    
  }
  DebugPrint((MAXTRACE, "\n"));
  
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk7\legacy.c ===
/*++

  Copyright (c) 2000  Microsoft Corporation
  
  Module Name:
  
    legacy.c
  
  Abstract:
   
  
  Author:
  
    Todd Carpenter (1/30/01) - create file
  
  Environment:
  
    Kernel mode

    
  Revision History:


--*/
#include "..\lib\processor.h"
#include "amdk7.h"
#include "legacy.h"
#include "fidvid.h"

PST_SIGNATURE SystemSignature;
PPST_BLOCK_HEADER PstBlockHeader;

extern ULONG AmdK7HackFlags;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeNonAcpiPerformanceStates)
#pragma alloc_text (PAGE, GetLegacyMaxProcFrequency)
#endif

//
// Legacy functions that must have a stub.
//

NTSTATUS
InitializeNonAcpiPerformanceStates(
    IN  PFDO_DATA DevExt
    )
/*++

  Routine Description:

      The generic processor driver doesn't have non-ACPI performance states.

  Arguments:

      FdoData - pointer to the device extension

  Return Value:

      NT status code


--*/
{
  NTSTATUS status;
  PPST_ENTRY pstMatch;

  DebugEnter();

  //
  // Check hack flags to see if we should use the Legacy interface.
  //

  if (!(AmdK7HackFlags & ENABLE_LEGACY_INTERFACE)) {
    status = STATUS_NOT_SUPPORTED;
    goto InitializeNonAcpiPerformanceStatesExit;
  }


  //
  // Find the Perf States
  //
  
  status = FindPSTBlock(&PstBlockHeader);
  
  
  if (!NT_SUCCESS(status)) {
    DebugPrint((ERROR, "ERROR!! PST Block Header NOT found\n"));
    goto InitializeNonAcpiPerformanceStatesExit;
  }

  DumpPSTBlock(PstBlockHeader);

  //
  // Generate Signature to help find correct PST
  //

  status = CreateSystemSignature(&SystemSignature);
  DebugPrint((TRACE, "Dumping System Signature...\n"));
  DumpPSTSignature(&SystemSignature);

  if (!NT_SUCCESS(status)) {
    goto InitializeNonAcpiPerformanceStatesExit;
  }


  //
  // Walk through one or more PST entries to find the best match
  //

  status = FindMatchingPSTEntry(PstBlockHeader, 
                                &SystemSignature,
                                &pstMatch);

  if (!NT_SUCCESS(status)) {
    DebugPrint((ERROR, "ERROR!! Couldn't find PST entry to match system signature\n"));
    goto InitializeNonAcpiPerformanceStatesExit;
  }

  DebugPrint((TRACE, "Dumping Matching Signature...\n"));
  DumpPSTEntry(pstMatch);

  DevExt->LegacyInterface = TRUE;

  //
  // Set up _PCT
  //
 
  DevExt->PctPackage.Control.AddressSpaceID = AcpiGenericSpaceFixedFunction;
  DevExt->PctPackage.Status.AddressSpaceID = AcpiGenericSpaceFixedFunction;


  //
  // Convert matching PST entry into _PSS package
  //

  status = ConvertPstToPss(DevExt, pstMatch, &DevExt->PssPackage);
  


InitializeNonAcpiPerformanceStatesExit:

  if (!NT_SUCCESS(status)) {
  
    //
    // undo what we have done
    //

    if (PstBlockHeader) {
      ExFreePool(PstBlockHeader);
      PstBlockHeader = NULL;
    }

    if (DevExt->PssPackage) {
      ExFreePool(DevExt->PssPackage);
      DevExt->PssPackage = NULL;
    }

    DevExt->LegacyInterface = FALSE;
  
  }

  DebugExitStatus(status);
  return status;
}

NTSTATUS
AcpiLegacyPerfStateTransition(
  IN PFDO_DATA DevExt,
  IN ULONG     State
  )
/*++

  Routine Description:

      The generic processor driver doesn't have non-ACPI performance states.

  Arguments:

     State - Target State

  Return Value:

      NT Status

--*/
{
  return Acpi2PerfStateTransition(DevExt, State + DevExt->PpcResult);
}


NTSTATUS
GetLegacyMaxProcFrequency(
  OUT PULONG CpuSpeed
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  FID_VID_STATUS fidVidStatus;

  DebugAssert(CpuSpeed);

  fidVidStatus.AsQWord = ReadMSR(AMDK7_FID_VID_STATUS_MSR);
  *CpuSpeed = FSB100FidToCpuFreq[fidVidStatus.MFid];
  
  return STATUS_SUCCESS;
}


NTSTATUS
FindPSTBlock (
  OUT PPPST_BLOCK_HEADER PstBlock  
  )
/*++

  Description:

    This routine looks in the BIOS memory area for the PST Block Header.  The 
    signature will be located on a 16-byte bountry in the area from C0000h to FFFF0h.
  
  Arguments:

    
  Return Value:

    NTSTATUS

--*/
{
  NTSTATUS          status = STATUS_UNSUCCESSFUL;
  ULONG             size = 0;
  PVOID             baseAddress;
  ULONG_PTR         address;
  ULONG_PTR         limit;
  PHYSICAL_ADDRESS  PhysAddress;
   
  DebugEnter();
  DebugAssert(PstBlock);
  PAGED_CODE();


  PhysAddress.HighPart = 0;
  PhysAddress.LowPart  = PST_SEARCH_RANGE_BEGIN;


  //
  // Map memory to search for PST Table
  //

  baseAddress = MmMapIoSpace(PhysAddress, PST_SEARCH_RANGE_LENGTH, 0);

  if (!baseAddress) {      
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto FindPSTBlockExit;
  }
  

  //
  // Compute limit for the for loop.  Do not start a scan within 16 bytes of
  // physical address 0xFFFFF
  //
  
  address = (ULONG_PTR) baseAddress;
  limit = address + PST_SEARCH_RANGE_LENGTH - PST_SEARCH_INTERVAL;
    
  for (; address <= limit; address += PST_SEARCH_INTERVAL) {

    if (*(PULONG)address == PST_BLOCK_SIGNATURE && 
        (!memcmp(((PPST_BLOCK_HEADER)address)->Signature, 
                   PST_BLOCK_SIGNATURE_STRING, 
                   PST_BLOCK_SIGNATURE_STRING_LEN))) {  
  
      DebugPrint((TRACE, "Found PST Header Block at %p\n", address));
        
      // 
      // We found the PST Block Header, copy it.
      //
  
      size = GetPSTSize((PPST_BLOCK_HEADER)address);
      
      *PstBlock = ExAllocatePoolWithTag(PagedPool,
                                        size,
                                        PROCESSOR_POOL_TAG);
  
      if (!(*PstBlock)) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FindPSTBlockExit;
      }
  
      RtlCopyMemory(*PstBlock, (PVOID)address, size);
      status = STATUS_SUCCESS;
      
      break;
      
    }
    
  }


FindPSTBlockExit:

  //
  // Unmap mapped memory
  //
  
  if (baseAddress) {
    MmUnmapIoSpace(baseAddress, PST_SEARCH_RANGE_LENGTH);
  }

  DebugExitStatus(status);
  return status;
  
}


NTSTATUS
FindMatchingPSTEntry(
  IN  PPST_BLOCK_HEADER PstBlock,
  IN  PPST_SIGNATURE Signature,
  OUT PPPST_ENTRY  PstStates
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  NTSTATUS status = STATUS_UNSUCCESSFUL;
  ULONG x, y;
  PPST_ENTRY pstEntry;

  //DebugEnter();
  DebugAssert(PstBlock);
  DebugAssert(Signature);
  DebugAssert(PstStates);

  //
  // Walk PST Block looking for matching PST Signature.
  //

  //
  // Get First PST Entry
  //

  pstEntry = &PstBlock->PstState;

  for (x=0; x < PstBlock->NumPST; x++) {
    
    if ((pstEntry->CpuId == Signature->CpuId) &&
        (pstEntry->FSBSpeed == Signature->FSBSpeed) &&
        (pstEntry->MaxFid == Signature->MaxFid) &&
        (pstEntry->StartVid == Signature->StartVid)) {

      //
      // Found Match, we assume there should only be one match, but
      // if there are more, we take the first one.
      //
    
      *PstStates = pstEntry;
      status = STATUS_SUCCESS;
      break;

    }
    
    //
    // Get Next PST State
    //
    
    pstEntry = (PPST_ENTRY)((PUCHAR)pstEntry + sizeof(PST_ENTRY) + 
               (sizeof(PST_DATA) * (pstEntry->NumPStates - 1)));

  }

  return status;
}


NTSTATUS
CreateSystemSignature(
  PPST_SIGNATURE Signature
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  NTSTATUS status;
  ULONG junk;
  FID_VID_STATUS fidVidStatus;

  //DebugEnter();
  DebugAssert(Signature);
  PAGED_CODE();

  //
  // Gather info needed to select the correct PST for this processor.
  //

  //
  // Get special CPUID using extended CPUID fuction 1
  //

  CPUID(0x80000001, &Signature->CpuId, &junk, &junk, &junk);

  //
  // Get MAX Fid & Startup VID
  //
  
  fidVidStatus.AsQWord = ReadMSR(AMDK7_FID_VID_STATUS_MSR);
  Signature->MaxFid = (UCHAR) fidVidStatus.MFid;
  Signature->StartVid = (UCHAR) fidVidStatus.SVid;

  //
  // Get Front Side Bus speed
  //

  Signature->FSBSpeed = GetFSBSpeed();
  DebugAssert(Signature->FSBSpeed);

  return STATUS_SUCCESS;
}


UCHAR
GetFSBSpeed(
  VOID
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  UCHAR speed;

  PAGED_CODE();

  //
  // FSB Speed == CPU frequency / FSB multiplier
  // 

  // toddcar - 4/30/01 - ISSUE:
  // Need to finish support for 133mhz
  //
  
  speed = 100;
  return speed;
}


NTSTATUS
ConvertPstToPss (
  IN PFDO_DATA DevExt,
  IN PPST_ENTRY PstEntry,
  OUT PACPI_PSS_PACKAGE *PssPackage
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  NTSTATUS status = STATUS_SUCCESS;  
  ULONG    pssSize;
  ULONG    x;
  ULONG    currentState;
  PACPI_PSS_PACKAGE tmpPss;

  DebugEnter();
  DebugAssert(PstEntry);
  DebugAssert(PssPackage);
  PAGED_CODE();

  

  // 
  // Allocate a chunk for PssPackage
  //
  
  pssSize = (sizeof(ACPI_PSS_DESCRIPTOR) * (PstEntry->NumPStates - 1)) +
              sizeof(ACPI_PSS_PACKAGE);


  tmpPss = ExAllocatePoolWithTag(NonPagedPool,
                                 pssSize,
                                 PROCESSOR_POOL_TAG);


  if (!tmpPss) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto ConvertPstToPssExit;
  }

  RtlZeroMemory(tmpPss, pssSize);
  tmpPss->NumPStates = PstEntry->NumPStates;


  //
  // Build a _PSS table
  // 

  for (x = 0; x < PstEntry->NumPStates; x++) {
   
    PSS_CONTROL pssControl = {0};
    PSS_STATUS  pssStatus  = {0};
    ULONG       pssState   = (PstEntry->NumPStates - 1) - x;

    pssControl.Fid = pssStatus.Fid = PstEntry->States[x].Fid;
    pssControl.Vid = pssStatus.Vid = PstEntry->States[x].Vid;
    pssControl.SGTC = PstEntry->FSBSpeed * 100; // need to finish support for 133mhz bus

    tmpPss->State[pssState].Control = pssControl.AsDWord;
    tmpPss->State[pssState].Status = pssStatus.AsDWord;
   
    DebugAssert(pssControl.Fid < INVALID_FID_VALUE);
    tmpPss->State[pssState].CoreFrequency = FSB100FidToCpuFreq[pssControl.Fid];

    DebugAssert(pssControl.Vid < INVALID_VID_VALUE);
    tmpPss->State[pssState].Power = MobileVidToCpuVoltage[pssControl.Vid];

  }

    
  //
  // Walk through each state collecting more information
  //
 
  status = FindCurrentPssPerfState(tmpPss, &currentState);
  
  if (!NT_SUCCESS(status)) {
    goto ConvertPstToPssExit;
  }

  DevExt->CurrentPssState = currentState;
  DevExt->PssPackage = tmpPss;


  //
  // Set Latency Info
  //

  status = ValidatePssLatencyValues(DevExt);

  
  //
  // Restore saved state
  //

  if (DevExt->CurrentPssState != currentState) {
    Acpi2PerfStateTransition(DevExt, currentState);
  }
  

  //
  // Need to merge this new data with our perfstates
  //
  
  MergePerformanceStates(DevExt);
  
  
ConvertPstToPssExit:

  if (!NT_SUCCESS(status)) {

    if (DevExt->PssPackage) {
      ExFreePool(DevExt->PssPackage);
      DevExt->PssPackage = NULL;
    }

  }

  DebugExitStatus(status);
  return status;

}
ULONG
GetPSTSize(
  IN PPST_BLOCK_HEADER PstBlock
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  ULONG size;
  ULONG x;
  PPST_ENTRY pstEntry;

  DebugAssert(PstBlock);

  size = sizeof(PST_BLOCK_HEADER);  // include block header, and one pst entry
  size += sizeof(PST_ENTRY) * (PstBlock->NumPST - 1);

  pstEntry = &PstBlock->PstState;

  for (x=0; x < PstBlock->NumPST; x++) {

    size += sizeof(PST_DATA) * (pstEntry->NumPStates-1);
   
    pstEntry = (PPST_ENTRY)((PUCHAR)pstEntry + sizeof(PST_ENTRY) + 
               (sizeof(PST_DATA) * (pstEntry->NumPStates - 1)));

  }

  return size;

}


#if DBG
VOID
DumpPSTBlock(
  PPST_BLOCK_HEADER PstBlock
  )
{

  ULONG x, y;
  PPST_ENTRY pstEntry;

  DebugAssert(PstBlock);

  DebugPrint((TRACE, "\n"));
  DebugPrint((TRACE, "PstBlock:\n"));
  DebugPrint((TRACE, "  Signature:     %.10s\n", PstBlock->Signature));
  DebugPrint((TRACE, "  TableVersion:  %u\n", PstBlock->TableVersion));
  DebugPrint((TRACE, "  Flags:         0x%x\n", PstBlock->Flags));
  DebugPrint((TRACE, "  SettlingTime:  %u us\n", PstBlock->SettlingTime));
  DebugPrint((TRACE, "  Reserved1:     0x0\n", PstBlock->Reserved1));
  DebugPrint((TRACE, "  NumPST:        %u\n", PstBlock->NumPST));
  DebugPrint((TRACE, "\n"));

  //
  // Get First PST Entry
  //

  pstEntry = &PstBlock->PstState;

  for (x=0; x < PstBlock->NumPST; x++) {

    DumpPSTEntry(pstEntry);
    
    //
    // Get Next PST State
    //
    
    pstEntry = (PPST_ENTRY)((PUCHAR)pstEntry + sizeof(PST_ENTRY) + 
               (sizeof(PST_DATA) * (pstEntry->NumPStates - 1)));

  }
}


VOID
DumpPSTEntry(
  PPST_ENTRY PstEntry
  )
{
  ULONG y;

  DebugPrint((TRACE, "PST Entry:\n"));
  DebugPrint((TRACE, "  CpuId:     0x%x\n", PstEntry->CpuId));
  DebugPrint((TRACE, "  FSBSpeed:  %u mhz\n", PstEntry->FSBSpeed));
  DebugPrint((TRACE, "  MaxFid:    0x%x\n", PstEntry->MaxFid));
  DebugPrint((TRACE, "  StartVid:  0x%x\n", PstEntry->StartVid));
  DebugPrint((TRACE, "  NumPStates %u\n", PstEntry->NumPStates));
  
  for (y=0; y < PstEntry->NumPStates; y++) {
  
    DebugPrint((TRACE, "  State #%u (Fid: 0x%x, Vid: 0x%x)\n", 
                y,
                PstEntry->States[y].Fid,
                PstEntry->States[y].Vid));
  }
  
  DebugPrint((TRACE, "\n"));

}


VOID
DumpPSTSignature(
  PPST_SIGNATURE PstSig
  )
{

  DebugPrint((TRACE, "PST Signature:\n"));
  DebugPrint((TRACE, "  CpuId:     0x%x\n", PstSig->CpuId));
  DebugPrint((TRACE, "  FSBSpeed:  %u mhz\n", PstSig->FSBSpeed));
  DebugPrint((TRACE, "  MaxFid:    0x%x\n", PstSig->MaxFid));
  DebugPrint((TRACE, "  StartVid:  0x%x\n", PstSig->StartVid));
  DebugPrint((TRACE, "\n"));

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\crusoe\crusoe.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crusoe.h


Author:

    Todd Carpenter (10/31/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#ifndef _CRUSOE_H
#define _CRUSOE_H

#include "..\lib\processor.h"
#include "..\eventmsg.h"
#include <pshpack1.h>


//
// CPUID 
//

#define LONGRUN_CPUID_MAXFUNCTION     0x80860000  // Max supported CPUID function, (ie 0x80860007)
#define LONGRUN_CPUID_PROCESSOR_INFO  0x80860001  
#define LONGRUN_CPUID_GETSTATE        0x80860007  // Current Speed, Voltage, and State


//
// read:  upper:lower bound of current performance percentage window
// write: set the upper:lower bound of desired performance percentage window
//        Correct:
//          if EDX == EAX == 100d, then full performance (ie LongRun disabled)
//          if EDX == EAX, then fixed performance
//          if EDX > EAX, the performance within upper:lower window
//
//        Incorrect: (results in #GP(0))
//          if (EDX > 100d) or (EAX > 100d)
//          if (EDX < EAX)
//

//
// CMS4.1 MSR
//

#define LONGRUN_CONTROL_STATUS_MSR        0x80868010


//
// CMS4.2 Longrun Table Interface  MSR's
//

#define LONGRUN_FLAGS_REGISTER_MSR        0x80868011
#define LONGRUN_TI_READOUT_MSR            0x80868018
#define LONGRUN_TI_PERFORMANCE_INDEX_MSR  0x80868019
#define LONGRUN_TI_VOLTAGE_FREQUENCY_MSR  0x8086801A
#define LONGRUN_TI_MEMORY_DIVISORS_MSR    0x8086801B
#define LONGRUN_TI_IO_DIVISORS_MSR        0x8086801C
#define LONGRUN_TI_GATE_DELAY_MSR         0x8086801D

//
// Processor Feature Flags
//

#define FEATURE_LONGRUN_ENALBED           0x2
#define FEATURE_LRTI_ENABLED              0x8

#define INVALID_LONGRUN_STATE             (ULONG)-1
#define MAX_LONGRUN_VALUE                 100
#define MAX_LONGRUN_STATES                4
#define CRUSOE_TRANSITION_LATENCY         20 // microseconds


typedef struct _STATE_INFO {

  ULONG CpuSpeed;
  ULONG Voltage;
  ULONG LongRunValue;

} STATE_INFO, *PSTATE_INFO;

typedef struct _LEGACY_INTERFACE_INFO {

  ULONG CurrentState;
  ULONG MaxSupportedStates;
  ULONG CurrentlyAvailableStates;
  
} LEGACY_INTERFACE_INFO, *PLEGACY_INTERFACE_INFO;

typedef struct _LONGRUN_STATES {

  ULONG      MaxState;
  STATE_INFO States[MAX_LONGRUN_STATES];
    
} LONGRUN_STATES, *PLONGRUN_STATES;


//
// Acpi 2.0 stuff
//

typedef struct {
  union {
    struct {
      ULONG  Min:16;      // 15:0   LongRun Lower Bound
      ULONG  Max:16;      // 31:16  LongRun Upper Bound 
    };
    ULONG AsDWord;
  };
} CRUSOE_PSS_VALUE;




//
// crusoe.c
//

NTSTATUS
AdjustLegacyProcessorPerformanceStates(
  IN OUT PPROCESSOR_PERFORMANCE_STATES PerfStates
  );  

//
// longrun.c
//

NTSTATUS
InitializeLegacyInterface(
  IN PFDO_DATA DeviceExtension
  );

NTSTATUS
SetCurrentStateMSR(
  IN ULONG   State,
  IN BOOLEAN InitPhase
  );

ULONG
ConvertLongRunValueToPerfState(
  IN PLONGRUN_STATES PerfStates,
  IN ULONG LongRunValue
  );
  
NTSTATUS
GetCurrentCpuSpeed(
  OUT PULONG CpuSpeed
  );
  
NTSTATUS
GetMaxCpuSpeed(
  OUT PULONG CpuSpeed
  );

VOID
GetProcessorFeatureFlags(
  OUT PULONG Flags
  );
  
NTSTATUS
GetCurrentStateInfo(
  OUT PSTATE_INFO StateInfo
  );

ULONGLONG
GetCurrentPerformanceRange(
  VOID
  );

VOID
SetCurrentPerformanceRange(
  IN ULONG Min,
  IN ULONG Max
  );

NTSTATUS
CalculateLongRunPerfStates(
  IN PLONGRUN_STATES PerfStates
  );

NTSTATUS
BuildAcpi2PerformanceStates(
  IN PACPI_PSS_PACKAGE PerfStates
  );
    
NTSTATUS
BuildLongRunPerfStatesCMS41(
  OUT PACPI_PSS_PACKAGE *PssPackage
  );
  
NTSTATUS
BuildLongRunPerfStatesCMS42(
  OUT PACPI_PSS_PACKAGE *PssPackage
  );

ULONG
LRTI_GetMaxSupportedLevel(
  VOID
  );

VOID
LRTI_SetCurrentLevel (
  ULONG LongRunLevel
  );

ULONG
LRTI_GetPerformanceIndex (
  VOID
  );

ULONG
LRTI_GetVoltage (
  VOID
  );

ULONG
LRTI_GetFrequency (
  VOID
  );

ULONG
GetLongRunFlagsRegister (
  VOID
  );

VOID
SetLongRunEconomyMode (
  VOID
  );

VOID
SetLongRunPerformanceMode (
  VOID
  );

#if DBG
VOID
DisplayStateInfo(
  IN PSTATE_INFO State
  );

VOID
DisplayLongRunStates(
  IN PLONGRUN_STATES States
  );
 
#else
#define DisplayStateInfo(_x_)
#define DisplayLongRunStates(_x_)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk7\inf\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
_INF=obj\$(TARGET_DIRECTORY)

make_infs:\
    $(_INF)\amdk7.inf

#
# Explicit dependencies.
#

#
# 'Standard' infs. The rules are all the same.
#

$(_INF)\amdk7.inf: $(_INX)\amdk7.inx $(_LNG)\amdk7.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\crusoe\longrun.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    longrun.c

Abstract:

    This module implements the Crusoe LongRun Adaptive Power Control interface
    
Author:

    Todd Carpenter (10/31/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#include <ntddk.h>
#include <ntacpi.h>
#include "crusoe.h"

LONGRUN_STATES LongRunStates;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeLegacyInterface)
#pragma alloc_text (PAGE, GetCurrentCpuSpeed)
#pragma alloc_text (PAGE, GetMaxCpuSpeed)
#endif

NTSTATUS
InitializeLegacyInterface(
  IN PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  NTSTATUS status = STATUS_SUCCESS;
  ULONG flags;
    
  DebugEnter();
  PAGED_CODE();

 
  //
  // Check Processor Feature Flags 
  //

  GetProcessorFeatureFlags(&flags);

  if (flags & FEATURE_LONGRUN_ENALBED) {

    //
    // If the CMS4.2 Interface is present use it, else use CMS4.1
    //
    
    if (flags & FEATURE_LRTI_ENABLED) {

      DebugPrint((ERROR, "Using LongRun CMS 4.2 Interface\n"));
      BuildLongRunPerfStatesCMS42(&DeviceExtension->PssPackage);
      
    } else {
  
      DebugPrint((ERROR, "Using LongRun CMS 4.1 Interface\n"));
      BuildLongRunPerfStatesCMS41(&DeviceExtension->PssPackage);
      
    }

    DeviceExtension->PctPackage.Control.AddressSpaceID = AcpiGenericSpaceFixedFunction;
    DeviceExtension->PctPackage.Status.AddressSpaceID = AcpiGenericSpaceFixedFunction;

    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DeviceExtension);
    
  } else {

    //
    // LongRun Interface is not present
    //

    DebugAssert(!"LongRun Interface is NOT enabled!\n");
    status = STATUS_UNSUCCESSFUL;

  }

  
  DebugExitStatus(status)
  return status;
}


NTSTATUS
SetCurrentStateMSR(
  IN ULONG   State,
  IN BOOLEAN InitPhase
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG index, longRunMax, longRunMin = 0;
  NTSTATUS status = STATUS_SUCCESS;
  ULARGE_INTEGER longRunStatus;
  
  // 
  // Convert our Perf State Value to LongRun value.
  // NOTE: LongRun states are stored in Ascending order.
  //

  index = (LongRunStates.MaxState - 1) - State;
  longRunMax = LongRunStates.States[index].LongRunValue;

  if (InitPhase) {
    longRunMin = longRunMax;
  }

  DebugPrint((ERROR, "Setting Long Run Range: l=0x%x, u=0x%x\n", longRunMin, longRunMax));
  SetCurrentPerformanceRange(longRunMin, longRunMax);
  longRunStatus.QuadPart = GetCurrentPerformanceRange();

  if ((longRunStatus.HighPart != longRunMax) ||
      (longRunStatus.LowPart != longRunMin)) {
  
    DebugPrint((ERROR, "ERROR! Expected: l=0x%x, h=0x%x Recieved: l=0x%x, h=0x%x\n",
               longRunMin,
               longRunMax,
               longRunStatus.LowPart,
               longRunStatus.HighPart));
                
    status = STATUS_UNSUCCESSFUL;
  }

  return status;  
}


ULONG
ConvertLongRunValueToPerfState(
  IN PLONGRUN_STATES PerfStates,
  IN ULONG LongRunValue
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG x;
  
  // 
  // Convert Transemta state values in Perf state values.
  //
  
  for (x = 0; x < PerfStates->MaxState; x++) {

    if (PerfStates->States[x].LongRunValue == LongRunValue) {
      return x;
    }
  }
  
  return INVALID_LONGRUN_STATE;
}


NTSTATUS
GetCurrentCpuSpeed(
  OUT PULONG CpuSpeed
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  NTSTATUS status;
  STATE_INFO stateInfo;

  DebugAssert(CpuSpeed);
  
  status = GetCurrentStateInfo(&stateInfo);

  if (NT_SUCCESS(status)) {
    *CpuSpeed = stateInfo.CpuSpeed;    
  }
  
  return status;
}


NTSTATUS
GetMaxCpuSpeed(
  OUT PULONG CpuSpeed
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG junk;

  DebugAssert(CpuSpeed);
  PAGED_CODE();

  CPUID(LONGRUN_CPUID_PROCESSOR_INFO,
        &junk,
        &junk,
        CpuSpeed,
        &junk);

  return STATUS_SUCCESS;
  
}


VOID
GetProcessorFeatureFlags(
  OUT PULONG Flags
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG junk;

  DebugAssert(Flags);
  PAGED_CODE();

  CPUID(LONGRUN_CPUID_PROCESSOR_INFO,
        &junk,
        &junk,
        &junk,
        Flags);
  
}


NTSTATUS
GetCurrentStateInfo(
  OUT PSTATE_INFO StateInfo
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG junk;
  
  DebugAssert(StateInfo);
  
  CPUID(LONGRUN_CPUID_GETSTATE,
        &StateInfo->CpuSpeed,
        &StateInfo->Voltage,
        &StateInfo->LongRunValue,
        &junk);

  return STATUS_SUCCESS;

}


ULONGLONG
GetCurrentPerformanceRange(
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  return ReadMSR(LONGRUN_CONTROL_STATUS_MSR);
}


VOID
SetCurrentPerformanceRange(
  IN ULONG Min,
  IN ULONG Max
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msrInfo;

  msrInfo.LowPart = Min;
  msrInfo.HighPart = Max;
  
  WriteMSR(LONGRUN_CONTROL_STATUS_MSR, msrInfo.QuadPart);

}


NTSTATUS
CalculateLongRunPerfStates(
  IN PLONGRUN_STATES PerfStates
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  STATE_INFO stateInfo;
  ULONG x, currentPerfState = 0;
  ULONG currentLongRunValue = INVALID_LONGRUN_STATE;

  DebugAssert(PerfStates);

  PerfStates->MaxState = MAX_LONGRUN_STATES;
  
  //
  // step through each state from 0 - 100, recording
  // unique performance states
  //

  for (x = 0; x <= MAX_LONGRUN_VALUE; x++) {

    //DebugPrint((ERROR, "Transition to state %u\n", x));
    SetCurrentPerformanceRange(x, x);
    GetCurrentStateInfo(&stateInfo);
    //DisplayStateInfo(&stateInfo);
   
    //
    // If this is a new state, record it.
    //
    // NOTE: we are ASSUMING that all states with identical LongRun
    //       state values are contigous AND that the LongRun values
    //       are increasing in value.  Here is an example of what we
    //       expect to find.
    //
    //       LongRun States (0-100)     unique LongRun value
    //    
    //         0-25                               0
    //         26-50                              40
    //         51-75                              71
    //         76-100                             100
    //

    if (stateInfo.LongRunValue != currentLongRunValue) {

      DebugAssert(currentPerfState < PerfStates->MaxState);
      DebugAssert(stateInfo.LongRunValue <= MAX_LONGRUN_VALUE);
      
      currentLongRunValue = stateInfo.LongRunValue;
            
      RtlCopyMemory(&PerfStates->States[currentPerfState++],
                    &stateInfo,
                    sizeof(STATE_INFO));
                    
    }

  }

  return STATUS_SUCCESS;
}


NTSTATUS
BuildAcpi2PerformanceStates(
  IN PACPI_PSS_PACKAGE PerfStates
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  return STATUS_SUCCESS;
}


NTSTATUS
BuildLongRunPerfStatesCMS41(
  OUT PACPI_PSS_PACKAGE *PssPackage
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG x;
  ULONG pssSize;
  ULONG currentPerfState = 0;
  ULONG currentLongRunValue = INVALID_LONGRUN_STATE;
  NTSTATUS status = STATUS_SUCCESS;
  STATE_INFO stateInfo;
  PACPI_PSS_PACKAGE tmpPss;
  
  DebugEnter();
  DebugAssert(PssPackage);
 
  
  pssSize = sizeof(ACPI_PSS_PACKAGE) + 
           ((MAX_LONGRUN_STATES-1) * sizeof(ACPI_PSS_DESCRIPTOR));
  
  tmpPss = ExAllocatePoolWithTag(NonPagedPool,
                                 pssSize,
                                 PROCESSOR_POOL_TAG);


  if (!tmpPss) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto BuildLongRunPerfStatesCMS41Exit;
  }


  //
  // Iterate through each level collecting data.
  //

  tmpPss->NumPStates = MAX_LONGRUN_STATES;

  for (x = 0; x <= MAX_LONGRUN_VALUE; x += 5) {

    SetCurrentPerformanceRange(x, x);
    GetCurrentStateInfo(&stateInfo);
   
   
    //
    // If this is a new state, record it.
    //
    // NOTE: we are ASSUMING that all states with identical LongRun
    //       state values are contigous AND that the LongRun values
    //       are increasing in value.  Here is an example of what we
    //       expect to find.
    //
    //       LongRun States (0-100)     unique LongRun value
    //    
    //         0-25                               0
    //         26-50                              40
    //         51-75                              71
    //         76-100                             100
    //

    if (stateInfo.LongRunValue != currentLongRunValue) {

      PACPI_PSS_DESCRIPTOR state;
      CRUSOE_PSS_VALUE longRunState = {0};
      
      DebugAssert(currentPerfState < MAX_LONGRUN_STATES);
      DebugAssert(stateInfo.LongRunValue <= MAX_LONGRUN_VALUE);

      state = &tmpPss->State[(MAX_LONGRUN_STATES-1) - currentPerfState];
      
      state->CoreFrequency = stateInfo.CpuSpeed;

      DebugAssert(stateInfo.Voltage < MAXUSHORT);
      state->Power = stateInfo.Voltage;
      state->Latency = CRUSOE_TRANSITION_LATENCY;
  
      longRunState.Max = stateInfo.LongRunValue;
      state->Control = longRunState.AsDWord;
      state->Status = longRunState.AsDWord;

      state->BmLatency = 0;

      //
      // If we have found all of the states, bail
      //
      
      if (currentPerfState == (MAX_LONGRUN_STATES-1)) {
        break; 
      } else {
        currentLongRunValue = stateInfo.LongRunValue;
        currentPerfState++;      
      }
      
    }

  }

  *PssPackage = tmpPss;
  
BuildLongRunPerfStatesCMS41Exit:

  DebugExitStatus(status);
  return status;
}


NTSTATUS
BuildLongRunPerfStatesCMS42(
  OUT PACPI_PSS_PACKAGE *PssPackage
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULONG maxLevel;
  ULONG pssSize;
  ULONG x;
  NTSTATUS status = STATUS_SUCCESS;
  PACPI_PSS_PACKAGE tmpPss;

  DebugEnter();
  DebugAssert(PssPackage);
 
  
  //
  // Get max LongRun Level
  //

  maxLevel = LRTI_GetMaxSupportedLevel();
  
  pssSize = sizeof(ACPI_PSS_PACKAGE) + (maxLevel * sizeof(ACPI_PSS_DESCRIPTOR));
  tmpPss = ExAllocatePoolWithTag(NonPagedPool,
                                 pssSize,
                                 PROCESSOR_POOL_TAG);


  if (!tmpPss) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto BuildLongRunPerfStatesCMS42Exit;
  }


  //
  // Iterate through each level collecting data.
  //

  DebugAssert(maxLevel < MAXUCHAR);
  tmpPss->NumPStates = (UCHAR) maxLevel+1;
  
  for (x=0; x <= maxLevel; x++) {

    PACPI_PSS_DESCRIPTOR state = &tmpPss->State[x];
    CRUSOE_PSS_VALUE longRunState;
    ULONG voltage;
    
    LRTI_SetCurrentLevel(x);

    state->CoreFrequency = LRTI_GetFrequency();

    voltage = LRTI_GetVoltage();
    
    DebugAssert(voltage < MAXUSHORT);
    state->Power = voltage;

    state->Latency = CRUSOE_TRANSITION_LATENCY;

    longRunState.Max = LRTI_GetPerformanceIndex();
    longRunState.Min = 0;
    
    state->Control = longRunState.AsDWord;
    state->Status = longRunState.AsDWord;

    state->BmLatency = 0;
    
  }

  
  *PssPackage = tmpPss;
      

BuildLongRunPerfStatesCMS42Exit:

  DebugExitStatus(status);
  return status;
}


ULONG
LRTI_GetMaxSupportedLevel(
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER results;
  
  results.QuadPart = ReadMSR(LONGRUN_TI_READOUT_MSR);
  return results.HighPart;
}


VOID
LRTI_SetCurrentLevel (
  ULONG LongRunLevel
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr;

  msr.LowPart = LongRunLevel;
  msr.HighPart = 0;
  
  WriteMSR(LONGRUN_TI_READOUT_MSR, msr.QuadPart);
}


ULONG
LRTI_GetPerformanceIndex (
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr;
  
  msr.QuadPart = ReadMSR(LONGRUN_TI_PERFORMANCE_INDEX_MSR);
  return msr.LowPart;
}


ULONG
LRTI_GetVoltage (
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr;
  
  msr.QuadPart = ReadMSR(LONGRUN_TI_VOLTAGE_FREQUENCY_MSR);
  return msr.HighPart;
}


ULONG
LRTI_GetFrequency (
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr;
  
  msr.QuadPart = ReadMSR(LONGRUN_TI_VOLTAGE_FREQUENCY_MSR);
  return msr.LowPart;
}


ULONG
GetLongRunFlagsRegister (
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr;
  
  msr.QuadPart = ReadMSR(LONGRUN_FLAGS_REGISTER_MSR);
  return msr.LowPart;
}


VOID
SetLongRunEconomyMode (
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr = {0};
  
  WriteMSR(LONGRUN_FLAGS_REGISTER_MSR, msr.QuadPart);
}


VOID
SetLongRunPerformanceMode (
  VOID
  )
/*++

  Routine Description:
         
  Arguments:
  
  Return Value:
  
--*/
{
  ULARGE_INTEGER msr = {0};

  msr.LowPart |= 0x1;
  WriteMSR(LONGRUN_FLAGS_REGISTER_MSR, msr.QuadPart);
}


#if DBG
VOID
DisplayStateInfo(
  IN PSTATE_INFO State
  )
{
  DebugPrint((MAXTRACE, "State Info:\n"));
  DebugPrint((MAXTRACE, "  Processor Clock Frequency: %u Mhz\n", State->CpuSpeed));
  DebugPrint((MAXTRACE, "  Processor Core Voltage:    %u millivolts\n", State->Voltage));
  DebugPrint((MAXTRACE, "  LongRun Value [0-100]:     %u\n", State->LongRunValue));
  DebugPrint((MAXTRACE, "  Performance State:         %u\n", ConvertLongRunValueToPerfState(
                                                               &LongRunStates,
                                                               State->LongRunValue)));
  DebugPrint((MAXTRACE, "\n"));
}


VOID
DisplayLongRunStates(
  IN PLONGRUN_STATES States
  )
{
  ULONG x;

   DebugPrint((MAXTRACE, "LongRun Performance Levels:\n"));

  for (x = 0; x < States->MaxState; x++) {

    DebugPrint((ERROR, "State %u:\n", x));
    DisplayStateInfo(&States->States[x]);
  }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\generic\generic.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    generic.c

Abstract:

    This module implements code that works on any processor.

Author:

    Jake Oshins (3/23/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#include "..\lib\processor.h"


//
// Must define for debug output
//

#if DBG
PUCHAR DebugName = "Processr.sys";
#endif

PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
UCHAR DevExtIndex;
extern GLOBALS Globals;


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeNonAcpiPerformanceStates)
#pragma alloc_text (PAGE, InitializeAcpi2PStates)
#pragma alloc_text (PAGE, InitializeAcpi2Cstates)
#pragma alloc_text (PAGE, MergePerformanceStates)
#endif

NTSTATUS
InitializeDriver(
  PUNICODE_STRING ServiceKeyRegPath
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{

  // 
  // Register for power state change notification
  //
  
  //PowerStateHandlerNotificationRegistration(ProcessSleepStateNotification,
  //                                          NULL,
  //                                          TRUE);

  return STATUS_SUCCESS;
}


#ifdef _X86_


NTSTATUS
FASTCALL
SetPerfLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();


  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }
  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetPerfLevelGeneric(Throttle, DeviceExtension);

}

NTSTATUS
FASTCALL
SetThrottleLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();

  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }

  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];
  

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetThrottleLevelGeneric(Throttle, DeviceExtension);

}


NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  //
  // With the generic driver we only try to find the Processor Brand String 
  // via the CPUID
  //
  
  return GetCPUIDProcessorBrandString(BrandString, Size);
}


#else
NTSTATUS
FASTCALL
SetPerfLevel(
  IN UCHAR Throttle
  )
{
  TRAP();
  return STATUS_SUCCESS;
}


NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  DebugAssert(Size);

  *Size = 0;
  return STATUS_NOT_SUPPORTED;
}
#endif


NTSTATUS
InitializeAcpi2PStates(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:
 

  Arguments:
  

  Return Value:


--*/
{
  NTSTATUS status;

  status = InitializeAcpi2PStatesGeneric(DevExt);

  //
  // Make sure we didn't find any NON I/O or MEM addresses
  //
  
  if (NT_SUCCESS(status)) {
  
    if (((DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceIO) &&
         (DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceMemory)) ||
        ((DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceIO) &&
         (DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceMemory))) {

      DebugPrint((WARN, "ONLY Memory & I/O _PCT addresses are supported\n"));
      DebugPrint((WARN, "NOT using Acpi 2.0 Performance States\n"));

      //
      // Undo what InitializeAcpi2PStatesGeneric() did
      //

      if (DevExt->PssPackage) {
        ExFreePool(DevExt->PssPackage);
        DevExt->PssPackage = NULL;
      }
      
      return STATUS_NOT_SUPPORTED;
    }

    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DevExt);

    //
    // Need to merge this new data with our perfstates
    //
  
    MergePerformanceStates(DevExt);

  }

  return status;
}


NTSTATUS
InitializeAcpi2Cstates(
  PFDO_DATA DevExt
  )
/*++

Routine Description:

    This function looks to see if there is an ACPI 2.0 _CST object in the
    namespace, and, if there is, it replaces the functions found by
    InitializeAcpi1Cstates.

    Further note:  This function leaves the filling in of throttling functions
    to the InitializePerformanceStates functions.

Arguments:

    DeviceExtension

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
  ULONG  apicId;
  ULONG  index = 0;

  DebugEnter();

  
  //
  // Record the address of this processor's DeviceExtension, as the
  // throttling API doesn't give it to us.
  //

  if (!Globals.SingleProcessorProfile) {

    //
    // save the index into the DeviceExtension[] for later retrieval based
    // on APIC Id.
    //
    
    apicId = Globals.ProcInfo.ProcIdToApicId[DevExt->ProcObjInfo.PhysicalID];  
    Globals.ProcInfo.ApicIdToDevExtIndex[apicId] = DevExtIndex;

    index = DevExtIndex++;
    
  }

  
  //
  // save Device Extension pointer
  //
  
  DeviceExtensions[index] = DevExt;
  


  //
  //  This processor driver only supports I/O Space based Cstates.
  //  InitializeAcpi2IoSpaceCstates() will fail if it finds Cstates with
  //  non AcpiGenericSpaceIO type addresses.
  //

  return InitializeAcpi2IoSpaceCstates(DevExt);

}

NTSTATUS
MergePerformanceStates(
  IN  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:

      This routine looks at the performance states stored in the device extension.

  Arguments:

      DeviceExtension


  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

  NOTE:

      - The caller must hold PerfStateLock.

      - This is called during START_DEVICE, and after recieving a Notify(0x80)
        on the processor.

--*/
{

  DebugEnter();

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return MergePerformanceStatesGeneric(DeviceExtension);

}


NTSTATUS
Acpi2PerfStateTransition(
  IN PFDO_DATA DeviceExtension,
  IN ULONG     State
  )
/*++

Routine Description:

    This routine changes the performance state of the processor
    based on ACPI 2.0 performance state objects.

Arguments:

    State - Index into _PSS object

Return Value:

    none

--*/
{

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return Acpi2PerfStateTransitionGeneric(DeviceExtension, State);

}


NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();

  //
  // if we are resuming from Hibernate, and this is an Acpi 2.0 system,
  // we must re-claim perf state and cstate control from the bios.
  //

  if (PreviousState == PowerSystemHibernate) {

    if (DeviceExtension->PssPackage) {
      AssumeProcessorPerformanceControl();
    }
    
    if (DeviceExtension->CstPresent) {
      AssumeCStateControl();
    }
    
  }

  //
  // restore previous state
  //

  return RestoreToSavedPerformanceState(DeviceExtension);

}


NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{ 
  DebugEnter();

  //
  // save current state, transition to lowest non-throttled perf state
  //

  return SaveCurrentStateGoToLowVolts(DeviceExtension);
}


//
// Legacy function that must have a stub.
//

NTSTATUS
InitializeNonAcpiPerformanceStates(
    IN  PFDO_DATA   DeviceExtension
    )
/*++

  Routine Description:

      The generic processor driver doesn't have non-ACPI performance states.

  Arguments:

      FdoData - pointer to the device extension

  Return Value:

      NT status code


--*/
{

  return STATUS_NOT_FOUND;

}

NTSTATUS
AcpiLegacyPerfStateTransition(
  IN PFDO_DATA    DeviceExtension,
  IN ULONG        State
  )
/*++

  Routine Description:

      The generic processor driver doesn't have non-ACPI performance states.

  Arguments:

     State - Target State

  Return Value:

      NT Status

--*/
{

  TRAP();
  return STATUS_NOT_FOUND;

}


NTSTATUS
GetLegacyMaxProcFrequency(
  OUT PULONG CpuSpeed
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{

  TRAP();
  return STATUS_NOT_FOUND;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk7\legacy.h ===
/*++

  Copyright (c) 2000  Microsoft Corporation
  
  Module Name:
  
    legacy.h
  
  Author:
  
    Todd Carpenter (4/16/01) - create file
  
  Environment:
  
    Kernel mode
  
  Notes:
  
  Revision History:

--*/
#ifndef _AMDK7_LEGACY_H
#define _AMDK7_LEGACY_H

#include <pshpack1.h>

#define PST_BLOCK_SIGNATURE             0x4b444d41   // "AMDK"
#define PST_BLOCK_SIGNATURE_STRING      "AMDK7PNOW!" // 41 4d 44 4b 37 50 4e 4f 57 21
#define PST_BLOCK_SIGNATURE_STRING_LEN  10
#define PST_SEARCH_RANGE_BEGIN          0xC0000
#define PST_SEARCH_RANGE_END            0xFFFF0
#define PST_SEARCH_RANGE_LENGTH         (PST_SEARCH_RANGE_END-PST_SEARCH_RANGE_BEGIN+1)
#define PST_SEARCH_INTERVAL             16          // search on 16 byte boundaries



#pragma pack (push, 1)
typedef struct _PST_SIGNATURE {

  ULONG    CpuId;
  UCHAR    FSBSpeed;
  UCHAR    MaxFid;
  UCHAR    StartVid;

} PST_SIGNATURE, *PPST_SIGNATURE;


typedef struct _PST_DATA {

  UCHAR Fid;
  UCHAR Vid;

} PST_DATA, *PPST_DATA;


typedef struct _PST_ENTRY {

  ULONG    CpuId;
  UCHAR    FSBSpeed;
  UCHAR    MaxFid;
  UCHAR    StartVid;
  UCHAR    NumPStates;       // total number of vid-fid pairs (must be >= 1)
  PST_DATA States[1];

} PST_ENTRY, *PPST_ENTRY, **PPPST_ENTRY;


typedef struct _PST_BLOCK_HEADER {

  UCHAR     Signature[10];            // "AMDK7PNOW!"
  UCHAR     TableVersion;
  UCHAR     Flags;
  USHORT    SettlingTime;
  UCHAR     Reserved1;
  UCHAR     NumPST;
  PST_ENTRY PstState;

} PST_BLOCK_HEADER, *PPST_BLOCK_HEADER, **PPPST_BLOCK_HEADER;
#pragma pack (pop)


//
// Functions
//
  
NTSTATUS
FindPSTBlock (
  OUT PPPST_BLOCK_HEADER PstBlock  
  );

NTSTATUS
FindMatchingPSTEntry(
  IN  PPST_BLOCK_HEADER PstBlock,
  IN  PPST_SIGNATURE Signature,
  OUT PPPST_ENTRY  PstStates
  );

NTSTATUS
CreateSystemSignature(
  PPST_SIGNATURE Signature
  );

UCHAR
GetFSBSpeed(
  VOID
  );

NTSTATUS
ConvertPstToPss (
  IN PFDO_DATA DevExt,
  IN PPST_ENTRY PstEntry,
  OUT PACPI_PSS_PACKAGE *PssPackage
  );

ULONG
GetPSTSize(
  IN PPST_BLOCK_HEADER PstBlock
  );

#if DBG
VOID
DumpPSTBlock(
  PPST_BLOCK_HEADER PstBlock
  );

VOID
DumpPSTEntry(
  PPST_ENTRY PstEntry
  );

VOID
DumpPSTSignature(
  PPST_SIGNATURE PstSig
  );
#else
#define DumpPSTBlock(_x_)
#define DumpPSTEntry(_x_)
#define DumpPSTSignature(_x_)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\dbgsys.c ===
/*++

Copyright(c) 1998  Microsoft Corporation

Module Name:

    dbgsys.c

Abstract:

    Debug routines

Author:

    Todd Carpenter

Environment:

    kernel mode


Revision History:

    08-24-98 : created, toddcar

--*/
#if DBG

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>
#include "dbgsys.h"

#pragma alloc_text (PAGELK, PnPMinorFunctionString)
#pragma alloc_text (PAGELK, PowerMinorFunctionString)
#pragma alloc_text (PAGELK, DbgSystemPowerString)
#pragma alloc_text (PAGELK, DbgDevicePowerString)


#define DEBUG_BUFFER_SIZE  256
extern  PUCHAR DebugName;


VOID
_cdecl
DebugPrintX(
    ULONG  DebugLevel,
    PUCHAR Format,
    ...
    )
/*++

Routine Description:

   
Arguments:
  

Return Value:

--*/
{
  va_list  list; 
  UCHAR debugString[DEBUG_BUFFER_SIZE+1];
   
  va_start(list, Format);
  debugString[DEBUG_BUFFER_SIZE]=0;
  _vsnprintf(debugString, DEBUG_BUFFER_SIZE, Format, list);

  DbgPrintEx(DPFLTR_PROCESSOR_ID, 
             DebugLevel, 
             "%s: %s", 
             DebugName,
             debugString);

  return;
}


PUCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
{
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18

    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "IRP_MN_UNKNOWN";
    }
}

PUCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
    )
{
    switch (MinorFunction)
    {
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";

        default:
            return "IRP_MN_?????";
    }
}

PUCHAR
DbgSystemPowerString(
    IN SYSTEM_POWER_STATE Type
    )
{
    switch (Type)
    {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "UnKnown System Power State";
    }
}

PUCHAR
DbgPowerStateHandlerType(
    IN POWER_STATE_HANDLER_TYPE Type
    )
{
    switch (Type)
    {
        
        case PowerStateSleeping1:
            return "PowerStateSleeping1";
        case PowerStateSleeping2:
            return "PowerStateSleeping2";
        case PowerStateSleeping3:
            return "PowerStateSleeping3";
        case PowerStateSleeping4:
            return "PowerStateSleeping4";
        case PowerStateSleeping4Firmware:
            return "PowerStateSleeping4Firware";
        case PowerStateShutdownReset:
            return "PowerStateShutdownReset";
        case PowerStateShutdownOff:
            return "PowerStateShutdownOff";
        case PowerStateMaximum:
            return "PowerStateMaximum";        
        default:
            return "UnKnown Power State Handler Type";
    }
}
 
PUCHAR
DbgDevicePowerString(
    IN DEVICE_POWER_STATE Type
    )
{
    switch (Type)
    {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "UnKnown Device Power State";
    }
}

VOID
DisplayPowerStateInfo(
  IN ULONG_PTR Arg1,
  IN ULONG_PTR Arg2
  )
{

  switch (Arg1) {
  
    case PO_CB_SYSTEM_POWER_POLICY:
      DebugPrint((TRACE, "  Power Policy Changed.\n"));
      break;

    case PO_CB_AC_STATUS:
      DebugPrint((TRACE, "  AC/DC Transition.  Now on %s\n", Arg2 ? "AC" : "DC"));
      break;

    case PO_CB_BUTTON_COLLISION:
      DebugPrint((ERROR, "PO_CB_BUTTON_COLLISION\n"));
      break;
    
    case PO_CB_SYSTEM_STATE_LOCK:
      DebugPrint((TRACE, "  %sLock memory.\n", Arg2 ? "Un" : ""));
      break;

    case PO_CB_LID_SWITCH_STATE:
      DebugPrint((TRACE, "  Lid is now %s\n", Arg2 ? "Open" : "Closed"));
      break;

    case PO_CB_PROCESSOR_POWER_POLICY:
      DebugPrint((TRACE, "  Processor Power Policy Changed.\n"));
      break;
      
    default:
      DebugPrint((TRACE, "  Unknown PowerState value 0x%x\n", Arg1));
    
  }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\crusoe\crusoe.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    crusoe.c

Abstract:

    This module implements code specific to the Crusoe processor
    

Author:

    Todd Carpenter (10/31/00) - create file

Environment:

    Kernel mode

Notes:

  DeviceInst  = "ACPI\GenuineTMx86_-_x86_Family_5_Model_4"
  ServiceName = "crusoe"
   
Revision History:


--*/
#include "crusoe.h"
#include "..\lib\processor.h"

#if DBG
PUCHAR DebugName = "Crusoe.sys";
#endif

PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
UCHAR DevExtIndex;

extern GLOBALS Globals;
extern LONGRUN_STATES LongRunStates;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeDriver)
#pragma alloc_text (PAGE, InitializeNonAcpiPerformanceStates)
#pragma alloc_text (PAGE, InitializeAcpi2PStates)
#pragma alloc_text (PAGE, InitializeAcpi2Cstates)
#pragma alloc_text (PAGE, MergePerformanceStates)
#pragma alloc_text (PAGE, GetLegacyMaxProcFrequency)
#pragma alloc_text (PAGE, AdjustLegacyProcessorPerformanceStates)
#pragma alloc_text (PAGE, GetProcessorBrandString)
#endif


NTSTATUS
InitializeDriver(
  PUNICODE_STRING ServiceKeyRegPath
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PAGED_CODE();
  return STATUS_SUCCESS;
}


NTSTATUS
InitializeNonAcpiPerformanceStates(
  IN  PFDO_DATA   DeviceExtension
  )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
  NTSTATUS  status;
  
  DebugEnter();
  PAGED_CODE();

  //
  // We automatically fail to use the Legacy Interface
  //
  
  if (Globals.HackFlags & DISABLE_LEGACY_INTERFACE_FLAG) {
    DebugPrint((ERROR, " Legacy Interface Disabled\n"));
    return STATUS_NOT_FOUND;
  }


  // 
  // Find and gather legacy interface info
  //
  
  status = InitializeLegacyInterface(DeviceExtension);
  
  if (!NT_SUCCESS(status)) {
    DebugExitStatus(status);
    return status;
  }
  
  //
  // Found Legacy Interface, and is available to use.
  //
  
  DeviceExtension->LegacyInterface = TRUE;

              
  //
  // Merge Perf states with other states we may have.
  //
  
  status = MergePerformanceStates(DeviceExtension);
  DumpProcessorPerfStates(DeviceExtension->PerfStates);
  
  
  if (!NT_SUCCESS(status)) {
      
    if (DeviceExtension->PerfStates) {
      ExFreePool(DeviceExtension->PerfStates);
    }

    if (DeviceExtension->PssPackage) {
      ExFreePool(DeviceExtension->PssPackage);
    }
    
    DeviceExtension->PerfStates = NULL;
    DeviceExtension->LegacyInterface = FALSE;
  }

  
  DebugExitStatus(status);
  return status;
  
}


NTSTATUS
AcpiLegacyPerfStateTransition(
  IN PFDO_DATA DevExt,
  IN ULONG     State
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{  
  return Acpi2PerfStateTransition(DevExt, State);
}


NTSTATUS
FASTCALL
SetPerfLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();


  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }
  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetPerfLevelGeneric(Throttle, DeviceExtension);

}

NTSTATUS
FASTCALL
SetThrottleLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();

  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }

  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];
  

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetThrottleLevelGeneric(Throttle, DeviceExtension);

}


NTSTATUS
InitializeAcpi2PStates(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{
  NTSTATUS status;

  status = InitializeAcpi2PStatesGeneric(DevExt);

  if (NT_SUCCESS(status)) {
  
    if ((DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceFixedFunction) ||
        (DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceFixedFunction)) {

      DebugPrint((ERROR, "This driver ONLY supports FFH addresses for Acpi 2.0\n"));
      status = STATUS_NOT_FOUND;
    }

    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DevExt);
    
    //
    // Need to merge this new data with our perfstates
    //
    
    MergePerformanceStates(DevExt);

  }

  
  return status;
}

NTSTATUS
InitializeAcpi2Cstates(
    PFDO_DATA DevExt
    )
/*++

Routine Description:

    This function looks to see if there is an ACPI 2.0 _CST object in the 
    namespace, and, if there is, it replaces the functions found by 
    InitializeAcpi1Cstates.
    
    Further note:  This function leaves the filling in of throttling functions 
    to the InitializePerformanceStates functions.

Arguments:

    DeviceExtension

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
  ULONG    apicId;
  ULONG    index = 0;

  DebugEnter();
  PAGED_CODE();

  
  //
  // Record the address of this processor's DeviceExtension, as the
  // throttling API doesn't give it to us.
  //

  if (!Globals.SingleProcessorProfile) {

    //
    // save the index into the DeviceExtension[] for later retrieval based
    // on APIC Id.
    //
    
    apicId = Globals.ProcInfo.ProcIdToApicId[DevExt->ProcObjInfo.PhysicalID];  
    Globals.ProcInfo.ApicIdToDevExtIndex[apicId] = DevExtIndex;

    index = DevExtIndex++;
    
  }

  
  //
  // save Device Extension pointer
  //
  
  DeviceExtensions[index] = DevExt;
  

  //
  //  This processor driver only supports I/O Space based Cstates.
  //  InitializeAcpi2IoSpaceCstates() will fail if it finds Cstates with
  //  non AcpiGenericSpaceIO type addresses.
  //

  return InitializeAcpi2IoSpaceCstates(DevExt);

}

NTSTATUS
MergePerformanceStates (
  IN  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:
  
      This routine looks at the performance states stored in the device extension.
  
  Arguments:
  
      DeviceExtension
      
      
  Return Value:
  
      A NTSTATUS code to indicate the result of the initialization.
  
  NOTE: 

      - The caller must hold PerfStateLock.
      
      - This is called during START_DEVICE, and after recieving a Notify(0x80)
        on the processor.

--*/
{
  
  DebugEnter();
  PAGED_CODE();

  //
  // Use the generic method to merge our perf states with stop clock states
  //
  
  return MergePerformanceStatesGeneric(DeviceExtension);

}


NTSTATUS
Acpi2PerfStateTransition(
  IN PFDO_DATA DevExt,
  IN ULONG     NewState
  )
/*++

Routine Description:

    This routine changes the performance state of the processor
    based on ACPI 2.0 performance state objects.
    
Arguments:

    State - Index into _PSS object

Return Value:

    none

--*/
{
  ULONG lowerBound;
  ULONG uppperBound;
  NTSTATUS   status = STATUS_SUCCESS;
  STATE_INFO stateInfo;
  CRUSOE_PSS_VALUE  pssControl;
  CRUSOE_PSS_VALUE  pssStatus;
  ULARGE_INTEGER longRunRange;

  DebugEnter();
  
  //
  // The only type of Acpi 2.0 implementation this driver supports is FFH
  //
  
  DebugAssert(DevExt);
  DebugAssert(DevExt->PctPackage.Control.AddressSpaceID == AcpiGenericSpaceFixedFunction);
  DebugAssert(DevExt->PctPackage.Status.AddressSpaceID == AcpiGenericSpaceFixedFunction);

  pssControl.AsDWord = DevExt->PssPackage->State[NewState].Control;
  pssStatus.AsDWord = DevExt->PssPackage->State[NewState].Status;
  
  //
  // Sanity Check illeagal conditions
  //

  if (pssControl.Min > MAX_LONGRUN_VALUE) {
    DebugPrint((ERROR, "ERROR: illegal LongRun value: Min=0x%x\n", pssControl.Min));
    pssControl.Min = MAX_LONGRUN_VALUE;
  }

  if (pssControl.Max > MAX_LONGRUN_VALUE) {
    DebugPrint((ERROR, "ERROR: illegal LongRun value: Max=0x%x\n", pssControl.Max));
    pssControl.Max = MAX_LONGRUN_VALUE;
  }

  if (pssControl.Min > pssControl.Max) {
    DebugPrint((ERROR, "ERROR: illegal LongRun Range: Min: 0x%x, Max: 0x%x\n",
                pssControl.Min,
                pssControl.Max));

    pssControl.Min = pssControl.Max;  
  }

  
  //
  // Transition to new performance state
  //

  DebugPrint((ERROR, "Setting Long Run Range: l=0x%x, u=0x%x\n", pssControl.Min, pssControl.Max));
  SetCurrentPerformanceRange(pssControl.Min, pssControl.Max);

  
  //
  // Check to see if the transition was successful
  // NOTE: we have to check the LongRun Range rather than a specific state as
  //       there is no way to know which state within a given range the cpu 
  //       will be in.
  //
  
  longRunRange.QuadPart = GetCurrentPerformanceRange();

    
  if ((longRunRange.HighPart == pssStatus.Max) &&
      (longRunRange.LowPart == pssStatus.Min)) {

    DevExt->CurrentPssState = NewState;

  } else {

    DebugPrint((ERROR, "ERROR! Expected: l=0x%x, h=0x%x Recieved: l=0x%x, h=0x%x\n",
                pssStatus.Min, 
                pssStatus.Max,
                longRunRange.LowPart,
                longRunRange.HighPart));
                

    status = STATUS_UNSUCCESSFUL;
  }

  return status;
}


NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{
  DebugEnter();

  //
  // if we are resuming from Hibernate, and this is an Acpi 2.0 system,
  // we must re-claim perf state and cstate control from the bios.
  //

  if (PreviousState == PowerSystemHibernate) {

    if (DeviceExtension->PssPackage) {
      AssumeProcessorPerformanceControl();
    }
    
    if (DeviceExtension->CstPresent) {
      AssumeCStateControl();
    }
    
  }

  //
  // restore previous state
  //

  return RestoreToSavedPerformanceState(DeviceExtension);

}


NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{ 
  DebugEnter();

  //
  // save current state, transition to lowest non-throttled perf state
  //

  return SaveCurrentStateGoToLowVolts(DeviceExtension);
}


NTSTATUS
GetLegacyMaxProcFrequency(
  OUT PULONG CpuSpeed
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

    NTSTATUS


--*/ 
{
  PAGED_CODE();
  return GetMaxCpuSpeed(CpuSpeed);
}


NTSTATUS
AdjustLegacyProcessorPerformanceStates(
  IN OUT PPROCESSOR_PERFORMANCE_STATES PerfStates
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{
  PAGED_CODE();
  return STATUS_SUCCESS;
}


NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  PAGED_CODE();
  
  //
  // This processor family supports CPUID Brand String
  //
  
  return GetCPUIDProcessorBrandString(BrandString, Size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\eventlog.h ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

  eventlog.h

Author:

  Todd Carpenter

Environment:

  Kernel Mode Only
  
--*/

#ifndef _EVENTLOG_H_
#define _EVENTLOG_H_

 #include <ntddk.h>

#define DWORD_ALIGN(value)       (((ULONG)(value) + 3) & ~3)
#define DWORD_ALIGNED(value)     (!(NOT_DWORD_ALIGNED(value)))
#define NOT_DWORD_ALIGNED(value) (value & 0x3)

#define MIN(_a_,_b_) ((_a_) < (_b_) ? (_a_) : (_b_))
#define MAX(_a_,_b_) ((_a_) > (_b_) ? (_a_) : (_b_))

NTSTATUS
WriteEventLogEntry (
    IN  PVOID     DeviceObject,
    IN  ULONG     ErrorCode,
    IN  PVOID     InsertionStrings, OPTIONAL
    IN  ULONG     StringCount,      OPTIONAL
    IN  PVOID     DumpData, OPTIONAL
    IN  ULONG     DataSize  OPTIONAL
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\dbgsys.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dbgsys.h

Environment:

    Kernel mode

Revision History:

    7-13-2000 : created

--*/

#ifndef _DBG_SYS_
#define _DBG_SYS_

#if DBG
#include <ntpoapi.h>

#define ERROR      DPFLTR_ERROR_LEVEL    // 0
#define WARN       DPFLTR_WARNING_LEVEL  // 1
#define TRACE      DPFLTR_TRACE_LEVEL    // 2
#define INFO       DPFLTR_INFO_LEVEL     // 3
#define MAXTRACE   5 // processor driver specific


VOID
_cdecl
DebugPrintX(
    ULONG  DebugLevel,
    PUCHAR Format,
    ...
    );

PUCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    );

PUCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
    );

PUCHAR
DbgSystemPowerString (
    IN SYSTEM_POWER_STATE Type
    );
    
PUCHAR
DbgPowerStateHandlerType(
    IN POWER_STATE_HANDLER_TYPE Type
    );
    
PUCHAR
DbgDevicePowerString (
    IN DEVICE_POWER_STATE Type
    );

VOID
DisplayPowerStateInfo(
  IN ULONG_PTR Arg1,
  IN ULONG_PTR Arg2
  );

    
#define TRAP() DbgBreakPoint()

#define DebugPrint(_x_) DebugPrintX _x_

#define DebugAssert(exp)                               \
          if (!(exp)) {                                \
            RtlAssert(#exp, __FILE__, __LINE__, NULL); \
          }

#define DebugAssertMsg(exp, msg)                       \
          if (!(exp)) {                                \
            RtlAssert(#exp, __FILE__, __LINE__, msg);  \
          }

#define DebugEnter()  DebugPrint((MAXTRACE, "Entering " __FUNCTION__ "\n"));
#define DebugExit()   DebugPrint((MAXTRACE, "Leaving  " __FUNCTION__ "\n"));
      

#define DebugExitStatus(_status_)  \
          DebugPrint((MAXTRACE, "Leaving " __FUNCTION__ ": status=0x%x\n", _status_));

#define DebugExitValue(_rc_)  \
          DebugPrint((MAXTRACE, "Leaving " __FUNCTION__ ": rc=%d (0x%x)\n", _rc_, _rc_));

#define TurnOnFullDebugSpew()  \
          DbgSetDebugFilterState(DPFLTR_PROCESSOR_ID, -1, TRUE);
           
#else

#define TRAP()
#define DebugAssert(exp)
#define DebugAssertMsg(exp, msg)
#define DebugPrint(_x_)
#define DebugEnter()
#define DebugExit()
#define DebugExitStatus(_status_)
#define DebugExitValue(_rc_)
#define PnPMinorFunctionString
#define DbgSystemPowerString(_x_)
#define DbgDevicePowerString(_x_)
#define WalkProcessorPerfStates(_x_)
#define TurnOnFullDebugSpew()
#define DisplayPowerStateInfo(_x_, _y_)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\eventlog.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

  eventlog.c

Abstract:



Author:

  Todd Carpenter

Environment:

  Kernel Mode Only

Revision History:

  07-12-2000  created

--*/
#include "eventlog.h"
#include "dbgsys.h"

ULONG ErrorLogCount = 0;

NTSTATUS
WriteEventLogEntry (
    IN  PVOID     DeviceObject,
    IN  ULONG     ErrorCode,
    IN  PVOID     InsertionStrings, OPTIONAL
    IN  ULONG     StringCount,      OPTIONAL
    IN  PVOID     DumpData, OPTIONAL
    IN  ULONG     DataSize  OPTIONAL
    )
/*++

Routine Description:

    

Arguments:

    Status            - 
    UniqueErrorValue  - 
    InsertionStrings  - 
    StringCount       - 
    DumpData          - 
    DataSize          - 

Return Value:

    NTSTATUS

--*/
{
#define ERROR_PACKET_SIZE   sizeof(IO_ERROR_LOG_PACKET)

  NTSTATUS  status = STATUS_SUCCESS;
  ULONG     totalPacketSize;
  ULONG     i, stringSize = 0;
  PWCHAR    *strings, temp;
  PIO_ERROR_LOG_PACKET  logEntry;

  
  //  
  // Calculate total string length, including NULL.
  //
  
  strings = (PWCHAR *) InsertionStrings;
    
  for (i = 0; i < StringCount; i++) {

    UNICODE_STRING  unicodeString;

    RtlInitUnicodeString(&unicodeString, strings[i]);
    stringSize += unicodeString.Length + sizeof(UNICODE_NULL);
    //stringSize += (wcslen(strings[i]) + 1) * sizeof(WCHAR);

  }

  //
  // Calculate total packet size to allocate.  The packet must be
  // at least sizeof(IO_ERROR_LOG_PACKET) and not larger than
  // ERROR_LOG_MAXIMUM_SIZE or the IoAllocateErrorLogEntry call will fail.
  //
  
  totalPacketSize = ERROR_PACKET_SIZE + DataSize + stringSize;
  
  if (totalPacketSize >= ERROR_LOG_MAXIMUM_SIZE) {

    DebugPrint((TRACE, "WriteEventLogEntry: Error Log Entry too large.\n"));
    status = STATUS_UNSUCCESSFUL;
    goto WriteEventLogEntryExit;

  }


  //
  // Allocate the error log packet
  //
  
  logEntry = IoAllocateErrorLogEntry(DeviceObject,
                                     (UCHAR) totalPacketSize);

  if (!logEntry) {

    status = STATUS_INSUFFICIENT_RESOURCES;
    goto WriteEventLogEntryExit;

  }

  RtlZeroMemory(logEntry, totalPacketSize);


  //
  // Fill out the packet
  //
  
  //logEntry->MajorFunctionCode     = 0;
  //logEntry->RetryCount            = 0;
  //logEntry->UniqueErrorValue      = 0;
  //logEntry->FinalStatus           = 0;
  //logEntry->SequenceNumber        = ErrorLogCount++;
  //logEntry->IoControlCode         = 0;
  //logEntry->DeviceOffset.QuadPart = 0;

  logEntry->DumpDataSize          = (USHORT) DataSize;
  logEntry->NumberOfStrings       = (USHORT) StringCount;
  logEntry->EventCategory         = 0x1;            // type devices 
  logEntry->ErrorCode             = ErrorCode;
  
  if (StringCount) {
    logEntry->StringOffset = (USHORT) (ERROR_PACKET_SIZE + DataSize);
  }

  
  //
  // Copy Dump Data
  //
  
  if (DataSize) {

    RtlCopyMemory((PVOID) logEntry->DumpData,
                  DumpData,
                  DataSize);

  }


  //
  // Copy String Data
  //
  
  temp = (PWCHAR) ((PUCHAR) logEntry + logEntry->StringOffset);
    
  for (i = 0; i < StringCount; i++) {

    PWCHAR  ptr = strings[i];

    //
    // This routine will copy the null terminator on the string
    //
    
    while ((*temp++ = *ptr++) != UNICODE_NULL);
    

  }

  //
  // Submit error log packet
  //
  
  IoWriteErrorLogEntry(logEntry);


WriteEventLogEntryExit:

  return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\method.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    method.c

Abstract:

    This module implements code to find and evaluate
    ACPI objects.

Author:

    Jake Oshins (3/18/00) - create file

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "processor.h"
#include "acpiioct.h"
#include "ntacpi.h"
#include <wdmguid.h>
#include "apic.inc"
#include "..\eventmsg.h"

#define rgzMultiFunctionAdapter L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"
#define rgzAcpiConfigurationData L"Configuration Data"
#define rgzAcpiIdentifier L"Identifier"
#define rgzBIOSIdentifier L"ACPI BIOS"

const WCHAR CCSEnumRegKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum";
const WCHAR FriendlyNameRegKey[] = L"FriendlyName";
const WCHAR EnumKeyName[] = L"Enum";

extern FADT     HalpFixedAcpiDescTable;
extern ULONG    HalpThrottleScale;

extern WMI_EVENT PStateEvent;
extern WMI_EVENT NewPStatesEvent;
extern WMI_EVENT NewCStatesEvent;

// toddcar 4/24/01 ISSUE
// when we support CStates and Throttle States on MP machines
// these values need to be in the device extension.
//
GEN_ADDR PCntAddress;
GEN_ADDR C2Address;
GEN_ADDR C3Address;

//
//  Well known virtual address of local processor apic
//

#define LOCALAPIC   0xfffe0000
#define pLocalApic  ((ULONG volatile *) UlongToPtr(LOCALAPIC))


NTSTATUS
AcpiParseGenRegDesc(
    IN  PUCHAR      Buffer,
    OUT PGEN_ADDR   *GenericAddress
    );

NTSTATUS
AcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    );

VOID
AcpiNotify80CallbackWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
AcpiNotify81CallbackWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#if DBG
VOID
DumpCStates(
  PACPI_CST_PACKAGE CStates
  );
#else
#define DumpCStates(_x_)
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, AcpiEvaluateCst)
#pragma alloc_text (PAGE, AcpiEvaluateMethod)
#pragma alloc_text (PAGE, AcpiEvaluatePct)
#pragma alloc_text (PAGE, AcpiEvaluatePpc)
#pragma alloc_text (PAGE, AcpiEvaluateProcessorObject)
#pragma alloc_text (PAGE, AcpiEvaluatePss)
#pragma alloc_text (PAGE, AcpiEvaluatePtc)
#pragma alloc_text (PAGE, AcpiFindRsdt)
#pragma alloc_text (PAGE, AcpiNotify80CallbackWorker)
#pragma alloc_text (PAGE, AcpiParseGenRegDesc)
#pragma alloc_text (PAGE, AcquireAcpiInterfaces)
#pragma alloc_text (PAGE, GetRegistryValue)
#pragma alloc_text (PAGE, GetAcpiTable)
#pragma alloc_text (PAGE, InitializeAcpi2PStatesGeneric)
#pragma alloc_text (PAGE, ReleaseAcpiInterfaces)
#pragma alloc_text (PAGE, InitializeAcpi2IoSpaceCstates)
#endif

NTSTATUS
AcpiEvaluateMethod (
    IN  PFDO_DATA   DeviceExtension,
    IN  PCHAR       MethodName,
    IN  PVOID       InputBuffer OPTIONAL,
    OUT PVOID       *OutputBuffer
    )
/*

  Routine Description:

      This routine sends an IRP to ACPI to evaluate a method.

  Arguments:

      MethodName  - String identifying the method
      InputBuffer - Arguments for the method.  If specified, the
                    method name must match MethodName
      OutputBuffer- Return value(s) from method

  Return Value:

      NTSTATUS

--*/
#define CONTROL_METHOD_BUFFER_SIZE  0x1024
{

    ACPI_EVAL_INPUT_BUFFER   inputBuffer;
    NTSTATUS                 status;
    PIRP                     irp = NULL;
    KEVENT                   irpCompleted;
    IO_STATUS_BLOCK          statusBlock;
    ULONG                    inputBufLen;

    DebugEnter();
    PAGED_CODE();

    if (!InputBuffer) {

        //
        // The caller didn't specify an input buffer.  So
        // build one without any arguments out of the MethodName.
        //

        ASSERT(strlen(MethodName) <= 4);
        if (strlen(MethodName) > 4) {
            return STATUS_INVALID_PARAMETER_1;
        }

        inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
        strncpy(inputBuffer.MethodName, MethodName, sizeof(inputBuffer.MethodName));

        InputBuffer = &inputBuffer;
    }

    //
    // Figure out how big the input buffer is.
    //

    switch(((PACPI_EVAL_INPUT_BUFFER)InputBuffer)->Signature) {
    case ACPI_EVAL_INPUT_BUFFER_SIGNATURE:
        inputBufLen = sizeof(ACPI_EVAL_INPUT_BUFFER);
        break;

    case ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER_SIGNATURE:
        inputBufLen = sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER);
        break;

    case ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING_SIGNATURE:
        inputBufLen = sizeof(ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING) +
            ((PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING)InputBuffer)->StringLength - 1;
        break;

    case ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE:
        inputBufLen = ((PACPI_EVAL_INPUT_BUFFER_COMPLEX)InputBuffer)->Size;
        break;

    default:
        return STATUS_INVALID_PARAMETER_2;
    }

    KeInitializeEvent(&irpCompleted, NotificationEvent, FALSE);

    //
    // Allocate 1K for the output buffer.  That should handle
    // everything that is necessary for ACPI 2.0 processor objects.
    //

    *OutputBuffer = ExAllocatePoolWithTag(PagedPool,
                                          CONTROL_METHOD_BUFFER_SIZE,
                                          PROCESSOR_POOL_TAG);

    if (!*OutputBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the IRP.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_ACPI_EVAL_METHOD,
                                        DeviceExtension->NextLowerDriver,
                                        InputBuffer,
                                        inputBufLen,
                                        *OutputBuffer,
                                        CONTROL_METHOD_BUFFER_SIZE,
                                        FALSE,
                                        &irpCompleted,
                                        &statusBlock);

    if (!irp) {
        ExFreePool(*OutputBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    status = IoCallDriver(DeviceExtension->NextLowerDriver, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(*OutputBuffer);
    }

    return status;
}

NTSTATUS
AcpiEvaluateProcessorObject (
    IN  PFDO_DATA   DeviceExtension,
    OUT PVOID       *OutputBuffer
    )
/*

  Routine Description:

      This routine sends an IRP to ACPI to evaluate a processor object.

  Arguments:

      OutputBuffer- Return value(s) from object

  Return Value:

      NTSTATUS

--*/
{

    NTSTATUS                 status;
    PIRP                     irp = NULL;
    KEVENT                   irpCompleted;
    IO_STATUS_BLOCK          statusBlock;
    ULONG                    inputBufLen;

    DebugEnter();
    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, NotificationEvent, FALSE);

    //
    // Allocate 1K for the output buffer.  That should handle
    // everything that is necessary for ACPI 2.0 processor objects.
    //

    *OutputBuffer = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(PROCESSOR_OBJECT_INFO),
                                           PROCESSOR_POOL_TAG);

    if (!*OutputBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the IRP.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_GET_PROCESSOR_OBJ_INFO,
                                        DeviceExtension->NextLowerDriver,
                                        NULL,
                                        0,
                                        *OutputBuffer,
                                        sizeof(PROCESSOR_OBJECT_INFO),
                                        FALSE,
                                        &irpCompleted,
                                        &statusBlock);

    if (!irp) {
        ExFreePool(*OutputBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    status = IoCallDriver(DeviceExtension->NextLowerDriver, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(*OutputBuffer);
    }

    return status;
}

NTSTATUS
AcpiParseGenRegDesc(
    IN  PUCHAR      Buffer,
    OUT PGEN_ADDR   *GenericAddress
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    DebugEnter();
    PAGED_CODE();

    if ((Buffer[0] != 0x82)  ||
        ((Buffer[1] != 0x0b) && (Buffer[1] != 0x0c)) ||
        (Buffer[2] != 0)) {

        //
        // The buffer is not a Generic Register Descriptor.
        //

        DebugPrint((WARN, "ACPI BIOS error: _PTC object was not a Generic Register Descriptor\n"));
        return STATUS_NOT_FOUND;
    }

    //
    // The thing passes the sanity test.
    //

    *GenericAddress = ExAllocatePoolWithTag(PagedPool,
                                            sizeof(GEN_ADDR),
                                            PROCESSOR_POOL_TAG);

    if (!*GenericAddress) {
      return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // toddcar - 10/31/2000 - TEMP
    // Need to remove this code once new Acpi2.0 bios's change to
    // reflect new register descriptor type.  Defined in Acpi 2.0 errata 1.1
    //

    if (Buffer[1] == 0x0b) {

      (*GenericAddress)->AddressSpaceID = Buffer[3];
      (*GenericAddress)->BitWidth = Buffer[4];
      (*GenericAddress)->BitOffset = Buffer[5];
      (*GenericAddress)->Reserved = 0;

      RtlCopyMemory(&(*GenericAddress)->Address.QuadPart,
                    &(Buffer[6]),
                    sizeof(PHYSICAL_ADDRESS));
    } else {

      RtlCopyMemory(*GenericAddress,
                    &(Buffer[3]),
                    sizeof(GEN_ADDR));

    }


    return STATUS_SUCCESS;
}

NTSTATUS
AcpiEvaluatePtc(
    IN  PFDO_DATA   DeviceExtension,
    OUT PGEN_ADDR   *Address
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    PACPI_EVAL_OUTPUT_BUFFER    ptcBuffer;
    NTSTATUS                    status;

    DebugEnter();
    PAGED_CODE();

    status = AcpiEvaluateMethod(DeviceExtension,
                                "_PTC",
                                NULL,
                                &ptcBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(ptcBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE);

    //
    // Sanity check the output buffer.  (ACPI BIOSes can often be
    // wrong.
    //

    if (ptcBuffer->Count != 1) {

        DebugPrint((WARN, "ACPI BIOS error: _PTC object returned multiple objects\n"));
        status = STATUS_NOT_FOUND;
        goto AcpiEvaluatePtcExit;
    }

    if (ptcBuffer->Argument[0].Type != ACPI_METHOD_ARGUMENT_BUFFER) {

        DebugPrint((WARN, "ACPI BIOS error: _PTC object didn't return a buffer\n"));
        status = STATUS_ACPI_INVALID_ARGTYPE;
        goto AcpiEvaluatePtcExit;
    }

    if (ptcBuffer->Argument[0].DataLength != sizeof(GEN_ADDR) + 2) {

        //
        // The buffer is not the right size.
        //

        DebugPrint((WARN, "ACPI BIOS error: _PTC object returned a buffer of the wrong size\n"));
        status = STATUS_ACPI_INVALID_ARGTYPE;
        goto AcpiEvaluatePtcExit;
    }

    status = AcpiParseGenRegDesc(ptcBuffer->Argument[0].Data,
                                 Address);

AcpiEvaluatePtcExit:

    ExFreePool(ptcBuffer);
    return status;
}

NTSTATUS
AcpiEvaluateCst(
    IN  PFDO_DATA   DeviceExtension,
    OUT PACPI_CST_PACKAGE   *CStates
    )
/*

  Routine Description:

      This routine finds and evaluates the _CST object in an ACPI 2.0
      namespace.  It returns the information in non-paged pool, as
      C-states must be entered and exited at DISPATCH_LEVEL.

  Arguments:

      DeviceExtension - FDO_DATA

      CStates         - pointer to be filled in with return data

  Return Value:

      NTSTATUS

--*/
{
    PACPI_EVAL_OUTPUT_BUFFER    output;
    PACPI_METHOD_ARGUMENT       arg, subArg;
    NTSTATUS    status;
    ULONG       cstateCount = 0;
    ULONG       subElement;
    ULONG       size;
    ULONG       totalCStates;

    DebugEnter();
    PAGED_CODE();

    DebugAssert(CStates);
    *CStates = NULL;

    status = AcpiEvaluateMethod(DeviceExtension,
                                "_CST",
                                NULL,
                                &output);

    if (!NT_SUCCESS(status)) {
      return status;
    }

    DebugAssert(output->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE);

    //
    // Parse the output buffer, figuring out what we got.  See chapter
    // 8.3.2 of the ACPI 2.0 spec for details.
    //

    if (output->Count == 0) {

        //
        // There was nothing in the object.
        //

        status = STATUS_ACPI_INVALID_ARGTYPE;
        goto AcpiEvaluateCstExit;
    }


    //
    // The first object should be an integer that lists the number of
    // C-states.
    //

    if (output->Argument[0].Type != ACPI_METHOD_ARGUMENT_INTEGER) {

        //
        // The first element in the _CST package wasn't an
        // integer.
        //

        status = STATUS_ACPI_INVALID_ARGTYPE;
        goto AcpiEvaluateCstExit;
    }

    ASSERT(output->Argument[0].DataLength == sizeof(ULONG));

    totalCStates = output->Argument[0].Argument;
    size = ((totalCStates - 1) * sizeof(ACPI_CST_DESCRIPTOR)) +
           sizeof(ACPI_CST_PACKAGE);

    *CStates = ExAllocatePoolWithTag(NonPagedPool,
                                     size,
                                     PROCESSOR_POOL_TAG);

    if (!*CStates) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiEvaluateCstExit;
    }


    RtlZeroMemory(*CStates, size);
    (*CStates)->NumCStates = (UCHAR) totalCStates;


    //
    // Get second data element, should be a package
    //

    arg = &output->Argument[1];

    while ((PUCHAR)arg < ((PUCHAR)output + output->Length)) {

        //
        // Crack the packages.
        //

        if (arg->Type == ACPI_METHOD_ARGUMENT_PACKAGE) {

            subArg = (PACPI_METHOD_ARGUMENT)(arg->Data);
            subElement = 0;


            // toddcar - 1/21/2001 - ISSUE
            // Currently there is no way to know if one our _CST
            // packages contained too few elements.
            //

            while ((PUCHAR)subArg < ((PUCHAR)(arg->Data) + arg->DataLength)) {

                //
                // In Chapter 8.3.2 of ACPI 2.0, these packages are
                // defined as having four elements each:
                //
                //  C State_Register    - Generic Register Descriptor
                //  C State_Type        - byte
                //  Latency             - word
                //  Power_Consumption   - dword
                //

                switch (subElement) {
                case 0:

                    //
                    // Looking at the buffer
                    //

                    ASSERT(subArg->Type == ACPI_METHOD_ARGUMENT_BUFFER);
                    ASSERT(subArg->DataLength >= sizeof(ACPI_GENERIC_REGISTER_DESC));

                    if ((subArg->DataLength < sizeof(ACPI_GENERIC_REGISTER_DESC)) ||
                        (subArg->Type != ACPI_METHOD_ARGUMENT_BUFFER)) {

                        DebugAssert(!"ACPI Bios Error: _CST Package[0] must be type Generic Register Descriptor");
                        status = STATUS_ACPI_INVALID_ARGTYPE;
                        goto AcpiEvaluateCstExit;
                    }

                    RtlCopyMemory(&(*CStates)->State[cstateCount].Register,
                                  &(subArg->Data[3]),
                                  sizeof(GEN_ADDR));

                    break;

                case 1:

                    if (subArg->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

                      DebugAssert(!"ACPI Bios Error: _CST Package item [1] must be type INTEGER");
                      status = STATUS_ACPI_INVALID_ARGTYPE;
                      goto AcpiEvaluateCstExit;

                    }

                    ASSERT(!(subArg->Argument & 0xffffff00));
                    (*CStates)->State[cstateCount].StateType = (UCHAR)subArg->Argument;

                    break;

                case 2:

                    if (subArg->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

                        DebugAssert(!"ACPI Bios Error: _CST Package item[2] must be type INTEGER");
                        status = STATUS_ACPI_INVALID_ARGTYPE;
                        goto AcpiEvaluateCstExit;
                    }

                    ASSERT(!(subArg->Argument & 0xffff0000));
                    (*CStates)->State[cstateCount].Latency = (USHORT)subArg->Argument;

                    break;

                case 3:

                    if (subArg->Type != ACPI_METHOD_ARGUMENT_INTEGER) {

                        DebugAssert(!"ACPI Bios Error: _CST Package item[3] must be type INTEGER");
                        status = STATUS_ACPI_INVALID_ARGTYPE;
                        goto AcpiEvaluateCstExit;
                    }

                    (*CStates)->State[cstateCount].PowerConsumption = subArg->Argument;
                    break;

                default:

                    //
                    // There were more than four elements in the package.
                    //

                    ASSERT(FALSE);
                    status = STATUS_ACPI_INVALID_ARGTYPE;
                    goto AcpiEvaluateCstExit;
                }

                subArg = ACPI_METHOD_NEXT_ARGUMENT(subArg);
                subElement++;
            }

        } else {

            //
            // There was an object that wasn't a package.
            //

            DebugAssert(!"ACPI Bios Error: _CST[2..n] must be type PACKAGE");
            status = STATUS_ACPI_INVALID_ARGTYPE;
            goto AcpiEvaluateCstExit;

        }

        arg = ACPI_METHOD_NEXT_ARGUMENT(arg);
        cstateCount++;
    }

    ASSERT(cstateCount == (output->Count - 1));
    DumpCStates(*CStates);

AcpiEvaluateCstExit:

    if (!NT_SUCCESS(status) && (*CStates != NULL)) {
      ExFreePool(*CStates);
      *CStates = NULL;
    }
    ExFreePool(output);

    DebugExitStatus(status);
    return status;
}

NTSTATUS
AcpiEvaluatePct(
    IN  PFDO_DATA   DeviceExtension,
    OUT PACPI_PCT_PACKAGE   *Address
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    PACPI_EVAL_OUTPUT_BUFFER    pctBuffer;
    PACPI_METHOD_ARGUMENT       arg;
    PGEN_ADDR                   genAddr;
    NTSTATUS                    status;
    ULONG                       pass = 0;

    DebugEnter();
    PAGED_CODE();

    ASSERT(Address);
    *Address = 0;

    status = AcpiEvaluateMethod(DeviceExtension,
                                "_PCT",
                                NULL,
                                &pctBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(pctBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE);

    //
    // Sanity check the output buffer.  (ACPI BIOSes can often be
    // wrong.
    //

    if (pctBuffer->Count != 2) {

        DebugPrint((WARN, "ACPI BIOS error: _PCT object didn't return two objects\n"));
        status = STATUS_NOT_FOUND;
        goto AcpiEvaluatePctExit;
    }

    *Address = ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(ACPI_PCT_PACKAGE),
                                     PROCESSOR_POOL_TAG);

    if (!*Address) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiEvaluatePctExit;
    }

    RtlZeroMemory(*Address, sizeof(ACPI_PCT_PACKAGE));

    //
    // Traverse the package, parsing the elements.
    //

    arg = (PACPI_METHOD_ARGUMENT)pctBuffer->Argument;

    while ((PUCHAR)arg < (PUCHAR)pctBuffer + pctBuffer->Length) {

        if (arg->Type != ACPI_METHOD_ARGUMENT_BUFFER) {

            DebugPrint((WARN, "ACPI BIOS error: _PCT object didn't return a buffer\n"));
            status = STATUS_ACPI_INVALID_ARGTYPE;
            goto AcpiEvaluatePctExit;
        }

        if (arg->DataLength < sizeof(GEN_ADDR) + 2) {

            //
            // The buffer is not the right size.
            //

            DebugPrint((WARN, "ACPI BIOS error: _PCT object returned a buffer of the wrong size\n"));
            status = STATUS_ACPI_INVALID_ARGTYPE;
            goto AcpiEvaluatePctExit;
        }

        if (pass > 1) {

            //
            // Too many things in the package.
            //

            status = STATUS_ACPI_INVALID_ARGTYPE;
            goto AcpiEvaluatePctExit;
        }

        //
        // Both package elements should contain generic addresses.  So parse one.
        //

        status = AcpiParseGenRegDesc(arg->Data,
                                     &genAddr);

        if (!NT_SUCCESS(status)) {
            goto AcpiEvaluatePctExit;
        }

        switch (pass) {
        case 0:

            //
            // The first object in a _PCT should be the Perf Control Register
            //

            RtlCopyMemory(&((*Address)->Control), genAddr, sizeof(*genAddr));

            break;

        case 1:

            //
            // The second object in a _PCT should be the Perf Status Register
            //

            RtlCopyMemory(&((*Address)->Status), genAddr, sizeof(*genAddr));
        }

        ExFreePool(genAddr);
        arg = ACPI_METHOD_NEXT_ARGUMENT(arg);
        pass++;
    }


AcpiEvaluatePctExit:

    if (!NT_SUCCESS(status)) {
        if (*Address) {
            ExFreePool(*Address);
            *Address = NULL;
        }
    }

    ExFreePool(pctBuffer);
    return status;
}

NTSTATUS
AcpiEvaluatePss(
    IN  PFDO_DATA   DeviceExtension,
    OUT PACPI_PSS_PACKAGE   *Address
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    PACPI_EVAL_OUTPUT_BUFFER    pssBuffer;
    PACPI_METHOD_ARGUMENT       arg, subArg;
    NTSTATUS                    status;
    ULONG                       subElem, pState = 0;

    static UCHAR fieldOffsets[] = {
        FIELD_OFFSET(ACPI_PSS_DESCRIPTOR, CoreFrequency),
        FIELD_OFFSET(ACPI_PSS_DESCRIPTOR, Power),
        FIELD_OFFSET(ACPI_PSS_DESCRIPTOR, Latency),
        FIELD_OFFSET(ACPI_PSS_DESCRIPTOR, BmLatency),
        FIELD_OFFSET(ACPI_PSS_DESCRIPTOR, Control),
        FIELD_OFFSET(ACPI_PSS_DESCRIPTOR, Status)
    };

    DebugEnter();
    PAGED_CODE();

    ASSERT(Address);
    *Address = 0;

    status = AcpiEvaluateMethod(DeviceExtension,
                                "_PSS",
                                NULL,
                                &pssBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(pssBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE);

    //
    // The _PSS object is a package of packages.  So the number
    // of objects in the _PCT method will be the number of
    // sub-packages.  The amount of memory we need is calculated
    // from that.
    //

    *Address = ExAllocatePoolWithTag(NonPagedPool,
                                     sizeof(ACPI_PSS_PACKAGE) +
                                     (sizeof(ACPI_PSS_DESCRIPTOR) * (pssBuffer->Count - 1)),
                                     PROCESSOR_POOL_TAG);

    if (!*Address) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcpiEvaluatePssExit;
    }

    (*Address)->NumPStates = (UCHAR)pssBuffer->Count;

    //
    // Traverse the package, parsing the elements.
    //

    arg = (PACPI_METHOD_ARGUMENT)pssBuffer->Argument;

    while ((PUCHAR)arg < (PUCHAR)pssBuffer + pssBuffer->Length) {

        //
        // Each element in a _PSS should be a package.
        //

        if (arg->Type != ACPI_METHOD_ARGUMENT_PACKAGE) {
            status = STATUS_ACPI_INVALID_ARGTYPE;
            goto AcpiEvaluatePssExit;
        }

        //
        // Traverse the inner package.
        //

        subElem = 0;
        subArg = (PACPI_METHOD_ARGUMENT)arg->Data;

        while ((PUCHAR)subArg < ((PUCHAR)arg) + arg->DataLength) {

            //
            // All the elements in the inner packages of
            // a _PSS object should be integers.
            //

            if (subArg->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
                status = STATUS_ACPI_INVALID_ARGTYPE;
                goto AcpiEvaluatePssExit;
            }

            if (subElem > 5) {

                //
                // There are too many elements in this package.
                //

                status = STATUS_ACPI_INVALID_ARGTYPE;
                goto AcpiEvaluatePssExit;
            }

            //
            // The next step is to fill in the proper field in the P-State
            // table.  Do this by indexing across pState and subElem.
            //

            *(PULONG)(((PUCHAR)&(*Address)->State[pState]) + fieldOffsets[subElem]) =
                subArg->Argument;

            subArg = ACPI_METHOD_NEXT_ARGUMENT(subArg);
            subElem++;
        }

        arg = ACPI_METHOD_NEXT_ARGUMENT(arg);
        pState++;
    }

    ASSERT(pState == (*Address)->NumPStates);
    status = STATUS_SUCCESS;

AcpiEvaluatePssExit:

    if (!NT_SUCCESS(status)) {
        if (*Address) ExFreePool(*Address);
    }

    ExFreePool(pssBuffer);
    return status;
}

NTSTATUS
AcpiEvaluatePpc(
    IN  PFDO_DATA   DeviceExtension,
    OUT ULONG       *AvailablePerformanceStates
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    PACPI_EVAL_OUTPUT_BUFFER    ppcBuffer;
    NTSTATUS                    status;

    DebugEnter();
    PAGED_CODE();

    ASSERT(AvailablePerformanceStates);
    *AvailablePerformanceStates = 0;

    status = AcpiEvaluateMethod(DeviceExtension,
                                "_PPC",
                                NULL,
                                &ppcBuffer);

    if (!NT_SUCCESS(status)) {
      return status;
    }

    ASSERT(ppcBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE);

    //
    // The _PPC object is an integer.
    //

    ASSERT(ppcBuffer->Count == 1);
    ASSERT(ppcBuffer->Argument[0].Type == ACPI_METHOD_ARGUMENT_INTEGER);

    *AvailablePerformanceStates = ppcBuffer->Argument[0].Argument;

    ExFreePool(ppcBuffer);
    return status;

}

NTSTATUS
InitializeAcpi2PStatesGeneric(
    IN  PFDO_DATA   DeviceExtension
    )
/*++

  Routine Description:

      This routine evaluates _PSS and _PCT, then
      builds the performance state array.

      Note:  The caller must hold PerfStateLock.

  Arguments:

      DeviceExtension

  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

--*/
{
    NTSTATUS status;
    PACPI_PCT_PACKAGE pctPackage = NULL;

    DebugEnter();
    PAGED_CODE();

    //
    // We automatically fail to use the Acpi 2.0 interface
    //

    if (Globals.HackFlags & DISABLE_ACPI20_INTERFACE_FLAG) {
      DebugPrint((ERROR, " Acpi 2.0 Interface Disabled\n"));
      return STATUS_NOT_FOUND;
    }


    //
    // Fill in the DeviceExtension with _PSS and _PCT.
    //

    status = AcpiEvaluatePss(DeviceExtension, &DeviceExtension->PssPackage);

    if (!NT_SUCCESS(status)) {
      goto InitializeAcpiPerformanceStatesExit;
    }



    status = AcpiEvaluatePct(DeviceExtension, &pctPackage);

    if (!NT_SUCCESS(status)) {
      goto InitializeAcpiPerformanceStatesExit;
    }


    RtlCopyMemory(&(DeviceExtension->PctPackage),
                  pctPackage,
                  sizeof(ACPI_PCT_PACKAGE));

    //
    // The _PCT object may have pointed to registers in Memory space.
    // If so, we need virtual addresses for these physical addresses.
    //

    if (DeviceExtension->PctPackage.Control.AddressSpaceID == AcpiGenericSpaceMemory) {

        DeviceExtension->PctPackage.Control.Address.QuadPart = (ULONG_PTR)
            MmMapIoSpace(DeviceExtension->PctPackage.Control.Address,
                         DeviceExtension->PctPackage.Control.BitWidth / 8,
                         MmNonCached);

        if (!DeviceExtension->PctPackage.Control.Address.QuadPart) {
            status = STATUS_INVALID_PARAMETER;
            goto InitializeAcpiPerformanceStatesExit;
        }
    }

    if (DeviceExtension->PctPackage.Status.AddressSpaceID == AcpiGenericSpaceMemory) {

        DeviceExtension->PctPackage.Status.Address.QuadPart = (ULONG_PTR)
            MmMapIoSpace(DeviceExtension->PctPackage.Status.Address,
                         DeviceExtension->PctPackage.Status.BitWidth / 8,
                         MmNonCached);

        if (!DeviceExtension->PctPackage.Status.Address.QuadPart) {
            status = STATUS_INVALID_PARAMETER;
            goto InitializeAcpiPerformanceStatesExit;
        }
    }

    //
    // Merge these states in with other available states.
    //

    status = MergePerformanceStates(DeviceExtension);

    //
    // Notify the bios we are taking control
    //

    if (NT_SUCCESS(status)) {
      AssumeProcessorPerformanceControl();
    }

InitializeAcpiPerformanceStatesExit:

    if (!NT_SUCCESS(status)) {
        //
        // Something went wrong.  Blow away the mess.
        //
        if (DeviceExtension->PssPackage) {
            ExFreePool(DeviceExtension->PssPackage);
            DeviceExtension->PssPackage = NULL;
        }
    }

    if (pctPackage) {
      ExFreePool(pctPackage);
    }

    DebugExitStatus(status);
    return status;

}

NTSTATUS
AcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE *AcpiMulti
    )
/*++

  Routine Description:

      This function looks into the registry to find the ACPI RSDT,
      which was stored there by ntdetect.com.

  Arguments:

      RsdtPtr - Pointer to a buffer that contains the ACPI
                Root System Description Pointer Structure.
                The caller is responsible for freeing this
                buffer.  Note:  This is returned in non-paged
                pool.

  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

--*/
{
    UNICODE_STRING unicodeString, unicodeValueName, biosId;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus;
    WCHAR wbuffer[10];
    ULONG i, length;
    PWSTR p;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    NTSTATUS status;
    BOOLEAN same;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;
    PLEGACY_GEYSERVILLE_INT15 int15Info;

    DebugEnter();
    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        DebugPrint((ERROR, "AcpiBios:Can not open MultifunctionAdapter registry key.\n"));
        return status;
    }

    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString(&biosId, rgzBIOSIdentifier);

    for (i = 0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (&objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    hMFunc,
                                    NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            DebugPrint((ERROR, "AcpiBios: ACPI BIOS MultifunctionAdapter registry key not found.\n"));
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //

        status = GetRegistryValue (hBus, rgzAcpiIdentifier, &valueInfo);
        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //
        while (length) {
            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {
                length -= 2;
            } else {
                break;
            }
        }

        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString(&biosId, &unicodeValueName, TRUE);
        ExFreePool(valueInfo);
        if (!same) {
            ZwClose (hBus);
            continue;
        }

        status = GetRegistryValue(hBus, rgzAcpiConfigurationData, &valueInfo);
        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


        break;
    }

    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                           ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY)) +
                           sizeof(LEGACY_GEYSERVILLE_INT15);

    *AcpiMulti = (PACPI_BIOS_MULTI_NODE) ExAllocatePoolWithTag(NonPagedPool,
                                                               multiNodeSize,
                                                               PROCESSOR_POOL_TAG);
    if (*AcpiMulti == NULL) {
        ExFreePool(valueInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(*AcpiMulti, multiNodeSize);
    RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize - sizeof(LEGACY_GEYSERVILLE_INT15));

    //
    // Geyserville BIOS information is appended to the E820 entries.  Unfortunately,
    // there is no way to know if it is there.  So wrap the code in a try/except.
    //

    try {

        int15Info = (PLEGACY_GEYSERVILLE_INT15)&(multiNode->E820Entry[multiNode->Count]);

        if (int15Info->Signature == 'GS') {

            //
            // This BIOS supports Geyserville.
            //

            RtlCopyMemory(((PUCHAR)*AcpiMulti + multiNodeSize - sizeof(LEGACY_GEYSERVILLE_INT15)),
                          int15Info,
                          sizeof(LEGACY_GEYSERVILLE_INT15));

        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        *((PUSHORT)((PUCHAR)*AcpiMulti + multiNodeSize - sizeof(LEGACY_GEYSERVILLE_INT15))) = 0;
    }

    ExFreePool(valueInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
GetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )
/*++

  Routine Description:

      This routine is invoked to retrieve the data for a registry key's value.
      This is done by querying the value of the key with a zero-length buffer
      to determine the size of the value, and then allocating a buffer and
      actually querying the value into the buffer.

      It is the responsibility of the caller to free the buffer.

  Arguments:

      KeyHandle - Supplies the key handle whose value is to be queried

      ValueName - Supplies the null-terminated Unicode name of the value.

      Information - Returns a pointer to the allocated data buffer.

  Return Value:

      The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    //DebugEnter();
    PAGED_CODE();

    RtlInitUnicodeString(&unicodeString, ValueName);

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey(KeyHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             (PVOID) NULL,
                             0,
                             &keyValueLength);

    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePoolWithTag(PagedPool,
                                       keyValueLength,
                                       PROCESSOR_POOL_TAG);
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey(KeyHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             infoBuffer,
                             keyValueLength,
                             &keyValueLength);

    if (!NT_SUCCESS(status)) {
        ExFreePool(infoBuffer);
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;

}

PVOID
GetAcpiTable(
    IN  ULONG  Signature
    )
/*++

  Routine Description:

      This routine will retrieve any table referenced in the ACPI
      RSDT.

  Arguments:

      Signature - Target table signature

  Return Value:

      pointer to a copy of the table, or NULL if not found

--*/
{

    PACPI_BIOS_MULTI_NODE multiNode;
    NTSTATUS status;
    ULONG entry, rsdtEntries;
    PDESCRIPTION_HEADER header;
    PHYSICAL_ADDRESS physicalAddr;
    PRSDT rsdt;
    PVOID table = NULL;

    DebugEnter();
    PAGED_CODE();

    status = AcpiFindRsdt(&multiNode);

    if (!NT_SUCCESS(status)) {
        return NULL;
    }


    rsdt = MmMapIoSpace(multiNode->RsdtAddress,
                        sizeof(RSDT) + (100 * sizeof(PHYSICAL_ADDRESS)),
                        MmCached);

    ExFreePool(multiNode);

    if (!rsdt) {
        return NULL;
    }

    //
    // Do a sanity check on the RSDT.
    //
    if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
        (rsdt->Header.Signature != XSDT_SIGNATURE)) {
        goto GetAcpiTableEnd;
    }

    //
    // Calculate the number of entries in the RSDT.
    //

    rsdtEntries = rsdt->Header.Signature == XSDT_SIGNATURE ?
        NumTableEntriesFromXSDTPointer(rsdt) :
        NumTableEntriesFromRSDTPointer(rsdt);

    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        //
        // BUGBUG: should the highpart always be zero ?  ie: what about PAE &
        // WIN64 ?  are other places in this module also susceptible to this ?
        //

        if (rsdt->Header.Signature == XSDT_SIGNATURE) {
            physicalAddr = ((PXSDT)rsdt)->Tables[entry];
        } else {
            physicalAddr.HighPart = 0;
            physicalAddr.LowPart = (ULONG)rsdt->Tables[entry];
        }

        header = MmMapIoSpace(physicalAddr,
                              PAGE_SIZE * 2,
                              MmCached);

        if (!header) {
            goto GetAcpiTableEnd;
        }

        if (header->Signature == Signature) {
            break;
        }

        MmUnmapIoSpace(header, PAGE_SIZE * 2);
    }

    if (entry == rsdtEntries) {
        goto GetAcpiTableEnd;
    }

    table = ExAllocatePoolWithTag(PagedPool,
                                  header->Length,
                                  PROCESSOR_POOL_TAG);

    if (table) {
        RtlCopyMemory(table, header, header->Length);
    }

    MmUnmapIoSpace(header, PAGE_SIZE * 2);

GetAcpiTableEnd:

    MmUnmapIoSpace(rsdt,
                   sizeof(RSDT) + (100 * sizeof(PHYSICAL_ADDRESS)));
    return table;

}

NTSTATUS
AcquireAcpiInterfaces(
    PFDO_DATA   DeviceExtension
    )
/*++

  Routine Description:

      This routine sends an IRP to the ACPI driver to get the
      funtion pointer table for the standard ACPI direct-call
      interfaces.

  Arguments:

      DeviceExtension

  Return Value:

      NTSTATUS

--*/
{
    KEVENT event;
    NTSTATUS status, callbackStatus;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;
    PACPI_INTERFACE_STANDARD acpiInterfaces = NULL;

    DebugEnter();
    PAGED_CODE();
    ASSERT(DeviceExtension->DevicePnPState == NotStarted);
    ASSERT(DeviceExtension->AcpiInterfaces == NULL);

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    acpiInterfaces = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(ACPI_INTERFACE_STANDARD),
                                           PROCESSOR_POOL_TAG);

    if (!acpiInterfaces) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       DeviceExtension->NextLowerDriver,
                                       NULL,
                                       0,
                                       NULL,
                                       &event,
                                       &ioStatusBlock);

    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto AcquireAcpiInterfacesExit;
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_ACPI_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof(ACPI_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) acpiInterfaces;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    status = IoCallDriver( DeviceExtension->NextLowerDriver, irp );

    if (!NT_SUCCESS(status)) {
        goto AcquireAcpiInterfacesExit;
    }

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
        status = ioStatusBlock.Status;
    }

    if (NT_SUCCESS(status)) {

        DeviceExtension->AcpiInterfaces = acpiInterfaces;

        //
        // Reference the interface.
        //
        if (DeviceExtension->AcpiInterfaces->InterfaceReference) {
          DeviceExtension->AcpiInterfaces->InterfaceReference(DeviceExtension->AcpiInterfaces->Context);
        }
        //
        // Register for notification callbacks.
        //

        callbackStatus = 
            DeviceExtension->AcpiInterfaces->RegisterForDeviceNotifications(
                 DeviceExtension->UnderlyingPDO,
                 AcpiNotifyCallback,
                 DeviceExtension
                 );


        if (!NT_SUCCESS(callbackStatus)) {

            DebugAssert(!"AcpiInterfaces->RegisterForDeviceNotifications() Failed!");

            if (DeviceExtension->AcpiInterfaces->InterfaceDereference) {
              DeviceExtension->AcpiInterfaces->InterfaceDereference(DeviceExtension->AcpiInterfaces->Context);
            }
            DeviceExtension->AcpiInterfaces = NULL;
            status = callbackStatus;
            goto AcquireAcpiInterfacesExit;
        }
    }

AcquireAcpiInterfacesExit:

    if (!NT_SUCCESS(status)) {

      if (acpiInterfaces) {
        ExFreePool(acpiInterfaces);
      }

    }

    return status;

}
NTSTATUS
ReleaseAcpiInterfaces(
    PFDO_DATA   DeviceExtension
    )
/*++

  Routine Description:

      This routine releases the ACPI interfaces.

  Arguments:

      DeviceExtension

  Return Value:

      NTSTATUS

--*/
{

    DebugEnter();
    PAGED_CODE();
    ASSERT(DeviceExtension->DevicePnPState == Deleted);
    ASSERT(DeviceExtension->AcpiInterfaces != NULL);

    //
    // Unregister for device notification.
    //

    DeviceExtension->AcpiInterfaces->UnregisterForDeviceNotifications(
        DeviceExtension->UnderlyingPDO,
        AcpiNotifyCallback
        );

    //
    // Dereference the interface.
    //

    DeviceExtension->AcpiInterfaces->InterfaceDereference(DeviceExtension->AcpiInterfaces->Context);
    DeviceExtension->AcpiInterfaces = NULL;

    return STATUS_SUCCESS;

}
VOID
AcpiNotifyCallback(
    PVOID   Context,
    ULONG   NotifyCode
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    PFDO_DATA   DeviceExtension = (PFDO_DATA)Context;
    PIO_WORKITEM workItem;

    DebugEnter();

    if ((DeviceExtension->DevicePnPState != Started) ||
        (DeviceExtension->LegacyInterface)) {

        //
        // Ignore notifications that come in while the device
        // isn't started, or if we are using the legacy interface.
        //

        return;
    }

    //
    // Allocate work item
    //
    
    workItem = IoAllocateWorkItem(DeviceExtension->Self);
  
    if (!workItem) {
      DebugPrint((ERROR, "IoAllocateWorkItem() Failed!\n"));
      return; // STATUS_INSUFFICIENT_RESOURCES
    }

    switch (NotifyCode) {
    
      case 0x80:

        IoQueueWorkItem(workItem,
                        AcpiNotify80CallbackWorker,
                        DelayedWorkQueue,
                        workItem);
        break;

      case 0x81:

        IoQueueWorkItem(workItem,
                        AcpiNotify81CallbackWorker,
                        DelayedWorkQueue,
                        workItem);
        break;


      default:
        DebugPrint((ERROR, "Unrecognized Notify code (0x%x)\n", NotifyCode));
        IoFreeWorkItem(workItem);
        break;
        
    }

    return;

}
VOID
AcpiNotify80CallbackWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

  Routine Description:

  Arguments:

    DeviceObject -

    Context - If we were called as part of a WorkItem, "Context" is a pointer
              to the WorkItem, otherwise, this value is NULL

  Return Value:


--*/
{
    NTSTATUS    status;
    PFDO_DATA DeviceExtension = (PFDO_DATA) DeviceObject->DeviceExtension;
    PPROCESSOR_PERFORMANCE_STATES oldPerfStates;
    PROCESSOR_PERFORMANCE_STATES  nullPerfStates = {NULL, 0, 0, 0, {0,0,0}};

    DebugEnter();
    PAGED_CODE();

    //
    // if called as WorkItem, free worker resources
    //

    if (Context) {
        IoFreeWorkItem((PIO_WORKITEM) Context);
    }

    if (!DeviceExtension->PssPackage) {

        //
        // This machine has no _PSS package, so
        // this notification shouldn't do anything.
        //

        return;
    }

    AcquireProcessorPerfStateLock(DeviceExtension);

    //
    // Register zero ACPI 2.0 performance states with the
    // kernel so that no state gets invoked while we're
    // screwing around with the DeviceExtension.
    //

    oldPerfStates = DeviceExtension->PerfStates;
    DeviceExtension->PerfStates = &nullPerfStates;

    status = RegisterStateHandlers(DeviceExtension);

    //
    // Need to put the orginal states back
    //

    DeviceExtension->PerfStates = oldPerfStates;

    if (!NT_SUCCESS(status)) {
      DebugAssert(!"RegisterStateHandlers(NULL PerfStates) Failed!");
      goto AcpiNotify80CallbackWorkerExit;
    }

    //
    // Calculate currently available states.
    // NOTE: MergePerformanceStates will invalidate CurrentPerfState
    //

    status = MergePerformanceStates(DeviceExtension);

    if (!NT_SUCCESS(status)) {
      goto AcpiNotify80CallbackWorkerExit;
    }

    //
    // Register new perf states with the kernel.
    //

    status = RegisterStateHandlers(DeviceExtension);
    ASSERT(NT_SUCCESS(status));


AcpiNotify80CallbackWorkerExit:

    if (!NT_SUCCESS(status)) {

        //
        // Something went wrong.  Blow away the mess.
        //

        if (DeviceExtension->PerfStates) {
          ExFreePool(DeviceExtension->PerfStates);
          DeviceExtension->PerfStates = NULL;
          DeviceExtension->CurrentPerfState = INVALID_PERF_STATE;
        }
    }

    ReleaseProcessorPerfStateLock(DeviceExtension);

    //
    // Notify anyone who might be interested
    //
    
    ProcessorFireWmiEvent(DeviceExtension, 
                          &NewPStatesEvent, 
                          &DeviceExtension->PpcResult);

}
VOID
AcpiNotify81CallbackWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
    NTSTATUS    status;
    PFDO_DATA DeviceExtension = (PFDO_DATA) DeviceObject->DeviceExtension;
    PPROCESSOR_IDLE_STATES  oldCStates;
    PROCESSOR_IDLE_STATES   nullCStates = {0,{0,0,{0,0,0,0,{0,0}},NULL}};

    DebugEnter();
    PAGED_CODE();

    //
    // Free worker resources
    //

    IoFreeWorkItem((PIO_WORKITEM) Context);

    if (!DeviceExtension->CstPresent) {

        //
        // This machine has no _CST package, so
        // this notification shouldn't do anything.
        //

        return;
    }

    AcquireProcessorPerfStateLock(DeviceExtension);

    //
    // Register zero ACPI 2.0 performance states with the
    // kernel so that no state gets invoked while we're
    // screwing around with the DeviceExtension.
    //

    oldCStates = DeviceExtension->CStates;
    DeviceExtension->CStates = &nullCStates;

    status = RegisterStateHandlers(DeviceExtension);

    //
    // restore previous CStates
    //

    DeviceExtension->CStates = oldCStates;

    if (!NT_SUCCESS(status)) {
      DebugAssert(!"RegisterStateHandlers(NULL CStates) Failed!");
      goto AcpiNotify81CallbackWorkerExit;
    }


    //
    // Calculate currently available Cstates.
    //

    status = InitializeAcpi2IoSpaceCstates(DeviceExtension);

    if (!NT_SUCCESS(status)) {
      goto AcpiNotify81CallbackWorkerExit;
    }

    //
    // Register new perf states with the kernel.
    //

    status = RegisterStateHandlers(DeviceExtension);
    ASSERT(NT_SUCCESS(status));


AcpiNotify81CallbackWorkerExit:

    if (!NT_SUCCESS(status)) {

        //
        // Something went wrong.  Blow away the mess.
        //
        if (DeviceExtension->CStates) {
          ExFreePool(DeviceExtension->CStates);
          DeviceExtension->CStates = NULL;
        }
    }

    ReleaseProcessorPerfStateLock(DeviceExtension);

    //
    // Notify anyone who might be interested
    //
         
    ProcessorFireWmiEvent(DeviceExtension, 
                          &NewCStatesEvent, 
                          NULL);
    
}

NTSTATUS
Acpi2PerfStateTransitionGeneric(
    IN PFDO_DATA    DeviceExtension,
    IN ULONG        State
    )
/*++

  Routine Description:

      This routine changes the performance state of the processor
      based on ACPI 2.0 performance state objects.

      NOTE:  This function only understands I/O and Memory addresses,
             not FFH addresses.

  Arguments:

      State - Index into _PSS

  Return Value:

      none

--*/
{
  ULONG    statusValue = 0;
  NTSTATUS status = STATUS_SUCCESS;
  
  DebugEnter();
  
  DebugAssert(State >= DeviceExtension->PpcResult);
  DebugAssert(State < DeviceExtension->PssPackage->NumPStates);
  DebugAssert(DeviceExtension->PctPackage.Control.Address.QuadPart);
  DebugAssert(DeviceExtension->PctPackage.Status.Address.QuadPart);
  
  
  //
  // Write Control value
  //
  
  WriteGenAddr(&DeviceExtension->PctPackage.Control,
               DeviceExtension->PssPackage->State[State].Control);
  
  
  //
  // Get Status Value
  //
  
  statusValue = ReadGenAddr(&DeviceExtension->PctPackage.Status);
  

 
  //
  // Check to see if the status register matches what we expect.
  //
  
  if (statusValue != DeviceExtension->PssPackage->State[State].Status) {
     
    DebugPrint((ERROR,
      "Acpi2PerfStateTransitionGeneric: Transition failed! Expected 0x%x status value, recieved 0x%x\n",
      DeviceExtension->PssPackage->State[State].Status,
      statusValue));
    
    status = STATUS_UNSUCCESSFUL;
  }


  DebugExitStatus(status);
  return status;
  
}
NTSTATUS
AcpiPerfStateTransition (
    IN PFDO_DATA    DeviceExtension,
    IN ULONG        State
    )
/*++

  Routine Description:


  Arguments:

    State - Index into DeviceExtension->PerfStates


  Return Value:


--*/
{

  //
  // Legacy drivers may use the PssPackage variable, so
  // we first check for legacy, all legacy drivers have
  // this flag set.
  //

  if (DeviceExtension->LegacyInterface) {

    return AcpiLegacyPerfStateTransition(DeviceExtension, State);

  } else if (DeviceExtension->PssPackage) {

    //
    //  The State index passed in reflects an index in the current PerfStates
    //  registered with the kernel.  Must convert it to an index into the _PSS.
    //

    return Acpi2PerfStateTransition(DeviceExtension,
                                    State + DeviceExtension->PpcResult);

  }

  return STATUS_NOT_IMPLEMENTED;

}

NTSTATUS
InitializeAcpi2IoSpaceCstates(
    IN PFDO_DATA   DeviceExtension
    )
/*++

  Routine Description:

      This function looks to see if there is an ACPI 2.0 _CST object in the
      namespace, and, if it is present and _does not_ contain CStates that
      reference funtionly fixed hardware registers, it replaces the functions
      found by InitializeAcpi1Cstates.  This generic driver has no knowledge
      of processor specific registers

      Note:  This is a little bit ridiculous, as the generic processor driver
      can't possibly know how to use a C-state that it couldn't find via ACPI 1.0
      means.  Never-the-less, we should respect what we find in a _CST, if for no
      other reason than that this code may be used as an example in a more complex
      driver.

      Further note:  This function leaves the filling in of throttling functions
      to the InitializePerformanceStates functions.

  Arguments:

      DeviceExtension

  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

--*/
{
#define HIGHEST_SUPPORTED_CSTATE   3

  PPROCESSOR_IDLE_STATES  iStates;
  PACPI_CST_PACKAGE       cstData = NULL;
  NTSTATUS                status;
  ULONG                   i;
  UCHAR                   cState;
  ULONG                   size;

  DebugEnter();
  PAGED_CODE();


  //
  // Find the _CST
  //

  status = AcpiEvaluateCst(DeviceExtension, &cstData);

  if (!NT_SUCCESS(status)) {
    goto InitializeAcpi2IoSpaceCstatesExit;
  }


  //
  // The namespace contains a _CST package.  So we should
  // use it instead of ACPI 1.0 C-states.
  //

  if (DeviceExtension->CStates) {

    //
    // There were 1.0 C-states.  Get rid of them.
    //

    ExFreePool(DeviceExtension->CStates);
    DeviceExtension->CStates = NULL;

  }


  //
  // Currently we only support 3 C States.  We can't allocate based on
  // the number of _CST cstates, as there may be more than we support
  //

  size = (sizeof(PROCESSOR_IDLE_STATE) *
           (HIGHEST_SUPPORTED_CSTATE - 1)) +
         sizeof(PROCESSOR_IDLE_STATES);

  iStates = ExAllocatePoolWithTag(NonPagedPool,
                                  size,
                                  PROCESSOR_POOL_TAG);

  if (!iStates) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto InitializeAcpi2IoSpaceCstatesExit;
  }

  //
  // Collect Acpi 2.0 CState info
  //

  DeviceExtension->CStates = iStates;
  DeviceExtension->CstPresent = TRUE;

  //
  // We always support C1.
  //

  iStates->State[0].StateType = 1;
  RtlZeroMemory(&(iStates->State[0].Register), sizeof(GEN_ADDR));

  iStates->State[0].Latency = 0;
  iStates->State[0].IdleHandler = AcpiC1Idle;


  //
  // We only support C2 & C3 on UP machines
  //

  if (!Globals.SingleProcessorProfile) {
    goto InitializeAcpi2IoSpaceCstatesExit;
  }



  //
  // Hunt through the _CST package looking for supported (and useful) states.
  // NOTE: if the _CST contains multiple definitions for C2 or C3, we will
  //       use deepest state, ie the one that offers the greatest power savings.
  //

  //
  // Start looking at C2
  //

  cState = 2;

  for (i = 0; i < cstData->NumCStates; i++) {

    if (cstData->State[i].StateType == cState) {

      DebugPrint((INFO, "Found CState C%u\n", cState));

      //
      // Look ahead to see if another identicle C state with greater power
      // savings exists.
      //

      while((i+1 < cstData->NumCStates) &&
            (cstData->State[i+1].StateType == cState) &&
            (cstData->State[i+1].PowerConsumption < cstData->State[i].PowerConsumption) &&
            (cstData->State[i+1].Register.AddressSpaceID == AcpiGenericSpaceIO)) {

        i++;

      }

      //
      // We have found a state in the package that matches the one we're
      // looking for.  See if we think that it's usable.  This function
      // only knows how to use ACPI 1.0-compatible C-states.  So anything
      // that is not in I/O space is out of bounds.
      //

      if (cstData->State[i].Register.AddressSpaceID != AcpiGenericSpaceIO) {
        DebugPrint((ERROR, "InitializeAcpi2IoSpaceCstates() only supports CStates in I/O space\n"));
        continue;
      }

      iStates->State[cState - 1].StateType = cState;
      iStates->State[cState - 1].Register  = cstData->State[i].Register;
      iStates->State[cState - 1].Latency   = cstData->State[i].Latency;

      switch (cState) {

        case 2:
          iStates->State[cState - 1].IdleHandler = Acpi2C2Idle;
          C2Address = iStates->State[cState - 1].Register;
          break;

        case 3:
          iStates->State[cState - 1].IdleHandler = Acpi2C3ArbdisIdle;
          C3Address = iStates->State[cState - 1].Register;
          break;

        default:
          DebugAssert(!"Found Unsupported CState")
          break;

      }

      //
      // Look for next state
      //

      cState++;


      //
      // if we found C3, then we are finished
      //

      if (cState > HIGHEST_SUPPORTED_CSTATE) {
        break;
      }

    }

  }

  //
  // "Count" represents the highest supported C State found,
  // must be < MAX_IDLE_HANDLERS.
  //

  iStates->Count = cState - 1;


InitializeAcpi2IoSpaceCstatesExit:


  if (cstData) {
    ExFreePool(cstData);
  }

  DebugExitStatus(status);
  return status;

}
VOID
AssumeProcessorPerformanceControl (
  VOID
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();
  DebugAssert(HalpFixedAcpiDescTable.smi_cmd_io_port);

  //
  // In Acpi 2.0, the FADT->pstate_control contains the magic value to write to
  // the SMI Command port to turn off bios control of processor performance control
  //

  if (HalpFixedAcpiDescTable.pstate_control) {

    WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR) HalpFixedAcpiDescTable.smi_cmd_io_port,
                     HalpFixedAcpiDescTable.pstate_control);

  }

}
VOID
AssumeCStateControl (
  VOID
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();
  DebugAssert(HalpFixedAcpiDescTable.smi_cmd_io_port);

  //
  // In Acpi 2.0, the FADT->cstate_control contains the magic value to write to
  // the SMI Command port to turn off bios control of Acpi 2.0 Cstates
  //

  if (HalpFixedAcpiDescTable.cstate_control) {

    WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR) HalpFixedAcpiDescTable.smi_cmd_io_port,
                     HalpFixedAcpiDescTable.cstate_control);

  }

}
NTSTATUS
GetRegistryDwordValue (
    IN  PWCHAR RegKey,
    IN  PWCHAR ValueName,
    OUT PULONG RegData
    )
/*++

  Routine Description:


  Arguments:


  Return Value:

    NTSTATUS

--*/
{

  NTSTATUS                 ntStatus      = STATUS_SUCCESS;
  ULONG_PTR                zero          = 0;
  RTL_QUERY_REGISTRY_TABLE paramTable[2] = {0};  // terminate with null table entry


  paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name          = ValueName;
  paramTable[0].EntryContext  = RegData;
  paramTable[0].DefaultType   = REG_DWORD;
  paramTable[0].DefaultData   = &zero;
  paramTable[0].DefaultLength = sizeof(zero);

  ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    RegKey,
                                    &paramTable[0],
                                    NULL,           // Context
                                    NULL);          // Environment

  return ntStatus;
}
NTSTATUS
SetRegistryStringValue (
    IN  PWCHAR RegKey,
    IN  PWCHAR ValueName,
    IN  PWCHAR String
    )
/*++

  Routine Description:


  Arguments:


  Return Value:

    NTSTATUS

--*/
{
  return RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                               RegKey,
                               ValueName,
                               REG_SZ,
                               String,
                               (wcslen(String)+1) * sizeof(WCHAR));

}
NTSTATUS
GetRegistryStringValue (
    IN  PWCHAR RegKey,
    IN  PWCHAR ValueName,
    OUT PUNICODE_STRING RegString
    )
/*++

  Routine Description:


  Arguments:


  Return Value:

    NTSTATUS

--*/
{

  NTSTATUS  status;
  ULONG_PTR zero = 0;
  RTL_QUERY_REGISTRY_TABLE paramTable[2] = {0};  // terminate with null table entry

  DebugEnter();
  DebugAssert(RegString);

  RtlZeroMemory(RegString, sizeof(UNICODE_STRING));

  paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  paramTable[0].Name          = ValueName;
  paramTable[0].EntryContext  = RegString;
  paramTable[0].DefaultType   = REG_SZ;
  paramTable[0].DefaultData   = &zero;
  paramTable[0].DefaultLength = sizeof(zero);

  status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                  RegKey,
                                  &paramTable[0],
                                  NULL,           // Context
                                  NULL);          // Environment

  DebugExitStatus(status);
  return status;
}

#ifdef _X86_
NTSTATUS
FASTCALL
SetPerfLevelGeneric(
  IN UCHAR      Throttle,
  IN PFDO_DATA  DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  ULONG     newState, lowestPerfState;
  ULONG     throttleValue;
  NTSTATUS  status = STATUS_SUCCESS;
  

  //DebugEnter();
  DebugAssert(DeviceExtension);
  DebugPrint((TRACE, "SetPerfLevelGeneric: Throttling to %u%%\n", Throttle));


  //
  // Save Throttle uncase we aren't able to Throttle
  //

  DeviceExtension->LastRequestedThrottle = Throttle;                             


  //
  // Run through the performance states looking for one
  // that matches this throttling level.
  //

  for (newState = 0; newState < DeviceExtension->PerfStates->Count; newState++) {

    if (DeviceExtension->PerfStates->State[newState].PercentFrequency <= Throttle) {
      DebugPrint((TRACE, "  Found Match! PerfState = %u, Freq %u%%\n",
                  newState,
                  DeviceExtension->PerfStates->State[newState].PercentFrequency));
      break;
    }
  }


  if (newState >= DeviceExtension->PerfStates->Count) {
    DebugPrint((ERROR, "Couldn't find match for throttle request of %u%%\n", Throttle));

    status = STATUS_UNSUCCESSFUL;
    goto SetPerfLevelGenericExit;
  }


  if (newState == DeviceExtension->CurrentPerfState) {

    //
    // No work to do.
    //

    goto SetPerfLevelGenericExit;

  }


  //
  // NOTE: The current state maybe invalid ie. 0xff, this happens notify(0x80).
  //

  lowestPerfState = DeviceExtension->LowestPerfState;

  if (newState <= lowestPerfState) {

    //
    // If throttling is on, turn it off.
    //

    if (DeviceExtension->ThrottleValue) {
      ProcessorThrottle((UCHAR)HalpThrottleScale);
      DeviceExtension->ThrottleValue = 0;
    }

    status = AcpiPerfStateTransition(DeviceExtension, newState);

  } else {

    //
    // Throttle states/percentages are build from the lowest Perf State, make
    // sure we are currently in the lowest perf state.
    //

    if (DeviceExtension->CurrentPerfState != lowestPerfState) {
      AcpiPerfStateTransition(DeviceExtension, lowestPerfState);
    }
      

    //
    // this state is a throttle state, so throttle even if the Transition to
    // low volts fails.
    //

    throttleValue = HalpThrottleScale - (newState - lowestPerfState);
    DebugAssert(throttleValue);
    DebugAssert(HalpThrottleScale != throttleValue);
    
    ProcessorThrottle((UCHAR)throttleValue);
    DeviceExtension->ThrottleValue = throttleValue;
    status = STATUS_SUCCESS;
       
  }


  //
  // Keep track of the state we just set.
  //

  DeviceExtension->LastTransitionResult = status;

  if (NT_SUCCESS(status)) {
    DeviceExtension->CurrentPerfState = newState;
  }


  //
  // Notify any interested parties
  //

  if (PStateEvent.Enabled) {

    PSTATE_EVENT data;
    
    data.State  = newState;
    data.Status = status;
    data.Latency = 0;    // latency
    data.Speed   = DeviceExtension->PerfStates->State[newState].Frequency;
  
    ProcessorFireWmiEvent(DeviceExtension, &PStateEvent, &data);
  }
  
SetPerfLevelGenericExit:
 
  return status;

}
NTSTATUS
FASTCALL
SetThrottleLevelGeneric (
  IN UCHAR     Throttle,
  IN PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  UCHAR       adjustedState;
  UCHAR       state;
  UCHAR       numAcpi2PerfStates;
  
  
  DebugEnter();
  DebugAssert(DeviceExtension);
  DebugPrint((TRACE, "  Throttling to %u%%\n", Throttle));
  
  //
  // Save Throttle in case we aren't able to Throttle
  //
  
  DeviceExtension->LastRequestedThrottle = Throttle;
  
  //
  // Run through the performance states looking for one
  // that matches this throttling level.
  //
  
  for (state = 0; state < DeviceExtension->PerfStates->Count; state++) {
  
    if (DeviceExtension->PerfStates->State[state].PercentFrequency <= Throttle) {
      break;
    }
  }
  
  
  //
  // We didn't find a match, or HalpThrottleScale is incorrect.
  // Either case is a problem.
  //
  
  if ((state >= DeviceExtension->PerfStates->Count) ||
      (state >= HalpThrottleScale)) {
  
    DebugAssert(!"SetThrottleLevel() Invalid state!");
    return STATUS_UNSUCCESSFUL;
  }
  
  
  if (state == DeviceExtension->CurrentPerfState) {
    return STATUS_SUCCESS;
  }
  
  //
  // if state == 0, then we are turning stop throttling off.
  //
  
  ProcessorThrottle((UCHAR)HalpThrottleScale - state);
  
  DeviceExtension->ThrottleValue = HalpThrottleScale - state;
  DeviceExtension->CurrentPerfState = state;

  //
  // Notify any interested parties
  //

  if (PStateEvent.Enabled) {

    PSTATE_EVENT data;
    
    data.State  = state;
    data.Status = STATUS_SUCCESS;
    data.Latency = 0;    // latency
    data.Speed   = DeviceExtension->PerfStates->State[state].Frequency;
  
    ProcessorFireWmiEvent(DeviceExtension, &PStateEvent, &data);
  }
  
  return STATUS_SUCCESS;
  
}
#endif
NTSTATUS
MergePerformanceStatesGeneric(
  IN  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:

      This routine looks at the performance states in the device extension.

      Note:  The caller must hold PerfStateLock.

  Arguments:

      DeviceExtension

  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

  NOTE:

      This is called during START_DEVICE, and after recieving a Notify(0x80)
      on the processor.

--*/
{
  NTSTATUS  status = STATUS_SUCCESS;
  ULONG     oldBuffSize, newBuffSize, state;
  ULONG     availablePerfStates, numThrottlingStates;
  ULONG     lowestPerfState, lowestPerfStateFreq;
  ULONG     maxFreq, maxTransitionLatency = 0;

  PPROCESSOR_PERFORMANCE_STATES newPerfStates;


  DebugEnter();
  PAGED_CODE();

  //
  // Find out how many performance states this machine currently supports
  // by evaluating the ACPI 2.0 _PPC object.
  //

  if (DeviceExtension->PssPackage) {

    status = BuildAvailablePerfStatesFromPss(DeviceExtension);

    if (!NT_SUCCESS(status)) {
      goto MergePerformanceStatesExit;
    }
  }

  //
  // We may have already found Acpi 2.0 or Legacy performance states
  // we need to add those to any duty-cycle throttling states supported.
  // So allocate a buffer big enough to hold them all.
  //

  DebugAssert(DeviceExtension->PerfStates);
  availablePerfStates = DeviceExtension->PerfStates->Count;

  oldBuffSize = sizeof(PROCESSOR_PERFORMANCE_STATES) +
                (sizeof(PROCESSOR_PERFORMANCE_STATE) *
                (availablePerfStates - 1));


  //
  // Calculate addition supported throttling states
  //

  numThrottlingStates = GetNumThrottleSettings(DeviceExtension);
  availablePerfStates += numThrottlingStates;

  newBuffSize = oldBuffSize +
                (sizeof(PROCESSOR_PERFORMANCE_STATE) * numThrottlingStates);


  newPerfStates = ExAllocatePoolWithTag(NonPagedPool,
                                        newBuffSize,
                                        PROCESSOR_POOL_TAG);

  if (!newPerfStates) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto MergePerformanceStatesExit;
  }


  RtlZeroMemory(newPerfStates, newBuffSize);

  DebugAssert(newBuffSize >= oldBuffSize);
  RtlCopyMemory(newPerfStates,
                DeviceExtension->PerfStates,
                oldBuffSize);


  //
  // Figure out which performance states to keep.  At present,
  // we believe that there is no advantage to throttling at any
  // voltage other than the lowest.  E.g. we will drop voltage until
  // there is no more voltage to drop, throttling after that.
  //

  maxFreq = GetMaxProcFrequency(DeviceExtension);


  //
  // Now cycle through any throttling states, appending them if appropriate.
  // PerfStates->Count - 1 is the lowest perf state.  This state will be the one
  // used to calculate frequency and power values from for throttling states.
  //

  lowestPerfState = DeviceExtension->PerfStates->Count - 1;
  lowestPerfStateFreq  = DeviceExtension->PerfStates->State[lowestPerfState].Frequency;

  for (state = lowestPerfState + 1;
       state < numThrottlingStates + lowestPerfState;
       state++) {

    //
    // Frequency is some fraction of the lowest perf state frequency.
    //

    newPerfStates->State[state].Frequency = lowestPerfStateFreq *
      (numThrottlingStates - (state - lowestPerfState)) / numThrottlingStates;

    newPerfStates->State[state].PercentFrequency =
      (UCHAR)PERCENT_TO_PERF_LEVEL((newPerfStates->State[state].Frequency * 100) / maxFreq);

    DebugAssert(newPerfStates->State[state].PercentFrequency <= 100);

    //
    // Mark this state as a Throttling State
    //
    
    newPerfStates->State[state].Flags = PROCESSOR_STATE_TYPE_THROTTLE;


    //
    // Stop processing when we have found all states greater than 200mhz or 
    // 25% of max speed
    //

    #define LOWEST_USABLE_FREQUENCY   200
    #define REQUIRED_THROTTLE_LEVEL    25

    if ((newPerfStates->State[state].Frequency < LOWEST_USABLE_FREQUENCY) &&
        (newPerfStates->State[state].PercentFrequency < REQUIRED_THROTTLE_LEVEL)) {

      DebugPrint((INFO, "Droping all Perf States after state %u: Freq=%u Percent=%u\n",
                 state,
                 newPerfStates->State[state].Frequency,
                 newPerfStates->State[state].PercentFrequency));
      break;
      
    }

  }

  newPerfStates->Count = (UCHAR) state;

  //
  // Replace old perf states with new.
  //

  ExFreePool(DeviceExtension->PerfStates);
  DeviceExtension->PerfStates = newPerfStates;
  DeviceExtension->CurrentPerfState = INVALID_PERF_STATE;

  DumpProcessorPerfStates(newPerfStates);


MergePerformanceStatesExit:

  DebugExitStatus(status);
  return status;

}
NTSTATUS
BuildAvailablePerfStatesFromPss (
  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  NTSTATUS status;
  ULONG    availablePerfStates, ppcResult, perfStatesSize;
  ULONG    maxFreq, maxTransitionLatency = 0, state;


  DebugEnter();
  DebugAssert(DeviceExtension->PssPackage);


  //
  // if this is a legacy system, simulate the _PPC method
  //

  if (DeviceExtension->LegacyInterface) {

    status = STATUS_SUCCESS;
    ppcResult = DeviceExtension->PpcResult;

  } else {

    status = AcpiEvaluatePpc(DeviceExtension, &ppcResult);
  }


  if (!NT_SUCCESS(status)) {
    goto BuildAvailablePerfStatesFromPssExit;
  }


  if (ppcResult > (ULONG)(DeviceExtension->PssPackage->NumPStates - 1)) {

    //
    // Log Error
    //

    QueueEventLogWrite(DeviceExtension,
                       PROCESSOR_PCT_ERROR,
                       ppcResult);


    //
    // change ppcResult to valid value
    //

    ppcResult = DeviceExtension->PssPackage->NumPStates - 1;

  }

  DeviceExtension->PpcResult = ppcResult;
  availablePerfStates = DeviceExtension->PssPackage->NumPStates - ppcResult;
  DeviceExtension->LowestPerfState = availablePerfStates - 1;
  DeviceExtension->CurrentPerfState = INVALID_PERF_STATE;

  //
  // if there were already PerfStates, they were probably acpi 1.0 type
  // throttling, so we will blow them away, because they will be recreated
  // in MergePerformanceStates()
  //

  if (DeviceExtension->PerfStates) {
    ExFreePool(DeviceExtension->PerfStates);
  }

  perfStatesSize = sizeof(PROCESSOR_PERFORMANCE_STATES) +
                     (sizeof(PROCESSOR_PERFORMANCE_STATE) *
                     (availablePerfStates - 1));


  DeviceExtension->PerfStates = ExAllocatePoolWithTag(PagedPool,
                                                      perfStatesSize,
                                                      PROCESSOR_POOL_TAG);


  if (!DeviceExtension->PerfStates) {

    status = STATUS_INSUFFICIENT_RESOURCES;
    goto BuildAvailablePerfStatesFromPssExit;

  }

  
  RtlZeroMemory(DeviceExtension->PerfStates,
                perfStatesSize);

  maxFreq = GetMaxProcFrequency(DeviceExtension);

  for (state = 0; state < availablePerfStates; state++) {

      //
      // Fill in the _PPC states, top down.
      //

      DeviceExtension->PerfStates->State[state].Frequency =
        DeviceExtension->PssPackage->State[state + ppcResult].CoreFrequency;

      DeviceExtension->PerfStates->State[state].PercentFrequency =
        PERCENT_TO_PERF_LEVEL(
          (DeviceExtension->PerfStates->State[state].Frequency * 100) / maxFreq);

      //
      // Mark this state as a Performance State
      //
      
      DeviceExtension->PerfStates->State[state].Flags = PROCESSOR_STATE_TYPE_PERFORMANCE;
      

      maxTransitionLatency =
        MAX(maxTransitionLatency,
          DeviceExtension->PssPackage->State[state + ppcResult].Latency);


    }

    DeviceExtension->PerfStates->TransitionLatency  = maxTransitionLatency;
    DeviceExtension->PerfStates->TransitionFunction = SetPerfLevel;
    DeviceExtension->PerfStates->Count = state;


BuildAvailablePerfStatesFromPssExit:

  DebugExitStatus(status);
  return status;

}

ULONG
GetMaxProcFrequency(
  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
    NTSTATUS status;
    ULONG    frequency = 0;
    static ULONG regSpeed = 0;

    DebugEnter();
    PAGED_CODE();

    //
    // First we check for Acpi 2.0 info, then NonAcpi info, and if we haven't
    // yet gathered either of those, then we use the CPU speed from the registy.
    //

    if (DeviceExtension->PssPackage) {

      frequency = DeviceExtension->PssPackage->State[0].CoreFrequency;

    } else if (DeviceExtension->LegacyInterface) {

      GetLegacyMaxProcFrequency(&frequency);

    } else {

      //
      // Retrieve cpu speed from the registry.
      //

      if (!regSpeed) {
        status = GetRegistryDwordValue(CPU0_REG_KEY,
                                       L"~MHz",
                                       &regSpeed);
      }

      frequency = regSpeed;

    }


    //
    // We couldn't find the max speed, so we will have to guess.
    //

    if (!frequency) {
      frequency = 650; // a reasonable guess?
    }


    DebugExitValue(frequency);
    return frequency;
}
NTSTATUS
SaveCurrentStateGoToLowVolts(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  ULONG targetState;

  DebugEnter();

  //
  // Throttling should be off, and if we have perf states, then we
  // should be at the lowest state.
  //

  if (DevExt->PerfStates && (DevExt->CurrentPerfState != INVALID_PERF_STATE)) {

    AcquireProcessorPerfStateLock(DevExt);

    //
    // Save current throttle percentage
    //

    DebugAssert(DevExt->CurrentPerfState < DevExt->PerfStates->Count);
    DevExt->SavedState = DevExt->PerfStates->State[DevExt->CurrentPerfState].PercentFrequency;


    //
    // Go to lowest Performance state
    //

    targetState = DevExt->LowestPerfState;

    if (DevExt->PerfStates->TransitionFunction) {

      DevExt->PerfStates->TransitionFunction(
        (UCHAR)DevExt->PerfStates->State[targetState].PercentFrequency);
    }

    ReleaseProcessorPerfStateLock(DevExt);
  }

  return STATUS_SUCCESS;

}
NTSTATUS
RestoreToSavedPerformanceState(
  IN PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  //
  // BUG 615135: remove code that restores save processor performance state,
  //             as it causes the kernel to get out of sync.
  //


  return STATUS_SUCCESS;

}
NTSTATUS
SetProcessorPerformanceState(
  IN ULONG TargetPerfState,
  IN PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
  NTSTATUS status;

  DebugEnter();
  DebugAssert(DeviceExtension);
  DebugPrint((TRACE, "Transitioning to state 0x%x\n", TargetPerfState));

  if (TargetPerfState < DeviceExtension->PerfStates->Count) {

    DeviceExtension->PerfStates->TransitionFunction(
      (UCHAR)DeviceExtension->PerfStates->State[TargetPerfState].PercentFrequency);

    status = STATUS_SUCCESS;

  } else {

    //
    // not a vaild state
    //

    DebugPrint((TRACE, "%u is not a valid Processor Performance State\n"));
    status = STATUS_UNSUCCESSFUL;

  }


  return status;
}
NTSTATUS
QueueEventLogWrite(
  IN PFDO_DATA DeviceExtension,
  IN ULONG EventErrorCode,
  IN ULONG EventValue
  )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
  PEVENT_LOG_CONTEXT context;

  context = ExAllocatePoolWithTag(NonPagedPool, 
                                  sizeof(EVENT_LOG_CONTEXT), 
                                  PROCESSOR_POOL_TAG);


  if (!context) {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  context->EventErrorCode = EventErrorCode;
  context->EventValue = EventValue;
  context->WorkItem = IoAllocateWorkItem(DeviceExtension->Self);
  

  if (context->WorkItem) {
    
    //
    // Log error to event log
    //

    IoQueueWorkItem(context->WorkItem,
                    ProcessEventLogEntry,
                    DelayedWorkQueue,
                    context);

    return STATUS_SUCCESS;
    
  } else {
  
    DebugPrint((ERROR, "IoAllocateWorkItem() Failed!\n"));
    ExFreePool(context);
    return STATUS_INSUFFICIENT_RESOURCES;
  }
}
VOID
ProcessEventLogEntry (
  IN PDEVICE_OBJECT DeviceObject,
  IN PVOID Context
  )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{

  WCHAR eventLogValue[11];
  UNICODE_STRING eventLogErrorString;
  PEVENT_LOG_CONTEXT workItem = (PEVENT_LOG_CONTEXT) Context;
  PVOID string = NULL;
  ULONG stringCount = 0;

  DebugEnter();
  DebugAssert(Context);
  PAGED_CODE();

  //
  // Free worker resources
  //

  IoFreeWorkItem(workItem->WorkItem);
  
  switch (workItem->EventErrorCode) {

    case PROCESSOR_PCT_ERROR:
    case PROCESSOR_INIT_TRANSITION_FAILURE:

      eventLogErrorString.Buffer = eventLogValue;
      eventLogErrorString.MaximumLength = sizeof(eventLogValue);
      RtlIntegerToUnicodeString(workItem->EventValue, 10, &eventLogErrorString);
      string = &eventLogErrorString.Buffer;
      stringCount = 1;
      break;

    case PROCESSOR_LEGACY_INTERFACE_FAILURE:
    case PROCESSOR_INITIALIZATION_FAILURE:
    case PROCESSOR_REINITIALIZATION_FAILURE:

      //
      // no strings
      //

      break;



    default:
      DebugPrint((ERROR, "ProcessEventLogEntry: Unknown EventErrorCode\n"));
      goto ProcessEventLogEntryExit;
  }


  //
  // Write Event
  //

  WriteEventLogEntry(DeviceObject,
                     workItem->EventErrorCode,
                     string,
                     stringCount,
                     NULL,
                     0);

  ProcessEventLogEntryExit:

    ExFreePool(Context);
}
NTSTATUS
PowerStateHandlerNotificationRegistration (
  IN PENTER_STATE_NOTIFY_HANDLER NotifyHandler,
  IN PVOID Context,
  IN BOOLEAN Register
  )
/*++

  Routine Description:

  Arguments:

  Return Value:


--*/
{
  POWER_STATE_NOTIFY_HANDLER newHandler = {0};
  NTSTATUS status;

  DebugEnter();



  if (Register) {

    DebugAssert(NotifyHandler);
    newHandler.Handler = NotifyHandler;
    newHandler.Context = Context;

  }


  status = ZwPowerInformation(SystemPowerStateNotifyHandler,
                              &newHandler,
                              sizeof(POWER_STATE_NOTIFY_HANDLER),
                              NULL,
                              0);


  DebugExitStatus(status);
  return status;
}
NTSTATUS
ProcessMultipleApicDescTable(
  PPROCESSOR_INFO ProcInfo
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PMAPIC mapicTable = NULL;
  PUCHAR apicTable;
  PUCHAR mapicTableEnd;
  UCHAR  apicType;
  UCHAR  apicSize;

  DebugEnter();
  DebugAssert(ProcInfo);
  DebugAssert(ProcInfo->TotalProcessors == 0);

  //
  // Get MAPIC table
  //

  mapicTable = GetAcpiTable(APIC_SIGNATURE);

  if (!mapicTable) {
    return STATUS_UNSUCCESSFUL;
  }

  //
  // Start of MAPIC tables
  //

  apicTable = (PUCHAR) mapicTable->APICTables;


  //
  // Calculate end of MAPIC table.
  //

  mapicTableEnd = (PUCHAR) mapicTable + mapicTable->Header.Length;


  //
  // Walk through each APIC table
  //

  while ((apicTable + sizeof(PROCLOCALAPIC)) <= mapicTableEnd) {

    //
    // individual apic tables have common header
    //

    apicType = ((PAPICTABLE)apicTable)->Type;
    apicSize = ((PAPICTABLE)apicTable)->Length;


    //
    // Sanity check
    //

    if (!apicSize) {
      DebugPrint((ERROR, "ProcessMultipleApicDescTable() table size = 0\n"));
      break;
    }


    if (apicType == PROCESSOR_LOCAL_APIC &&
        apicSize == PROCESSOR_LOCAL_APIC_LENGTH) {

      PPROCLOCALAPIC procLocalApic = (PPROCLOCALAPIC) apicTable;

      // toddcar - 12/08/2000: TEMP
      // Should implement better method to map between processorid and ApicId.
      //

      //
      // save Processor ID to APIC ID mappings
      //

      ProcInfo->ProcIdToApicId[procLocalApic->ACPIProcessorID] = procLocalApic->APICID;
      ProcInfo->TotalProcessors++;

      DebugAssert(ProcInfo->TotalProcessors < MAX_PROCESSOR_VALUE);

      if (procLocalApic->Flags & PLAF_ENABLED) {
        ProcInfo->ActiveProcessors++;
      }
    }

    apicTable += apicSize;
  }

  //
  // Allocated by GetAcpiTable()
  //

  if (mapicTable) {
    ExFreePool(mapicTable);
  }

  return STATUS_SUCCESS;
}
extern
_inline
ULONG
GetApicId(
  VOID
  )
{

//
//  Well known virtual address of local processor apic
//

  return ((pLocalApic[LU_ID_REGISTER] & APIC_ID_MASK) >> APIC_ID_SHIFT);
}
NTSTATUS
SetProcessorFriendlyName (
  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  NTSTATUS       status = STATUS_UNSUCCESSFUL;
  PWCHAR         driverEnumKey;
  PWCHAR         instanceId;
  PWCHAR         deviceRegKey;
  ULONG          size;
  PUCHAR         cpuBrandString = NULL;
  PUCHAR         tmpBrandString = NULL;
  ANSI_STRING    ansiCpuString;
  UNICODE_STRING unicodeCpuString;
  UNICODE_STRING fullDeviceId;


  DebugEnter();


  //
  // if we already have the Processor Brand String,
  // we will use it.
  //

  if (!Globals.ProcessorBrandString) {

    //
    // Get size needed
    //

    status = GetProcessorBrandString(NULL, &size);

    if (status == STATUS_NOT_SUPPORTED || !size) {
      goto SetProcessorFriendlyNameExit;
    }


    //
    // alloc some memory
    //

    cpuBrandString = ExAllocatePoolWithTag(PagedPool,
                                           size,
                                           PROCESSOR_POOL_TAG);

    if (!cpuBrandString) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto SetProcessorFriendlyNameExit;
    }


    //
    // Get Brand String
    //

    status = GetProcessorBrandString(cpuBrandString, &size);

    if (!NT_SUCCESS(status)) {
      goto SetProcessorFriendlyNameExit;
    }


    //
    // need to save orig pointer for the free
    //

    tmpBrandString = cpuBrandString;


    //
    // some Processors include leading spaces, removed them
    //

    while (tmpBrandString[0] == 0x20) {
      tmpBrandString++;
    }


    //
    // Convert ansi string to wide
    //

    RtlInitAnsiString(&ansiCpuString, tmpBrandString);
    status = RtlAnsiStringToUnicodeString(&unicodeCpuString,
                                          &ansiCpuString,
                                          TRUE);

    if (!NT_SUCCESS(status)) {
      goto SetProcessorFriendlyNameExit;
    }

    Globals.ProcessorBrandString = unicodeCpuString.Buffer;
  }


  //
  // construct registy path for current pocessor device
  //


  //
  // Construct driver enum path...
  // HKLM\Machine\System\CurrentControlSet\Services\P3+\+Enum
  // 2 == "\" + NULL
  //

  size = Globals.RegistryPath.Length +
         ((wcslen(EnumKeyName) + 2) * sizeof(WCHAR));

  driverEnumKey = ExAllocatePoolWithTag(PagedPool, size, PROCESSOR_POOL_TAG);

  if (!driverEnumKey) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto SetProcessorFriendlyNameExit;
  }


  //
  // construct enum registry path for current device
  //

  _snwprintf(driverEnumKey,
             size,
             L"%s\\%s",
             Globals.RegistryPath.Buffer,
             EnumKeyName);


  //
  // Get Instance Id string
  //

  status = GetInstanceId(DeviceExtension, &instanceId);

  if (!NT_SUCCESS(status)) {
    goto SetProcessorFriendlyNameExit;
  }

  //
  // get Bus\DeviceId\InstanceId path from driver's enum key
  //

  GetRegistryStringValue(driverEnumKey,
                         instanceId,
                         &fullDeviceId);



  ExFreePool(driverEnumKey);
  ExFreePool(instanceId); // allocated inside GetInstanceId



  //
  // alloc enough memory for entire regkey path
  // 2 == "\" + NULL
  //

  size = fullDeviceId.Length + ((wcslen(CCSEnumRegKey) + 2) * sizeof(WCHAR));
  deviceRegKey = ExAllocatePoolWithTag(PagedPool, size, PROCESSOR_POOL_TAG);


  if (!deviceRegKey) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto SetProcessorFriendlyNameExit;
  }


  //
  // construct enum registry path for current device
  //

  _snwprintf(deviceRegKey,
             size,
             L"%s\\%s",
             CCSEnumRegKey,
             fullDeviceId.Buffer);


  //
  // create "FriendlyName" regkey for processor device
  //

  status = SetRegistryStringValue(deviceRegKey,
                                  (PWCHAR)FriendlyNameRegKey,
                                  Globals.ProcessorBrandString);


  ExFreePool(deviceRegKey);
  ExFreePool(fullDeviceId.Buffer);


SetProcessorFriendlyNameExit:

  if (cpuBrandString) {
    ExFreePool(cpuBrandString);
  }


  DebugExitStatus(status);
  return status;

}
NTSTATUS
GetHardwareId(
  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:

--*/
{
  NTSTATUS status;
  KEVENT   event;
  PIRP     irp;
  IO_STATUS_BLOCK ioStatusBlock;
  PIO_STACK_LOCATION irpStack;

  DebugEnter();

  KeInitializeEvent(&event, NotificationEvent, FALSE);

  irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                     DeviceExtension->NextLowerDriver,
                                     NULL,
                                     0,
                                     NULL,
                                     &event,
                                     &ioStatusBlock);

  if (!irp) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto GetHardwareIdExit;
  }

  irpStack = IoGetNextIrpStackLocation(irp);
  irpStack->MinorFunction = IRP_MN_QUERY_ID;
  irpStack->Parameters.QueryId.IdType = BusQueryDeviceID;

  irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

  status = IoCallDriver(DeviceExtension->NextLowerDriver, irp);

  if (status == STATUS_PENDING) {

      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = ioStatusBlock.Status;

  }


  if (NT_SUCCESS(status)) {
    DebugPrint((ERROR, "DeviceId == %S\n", ioStatusBlock.Information));
  }



GetHardwareIdExit:


  DebugExitStatus(status);
  return status;

}
NTSTATUS
GetInstanceId(
  PFDO_DATA DeviceExtension,
  PWCHAR    *InstanceId
  )
/*++

  Routine Description:


  Arguments:


  Return Value:

--*/
{
  NTSTATUS status;
  KEVENT   event;
  PIRP     irp;
  ULONG    idSize;
  IO_STATUS_BLOCK ioStatusBlock;
  PIO_STACK_LOCATION irpStack;

  DebugEnter();
  DebugAssert(InstanceId);

  KeInitializeEvent(&event, NotificationEvent, FALSE);

  irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                     DeviceExtension->NextLowerDriver,
                                     NULL,
                                     0,
                                     NULL,
                                     &event,
                                     &ioStatusBlock);

  if (!irp) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto GetHardwareIdExit;
  }

  irpStack = IoGetNextIrpStackLocation(irp);
  irpStack->MinorFunction = IRP_MN_QUERY_ID;
  irpStack->Parameters.QueryId.IdType = BusQueryInstanceID;

  irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

  status = IoCallDriver(DeviceExtension->NextLowerDriver, irp);

  if (status == STATUS_PENDING) {

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = ioStatusBlock.Status;

  }


  //
  // remove leading white spaces
  //


  if (NT_SUCCESS(status)) {

    PWCHAR idString = (PWCHAR)ioStatusBlock.Information;

    //
    // remove leading white space
    //

    while(idString[0] == 0x20) {
      idString++;
    }

    idSize = (wcslen(idString) + 1) * sizeof(WCHAR);

    *InstanceId = ExAllocatePoolWithTag(PagedPool, idSize, PROCESSOR_POOL_TAG);

    if (!(*InstanceId)) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto GetHardwareIdExit;
    }

    RtlCopyMemory(*InstanceId, idString, idSize);
 
    //
    // Free ID structure
    //
  
    ExFreePool((PWCHAR)ioStatusBlock.Information);
  }

GetHardwareIdExit:


  DebugExitStatus(status);
  return status;

}
__inline
NTSTATUS
AcquireProcessorPerfStateLock (
  IN PFDO_DATA DevExt
  )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

  return  KeWaitForSingleObject(&DevExt->PerfStateLock,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL);
}
__inline
NTSTATUS
ReleaseProcessorPerfStateLock (
  IN PFDO_DATA DevExt
  )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
  return KeSetEvent(&DevExt->PerfStateLock, IO_NO_INCREMENT, FALSE);
}
#if DBG
VOID
DumpCStates(
  PACPI_CST_PACKAGE CStates
  )
{

  ULONG x;
  PACPI_CST_DESCRIPTOR cState;

  DebugAssert(CStates);

  DebugPrint((TRACE, "\n"));
  DebugPrint((TRACE, "_CST:\n"));
  DebugPrint((TRACE, "Found %u C-states\n", CStates->NumCStates));
  DebugPrint((TRACE, "\n"));

  for (x=0; x < CStates->NumCStates; x++) {

    cState = &CStates->State[x];

    DebugPrint((TRACE, "State #%u:\n", x));
    DebugPrint((TRACE, "  Register:\n"));
    DebugPrint((TRACE, "    AddressSpaceID:  0x%x\n", cState->Register.AddressSpaceID));
    DebugPrint((TRACE, "    BitWidth:        0x%x\n", cState->Register.BitWidth));
    DebugPrint((TRACE, "    BitOffset:       0x%x\n", cState->Register.BitOffset));
    DebugPrint((TRACE, "    Reserved:        0x%x\n", cState->Register.Reserved));
    DebugPrint((TRACE, "    Address:         0x%I64x\n", cState->Register.Address));
    DebugPrint((TRACE, "\n"));
    DebugPrint((TRACE, "  State Type:        C%u\n", cState->StateType));
    DebugPrint((TRACE, "  Latency:           %u us\n", cState->Latency));
    DebugPrint((TRACE, "  Power Consumption: %u mW\n", cState->PowerConsumption));
    DebugPrint((TRACE, "\n"));

  }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\power.h ===
/*++
Copyright (c) 1990-2000    Microsoft Corporation All Rights Reserved

Module Name:

    power.h

Abstract:

    This module contains the declarations used by power.c

Author:

     Eliyas Yakub   Sep 16, 1998

Environment:

    user and kernel
Notes:


Revision History:


--*/
#ifndef __POWER_H
#define __POWER_H

typedef enum {

    IRP_NEEDS_FORWARDING = 1,
    IRP_ALREADY_FORWARDED

} IRP_DIRECTION;

typedef struct _POWER_COMPLETION_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    PIRP            SIrp;

} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {

    PDEVICE_OBJECT  DeviceObject;
    PIRP            Irp;
    IRP_DIRECTION   IrpDirection;
    PIO_WORKITEM    WorkItem;

} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;
    
typedef struct {

    PAC_DC_NOTIFY_HANDLER Handler;
    PVOID                 Context;
    
} AC_DC_TRANSITION_NOTIFY, *PAC_DC_TRANSITION_NOTIFY;


NTSTATUS
ProcessorDefaultPowerHandler  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    );


NTSTATUS
ProcessorQueryPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    );

NTSTATUS
ProcessorSetPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    );


VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
);

NTSTATUS
HoldIoRequests(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  IRP_DIRECTION       Direction
    );

NTSTATUS
ProcessorPowerCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PVOID                Context
    )   ;

VOID
ProcessorPoRequestComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleSystemPowerIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
OnFinishSystemPowerUp(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

VOID
QueueCorrespondingDeviceIrp(
    IN PIRP             SIrp,
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
OnPowerRequestComplete(
    PDEVICE_OBJECT              DeviceObject,
    UCHAR                       MinorFunction,
    POWER_STATE                 state,
    POWER_COMPLETION_CONTEXT*   ctx,
    PIO_STATUS_BLOCK            pstatus
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

NTSTATUS HandleDeviceSetPower(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
OnFinishDevicePowerUp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            junk
    );


NTSTATUS
BeginSetDevicePowerState(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  IRP_DIRECTION       Direction
    );

NTSTATUS
FinishDevicePowerIrp(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  IRP_DIRECTION       Direction,
    IN  NTSTATUS            Result
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\power.c ===
/*++

Copyright (c) 1990-2000    Microsoft Corporation All Rights Reserved

Module Name:

    power.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    The power policy of this driver is simple. The device enters the
    device working state D0 when the system enters the system
    working state S0. The device enters the lowest-powered sleeping state
    D3 for all the other system power states (S1-S5).

Environment:

    Kernel mode

Revision History:

--*/

#include "processor.h"
#include "power.h"

PVOID ProcessorSleepPageLock = NULL;
AC_DC_TRANSITION_NOTIFY AcDcTransitionNotifyHandler;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGELK, ProcessorDispatchPower)
#pragma alloc_text (PAGELK, ProcessorDefaultPowerHandler)
#pragma alloc_text (PAGELK, ProcessorSetPowerState)
#pragma alloc_text (PAGELK, ProcessorQueryPowerState)
#pragma alloc_text (PAGELK, HandleSystemPowerIrp)
#pragma alloc_text (PAGELK, OnFinishSystemPowerUp)
#pragma alloc_text (PAGELK, QueueCorrespondingDeviceIrp)
#pragma alloc_text (PAGELK, OnPowerRequestComplete)
#pragma alloc_text (PAGELK, HandleDeviceQueryPower)
#pragma alloc_text (PAGELK, HandleDeviceSetPower)
#pragma alloc_text (PAGELK, OnFinishDevicePowerUp)
#pragma alloc_text (PAGELK, BeginSetDevicePowerState)
#pragma alloc_text (PAGELK, FinishDevicePowerIrp)
#pragma alloc_text (PAGELK, HoldIoRequests)
#pragma alloc_text (PAGELK, HoldIoRequestsWorkerRoutine)
#pragma alloc_text (PAGELK, ProcessorPowerStateCallback)
#pragma alloc_text (PAGELK, RegisterAcDcTransitionNotifyHandler)
#endif

NTSTATUS
ProcessorDispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    PFDO_DATA           fdoData;
    NTSTATUS            status;

    DebugEnter();
    
    stack   = IoGetCurrentIrpStackLocation(Irp);
    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    DebugPrint((TRACE, "FDO %s IRP:0x%x %s %s\n",
                         PowerMinorFunctionString(stack->MinorFunction),
                         Irp,
                         DbgSystemPowerString(fdoData->SystemPowerState),
                         DbgDevicePowerString(fdoData->DevicePowerState)));

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //


    if (Deleted == fdoData->DevicePnPState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // If the device is not stated yet, just pass it down.
    //

    if (NotStarted == fdoData->DevicePnPState ) {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(fdoData->NextLowerDriver, Irp);
    }

    ProcessorIoIncrement (fdoData);

    //
    // Check the request type.
    //

    switch  (stack->MinorFunction)  {

        case IRP_MN_SET_POWER   :

            //
            // The Power Manager sends this IRP for one of the
            // following reasons:
            // 1) To notify drivers of a change to the system power state.
            // 2) To change the power state of a device for which
            //    the Power Manager is performing idle detection.
            // A driver sends IRP_MN_SET_POWER to change the power
            // state of its device if it's a power policy owner for the
            // device.
            //

            status = ProcessorSetPowerState(DeviceObject, Irp);

            break;


        case IRP_MN_QUERY_POWER   :


            //
            // The Power Manager sends a power IRP with the minor
            // IRP code IRP_MN_QUERY_POWER to determine whether it
            // can safely change to the specified system power state
            // (S1-S5) and to allow drivers to prepare for such a change.
            // If a driver can put its device in the requested state,
            // it sets status to STATUS_SUCCESS and passes the IRP down.
            //

            status = ProcessorQueryPowerState(DeviceObject, Irp);
            break;

        case IRP_MN_WAIT_WAKE   :
            //
            // The minor power IRP code IRP_MN_WAIT_WAKE provides
            // for waking a device or waking the system. Drivers
            // of devices that can wake themselves or the system
            // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
            // only to devices that always wake the system, such as
            // the power-on switch.
            //

        case IRP_MN_POWER_SEQUENCE   :

            //
            // A driver sends this IRP as an optimization to determine
            // whether its device actually entered a specific power state.
            // This IRP is optional. Power Manager cannot send this IRP.
            //

        default:
            //
            // Pass it down
            //
            status = ProcessorDefaultPowerHandler(DeviceObject, Irp);
            ProcessorIoDecrement(fdoData);
            break;
    }

    return status;
}

NTSTATUS
ProcessorDefaultPowerHandler  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )
/*++

Routine Description:

    If a driver does not support a particular power IRP,
    it must nevertheless pass the IRP down the device stack
    to the next-lower driver. A driver further down the stack
    might be prepared to handle the IRP and must have the
    opportunity to do so.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS         status;
    PFDO_DATA        fdoData;

    DebugEnter();
    
    //
    // Drivers must call PoStartNextPowerIrp while the current
    // IRP stack location points to the current driver.
    // This routine can be called from the DispatchPower routine
    // or from the IoCompletion routine. However, PoStartNextPowerIrp
    // must be called before IoCompleteRequest, IoSkipCurrentIrpStackLocation,
    // and PoCallDriver. Calling the routines in the other order might
    // cause a system deadlock.
    //

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    fdoData = (PFDO_DATA)DeviceObject->DeviceExtension;

    //
    // Drivers must use PoCallDriver, rather than IoCallDriver,
    // to pass power IRPs. PoCallDriver allows the Power Manager
    // to ensure that power IRPs are properly synchronized throughout
    // the system.
    //

    status = PoCallDriver(fdoData->NextLowerDriver, Irp);

    if (!NT_SUCCESS(status)) {
        DebugPrint((0, "Lower driver fails a power irp\n"));
    }

    return status;
}

NTSTATUS
ProcessorSetPowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Processes IRP_MN_SET_POWER.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

    DebugEnter();
    
    return (stack->Parameters.Power.Type == SystemPowerState) ?
            HandleSystemPowerIrp(DeviceObject, Irp) :
            HandleDeviceSetPower(DeviceObject, Irp);
}


NTSTATUS
ProcessorQueryPowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Processes IRP_MN_QUERY_POWER.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);

    DebugEnter();
    
    return (stack->Parameters.Power.Type == SystemPowerState) ?
        HandleSystemPowerIrp(DeviceObject, Irp) :
        HandleDeviceQueryPower(DeviceObject, Irp);
}


NTSTATUS
HandleSystemPowerIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

   Processes IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
   for the system power Irp (S-IRP).

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION  stack = IoGetCurrentIrpStackLocation(Irp);
    POWER_STATE_TYPE    type  = stack->Parameters.Power.Type;
    PFDO_DATA           fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    SYSTEM_POWER_STATE  newSystemState;

    DebugEnter();

    IoMarkIrpPending(Irp);


    newSystemState = stack->Parameters.Power.State.SystemState;

    
    //
    // Here we update our cached away system power state.
    //
    
    if (stack->MinorFunction == IRP_MN_SET_POWER) {
                
        //
        // We are suspending ...
        //
        
        if (newSystemState > PowerSystemWorking &&
            newSystemState < PowerSystemShutdown) {
            
          ProcessSuspendToSleepState(newSystemState, fdoData);
          
        }
       
    
        //
        // We are resuming ...
        //
        
        if (newSystemState == PowerSystemWorking) { 
          ProcessResumeFromSleepState(fdoData->SystemPowerState, fdoData);
        }

    
        fdoData->SystemPowerState = newSystemState;                    
    }

    //
    // Send the IRP down
    //
    
    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           (PIO_COMPLETION_ROUTINE) OnFinishSystemPowerUp,
                           NULL, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    PoCallDriver(fdoData->NextLowerDriver, Irp);

    return STATUS_PENDING;
}


NTSTATUS
OnFinishSystemPowerUp(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
/*++

Routine Description:

   The completion routine for Power Up S-IRP.
   It queues a corresponding D-IRP.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Not used  - context pointer

Return Value:

   NT status code

--*/
{
    PFDO_DATA   fdoData = (PFDO_DATA) Fdo->DeviceExtension;
    NTSTATUS    status = Irp->IoStatus.Status;

    DebugEnter();

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        ProcessorIoDecrement(fdoData);
        return STATUS_SUCCESS;
    }

    QueueCorrespondingDeviceIrp(Irp, Fdo);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
QueueCorrespondingDeviceIrp(
    IN PIRP SIrp,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

   This routine gets the D-State for a particular S-State
   from DeviceCaps and generates a D-IRP.

Arguments:

   Irp - pointer to an S-IRP.

   DeviceObject - pointer to a device object.

Return Value: 

--*/

{
    POWER_COMPLETION_CONTEXT* powerContext;
    NTSTATUS            status;
    POWER_STATE         state;
    PFDO_DATA           fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  stack = IoGetCurrentIrpStackLocation(SIrp);
    POWER_STATE         systemState = stack->Parameters.Power.State;

    DebugEnter();
    
    //
    // Read the D-IRP out of the S->D mapping array we captured in QueryCap's.
    // We can choose deeper sleep states than our mapping (with the appropriate
    // caveats if we have children), but we can never choose lighter ones, as
    // what hardware stays on in a given S-state is a function of the
    // motherboard wiring.
    //
    // Also note that if a driver rounds down it's D-state, it must ensure that
    // such a state is supported. A driver can do this by examining the
    // D1Supported? and D2Supported? flags (Win2k), or by examining the entire
    // S->D state mapping (Win98).
    //
    state.DeviceState = fdoData->DeviceCaps.DeviceState[systemState.SystemState];

    powerContext = (POWER_COMPLETION_CONTEXT*) 
                        ExAllocatePoolWithTag(NonPagedPool, 
                                              sizeof(POWER_COMPLETION_CONTEXT),
                                              PROCESSOR_POOL_TAG);

    if (!powerContext) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;

        //
        // Note: Win2k's PoRequestPowerIrp can take an FDO,
        // but Win9x's requires the PDO.
        //

        status = PoRequestPowerIrp(fdoData->UnderlyingPDO,
                                    stack->MinorFunction,
                                    state, OnPowerRequestComplete,
                                    powerContext, NULL);
    }

    if (!NT_SUCCESS(status)) {

        if (powerContext) {
            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);
        SIrp->IoStatus.Status = status;
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);
        ProcessorIoDecrement(fdoData);

    }
}


VOID
OnPowerRequestComplete(
    PDEVICE_OBJECT DeviceObject,
    UCHAR MinorFunction,
    POWER_STATE state,
    POWER_COMPLETION_CONTEXT* PowerContext,
    PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

   Completion routine for D-IRP.

Arguments:


Return Value: 

--*/
{
    PFDO_DATA   fdoData = (PFDO_DATA) PowerContext->DeviceObject->DeviceExtension;
    PIRP        sIrp = PowerContext->SIrp;

    DebugEnter();
    
    //
    // Here we copy the D-IRP status into the S-IRP
    //
    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // Release the IRP
    //
    PoStartNextPowerIrp(sIrp);
    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // Cleanup
    //
    ExFreePool(PowerContext);
    ProcessorIoDecrement(fdoData);

}


NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Handles IRP_MN_QUERY_POWER for D-IRP

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack = IoGetCurrentIrpStackLocation(Irp);
    PFDO_DATA           fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    DEVICE_POWER_STATE  deviceState = stack->Parameters.Power.State.DeviceState;
    NTSTATUS            status;

    DebugEnter();
    
    //
    // Here we check to see if it's OK for our hardware to be suspended. Note
    // that our driver may have requests that would cause us to fail this
    // check. If so, we need to begin queuing requests after succeeding this
    // call (otherwise we may succeed such an IRP *after* we've said we can
    // power down).
    //
    // Note - we may be at DISPATCH_LEVEL here. As such the below code assumes
    //        all I/O is handled at DISPATCH_LEVEL under a spinlock
    //        (IoStartNextPacket style), or that this function cannot fail. If
    //        such operations are to be handled at PASSIVE_LEVEL (meaning we
    //        need to block on an *event* here), then this code should mark the
    //        Irp pending (via IoMarkIrpPending), queue a workitem, and return
    //        STATUS_PENDING.
    //

    if (deviceState == PowerDeviceD0) {

        //
        // Note - this driver does not queue IRPs if the S-to-D state mapping
        //        specifies that the device will remain in D0 during standby.
        //        For some devices, this could be a problem. For instance, if
        //        an audio card where in a machine where S1->D0, it not want to
        //        stay "active" during standby (could be noisy).
        //
        //        Ideally, a driver would be able to use the ShutdownType field
        //        in the D-IRP to distinguish these cases. Unfortunately, this
        //        field cannot be trusted for D0 IRPs. A driver can get the same
        //        information however by maintaining a pointer to the current
        //        S-IRP in its device extension. Of course, such a driver must
        //        be very very careful if it also does idle detection (which is
        //        not shown here).
        //
        status = STATUS_SUCCESS;
    } else {

        status = HoldIoRequests(DeviceObject, Irp, IRP_NEEDS_FORWARDING);
        if(STATUS_PENDING == status)
        {
            return status;
        }
    }

    status = FinishDevicePowerIrp(DeviceObject, Irp, IRP_NEEDS_FORWARDING, status);

    return status;
}


NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles IRP_MN_SET_POWER for D-IRP

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack = IoGetCurrentIrpStackLocation(Irp);
    POWER_STATE_TYPE    type = stack->Parameters.Power.Type;
    POWER_STATE         state = stack->Parameters.Power.State;
    NTSTATUS            status;
    PFDO_DATA           fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    DebugEnter();
    
    if (state.DeviceState < fdoData->DevicePowerState) { // adding power

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                      (PIO_COMPLETION_ROUTINE) OnFinishDevicePowerUp,
                      NULL, TRUE, TRUE, TRUE);

        PoCallDriver(fdoData->NextLowerDriver, Irp);
        return STATUS_PENDING;

    } else {

        //
        // We are here if we are entering a deeper sleep or entering a state
        // we are already in.
        //
        // As non-D0 IRPs are not alike (some may be for hibernate, shutdown,
        // or sleeping actions), we present these to our state machine.
        //
        // All D0 IRPs are alike though, and we don't want to touch our hardware
        // on a D0->D0 transition. However, we must still present them to our
        // state machine in case we succeeded a Query-D call (which may begin
        // queueing future requests) and the system has sent an S0 IRP to cancel
        // that preceeding query.
        //
        status = BeginSetDevicePowerState(DeviceObject, Irp, IRP_NEEDS_FORWARDING);
        return status;
    }
}


NTSTATUS
OnFinishDevicePowerUp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID NotUsed
    )
/*++

Routine Description:

   The completion routine for Power Up D-IRP.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Not used  - context pointer

Return Value:

   NT status code

--*/
{
    PFDO_DATA           fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    NTSTATUS            status = Irp->IoStatus.Status;
    PIO_STACK_LOCATION  stack = IoGetCurrentIrpStackLocation(Irp);
    POWER_STATE_TYPE    type = stack->Parameters.Power.Type;

    DebugEnter();
    
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        ProcessorIoDecrement(fdoData);
        return STATUS_SUCCESS;
    }

    ASSERT(stack->MajorFunction == IRP_MJ_POWER);
    ASSERT(stack->MinorFunction == IRP_MN_SET_POWER);

    BeginSetDevicePowerState(DeviceObject, Irp, IRP_ALREADY_FORWARDED);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
BeginSetDevicePowerState(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  IRP_DIRECTION       Direction
    )
/*++

Routine Description:

   This routine performs the actual power changes to the device.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an D-IRP.

   Direction -  Whether to forward the D-IRP down or not.
                This depends on whether the system is powering
                up or down.
Return Value:

   NT status code

--*/
{
    PFDO_DATA           fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  stack = IoGetCurrentIrpStackLocation(Irp);
    POWER_ACTION        newDeviceAction;
    DEVICE_POWER_STATE  newDeviceState, oldDeviceState;
    POWER_STATE         newState;
    NTSTATUS            status = STATUS_SUCCESS;

    DebugEnter();
    
    //
    // Note - Here we may be at DISPATCH_LEVEL. The below code assumes all I/O
    //        is handled at DISPATCH_LEVEL under a spinlock (IoStartNextPacket
    //        style). If such operations are to be handled at PASSIVE_LEVEL then
    //        this code should queue a workitem if called at DISPATCH_LEVEL.
    //
    //        Also note that we'd want to mark the IRP appropriately (via
    //        IoMarkIrpPending) and we'd want to return STATUS_PENDING. As this
    //        example does things synchronously, it is enough for us to return
    //        the result of FinishSetDevicePowerState.
    //

    //
    // Update our state.
    //
    newState =  stack->Parameters.Power.State;
    newDeviceState = newState.DeviceState;
    oldDeviceState = fdoData->DevicePowerState;
    fdoData->DevicePowerState = newDeviceState;

    DebugPrint((TRACE, "BeginSetDevicePowerState: Device State = %s\n",
                DbgDevicePowerString(fdoData->DevicePowerState)));

    if (newDeviceState > PowerDeviceD0) {

        //
        // We are here if our hardware is about to be turned off. HoldRequests
        // queues a workitem and returns immediately with STATUS_PENDING.
        //
        status = HoldIoRequests(DeviceObject, Irp, Direction);

        if(STATUS_PENDING == status)
        {
            return status;
        }
    }

    newDeviceAction = stack->Parameters.Power.ShutdownType;

    if (newDeviceState > oldDeviceState) {

        //
        // We are entering a deeper sleep state. Save away the appropriate
        // state and update our hardware. Note that this particular driver does
        // not care to distinguish Hibernates from shutdowns or standbys. If we
        // did the logic would also have to examine newDeviceAction.
        //
        PoSetPowerState(DeviceObject, DevicePowerState, newState);

    } else if (newDeviceState < oldDeviceState) {

        //
        // We are entering a lighter sleep state. Restore the appropriate amount
        // of state to our hardware.
        //
        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    if (newDeviceState == PowerDeviceD0) {

        //
        // Our hardware is now on again. Here we empty our existing queue of
        // requests and let in new ones. Note that if this is a D0->D0 (ie
        // no change) we will unblock our queue, which may have been blocked
        // processing our Query-D IRP.
        //
        fdoData->QueueState = AllowRequests;
        ProcessorProcessQueuedRequests(fdoData);
        status = STATUS_SUCCESS;
    }

    return FinishDevicePowerIrp(
                            DeviceObject,
                            Irp,
                            Direction,
                            status
                            );

}


NTSTATUS
FinishDevicePowerIrp(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  IRP_DIRECTION       Direction,
    IN  NTSTATUS            Result
    )
/*++

Routine Description:

   This is the final step in D-IRP handling.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an D-IRP.

   Direction -  Whether to forward the D-IRP down or not.
                This depends on whether the system is powering
                up or down.

   Result  -
Return Value:

   NT status code

--*/
{
    NTSTATUS  status;
    PFDO_DATA fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    DebugEnter();
    
    if (Direction == IRP_ALREADY_FORWARDED || (!NT_SUCCESS(Result))) {

        //
        // In either of these cases it is now time to complete the IRP.
        //
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = Result;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        ProcessorIoDecrement(fdoData);
        return Result;
    }

    //
    // Here we update our result. Note that ProcessorDefaultPowerHandler calls
    // PoStartNextPowerIrp for us.
    //
    Irp->IoStatus.Status = Result;
    status = ProcessorDefaultPowerHandler(DeviceObject, Irp);
    ProcessorIoDecrement(fdoData);
    return status;
}


NTSTATUS
HoldIoRequests(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  IRP_DIRECTION       Direction
    )
/*++

Routine Description:

    This routine sets queue state and queues an item to
    HoldIoRequestsWorkerRoutine.

Arguments:

Return Value:

   NT status code

--*/
{

    PIO_WORKITEM            item;
    PWORKER_THREAD_CONTEXT  context;
    NTSTATUS                status;
    PFDO_DATA               fdoData;

    DebugEnter();
        
    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    fdoData->QueueState = HoldRequests;

    //
    // We must wait for the pending I/Os to finish
    // before powering down the device. But we can't wait
    // while handling a power IRP because it can deadlock
    // the system. So let us queue a worker callback
    // item to do the wait and complete the irp.
    //
    context = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(WORKER_THREAD_CONTEXT),
                                    PROCESSOR_POOL_TAG);
    if(context)
    {
        item = IoAllocateWorkItem(DeviceObject);
        context->Irp = Irp;
        context->DeviceObject= DeviceObject;
        context->IrpDirection = Direction;
        context->WorkItem = item;
        if (item) {

            IoMarkIrpPending(Irp);
            IoQueueWorkItem (item,
                             HoldIoRequestsWorkerRoutine,
                             DelayedWorkQueue,
                             context);
            status = STATUS_PENDING;
        }
        else
        {
            ExFreePool(context);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
        status = STATUS_INSUFFICIENT_RESOURCES;

    return status;
}


VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

 Routine Description:
 
     This routine waits for the I/O in progress to finish and
     power downs the device.
 
 Arguments:
 
 Return Value:


--*/
{
    PFDO_DATA               fdoData;
    PWORKER_THREAD_CONTEXT  context = (PWORKER_THREAD_CONTEXT)Context;

    DebugEnter();
        
    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    DebugPrint((TRACE, "Waiting for pending requests to complete\n"));

    //
    // Wait for the I/O in progress to be finish.
    // The Stop event gets set when the counter drops
    // to Zero. Since our power handler routines incremented
    // the counter twice - once for the S-IRP and once for the
    // D-IRP - we must call the decrement function twice.
    //

    ProcessorIoDecrement(fdoData); // one
    ProcessorIoDecrement(fdoData);

    KeWaitForSingleObject(
               &fdoData->StopEvent,
               Executive,   // Waiting for reason of a driver
               KernelMode,  // Waiting in kernel mode
               FALSE,       // No allert
               NULL);       // No timeout

    //
    // Increment the counter back to take into account the S-IRP and D-IRP
    // currently in progress.
    //

    ProcessorIoIncrement (fdoData);
    ProcessorIoIncrement (fdoData);

    FinishDevicePowerIrp(
                    context->DeviceObject,
                    context->Irp,
                    context->IrpDirection,
                    STATUS_SUCCESS
                    );

    //
    // Cleanup before exiting from the worker thread.
    //
    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

}

VOID
ProcessorPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG_PTR   action = (ULONG_PTR)Argument1;
    ULONG_PTR   state  = (ULONG_PTR)Argument2;

    DebugEnter();
    DisplayPowerStateInfo(action, state);
    
    if (action == PO_CB_SYSTEM_STATE_LOCK) {
        
        switch (state) {
          case 0:
  
              //
              // Lock down everything in the PAGELK code section.
              //
  
              ProcessorSleepPageLock = MmLockPagableCodeSection((PVOID)ProcessorDispatchPower);
              break;
  
          case 1:                 
  
              //
              // unlock it all
              //
              
              MmUnlockPagableImageSection(ProcessorSleepPageLock);
              break;
  
          default:
  
              DebugPrint((TRACE, "Unknown callback operation.\n"));
          }

    } else if (action == PO_CB_AC_STATUS) {

      //
      // AC <-> DC Transition has occurred, call Notify routine.
      // State == TRUE if on AC, else FALSE.
      //

      // toddcar - 02/14/01 - ISSUE:
      // should we call this sync or async?
      //
      if (AcDcTransitionNotifyHandler.Handler) {
        AcDcTransitionNotifyHandler.Handler(AcDcTransitionNotifyHandler.Context,
                                            (BOOLEAN) state);
      }
      
    }

    return;
}


NTSTATUS
RegisterAcDcTransitionNotifyHandler (
  IN PAC_DC_NOTIFY_HANDLER NewHandler,  
  IN PVOID                 Context
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{

  //
  // Notify handler can only be registered once.
  //
  
  if (AcDcTransitionNotifyHandler.Handler && NewHandler) {
    return STATUS_INVALID_PARAMETER;
  }
  
  
  //
  // Set new handler
  //
  
  AcDcTransitionNotifyHandler.Handler = NewHandler;
  AcDcTransitionNotifyHandler.Context = Context;
  
  return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\processor.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation All Rights Reserved

Module Name:

    processor.c

Abstract:

    Device driver to control the processor device.


Environment:

    Kernel mode


Revision History:

    Eliyas Yakub    Oct 6, 1998
    Jake Oshins     March 5, 2000
        Stole Eliyas' toaster code and made a processor
        driver out of it.

--*/
#include "processor.h"
#include <initguid.h>

GLOBALS  Globals;
FADT HalpFixedAcpiDescTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, ProcessorAddDevice)
#pragma alloc_text (PAGE, ProcessorDispatchPnp)
#pragma alloc_text (PAGE, ProcessorReadWrite)
#pragma alloc_text (PAGE, ProcessorCreateClose)
#pragma alloc_text (PAGE, ProcessorDispatchIoctl)
#pragma alloc_text (PAGE, ProcessorStartDevice)
#pragma alloc_text (PAGE, ProcessorUnload)
#pragma alloc_text (PAGE, ProcessorCanRemoveDevice)
#pragma alloc_text (PAGE, ProcessorReturnResources)
#pragma alloc_text (PAGE, ProcessorSendIrpSynchronously)
#pragma alloc_text (PAGE, RegisterStateHandlers)
#endif

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

  Routine Description:

      Installable driver initialization entry point.
      This entry point is called directly by the I/O system.

  Arguments:

      DriverObject - pointer to the driver object

      RegistryPath - pointer to a unicode string representing the path,
                     to driver-specific key in the registry.

  Return Value:

      STATUS_SUCCESS if successful,
      STATUS_UNSUCCESSFUL otherwise.

--*/
{
  NTSTATUS          status = STATUS_SUCCESS;
  OBJECT_ATTRIBUTES objAttributes;
  UNICODE_STRING    callbackName;
  PCALLBACK_OBJECT  callback;
  FADT          *fadt;

#if MAX_DEBUG
  TurnOnFullDebugSpew();
#endif

  DebugPrint((INFO, "Built: %s %s\n", __DATE__, __TIME__));
  DebugEnter();


  //
  // Get Global Processor Flags
  //

  GetRegistryDwordValue(PROCESSOR_PARAMETERS_REG_PATH,
                        PROCESSOR_GLOBAL_FLAGS_REG_KEY,
                        &Globals.HackFlags);


  //
  // Save the RegistryPath.
  //

  Globals.DriverObject = DriverObject;
  Globals.RegistryPath.MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
  Globals.RegistryPath.Length = RegistryPath->Length;
  Globals.RegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool,
                                           Globals.RegistryPath.MaximumLength,
                                           PROCESSOR_POOL_TAG);

  if (!Globals.RegistryPath.Buffer) {
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  RtlCopyUnicodeString(&Globals.RegistryPath, RegistryPath);

  DriverObject->MajorFunction[IRP_MJ_PNP]             = ProcessorDispatchPnp;
  DriverObject->MajorFunction[IRP_MJ_POWER]           = ProcessorDispatchPower;
  DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = ProcessorDispatchIoctl;
  DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = ProcessorSystemControl;
  DriverObject->DriverExtension->AddDevice            = ProcessorAddDevice;
  DriverObject->DriverUnload                          = ProcessorUnload;


  //
  // Register callback that tells us to make
  // anything we need for sleeping non-pageable.
  //

  RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

  InitializeObjectAttributes(&objAttributes,
                             &callbackName,
                             OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                             NULL,
                             NULL);

  ExCreateCallback(&callback,
                   &objAttributes,
                   FALSE,
                   TRUE);

  Globals.CallbackRegistration = ExRegisterCallback(callback,
                                                    ProcessorPowerStateCallback,
                                                    NULL);


  //
  // copy fadt
  //

  fadt = (FADT*) GetAcpiTable(FADT_SIGNATURE);

  if (fadt) {

    RtlCopyMemory(&HalpFixedAcpiDescTable, fadt, fadt->Header.Length);
    ExFreePool(fadt);

  } else {

    DebugAssert(!"GetAcpiTable(FACP) Failed!");

  }


  //
  // Parse MAPIC tables, store processor information in Globals
  //

  status = ProcessMultipleApicDescTable(&Globals.ProcInfo);

  if (!NT_SUCCESS(status)) {

    //
    // no MAPIC table, then we are a single proc machine.
    //

    Globals.ProcInfo.ActiveProcessors = 1;
    Globals.ProcInfo.TotalProcessors  = 1;

  }


  if (Globals.ProcInfo.ActiveProcessors == 1) {
    Globals.SingleProcessorProfile = TRUE;
  }


  //
  // Call family specific driver
  //

  InitializeDriver(&Globals.RegistryPath);

  return STATUS_SUCCESS;
}
NTSTATUS
ProcessorAddDevice (
  IN PDRIVER_OBJECT DriverObject,
  IN PDEVICE_OBJECT PhysicalDeviceObject
  )
/*++

  Routine Description:

      The Plug & Play subsystem is handing us a brand new PDO, for which we
      (by means of INF registration) have been asked to provide a driver.

      We need to determine if we need to be in the driver stack for the device.
      Create a function device object to attach to the stack
      Initialize that device object
      Return status success.

      Remember: We can NOT actually send ANY non-pnp IRPS to the given driver
      stack, UNTIL we have received an IRP_MN_START_DEVICE.

  Arguments:

      DeviceObject - pointer to a device object.

      PhysicalDeviceObject -  pointer to a device object created by the
                              underlying bus driver.

  Return Value:

      NT status code.

--*/
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PFDO_DATA               fdoData;
    POWER_STATE             powerState;

    DebugEnter();
    PAGED_CODE();

    //
    // Create a function device object.
    //

    status = IoCreateDevice(DriverObject,
                            sizeof(FDO_DATA),
                            NULL,  // No Name
                            FILE_DEVICE_UNKNOWN,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &deviceObject);


    if (!NT_SUCCESS (status)) {

        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //

        goto ProcessorAddDeviceExit;
    }

    RtlZeroMemory(deviceObject->DeviceExtension, sizeof(FDO_DATA));
    DebugPrint((TRACE, "  pdo=0x%x, new fdo=0x%x\n",
                PhysicalDeviceObject,
                deviceObject));

    //
    // Initialize the device extension.
    //

    fdoData = (PFDO_DATA) deviceObject->DeviceExtension;

    //
    // Set the initial state of the FDO
    //

    INITIALIZE_PNP_STATE(fdoData);

    fdoData->UnderlyingPDO = PhysicalDeviceObject;

    //
    // We will hold all requests until we are started.
    // On W2K we will not get any I/O until the entire device
    // is started. On Win9x this may be required.
    //

    fdoData->QueueState = HoldRequests;

    fdoData->Self = deviceObject;
    fdoData->NextLowerDriver = NULL;

    InitializeListHead(&fdoData->NewRequestsQueue);
    KeInitializeSpinLock(&fdoData->QueueLock);

    //
    // Initialize the remove event to Not-Signaled
    //

    KeInitializeEvent(&fdoData->RemoveEvent, SynchronizationEvent, FALSE);

    //
    // Initialize the stop event to Signaled:
    // there are no Irps that prevent the device from being
    // stopped. This event will be set when the OutstandingIO
    // will become 1.
    //

    KeInitializeEvent(&fdoData->StopEvent, SynchronizationEvent, TRUE);

    fdoData->OutstandingIO = 1; // biased to 1.  Transition to zero during
                                // remove device means IO is finished.
                                // Transition to 1 means the device can be
                                // stopped.

    //
    // Initialize the structures that protect the performance states.
    //

    KeInitializeEvent(&fdoData->PerfStateLock, SynchronizationEvent, TRUE);

    deviceObject->Flags |= DO_POWER_PAGABLE;
    deviceObject->Flags |= DO_BUFFERED_IO;


    //
    // Typically, the function driver for a device is its
    // power policy owner, although for some devices another
    // driver or system component may assume this role.
    // Set the initial power state of the device, if known, by calling
    // PoSetPowerState.
    //

    fdoData->DevicePowerState = PowerDeviceD0;
    fdoData->SystemPowerState = PowerSystemWorking;

    powerState.DeviceState = PowerDeviceD0;
    PoSetPowerState ( deviceObject, DevicePowerState, powerState );


    //
    // Attach our driver to the device stack.
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //

    fdoData->NextLowerDriver = IoAttachDeviceToDeviceStack(deviceObject,
                                                           PhysicalDeviceObject);
    if (!fdoData->NextLowerDriver) {

        IoDeleteDevice(deviceObject);
        status = STATUS_NO_SUCH_DEVICE;
        goto ProcessorAddDeviceExit;
    }

    //
    // Pick up ACPI interfaces.
    //

    status = AcquireAcpiInterfaces(fdoData);

    if (!NT_SUCCESS (status)) {
      DebugPrint((ERROR, "AddDevice: AcquireAcpiInterfaces failed (%x)\n", status));
      IoDetachDevice(fdoData->NextLowerDriver);
      IoDeleteDevice (deviceObject);
      goto ProcessorAddDeviceExit;
    }


    //
    // Initialize our saved state.
    //

    fdoData->SavedState = (ULONG)-1;


    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags.
    //

    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

ProcessorAddDeviceExit:

    DebugExitStatus(status);
    return status;
}
NTSTATUS
ProcessorDispatchPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

  Routine Description:

      The plug and play dispatch routines.

      Most of these requests the driver will completely ignore.
      In all cases it must pass on the IRP to the lower driver.

  Arguments:

     DeviceObject - pointer to a device object.

     Irp - pointer to an I/O Request Packet.

  Return Value:

        NT status code

--*/
{
    PFDO_DATA               fdoData;
    PIO_STACK_LOCATION      stack;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   requestCount;
    PPNP_DEVICE_STATE       deviceState;


    DebugEnter();
    PAGED_CODE();

    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    stack = IoGetCurrentIrpStackLocation (Irp);

    DebugPrint((TRACE, "FDO %s\n",
                PnPMinorFunctionString(stack->MinorFunction)));

    if (Deleted == fdoData->DevicePnPState) {

        //
        // Since the device is removed, we will not hold any IRPs.
        // We just fail it.
        //
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ProcessorIoIncrement (fdoData);
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        // First pass the IRP down.
        //

        status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver, Irp);
        if (NT_SUCCESS (status)) {
            //
            // Lower drivers have finished their start operation, so now
            // we can finish ours.
            //
            status = ProcessorStartDevice (fdoData, Irp);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completion routine with MORE_PROCESSING_REQUIRED.
        //
        break;


    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // Processors cannot be stopped.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

   case IRP_MN_CANCEL_STOP_DEVICE:

        //
        // Send this IRP down and wait for it to come back.
        // Set the QueueState flag to AllowRequests,
        // and process all the previously queued up IRPs.
        //

        //
        // First check to see whether you have received cancel-stop
        // without first receiving a query-stop. This could happen if someone
        // above us fails a query-stop and passes down the subsequent
        // cancel-stop.
        //

        status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver,Irp);
        if(NT_SUCCESS(status)) {

            if(StopPending == fdoData->DevicePnPState) {

                fdoData->QueueState = AllowRequests;

                RESTORE_PREVIOUS_PNP_STATE(fdoData);

                ASSERT(fdoData->DevicePnPState == Started);
                //
                // Process the queued requests
                //

                ProcessorProcessQueuedRequests(fdoData);
            }
        }

        break;

    case IRP_MN_STOP_DEVICE:

        //
        // We should never get here.
        //

        ASSERTMSG("Processors don't stop. Fatal error!", FALSE);
        return STATUS_INVALID_DEVICE_REQUEST;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // If we can allow removal of the device, we should set the QueueState
        // to HoldRequests so further requests will be queued. This is required
        // so that we can process queued up requests in cancel-remove just in
        // case somebody else in the stack fails the query-remove.
        //

        status = ProcessorCanRemoveDevice(DeviceObject, Irp);

        if (NT_SUCCESS(status)) {

            //
            // Now prepare to hold the new ones (eventually we might
            // get a IRP_MN_CANCEL_REMOVE_DEVICE) and we need to
            // process the queued requests then.
            //

            fdoData->QueueState = HoldRequests;

            SET_NEW_PNP_STATE(fdoData, RemovePending);

            DebugPrint((TRACE, "Query - remove holding requests...\n"));

            ProcessorIoDecrement(fdoData);

            //
            // Wait for all the requests to be completed
            //

            KeWaitForSingleObject(
                &fdoData->StopEvent,
                Executive, // Waiting for reason of a driver
                KernelMode, // Waiting in kernel mode
                FALSE, // No alert
                NULL); // No timeout


            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation (Irp);

            status = IoCallDriver (fdoData->NextLowerDriver, Irp);
            return status;
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        //
        // We need to reset the QueueState flag to ProcessRequest,
        // since the device resume its normal activities.
        //

        //
        // First check to see whether you have received cancel-remove
        // without first receiving a query-remove. This could happen if
        // someone above us fails a query-remove and passes down the
        // subsequent cancel-remove.
        //

        if(RemovePending == fdoData->DevicePnPState)
        {

            status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver,Irp);

            if(NT_SUCCESS(status))
            {
                fdoData->QueueState = AllowRequests;

                RESTORE_PREVIOUS_PNP_STATE(fdoData);

                //
                // Process the queued requests that arrived between
                // QUERY_REMOVE and CANCEL_REMOVE.
                //

                ProcessorProcessQueuedRequests(fdoData);
            } else {
                //
                // Nobody can fail this IRP. This is a fatal error.
                //
                ASSERTMSG("Cancel remove failed. Fatal error!", FALSE);
                DebugPrint((TRACE, "Failure status = 0x%x\n", status));
            }
        }
        else {
            status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver,Irp);
        }

        break;

   case IRP_MN_SURPRISE_REMOVAL:
   {
       PVOID parameterArray[4] = {0};
       UCHAR buffer[] = "Processor driver does not support IRP_MN_SURPRISE_REMOVAL\n";
     
       //
       // Processors cannot be gracefully yanked from a running
       // system.
       //

       KeBugCheckEx(FATAL_UNHANDLED_HARD_ERROR,
                    0x10000,
                    (ULONG_PTR) parameterArray,
                    (ULONG_PTR) buffer,
                    (ULONG_PTR) NULL);
        
       return STATUS_INVALID_DEVICE_REQUEST;
    }
            

   case IRP_MN_REMOVE_DEVICE:

       //
       // For now, we can't remove processors.
       //

       status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver,Irp);
       if (!NT_SUCCESS(status)) {
           status = STATUS_INVALID_DEVICE_REQUEST;
       }
       break;

#if 0
        //
        // The Plug & Play system has dictated the removal of this device.  We
        // have no choice but to detach and delete the device object.
        // (If we wanted to express an interest in preventing this removal,
        // we should have failed the query remove IRP).
        //


        if(SurpriseRemovePending != fdoData->DevicePnPState)
        {
            //
            // This means we are here after query-remove.
            // So first stop the device, disable the interface,
            // return resources, and fail all the pending request,.
            //

            fdoData->QueueState = FailRequests;

            //
            // Fail all the pending request. Since the QueueState is FailRequests
            // ProcessorProcessQueuedRequests will simply flush the queue,
            // completing each IRP with STATUS_DELETE_PENDING
            //

            ProcessorProcessQueuedRequests(fdoData);

       //   //
       //   // Disable the Interface
       //   //
       //
       //   status = IoSetDeviceInterfaceState(&fdoData->InterfaceName, FALSE);
       //
       //   if (!NT_SUCCESS (status)) {
       //       DebugPrint((0,
       //               "IoSetDeviceInterfaceState failed: 0x%x\n", status));
       //   }

            //
            // Return hardware resources.
            //

            ProcessorReturnResources(DeviceObject);

        }

        SET_NEW_PNP_STATE(fdoData, Deleted);

        //
        // Drop ACPI interfaces.
        //

        status = ReleaseAcpiInterfaces(fdoData);
        ASSERT(NT_SUCCESS(status));

#if 0
        //
        // Inform WMI to remove this DeviceObject from its
        // list of providers.
        //

        ProcessorWmiDeRegistration(fdoData);
#endif

        //
        // We need two decrements here, one for the increment in
        // ProcessorPnpDispatch, the other for the 1-biased value of
        // OutstandingIO. Also, we need to wait that all the requests
        // are served.
        //

        requestCount = ProcessorIoDecrement (fdoData);

        //
        // The requestCount is a least one here (is 1-biased)
        //
        ASSERT(requestCount > 0);

        requestCount = ProcessorIoDecrement (fdoData);

        KeWaitForSingleObject (
                &fdoData->RemoveEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);


        //
        // Send on the remove IRP.
        // We need to send the remove down the stack before we detach,
        // but we don't need to wait for the completion of this operation
        // (and to register a completion routine).
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (fdoData->NextLowerDriver, Irp);

        //
        // Detach the FDO from the device stack
        //
        IoDetachDevice (fdoData->NextLowerDriver);

    /// //
    /// // Free up interface memory
    /// //
    ///
    /// RtlFreeUnicodeString(&fdoData->InterfaceName);
        IoDeleteDevice (fdoData->Self);

        return status;
#endif

    case IRP_MN_QUERY_CAPABILITIES:

        status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver, Irp);
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        //
        // Pass the IRP down because the modification to the Irp is done
        // on the way up.
        //

        status = ProcessorSendIrpSynchronously(fdoData->NextLowerDriver, Irp);
        break;

    default:
    
        //
        // Pass down all the unhandled Irps.
        //

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (fdoData->NextLowerDriver, Irp);
        ProcessorIoDecrement(fdoData);

        return status;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    ProcessorIoDecrement(fdoData);

    return status;
}
NTSTATUS
ProcessorDispatchPnpComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

  Routine Description:
      The lower-level drivers completed the pnp IRP.
      Signal this to whoever registered us.

  Arguments:

     DeviceObject - pointer to a device object.

     Irp - pointer to an I/O Request Packet.

     Context - pointer to the event to be signaled.
  Return Value:

      NT status code


--*/
{

    PKEVENT event = (PKEVENT) Context;
     
    DebugEnter();
    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Wait for lower drivers to be done with the Irp.
    // Important thing to note here is when you allocate
    // the memory for an event in the stack you must do a
    // KernelMode wait instead of UserMode to prevent
    // the stack from getting paged out.
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    //
    // Take the IRP back so that we can continue using it during
    // the dispatch routine.
    // NB: The dispatch routine will have to call IoCompleteRequest
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}
NTSTATUS
ProcessorReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

  Routine Description:

      Performs read/write to the Processor device.

  Arguments:

     DeviceObject - pointer to a device object.

     Irp - pointer to an I/O Request Packet.

  Return Value:

      NT status code


--*/

{
    PFDO_DATA    fdoData;
    NTSTATUS     status = STATUS_SUCCESS;

    DebugEnter();
    PAGED_CODE();

    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    if (HoldRequests == fdoData->QueueState) {

        status = ProcessorQueueRequest(fdoData, Irp);
        return status;
    }

    ProcessorIoIncrement (fdoData);

    //
    // Perform read/write operation here
    //

    Irp->IoStatus.Information = 0; // fill in the correct length
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    ProcessorIoDecrement(fdoData);

    return STATUS_SUCCESS;

}
NTSTATUS
ProcessorCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

  Routine Description:

     Dispatch routine to handle Create/Close on the
     Processor device.

  Arguments:

     DeviceObject - pointer to a device object.

     Irp - pointer to an I/O Request Packet.

  Return Value:

     NT status code

--*/
{
    PFDO_DATA    fdoData;
    NTSTATUS     status;
    PIO_STACK_LOCATION  irpStack;

    DebugEnter();
    PAGED_CODE();

    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    //
    // Since we don't access the hardware to process
    // these two requests, we don't have to worry about
    // about the current device state and whether or not
    // to queue this request.
    //

    ProcessorIoIncrement (fdoData);

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:

        DebugPrint((TRACE, "Create \n"));
        break;

    case IRP_MJ_CLOSE:
        DebugPrint((TRACE, "Close \n"));
        break;

    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    ProcessorIoDecrement(fdoData);


    return status;
}
NTSTATUS
ProcessorDispatchIoctl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

  Routine Description:

      Handle user mode DeviceIoControl requests.

  Arguments:

     DeviceObject - pointer to a device object.

     Irp - pointer to an I/O Request Packet.

  Return Value:

     NT status code

--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status= STATUS_SUCCESS;
    PFDO_DATA               fdoData;

    DebugEnter();
    PAGED_CODE();

    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;

    if (HoldRequests == fdoData->QueueState) {

        status = ProcessorQueueRequest(fdoData, Irp);
        return status;
    }

    ProcessorIoIncrement (fdoData);

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    ProcessorIoDecrement(fdoData);
    return status;
}



NTSTATUS
ProcessorStartDevice (
    IN PFDO_DATA  FdoData,
    IN PIRP       Irp
    )
/*++

  Routine Description:

      Performs whatever initialization is needed to setup the
      device, namely connecting to an interrupt,
      setting up a DMA channel or mapping any I/O port resources.

  Arguments:

     Irp - pointer to an I/O Request Packet.

     FdoData - pointer to a FDO_DATA structure

  Return Value:

      NT status code


--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PPROCESSOR_OBJECT_INFO objInfo;

    DebugEnter();
    PAGED_CODE();

    FdoData->PerfStates = NULL;
    
    //
    // Set Processor Device's Friendly Name
    //

    SetProcessorFriendlyName(FdoData);


    //
    // Query the ACPI driver to get the info from the ACPI
    // processor object.
    //

    status = AcpiEvaluateProcessorObject(FdoData, &objInfo);

    if (!NT_SUCCESS(status)) {
        DebugPrint((TRACE, "Failed to get processor information from ACPI\n"));
        return status;
    }

    RtlCopyMemory(&FdoData->ProcObjInfo, objInfo, sizeof(PROCESSOR_OBJECT_INFO));
    ExFreePool(objInfo);

    AcquireProcessorPerfStateLock(FdoData);

    //
    // Build up a notion of available C-states by looking first for
    // ACPI 1.0 C-states and then for ACPI 2.0 C-states.
    //

#ifdef _X86_

    //
    // Acpi 1.0 CStates
    //
    
    status = InitializeAcpi1Cstates(FdoData);

    if (!NT_SUCCESS(status) &&
        !((status == STATUS_NOT_FOUND) ||
          (status == STATUS_OBJECT_NAME_NOT_FOUND))) {
        DebugPrint((WARN, "Failed to initialize ACPI 1.0 C-states\n"));
        return status;
    }

    //
    // Acpi 1.0 TStates
    //
    
    status = InitializeAcpi1TStates(FdoData);

    if (!NT_SUCCESS(status)) {
      DebugPrint((WARN, "Failed to initialize ACPI 1.0 T-states\n"));
      return status;
    }


    //
    // Acpi 2.0 CStates
    //
    
    status = InitializeAcpi2Cstates(FdoData);

    if (NT_SUCCESS(status)) {

      //
      // Notify the BIOS that we are taking control
      //

      AssumeCStateControl();

    } else if ((status != STATUS_NOT_FOUND) && 
               (status != STATUS_OBJECT_NAME_NOT_FOUND)) {

      DebugPrint((INFO, "Failed to initialize ACPI 2.0 C-states\n"));
      return status;
    
    }

    //
    // Acpi 2.0 PStates/TStates or Legacy PStates/TStates
    //

    status = InitializeAcpi2PStates(FdoData);

    if (status == STATUS_NOT_SUPPORTED) {

      //
      // We found an Acpi 2.0 interface, but it wasn't one we supported,
      // ie Function Fixed Hardware.  We need to re-init our Acpi 1.0 
      // throttle states.
      //
    
      status = InitializeAcpi1TStates(FdoData);

      if (!NT_SUCCESS(status)) {
        DebugPrint((WARN, "Failed to initialize ACPI 1.0 T-states\n"));
        return status;
      } 

    }

    if (!NT_SUCCESS(status)) {
      status = InitializeNonAcpiPerformanceStates(FdoData);
    }


    if (!NT_SUCCESS(status)) {
      DebugPrint((WARN, "This processor doesn't support voltage transitions\n"));
      status = STATUS_SUCCESS;
    }

    //
    // if we found Perf States, then register with WMI
    //

    if (FdoData->PerfStates) {

      //
      // Register with WMI.
      //

      status = ProcessorWmiRegistration(FdoData);

      if (!NT_SUCCESS(status)) {
        DebugPrint((ERROR, "IoWMIRegistrationControl() failed! rc=0x%x\n", status));
      }
    }


    status = RegisterStateHandlers(FdoData);

    if (!NT_SUCCESS(status)) {
        DebugPrint((ERROR, "Failed to register C-states\n"));
        return status;
    }
#endif

    ReleaseProcessorPerfStateLock(FdoData);

    //
    // Set PnP state flag
    //

    SET_NEW_PNP_STATE(FdoData, Started);

    //
    // Mark the device as active and not holding IRPs
    //

    FdoData->QueueState = AllowRequests;

    //
    // The last thing to do is to process the pending IRPs.
    //

    ProcessorProcessQueuedRequests(FdoData);

    return status;
}
NTSTATUS
ProcessorCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

  Routine Description:

      The dispatch routine for cleanup: we need to walk the Irp queue and
      to cancel all the requests for which the file object is the same with
      the one in the Irp.


  Arguments:

     DeviceObject - pointer to a device object.

     Irp - pointer to an I/O Request Packet.

  Return Value:

     NT status code

--*/
{
    PFDO_DATA              fdoData;
    KIRQL                  oldIrql;
    LIST_ENTRY             cleanupList;
    PLIST_ENTRY            thisEntry, nextEntry, listHead;
    PIRP                   pendingIrp;
    PIO_STACK_LOCATION     pendingIrpStack, irpStack;


    DebugEnter();

    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    ProcessorIoIncrement (fdoData);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    InitializeListHead(&cleanupList);

    //
    // We must acquire queue lock first.
    //

    KeAcquireSpinLock(&fdoData->QueueLock, &oldIrql);

    //
    // Walk through the list and remove all the IRPs
    // that belong to the input irp's fileobject.
    //

    listHead = &fdoData->NewRequestsQueue;
    for(thisEntry = listHead->Flink,nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry,nextEntry = thisEntry->Flink)
    {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP,
                                Tail.Overlay.ListEntry);
        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if (irpStack->FileObject == pendingIrpStack->FileObject)
        {
            RemoveEntryList(thisEntry);

            //
            // Set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine (pendingIrp, NULL))
            {
                //
                // The cancel routine has run but it must be waiting to hold
                // the queue lock. It will cancel the IRP as soon as we
                // drop the lock outside this loop. We will initialize
                // the IRP's listEntry so that the cancel routine wouldn't barf
                // when it tries to remove the IRP from the queue, and
                // leave the this IRP alone.
                //
                InitializeListHead(thisEntry);
            } else {
                //
                // Cancel routine is not called and will never be
                // called. So we queue the IRP in the cleanupList
                // and cancel it after dropping the lock
                //
                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock.
    //

    KeReleaseSpinLock(&fdoData->QueueLock, oldIrql);

    //
    // Walk through the cleanup list and cancel all
    // the Irps.
    //

    while(!IsListEmpty(&cleanupList))
    {
        //
        // Complete the IRP
        //

        thisEntry = RemoveHeadList(&cleanupList);
        pendingIrp = CONTAINING_RECORD(thisEntry, IRP,
                                Tail.Overlay.ListEntry);
        //
        // You must clear the cancel routine before completing the IRP.
        //

        IoSetCancelRoutine (pendingIrp, NULL);
        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    ProcessorIoDecrement (fdoData);
    return STATUS_SUCCESS;
}

VOID
ProcessorUnload (
    IN PDRIVER_OBJECT DriverObject
    )
/*++

  Routine Description:

      Free all the resources allocated in DriverEntry.

  Arguments:

      DriverObject - pointer to a driver object.

  Return Value:

      VOID.

--*/
{
    DebugEnter();
    PAGED_CODE();

    // toddcar - 1/21/2001 - ISSUE
    // need to finish support of unloading processor driver, also
    // need to implement mechanism to call family specific driver
    // code to allow them to free their resources
    //

    //
    // The device object(s) should be NULL now
    // (since we unload, all the devices objects associated with this
    // driver must be deleted.
    //

    DebugAssert(DriverObject->DeviceObject == NULL);

    //
    // We should not be unloaded until all the devices we control
    // have been removed from our queue.
    //

    if (Globals.RegistryPath.Buffer) {
      ExFreePool(Globals.RegistryPath.Buffer);
    }

    DebugAssert(Globals.CallbackRegistration);
    ExUnregisterCallback(Globals.CallbackRegistration);

    return;
}

NTSTATUS
ProcessorQueueRequest (
    IN OUT PFDO_DATA FdoData,
    IN PIRP Irp
    )
/*++

  Routine Description:

      Queues the Irp in the device queue. This routine will be called whenever
      the device receives IRP_MN_QUERY_STOP_DEVICE or IRP_MN_QUERY_REMOVE_DEVICE

  Arguments:

      FdoData - pointer to the device's extension.

      Irp - the request to be queued.

  Return Value:

      NT status code.

--*/
{

    KIRQL    oldIrql;
    NTSTATUS status = STATUS_PENDING;

    DebugEnter();

    //
    // Check whether we are allowed to queue requests.
    //

    ASSERT(HoldRequests == FdoData->QueueState);

    KeAcquireSpinLock(&FdoData->QueueLock, &oldIrql);

    InsertTailList(&FdoData->NewRequestsQueue,
                        &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine (Irp, ProcessorCancelQueued);

    KeReleaseSpinLock(&FdoData->QueueLock, oldIrql);

    return status;
}

VOID
ProcessorProcessQueuedRequests (
    IN OUT PFDO_DATA FdoData
    )
/*++

  Routine Description:

      Removes and processes the entries in the queue. If this routine is called
      when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
      or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
      If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
      are completed with STATUS_DELETE_PENDING.


  Arguments:

      FdoData - pointer to the device's extension (where is the held IRPs queue).


  Return Value:

      VOID.

--*/
{

    KIRQL               oldIrql;
    PIRP                nextIrp, cancelledIrp;
    PLIST_ENTRY         listEntry;
    LIST_ENTRY          cancelledIrpList;

    DebugEnter();

    InitializeListHead(&cancelledIrpList);

    //
    // We need to dequeue all the entries in the queue, reset the cancel
    // routine for each of them and then process then:
    // - if the device is active, we will send them down
    // - else we will complete them with STATUS_DELETE_PENDING
    //

    for(;;)
    {
        //
        // Acquire the queue lock before manipulating the list entries.
        //
        KeAcquireSpinLock(&FdoData->QueueLock, &oldIrql);

        if(IsListEmpty(&FdoData->NewRequestsQueue))
        {
            KeReleaseSpinLock(&FdoData->QueueLock, oldIrql);
            break;
        }

        //
        // Remove a request from the queue.
        //
        listEntry = RemoveHeadList(&FdoData->NewRequestsQueue);

        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // Check to see if it's cancelled.
        //
        if (nextIrp->Cancel)
        {
            if(IoSetCancelRoutine (nextIrp, NULL))
            {
                //
                // This IRP was just cancelled but the cancel routine
                // hasn't been called yet. So it's safe to cancel the IRP,
                // Let's queue the IRP in the cancelledIrp list and complete
                // them after releasing the lock. This is to ensure that
                // we don't call out of the driver while holding a lock.
                //

                InsertTailList(&cancelledIrpList, listEntry);
            } else {
                //
                // The cancel routine has run but it must be waiting to hold
                // the queue lock. It will cancel the IRP as soon as we
                // drop the lock. So initialize the IRPs
                // listEntry so that the cancel routine wouldn't barf
                // when it tries to remove the IRP from the queue.
                //
                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&FdoData->QueueLock, oldIrql);
        }
        else
        {
            IoSetCancelRoutine (nextIrp, NULL);

            //
            // Release the lock before we call out of the driver
            //

            KeReleaseSpinLock(&FdoData->QueueLock, oldIrql);

            if (FailRequests == FdoData->QueueState) {
                //
                // The device was removed, we need to fail the request
                //
                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest (nextIrp, IO_NO_INCREMENT);

            } else {
                //
                // Process the IRP. Depending on the type of the
                // IRP either we pass it down or complete it here.
                //
                ProcessorIoIncrement (FdoData);

                IoSkipCurrentIrpStackLocation (nextIrp);
                IoCallDriver (FdoData->NextLowerDriver, nextIrp);

                ProcessorIoDecrement(FdoData);
            }

        }
    }// end of loop

    //
    // Walk through the cancelledIrp list and cancel all
    // the Irps.
    //

    while(!IsListEmpty(&cancelledIrpList))
    {
        //
        // Complete the IRP
        //

        PLIST_ENTRY listItem = RemoveHeadList(&cancelledIrpList);
        cancelledIrp = CONTAINING_RECORD(listItem, IRP, Tail.Overlay.ListEntry);
        cancelledIrp->IoStatus.Information = 0;
        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    return;

}
VOID
ProcessorCancelQueued (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

  Routine Description:

      The cancel routine. It will remove the IRP from the queue
      and will complete it. The cancel spin lock is already acquired
      when this routine is called.

  Arguments:

      DeviceObject - pointer to the device object.

      Irp - pointer to the IRP to be cancelled.


  Return Value:

      VOID.

--*/
{
    PFDO_DATA fdoData = DeviceObject->DeviceExtension;
    KIRQL               oldIrql = Irp->CancelIrql;

    DebugEnter();

    //
    // Release the cancel spinlock
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql);

    //
    // Acquire the local spinlock
    //

    KeAcquireSpinLockAtDpcLevel(&fdoData->QueueLock);


    //
    // Remove the cancelled IRP from queue and
    // release the queue lock.
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&fdoData->QueueLock, oldIrql);

    //
    // Complete the request with STATUS_CANCELLED.
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return;

}

NTSTATUS
ProcessorCanRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

  Routine Description:

      This routine determines whether the device can be safely removed. In our
      particular case, we'll assume we can always remove the device.
      A device shouldn't be removed if, for example, it has open handles or
      removing the device could result in losing data (plus the reasons
      mentioned at ProcessorCanStopDevice). The PnP manager on Windows 2000 fails
      on its own any attempt to remove, if there any open handles to the device.
      However on Win9x, the driver must keep count of open handles and fail
      query_remove if there are any open handles.

  Arguments:

      DeviceObject - pointer to the device object.

      Irp - pointer to the current IRP.


  Return Value:

      STATUS_SUCCESS if the device can be safely removed, an appropriate
      NT Status if not.

--*/
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    DebugEnter();
    PAGED_CODE();

    //
    // As we implement hot-plug processors, this will have to change.
    //

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
ProcessorReturnResources (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

  Routine Description:

      This routine returns all the resources acquired during
      device startup.

  Arguments:

      DeviceObject - pointer to the device object.


  Return Value:

      STATUS_SUCCESS if the device can be safely removed, an appropriate
      NT Status if not.

--*/
{
    UNREFERENCED_PARAMETER(DeviceObject);

    DebugEnter();
    PAGED_CODE();

    //
    // Disconnect from the interrupt and unmap any I/O ports
    // that are mapped in StartDevice.
    //

    return STATUS_SUCCESS;
}
NTSTATUS
ProcessorSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

  Routine Description:

      Sends the Irp down the stack and waits for it to complete.

  Arguments:
      DeviceObject - pointer to the device object.

      Irp - pointer to the current IRP.

      NotImplementedIsValid -

  Return Value:

      NT status code

--*/
{
    KEVENT   event;
    NTSTATUS status;

    DebugEnter();
    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           ProcessorDispatchPnpComplete,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp.
    // Important thing to note here is when you allocate
    // memory for an event in the stack you must do a
    // KernelMode wait instead of UserMode to prevent
    // the stack from getting paged out.
    //
    //

    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    return status;
}
LONG
ProcessorIoIncrement (
    IN  OUT PFDO_DATA   FdoData
    )
/*++

  Routine Description:

      This routine increments the number of requests the device receives


  Arguments:

      DeviceObject - pointer to the device object.

  Return Value:

      The value of OutstandingIO field in the device extension.


--*/

{
    LONG  result;

    //DebugEnter();

    result = InterlockedIncrement(&FdoData->OutstandingIO);
    ASSERT(result > 0);

    //
    // Need to clear StopEvent (when OutstandingIO bumps from 1 to 2)
    //
    if (result == 2) {
        //
        // We need to clear the event
        //
        KeClearEvent(&FdoData->StopEvent);
    }

    return result;
}
LONG
ProcessorIoDecrement    (
    IN  OUT PFDO_DATA  FdoData
    )
/*++

  Routine Description:

      This routine decrements as it complete the request it receives

  Arguments:

      DeviceObject - pointer to the device object.

  Return Value:

      The value of OutstandingIO field in the device extension.


--*/
{
    LONG  result;

    //DebugEnter();

    result = InterlockedDecrement(&FdoData->OutstandingIO);
    ASSERT(result >= 0);

    if (result == 1) {
        //
        // Set the stop event. Note that when this happens
        // (i.e. a transition from 2 to 1), the type of requests we
        // want to be processed are already held instead of being
        // passed away, so that we can't "miss" a request that
        // will appear between the decrement and the moment when
        // the value is actually used.
        //

        KeSetEvent (&FdoData->StopEvent,
                    IO_NO_INCREMENT,
                    FALSE);

    }

    if (result == 0) {

        //
        // The count is 1-biased, so it can be zero only if an
        // extra decrement is done when a remove Irp is received
        //

        ASSERT(Deleted == FdoData->DevicePnPState);

        //
        // Set the remove event, so the device object can be deleted
        //

        KeSetEvent (&FdoData->RemoveEvent,
                    IO_NO_INCREMENT,
                    FALSE);

    }


    return result;
}

NTSTATUS
RegisterStateHandlers (
    IN PFDO_DATA DeviceExtension
    )
/*++

  Routine Description:

      This routine calls the kernel with C-states and P-states.

  Arguments:

      DeviceExtension

  Return Value:

      status

--*/
{
    PPROCESSOR_STATE_HANDLER2    procStates;
    NTSTATUS    status;
    ULONG       i, bufSize;

    DebugEnter();
    PAGED_CODE();

    bufSize = sizeof(PROCESSOR_STATE_HANDLER2) +
                  (sizeof(PROCESSOR_PERF_LEVEL) *
                   (DeviceExtension->PerfStates ?
                    (DeviceExtension->PerfStates->Count - 1) : 0));

    procStates = ExAllocatePoolWithTag(NonPagedPool,
                                       bufSize,
                                       PROCESSOR_POOL_TAG);

    if (!procStates) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(procStates, bufSize);

    procStates->NumIdleHandlers = DeviceExtension->CStates->Count;
    DebugAssert(procStates->NumIdleHandlers <= MAX_IDLE_HANDLERS);


    for (i = 0; i < procStates->NumIdleHandlers; i++) {

        procStates->IdleHandler[i].HardwareLatency = DeviceExtension->CStates->State[i].Latency;
        procStates->IdleHandler[i].Handler =  DeviceExtension->CStates->State[i].IdleHandler;
    }

#ifdef _X86_

    if (DeviceExtension->PerfStates) {

        procStates->SetPerfLevel = DeviceExtension->PerfStates->TransitionFunction;
        procStates->HardwareLatency = DeviceExtension->PerfStates->TransitionLatency;
        procStates->NumPerfStates = (UCHAR) DeviceExtension->PerfStates->Count;

        for (i = 0; i < procStates->NumPerfStates; i++) {

            procStates->PerfLevel[i].PercentFrequency = (UCHAR) DeviceExtension->PerfStates->State[i].PercentFrequency;
            procStates->PerfLevel[i].Flags = (USHORT) DeviceExtension->PerfStates->State[i].Flags;
        }
    }

#endif

    DumpProcessorStateHandler2Info(procStates);

    status = ZwPowerInformation(ProcessorStateHandler2,
                                procStates,
                                bufSize,
                                NULL,
                                0);

    ExFreePool(procStates);
    return status;
}
#if DBG
VOID
DumpProcessorPerfStates (
  PPROCESSOR_PERFORMANCE_STATES PerfStates
  )
{
  ULONG x;

  DebugPrint((TRACE, "Processor Performance States (0x%p)\n", PerfStates));
  DebugPrint((TRACE, "  TransitionFunction: 0x%p\n", PerfStates->TransitionFunction));
  DebugPrint((TRACE, "  Highest Latency:    %u us\n", PerfStates->TransitionLatency));
  DebugPrint((TRACE, "\n"));
  DebugPrint((TRACE, "  State\tFrequency\t\tPower Consumption\n"));
  DebugPrint((TRACE, "  -----\t---------\t\t-----------------\n"));
    
  for (x=0; x < PerfStates->Count; x++) {

    DebugPrint((TRACE, "  %u:\t\t%u mhz (%u%%)\t\tFlags: 0x%x\n",
                x,
                PerfStates->State[x].Frequency,
                PerfStates->State[x].PercentFrequency,
                PerfStates->State[x].Flags));
  }

  DebugPrint((TRACE, "\n"));

}
VOID
DumpProcessorStateHandler2Info (
  PPROCESSOR_STATE_HANDLER2 StateInfo
  )
{
  ULONG x;

  DebugPrint((TRACE, "Processor State Handler Info (0x%p)\n", StateInfo));
  DebugPrint((TRACE, "  NumIdleHandlers: %u\n", StateInfo->NumIdleHandlers));

  for (x=0; x < MAX_IDLE_HANDLERS; x++) {

    DebugPrint((TRACE, "    Idle Handler #%u\n", x));
    DebugPrint((TRACE, "    HardwareLatency: %u\n", StateInfo->IdleHandler[x].HardwareLatency));
    DebugPrint((TRACE, "    Handler:         0x%p\n", StateInfo->IdleHandler[x].Handler));

  }

  DebugPrint((TRACE, "  SetPerfLevel:     0x%p\n", StateInfo->SetPerfLevel));
  DebugPrint((TRACE, "  HardwareLatency:  %u\n", StateInfo->HardwareLatency));
  DebugPrint((TRACE, "  NumPerfStates:    %u\n", StateInfo->NumPerfStates));

  for (x=0; x < StateInfo->NumPerfStates; x++) {

    DebugPrint((TRACE, "    Perf State #%u:\n", x));
    DebugPrint((TRACE, "      PercentFrequency: %u\n", StateInfo->PerfLevel[x].PercentFrequency));
    DebugPrint((TRACE, "      Flags:            %u\n", StateInfo->PerfLevel[x].Flags));

  }

  DebugPrint((TRACE, "\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\processor.h ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation All Rights Reserved

Module Name:

    Processor.h

Abstract:

    Header file for the processor driver modules.

Environment:

    Kernel mode

Revision History:

    Eliyas Yakub Oct 6, 1998

--*/

#ifndef _PROCESSOR_H_
#define _PROCESSOR_H_

#include <stdarg.h>
#include <stdio.h>
#include <stddef.h>

#include <ntddk.h>
#include <wmilib.h>

#include <acpitabl.h>
#define _NTPOAPI_
#include <poclass.h>
#undef _NTPOAPI_

#include <ntpoapi.h>
#include "dbgsys.h"
#include "eventlog.h"
#include "wmi.h"


NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

//
// CStateFlags
//

#define CSTATE_FLAGS_REG_KEY           L"CStateFlags"
#define CSTATE_FLAG_DISABLE_C2         0x2
#define CSTATE_FLAG_DISABLE_C3         0x4
#define CSTATE_FLAG_WIN2K_COMPAT       0x8


//
// Definition of Global Flags
//

#define DISABLE_LEGACY_INTERFACE_FLAG   0x1
#define DISABLE_ACPI20_INTERFACE_FLAG   0x2
#define DISABLE_THROTTLE_STATES         0x4

#define PROCESSOR_GLOBAL_FLAGS_REG_KEY  L"HackFlags"
#define PROCESSOR_PARAMETERS_REG_PATH   L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Processor"

#define CPU0_REG_KEY   L"\\Registry\\Machine\\Hardware\\Description\\System\\CentralProcessor\\0"

#define PROCESSOR_POOL_TAG         (ULONG) 'rcrP'
#define MAX_SUPPORTED_PROCESSORS   (sizeof(KAFFINITY) * 8)

#define MIN(_a_,_b_) ((_a_) < (_b_) ? (_a_) : (_b_))
#define MAX(_a_,_b_) ((_a_) > (_b_) ? (_a_) : (_b_))

#define MAX_PROCESSOR_VALUE   256 // max uchar
#define INVALID_PERF_STATE    MAXULONG

typedef struct _PROCESSOR_INFO {

  ULONG ActiveProcessors;
  ULONG TotalProcessors;
  
  UCHAR ProcIdToApicId[MAX_PROCESSOR_VALUE]; 
  UCHAR ApicIdToDevExtIndex[MAX_PROCESSOR_VALUE];

} PROCESSOR_INFO, *PPROCESSOR_INFO;


typedef struct _GLOBALS {

    //
    // Path to the driver's Services Key in the registry
    //

    UNICODE_STRING  RegistryPath;
    PVOID           CallbackRegistration;
    BOOLEAN         SingleProcessorProfile;
    ULONG           HackFlags;
    ULONG           CStateFlags;
    PDRIVER_OBJECT  DriverObject;
    PROCESSOR_INFO  ProcInfo;
    PWCHAR          ProcessorBrandString;
    

} GLOBALS;

extern GLOBALS Globals;


//
// These are the states FDO transition to upon
// receiving a specific PnP Irp. Refer to the PnP Device States
// diagram in DDK documentation for better understanding.
//

typedef enum _DEVICE_PNP_STATE {

    NotStarted = 0,         // Not started yet
    Started,                // Device has received the START_DEVICE IRP
    StopPending,            // Device has received the QUERY_STOP IRP
    Stopped,                // Device has received the STOP_DEVICE IRP
    RemovePending,          // Device has received the QUERY_REMOVE IRP
    SurpriseRemovePending,  // Device has received the SURPRISE_REMOVE IRP
    Deleted                 // Device has received the REMOVE_DEVICE IRP

} DEVICE_PNP_STATE;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DevicePnPState =  NotStarted;\
        (_Data_)->PreviousPnPState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PreviousPnPState =  (_Data_)->DevicePnPState;\
        (_Data_)->DevicePnPState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DevicePnPState =   (_Data_)->PreviousPnPState;\

typedef enum _QUEUE_STATE {

    HoldRequests = 0,        // Device is not started yet, temporarily
                            // stopped for resource rebalancing, or
                            // entering a sleep state.
    AllowRequests,         // Device is ready to process pending requests
                            // and take in new requests.
    FailRequests             // Fail both existing and queued up requests.

} QUEUE_STATE;

#pragma pack (push, 1)
typedef struct {
    UCHAR   Type;
    USHORT  Length;
    UCHAR   AddressSpaceID;
    UCHAR   BitWidth;
    UCHAR   BitOffset;
    UCHAR   Reserved;
    PHYSICAL_ADDRESS    Address;
} ACPI_GENERIC_REGISTER_DESC, *PACPI_GENERIC_REGISTER_DESC;
#pragma pack (pop)

typedef struct {
    ULONG   Frequency;          // in megahertz
    ULONG   Flags;
    ULONG   PercentFrequency;   // for quick lookup
} PROCESSOR_PERFORMANCE_STATE, *PPROCESSOR_PERFORMANCE_STATE;

typedef struct {
    PSET_PROCESSOR_THROTTLE2    TransitionFunction;
    ULONG                       TransitionLatency;  // in microseconds
    ULONG                       Current;
    ULONG                       Count;
    PROCESSOR_PERFORMANCE_STATE State[1]; // sorted from fastest to slowest
} PROCESSOR_PERFORMANCE_STATES, *PPROCESSOR_PERFORMANCE_STATES;

typedef struct {
    GEN_ADDR    Register;
    UCHAR       StateType;
    USHORT      Latency;            // in microseconds
    ULONG       PowerConsumption;   // in milliwatts
} ACPI_CST_DESCRIPTOR, *PACPI_CST_DESCRIPTOR;

typedef struct {
    UCHAR       NumCStates;
    ACPI_CST_DESCRIPTOR    State[ANYSIZE_ARRAY];
} ACPI_CST_PACKAGE, *PACPI_CST_PACKAGE;

typedef struct {
    UCHAR       StateType;
    USHORT      Latency;        // in microseconds
    GEN_ADDR    Register;
    PPROCESSOR_IDLE_HANDLER IdleHandler;
} PROCESSOR_IDLE_STATE, *PPROCESSOR_IDLE_STATE;

typedef struct {
    UCHAR   Count;
    PROCESSOR_IDLE_STATE State[1];
} PROCESSOR_IDLE_STATES, *PPROCESSOR_IDLE_STATES;

typedef struct {
    GEN_ADDR  Control;
    GEN_ADDR  Status;
} ACPI_PCT_PACKAGE, *PACPI_PCT_PACKAGE;

typedef struct {
    ULONG   CoreFrequency;      // in megahertz
    ULONG   Power;              // in milliwatts
    ULONG   Latency;            // in microseconds
    ULONG   BmLatency;          // in microseconds - BUGBUG
    ULONG   Control;
    ULONG   Status;
} ACPI_PSS_DESCRIPTOR, *PACPI_PSS_DESCRIPTOR;

typedef struct {
    UCHAR   NumPStates;
    ACPI_PSS_DESCRIPTOR State[ANYSIZE_ARRAY];
} ACPI_PSS_PACKAGE, *PACPI_PSS_PACKAGE;

typedef struct _EVENT_LOG_CONTEXT {

  PIO_WORKITEM WorkItem;
  ULONG  EventErrorCode;
  ULONG  EventValue;
  ULONG  BufferSize;
  PUCHAR Buffer;
   
} EVENT_LOG_CONTEXT, *PEVENT_LOG_CONTEXT;


//
// The device extension for the device object
//

typedef struct _FDO_DATA
{
  PIO_WORKITEM WorkItem;
  PDEVICE_OBJECT      Self;            // back pointer to the DeviceObject.
  PDEVICE_OBJECT      UnderlyingPDO;   // The underlying PDO
  PDEVICE_OBJECT      NextLowerDriver; // top of the device stack (beneath this device object)
  DEVICE_PNP_STATE    DevicePnPState;  // Track the state of the device
  DEVICE_PNP_STATE    PreviousPnPState;// Remembers the previous pnp state
  QUEUE_STATE         QueueState;      // This flag is set whenever the
                                       // device needs to queue incoming
                                       // requests (when it receives a
                                       // QUERY_STOP or QUERY_REMOVE).

  LIST_ENTRY          NewRequestsQueue; // The queue where the incoming
                                        // requests are held when
                                        // QueueState is set to HoldRequest
                                        // or the device is busy.
  KSPIN_LOCK          QueueLock;        // The spin lock that protects
                                        // the queue

  KEVENT              RemoveEvent; // an event to sync outstandingIO to zero.
  KEVENT              StopEvent;   // an event to sync outstandingIO to 1.

  ULONG               OutstandingIO; // 1-biased count of reasons why
                                     // this object should stick around.

  SYSTEM_POWER_STATE  SystemPowerState; // The general system power state
  DEVICE_POWER_STATE  DevicePowerState; // The state of the device(D0 or D3)
  UNICODE_STRING      InterfaceName;    // The name returned from IoRegisterDeviceInterface()
  DEVICE_CAPABILITIES DeviceCaps;       // Copy of the device capability (S->D mappings)
  WMILIB_CONTEXT      WmiLibInfo;       // WMI Information

  KEVENT                          PerfStateLock;
  
  PPROCESSOR_PERFORMANCE_STATES   PerfStates;
  PPROCESSOR_IDLE_STATES          CStates;

  PROCESSOR_OBJECT_INFO           ProcObjInfo;
  PACPI_PSS_PACKAGE               PssPackage;
  ACPI_PCT_PACKAGE                PctPackage;
  ULONG                           PpcResult;
  ULONG                           LowestPerfState;

  BOOLEAN                         LegacyInterface;
  BOOLEAN                         CstPresent;

  ULONG                           CurrentPerfState;
  ULONG                           ThrottleValue;
  ULONG                           LastRequestedThrottle;
  ULONG                           LastTransitionResult;
  ULONG                           SavedState;

  PACPI_INTERFACE_STANDARD        AcpiInterfaces;
  ULONG                           CurrentPssState;

}  FDO_DATA, *PFDO_DATA;

typedef struct _PROCESSOR_WMI_STATUS_DATA {

  UINT32  CurrentPerfState;
  UINT32  LastRequestedThrottle;
  UINT32  LastTransitionResult;
  UINT32  ThrottleValue;
  UINT32  LowestPerfState;
  UINT32  UsingLegacyInterface;
  PROCESSOR_PERFORMANCE_STATES PerfStates;

} PROCESSOR_WMI_STATUS_DATA, *PPROCESSOR_WMI_STATUS_DATA;


typedef NTSTATUS 
(*PPERF_TRANSITION)(
  IN PFDO_DATA, 
  IN ULONG
  );
  
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


NTSTATUS
ProcessorAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


NTSTATUS
ProcessorDispatchPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ProcessorDispatchPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
ProcessorDispatchIoctl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ProcessorCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ProcessorReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ProcessorCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ProcessorStartDevice (
    IN PFDO_DATA     FdoData,
    IN PIRP             Irp
    );



NTSTATUS
ProcessorDispatchPnpComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


VOID
ProcessorUnload(
    IN PDRIVER_OBJECT DriverObject
    );



VOID
ProcessorCancelQueued (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );



LONG
ProcessorIoIncrement    (
    IN  OUT PFDO_DATA   FdoData
    );


LONG
ProcessorIoDecrement    (
    IN  OUT PFDO_DATA   FdoData
    );



//
//  wmi.c
//

NTSTATUS
ProcessorSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ProcessorSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ProcessorSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ProcessorSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ProcessorQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
ProcessorQueryWmiRegInfo(
  IN PDEVICE_OBJECT    DeviceObject,
  OUT PULONG           RegFlags,
  OUT PUNICODE_STRING  InstanceName,
  OUT PUNICODE_STRING* RegistryPath,
  OUT PUNICODE_STRING  ResourceName,
  OUT PDEVICE_OBJECT*  Pdo
  );

NTSTATUS
ProcessorExecuteWmiMethod(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG MethodId,
  IN ULONG InBufferSize,
  IN ULONG OutBufferSize,
  IN PUCHAR Buffer
  );

NTSTATUS
ProcessorWmiFunctionControl(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN WMIENABLEDISABLECONTROL Function,
  IN BOOLEAN Enable
  );


NTSTATUS
ProcessorWmiRegistration(
    IN PFDO_DATA               FdoData
);

NTSTATUS
ProcessorWmiDeRegistration(
    IN PFDO_DATA               FdoData
);

NTSTATUS
_cdecl
ProcessorWmiLogEvent(
  IN ULONG    LogLevel,
  IN ULONG    LogType,
  IN LPGUID   TraceGuid,
  IN PUCHAR   Format, 
  ...
  );


NTSTATUS
ProcessorFireWmiEvent(
  IN PFDO_DATA  DeviceExtension,
  IN PWMI_EVENT Event,
  IN PVOID      Data
  );
  
VOID
ProcessorEnableGlobalLogging(
  VOID
  );

 

NTSTATUS
ProcessorReturnResources (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ProcessorQueueRequest    (
    IN OUT PFDO_DATA FdoData,
    IN PIRP Irp
    );


VOID
ProcessorProcessQueuedRequests    (
    IN OUT PFDO_DATA FdoData
    );

NTSTATUS
ProcessorCanRemoveDevice    (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
ProcessorPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

NTSTATUS
RegisterStateHandlers(
    IN PFDO_DATA DeviceExtension
    );

NTSTATUS
FASTCALL
SetPerfLevel (
    IN UCHAR Throttle
    );

UCHAR
GetNumThrottleSettings(
    IN PFDO_DATA DeviceExtension
    );

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

//
// Definitions for ACPI-defined objects and operations.
//

NTSTATUS
AcquireAcpiInterfaces(
    PFDO_DATA   DeviceExtension
    );

NTSTATUS
ReleaseAcpiInterfaces(
    PFDO_DATA   DeviceExtension
    );

VOID
AcpiNotifyCallback(
    PVOID   Context,
    ULONG   NotifyCode
    );

NTSTATUS
AcpiEvaluateMethod (
    IN  PFDO_DATA   DeviceExtension,
    IN  PCHAR       MethodName,
    IN  PVOID       InputBuffer OPTIONAL,
    OUT PVOID       *OutputBuffer
    );

NTSTATUS
AcpiEvaluateProcessorObject (
    IN  PFDO_DATA   DeviceExtension,
    OUT PVOID       *OutputBuffer
    );

NTSTATUS
AcpiEvaluatePtc(
    IN  PFDO_DATA   DeviceExtension,
    OUT PGEN_ADDR   *Address
    );

NTSTATUS
AcpiEvaluateCst(
    IN  PFDO_DATA           DeviceExtension,
    OUT PACPI_CST_PACKAGE   *CStates
    );

NTSTATUS
AcpiEvaluatePct(
    IN  PFDO_DATA           DeviceExtension,
    OUT PACPI_PCT_PACKAGE   *Address
    );

NTSTATUS
AcpiEvaluatePss(
    IN  PFDO_DATA           DeviceExtension,
    OUT PACPI_PSS_PACKAGE   *Address
    );

NTSTATUS
AcpiEvaluatePpc(
    IN  PFDO_DATA   DeviceExtension,
    OUT ULONG       *AvailablePerformanceStates
    );

NTSTATUS
InitializeAcpi2PStatesGeneric(
    IN  PFDO_DATA   DeviceExtension
    );

NTSTATUS
InitializeAcpi2PStates(
    IN  PFDO_DATA   DeviceExtension
    );

PVOID
GetAcpiTable(
    IN  ULONG   Signature
    );

NTSTATUS
InitializeAcpi1Cstates(
    PFDO_DATA   DeviceExtension
    );

NTSTATUS
InitializeAcpi1TStates(
  PFDO_DATA DeviceExtension
  );
  
NTSTATUS
InitializeAcpi2Cstates(
    PFDO_DATA   DeviceExtension
    );

NTSTATUS
RegisterPerfStateHandlers(
    PFDO_DATA   DeviceExtension
    );

BOOLEAN
FASTCALL
AcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
AcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
AcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
Acpi2C2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
Acpi2C3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );  

VOID
FASTCALL
ProcessorThrottle (
    IN UCHAR Throttle
    );

NTSTATUS
FASTCALL
SetThrottleLevel (
    IN UCHAR Throttle
    );

NTSTATUS
AcpiPerfStateTransition (
    IN PFDO_DATA    DeviceExtension,
    IN ULONG        State
    );

NTSTATUS
Acpi2PerfStateTransition (
    IN PFDO_DATA    DeviceExtension,
    IN ULONG        State
    );

NTSTATUS
AcpiLegacyPerfStateTransition (
    IN PFDO_DATA    DeviceExtension,
    IN ULONG        State
    );
    
NTSTATUS
MergePerformanceStates(
    IN  PFDO_DATA   DeviceExtension
    );

NTSTATUS
InitializeAcpi2IoSpaceCstates(
    IN PFDO_DATA   DeviceExtension
    );

VOID
AssumeProcessorPerformanceControl (
  VOID
  );

VOID
AssumeCStateControl (
  VOID
  );
  
NTSTATUS
GetRegistryDwordValue (
    IN  PWCHAR RegKey,
    IN  PWCHAR ValueName,
    OUT PULONG RegData
    );

NTSTATUS
SetRegistryStringValue (
    IN  PWCHAR RegKey,
    IN  PWCHAR ValueName,
    IN  PWCHAR String
    );

NTSTATUS
GetRegistryStringValue (
    IN  PWCHAR RegKey,
    IN  PWCHAR ValueName,
    OUT PUNICODE_STRING RegString
    );

//
// Functions that must be implemented by each driver.
//

NTSTATUS
InitializeDriver(
  PUNICODE_STRING ServiceKeyRegPath
  );
  
NTSTATUS
InitializeNonAcpiPerformanceStates(
    IN  PFDO_DATA   DeviceExtension
    );

NTSTATUS
GetLegacyMaxProcFrequency (
  OUT PULONG CpuSpeed
  );

NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  );

NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  );

NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  );

  
typedef struct {
    USHORT  Signature;
    USHORT  CommandPortAddress;
    USHORT  EventPortAddress;
    USHORT  PollInterval;
    UCHAR   CommandDataValue;
    UCHAR   EventPortBitmask;
    UCHAR   MaxLevelAc;
    UCHAR   MaxLevelDc;
} LEGACY_GEYSERVILLE_INT15, *PLEGACY_GEYSERVILLE_INT15;


//
// method.c
//

NTSTATUS
Acpi2PerfStateTransitionGeneric(
  IN PFDO_DATA    DeviceExtension,
  IN ULONG        State
  );

NTSTATUS
FASTCALL
SetPerfLevelGeneric(
  IN UCHAR     Throttle,
  IN PFDO_DATA DeviceExtension
  );

NTSTATUS
MergePerformanceStatesGeneric(
  IN  PFDO_DATA DeviceExtension
  );

NTSTATUS
FASTCALL
SetThrottleLevelGeneric (
  IN UCHAR     Throttle,
  IN PFDO_DATA DeviceExtension
  );

NTSTATUS
BuildAvailablePerfStatesFromPss (
  PFDO_DATA DeviceExtension
  );

ULONG
GetMaxProcFrequency(
  PFDO_DATA   DeviceExtension
  );

NTSTATUS
SaveCurrentStateGoToLowVolts(
  IN PFDO_DATA DeviceExtension
  );

NTSTATUS
RestoreToSavedPerformanceState(
  IN PFDO_DATA DeviceExtension
  );

NTSTATUS
SetProcessorPerformanceState(
  IN ULONG TargetPerfState,
  IN PFDO_DATA DeviceExtension
  );

NTSTATUS
QueueEventLogWrite(
  IN PFDO_DATA DeviceExtension,
  IN ULONG EventErrorCode,
  IN ULONG EventValue
  );
  
VOID
ProcessEventLogEntry (
  IN PDEVICE_OBJECT DeviceObject,
  IN PVOID Context
  );

NTSTATUS
PowerStateHandlerNotificationRegistration (
  IN PENTER_STATE_NOTIFY_HANDLER NotifyHandler,
  IN PVOID Context,
  IN BOOLEAN Register
  );

NTSTATUS
ProcessMultipleApicDescTable(
  PPROCESSOR_INFO ProcInfo
  );

extern
__inline
ULONG 
GetApicId(
  VOID
  );

extern
__inline
NTSTATUS
AcquireProcessorPerfStateLock (
  IN PFDO_DATA DevExt
  );

extern
__inline
NTSTATUS
ReleaseProcessorPerfStateLock (
  IN PFDO_DATA DevExt
  );
  
extern
__inline
CPUID(
  IN  ULONG CpuIdType,
  OUT PULONG EaxReg,
  OUT PULONG EbxReg,
  OUT PULONG EcxReg,
  OUT PULONG EdxReg
  );

extern
__inline
ULONGLONG 
ReadMSR(
  IN ULONG MSR
  );

extern
__inline
WriteMSR(
  IN ULONG MSR,
  IN ULONG64 MSRInfo
  );
  
NTSTATUS
SetProcessorFriendlyName (
  PFDO_DATA DeviceExtension
  );

NTSTATUS
GetHardwareId(
  PFDO_DATA DeviceExtension
  );

NTSTATUS
GetInstanceId(
  PFDO_DATA DeviceExtension,
  PWCHAR    *InstanceId
  );
  

NTSTATUS
GetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    );


//
// i386\util.c
//

NTSTATUS
CalculateCpuFrequency(
  OUT PULONG Freq
  );

NTSTATUS
GetCPUIDProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  );

ULONG
GetCheckSum (
  IN PUCHAR  Address,
  IN ULONG   Length
  );

ULONG
Bcd8ToUlong(
  IN ULONG BcdValue
  );

ULONG
ReadGenAddr(
  IN PGEN_ADDR GenAddr
  );

VOID
WriteGenAddr(
  IN PGEN_ADDR GenAddr,
  IN ULONG     Value
  );

//
// power.c
//

typedef NTSTATUS
(*PAC_DC_NOTIFY_HANDLER)(
  IN PVOID   Context,
  IN BOOLEAN AC
  );
  
NTSTATUS
RegisterAcDcTransitionNotifyHandler (
  IN PAC_DC_NOTIFY_HANDLER NewHandler,  
  IN PVOID                 Context
  );


// end power.c


//
// method.c
//

NTSTATUS
GetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    );

  
//
// misc debug routines
//

#if DBG
VOID
DumpProcessorPerfStates (
    PPROCESSOR_PERFORMANCE_STATES PerfStates
    );

VOID
DumpProcessorStateHandler2Info (
    PPROCESSOR_STATE_HANDLER2 StateInfo
    );
#else
#define DumpProcessorPerfStates(_x_)
#define DumpProcessorStateHandler2Info(_x_)
#endif



//
// shared.c
//

NTSTATUS
ValidatePssLatencyValues (
  IN PFDO_DATA DeviceExtension
  );
  
#if DBG
VOID
DumpPSS(
  IN PACPI_PSS_PACKAGE PStates
  );
#else
#define DumpPSS(_x_)
#endif

#endif  // _PROCESSOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\shared.c ===
/*++

Copyright(c) 1998  Microsoft Corporation

Module Name:

    shared.c

Abstract:

    routines shared outside of library

Author:

    Todd Carpenter

Environment:

    kernel mode


Revision History:

    03-28-01 : created, toddcar

--*/
#include "processor.h"


NTSTATUS
ValidatePssLatencyValues (
  IN PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:

--*/
{
  NTSTATUS status = STATUS_SUCCESS;
  ULONG savedState = INVALID_PERF_STATE;
  ULONG targetState;
  ULONG x;
  ULONG latency;
  LARGE_INTEGER  start;
  LARGE_INTEGER  end;
  LARGE_INTEGER  freq;
     
  
  DebugEnter();
  DebugAssert(DeviceExtension);

  //
  // Save current state, go to highest perfstate available
  //

  if (DeviceExtension->CurrentPerfState != INVALID_PERF_STATE) {
    savedState = DeviceExtension->CurrentPerfState;
  }

  if (DeviceExtension->CurrentPerfState) {
    Acpi2PerfStateTransition(DeviceExtension, DeviceExtension->PpcResult);
  }
  

  //
  // Get Perf Counter Frequency
  //
    
  KeQueryPerformanceCounter(&freq);


  //
  // Walk though all available states, calulate transition latency
  //
  
  for (x = 0; x < DeviceExtension->PssPackage->NumPStates; x++) {
  
    targetState = DeviceExtension->PssPackage->NumPStates - x - 1;
    latency = 0;

    //
    // We should already be at PerfState == PpcResult,
    // and we can't go to a higher state
    //
    
    if (targetState < DeviceExtension->PpcResult) {
      continue;
    }
    
    start = KeQueryPerformanceCounter(NULL);
    status = Acpi2PerfStateTransition(DeviceExtension, targetState);
    end = KeQueryPerformanceCounter(NULL);
     
    //
    // Calculate transition latency.
    //

    if (NT_SUCCESS(status)) {
      latency = (ULONG)((end.QuadPart - start.QuadPart) * 1000000 / freq.QuadPart);
    }

    //
    // Record new latency value in unused BmLatency field
    //
    
    DeviceExtension->PssPackage->State[targetState].Latency = latency;
  }


  //
  // Restore saved Perf State
  //
  
  if (savedState != DeviceExtension->CurrentPerfState && 
      savedState != INVALID_PERF_STATE) {
    Acpi2PerfStateTransition(DeviceExtension, savedState);
  }

  return status;
}


ULONG
ReadGenAddr(
  IN PGEN_ADDR GenAddr
  )
{
  ULONG bitWidth;
  ULONG mask = 0;
  ULONG result = 0;


  DebugAssert(GenAddr);
  DebugAssert(GenAddr->BitWidth);
  DebugAssert(GenAddr->BitWidth <= 32);

  
  //
  // Figure out how wide our target register is.
  //
  
  bitWidth = GenAddr->BitWidth +  GenAddr->BitOffset;


  if (bitWidth <= 8) {
    bitWidth = 8;
  } else if (bitWidth <= 16) {
    bitWidth = 16;
  } else {
    bitWidth = 32;
  }

  switch (GenAddr->AddressSpaceID) {

    case AcpiGenericSpaceIO:
    
      DebugAssert(!(GenAddr->Address.LowPart & 0Xffff0000));
      DebugAssert(GenAddr->Address.HighPart == 0);
  
      switch (bitWidth) {

        case 8:
        
          result = READ_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart);
          break;
    
        case 16:
        
          result = READ_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart);
          break;
    
        case 32:
        
          result = READ_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart);
          break;
  
        default:
          return 0;
      }
  
      break;
  
      case AcpiGenericSpaceMemory:
    
        //
        // This code path depends on the fact that the addresses
        // in these structures have already been converted to
        // virtual addresses.
        //
    
        switch (bitWidth) {

          case 8:
          
            result = READ_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart);
            break;
      
          case 16:
          
            result = READ_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart);
            break;
      
          case 32:
          
            result = READ_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart);
            break;
      
          default:
            return 0;
        }
    
        break;

    default:
     return 0;

  }

  //
  // If the register is not actually byte-aligned, correct for that.
  //

  if (result && (bitWidth != GenAddr->BitWidth)) {
           
    result >>= GenAddr->BitOffset;
    result &= ((0x1ul << GenAddr->BitWidth) - 1);
      
  }
  
  return result;
}


VOID
WriteGenAddr(
  IN PGEN_ADDR GenAddr,
  IN ULONG     Value
  )
{
  ULONG bitWidth;
  ULONG data = 0;
  ULONG mask = 0;

  DebugAssert(GenAddr);
  DebugAssert(GenAddr->BitWidth);
  DebugAssert(GenAddr->BitWidth <= 32);


  //
  // Figure out how wide our target register is.
  //
  
  bitWidth = GenAddr->BitWidth + GenAddr->BitOffset;

  
  if (bitWidth <= 8) {
    bitWidth = 8;
  } else if (bitWidth <= 16) {
    bitWidth = 16;
  } else {
    bitWidth = 32;
  }
  

  switch (GenAddr->AddressSpaceID) {

    case AcpiGenericSpaceIO:
    
      DebugAssert(!(GenAddr->Address.LowPart & 0Xffff0000));
      DebugAssert(GenAddr->Address.HighPart == 0);
  
      switch(bitWidth) {

        case 8:
    
          DebugAssert(!(Value & 0xffffff00));
    
          if ((GenAddr->BitOffset != 0) || (GenAddr->BitWidth != bitWidth)) {
    
            data = READ_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart);
            mask = (UCHAR)~0 >> (8 - GenAddr->BitWidth);
            mask = (UCHAR)~(mask << GenAddr->BitOffset);
            data &= mask;
            data |= (UCHAR)Value << GenAddr->BitOffset;
    
          } else {
            data = Value;
          }
    
          WRITE_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart, (UCHAR)data);
          break;
  
        case 16:
    
          DebugAssert(!(Value & 0xffff0000));
    
          if ((GenAddr->BitOffset != 0) || (GenAddr->BitWidth != bitWidth)) {
    
            data = READ_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart);
            mask = (USHORT)~0 >> (16 - GenAddr->BitWidth);
            mask = (USHORT)~(mask << GenAddr->BitOffset);
            data &= mask;
            data |= (USHORT)Value << GenAddr->BitOffset;
    
          } else {
            data = Value;
          }
    
          WRITE_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart, (USHORT)data);
          break;
  
        case 32:
    
          if ((GenAddr->BitOffset != 0) || (GenAddr->BitWidth != bitWidth)) {
  
            data = READ_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart);
            mask = (ULONG)~0 >> (32 - GenAddr->BitWidth);
            mask = ~(mask << GenAddr->BitOffset);
            data &= mask;
            data |= Value << GenAddr->BitOffset;
  
          } else {
            data = Value;
          }
  
          WRITE_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart, data);
          break;
    
        default:
          return;
      }
  
      break;
    
    case AcpiGenericSpaceMemory:
    
      //
      // This code path depends on the fact that the addresses in these structures 
      // have already been converted to virtual addresses.
      //
  
      switch (bitWidth) {

        case 8:
    
          DebugAssert(!(Value & 0xffffff00));
  
          if ((GenAddr->BitOffset != 0) || (GenAddr->BitWidth != bitWidth)) {
  
            data = READ_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart);
            mask = (UCHAR)~0 >> (8 - GenAddr->BitWidth);
            mask = (UCHAR)~(mask << GenAddr->BitOffset);
            data &= mask;
            data |= (UCHAR)Value << GenAddr->BitOffset;
  
          } else {
            data = Value;
          }
  
          WRITE_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart, (UCHAR)data);
          break;
  
        case 16:
    
            DebugAssert(!(Value & 0xffff0000));
    
            if ((GenAddr->BitOffset != 0) || (GenAddr->BitWidth != bitWidth)) {
    
              data = READ_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart);
              mask = (USHORT)~0 >> (16 - GenAddr->BitWidth);
              mask = (USHORT)~(mask << GenAddr->BitOffset);
              data &= mask;
              data |= (USHORT)Value << GenAddr->BitOffset;
    
            } else {
              data = Value;
            }
    
            WRITE_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart, (USHORT)data);
            break;
  
        case 32:
    
          if ((GenAddr->BitOffset != 0) || (GenAddr->BitWidth != bitWidth)) {
  
            data = READ_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart);
            mask = (ULONG)~0 >> (32 - GenAddr->BitWidth);
            mask = ~(mask << GenAddr->BitOffset);
            data &= mask;
            data |= Value << GenAddr->BitOffset;
  
          } else {
            data = Value;
          }
  
          WRITE_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart, data);
          break;
    
        default:
          return;
      }
  
      break;
    
    default:
        return;
  }

}

//
// Misc Debug Routines
//

#if DBG
VOID
DumpPSS(
  IN PACPI_PSS_PACKAGE PStates
  )
{
  ULONG x;
  PACPI_PSS_DESCRIPTOR pState;

  DebugAssert(PStates);

  DebugPrint((TRACE, "\n"));
  DebugPrint((TRACE, "_PSS:\n"));
 
  for (x = 0; x < PStates->NumPStates; x++) {
      
    pState = &PStates->State[x];

    DebugPrint((TRACE, "State: #%u\n", x));
    DebugPrint((TRACE, "  Core Frequency      %u mhz\n",pState->CoreFrequency));
    DebugPrint((TRACE, "  Power               %u mW\n", pState->Power));
    DebugPrint((TRACE, "  Transition Latency  %u us\n", pState->Latency));
    DebugPrint((TRACE, "  Bus Master Latency  %u us\n", pState->BmLatency));
    DebugPrint((TRACE, "  Control value       0x%x\n",  pState->Control));
    DebugPrint((TRACE, "  Status value        0x%x\n",  pState->Status));
    DebugPrint((TRACE, "\n"));

  }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\axp64\cstate.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cstatec.c

Abstract:

    This module implements code to find and intialize
    ACPI C-states.

Author:

    Jake Oshins (3/27/00) - create file

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "processor.h"
#include "ntacpi.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeAcpi1Cstates)
#endif

NTSTATUS
InitializeAcpi1Cstates(
    PFDO_DATA   DeviceExtension
    )
/*++

Routine Description:
    
    This routine discovers any available ACPI 1.0 C-states
    and fills in the CState structure in the device
    extension.  And there are no ACPI 1.0 C-states for
    64-bit machines.

Arguments:
    
    DeviceExtension
   
Return Value:

    NT status code
    

--*/
{
    return STATUS_SUCCESS;
}

BOOLEAN
FASTCALL
AcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
AcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
AcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

VOID
FASTCALL
ProcessorThrottle (
    IN UCHAR Throttle
    )
{
    DbgBreakPoint();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\wmi.h ===
/*++

  Copyright (c) 1990-2000 Microsoft Corporation All Rights Reserved
  
  Module Name:
  
    wmi.h
  
  Author:
  
    Todd Carpenter
  
  Environment:
  
    Kernel mode
    
  Revision History:

    3/15/2001 - created, toddcar

--*/

#ifndef _WMI_H_
#define _WMI_H_

#include <initguid.h>
#include <wmistr.h>
#include <wmilib.h>
#include <evntrace.h>
#include <ntwmi.h>

#define PROCESSOR_WMI_GUID_LIST_SIZE  sizeof(ProcessorWmiGuidList)/sizeof(WMIGUIDREGINFO);
#define PROCESSOR_MOF_RESOURCE_NAME   L"PROCESSORWMI"
#define PROCESSOR_EVENT_BUFFER_SIZE   256


// {ee751f9d-cec5-4686-9816-ff6d1ca2261c}
DEFINE_GUID(PROCESSOR_STATUS_WMI_GUID, 
0xee751f9d, 0xcec5, 0x4686, 0x98, 0x16, 0xff, 0x6d, 0x1c, 0xa2, 0x26, 0x1c);

// {590C82FC-98A3-48e1-BE04-FE11441A11E7}
DEFINE_GUID(PROCESSOR_METHOD_WMI_GUID, 
0x590c82fc, 0x98a3, 0x48e1, 0xbe, 0x4, 0xfe, 0x11, 0x44, 0x1a, 0x11, 0xe7);

// {08213901-B301-4a4c-B1DD-177238110F9F}
DEFINE_GUID(PROCESSOR_TRACING_WMI_GUID, 
0x8213901, 0xb301, 0x4a4c, 0xb1, 0xdd, 0x17, 0x72, 0x38, 0x11, 0xf, 0x9f);

// {7FD18652-0CFE-40d2-B0A1-0B066A87759E}
DEFINE_GUID(PROCESSOR_PERFMON_WMI_GUID, 
0x7fd18652, 0xcfe, 0x40d2, 0xb0, 0xa1, 0xb, 0x6, 0x6a, 0x87, 0x75, 0x9e);

// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
DEFINE_GUID(PROCESSOR_PSTATE_EVENT_WMI_GUID, 
0xa5b32ddd, 0x7f39, 0x4abc, 0xb8, 0x92, 0x90, 0xe, 0x43, 0xb5, 0x9e, 0xbb);

// {66A9B302-F9DB-4864-B0F1-843905E8080F}
DEFINE_GUID(PROCESSOR_NEW_PSTATES_EVENT_WMI_GUID, 
0x66a9b302, 0xf9db, 0x4864, 0xb0, 0xf1, 0x84, 0x39, 0x5, 0xe8, 0x8, 0xf);

// {1C9D482E-93CE-4b9e-BDEC-23653CE0CE28}
DEFINE_GUID(PROCESSOR_NEW_CSTATES_EVENT_WMI_GUID, 
0x1c9d482e, 0x93ce, 0x4b9e, 0xbd, 0xec, 0x23, 0x65, 0x3c, 0xe0, 0xce, 0x28);

//
// WmiMethodId
//

typedef enum {

  WmiFunctionSetProcessorPerfState = 1

} PROCESSOR_WMI_METHODS;


typedef struct _WMI_TRACE_INFO {

  EVENT_TRACE_HEADER  TraceHeader;
  MOF_FIELD           TraceData;
  
} WMI_TRACE_INFO, *PWMI_TRACE_INFO;


typedef struct _WMI_EVENT {

  ULONG  Enabled;
  ULONG  EventId;
  ULONG  DataSize;
  LPGUID Guid;

} WMI_EVENT, *PWMI_EVENT;

typedef struct _NEW_PSTATES_EVENT {

  ULONG HighestState;

} NEW_PSTATES_EVENT, *PNEW_PSTATES_EVENT;

typedef struct _PSTATE_EVENT {

  ULONG State;
  ULONG Status;
  ULONG Latency;
  ULONG Speed;

} PSTATE_EVENT, *PPSTATE_EVENT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\amd64\cstate.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cstatec.c

Abstract:

    This module implements code to find and intialize
    ACPI C-states.

Author:

    Jake Oshins (3/27/00) - create file

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "processor.h"
#include "ntacpi.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeAcpi1Cstates)
#pragma alloc_text (PAGE, GetNumThrottleSettings)
#endif

NTSTATUS
InitializeAcpi1Cstates(
    PFDO_DATA   DeviceExtension
    )
/*++

Routine Description:
    
    This routine discovers any available ACPI 1.0 C-states
    and fills in the CState structure in the device
    extension.  And there are no ACPI 1.0 C-states for
    64-bit machines.

Arguments:
    
    DeviceExtension
   
Return Value:

    NT status code
    

--*/
{
    return STATUS_SUCCESS;
}

BOOLEAN
FASTCALL
AcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
AcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
AcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
Acpi2C1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
Acpi2C2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
Acpi2C3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

VOID
FASTCALL
ProcessorThrottle (
    IN UCHAR Throttle
    )
{
    DbgBreakPoint();
}

UCHAR
GetNumThrottleSettings(
    IN PFDO_DATA DeviceExtension
    )
{
    PAGED_CODE();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\wmi.c ===
/*++

  Copyright (c) 1990-2000 Microsoft Corporation All Rights Reserved
  
  Module Name:
  
      wmi.c
  
  Abstract:
  
      This module handle all the WMI Irps.
  
  Environment:
  
      Kernel mode
  
  Revision History:
  
      10-26-1998 Eliyas Yakub
      10-10-2000 Todd Carpenter - re-written & updated based on wmifilt.sys
    
--*/
#include "processor.h"
#include "wmi.h"

PCHAR
WMIMinorFunctionString (
  UCHAR MinorFunction
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ProcessorWmiRegistration)
#pragma alloc_text(PAGE,ProcessorWmiDeRegistration)
#pragma alloc_text(PAGE,ProcessorSystemControl)
#pragma alloc_text(PAGE,ProcessorSetWmiDataItem)
#pragma alloc_text(PAGE,ProcessorSetWmiDataBlock)
#pragma alloc_text(PAGE,ProcessorQueryWmiDataBlock)
#pragma alloc_text(PAGE,ProcessorQueryWmiRegInfo)
#endif

WMIGUIDREGINFO ProcessorWmiGuidList[] = {

  {&PROCESSOR_STATUS_WMI_GUID,  1, 0},
  {&PROCESSOR_METHOD_WMI_GUID,  1, 0},
  {&PROCESSOR_TRACING_WMI_GUID, 0, WMIREG_FLAG_TRACED_GUID |
                                   WMIREG_FLAG_TRACE_CONTROL_GUID},
  {&PROCESSOR_PERFMON_WMI_GUID, 1, 0},
  {&PROCESSOR_PSTATE_EVENT_WMI_GUID,        1, 0},
  {&PROCESSOR_NEW_PSTATES_EVENT_WMI_GUID,   1, 0},
  {&PROCESSOR_NEW_CSTATES_EVENT_WMI_GUID,   1, 0}
  
};

// 
// These correspond to the indexes of the above GUIDs
//

typedef enum {

    ProcessorWmiStatusId,
    ProcessorWmiMethodId,
    ProcessorWmiTracingId,
    ProcessorWmiPerfMonId,
    ProcessorWmiPStateEventId,
    ProcessorWmiNewPStatesEventId,
    ProcessorWmiNewCStatesEventId
    
} PROCESSOR_WMI_GUID_LIST;


ULONG       WmiTraceEnable;
TRACEHANDLE WmiTraceHandle;
BOOLEAN     UsingGlobalWmiTraceHandle;
  
WMI_EVENT NewPStatesEvent = {0,
                             ProcessorWmiNewPStatesEventId,
                             sizeof(NEW_PSTATES_EVENT),
                             (LPGUID)&PROCESSOR_NEW_PSTATES_EVENT_WMI_GUID};
                                  
WMI_EVENT NewCStatesEvent = {0,
                             ProcessorWmiNewCStatesEventId,
                             0,
                             (LPGUID)&PROCESSOR_NEW_CSTATES_EVENT_WMI_GUID};

WMI_EVENT PStateEvent     = {0,
                             ProcessorWmiPStateEventId,
                             sizeof(PSTATE_EVENT),
                             (LPGUID)&PROCESSOR_PSTATE_EVENT_WMI_GUID};







NTSTATUS
ProcessorWmiRegistration (
  PFDO_DATA  FdoData
  )
/*++

  Routine Description

    Registers with WMI as a data provider for this
    instance of the device

--*/
{     
  DebugEnter();
  PAGED_CODE();
  
  FdoData->WmiLibInfo.GuidCount          = PROCESSOR_WMI_GUID_LIST_SIZE; 
  FdoData->WmiLibInfo.GuidList           = ProcessorWmiGuidList;
  FdoData->WmiLibInfo.QueryWmiRegInfo    = ProcessorQueryWmiRegInfo;
  FdoData->WmiLibInfo.QueryWmiDataBlock  = ProcessorQueryWmiDataBlock;
  FdoData->WmiLibInfo.SetWmiDataBlock    = ProcessorSetWmiDataBlock;
  FdoData->WmiLibInfo.SetWmiDataItem     = ProcessorSetWmiDataItem;
  FdoData->WmiLibInfo.ExecuteWmiMethod   = ProcessorExecuteWmiMethod;
  FdoData->WmiLibInfo.WmiFunctionControl = ProcessorWmiFunctionControl;
  
  
  //
  // Register with WMI
  //   
  
  return IoWMIRegistrationControl(FdoData->Self, WMIREG_ACTION_REGISTER);
    
}


NTSTATUS
ProcessorWmiDeRegistration (
  PFDO_DATA  FdoData
  )
/*++

  Routine Description

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

--*/
{

  DebugEnter();
  PAGED_CODE();
  
  return IoWMIRegistrationControl(FdoData->Self, WMIREG_ACTION_DEREGISTER);

}


NTSTATUS
ProcessorSystemControl (
  IN  PDEVICE_OBJECT  DeviceObject,
  IN  PIRP            Irp
  )
/*++

  Routine Description

    Dispatch routine for System Control IRPs 
    (MajorFunction == IRP_MJ_SYSTEM_CONTROL)

  Arguments:
  
      DeviceObject - Targetted device object
      Irp - Io Request Packet
    
  Return Value:
  
      NT status code
    

--*/
{
  PFDO_DATA               fdoData;
  SYSCTL_IRP_DISPOSITION  disposition;
  NTSTATUS                status;
  PIO_STACK_LOCATION      stack;

  DebugEnter();
  PAGED_CODE();
  
  stack = IoGetCurrentIrpStackLocation (Irp);
  
  DebugPrint((TRACE, "  %s\n", WMIMinorFunctionString(stack->MinorFunction)));
  
  fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
  
  ProcessorIoIncrement(fdoData);

  
  if (fdoData->DevicePnPState == Deleted) {
  
    Irp->IoStatus.Status = status = STATUS_DELETE_PENDING;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    ProcessorIoDecrement (fdoData);
    return status;
    
  }
  
  status = WmiSystemControl(&fdoData->WmiLibInfo, 
                            DeviceObject, 
                            Irp,
                            &disposition);
  
  
  switch (disposition) {
  
    case IrpProcessed:
    
      //
      // This irp has been processed and may be completed or pending.
      //
      
      break;
    
    
    case IrpNotCompleted:
    
      //
      // This irp has not been completed, but has been fully processed.
      // we will complete it now
      //
      
      IoCompleteRequest(Irp, IO_NO_INCREMENT);                
      break;
    
    
    case IrpForward:
    case IrpNotWmi:
    
      //
      // This irp is either not a WMI irp or is a WMI irp targeted
      // at a device lower in the stack.
      //
      
      IoSkipCurrentIrpStackLocation(Irp);
      status = IoCallDriver(fdoData->NextLowerDriver, Irp);
      break;
    
                                
    default:
    
      //
      // We really should never get here, but if we do just forward....
      //
      
      DebugAssert(!"WmiSystemControl() returned unknown disposition");
      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver(fdoData->NextLowerDriver, Irp);
      break;
           
  }
  
  ProcessorIoDecrement(fdoData);
  return status;
  
}


//
// WMI System Call back functions
//


NTSTATUS
ProcessorSetWmiDataItem (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG DataItemId,
  IN ULONG BufferSize,
  IN PUCHAR Buffer
  )
/*++

  Routine Description:
  
      This routine is a callback into the driver to change the contents of
      a data block. If teh driver can change teh data block within
      the callback it should call WmiCompleteRequest to complete the irp before
      returning to the caller. Or the driver can return STATUS_PENDING if the
      irp cannot be completed immediately and must then call WmiCompleteRequest
      once the data is changed.
  
  Arguments:
  
      DeviceObject is the device whose data block is being changed
  
      Irp is the Irp that makes this request
  
      GuidIndex is the index into the list of guids provided when the
          device registered
  
      InstanceIndex is the index that denotes which instance of the data block
          is being queried.
              
      DataItemId has the id of the data item being set
  
      BufferSize has the size of the data item passed
  
      Buffer has the new values for the data item
  
  
  Return Value:
  
      status

--*/
{
    NTSTATUS   status;
    PFDO_DATA  fdoData;    
    PIO_STACK_LOCATION  stack;

    DebugEnter();
    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation(Irp);
    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    

    switch (GuidIndex) {

      case ProcessorWmiStatusId: 
      case ProcessorWmiMethodId:
      case ProcessorWmiPerfMonId:
     
        status = STATUS_WMI_READ_ONLY;
        break;
      
      default:

        status = STATUS_WMI_GUID_NOT_FOUND;

    }
        
   
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);

    return status;
  
}


NTSTATUS
ProcessorSetWmiDataBlock (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG BufferSize,
  IN PUCHAR Buffer
  )
/*++

  Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.
  
  Arguments:
  
      DeviceObject is the device whose data block is being queried
  
      Irp is the Irp that makes this request
  
      GuidIndex is the index into the list of guids provided when the
          device registered
  
      InstanceIndex is the index that denotes which instance of the data block
          is being queried.
              
      BufferSize has the size of the data block passed
  
      Buffer has the new values for the data block
  
  
  Return Value:
  
      status

--*/
{
    NTSTATUS   status;
    PFDO_DATA  fdoData;    
    PIO_STACK_LOCATION  stack;

    DebugEnter();
    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation(Irp);
    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    

    switch (GuidIndex) {

      case ProcessorWmiStatusId:
      case ProcessorWmiMethodId:
      case ProcessorWmiPerfMonId:
 
        status = STATUS_WMI_READ_ONLY;
        break;
      
      default:

        status = STATUS_WMI_GUID_NOT_FOUND;
        
    }
        
   
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);

    return status;
  
}


NTSTATUS
ProcessorQueryWmiDataBlock (
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG InstanceCount,
  IN OUT PULONG InstanceLengthArray,
  IN ULONG BufferAvail,
  OUT PUCHAR Buffer
  )
/*++

  Routine Description:
  
      This routine is a callback into the driver to query for the contents of
      all instances of a data block. If the driver can satisfy the query within
      the callback it should call WmiCompleteRequest to complete the irp before
      returning to the caller. Or the driver can return STATUS_PENDING if the
      irp cannot be completed immediately and must then call WmiCompleteRequest
      once the query is satisfied.
  
  Arguments:
  
      DeviceObject is the device whose data block is being queried
  
      Irp is the Irp that makes this request
  
      GuidIndex is the index into the list of guids provided when the
          device registered
  
      InstanceCount is the number of instnaces expected to be returned for
          the data block.
  
      InstanceLengthArray is a pointer to an array of ULONG that returns the
          lengths of each instance of the data block. If this is NULL then
          there was not enough space in the output buffer to fufill the request
          so the irp should be completed with the buffer needed.
  
      BufferAvail on entry has the maximum size available to write the data
          blocks.
  
      Buffer on return is filled with the returned data blocks. Note that each
          instance of the data block must be aligned on a 8 byte boundry.
  
  
  Return Value:
  
      status

--*/
{
    NTSTATUS   status;
    PFDO_DATA  fdoData;
    ULONG      perfStateSize = 0;
    ULONG      sizeNeeded    = 0;
    PIO_STACK_LOCATION  stack;

    DebugEnter();
    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation(Irp);
    fdoData = (PFDO_DATA) DeviceObject->DeviceExtension;
    

    switch (GuidIndex) {

      case ProcessorWmiStatusId:
        DebugPrint((TRACE, "ProcessorWmiStatusId\n"));
        
        if (fdoData->PerfStates) {

          AcquireProcessorPerfStateLock(fdoData);
          
          perfStateSize = sizeof(PROCESSOR_PERFORMANCE_STATES) + 
                          (sizeof(PROCESSOR_PERFORMANCE_STATE) *
                          (fdoData->PerfStates->Count - 1));
          
          sizeNeeded = sizeof(PROCESSOR_WMI_STATUS_DATA) +
                       (sizeof(PROCESSOR_PERFORMANCE_STATE) *
                       (fdoData->PerfStates->Count - 1));
                       
  
          if (BufferAvail >= sizeNeeded) {
            
            ((PPROCESSOR_WMI_STATUS_DATA)Buffer)->CurrentPerfState = fdoData->CurrentPerfState;
            ((PPROCESSOR_WMI_STATUS_DATA)Buffer)->LastRequestedThrottle = fdoData->LastRequestedThrottle;
            ((PPROCESSOR_WMI_STATUS_DATA)Buffer)->LastTransitionResult = fdoData->LastTransitionResult;
            ((PPROCESSOR_WMI_STATUS_DATA)Buffer)->ThrottleValue = fdoData->ThrottleValue;
            ((PPROCESSOR_WMI_STATUS_DATA)Buffer)->LowestPerfState = fdoData->LowestPerfState;
            ((PPROCESSOR_WMI_STATUS_DATA)Buffer)->UsingLegacyInterface = (ULONG) fdoData->LegacyInterface;
  
            RtlCopyMemory(&((PPROCESSOR_WMI_STATUS_DATA)Buffer)->PerfStates, 
                          fdoData->PerfStates, 
                          perfStateSize);
                          
            status = STATUS_SUCCESS;
            
          } else {
            status = STATUS_BUFFER_TOO_SMALL;
          }

          ReleaseProcessorPerfStateLock(fdoData);

        } else {

          DebugPrint((ERROR, "ProcessorQueryWmiDataBlock(): PerfStates == NULL\n"));
          status = STATUS_WMI_GUID_NOT_FOUND;
          
        }
        
        break;

      
      case ProcessorWmiMethodId:
        DebugPrint((TRACE, "ProcessorWmiMethodId\n"));
        
        //
        // Method classes do not have any data within them, but must repond 
        // successfully to queries so that WMI method operation work successfully.
        //

        //sizeNeeded = sizeof(USHORT);

        sizeNeeded = 0;
        status = STATUS_SUCCESS;
        
        //if (BufferAvail >= sizeNeeded) {
          //status = STATUS_SUCCESS;
        //} else {
          //status = STATUS_BUFFER_TOO_SMALL;
        //}
        break;


      case ProcessorWmiPerfMonId:
        DebugPrint((TRACE, "ProcessorWmiPerfMonId\n"));
        

        if (fdoData->PerfStates) {
                  
          sizeNeeded = sizeof(PROCESSOR_PERFORMANCE_STATE);
                       
  
          if (BufferAvail >= sizeNeeded) {

            AcquireProcessorPerfStateLock(fdoData);

            RtlCopyMemory(Buffer, 
                          &fdoData->PerfStates->State[fdoData->CurrentPerfState], 
                          sizeNeeded);
                          
            ReleaseProcessorPerfStateLock(fdoData);
            status = STATUS_SUCCESS;
            
          } else {
            status = STATUS_BUFFER_TOO_SMALL;
          }

        } else {

          DebugPrint((ERROR, "ProcessorQueryWmiDataBlock(): PerfStates == NULL\n"));
          status = STATUS_WMI_GUID_NOT_FOUND;
          
        }
        
        break;


      
      default:
        status = STATUS_WMI_GUID_NOT_FOUND;
      
    }
        
      
    InstanceLengthArray[0] = sizeNeeded;
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                sizeNeeded,
                                IO_NO_INCREMENT);


    DebugExitStatus(status);
    return status;
    
}


NTSTATUS
ProcessorQueryWmiRegInfo(
  IN PDEVICE_OBJECT DeviceObject,
  OUT PULONG RegFlags,
  OUT PUNICODE_STRING InstanceName,
  OUT PUNICODE_STRING *RegistryPath,
  OUT PUNICODE_STRING ResourceName,
  OUT PDEVICE_OBJECT *Pdo    
  )
/*++

  Routine Description:
  
      This routine is a callback into the driver to retrieve the list of
      guids or data blocks that the driver wants to register with WMI. This
      routine may not pend or block. Driver should NOT call
      WmiCompleteRequest.
  
  Arguments:
  
      DeviceObject is the device whose data block is being queried
  
      *RegFlags returns with a set of flags that describe the guids being
          registered for this device. If the device wants enable and disable
          collection callbacks before receiving queries for the registered
          guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
          returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
          the instance name is determined from the PDO associated with the
          device object. Note that the PDO must have an associated devnode. If
          WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
          name for the device.
  
      InstanceName returns with the instance name for the guids if
          WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
          caller will call ExFreePool with the buffer returned.
  
      *RegistryPath returns with the registry path of the driver
  
      *MofResourceName returns with the name of the MOF resource attached to
          the binary file. If the driver does not have a mof resource attached
          then this can be returned as NULL.
  
      *Pdo returns with the device object for the PDO associated with this
          device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
          *RegFlags.
  
  Return Value:
  
      status

--*/
{
  PFDO_DATA fdoData;
  
  DebugEnter();
  PAGED_CODE();
  
  fdoData = DeviceObject->DeviceExtension;
  
  *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
              
  *RegistryPath = &Globals.RegistryPath;
  *Pdo = fdoData->UnderlyingPDO;
  RtlInitUnicodeString(ResourceName, PROCESSOR_MOF_RESOURCE_NAME);
  
  return STATUS_SUCCESS;
  
}


NTSTATUS
ProcessorExecuteWmiMethod(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN ULONG InstanceIndex,
  IN ULONG MethodId,
  IN ULONG InBufferSize,
  IN ULONG OutBufferSize,
  IN PUCHAR Buffer
  )
/*++

  Routine Description:
  
      This routine is a callback into the driver to execute a method. If
      the driver can complete the method within the callback it should
      call WmiCompleteRequest to complete the irp before returning to the
      caller. Or the driver can return STATUS_PENDING if the irp cannot be
      completed immediately and must then call WmiCompleteRequest once the
      data is changed.
  
  Arguments:
  
      DeviceObject is the device whose method is being executed
  
      Irp is the Irp that makes this request
  
      GuidIndex is the index into the list of guids provided when the
          device registered
  
      MethodId has the id of the method being called
  
      InBufferSize has the size of the data block passed in as the input to
          the method.
  
      OutBufferSize on entry has the maximum size available to write the
          returned data block.
  
      Buffer is filled with the input buffer on entry and returns with
           the output data block
  
  Return Value:
  
      status

--*/
{
  ULONG sizeNeeded = 0;
  NTSTATUS  status;
  PFDO_DATA devExt = DeviceObject->DeviceExtension;
  
  DebugEnter();
  
  
  //
  // Execute a Method, or Fire an Event
  // 
  
  if (GuidIndex == ProcessorWmiMethodId) {
  
   switch (MethodId) {
   
       case WmiFunctionSetProcessorPerfState:
       {
         ULONG newPerfState = 0;
         ULONG rc = 0;

         if (InstanceIndex != 0) {
           status = STATUS_WMI_INSTANCE_NOT_FOUND;
           break;
         }
         
         if (InBufferSize < sizeof(ULONG)) {
   
           DebugPrint((TRACE, "WmiFunctionSetProcessorPerfState: InBuffer too small: 0x%x\n",
                       InBufferSize));
                       
           status = STATUS_BUFFER_TOO_SMALL;
           sizeNeeded = sizeof(ULONG);
           break;
         }                  
   
         if (OutBufferSize < sizeof(ULONG)) {
   
           DebugPrint((TRACE, "WmiFunctionSetProcessorPerfState: OutBuffer too small: 0x%x\n",
                       OutBufferSize));
                       
           status = STATUS_BUFFER_TOO_SMALL;
           sizeNeeded = sizeof(ULONG);
           break;
         } 
         
         //
         // This functionality is only supported on debug builds
         //
         
#if DBG || ENABLE_STATE_CHANGE

         newPerfState = *((PULONG)Buffer);
         
         rc = SetProcessorPerformanceState(newPerfState, devExt);
         RtlCopyMemory(Buffer, (PUCHAR)&rc, sizeof(rc));
         sizeNeeded = sizeof(rc);
         status = STATUS_SUCCESS;
#else  
         sizeNeeded = 0;
         status = STATUS_WMI_ITEMID_NOT_FOUND;
#endif
        
         break; 
       }
   
       default:
         DebugPrint((TRACE, "ProcessorExecuteWmiMethod: Uknown MethodId of 0x%x\n", MethodId));
         status = STATUS_WMI_ITEMID_NOT_FOUND;
   
    }
      
  } else {
    status = STATUS_WMI_GUID_NOT_FOUND;
  }
  
  status = WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              sizeNeeded,
                              IO_NO_INCREMENT);
  
  return status;
  
}


NTSTATUS
ProcessorWmiFunctionControl(
  IN PDEVICE_OBJECT DeviceObject,
  IN PIRP Irp,
  IN ULONG GuidIndex,
  IN WMIENABLEDISABLECONTROL Function,
  IN BOOLEAN Enable
  )
/*++

  Routine Description:
  
      This routine is a callback into the driver to enabled or disable event
      generation or data block collection. A device should only expect a
      single enable when the first event or data consumer enables events or
      data collection and a single disable when the last event or data
      consumer disables events or data collection. Data blocks will only
      receive collection enable/disable if they were registered as requiring
      it. If the driver can complete enabling/disabling within the callback it
      should call WmiCompleteRequest to complete the irp before returning to
      the caller. Or the driver can return STATUS_PENDING if the irp cannot be
      completed immediately and must then call WmiCompleteRequest once the
      data is changed.
  
  Arguments:
  
      DeviceObject is the device object
  
      GuidIndex is the index into the list of guids provided when the
          device registered
  
      Function specifies which functionality is being enabled or disabled
      (currently either WmiEventControl or WmiDataBlockControl)
  
      Enable is TRUE then the function is being enabled else disabled
  
  Return Value:
  
      status

--*/
{

    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  irpStack;
    PWNODE_HEADER       Wnode;
    PFDO_DATA           devExt;
    
    DebugEnter();
    DebugAssert(DeviceObject);
   
    if (Function) {
      DebugPrint((ERROR, "ProcessorWmiFunctionControl doesn't handle WmiDataBlockControl requests\n"));
      return STATUS_UNSUCCESSFUL;
    }

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    Wnode = (PWNODE_HEADER)irpStack->Parameters.WMI.Buffer;
    DebugAssert(irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER));

    devExt = DeviceObject->DeviceExtension;

    //
    // Enable/Disable events
    //

    switch (GuidIndex) {

      case ProcessorWmiTracingId:
      
        //
        // NOTE: for the TraceLog event, level is passed in as the HIWORD(Wnode->Version) 
        // from tracelog.exe -level
        //
        //
        
        if (Enable) {
  
          InterlockedExchange(&WmiTraceEnable, 1);
          WmiTraceHandle = ((PWNODE_HEADER)irpStack->Parameters.WMI.Buffer)->HistoricalContext;
          UsingGlobalWmiTraceHandle = FALSE;
          
        } else {
        
          InterlockedExchange(&WmiTraceEnable, 0);
          WmiTraceHandle = 0;

        }
        break;

      case ProcessorWmiPStateEventId:

        if (devExt->PerfStates) {
          InterlockedExchange(&PStateEvent.Enabled, Enable);
        }
        break;
        
      case ProcessorWmiNewPStatesEventId:
        
        if (devExt->PssPackage) {
          InterlockedExchange(&NewPStatesEvent.Enabled, Enable);
        }
        break;        
        
      case ProcessorWmiNewCStatesEventId:

        if (devExt->CstPresent) {
          InterlockedExchange(&NewCStatesEvent.Enabled, Enable);
        }
        break;  

      default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;

    }

    
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                0,
                                IO_NO_INCREMENT);


    return status;
                              
}


NTSTATUS
_cdecl
ProcessorWmiLogEvent(
  IN ULONG    LogLevel,
  IN ULONG    LogType,
  IN LPGUID   TraceGuid,
  IN PUCHAR   Format, 
  ...
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  va_list         list; 
  UCHAR           eventString[PROCESSOR_EVENT_BUFFER_SIZE+1];
  NTSTATUS        status = STATUS_SUCCESS;
  LARGE_INTEGER   timeStamp;
  WMI_TRACE_INFO  eventInfo;
  PEVENT_TRACE_HEADER  wnodeEventItem;
  KIRQL irql;

  if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
    goto ProcessorWmiLogEventExit;
  }

  
  if (WmiTraceEnable) {

    //
    // record the time
    //
    
    KeQuerySystemTime(&timeStamp);
      
    va_start(list, Format);
    eventString[PROCESSOR_EVENT_BUFFER_SIZE]=0;
    _vsnprintf(eventString, PROCESSOR_EVENT_BUFFER_SIZE, Format, list);

    DebugAssert(WmiTraceHandle);
    
    eventInfo.TraceData.DataPtr  = (ULONG64) eventString;
    eventInfo.TraceData.Length   = strlen(eventString);
    eventInfo.TraceData.DataType = 0;
    
    eventInfo.TraceHeader.Size        = sizeof(WMI_TRACE_INFO);
    eventInfo.TraceHeader.Class.Type  = (UCHAR) LogType;
    eventInfo.TraceHeader.Class.Level = (UCHAR) LogLevel;
    eventInfo.TraceHeader.TimeStamp   = timeStamp;
    eventInfo.TraceHeader.GuidPtr     = (ULONGLONG) TraceGuid;
    eventInfo.TraceHeader.Flags       = WNODE_FLAG_TRACED_GUID   | 
                                        WNODE_FLAG_USE_TIMESTAMP |
                                        WNODE_FLAG_USE_MOF_PTR   |
                                        WNODE_FLAG_USE_GUID_PTR;
                                  
    wnodeEventItem = &eventInfo.TraceHeader;
    ((PWNODE_HEADER)wnodeEventItem)->HistoricalContext = WmiTraceHandle;

  
    //
    // Fire the event. Since this is a trace event and not a standard
    // WMI event, IoWMIWriteEvent will not attempt to free the buffer
    // passed into it.
    //

  
    status = IoWMIWriteEvent((PVOID)wnodeEventItem);

  
    if (!NT_SUCCESS(status)) {
    
      DebugPrint((ERROR, "IoWMIWriteEvent Failed! rc=0x%x len(%u)\n", status, strlen(eventString)));

      if (status == STATUS_INVALID_HANDLE) {
        DebugPrint((ERROR, "Invalid Handle == %I64x\n", WmiTraceHandle));
      }
      
      //
      //  According to the powers that be, if we are using the global
      //  handle, and the IoWMIWriteEvent() fails, then we need to stop
      //  using the global handle
      //

      //if (UsingGlobalWmiTraceHandle) {
      
      //  InterlockedExchange(&WmiTraceEnable, 0);
      //  UsingGlobalWmiTraceHandle = FALSE;
      //  WmiTraceHandle = 0;

      //}
      
    }
    
  }    


ProcessorWmiLogEventExit:

  return status;
}


NTSTATUS
ProcessorFireWmiEvent(
  IN PFDO_DATA  DeviceExtension,
  IN PWMI_EVENT Event,
  IN PVOID      Data
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  NTSTATUS status = STATUS_SUCCESS;
  PUCHAR   eventData = NULL;
  PWNODE_SINGLE_INSTANCE  wnode;

 
  DebugEnter();
  DebugAssert(Event);
  

  if (!Event->Enabled) {
    status = STATUS_SUCCESS;
    goto ProcessorFireWmiEventExit;
  }

  if (Data && Event->DataSize) {
    eventData = ExAllocatePoolWithTag(NonPagedPool,
                                      Event->DataSize,
                                      PROCESSOR_POOL_TAG);


    if (!eventData) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto ProcessorFireWmiEventExit;
    }


  
    RtlCopyMemory(eventData, Data, Event->DataSize);
  }
  
  //
  // FireEvent... WmiFireEvent will free the memory
  //
  
  status = WmiFireEvent(DeviceExtension->Self,
                        Event->Guid,
                        0,
                        Event->DataSize,
                        (PVOID) eventData);
     

ProcessorFireWmiEventExit:

  DebugExitStatus(status);
  return status;
  
}


VOID
ProcessorEnableGlobalLogging(
  VOID
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{

  WmiSetLoggerId(WMI_GLOBAL_LOGGER_ID, &WmiTraceHandle);

  InterlockedExchange(&WmiTraceEnable, 1);
  UsingGlobalWmiTraceHandle = TRUE;
  
}


#if DBG
PCHAR
WMIMinorFunctionString (
  UCHAR MinorFunction
  )
{
    switch (MinorFunction) {

      case IRP_MN_QUERY_ALL_DATA:
          return "IRP_MN_QUERY_ALL_DATA";
      case IRP_MN_QUERY_SINGLE_INSTANCE:
          return "IRP_MN_QUERY_SINGLE_INSTANCE";
      case IRP_MN_CHANGE_SINGLE_INSTANCE:
          return "IRP_MN_CHANGE_SINGLE_INSTANCE";
      case IRP_MN_CHANGE_SINGLE_ITEM:
          return "IRP_MN_CHANGE_SINGLE_ITEM";
      case IRP_MN_ENABLE_EVENTS:
          return "IRP_MN_ENABLE_EVENTS";
      case IRP_MN_DISABLE_EVENTS:
          return "IRP_MN_DISABLE_EVENTS";
      case IRP_MN_ENABLE_COLLECTION:
          return "IRP_MN_ENABLE_COLLECTION";
      case IRP_MN_DISABLE_COLLECTION:
          return "IRP_MN_DISABLE_COLLECTION";
      case IRP_MN_REGINFO:
          return "IRP_MN_REGINFO";
      case IRP_MN_EXECUTE_METHOD:
          return "IRP_MN_EXECUTE_METHOD";
      case IRP_MN_REGINFO_EX:
          return "IRP_MN_REGINFO_EX";
      default:
          return "Unknown IRP_MJ_SYSTEM_CONTROL";
          
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\i386\cstate.asm ===
title  "Processor Idle Handlers"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixcstate.asm
;
; Abstract:
;
;    This module implements the code for idling the processor
;    in low power modes.
;
; Author:
;
;    Jake Oshins (jakeo) March 10, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include ntacpi.h

        .list

        EXTRNP  _KeStallExecutionProcessor, 1
        EXTRNP  _KeQueryPerformanceCounter, 1
        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _HalpBroken440BX:byte
        extrn   _HalpOutstandingScatterGatherCount:DWORD
        extrn   _HalpPiix4:byte
        extrn   _PBlkAddress:DWORD
        extrn   _AcpiC3Win2kCompatable:BYTE
        
PIIX4_THROTTLE_FIX  EQU 10000h

;
; Defines for PROCESSOR_IDLE_TIMES structure
;

Idle struc
    StartTimeLow        dd      ?
    StartTimeHigh       dd      ?
    EndTimeLow          dd      ?
    EndTimeHigh         dd      ?
    Pm1aState           dw      ?
    Pm1bState           dw      ?
Idle ends

;
; Defines for GEN_ADDR
;

GenAddr struc
    AddressSpaceID      db      ?
    BitWidth            db      ?
    BitOffset           db      ?
    GenAddrReserved     db      ?
    AddressLow          dd      ?
    AddressHigh         dd      ?
GenAddr ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Processor Idle Handlers"

;++
;typedef struct {
;    ULONGLONG                   StartTime;
;    ULONGLONG                   EndTime;
;    ULONG                       IdleHandlerReserved[4];
;} PROCESSOR_IDLE_TIMES, *PPROCESSOR_IDLE_TIMES;
;
; BOOLEAN
; FASTCALL
; AcpiC1Idle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C1.  It
;     basically just stops the processor until an interrupt
;     occurs.
;
; Arguments:
;
;     (ecx) = IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     TRUE if immediate demotion required
;
;--

cPublicFastCall AcpiC1Idle, 1
cPublicFpo 0, 2
        push    ecx

        ;
        ; record the StartTime of this idle
        ;
        stdCall _KeQueryPerformanceCounter, <0>

        mov     ecx, [esp]
        mov     [ecx].StartTimeLow, eax
        mov     [ecx].StartTimeHigh, edx

        ;
hc1_10: ; Note the C2 handler will jump to this target in the C1 handler
        ; this is a piix4 and throttling is enabled (since on piix4 trying
        ; to enter C2 while throttling does not work)
        ;

        sti
        hlt

        ;
        ; record the EndTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        pop     ecx
        mov     [ecx].EndTimeLow, eax
        mov     [ecx].EndTimeHigh, edx

        xor     eax, eax
        fstRET    AcpiC1Idle

fstENDP AcpiC1Idle

;++
; BOOLEAN
; FASTCALL
; AcpiC2Idle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C2.  It
;     shuts part of the processor off.
;
; Arguments:
;
;     (ecx) = IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     TRUE if immediate demotion required
;
;--
cPublicFastCall AcpiC2Idle, 1
cPublicFpo 0,2
        push    ecx

        ;
        ; record the StartTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        mov     ecx, [esp]
        mov     [ecx].StartTimeLow, eax
        mov     [ecx].StartTimeHigh, edx

        ;
        ; Check if BM_RLD has been set and needs clear
        ;

        test    byte ptr [ecx].Pm1aState, SCI_EN
        jnz     short hac2_piix4fix

hac2_10:
        ;
        ; Get the I/O port we need for C2.  This codes
        ; assumes that nobody will ever do an ACPI 1.0 C2 
        ; state on an MP machine.
        ;

        mov     edx, [_PBlkAddress].AddressLow
        test    edx, PIIX4_THROTTLE_FIX         ; Piix4 throttling work-around
        jnz     short hc1_10                    ; JUMP TO C1 handler

        add     edx, P_LVL2

        ;
        ; put the processor to bed
        ;

        in      al, dx
        sub     edx, P_LVL2-P_CNT               ; Read P_CNT register to close processor
        in      eax, dx                         ; window on entering C2

        ;
        ; record the EndTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        pop     ecx
        mov     [ecx].EndTimeLow, eax
        mov     [ecx].EndTimeHigh, edx

        xor     eax, eax                        ; return FALSE
        fstRET    AcpiC2Idle

hac2_piix4fix:
        ;
        ; Clear the BM_RLD settings for piix4
        ;

        mov     edx, [PM1a_CNT]
        mov     ax, [ecx].Pm1aState
        mov     [ecx].Pm1aState, 0
        out     dx, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short hac2_10
        mov     ax, [ecx].Pm1bState
        out     dx, ax
        jmp     short hac2_10

fstENDP AcpiC2Idle

;++
; UCHAR
; FASTCALL
; HalpSetup440BXWorkaround(
;     )
;
; Routine Description:
;
;     This function provides part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     none
;
; Return Value:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
;--
cPublicFastCall HalpSetup440BXWorkaround, 0
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        mov     cl, al
        or      al, 7
        out     dx, al
        push    ecx
        stdCall _KeStallExecutionProcessor <15>
        pop     ecx
        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        and     al, 0f8h
        out     dx, al
        movzx   eax, cl
        fstRET  HalpSetup440BXWorkaround

fstENDP HalpSetup440BXWorkaround

;++
; VOID
; FASTCALL
; HalpComplete440BXWorkaround(
;     UCHAR DramControl
;     )
;
; Routine Description:
;
;     This function provides the other part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
; Return Value:
;
;     none
;
;--
cPublicFastCall HalpComplete440BXWorkaround, 1
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        mov     al, cl
        out     dx, al
        fstRET  HalpComplete440BXWorkaround

fstENDP HalpComplete440BXWorkaround

;++
; BOOLEAN
; FASTCALL
; AcpiC3ArbdisIdle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C3.  It
;     shuts part of the processor off.
;
;     This routine assumes that the machine supports
;     PM2_CNT.ARB_DIS.
;
;     UNIPROCESSOR only.  Due to a piix4 errata this function needs to
;     mess with a global register (bm_rld)
;
; Arguments:
;
;     IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     none
;
;--

cPublicFastCall AcpiC3ArbdisIdle, 1
cPublicFpo 0, 3

        push    ebx
        mov     ebx, ecx
        push    esi

        ;
        ; Another PIIX4 bug.  If the IDE controller might
        ; create any busmaster traffic, then we will hang
        ; the machine.  (So would any F-type DMA traffic,
        ; but in NT, you can disable that by failing to
        ; add it to your ACPI BIOS.  So the onus for worrying
        ; about it falls to the OEMs.)  If the count
        ; of outstanding scatter/gather operations is 
        ; non-zero, bail.
        ;
        
        .if (_HalpPiix4)
        mov     eax, [_HalpOutstandingScatterGatherCount]
        mov     eax, [eax]
        test    eax, eax
        jnz     short hac3_abort2
        .endif
        
        ;
        ; record the StartTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        mov     [ebx].StartTimeLow, eax
        mov     [ebx].StartTimeHigh, edx

        ;
        ; check to see if busmaster activity has occurred
        ; if so, clear it and if it stays set, just get out
        ;

        mov     edx, [PM1a_EVT]
        mov     ecx, [PM1b_EVT]
        or      ecx, ecx                        ; is there a 2nd bm_sts to check?
        jz      short hac3_10                   ; no, skip it

        in      ax, dx                          ; read bm_sts
        test    al, BM_STS                      ; if not set, keep going
        jz      short hac3_9

        mov     al, _AcpiC3Win2kCompatable     ; check to see if we should behave like win2k
        test    al, al
        jnz     short hac3_abort
        
        mov     eax, BM_STS                     ; clear the bit
        out     dx, ax
        in      ax, dx                          ; and reread it
        test    al, BM_STS                      ; if still set, abort c3
        jnz     short hac3_abort

hac3_9:
        xchg    edx, ecx                        ; read next bm_sts

hac3_10:
        in      ax, dx                          ; read bm_sts
        test    al, BM_STS
        jz      short hac3_checkthrottle        ; if not set, keep going

        mov     al, _AcpiC3Win2kCompatable     ; check to see if we should behave like win2k
        test    al, al
        jnz     short hac3_abort
              
        mov     eax, BM_STS
        out     dx, ax                          ; clear the bit
        in      ax, dx                          ; and reread it
        test    al, BM_STS
        jz      short hac3_checkthrottle        ; if not set, keep going

hac3_abort:

    ;
    ; Bus master activity occured, abort C3 wait by returning
    ; non-zero to the OS.   Clear bus master status for next
    ; attempt.
    ;

        mov     eax, BM_STS
        out     dx, ax

        mov     edx, ecx
        or      ecx, ecx
        jz      short hac3_abort2

        out     dx, ax

hac3_abort2:
        ; return non-zero
        pop     esi
        pop     ebx
        fstRET    AcpiC3ArbdisIdle

hac3_checkthrottle:
        ;
        ; Check to see if piix4 is in a state where it can't use C3
        ;

        mov     edx, [_PBlkAddress].AddressLow
        test    edx, PIIX4_THROTTLE_FIX
        jnz     hac3piix4

        ;
        ; If BM_RLD not set, then set it
        ;

        test    byte ptr [ebx].Pm1aState, SCI_EN
        jnz     short hac3_20

        mov     edx, [PM1a_CNT]

        in      ax, dx                          ; read first pm1a_cnt
        mov     [ebx].Pm1aState, ax             ; save the original value
        or      ax, BM_RLD                      ; set BM_RLD
        out     dx, ax                          ; update the register

        mov     edx, [PM1b_CNT]
        or      edx, edx                        ; is there a 2nd pm1b_cnt register?
        jz      short hac3_20                   ; no, done with this

        in      ax, dx                          ; read second pm1b_cnt
        mov     [ebx].Pm1bState, ax             ; save the original value
        or      ax, BM_RLD                      ; set BM_RLD
        out     dx, ax                          ; update the register

hac3_20:
        ;
        ; disable bus masters
        ;

        mov     edx, [PM2_CNT_BLK]
        in      al, dx
        mov     cl, al                          ; save current PM2_CNT_BLK
        or      al, ARB_DIS                     ; set PM2_CNT.ARB_DIS
        out     dx, al                          ; write PM2_CNT_BLK

        ;
        ; Work around potentially broken 440BX
        ;
        ; N.B. This function will never be called on a machine with more
        ;      than one processor
        ;
        ; N.B. We don't call the PCI configuration functions for several
        ;      reasons.  First, that would involve buying a bunch of stack.
        ;      Second, we don't want the huge latency that would involve,
        ;      as this workaround is about DRAM refresh timings.
        ;

        .if (_HalpBroken440BX)
        push    ecx
        pushfd
        cli
        fstCall HalpSetup440BXWorkaround
        mov     esi, eax
        .endif

        ;
        ; put processor into C3 sleep
        ;

        mov     edx, [_PBlkAddress].AddressLow
        add     edx, P_LVL3
        in      al, dx                          ; Go to C3 sleep

        sub     edx, P_LVL3                     ; Read P_CNT register to close processor
        in      eax, dx                         ; window on entering C3

        .if (_HalpBroken440BX)
        mov     ecx, esi
        fstCall HalpComplete440BXWorkaround
        popfd
        pop     ecx
        .endif

        ;
        ; Restore bus master access
        ;

        mov     edx, [PM2_CNT_BLK]
        mov     al, cl                          ; Get saved copy of pm2_cnt_blk
        out     dx, al

hac3_90:
        ;
        ; record the EndTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        mov     [ebx].EndTimeLow, eax
        mov     [ebx].EndTimeHigh, edx

        xor     eax, eax
        pop     esi
        pop     ebx

        fstRET    AcpiC3ArbdisIdle

hac3piix4:
        sti
        hlt
        jmp     short hac3_90


fstENDP AcpiC3ArbdisIdle

if 0
;++
; BOOLEAN
; FASTCALL
; HalAcpiC3WbinvdIdle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C3.  It
;     shuts part of the processor off.
;
;     This routine assumes that the machine supports
;     WBINVD.
;
; Arguments:
;
;     IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     none
;
;--
cPublicFastCall HalAcpiC3WbinvdIdle, 1
cPublicFpo 0, 1

        push    ecx

        ;
        ; record the StartTime of this idle
        ;
        fstCall HalpQueryPerformanceCounter    ; move current counter into edx:eax

        mov     ecx, [esp]
        mov     [ecx].StartTimeLow, eax
        mov     [ecx].StartTimeHigh, edx

        ;
        ; get the I/O port we need for C3
        ;
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbHalReserved.PcrPblk
        add     edx, P_LVL3

.586p
        wbinvd                                  ; flush the processor cache
.386p
        ;
        ; put the processor to bed
        ;
        mov     edx, ecx
        in      al, dx

        sub     edx, P_LVL2-P_CNT               ; Read P_CNT register to close processor
        in      eax, dx                         ; window on entering C3

        ;
        ; record the EndTime of this idle
        ;
        fstCall HalpQueryPerformanceCounter    ; move current counter into edx:eax

        pop     ecx
        mov     [ecx].EndTimeLow, eax
        mov     [ecx].EndTimeHigh, edx

        xor     eax, eax                        ; return FALSE
        fstRET  HalAcpiC3WbinvdIdle

fstENDP HalAcpiC3WbinvdIdle
endif

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\ia64\cstate.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cstatec.c

Abstract:

    This module implements code to find and intialize
    ACPI C-states.

Author:

    Jake Oshins (3/27/00) - create file

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "processor.h"
#include "ntacpi.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeAcpi1Cstates)
#pragma alloc_text (PAGE, GetNumThrottleSettings)
#endif

NTSTATUS
InitializeAcpi1Cstates(
    PFDO_DATA   DeviceExtension
    )
/*++

Routine Description:
    
    This routine discovers any available ACPI 1.0 C-states
    and fills in the CState structure in the device
    extension.  And there are no ACPI 1.0 C-states for
    64-bit machines.

Arguments:
    
    DeviceExtension
   
Return Value:

    NT status code
    

--*/
{
    return STATUS_SUCCESS;
}

BOOLEAN
FASTCALL
AcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
AcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
AcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
Acpi2C1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
Acpi2C2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

BOOLEAN
FASTCALL
Acpi2C3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    )
{
    DbgBreakPoint();
    return FALSE;
}

VOID
FASTCALL
ProcessorThrottle (
    IN UCHAR Throttle
    )
{
    DbgBreakPoint();
}

UCHAR
GetNumThrottleSettings(
    IN PFDO_DATA DeviceExtension
    )
{
    PAGED_CODE();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\i386\cstate2.asm ===
title  "Processor Idle Handlers"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cstate.asm
;
; Abstract:
;
;    This module implements the code for idling the processor
;    in low power modes.
;
; Author:
;
;    Jake Oshins (jakeo) March 10, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include ntacpi.h

        .list

        EXTRNP  _ReadGenAddr, 1
        EXTRNP  _KeStallExecutionProcessor, 1
        EXTRNP  _KeQueryPerformanceCounter, 1
        extrn   _HalpFixedAcpiDescTable:DWORD     
        extrn   _HalpBroken440BX:byte
        extrn   _HalpOutstandingScatterGatherCount:DWORD
        extrn   _HalpPiix4:byte
        extrn   _PCntAddress:DWORD
        extrn   _C2Address:DWORD
        extrn   _C3Address:DWORD
        extrn   _AcpiC3Win2kCompatable:BYTE
        extrn   _Piix4ThrottleFix:DWORD
        
;
; Defines for PROCESSOR_IDLE_TIMES structure
;

Idle struc
    StartTimeLow        dd      ?
    StartTimeHigh       dd      ?
    EndTimeLow          dd      ?
    EndTimeHigh         dd      ?
    Pm1aState           dw      ?
    Pm1bState           dw      ?
Idle ends

;
; Defines for GEN_ADDR
;

GenAddr struc
    AddressSpaceID      db      ?
    BitWidth            db      ?
    BitOffset           db      ?
    GenAddrReserved     db      ?
    AddressLow          dd      ?
    AddressHigh         dd      ?
GenAddr ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Processor2 Idle Handlers"

;++
;typedef struct {
;    ULONGLONG                   StartTime;
;    ULONGLONG                   EndTime;
;    ULONG                       IdleHandlerReserved[4];
;} PROCESSOR_IDLE_TIMES, *PPROCESSOR_IDLE_TIMES;
;
; BOOLEAN
; FASTCALL
; Acpi2C1Idle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C1.  It
;     basically just stops the processor until an interrupt
;     occurs.
;
; Arguments:
;
;     (ecx) = IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     TRUE if immediate demotion required
;
;--

cPublicFastCall Acpi2C1Idle, 1
cPublicFpo 0, 2
        push    ecx

        ;
        ; record the StartTime of this idle
        ;
        stdCall _KeQueryPerformanceCounter, <0>

        mov     ecx, [esp]
        mov     [ecx].StartTimeLow, eax
        mov     [ecx].StartTimeHigh, edx

        ;
hc1_10: ; Note the C2 handler will jump to this target in the C1 handler
        ; this is a piix4 and throttling is enabled (since on piix4 trying
        ; to enter C2 while throttling does not work)
        ;

        sti
        hlt

        ;
        ; record the EndTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        pop     ecx
        mov     [ecx].EndTimeLow, eax
        mov     [ecx].EndTimeHigh, edx

        xor     eax, eax
        fstRET    Acpi2C1Idle

fstENDP Acpi2C1Idle


;++
; BOOLEAN
; FASTCALL
; Acpi2C2Idle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C2.  It
;     shuts part of the processor off.
;
; Arguments:
;
;     (ecx) = IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     TRUE if immediate demotion required
;
;--
cPublicFastCall Acpi2C2Idle, 1
cPublicFpo 0,2

        push    ecx

        ;
        ; record the StartTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        mov     ecx, [esp]
        mov     [ecx].StartTimeLow, eax
        mov     [ecx].StartTimeHigh, edx

        ;
        ; Check if BM_RLD has been set and needs clear
        ;

        test    byte ptr [ecx].Pm1aState, SCI_EN
        jnz     short hac2_piix4fix

hac2_10:
        
        mov     edx, _Piix4ThrottleFix
        test    edx, edx                        ; if piix4 and currently throttled, 
        jnz     short hc1_10                    ; jump to C1 handler


        ;
        ; Enter C2 sleep
        ;
       
        stdCall  _ReadGenAddr, <offset _C2Address>                                 
        stdCall  _ReadGenAddr, <offset _PCntAddress>  ; close processor window on entering C2
        
       
        ;
        ; record the EndTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        pop     ecx
        mov     [ecx].EndTimeLow, eax
        mov     [ecx].EndTimeHigh, edx

        xor     eax, eax                        ; return FALSE
        fstRET  Acpi2C2Idle

hac2_piix4fix:
        ;
        ; Clear the BM_RLD settings for piix4
        ;

        mov     edx, [PM1a_CNT]
        mov     ax, [ecx].Pm1aState
        mov     [ecx].Pm1aState, 0
        out     dx, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short hac2_10
        mov     ax, [ecx].Pm1bState
        out     dx, ax
        jmp     short hac2_10

fstENDP Acpi2C2Idle

;++
; UCHAR
; FASTCALL
; HalpSetup440BXWorkaround(
;     )
;
; Routine Description:
;
;     This function provides part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     none
;
; Return Value:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
;--
cPublicFastCall Halp2Setup440BXWorkaround, 0
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        mov     cl, al
        or      al, 7
        out     dx, al
        push    ecx
        stdCall _KeStallExecutionProcessor <15>
        pop     ecx
        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        and     al, 0f8h
        out     dx, al
        movzx   eax, cl
        fstRET  Halp2Setup440BXWorkaround

fstENDP Halp2Setup440BXWorkaround

;++
; VOID
; FASTCALL
; HalpComplete440BXWorkaround(
;     UCHAR DramControl
;     )
;
; Routine Description:
;
;     This function provides the other part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
; Return Value:
;
;     none
;
;--
cPublicFastCall Halp2Complete440BXWorkaround, 1
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        mov     al, cl
        out     dx, al 
        fstRET  Halp2Complete440BXWorkaround

fstENDP Halp2Complete440BXWorkaround


;++
; BOOLEAN
; FASTCALL
; Acpi2C3ArbdisIdle(
;     OUT PPROCESSOR_IDLE_TIMES IdleTimes
;     )
;
; Routine Description:
;
;     This is the Idle Handler for processor state C3.  It
;     shuts part of the processor off.
;
;     This routine assumes that the machine supports
;     PM2_CNT.ARB_DIS.
;
;     UNIPROCESSOR only.  Due to a piix4 errata this function needs to
;     mess with a global register (bm_rld)
;
; Arguments:
;
;     IdleTimes - beginning and ending time stamps
;
; Return Value:
;
;     none
;
;--

cPublicFastCall Acpi2C3ArbdisIdle, 1
cPublicFpo 0, 3

        push    ebx
        mov     ebx, ecx
        push    esi

        ;
        ; Another PIIX4 bug.  If the IDE controller might create any busmaster traffic, 
        ; then we will hang the machine.  (So would any F-type DMA traffic, but in NT, 
        ; you can disable that by failing to add it to your ACPI BIOS.  So the onus for 
        ; worrying about it falls to the OEMs.)  If the count of outstanding 
        ; scatter/gather operations is non-zero, bail.
        ;
        
        .if (_HalpPiix4)
        mov     eax, [_HalpOutstandingScatterGatherCount]
        mov     eax, [eax]
        test    eax, eax
        jnz     short hac3_abort2
        .endif
        
        ;
        ; record the StartTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        mov     [ebx].StartTimeLow, eax
        mov     [ebx].StartTimeHigh, edx

        ;
        ; check to see if busmaster activity has occurred
        ; if so, clear it and if it stays set, just get out
        ;

        mov     edx, [PM1a_EVT]
        mov     ecx, [PM1b_EVT]
        or      ecx, ecx                        ; is there a 2nd bm_sts to check?
        jz      short hac3_10                   ; no, skip it

        in      ax, dx                          ; read bm_sts
        test    al, BM_STS                      ; if not set, keep going
        jz      short hac3_9

        mov     al, _AcpiC3Win2kCompatable     ; check to see if we should behave like win2k
        test    al, al
        jnz     short hac3_abort
        
        mov     eax, BM_STS                     ; clear the bit
        out     dx, ax
        in      ax, dx                          ; and reread it
        test    al, BM_STS                      ; if still set, abort c3
        jnz     short hac3_abort

hac3_9:
        xchg    edx, ecx                        ; read next bm_sts

hac3_10:
        in      ax, dx                          ; read bm_sts
        test    al, BM_STS
        jz      short hac3_checkthrottle        ; if not set, keep going

        mov     al, _AcpiC3Win2kCompatable     ; check to see if we should behave like win2k
        test    al, al
        jnz     short hac3_abort
               
        mov     eax, BM_STS
        out     dx, ax                          ; clear the bit
        in      ax, dx                          ; and reread it
        test    al, BM_STS
        jz      short hac3_checkthrottle        ; if not set, keep going

hac3_abort:

    ;
    ; Bus master activity occured, abort C3 wait by returning
    ; non-zero to the OS.   Clear bus master status for next
    ; attempt.
    ;

        mov     eax, BM_STS
        out     dx, ax

        mov     edx, ecx
        or      ecx, ecx
        jz      short hac3_abort2

        out     dx, ax

hac3_abort2:
        ; return non-zero
        pop     esi
        pop     ebx
        fstRET    Acpi2C3ArbdisIdle

hac3_checkthrottle:

        mov     edx, _Piix4ThrottleFix
        test    edx, edx
        jnz     hac3piix4

        ;
        ; If BM_RLD not set, then set it
        ;

        test    byte ptr [ebx].Pm1aState, SCI_EN
        jnz     short hac3_20

        mov     edx, [PM1a_CNT]

        in      ax, dx                          ; read first pm1a_cnt
        mov     [ebx].Pm1aState, ax             ; save the original value
        or      ax, BM_RLD                      ; set BM_RLD
        out     dx, ax                          ; update the register

        mov     edx, [PM1b_CNT]
        or      edx, edx                        ; is there a 2nd pm1b_cnt register?
        jz      short hac3_20                   ; no, done with this

        in      ax, dx                          ; read second pm1b_cnt
        mov     [ebx].Pm1bState, ax             ; save the original value
        or      ax, BM_RLD                      ; set BM_RLD
        out     dx, ax                          ; update the register

hac3_20:
        ;
        ; disable bus masters
        ;

        mov     edx, [PM2_CNT_BLK]
        in      al, dx
        mov     cl, al                          ; save current PM2_CNT_BLK
        or      al, ARB_DIS                     ; set PM2_CNT.ARB_DIS
        out     dx, al                          ; write PM2_CNT_BLK

        ;
        ; Work around potentially broken 440BX
        ;
        ; N.B. This function will never be called on a machine with more
        ;      than one processor
        ;
        ; N.B. We don't call the PCI configuration functions for several
        ;      reasons.  First, that would involve buying a bunch of stack.
        ;      Second, we don't want the huge latency that would involve,
        ;      as this workaround is about DRAM refresh timings.
        ;

        .if (_HalpBroken440BX)
        push    ecx
        pushfd
        cli
        fstCall Halp2Setup440BXWorkaround
        mov     esi, eax
        .endif

        ;
        ; Enter C3 sleep
        ;
      
        stdCall  _ReadGenAddr, <offset _C3Address>
        stdCall  _ReadGenAddr, <offset _PCntAddress>    ; close processor window on entering C3
         
        
        .if (_HalpBroken440BX)
         mov     ecx, esi
         fstCall Halp2Complete440BXWorkaround
         popfd
         pop     ecx
        .endif

        ;
        ; Restore bus master access
        ;

        mov     edx, [PM2_CNT_BLK]
        mov     al, cl                          ; Get saved copy of pm2_cnt_blk
        out     dx, al

hac3_90:
        ;
        ; record the EndTime of this idle
        ;

        stdCall _KeQueryPerformanceCounter, <0>

        mov     [ebx].EndTimeLow, eax
        mov     [ebx].EndTimeHigh, edx

        xor     eax, eax
        pop     esi
        pop     ebx

        fstRET    Acpi2C3ArbdisIdle

hac3piix4:
        sti
        hlt
        jmp     short hac3_90


fstENDP Acpi2C3ArbdisIdle

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\i386\cstatec.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cstatec.c

Abstract:

    This module implements code to find and intialize
    ACPI C-states.

Author:

    Jake Oshins (3/27/00) - create file

Environment:

    Kernel mode

Notes:


Revision History:

--*/

#include "processor.h"
#include "ntacpi.h"

//
// Acpi defines
//

#define P_LVL2    4
#define P_LVL3    5


UCHAR       HalpPiix4;
BOOLEAN     HalpBroken440BX;
PULONG      HalpOutstandingScatterGatherCount;
ULONG       HalpThrottleScale;
ULONG       HalpPiix4SlotNumber;
ULONG       HalpPiix4DevActB;
BOOLEAN     AcpiC3Win2kCompatable;
ULONG       Piix4ThrottleFix;

GEN_ADDR PBlkAddress;
extern FADT HalpFixedAcpiDescTable;
extern GEN_ADDR PCntAddress;
extern GEN_ADDR C2Address;
extern GEN_ADDR C3Address;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeAcpi1Cstates)
#pragma alloc_text (PAGE, GetNumThrottleSettings)
#endif

NTSTATUS
InitializeAcpi1Cstates(
    PFDO_DATA   DeviceExtension
    )
/*++

Routine Description:

    This routine discovers any available ACPI 1.0 C-states
    and fills in the CState structure in the device
    extension.

Arguments:

    DeviceExtension

Return Value:

    NT status code


--*/
#define NUM_HACKS   5
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    ULONG               disposition, length, i;
    NTSTATUS            status;
    FADT               *fadt;
    BOOLEAN             C2present = FALSE; 
    BOOLEAN             C3present = FALSE;
    
    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        ULONG Data;
    } PartialInformation;

    struct {
        PVOID   HackTarget;
        ULONG   DataSize;
        PWCHAR  RegString;
    } HacksFromHal[NUM_HACKS] =
    {

      {&HalpPiix4,
      sizeof(HalpPiix4),
      L"Piix4"},
      {&HalpBroken440BX,                          // unused
      sizeof(HalpBroken440BX),
      L"440BX"},
      {&HalpOutstandingScatterGatherCount,        // unused
      sizeof(HalpOutstandingScatterGatherCount),
      L"SGCount"},
      {&HalpPiix4SlotNumber,
      sizeof(HalpPiix4SlotNumber),
      L"Piix4Slot"},
      {&HalpPiix4DevActB,
      sizeof(HalpPiix4DevActB),
      L"Piix4DevActB"}

    };

    PAGED_CODE();

    //
    // Get CState hacks from Registy
    //

    GetRegistryDwordValue(PROCESSOR_PARAMETERS_REG_PATH,
                          CSTATE_FLAGS_REG_KEY,
                          &Globals.CStateFlags);


    //
    // Determine whether C2 and C3 are usable. We don't try to use
    // C2 and C3 on any ACPI MP machine.  Even if they say that they
    // support it, they really don't.
    //

    if ((DeviceExtension->ProcObjInfo.PBlkLength &&
         DeviceExtension->ProcObjInfo.PBlkAddress) &&
         Globals.SingleProcessorProfile) {

        //
        // We have a PBLK, which means that we might
        // be able to do C2 and/or C3.
        //

        if (HalpFixedAcpiDescTable.lvl2_latency <= 100) {
            C2present = TRUE;
        }

        //
        // HACKHACK
        //
        // Win98 does not handle the 440BX workaround.  So a prudent
        // BIOS vendor cannot specify a useful latency for C3 without
        // causing their machine to hang on Win98.  So we are letting
        // them specify the real value plus 0xa000 so that they can
        // trick Win98 into not using C3 and let it work for us.
        //

        if (HalpFixedAcpiDescTable.lvl3_latency >= 0xa000) {
            HalpFixedAcpiDescTable.lvl3_latency -= 0xa000;
        }

        if ((HalpFixedAcpiDescTable.lvl3_latency <= 1000) &&
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port) {

            C3present = TRUE;
        }


        PCntAddress.AddressSpaceID = AcpiGenericSpaceIO;
        PCntAddress.BitWidth  = 32;
        PCntAddress.BitOffset = 0;
        PCntAddress.Reserved  = 0;
        PCntAddress.Address.HighPart = 0;
        PCntAddress.Address.LowPart = DeviceExtension->ProcObjInfo.PBlkAddress;

        //
        // Compatability with Acpi 1.0 Cstate handlers
        //
        
        PBlkAddress = PCntAddress;

    }


    //
    // Check for C state overrides
    //

    if (Globals.CStateFlags & CSTATE_FLAG_DISABLE_C2) {
      C2present = FALSE;
    }


    if (Globals.CStateFlags & CSTATE_FLAG_DISABLE_C3) {
      C3present = FALSE;
    }


    if (Globals.CStateFlags & CSTATE_FLAG_WIN2K_COMPAT) {
      AcpiC3Win2kCompatable = TRUE;
    }

    //
    // Fill in the DeviceExtension with C-state handlers.
    //

    ASSERT(DeviceExtension->CStates == NULL);
    
    DeviceExtension->CStates =
        ExAllocatePoolWithTag(NonPagedPool,
                              sizeof(PROCESSOR_IDLE_STATES) +
                                (C2present ? sizeof(PROCESSOR_IDLE_STATE) : 0) +
                                (C3present ? sizeof(PROCESSOR_IDLE_STATE) : 0),
                              PROCESSOR_POOL_TAG);

    if (!DeviceExtension->CStates) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // C1 is always possible.
    //

    DeviceExtension->CStates->Count = 1;
    RtlZeroMemory(&(DeviceExtension->CStates->State[0].Register), sizeof(GEN_ADDR));
    DeviceExtension->CStates->State[0].StateType = 1;
    DeviceExtension->CStates->State[0].Latency   = 0;
    DeviceExtension->CStates->State[0].IdleHandler = AcpiC1Idle;

    i = 1;

    if (C2present) {

        DeviceExtension->CStates->Count++;
        DeviceExtension->CStates->State[i].Register.AddressSpaceID = AcpiGenericSpaceIO;
        DeviceExtension->CStates->State[i].Register.BitWidth  = 8;
        DeviceExtension->CStates->State[i].Register.BitOffset = 0;
        DeviceExtension->CStates->State[i].Register.Reserved  = 0;
        DeviceExtension->CStates->State[i].Register.Address.HighPart = 0;
        DeviceExtension->CStates->State[i].Register.Address.LowPart =
            DeviceExtension->ProcObjInfo.PBlkAddress + P_LVL2;
        DeviceExtension->CStates->State[i].StateType = 2;
        DeviceExtension->CStates->State[i].Latency =
            HalpFixedAcpiDescTable.lvl2_latency;
        DeviceExtension->CStates->State[i].IdleHandler = AcpiC2Idle;

        C2Address = DeviceExtension->CStates->State[i].Register;

        i++;
    }

    if (C3present) {

        DeviceExtension->CStates->Count++;
        DeviceExtension->CStates->State[i].Register.AddressSpaceID = AcpiGenericSpaceIO;
        DeviceExtension->CStates->State[i].Register.BitWidth  = 8;
        DeviceExtension->CStates->State[i].Register.BitOffset = 0;
        DeviceExtension->CStates->State[i].Register.Reserved  = 0;
        DeviceExtension->CStates->State[i].Register.Address.HighPart = 0;
        DeviceExtension->CStates->State[i].Register.Address.LowPart =
            DeviceExtension->ProcObjInfo.PBlkAddress + P_LVL3;
        DeviceExtension->CStates->State[i].StateType = 3;
        DeviceExtension->CStates->State[i].Latency =
            HalpFixedAcpiDescTable.lvl3_latency;
        DeviceExtension->CStates->State[i].IdleHandler = AcpiC3ArbdisIdle;

        C3Address = DeviceExtension->CStates->State[i].Register;
    }

    //
    // Read the registry to figure out what special HAL hacks to duplicate here.
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control\\HAL\\CStateHacks");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        goto InitializeAcpi1CstatesExit;
    }

    //
    // Read values for each of the hacks.
    //

    for (i = 0; i < NUM_HACKS; i++) {

        RtlInitUnicodeString(&UnicodeString,
                             HacksFromHal[i].RegString);

        status = ZwQueryValueKey(BaseHandle,
                                 &UnicodeString,
                                 KeyValuePartialInformation,
                                 &PartialInformation,
                                 sizeof(PartialInformation),
                                 &length);

        if (!NT_SUCCESS(status)) {
            goto InitializeAcpi1CstatesExit;
        }

        ASSERT(PartialInformation.Inf.DataLength == sizeof(ULONG));

        RtlCopyMemory(HacksFromHal[i].HackTarget,
                      (PUCHAR)(PartialInformation.Inf.Data),
                      HacksFromHal[i].DataSize);
    }


InitializeAcpi1CstatesExit:

    if (!NT_SUCCESS(status)) {
        ExFreePool(DeviceExtension->CStates);
        DeviceExtension->CStates = NULL;
    }

    ZwClose(BaseHandle);
    return status;
}


NTSTATUS
InitializeAcpi1TStates(
  PFDO_DATA DeviceExtension
  )
{
    
  NTSTATUS status = STATUS_SUCCESS;
  ULONG    freq;
  ULONG    stepFreq;
  ULONG    maxFreq;
  ULONG    i;

        
  //
  // We may be called to re-init the Acpi 1.0 Throttling states,
  // remove any previous states.
  //
  
  if (DeviceExtension->PerfStates) {
    ExFreePool(DeviceExtension->PerfStates);
    DeviceExtension->PerfStates = NULL;
    DeviceExtension->CurrentPerfState = INVALID_PERF_STATE;
  }

  
  HalpThrottleScale = (ULONG) GetNumThrottleSettings(DeviceExtension);
  
  if (HalpThrottleScale) {
  
      DeviceExtension->PerfStates = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(PROCESSOR_PERFORMANCE_STATES) +
                                        (sizeof(PROCESSOR_PERFORMANCE_STATE) *
                                        (HalpThrottleScale - 1)),
                                      PROCESSOR_POOL_TAG);
  
      if (!DeviceExtension->PerfStates) {
          status = STATUS_INSUFFICIENT_RESOURCES;
          goto InitializeAcpi1TStatesExit;
      }

      //
      // Initialize Throttle States to "Throttle off"
      //

      ProcessorThrottle((UCHAR)HalpThrottleScale);

      
      DeviceExtension->PerfStates->Count = (UCHAR) HalpThrottleScale;
      DeviceExtension->PerfStates->TransitionLatency = 0;
      DeviceExtension->PerfStates->TransitionFunction = SetThrottleLevel;
      DeviceExtension->CurrentPerfState = 0;
      DeviceExtension->LowestPerfState = 0;
  
      freq = maxFreq = GetMaxProcFrequency(DeviceExtension);
      stepFreq = (maxFreq / DeviceExtension->PerfStates->Count);
  
      for (i = 0; i < DeviceExtension->PerfStates->Count; i++) {
  
          //
          // Create a perfstate for each throttle setting.
          //
  
          DeviceExtension->PerfStates->State[i].Frequency = freq;
          DeviceExtension->PerfStates->State[i].PercentFrequency = (UCHAR)
              ((freq * POWER_PERF_SCALE) / maxFreq);
  
          DeviceExtension->PerfStates->State[i].Flags = PROCESSOR_STATE_TYPE_THROTTLE;
  
          freq -= stepFreq;
      }
  }

InitializeAcpi1TStatesExit:

  return status;
  
}


UCHAR
GetNumThrottleSettings(
    IN PFDO_DATA DeviceExtension
    )
{
    PAGED_CODE();

    if (HalpFixedAcpiDescTable.duty_width &&
        DeviceExtension->ProcObjInfo.PBlkLength &&
        DeviceExtension->ProcObjInfo.PBlkAddress &&
        Globals.SingleProcessorProfile) {

        //
        // Only do throttling if the machine claims to support it.
        // Currently we only support throttling on UP machines.
        //

        return 1 << HalpFixedAcpiDescTable.duty_width;

    } else {

        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\procsym\procsym.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    halsym.c

--*/

#include "processor.h"

FDO_DATA fdodata;

int cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\p3\bios.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bios.c

Abstract:

    This module implements code to make BIOS calls

Author:

    Jake Oshins (3/18/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#include <ntddk.h>
#include "p3.h"
#include "ntacpi.h"

extern P3_GLOBALS P3_Globals;
extern PROCESSOR_STATE_INFO Coppermine100[];
extern PROCESSOR_STATE_INFO Coppermine133[];
extern PROCESSOR_STATE_INFO Tualatin100[];
extern PROCESSOR_STATE_INFO Tualatin133[];


ULONG StateFlags;
PPROCESSOR_STATE_INFO ProcessorStateInfo;
LEGACY_GEYSERVILLE_INT15 LegacyInterface;
const CHAR SignatureString[] = "Copyright (c) 1999 Intel Corporation";

NTSTATUS
AcpiFindRsdt (
  OUT PACPI_BIOS_MULTI_NODE *AcpiMulti
  );

__inline
ULONG
GetBusRatio (
  VOID
  );

__inline
BOOLEAN
Is133MhzBus (
  VOID
  );
  
NTSTATUS
GetMaxProcFrequencySMM (
  PULONG    MaxSpeed
  );
  

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeLegacyInterface)
#pragma alloc_text (PAGE, FindLegacyGeyservilleInterface)
#pragma alloc_text (PAGE, GetMaxProcFrequencySMM)
#pragma alloc_text (PAGE, GetCurrentStateSmm)
#pragma alloc_text (PAGE, SetCurrentSetupSmm)
#pragma alloc_text (PAGE, GetCurrentProcFrequency)
#pragma alloc_text (PAGE, GetBusRatio)
#pragma alloc_text (PAGE, GetLegacyMaxProcFrequency)
#pragma alloc_text (PAGE, CollectProcessorInfomation)
#endif


NTSTATUS
InitializeLegacyInterface (
  PLEGACY_GEYSERVILLE_INTERFACE_INFO Info,
  PFDO_DATA DeviceExtension
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

    NTSTATUS


--*/ 
{
    NTSTATUS status;
    ULONG    currentState;
    ULONG    smiCmdData = 0;
    ULONG    smiCmdPort = 0;
       
    DebugEnter();
    PAGED_CODE();

    //
    // Must be a Geyserville processor
    //
    
    status = CollectProcessorInfomation();

    if (!NT_SUCCESS(status)) {
      goto InitializeLegacyInterfaceExit;
    }

    DumpStateFlags(StateFlags);
    DebugPrint((MAXTRACE, "Bus Ratio == %u\n", GetBusRatio()));
    DebugPrint((MAXTRACE, "Ist Field == %u\n", P3_Globals.IstField));
    

    //
    // Check for Legacy Geyserville Interface override values.
    //
    
    GetRegistryDwordValue(P3_PARAMETERS_KEY, 
                          L"SmiCmdPort", 
                          &smiCmdPort);    

    GetRegistryDwordValue(P3_PARAMETERS_KEY, 
                          L"SmiCmdData", 
                          &smiCmdData);


    //
    // NOTE: if we have the SmiCmdData value but not the SmiCmdPort value, we
    //       could grab the SmiCmdPort value from HalpFixedAcpiDescTable->smi_cmd_io_port
    //

    
    //
    // If we already have both the SmiCmdPort and the SmiCmdData,
    // then we already have the data we need, otherwise copy INT 15 E820 
    // data to LegacyInterface structure...
    //

    if (!(smiCmdPort && smiCmdData)) {
      status = FindLegacyGeyservilleInterface();

      if (!NT_SUCCESS(status)) {
        goto InitializeLegacyInterfaceExit;
      }
    }
    
        
    if (smiCmdPort) {
      LegacyInterface.CommandPortAddress = (UCHAR) smiCmdPort;
      DebugPrint((INFO, "  Overriding SmiCommandPortAddress with registry value 0x%x\n", 
                 smiCmdPort));
    }

    if (smiCmdData) {
      LegacyInterface.CommandDataValue = (UCHAR) smiCmdData;
      DebugPrint((INFO, "  Overriding SmiCommandDataVale with registry value 0x%x\n", 
                 smiCmdData));
    }

    
    //
    // Set the Default Behavior for AC and DC
    //
    
    P3_Globals.MaxLevelAc = 0;
    P3_Globals.MaxLevelDc = 1;
    

    //
    // Check for INT 15 or Registy Flag overrides
    //

    if (LegacyInterface.Signature == 'GS') {

      //
      // If the values returned from the INT 15 Interface look
      // reasonable, use them, other wise we'll use the defaults.
      //
      
      if (LegacyInterface.MaxLevelAc < MAX_GEYSERVILLE_STATES) {
        P3_Globals.MaxLevelAc = LegacyInterface.MaxLevelAc;
      }

      if (LegacyInterface.MaxLevelDc < MAX_GEYSERVILLE_STATES) { 
        P3_Globals.MaxLevelDc = LegacyInterface.MaxLevelDc;
      }

      //
      // sanity check, some machines report this info incorrectly.
      //

      if (P3_Globals.MaxLevelAc > P3_Globals.MaxLevelDc) {
        P3_Globals.MaxLevelAc = P3_Globals.MaxLevelDc;
      }
      
    }

    
    if (P3_Globals.HackFlags & ENABLE_HIGH_SPEED_ON_BATTERY) {
      P3_Globals.MaxLevelDc = 0;
      DeviceExtension->PpcResult = 0;
    }

    
    //
    // Init the SMI Interface
    //
    
    status = InitializeSmmInterface();

    if (!NT_SUCCESS(status)) {

      //
      // found INT 15 interface or registry override values,
      // but were unable to Initialize SMM Interface, log error
      //
      
      QueueEventLogWrite(DeviceExtension, 
                         PROCESSOR_LEGACY_INTERFACE_FAILURE, 
                         0);

      
      
      goto InitializeLegacyInterfaceExit;
    }

    //
    // Find out more about what state we're in and what
    // states we can use.
    //

    status = GetCurrentStateSmm(Info);


InitializeLegacyInterfaceExit:

    DebugExitStatus(status);
    return status;
   
}

NTSTATUS
FindLegacyGeyservilleInterface (
  VOID
  )
/*++

  Routine Description:

    This routine looks in the registry to find out if Geyserville
    is supported on this system via Intel's SMI interface.  If
    so it collects information about how to use the interface.

  Arguments:
    
  Return Value:

    NTSTATUS

--*/ 
{
    PACPI_BIOS_MULTI_NODE     multiNode;
    PLEGACY_GEYSERVILLE_INT15 int15Info;
    NTSTATUS status;

    DebugEnter();
    PAGED_CODE();

    status = AcpiFindRsdt(&multiNode);

    if (!NT_SUCCESS(status)) {
      goto FindLegacyGeyservilleInterfaceExit;
    }

    //
    // Geyserville BIOS information is appended to the E820 entries.
    //
    
    int15Info = (PLEGACY_GEYSERVILLE_INT15)&(multiNode->E820Entry[multiNode->Count]);

    if (int15Info->Signature == 'GS') {

      //
      // This BIOS supports Geyserville.
      //
  
      RtlCopyMemory(&LegacyInterface, 
                    int15Info, 
                    sizeof(LEGACY_GEYSERVILLE_INT15));
      
      status = STATUS_SUCCESS;
      
    } else {
    
      status = STATUS_NOT_FOUND;

    }
    
    ExFreePool(multiNode);


FindLegacyGeyservilleInterfaceExit:

    DebugExitStatus(status);
    return status;
}

NTSTATUS
InitializeSmmInterface (
  VOID
  )
/*++

  Routine Description:

    This routine makes the first Geyserville SMI, enabling
    the other functions.

  Arguments:
    
  Return Value:

    NTSTATUS

--*/ 
{
    ULONG   regEax, regEbx, regEdx, returnCode;
    PHYSICAL_ADDRESS signatureAddr;
    
    //
    // Enable Geyserville SMM.
    //

    regEax = ('GSI' << 8) | LegacyInterface.CommandDataValue;
    regEbx = GeyservilleControl;
    regEdx = LegacyInterface.CommandPortAddress;

    signatureAddr = MmGetPhysicalAddress((PVOID)SignatureString);
    ASSERT(signatureAddr.QuadPart);

    _asm {
        mov     edx, regEdx
        mov     eax, regEax
        mov     ebx, regEbx
        mov     ecx, GeyservilleControlEnableApp
        mov     esi, signatureAddr.LowPart
        xor     edi, edi
        out     dx, al
        mov     returnCode, edi
    }

    if (returnCode == GeyservilleControlSuccessful) {
    
      return STATUS_SUCCESS;

    } else {

      DebugPrint((ERROR, "InitializeSmmInterface() Failed! rc=0x%x\n", returnCode));
      return STATUS_UNSUCCESSFUL;
    }

}


NTSTATUS
GetMaxProcFrequencySMM (
  PULONG MaxSpeed
  )
/*++

  Routine Description:

    This routine determines the maximun speed of the processor.

  Arguments:

    MaxSpeed - returned information
    
  Return Value:

    NTSTATUS

--*/ 
{
  LEGACY_GEYSERVILLE_INTERFACE_INFO info;
  NTSTATUS status;
  ULONG cpuSpeed;
  ULONG msrResult;
  ULONG busRatio;
 

  DebugEnter();
  PAGED_CODE();
  
  status = GetCurrentStateSmm(&info);

  if (!NT_SUCCESS(status)) {
    goto GetMaxProcFrequencySMMExit;
  }

  //
  // If we are in state 0, then just get current speed
  //
  // If we are in state 1:
  //   get current state's bin value
  //   add bin delta value
  //   convert bin value to Cpu Speed
  //


  //
  // High Volts
  //
  
  if (info.CurrentState == 0) {

    GetCurrentProcFrequency(0, &cpuSpeed);

  } else {

    ULONG binValue;
    ULONG newBinValue;
    ULONG index;
    
    //
    // Low Volts
    //

    DebugAssert(info.CurrentState == 1);


    //
    // Get Current Bin Value
    //

    busRatio = GetBusRatio();
    DebugPrint((MAXTRACE, "BusRatio == %u\n", busRatio));

    //
    // An error has occurred
    //
    
    if (busRatio >= PROC_STATE_INFO_SIZE) {
      DebugPrint((ERROR, "BusRatio invalid value = 0x%x\n", busRatio));
      DebugAssert(busRatio >= PROC_STATE_INFO_SIZE);
      return STATUS_UNSUCCESSFUL;
    }
    
    
    binValue = ProcessorStateInfo[busRatio].BinValue;
    DebugPrint((MAXTRACE, "BinValue == %u\n", binValue));

    newBinValue = binValue + P3_Globals.IstField;
    DebugPrint((MAXTRACE, "IstField == %u\n", P3_Globals.IstField));
    DebugPrint((MAXTRACE, "New BinValue == %u\n", newBinValue));


    cpuSpeed = FindCpuSpeedByBinValue(newBinValue, ProcessorStateInfo);
    DebugPrint((MAXTRACE, "Current CpuSpeed == %u\n", ProcessorStateInfo[busRatio].Frequency));
    DebugPrint((MAXTRACE, "Max CpuSpeed == %u\n", cpuSpeed));

  }

  
  if (ARGUMENT_PRESENT(MaxSpeed)) {
    DebugPrint((TRACE, "GetMaxProcFrequencySMM() returning %u Mhz\n", cpuSpeed));
    *MaxSpeed = cpuSpeed;
  }


GetMaxProcFrequencySMMExit:

  DebugExitStatus(status);
  return status;
  
}

NTSTATUS
GetCurrentStateSmm (
  PLEGACY_GEYSERVILLE_INTERFACE_INFO Info
  )
/*++

  Routine Description:

    This routine determines the current processor state.

  Arguments:

    Info    - returned information
    
  Return Value:

    NTSTATUS

--*/ 
{
    ULONG     regEax, regEbx, regEdx;
    ULONG     returnCode, currentState, interfaceInfo;
   
    PAGED_CODE();
    ASSERT(Info);

    
    //
    // GetGeyservilleStatus
    //

    regEax = ('GSI' << 8) | LegacyInterface.CommandDataValue;
    regEbx = GetGeyservilleStatus;
    regEdx = LegacyInterface.CommandPortAddress;

    _asm {
        mov     edx, regEdx
        mov     eax, regEax
        mov     ebx, regEbx
        xor     esi, esi
        xor     edi, edi
        out     dx, al
        mov     interfaceInfo, esi
        mov     returnCode, edi
        mov     currentState, ebx
    }
    
    //
    // Suck up the return values.
    //

    Info->CurrentState = currentState;
    Info->InterfaceMajorRev  = (UCHAR)(interfaceInfo >> 24);
    Info->InterfaceMinorRev  = (USHORT)((interfaceInfo >> 8) & 0xffff);
    Info->InterfaceReserved  = (UCHAR)(interfaceInfo & 0xff);
    Info->MaxSupportedStates = (UCHAR)(returnCode >> 24);
    Info->CurrentlyAvailableStates = (UCHAR)((returnCode >> 16) & 0xff);
    Info->CurrentBiosSettings = (UCHAR)(returnCode & 0xff);

    return STATUS_SUCCESS;
    
}

NTSTATUS
SetCurrentStateSmm (
  ULONG  NewState
  )
/*++

  Routine Description:

    This routine sets the current processor state.

  Arguments:

    NewState    - target state
    
  Return Value:

    STATUS_SUCCESS      - new state currently in use
    STATUS_NOT_FOUND    - new state unreachable
    STATUS_RETRY        - new state reachable, but this transition didn't work
    STATUS_UNSUCCESSFUL - hard error                      

--*/ 
{
    ULONG    regEax, regEbx, regEdx;
    ULONG    returnCode, currentState;
    static ULONG errorCount;

    if (NewState > 1) {
      DebugAssert((NewState == 0) || (NewState == 1));
      return STATUS_INVALID_PARAMETER;
    }
    
    
    //
    // SetGeyservilleState
    //

    regEax = ('GSI' << 8) | LegacyInterface.CommandDataValue;
    regEbx = SetGeyservilleState;
    regEdx = LegacyInterface.CommandPortAddress;

    _asm {
        mov     edx, regEdx
        mov     eax, regEax
        mov     ebx, regEbx
        mov     ecx, NewState
        xor     edi, edi
        out     dx, al
        mov     returnCode, edi
        mov     currentState, ebx
    }

    switch (returnCode) {

      case GeyservilleSetSuccessful:
        if (currentState != NewState) {
          DebugPrint((ERROR, "SetCurrentStateSmm(%u): BIOS ERROR: SMI returned"
                      " success with invalid current SpeedStep state = %u\n", 
                      NewState, 
                      currentState));
                      
          DebugAssert(currentState != NewState);
          return STATUS_INVALID_DEVICE_STATE;                  
        }
        return STATUS_SUCCESS;
        
      case GeyservilleStateUnavailable:
        return STATUS_NOT_FOUND;

      case GeyservilleUnsuccessfulTransition:
        return STATUS_RETRY;

      case GeyservilleAbortCritical:
        return STATUS_CANCELLED;
       
      case GeyservilleSetUnknownError:
        //DebugPrint((ERROR, "SetCurrentStateSmm() rc=GeyservilleSetUnknownError\n"));
        return STATUS_UNSUCCESSFUL;

      case GeyservilleTransitionUnavailable:
        return STATUS_PERF_TRANSITIONS_UNAVAILABLE;
        
      default:
        //DebugPrint((ERROR, "SetCurrentStateSmm() Unknown return code 0x%x\n", returnCode));
        return STATUS_UNSUCCESSFUL;
        
    }

}

NTSTATUS
SetCurrentSetupSmm (
  IN ULONG NewState
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

    NTSTATUS


--*/ 
{
    ULONG    regEax, regEbx, regEdx;
    ULONG    returnCode;

    PAGED_CODE();
    TRAP();

    //
    // SetGeyservilleSetup
    //

    regEax = ('GSI' << 8) | LegacyInterface.CommandDataValue;
    regEbx = SetGeyservilleSetup;
    regEdx = LegacyInterface.CommandPortAddress;

    _asm {
        mov     edx, regEdx
        mov     eax, regEax
        mov     ebx, regEbx
        mov     ecx, NewState
        xor     edi, edi
        out     dx, al
        mov     returnCode, edi
    }

    
    if (returnCode == 0) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_UNSUCCESSFUL;
    }
}


NTSTATUS
GetCurrentProcFrequency (
  IN  ULONG  State,
  OUT PULONG CpuSpeed
  )
/*++

  Description:
  
  Arguments:
      
  Return Value:

--*/
{
  ULONG cpuSpeed = 0;
   
  DebugAssert(CpuSpeed);
  UNREFERENCED_PARAMETER(State);
  PAGED_CODE();


  //
  // If this is a known Cpu, then we should be able
  // to use the tables for a fast look up.
  //
  
  if (P3_Globals.KnownCPUID) {

    ULONG index = GetBusRatio();

    if (index < PROC_STATE_INFO_SIZE) {
      cpuSpeed = ProcessorStateInfo[index].Frequency;
    }
    
  } 




  if (!cpuSpeed) {

    //
    // Something went wrong, and we weren't able to use the tables,
    // calculate by hand.
    //

    CalculateCpuFrequency(CpuSpeed);

  }


  *CpuSpeed = cpuSpeed;
  return STATUS_SUCCESS;
}


__inline
ULONG
GetBusRatio (
  VOID
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

   
--*/
{
  LARGE_INTEGER msrResult;
  ULONG busRatio;

  PAGED_CODE();
  
  //
  // Get Bus Ratio Value
  //
  
  msrResult.QuadPart = ReadMSR(MSR_2A);
  
  busRatio = msrResult.LowPart >> MSR_2A_BUS_RATIO_OFFSET;
  busRatio &= (BIT0+BIT1+BIT2+BIT3);

  //
  // This flag should be set on all 0x686 and newer cpu's
  //
  
  if (StateFlags & EXTENDED_BUS_RATIO) {
    if (msrResult.LowPart & MSR_2A_BUS_RATIO_MSB_BIT) {
      busRatio |= BIT4;
    }
  }

  return busRatio;
}


NTSTATUS
GetLegacyMaxProcFrequency(
  OUT PULONG CpuSpeed
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

    NTSTATUS


--*/ 
{
  static ULONG maxCpuSpeed;
  NTSTATUS status = STATUS_SUCCESS;

  DebugAssert(CpuSpeed);
  PAGED_CODE();

  //
  // if we have already calculated the max speed, use it
  //
  
  if (!maxCpuSpeed) {
    status = GetMaxProcFrequencySMM(&maxCpuSpeed); 
  }

  *CpuSpeed = maxCpuSpeed;
  return STATUS_SUCCESS;
}


NTSTATUS
CollectProcessorInfomation (
  VOID
  )
/*++

  Description:
    

  Arguments:
    
    
  Return Value:

    NTSTATUS


--*/ 
{
  LARGE_INTEGER msr17;
  LARGE_INTEGER msr2a;
  LARGE_INTEGER msr20;
  LARGE_INTEGER msr119;
  NTSTATUS status = STATUS_SUCCESS;
  ULONG cpuIdentifier;
  ULONG istField;
  ULONG platformId;
  ULONG junk;
  ULONG tmp;

  PAGED_CODE();
  

  //
  // Get CpuId
  //
  
  CPUID(1, &cpuIdentifier, &junk, &junk, &junk);

  //
  // Get MSR 0x17 results
  //

  msr17.QuadPart = ReadMSR(MSR_17);

  
  //
  // Check mobile bit, MSR 0x17[50] .. EDX[18]
  //
  
  if (!(msr17.HighPart & MSR_17_HIGH_MOBILE_PROCESSOR)) {

    DebugPrint((WARN, "This is NOT a Mobile Intel Processor\n"));
    status = STATUS_UNSUCCESSFUL;
    goto CollectProcessorInfomationExit;
    
  }


  //
  // Collect Bus Speed Information (MSR2A[19:18])
  // 0x1 == 133mhz Bus
  //
  
  msr2a.QuadPart = ReadMSR(MSR_2A);
  msr2a.LowPart >>= MSR_2A_BUS_SPEED_OFFSET;

  if ((msr2a.LowPart & (BIT0+BIT1)) == 0x1) {
    StateFlags |= BUS_133MHZ;
  }

    
  //
  // Collect Bin value Delta MSR17[57:56] .. EDX[25:24]
  //
  
  istField = (msr17.HighPart >> MSR_17_IST_FIELD_OFFSET) & (BIT0 + BIT1);


  //
  // Modify istField for specific processor steppings
  //

  //
  // If Tualatin Processor, we have to check the Stride bit MSR17[15].
  // If the Stride bit is set, add 5 to IST value, otherwise add 2
  //

  if ((cpuIdentifier & FAMILYMODEL_MASK) == FAMILYMODEL_TUALATIN) {

    StateFlags |= TUALATINE_PROCESSOR;
    StateFlags |= EXTENDED_BUS_RATIO;

    if (cpuIdentifier <= HIGHEST_KNOWN_TUALATIN_CPUID) {
      P3_Globals.KnownCPUID = TRUE;
    }


    //
    // Select the correct table
    //
    
    ProcessorStateInfo = (StateFlags & BUS_133MHZ) ? Tualatin133 : Tualatin100;

    

    //
    // Read MSR20h[15] "Stride fuse"
    //
    
    msr20.QuadPart = ReadMSR(MSR_20);
    istField += (msr20.LowPart & MSR_20_STRIDE_BIT) ? 5 : 2;
    
        
  } else if ((cpuIdentifier & FAMILYMODEL_MASK) == FAMILYMODEL_COPPERMINE) {


    StateFlags |= COPPERMINE_PROCESSOR;

    if (cpuIdentifier <= HIGHEST_KNOWN_COPPERMINE_CPUID) {
      P3_Globals.KnownCPUID = TRUE;
    }


    //
    // Select the correct table
    //

    ProcessorStateInfo = (StateFlags & BUS_133MHZ) ? Coppermine133 : Coppermine100;
    
    if (cpuIdentifier == 0x686) {
    
      //
      // C Stepping ...
      // For 0x686 we need to perform some magic based on the PlatformId bits,
      // possibly set bit 2 in istField
      //

      StateFlags |= EXTENDED_BUS_RATIO;
      platformId = (msr17.HighPart >> MSR_17_PLATFORM_ID_OFFSET) & (BIT0 + BIT1);
    
      if (platformId & BIT1) { 
  
        //
        // Componet Type
        //
  
        if (platformId & BIT0) {
          istField |= BIT2;
        }
        
      } else { 
      
        //
        // Module Type
        //
  
        if (!(platformId & BIT0)) {
          istField |= BIT2;
        }
    
      }
    
    } else if (cpuIdentifier > 0x686) {
    
      //
      // D Stepping ...
      // We need to set bit 2 in istField if MSR 0x119[0] is set 
      //

      StateFlags |= EXTENDED_BUS_RATIO;
      
      msr119.QuadPart = ReadMSR(MSR_119);
    
      if (msr119.LowPart & BIT0) {
        istField |= BIT2;
      }
      
    }

  } else {

    DebugAssert(!"Unknown Processor Family\n");
    StateFlags = 0;

  }
  

  //
  // Check to see if this processor is SpeedStep capable
  //
  
  if (!(istField & (BIT0 + BIT1 + BIT2 + BIT3 + BIT4))) {

    DebugPrint((WARN, "This processor is NOT SpeedStep capable.\n"));
    status = STATUS_UNSUCCESSFUL;
    goto CollectProcessorInfomationExit;

  }
  

  //
  // Save the IST
  //
  
  P3_Globals.IstField = istField;

    
CollectProcessorInfomationExit:

  DebugExitStatus(status);
  return status;
  
}


ULONG
FindCpuSpeedByBinValue (
  ULONG BinValue,
  PPROCESSOR_STATE_INFO Table
  )
{

  ULONG x;
  
  DebugAssert(Table);
    
  //
  // Walk tables looking for entry with matching bin value
  //

  for (x = 0; x < PROC_STATE_INFO_SIZE; x++) {

    if (Table[x].BinValue == BinValue) {
      return Table[x].Frequency;
    }
    
  }

  return 0;

}


VOID
DumpStateFlags (
  ULONG StateFlags
  )
{

  DebugPrint((MAXTRACE, "\n"));
  DebugPrint((MAXTRACE, "State Flags:\n"));
  DebugPrint((MAXTRACE, "  Coppermine Processor:  %s\n", (StateFlags & COPPERMINE_PROCESSOR) ? "Yes" : "No"));
  DebugPrint((MAXTRACE, "  Tualatine Processor:   %s\n", (StateFlags & TUALATINE_PROCESSOR) ? "Yes" : "No"));
  DebugPrint((MAXTRACE, "  133mhz Bus:            %s\n", (StateFlags & BUS_133MHZ) ? "Yes" : "No"));
  DebugPrint((MAXTRACE, "  Extended Bus Ratio     %s\n", (StateFlags & EXTENDED_BUS_RATIO) ? "Yes" : "No"));
  DebugPrint((MAXTRACE, "\n"));
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\p3\tables.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tables.c

Abstract:
   

Environment:

    Kernel mode

Notes:

Revision History:

--*/

#include "p3.h"

//
// State Flags
//

#define COPPERMINE_PROCESSOR   0x1
#define TUALATINE_PROCESSOR    0x2
#define BUS_133MHZ             0x4
#define EXTENDED_BUS_RATIO     0x8


//
// From the Geyserville BIOS Writer's guide, Chapter 2.
// The input is MSR2A[25:22] and MSR2A[27] in a Mobile PentiumIII.
// The output is the core frequency for a 100MHz front-side bus.
//

#define HIGHEST_KNOWN_COPPERMINE_CPUID 0x68A
#define HIGHEST_KNOWN_TUALATIN_CPUID   0x6B1

#define FAMILYMODEL_MASK         0x0FF0 // Mask for family/model codes.
#define FAMILYMODEL_COPPERMINE   0x0680 // Coppermine family/mode code.
#define FAMILYMODEL_TUALATIN     0x06B0 // Tualatin family/mode code.
#define EXTENDED_INFO_TYPE       0x0686 // CPUID of extended bus ratio support
#define EXTENDED_BIN_TYPE        0x068A // CPUID of extended bin support   


PROCESSOR_STATE_INFO Coppermine100[PROC_STATE_INFO_SIZE] = {

 {10, 500,  0}, // 0 - 500MHz @ 0.0W.
 {6,  300,  0}, // 1 - 300MHz @ 0.0W.
 {8,  400,  0}, // 2 - 400MHz @ 0.0W.
 {0,    0,  0}, // 3 - SAFE.
 {11,  550, 0}, // 4 - 550MHz @ 0.0W.
 {7,  350,  0}, // 5 - 350MHz @ 0.0W.
 {9,  450,  0}, // 6 - 450MHz @ 0.0W.
 {5,  250,  0}, // 7 - 250MHz @ 0.0W.
 {0,    0,  0}, // 8 - RESERVED.
 {14,  700, 0}, // 9 - 700MHz @ 0.0W.
 {16,  800, 0}, // 10 - 800MHz @ 0.0W.
 {12,  600, 0}, // 11 - 600MHz @ 0.0W.
 {0,    0,  0}, // 12 - SAFE.
 {15,  750, 0}, // 13 - 750MHz @ 0.0W.
 {0,    0,  0}, // 14 - RESERVED.
 {13,  650, 0}, // 15 - 650MHz @ 0.0W.
 {18,  900, 0}, // 16 - 900MHz @ 0.0W.
 {22, 1100, 0}, // 17 - 1100MHz @ 0.0W.
 {24, 1200, 0}, // 18 - 1200MHz @ 0.0W.
 {0,    0,  0}, // 19 - RESERVED.
 {19,  950, 0}, // 20 - 950MHz @ 0.0W.
 {23, 1150, 0}, // 21 - 1150MHz @ 0.0W.
 {17,  850, 0}, // 22 - 850MHz @ 0.0W.
 {0,    0,  0}, // 23 - RESERVED.
 {0,    0,  0}, // 24 - RESERVED.
 {0,    0,  0}, // 25 - RESERVED.
 {0,    0,  0}, // 26 - RESERVED.
 {20, 1000, 0}, // 27 - 1000MHz @ 0.0W.
 {0,    0,  0}, // 28 - RESERVED.
 {0,    0,  0}, // 29 - RESERVED.
 {0,    0,  0}, // 30 - RESERVED.
 {21, 1050, 0}  // 31 - 1050MHz @ 0.0W.

};

PROCESSOR_STATE_INFO Coppermine133[PROC_STATE_INFO_SIZE] = {

 {10,  667, 0}, // 0 - 667MHz @ 0.0W.
 {6,   400, 0}, // 1 - 400MHz @ 0.0W.
 {8,   533, 0}, // 2 - 533MHz @ 0.0W.
 {0,     0, 0}, // 3 - SAFE.
 {11,  733, 0}, // 4 - 733MHz @ 0.0W.
 {7,   466, 0}, // 5 - 466MHz @ 0.0W.
 {9,   600, 0}, // 6 - 600MHz @ 0.0W.
 {5,   333, 0}, // 7 - 533MHz @ 0.0W.
 {0,     0, 0}, // 8 - RESERVED
 {14,  933, 0}, // 9 - 933MHz @ 0.0W.
 {16, 1066, 0}, // 10 - 1066MHz @ 0.0W.
 {12,  800, 0}, // 11 - 800MHz @ 0.0W.
 {0,     0, 0}, // 12 - SAFE.
 {15, 1000, 0}, // 13 - 1000MHz @ 0.0W.
 {0,     0, 0}, // 14 - RESERVED.
 {13,  866, 0}, // 15 - 866MHz @ 0.0W.
 {18, 1200, 0}, // 16 - 1200MHz @ 0.0W.
 {22, 1466, 0}, // 17 - 1466MHz @ 0.0W.
 {24, 1600, 0}, // 18 - 1600MHz @ 0.0W.
 {0,     0, 0}, // 19 - RESERVED.
 {19, 1266, 0}, // 20 - 1266MHz @ 0.0W.
 {23, 1533, 0}, // 21 - 1533MHz @ 0.0W.
 {17, 1133, 0}, // 22 - 1133MHz @ 0.0W.
 {0,     0, 0}, // 23 - RESERVED.
 {0,     0, 0}, // 24 - RESERVED.
 {0,     0, 0}, // 25 - RESERVED.
 {0,     0, 0}, // 26 - RESERVED.
 {20, 1333, 0}, // 27 - 1333MHz @ 0.0W.
 {0,     0, 0}, // 28 - RESERVED.
 {0,     0, 0}, // 29 - RESERVED.
 {0,     0, 0}, // 30 - RESERVED.
 {21, 1400, 0}  // 31 - 1400MHz @ 0.0W.

};

PROCESSOR_STATE_INFO Tualatin100[PROC_STATE_INFO_SIZE] = {

 {10,  500, 0}, // 0 - 500MHz @ 0.0W.
 {6,   300, 0}, // 1 - 300MHz @ 0.0W.
 {8,   400, 0}, // 2 - 400MHz @ 0.0W.
 {0,     0, 0}, // 3 - SAFE.
 {11,  550, 0}, // 4 - 550MHz @ 0.0W.
 {7,   350, 0}, // 5 - 350MHz @ 0.0W.
 {9,   450, 0}, // 6 - 450MHz @ 0.0W.
 {0,     0, 0}, // 7 - RESERVED.
 {32, 1600, 0}, // 8 - 1600MHz @ 0.0W.
 {14,  700, 0}, // 9 - 700MHz @ 0.0W.
 {16,  800, 0}, // 10 - 800MHz @ 0.0W.
 {12,  600, 0}, // 11 - 600MHz @ 0.0W.
 {0,     0, 0}, // 12 - SAFE.
 {15,  750, 0}, // 13 - 750MHz @ 0.0W.
 {0,     0, 0}, // 14 - RESERVED.
 {13,  650, 0}, // 15 - 650MHz @ 0.0W.
 {18,  900, 0}, // 16 - 900MHz @ 0.0W.
 {22, 1100, 0}, // 17 - 1100MHz @ 0.0W.
 {24, 1200, 0}, // 18 - 1200MHz @ 0.0W.
 {0,     0, 0}, // 19 - RESERVED.
 {19,  950, 0}, // 20 - 950MHz @ 0.0W.
 {23, 1150, 0}, // 21 - 1150MHz @ 0.0W.
 {17,  850, 0}, // 22 - 850MHz @ 0.0W.
 {0,     0, 0}, // 23 - RESERVED.
 {0,     0, 0}, // 24 - RESERVED.
 {0,     0, 0}, // 25 - RESERVED.
 {26, 1300, 0}, // 26 - 1300MHz @ 0.0W.
 {20, 1000, 0}, // 27 - 1000MHz @ 0.0W.
 {28, 1400, 0}, // 28 - 1400MHz @ 0.0W.
 {0,     0, 0}, // 29 - RESERVED.
 {30, 1500, 0}, // 30 - 1500MHz @ 0.0W.
 {21, 1050, 0}  // 31 - 1050MHz @ 0.0W.

};

PROCESSOR_STATE_INFO Tualatin133[PROC_STATE_INFO_SIZE] = {

 {10,  667, 0}, // 0 - 667MHz @ 0.0W.
 {6,   400, 0}, // 1 - 400MHz @ 0.0W.
 {8,   533, 0}, // 2 - 533MHz @ 0.0W.
 {0,     0, 0}, // 3 - SAFE.
 {11,  733, 0}, // 4 - 733MHz @ 0.0W.
 {7,   466, 0}, // 5 - 466MHz @ 0.0W.
 {9,   600, 0}, // 6 - 600MHz @ 0.0W.
 {0,     0, 0}, // 7 - RESERVED.
 {32, 2133, 0}, // 8 - 21330MHz @ 0.0W.
 {14,  933, 0}, // 9 - 933MHz @ 0.0W.
 {16, 1066, 0}, // 10 - 1066MHz @ 0.0W.
 {12,  800, 0}, // 11 - 800MHz @ 0.0W.
 {0,     0, 0}, // 12 - SAFE.
 {15, 1000, 0}, // 13 - 1000MHz @ 0.0W.
 {0,     0, 0}, // 14 - RESERVED.
 {13,  866, 0}, // 15 - 866MHz @ 0.0W.
 {18, 1200, 0}, // 16 - 1200MHz @ 0.0W.
 {22, 1466, 0}, // 17 - 1466MHz @ 0.0W.
 {24, 1600, 0}, // 18 - 1600MHz @ 0.0W.
 {0,     0, 0}, // 19 - RESERVED.
 {19, 1266, 0}, // 20 - 1266MHz @ 0.0W.
 {23, 1533, 0}, // 21 - 1533MHz @ 0.0W.
 {17, 1133, 0}, // 22 - 1133MHz @ 0.0W.
 {0,     0, 0}, // 23 - RESERVED.
 {0,     0, 0}, // 24 - RESERVED.
 {0,     0, 0}, // 25 - RESERVED.
 {26, 1733, 0}, // 26 - 1733MHz @ 0.0W.
 {20, 1333, 0}, // 27 - 1333MHz @ 0.0W.
 {28, 1866, 0}, // 28 - 1866MHz @ 0.0W.
 {0,     0, 0}, // 29 - RESERVED.
 {30, 2000, 0}, // 30 - 2000MHz @ 0.0W.
 {21, 1400, 0}  // 31 - 1400MHz @ 0.0W.

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\p3\p3.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    p3.h

Abstract:

    This is included by every file in p3.sys

Author:

    Jake Oshins (3/21/00) - create file

Environment:

    Kernel mode

Notes:

Revision History:

--*/

#ifndef _P3_H_
#define _P3_H_

#include "..\lib\processor.h"
#include "..\eventmsg.h"

//
// Time defined in 100ns intervals
//

#define MICROSECOND        10
#define MILLISECOND        (MICROSECOND * 1000)
#define SECOND             (MILLISECOND * 1000)
#define MINUTE             (SECOND * 60)
    
#define STATUS_PERF_TRANSITIONS_UNAVAILABLE      MAXULONG
#define MAX_RETRY_TIMEOUT                        1800       // 30 minutes
#define MIN_RETRY_TIMEOUT                        1          // 1 second
#define DEFAULT_RETRY_TIMEOUT                    60         // 1 minute

//
// Registry location for p3.sys's parameters regkey 
//
                          
#define P3_PARAMETERS_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\P3\\Parameters"
#define ENABLE_LEGACY_SPEEDSTEP_INTERFACE   0x1
#define INTEL_APPLET_REMOVED_ON_UPGRADE     0x2
#define ENABLE_HIGH_SPEED_ON_BATTERY        0x4


//
// Geyserville defintions
//

#define MAX_GEYSERVILLE_STATES          2

#define BIT0                            0x1
#define BIT1                            0x2
#define BIT2                            0x4
#define BIT3                            0x8
#define BIT4                            0x10

#define MSR_17                          0x17
#define MSR_17_HIGH_MOBILE_PROCESSOR    0x40000    // bit 18
#define MSR_17_PLATFORM_ID_OFFSET       19
#define MSR_17_IST_FIELD_OFFSET         24

#define MSR_20                          0x20
#define MSR_20_STRIDE_BIT_OFFSET        15
#define MSR_20_STRIDE_BIT               (1 << MSR_20_STRIDE_BIT_OFFSET)

#define MSR_2A                          0x2A
#define MSR_2A_BUS_SPEED_OFFSET         18
#define MSR_2A_BUS_RATIO_OFFSET         22
#define MSR_2A_BUS_RATIO_MSB_BIT        0x8000000 // bit 27


#define MSR_119                         0x119


extern LEGACY_GEYSERVILLE_INT15    LegacyInterface;

//
// Array index is the Bus Ratio
//

#define PROC_STATE_INFO_SIZE    32

//
// State Flags
//

#define COPPERMINE_PROCESSOR   0x1
#define TUALATINE_PROCESSOR    0x2
#define BUS_133MHZ             0x4
#define EXTENDED_BUS_RATIO     0x8


//
// From the Geyserville BIOS Writer's guide, Chapter 2.
// The input is MSR2A[25:22] and MSR2A[27] in a Mobile PentiumIII.
// The output is the core frequency for a 100MHz front-side bus.
//

#define HIGHEST_KNOWN_COPPERMINE_CPUID 0x68A
#define HIGHEST_KNOWN_TUALATIN_CPUID   0x6B1

#define FAMILYMODEL_MASK         0x0FF0 // Mask for family/model codes.
#define FAMILYMODEL_COPPERMINE   0x0680 // Coppermine family/mode code.
#define FAMILYMODEL_TUALATIN     0x06B0 // Tualatin family/mode code.
#define EXTENDED_INFO_TYPE       0x0686 // CPUID of extended bus ratio support
#define EXTENDED_BIN_TYPE        0x068A // CPUID of extended bin support   


//
// This is put in ebx before a call.
//

typedef enum {
    GeyservilleControl,
    GetGeyservilleStatus,
    SetGeyservilleState,
    SetGeyservilleSetup
} LEGACY_GEYSERVILLE_CONTROL_CODES;

typedef enum {
    GeyservilleControlEnableApp,
    GeyservilleControlReserved,
    GeyservilleControlDisableApp
} LEGACY_GEYSERVILLE_CONTROL_SUBCODES;

typedef enum {
    GeyservilleControlSuccessful,
    GeyservilleDisabledInSetup,
    GeyservilleSystemNotCapable,
    GeyservilleDisabledByOS,
    GeyservilleInvalidSignature,
    GeyservilleUnknownError
} LEGACY_GEYSERVILLE_CONTROL_RETURN_CODES;

typedef enum {
    GeyservilleSetSuccessful,
    GeyservilleStateUnavailable,
    GeyservilleUnsuccessfulTransition,
    GeyservilleAbortCritical,
    GeyservilleSetUnknownError,
    GeyservilleTransitionUnavailable
} LEGACY_GEYSERVILLE_SET_RETURN_CODES;


typedef struct _LEGACY_GEYSERVILLE_INTERFACE_INFO {

    ULONG   CurrentState;
    UCHAR   InterfaceMajorRev;
    USHORT  InterfaceMinorRev;
    UCHAR   InterfaceReserved;
    UCHAR   MaxSupportedStates;
    UCHAR   CurrentlyAvailableStates;
    USHORT  CurrentBiosSettings;
    
} LEGACY_GEYSERVILLE_INTERFACE_INFO, *PLEGACY_GEYSERVILLE_INTERFACE_INFO;


typedef struct _P3_GLOBALS {

  ULONG   HackFlags;
  BOOLEAN KnownCPUID;
  LEGACY_GEYSERVILLE_INTERFACE_INFO LegacyInterfaceInfo;
  ULONG   MaxLevelAc;
  ULONG   MaxLevelDc;
  ULONG   IstField;
  BOOLEAN TransitionsUnavailable;
  KDPC    Dpc;
  KTIMER  Timer;
  LARGE_INTEGER TimeOut;

} P3_GLOBALS;


typedef struct _PROCESSOR_STATE_INFO {

  ULONG BinValue;
  ULONG Frequency;
  ULONG Power;

} PROCESSOR_STATE_INFO, *PPROCESSOR_STATE_INFO;



//
// bios.c
//

NTSTATUS
InitializeLegacyInterface (
    PLEGACY_GEYSERVILLE_INTERFACE_INFO Info,
    PFDO_DATA DeviceExtension
    );
    
NTSTATUS
FindLegacyGeyservilleInterface(
    VOID
    );

NTSTATUS
GetCurrentStateSmm(
    PLEGACY_GEYSERVILLE_INTERFACE_INFO Info
    );

NTSTATUS
SetCurrentStateSmm(
    ULONG   NewState
    );

NTSTATUS
SetCurrentSetupSmm(
    ULONG   NewState
    );
    
NTSTATUS
InitializeSmmInterface(
    VOID
    );

NTSTATUS
GetCurrentProcFrequency (
  IN  ULONG  State,
  OUT PULONG CpuSpeed
  );

NTSTATUS
CollectProcessorInfomation (
  VOID
  );

ULONG
FindCpuSpeedByBinValue (
  ULONG BinValue,
  PPROCESSOR_STATE_INFO Table
  );

NTSTATUS
AdjustLegacyProcessorPerformanceStates(
  IN OUT PACPI_PSS_PACKAGE PssPackage
  );

NTSTATUS
ProcessSleepStateNotification (
  IN POWER_STATE_HANDLER_TYPE  State,
  IN PVOID Context,
  IN BOOLEAN Entering
  );


VOID
DumpStateFlags (
  ULONG StateFlags
  );


VOID 
P3TimerDpcHandler ( 
    IN PKDPC Dpc, 
    IN PVOID DeferredContext, 
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 
    );

  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\procsym\sources.inc ===
TARGETTYPE=NOTARGET
TARGETPATH=obj

INCLUDES=\
    ..;\
    ..\..\lib;\
    $(DDK_INC_PATH)\wdm; \
    $(DDK_INC_PATH);\
    $(PROCESSORKIT_INC_PATH)
    

SOURCES=..\procsym.c

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\i386\throttle.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    throttle.c

Abstract:

    This module implements the code for throttling the processors

Author:

    Jake Oshins (jakeo) 17-July-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "processor.h"


//
// ACPI Register definitions
//

#define PBLK_THT_EN     0x10

extern ULONG    HalpThrottleScale;
extern UCHAR    HalpPiix4;
extern FADT     HalpFixedAcpiDescTable;
extern ULONG    HalpPiix4SlotNumber;
extern ULONG    HalpPiix4DevActB;
extern ULONG    Piix4ThrottleFix;

extern GEN_ADDR PCntAddress;
extern GEN_ADDR C2Address;
extern GEN_ADDR PBlkAddress;

#define PIIX4_THROTTLE_FIX 0x10000

VOID
FASTCALL
ProcessorThrottle (
    IN UCHAR Throttle
    )
/*++

Routine Description:

    This function limits the speed of the processor.

Arguments:

    (ecx) = Throttle setting

Return Value:

    none

--*/
{
    ULONG       ThrottleSetting;
    ULONG       Addr;
    ULONG       Mask;
    ULONG       i;

    //
    // Sanity check that we can do ACPI 1.0 throttling.
    //

    DebugAssert(PCntAddress.AddressSpaceID == AcpiGenericSpaceIO);
    DebugAssert((Globals.SingleProcessorProfile == FALSE) ? (HalpPiix4 == 0) : TRUE);
    DebugAssert(Throttle <= (1 << HalpFixedAcpiDescTable.duty_width));


    //
    // Get current throttle setting.
    //

    ThrottleSetting = ReadGenAddr(&PCntAddress);

    if (Throttle == HalpThrottleScale) {

        //
        // If this is a piix4 and we're no longer going to
        // throttle, set the break events (a piix4 thing) to
        // get any interrupt to wake a C2 to C3 stopped
        // processor.  (note that piix4 can only be set on a
        // UP system).  Then clear the bit to allow C2 and C3
        // idle handlers to work again.
        //

        if (HalpPiix4 == 1) {
        
            HalSetBusDataByOffset(PCIConfiguration,
                                  HalpPiix4SlotNumber >> 16,
                                  HalpPiix4SlotNumber & 0xffff,
                                  &HalpPiix4DevActB,
                                  0x58,
                                  sizeof (ULONG));

            InterlockedExchange(&Piix4ThrottleFix, 0);
            PBlkAddress.Address.LowPart &= ~PIIX4_THROTTLE_FIX;
        }

        //
        // Throttling is off
        //

        ThrottleSetting &= ~PBLK_THT_EN;
        WriteGenAddr(&PCntAddress, ThrottleSetting);

    } else {

        //
        // Throttling is on.
        //

        if (HalpPiix4 == 1) {

            //
            // These piix4's have the thottle setting backwards, so
            // invert the value
            //

            Throttle = (UCHAR) HalpThrottleScale - Throttle;


            //
            // Piix4 will hang on a high throttle setting, so make
            // sure we don't do that
            //

            if (Throttle < 3) {
                Throttle = 3;
            }

        }

        //
        // Shift the throttle and build a mask to be in the proper location
        // for this platform
        //

        Throttle = Throttle << HalpFixedAcpiDescTable.duty_offset;
        Mask = (HalpThrottleScale - 1) << HalpFixedAcpiDescTable.duty_offset;

        //
        // Set the rate
        //

        ThrottleSetting &= ~Mask;
        ThrottleSetting |= Throttle | PBLK_THT_EN;

        WriteGenAddr(&PCntAddress, ThrottleSetting);

        //
        // If this is a piix4 we need to disable all the break events
        // (a piix4 thing) and then read the level2 processor stop
        // register to get it to start throttling.  Oh yes, also set
        // the bit in the Paddr to stop doing C2 & C3 stops at the
        // same time.
        //

        if (HalpPiix4 == 1) {

            InterlockedExchange(&Piix4ThrottleFix, 1);
            PBlkAddress.Address.LowPart |= PIIX4_THROTTLE_FIX;

            i = HalpPiix4DevActB & ~0x23;
            HalSetBusDataByOffset (
                PCIConfiguration,
                HalpPiix4SlotNumber >> 16,
                HalpPiix4SlotNumber & 0xffff,
                &i,
                0x58,
                sizeof(ULONG)
                );

            ReadGenAddr(&C2Address);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\p3\p3.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    p3.c

Abstract:

    This module implements code specific to the PentiumIII processor

Author:

    Jake Oshins (3/21/00) - create file

Environment:

    Kernel mode

Notes:

  DeviceInst  = "ACPI\GenuineIntel_-_x86_Family_6_Model_8"
  ServiceName = "P3"

Revision History:

--*/
#include "p3.h"
#include "..\lib\processor.h"

#if DBG
PUCHAR DebugName = "P3.sys";
#endif

PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
UCHAR DevExtIndex;
P3_GLOBALS P3_Globals;

extern ULONG   HalpThrottleScale;
extern GLOBALS Globals;
extern LEGACY_GEYSERVILLE_INT15 LegacyInterface;

VOID
AcpiNotify80CallbackWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
UpdateAcDcMaxLevel(
    IN PVOID   Context,
    IN BOOLEAN AC
  );

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeDriver)
#pragma alloc_text (PAGE, InitializeNonAcpiPerformanceStates)
#pragma alloc_text (PAGE, InitializeAcpi2PStates)
#pragma alloc_text (PAGE, InitializeAcpi2Cstates)
#pragma alloc_text (PAGE, MergePerformanceStates)
#pragma alloc_text (PAGE, AdjustLegacyProcessorPerformanceStates)
#pragma alloc_text (PAGE, GetProcessorBrandString)
#endif
NTSTATUS
InitializeDriver(
  PUNICODE_STRING ServiceKeyRegPath
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{


  //
  // Get P3 Hack Flags
  //

  GetRegistryDwordValue((PWCHAR) P3_PARAMETERS_KEY, 
                        L"HackFlags", 
                        &P3_Globals.HackFlags);



  //
  // Setup Timer Dpc Thread, this is not MP safe.
  //
  
  if (Globals.SingleProcessorProfile) {

    LONG timeOutSeconds = 0;
  
    //
    // Initialize CustomTimerDpc
    //
  
    KeInitializeDpc(&P3_Globals.Dpc, P3TimerDpcHandler, NULL);
    KeInitializeTimer(&P3_Globals.Timer);


    //
    // Get tranistion timeout value from Registry
    //
  
    GetRegistryDwordValue((PWCHAR) P3_PARAMETERS_KEY, 
                          L"RetryTimeOut", 
                          &timeOutSeconds);
  
 
    if (timeOutSeconds) {

      //
      // Validate timeout values
      //
      
      timeOutSeconds = MIN(timeOutSeconds, MAX_RETRY_TIMEOUT);
      timeOutSeconds = MAX(timeOutSeconds, MIN_RETRY_TIMEOUT);
      

    } else {

      //
      // Set default 1 minute timeout
      //

      timeOutSeconds = DEFAULT_RETRY_TIMEOUT;
    
    }

    
    P3_Globals.TimeOut.QuadPart = -(timeOutSeconds * SECOND);


    // tmp debug
    DebugPrint((ERROR, "Using TimeOutRetry value of %d minutes (%d seconds)\n", 
               timeOutSeconds/60,
               timeOutSeconds));
     
  }
  
  return STATUS_SUCCESS;
}
NTSTATUS
InitializeNonAcpiPerformanceStates(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:

    This function tries to gather as much information as it can about what
    states are available.  It puts a table in the device extension that
    describes the available states.  Unfortunately, we might not have enough
    information to fill in the state table, as the BIOS doesn't tell us much.
    We try to run through all the states, figuring out what we can about them
    as we pass through them.  But some states may not be available at the
    moment, particularly if we are running on DC power at the moment.  So some
    states may have zeros in the table.

  Arguments:

   FdoData - pointer to the device extension

  Return Value:

    NT status code


--*/
{
  LARGE_INTEGER   startTime; 
  LARGE_INTEGER   endTime;
  LARGE_INTEGER   perfFreq;
  ULONG           newState;
  ULONG           currentFreq;
  ULONG           pssSize;
  ULONG           latency;
  NTSTATUS        status;
  PLEGACY_GEYSERVILLE_INTERFACE_INFO info = &P3_Globals.LegacyInterfaceInfo;

  DebugEnter();
  PAGED_CODE();

  //
  // We automatically fail to use the Legacy Interface
  //
  
  if (Globals.HackFlags & DISABLE_LEGACY_INTERFACE_FLAG) {
    DebugPrint((ERROR, " Legacy Interface Disabled\n"));
    return STATUS_NOT_FOUND;
  }


  //
  // Check hack flags to see if we should use the Legacy interface.
  //

  if (!(P3_Globals.HackFlags & ENABLE_LEGACY_SPEEDSTEP_INTERFACE)) {
    status = STATUS_NOT_FOUND;
    DebugPrint((WARN, "  Legacy Interface NOT enabled in P3\\parameters\\HackFlags.\n"));
    DebugExitStatus(status);
    return status;
  }


  //
  // Find and gather legacy interface info
  //

  status = InitializeLegacyInterface(info, DevExt);

  if (!NT_SUCCESS(status)) {
    DebugExitStatus(status);
    return status;
  }

  
  if (!info->CurrentlyAvailableStates) {

    status = STATUS_NOT_FOUND;
    DebugPrint((ERROR, "  Found Legacy Interface, but no perfstates.\n"));
    DebugExitStatus(status);
    return status;

  } else if (info->CurrentlyAvailableStates > MAX_GEYSERVILLE_STATES) {

    status = STATUS_NOT_FOUND;
    DebugPrint((ERROR, "  Found Legacy Interface. Error: %u PerfStates defined\n",
                info->CurrentlyAvailableStates));
    DebugExitStatus(status);
    return status;
  }

  //
  // Found Legacy Interface, and is available to use.
  //

  DevExt->LegacyInterface = TRUE;

 
  //
  // Allocate enough space for 2 perf states.
  //
  
  pssSize = sizeof(ACPI_PSS_PACKAGE) + sizeof(ACPI_PSS_DESCRIPTOR);
  DevExt->PssPackage = ExAllocatePoolWithTag(NonPagedPool,
                                             pssSize,
                                             PROCESSOR_POOL_TAG);


  if (!DevExt->PssPackage) {
    status = STATUS_INSUFFICIENT_RESOURCES;
    goto InitalizeNonAcpiPerformanceStatesExit;
  }
                                               
  RtlZeroMemory(DevExt->PssPackage, pssSize);

  DevExt->PssPackage->NumPStates = MAX_GEYSERVILLE_STATES;
  
  
  //
  // Jump through each state so that we can figure out how to fill in
  // the table.  Start by jumping to the low state.
  //

  DebugPrint((INFO, "Perf States available: 0x%x  Current State: 0x%x\n",
              info->CurrentlyAvailableStates,
              info->CurrentState));
              
  
  //
  // Get Perf Counter Frequency
  //
  
  KeQueryPerformanceCounter(&perfFreq);


  //
  // Fill out the _PSS for first state, opposite of the current state
  // 
  
  newState = info->CurrentState ? 0 : 1;
  
  startTime = KeQueryPerformanceCounter(NULL);
  status = AcpiPerfStateTransition(DevExt, newState);
  endTime = KeQueryPerformanceCounter(NULL);
  
  if (!NT_SUCCESS(status)) {
    QueueEventLogWrite(DevExt, PROCESSOR_INIT_TRANSITION_FAILURE, newState);
    goto InitalizeNonAcpiPerformanceStatesExit;
  }
  
  
  //
  // Calculate latency, speed, & power
  //
  
  latency = (ULONG)((endTime.QuadPart - startTime.QuadPart) * 1000000 / perfFreq.QuadPart);
  DevExt->PssPackage->State[newState].Latency = latency;
    
  GetCurrentProcFrequency(newState, &currentFreq);
  DevExt->PssPackage->State[newState].CoreFrequency = currentFreq;
  DevExt->PssPackage->State[newState].Power = currentFreq * 16;
  
  DebugPrint((INFO, "Jumped to state 0x%x in %d us\n", newState, latency));

  
  //
  // Jump back to orginal state
  //

  newState = info->CurrentState;
  
  startTime = KeQueryPerformanceCounter(NULL);
  status = AcpiPerfStateTransition(DevExt, newState);
  endTime = KeQueryPerformanceCounter(NULL);
  
  if (!NT_SUCCESS(status)) {
    QueueEventLogWrite(DevExt, PROCESSOR_INIT_TRANSITION_FAILURE, newState);
    goto InitalizeNonAcpiPerformanceStatesExit;
  }
  
  
  //
  // Calculate latency, speed, & power
  //
  
  latency = (ULONG)((endTime.QuadPart - startTime.QuadPart) * 1000000 / perfFreq.QuadPart);
  DevExt->PssPackage->State[newState].Latency = latency;
    
  GetCurrentProcFrequency(newState, &currentFreq);
  DevExt->PssPackage->State[newState].CoreFrequency = currentFreq;
  DevExt->PssPackage->State[newState].Power = currentFreq * 16;
  
  DebugPrint((INFO, "Jumped to state 0x%x in %d us\n", newState, latency));

  
  //
  // NOTE: This is a work around because the Policy Manager won't set our
  // low perf state to POP_THROTTLE_NON_LINEAR if we use the above algothrim,
  // because it makes each of our states very linear.  In Acpi 2.0, this
  // information is given to us in the _PSS, but for legacy perfstates, we
  // have to make it up.
  //

  AdjustLegacyProcessorPerformanceStates(DevExt->PssPackage);

  
  //
  // Sanity Check the two states.
  //

  DebugAssert(DevExt->PssPackage->State[0].CoreFrequency >
              DevExt->PssPackage->State[1].CoreFrequency);


  //
  // Merge Perf states with other states we may have.
  //

  status = MergePerformanceStates(DevExt);

  if(!NT_SUCCESS(status)) {
   goto InitalizeNonAcpiPerformanceStatesExit;
  }
  
  // 
  // Register for power state change notification so we can re-init the
  // legacy interface when resuming from S4
  //
  
  status = PowerStateHandlerNotificationRegistration(ProcessSleepStateNotification,
                                                     NULL,
                                                     TRUE);

  //
  // If the max state avaiablable on Ac & Dc is different, then
  // register for AC<->DC transition notification.
  //

  if (P3_Globals.MaxLevelAc != P3_Globals.MaxLevelDc) {
    RegisterAcDcTransitionNotifyHandler(UpdateAcDcMaxLevel, (PVOID) DevExt);
  }

  
InitalizeNonAcpiPerformanceStatesExit:

  if (!NT_SUCCESS(status)) {

    if (DevExt->PssPackage) {
      ExFreePool(DevExt->PssPackage);
    }

    DevExt->PssPackage = NULL;
    DevExt->LegacyInterface = FALSE;
  }

  DebugExitStatus(status);
  return status;
}
NTSTATUS
AcpiLegacyPerfStateTransition(
  IN PFDO_DATA    DeviceExtension,
  IN ULONG        State
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
#define TRANSITION_RETRY_VALUE  1000

  NTSTATUS status;
  ULONG    x;

  //
  // Performance Transitions are currently unavailable.
  //
  
  if (P3_Globals.TransitionsUnavailable) {
    return STATUS_UNSUCCESSFUL;
  }

    
  //
  // Adjust the actual state value.
  //
  
  State += DeviceExtension->PpcResult;


  //
  // Attempt transition
  //


  for (x = 0; x < TRANSITION_RETRY_VALUE; x++) {

    status = SetCurrentStateSmm(State);


    if (NT_SUCCESS(status) || (status == STATUS_PERF_TRANSITIONS_UNAVAILABLE)) {

      break;

    } else if (status == STATUS_INVALID_DEVICE_STATE) {

      status = STATUS_SUCCESS;
      break;
    }
    
  }


  if (x) {
    DebugPrint((WARN, "SetCurrentStateSmm() Failed %u of 1000 retries\n", x));
  }


  if (status == STATUS_PERF_TRANSITIONS_UNAVAILABLE) {

    // tmp debug
    DebugPrint((ERROR, "SetCurrentStateSmm() failed STATUS_PERF_TRANSITIONS_UNAVAILABLE\n"));
    DebugPrint((ERROR, "*** Disabling Transitions\n"));
  
    //
    //  Transitions are no longer available.
    //

    P3_Globals.TransitionsUnavailable = TRUE;
    

    //
    // Set timer to launch DPC thread
    //

    KeSetTimer(&P3_Globals.Timer, P3_Globals.TimeOut, &P3_Globals.Dpc);


    status = STATUS_UNSUCCESSFUL;
  }

  
  return status;
}
NTSTATUS
FASTCALL
SetPerfLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();


  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }
  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetPerfLevelGeneric(Throttle, DeviceExtension);

}

NTSTATUS
FASTCALL
SetThrottleLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();

  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }

  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];
  

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetThrottleLevelGeneric(Throttle, DeviceExtension);

}
NTSTATUS
InitializeAcpi2PStates(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:
 

  Arguments:
  

  Return Value:


--*/
{
  NTSTATUS status;

  status = InitializeAcpi2PStatesGeneric(DevExt);

  //
  // Make sure we didn't find any NON I/O or MEM addresses
  //
  
  if (NT_SUCCESS(status)) {
  
    if (((DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceIO) &&
         (DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceMemory)) ||
        ((DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceIO) &&
         (DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceMemory))) {

      DebugPrint((WARN, "ONLY Memory & I/O _PCT addresses are supported\n"));
      DebugPrint((WARN, "NOT using Acpi 2.0 Performance States\n"));

      //
      // Undo what InitializeAcpi2PStatesGeneric() did
      //

      if (DevExt->PssPackage) {
        ExFreePool(DevExt->PssPackage);
        DevExt->PssPackage = NULL;
      }
      
      return STATUS_NOT_SUPPORTED;
    }




    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DevExt);

    //
    // Need to merge this new data with our perfstates
    //
  
    MergePerformanceStates(DevExt);

  }

  return status;
}

NTSTATUS
InitializeAcpi2Cstates(
  PFDO_DATA  DevExt
  )
/*++

  Routine Description:

      This function looks to see if there is an ACPI 2.0 _CST object in the
      namespace, and, if there is, it replaces the functions found by
      InitializeAcpi1Cstates.

      Further note:  This function leaves the filling in of throttling functions
      to the InitializePerformanceStates functions.

  Arguments:

      DeviceExtension

  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

--*/
{
  ULONG  apicId;
  ULONG  index = 0;

  DebugEnter();

  
  //
  // Record the address of this processor's DeviceExtension, as the
  // throttling API doesn't give it to us.
  //

  if (!Globals.SingleProcessorProfile) {

    //
    // save the index into the DeviceExtension[] for later retrieval based
    // on APIC Id.
    //
                
    apicId = Globals.ProcInfo.ProcIdToApicId[DevExt->ProcObjInfo.PhysicalID];  
    Globals.ProcInfo.ApicIdToDevExtIndex[apicId] = DevExtIndex;
               
    index = DevExtIndex++;
    
  }

  
  //
  // save Device Extension pointer
  //

  DebugAssert(DeviceExtensions[index] == 0);
  DeviceExtensions[index] = DevExt;
  


  //
  //  This processor driver only supports I/O Space based Cstates.
  //  InitializeAcpi2IoSpaceCstates() will fail if it finds Cstates with
  //  non AcpiGenericSpaceIO type addresses.
  //

  return InitializeAcpi2IoSpaceCstates(DevExt);

}

NTSTATUS
MergePerformanceStates (
  IN  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:

      This routine looks at the performance states stored in the device extension.

  Arguments:

      DeviceExtension


  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

  NOTE:

      - The caller must hold PerfStateLock.

      - This is called during START_DEVICE, and after recieving a Notify(0x80)
        on the processor.

--*/
{

  DebugEnter();

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return MergePerformanceStatesGeneric(DeviceExtension);

}
NTSTATUS
Acpi2PerfStateTransition(
  IN PFDO_DATA DeviceExtension,
  IN ULONG     State
  )
/*++

Routine Description:

    This routine changes the performance state of the processor
    based on ACPI 2.0 performance state objects.

Arguments:

    State - Index into _PSS object

Return Value:

    none

--*/
{

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return Acpi2PerfStateTransitionGeneric(DeviceExtension, State);

}
NTSTATUS
AdjustLegacyProcessorPerformanceStates(
  IN OUT PACPI_PSS_PACKAGE PssPackage
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugAssert(PssPackage->NumPStates <= 2)
  PssPackage->State[0].Power = PssPackage->State[0].CoreFrequency * 50;

  return STATUS_SUCCESS;
}
NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();

  //
  // if we are resuming from Hibernate, and this is an Acpi 2.0 system,
  // we must re-claim perf state and cstate control from the bios.
  //

  if (PreviousState == PowerSystemHibernate) {

    if (DeviceExtension->PssPackage) {
      AssumeProcessorPerformanceControl();
    }
    
    if (DeviceExtension->CstPresent) {
      AssumeCStateControl();
    }
    
  }

  //
  // restore previous state
  //

  return RestoreToSavedPerformanceState(DeviceExtension);

}
NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{ 
  DebugEnter();

  //
  // save current state, transition to lowest non-throttled perf state
  //

  return SaveCurrentStateGoToLowVolts(DeviceExtension);
}
NTSTATUS
ProcessSleepStateNotification (
  IN POWER_STATE_HANDLER_TYPE  State,
  IN PVOID Context,
  IN BOOLEAN Entering
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  NTSTATUS  status = STATUS_SUCCESS;
  PFDO_DATA DeviceExtension;

  DebugEnter();

  //
  // Currently we only support this for single proc machines.
  //
  
  if (Globals.SingleProcessorProfile) {
    
    //
    // Get the DeviceExtension.
    //
  
    DeviceExtension = DeviceExtensions[0];
  
     
    //
    // if we are resuming from Hibernate on a system using the legacy Geyserville
    // interface, we need to reinit the interface
    //
  
    if (!Entering && (State == PowerStateSleeping4)) {
 
      //
      // Initialize Throttle States to "Throttle off"
      //
      
      if (HalpThrottleScale) {  
        ProcessorThrottle((UCHAR)HalpThrottleScale);
      }


      if (DeviceExtension->LegacyInterface) {
      
        status = InitializeSmmInterface();
    
        if (!NT_SUCCESS(status)) {
  
          //
          // Log event
          //
          
          QueueEventLogWrite(DeviceExtension, 
                             PROCESSOR_REINITIALIZATION_FAILURE, 
                             0);
          
          DebugPrint((ERROR, "ProcessSleepStateNotification: InitializeSmmInterface() Failed! rc=0x%x\n",
                     status));
      
        }
      }
    }
  }
  
  return status;
}
NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  )
/*++

  Routine Description:
  
     
  Arguments:
    
  
  Return Value:

--*/
{
#define CPUID_BRAND_STRING_LENGTH  49

  PUCHAR tmpPtr;
  ULONG  tmp;
  ULONG  brandIndex;
  ULONG  cpuId;
  NTSTATUS status;

  DebugAssert(Size);
  PAGED_CODE();


  //
  // check incoming buffer size, the most we will need is CPUID_BRAND_STRING_LENGTH
  //

  if (!BrandString || (*Size < CPUID_BRAND_STRING_LENGTH)) {
  
    *Size = CPUID_BRAND_STRING_LENGTH;
    return STATUS_BUFFER_TOO_SMALL;
  }


  //
  // First we will check to see if this processor supports
  // brand strings
  //

  status = GetCPUIDProcessorBrandString(BrandString, Size);

  if (NT_SUCCESS(status)) {
    return status;
  }
  

  CPUID(1, &cpuId, &brandIndex, &tmp, &tmp);
  brandIndex &= 0xf;


  //
  // NOTE: these strings CANNOT exceed CPUID_BRAND_STRING_LENGTH in size
  //       or the above code must change
  //
  
  switch (brandIndex) {

    case 0x1:
      tmpPtr = "Intel(r) Celeron(r) processor";
      break;
      
    case 0x2:
      tmpPtr = "Intel(r) Pentium(r)III processor";
      break;

    case 0x3:

      if (cpuId == 0x6B1) {
        tmpPtr = "Intel(r) Celeron(r) processor";
      } else {
        tmpPtr = "Intel(r) Pentium(r)III Xeon(tm) processor";
      }
      break;

    case 0x4:
      tmpPtr = "Intel(r) Pentium(r)III processor";
      break;

    case 0x6:
      tmpPtr = "Mobile Intel(r) Pentium(r)III Processor-M";
      break;

    case 0x7:
      tmpPtr = "Mobile Intel(r) Celeron(r) processor";
      break;

    case 0x8:

      if (cpuId >= 0xF20) {
        tmpPtr = "Intel(r) Genuine processor";
      } else {
        tmpPtr = "Intel(r) Pentium(r)4 processor";
      }
      break;

    case 0x9:
      tmpPtr = "Intel(r) Pentium(r)4 processor";
      break;

    case 0xA:
      tmpPtr = "Intel(r) Xeon(tm) processor";
      break;

    case 0xE:
      tmpPtr = "Intel(r) Xeon(tm) processor";
      break;
      
    default:
      return STATUS_NOT_SUPPORTED;
      
  }


  //
  // Copy string to buffer
  //
  
  strncpy(BrandString, tmpPtr, strlen(tmpPtr) + 1);
  
  return STATUS_SUCCESS;
}
NTSTATUS
UpdateAcDcMaxLevel(
  IN PVOID   Context,
  IN BOOLEAN AC
  )
/*++

  Routine Description:
     
  Arguments:
  
  Return Value:

--*/
{
  ULONG newPpc;
  PFDO_DATA devExt = Context;

  //
  // We only do this when using the Legacy SpeedStep interface
  //
  
  if (devExt->LegacyInterface &&
      devExt->PssPackage) {
 
    newPpc =  AC ? P3_Globals.MaxLevelAc : P3_Globals.MaxLevelDc;  

    //
    // if the Max state currently available has changed, then
    // we will rebuilt the states.
    //
    
    if (devExt->PpcResult != newPpc) {

      DebugPrint((ERROR, "UpdateAcDcMaxLevel: New _PPC = %u\n", newPpc));
      
      devExt->PpcResult = newPpc;
      AcpiNotify80CallbackWorker(devExt->Self, 
                                 NULL);
      
    }
    
  }

  return STATUS_SUCCESS;
}
VOID 
P3TimerDpcHandler ( 
    IN PKDPC Dpc, 
    IN PVOID DeferredContext, 
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 
    )
{

  // tmp debug
  DebugPrint((ERROR, "*** Re-enabling Transitions\n"));
  
  //
  // Re-enable transitions
  //
  
  P3_Globals.TransitionsUnavailable = FALSE; 
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\lib\i386\util.c ===
/*++

Copyright(c) 1998  Microsoft Corporation

Module Name:

    util.c

Abstract:

    misc routines.

Author:

    Todd Carpenter

Environment:

    kernel mode


Revision History:

    12-05-00 : created, toddcar

--*/
#include "processor.h"



#define MAX_ATTEMPTS 10

struct {
  
    LARGE_INTEGER   PerfStart;
    LARGE_INTEGER   PerfEnd;
    LONGLONG        PerfDelta;
    LARGE_INTEGER   PerfFreq;
    LONGLONG        TSCStart;
    LONGLONG        TSCEnd;
    LONGLONG        TSCDelta;
    ULONG           MHz;
      
} Samples[MAX_ATTEMPTS], *pSamp;



__inline 
ULONGLONG 
RDTSC()
{
  __asm{ RDTSC }
} 


__inline
CPUID(
  IN  ULONG CpuIdType,
  OUT PULONG EaxReg,
  OUT PULONG EbxReg,
  OUT PULONG EcxReg,
  OUT PULONG EdxReg
  )
/*++

  Routine Description:
  
  Arguments:
     
  Return Value:
  
--*/
{

  ULONG eaxTemp, ebxTemp, ecxTemp, edxTemp;
  
 
  _asm {

    mov     eax, DWORD PTR CpuIdType
    xor     ebx, ebx
    xor     ecx, ecx
    xor     edx, edx
    
    cpuid

    mov     eaxTemp, eax
    mov     ebxTemp, ebx
    mov     ecxTemp, ecx
    mov     edxTemp, edx
      
  }

  *EaxReg = eaxTemp;
  *EbxReg = ebxTemp;
  *EcxReg = ecxTemp;
  *EdxReg = edxTemp;
  
}


__inline
ULONGLONG 
ReadMSR(
  IN ULONG MSR
  )
/*++

  Routine Description:
  
  Arguments:
     
  Return Value:
  
--*/
{
  ULARGE_INTEGER  msrContents;

  _asm {

    xor     edx, edx
    mov     ecx, MSR
    rdmsr
    mov     msrContents.LowPart, eax
    mov     msrContents.HighPart, edx

  }

  return msrContents.QuadPart;
}


__inline
WriteMSR(
  IN ULONG MSR,
  IN ULONG64 MSRInfo
  )
/*++

  Routine Description:
  
  Arguments:
     
  Return Value:
  
--*/
{  
  ULARGE_INTEGER data;

  data.QuadPart = MSRInfo;
  
  _asm {

    mov     eax, data.LowPart
    mov     edx, data.HighPart
    mov     ecx, MSR
    wrmsr
   
  } 
}


NTSTATUS
CalculateCpuFrequency(
  OUT PULONG Freq
  )
/*++

  Routine Description:
  
  Arguments:
     
  Return Value:
  
--*/
{

  ULONG Index;
  ULONG Average;
  ULONG Junk;
    
  Index = 0;
  pSamp = Samples;

  for (; ;) {
  
    //
    // Collect a new sample
    // Delay the thread a "long" amount and time it with
    // a time source and RDTSC.
    //
  
    CPUID(0, &Junk, &Junk, &Junk, &Junk);
    pSamp->PerfStart = KeQueryPerformanceCounter(NULL);
    pSamp->TSCStart = RDTSC();
    pSamp->PerfFreq.QuadPart = -50000;
  
    KeDelayExecutionThread (KernelMode, FALSE, &pSamp->PerfFreq);
  
    CPUID(0, &Junk, &Junk, &Junk, &Junk);
    pSamp->PerfEnd = KeQueryPerformanceCounter(&pSamp->PerfFreq);
    pSamp->TSCEnd = RDTSC();
  
    //
    // Calculate processors MHz
    //
  
    pSamp->PerfDelta = pSamp->PerfEnd.QuadPart - pSamp->PerfStart.QuadPart;
    pSamp->TSCDelta = pSamp->TSCEnd - pSamp->TSCStart;
  
    pSamp->MHz = (ULONG) ((pSamp->TSCDelta * pSamp->PerfFreq.QuadPart + 500000L) /
                          (pSamp->PerfDelta * 1000000L));
  
  
    //
    // If last 2 samples matched within a MHz, done
    //
  
    if (Index) {
      if (pSamp->MHz == pSamp[-1].MHz ||
          pSamp->MHz == pSamp[-1].MHz + 1 ||
          pSamp->MHz == pSamp[-1].MHz - 1) {
              break;
      }
    }
  
    //
    // Advance to next sample
    //
  
    pSamp += 1;
    Index += 1;
  
    //
    // If too many samples, then something is wrong
    //
  
    if (Index >= MAX_ATTEMPTS) {
  
  
      //
      // Temp breakpoint to see where this is failing
      // and why
      //
  
      TRAP();
  
  
      Average = 0;
      for (Index = 0; Index < MAX_ATTEMPTS; Index++) {
          Average += Samples[Index].MHz;
      }
      pSamp[-1].MHz = Average / MAX_ATTEMPTS;
      break;
      
    }
  
  }

  if (ARGUMENT_PRESENT(Freq)) {
  
    *Freq = pSamp[-1].MHz;

  }

  return STATUS_SUCCESS;
}


NTSTATUS
GetCPUIDProcessorBrandString (
  PUCHAR ProcessorString,
  PULONG Size
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
#define CPUID_EXTENDED_FUNCTION    0x80000000
#define CPUID_80000002             0x80000002   // first 16 bytes
#define CPUID_80000003             0x80000003   // second 16 bytes
#define CPUID_80000004             0x80000004   // third 16 bytes
#define CPUID_BRAND_STRING_LENGTH  49


  ULONG  x, extdFunctions, junk;
  PULONG string = (PULONG) ProcessorString;

  DebugEnter();
  DebugAssert(Size); 


  //
  // if empty buffer or buffer too small, return the size needed
  //
  
  if (!ProcessorString ||
     (ProcessorString && (*Size < CPUID_BRAND_STRING_LENGTH))) {
  
    *Size = CPUID_BRAND_STRING_LENGTH;
    return STATUS_BUFFER_TOO_SMALL;
  }
   

  //
  // Check if extended CPUID functions are supported
  //
  
  CPUID(CPUID_EXTENDED_FUNCTION, &extdFunctions, &junk, &junk, &junk);

  //
  // check to see if Processor Name Brand String functions are supported,
  // then loop through supported functions.
  //
  
  if (extdFunctions >= CPUID_80000002) {

    ULONG max = (extdFunctions > CPUID_80000004) ?  CPUID_80000004 : extdFunctions;

    for (x=CPUID_80000002; x <= max; x++) {

      CPUID(x, string, string+1, string+2, string+3);
      string += 4;

    }

  } else {
  
    DebugPrint((WARN, "GetCPUIDProcessorBrandString: CPUID Extended Functions not supported!\n"));
    return STATUS_NOT_SUPPORTED;

  }


  //
  // some processors forget to NULL terminate
  //
  
  ProcessorString[CPUID_BRAND_STRING_LENGTH-1] = 0;


  //
  // record size used.
  //
  
  *Size = CPUID_BRAND_STRING_LENGTH;
  
  
  return STATUS_SUCCESS;
}


ULONG
GetCheckSum (
  IN PUCHAR  Address,
  IN ULONG   Length
  )
/*++

  Routine Description:
  
          
  Arguments:
  
     
  Return Value:

  
--*/
{
  ULONG  i;
  UCHAR  sum = 0;

  if (!Length) {
    return 0;
  }

  for (i = 0; i < Length; i++) {
    sum += Address[i];
  }

  return sum;
}


ULONG
Bcd8ToUlong(
  IN ULONG BcdValue
  )
{
#define NIBBLE_SIZE    4

  ULONG intValue = 0;
  ULONG powerOfTen = 1;

  while (BcdValue) {
  
    intValue += (BcdValue & 0xF) * powerOfTen;

    BcdValue >>= NIBBLE_SIZE;
    powerOfTen *= 10;
    
  }
  
  return intValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\procsym\amdk6\makefile.inc ===
$(O)\amdk6.c : ..\procsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\procsym\crusoe\makefile.inc ===
$(O)\crusoe.c : ..\procsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\procsym\p3\makefile.inc ===
$(O)\p3.c : ..\procsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\procsym\processr\makefile.inc ===
$(O)\processr.c : ..\procsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\tools\cpuevent\cpuevent.h ===
/*++

  Copyright (c) 2000 Microsoft Corporation All Rights Reserved
  
  Module Name:
  
      cpuperf.h
  
  Environment:
  
      User mode
  
  Revision History:
  
      10-18-2000  Todd Carpenter
    
--*/

#include <windows.h>
#include <wmium.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

GUID ProcessorMethodGuid = {0x590c82fc, 0x98a3, 0x48e1, {0xbe, 0x4, 0xfe, 0x11, 0x44, 0x1a, 0x11, 0xe7}};
GUID ProcessorPStateEventGuid = {0xa5b32ddd, 0x7f39, 0x4abc, {0xb8, 0x92, 0x90, 0xe, 0x43, 0xb5, 0x9e, 0xbb}};
GUID ProcessorNewPStatesEventGuid = {0x66a9b302, 0xf9db, 0x4864, {0xb0, 0xf1, 0x84, 0x39, 0x5, 0xe8, 0x8, 0xf}};
GUID ProcessorNewCStatesEventGuid = {0x1c9d482e, 0x93ce, 0x4b9e, {0xbd, 0xec, 0x23, 0x65, 0x3c, 0xe0, 0xce, 0x28}};

enum {

  PStateEventId,
  NewPStatesEventId,
  NewCStatesEventId
    
};


typedef struct _PSTATE_EVENT {

  ULONG State;
  ULONG Status;
  ULONG Latency;
  ULONG Speed;

} PSTATE_EVENT, *PPSTATE_EVENT;

typedef struct _NEW_PSTATES_EVENT {

  ULONG HighestState;

} NEW_PSTATES_EVENT, *PNEW_PSTATES_EVENT;


//
// functions
//

VOID
__cdecl
_tmain(
  IN INT    argc,
  IN TCHAR *argv[]
  );

ULONG
GetInstanceName(
  OUT PTSTR *Buffer
  );

VOID
EventCallBackRoutine(
  IN PWNODE_HEADER WnodeHeader,
  IN UINT_PTR Context
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\tools\cpuevent\cpuevent.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpuevent.c

Abstract:

    Monitor Processor Driver Events

Author:

    Todd Carpenter

Environment:

    user mode

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    03-15-2001 : ToddCar - created

--*/
#include "cpuevent.h"




VOID
__cdecl
_tmain(
  IN INT    argc,
  IN TCHAR *argv[]
  )
/*++

Routine Description:

  Main()


Arguments:



Return Value:


--*/
{
  ULONG  status;
  PTSTR  instanceName = NULL;
 
  status = GetInstanceName(&instanceName);
  _tprintf(TEXT("InstanceName == %s\n"), instanceName);
    
  if (status != ERROR_SUCCESS) {

    if (status == ERROR_WMI_GUID_NOT_FOUND) {
    
      _tprintf(TEXT("\n"));
      _tprintf(TEXT("This processor driver does not support WMI interface\n"));
      _tprintf(TEXT("\n"));

    } else {

      _tprintf(TEXT("GetInstanceName() Failed! rc=0x%x\n"), status);
      
    }
    return;
  }

  
  
  //
  // Register for Notifications
  //
  
  _tprintf(TEXT("Registering for events...\n"));
  status = WmiNotificationRegistration((LPGUID) &ProcessorPStateEventGuid,
                                       (BOOLEAN) TRUE,
                                       EventCallBackRoutine,
                                       PStateEventId,
                                       NOTIFICATION_CALLBACK_DIRECT);

  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("WmiNotificationRegistration() Failed! rc=0x%x\n"), status);
  }

  status = WmiNotificationRegistration((LPGUID) &ProcessorNewPStatesEventGuid,
                                       (BOOLEAN) TRUE,
                                       EventCallBackRoutine,
                                       NewPStatesEventId,
                                       NOTIFICATION_CALLBACK_DIRECT);

  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("WmiNotificationRegistration() Failed! rc=0x%x\n"), status);
  }

  status = WmiNotificationRegistration((LPGUID) &ProcessorNewCStatesEventGuid,
                                       (BOOLEAN) TRUE,
                                       EventCallBackRoutine,
                                       NewCStatesEventId,
                                       NOTIFICATION_CALLBACK_DIRECT);

  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("WmiNotificationRegistration() Failed! rc=0x%x\n"), status);
  }

  _tprintf(TEXT("Waiting.... press 'q' to quit\n\n"));
  while(_getch() != 'q');
 
  return;
  
}


ULONG
GetInstanceName(
  OUT PTSTR *Buffer
  )
/*++

  Routine Description:
  
    GetInstanceName()
  
  
  Arguments:
  
  
  
  Return Value:


--*/
{
  ULONG     status;
  ULONG     sizeNeeded;
  PUCHAR    buffer;
  PTSTR     instanceName;
  ULONG     instanceNameOffset;
  WMIHANDLE wmiStatusHandle;
  


  //
  // NOTE: must use ProcessorMethodGuid to get Instance Name ... not
  //       sure why others guid don't work.
  //
    
  //
  // Open connection
  //
  
  status = WmiOpenBlock(&ProcessorMethodGuid,
                        GENERIC_READ,
                        &wmiStatusHandle);


  if (status != ERROR_SUCCESS) {
    //_tprintf(TEXT("GetInstanceName: WmiOpenBlock() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }

  

  //
  // Query for buffer size needed
  //
  
  status = WmiQueryAllData(wmiStatusHandle,
                           &sizeNeeded,
                           0);

  if (status != ERROR_INSUFFICIENT_BUFFER) {
    _tprintf(TEXT("GetInstanceName:WmiQueryAllData(0) Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }


  //
  // Allocate buffer
  //
  
  buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeNeeded);

  if (!buffer) {
    _tprintf(TEXT("GetInstanceName: HeapAlloc(size=0x%x) Failed!\n"), sizeNeeded);
    status = ERROR_INSUFFICIENT_BUFFER;
    goto GetProcessorPerformanceStatusDataExit;
  }


  //
  // Retrieve Data
  //
  
  status = WmiQueryAllData(wmiStatusHandle,
                           &sizeNeeded,
                           buffer);

  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("GetInstanceName: WmiQueryAllData() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }
  
  //
  // Get instance name.
  //

  instanceNameOffset = (ULONG) buffer[((PWNODE_ALL_DATA)buffer)->OffsetInstanceNameOffsets];
  instanceName = (PTSTR) &buffer[instanceNameOffset + sizeof(USHORT)];

  
  //
  // Copy instance name
  //
  
  if (instanceName && Buffer) {

    ULONG nameSize = lstrlen(instanceName) + sizeof(TCHAR);
    
    *Buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nameSize);

    if (!(*Buffer)) {
      status = ERROR_INSUFFICIENT_BUFFER;
      goto GetProcessorPerformanceStatusDataExit;
    }
    
    lstrcpyn(*Buffer, instanceName, nameSize);
  }


  //
  // Close connection
  //

  WmiCloseBlock(wmiStatusHandle);
  
  
  
GetProcessorPerformanceStatusDataExit:

  if (buffer) {
    //HeapFree(GetProcessHeap(), 0, buffer);
  }
  
  return status;
  
}


VOID
EventCallBackRoutine(
  IN PWNODE_HEADER WnodeHeader,
  IN UINT_PTR Context
  )
{

  PWNODE_SINGLE_INSTANCE wnode = (PWNODE_SINGLE_INSTANCE) WnodeHeader;
  

  switch (Context) {

    case PStateEventId:
    {
      PPSTATE_EVENT data = (PPSTATE_EVENT)((ULONG_PTR)wnode + (ULONG_PTR)wnode->DataBlockOffset);

      _tprintf(TEXT("Perf State Transition:\n"));
      _tprintf(TEXT("  New State = %u\n"), data->State);
      _tprintf(TEXT("  Status    = 0x%x\n"), data->Status);
      _tprintf(TEXT("  Cpu Speed = %u mhz\n\n"), data->Speed);
      break;
    }
    

    case NewPStatesEventId:
    {
      PNEW_PSTATES_EVENT data = (PNEW_PSTATES_EVENT)((ULONG_PTR)wnode + (ULONG_PTR)wnode->DataBlockOffset);

      _tprintf(TEXT("New Perf States:\n"));
      _tprintf(TEXT("  Highest Available State = %u\n\n"), data->HighestState);
      break;
    }
    
    case NewCStatesEventId:
    
      _tprintf(TEXT("New CStates!\n"));
      break;
    
    
    default:
      _tprintf(TEXT("Unknown Event Id = %u\n\n"), Context);
  }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\tools\cpuperf\cpuperf.h ===
/*++

  Copyright (c) 2000 Microsoft Corporation All Rights Reserved
  
  Module Name:
  
      cpuperf.h
  
  Environment:
  
      User mode
  
  Revision History:
  
      10-18-2000  Todd Carpenter
    
--*/

#include <windows.h>
#include <wmium.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

GUID ProcessorStatusGuid = {0xee751f9d, 0xcec5, 0x4686, {0x98, 0x16, 0xff, 0x6d, 0x1c, 0xa2, 0x26, 0x1c}}; 
GUID ProcessorMethodGuid = {0x590c82fc, 0x98a3, 0x48e1, {0xbe, 0x4, 0xfe, 0x11, 0x44, 0x1a, 0x11, 0xe7}};

#define WmiSetProcessorPerfStateMethodId    0x1

// Processor_Perf_Level Flags

#define PROCESSOR_STATE_TYPE_PERFORMANCE    0x1
#define PROCESSOR_STATE_TYPE_THROTTLE       0x2

typedef struct {

  ULONG  Frequency;          // in megahertz
  ULONG  Flags;
  ULONG  PercentFrequency;   // for quick lookup
    
} PROCESSOR_PERFORMANCE_STATE, *PPROCESSOR_PERFORMANCE_STATE;


typedef struct {

  PUCHAR                      TransitionFunction;
  ULONG                       TransitionLatency;  // in milliseconds
  ULONG                       Current;
  ULONG                       Count;
  PROCESSOR_PERFORMANCE_STATE State[1]; // sorted from fastest to slowest
    
} PROCESSOR_PERFORMANCE_STATES, *PPROCESSOR_PERFORMANCE_STATES;


typedef struct _PROCESSOR_WMI_STATUS_DATA {

  ULONG                        CurrentPerfState;
  ULONG                        LastRequestedThrottle;
  ULONG                        LastTransitionResult;
  ULONG                        ThrottleValue;
  ULONG                        LowestPerfState;
  ULONG                        UsingLegacyInterface;
  PROCESSOR_PERFORMANCE_STATES PerfStates;
 
} PROCESSOR_WMI_STATUS_DATA, *PPROCESSOR_WMI_STATUS_DATA;


//
// functions
//

VOID
__cdecl
_tmain(
  IN INT    argc,
  IN TCHAR *argv[]
  );

ULONG
GetProcessorPerformanceStatusData(
  IN PPROCESSOR_WMI_STATUS_DATA *ProcessorData
  );
  
ULONG
SetProcessorPerformanceState(
  IN ULONG TargetState,
  IN PTSTR InstanceName,
  OUT PULONG ReturnedValue
  );

ULONG
GetInstanceName(
  OUT PTSTR *Buffer
  );
  
VOID
FreeData(
  IN PVOID Data
  );
  
VOID
DisplayProcessorData (
  IN PPROCESSOR_WMI_STATUS_DATA Data,
  IN PTSTR InstanceName
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\tools\cpuperf\cpuperf.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpuperf.c

Abstract:

    Display Acpi 2.0 Processor Performance States

Author:

    Todd Carpenter

Environment:

    user mode

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.


Revision History:

    10-18-2000 : ToddCar - created

--*/
#include "cpuperf.h"



VOID
__cdecl
_tmain(
  IN INT    argc,
  IN TCHAR *argv[]
  )
/*++

Routine Description:

  Main()


Arguments:



Return Value:


--*/
{
  ULONG  rc = (ULONG) 0xdeaddead;
  ULONG  status;
  ULONG  targetState;
  PTSTR  instanceName = NULL;
  PPROCESSOR_WMI_STATUS_DATA processorData = NULL;

  status = GetInstanceName(&instanceName);
  _tprintf(TEXT("InstanceName == %s\n"), instanceName);
    
  if (status != ERROR_SUCCESS) {

    if (status == ERROR_WMI_GUID_NOT_FOUND) {
    
      _tprintf(TEXT("\n"));
      _tprintf(TEXT("This processor driver does not support WMI interface\n"));
      _tprintf(TEXT("\n"));

    } else {

      _tprintf(TEXT("GetInstanceName() Failed! rc=0x%x\n"), status);
      
    }
    return;
  }

  
  //
  // if called with "setstate X", call SetProcessorPerformanceState(X) first.
  //

  if (argc > 1) {

    if ((_tcsstr(argv[1], TEXT("setstate"))) && argc > 2) {

      targetState = _ttoi(argv[2]);

      _tprintf(TEXT("\n"));
      _tprintf(TEXT("Setting Processor Performance to state %u\n"), targetState);

      status = SetProcessorPerformanceState(targetState, instanceName, &rc);
  
      if (status != ERROR_SUCCESS) {
        _tprintf(TEXT("SetProcessorPerformanceState() Failed! rc=0x%x\n"), rc);
        return;
      }
      
    } else {

      //
      // display help? or just ignor and continue?
      //

    }

  }

  
  status = GetProcessorPerformanceStatusData(&processorData);
  
  if (status == ERROR_SUCCESS) {
    DisplayProcessorData(processorData, instanceName);
  }

  
  //FreeData(instanceName);
  //FreeData(processorData);
  
  return;
  
}


ULONG
GetProcessorPerformanceStatusData(
  IN PPROCESSOR_WMI_STATUS_DATA *ProcessorData
  )
/*++

  Routine Description:
  
    GetProcessorPerformanceStatusData()
  
  
  Arguments:
  
  
  
  Return Value:


--*/
{
  ULONG     status;
  ULONG     sizeNeeded;
  PTSTR     buffer = NULL;
  PTSTR     instanceName = NULL;
  ULONG     instanceNameOffset;
  WMIHANDLE wmiStatusHandle;
  PWNODE_ALL_DATA wmiAllData;
  PPROCESSOR_WMI_STATUS_DATA processorStatusData;
  
  
  status = WmiOpenBlock(&ProcessorStatusGuid,
                        GENERIC_READ,
                        &wmiStatusHandle);


  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("WmiOpenBlock() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }
  

  status = WmiQueryAllData(wmiStatusHandle,
                           &sizeNeeded,
                           0);

  if (status != ERROR_INSUFFICIENT_BUFFER) {
    _tprintf(TEXT("WmiQueryAllData() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }

  
  buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeNeeded);
  //_tprintf(TEXT("HeapAlloc(size=0x%x) allocated: %p\n"), sizeNeeded, buffer);

  if (!buffer) {
    _tprintf(TEXT("HeapAlloc(size=0x%x) Failed!\n"), sizeNeeded);
    status = ERROR_INSUFFICIENT_BUFFER;
    goto GetProcessorPerformanceStatusDataExit;
  }


  status = WmiQueryAllData(wmiStatusHandle,
                           &sizeNeeded,
                           buffer);

  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("WmiQueryAllData() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }


  wmiAllData = (PWNODE_ALL_DATA) buffer;
  
  if (wmiAllData->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE) {
  
    _tprintf(TEXT("WNODE_FLAG_FIXED_INSTANCE_SIZE\n"), sizeNeeded);
    processorStatusData = (PPROCESSOR_WMI_STATUS_DATA) &buffer[wmiAllData->DataBlockOffset];
        
  } else {

    processorStatusData = (PPROCESSOR_WMI_STATUS_DATA) &buffer[wmiAllData->OffsetInstanceDataAndLength[0].OffsetInstanceData];

  }

  if (processorStatusData) {
    *ProcessorData = processorStatusData;
  }


GetProcessorPerformanceStatusDataExit:
  
  return status;
  
}


ULONG
SetProcessorPerformanceState(
  IN ULONG TargetState,
  IN PTSTR InstanceName,
  OUT PULONG ReturnedValue
  )
/*++

  Routine Description:
  
    SetProcessorPerformanceState()
  
  
  Arguments:
  
  
  
  Return Value:


--*/
{
  ULONG status;
  ULONG sizeReturned = sizeof(ULONG);
  WMIHANDLE wmiMethodHandle;
 

   
  status = WmiOpenBlock(&ProcessorMethodGuid,
                        GENERIC_EXECUTE,
                        &wmiMethodHandle);


  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("SetProcessorPerformanceState: WmiOpenBlock() Failed! rc=0x%x\n"), status);
    return status;
  }

  
  status = WmiExecuteMethod(wmiMethodHandle,
                            InstanceName,
                            WmiSetProcessorPerfStateMethodId,
                            sizeof(ULONG),
                            (PVOID) &TargetState,
                            &sizeReturned,
                            (PVOID) ReturnedValue);
            

  return status;
  
}


ULONG
GetInstanceName(
  OUT PTSTR *Buffer
  )
/*++

  Routine Description:
  
    GetInstanceName()
  
  
  Arguments:
  
  
  
  Return Value:


--*/
{
  ULONG     status;
  ULONG     sizeNeeded;
  PUCHAR    buffer;
  PTSTR     instanceName;
  ULONG     instanceNameOffset;
  WMIHANDLE wmiStatusHandle;
  


  //
  // NOTE: must use ProcessorMethodGuid to get Instance Name ... not
  //       sure why others guid don't work.
  //
    
  //
  // Open connection
  //
  
  status = WmiOpenBlock(&ProcessorMethodGuid,
                        GENERIC_READ,
                        &wmiStatusHandle);


  if (status != ERROR_SUCCESS) {
    //_tprintf(TEXT("GetInstanceName: WmiOpenBlock() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }

  

  //
  // Query for buffer size needed
  //
  
  status = WmiQueryAllData(wmiStatusHandle,
                           &sizeNeeded,
                           0);

  if (status != ERROR_INSUFFICIENT_BUFFER) {
    _tprintf(TEXT("GetInstanceName:WmiQueryAllData(0) Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }


  //
  // Allocate buffer
  //
  
  buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeNeeded);

  if (!buffer) {
    _tprintf(TEXT("GetInstanceName: HeapAlloc(size=0x%x) Failed!\n"), sizeNeeded);
    status = ERROR_INSUFFICIENT_BUFFER;
    goto GetProcessorPerformanceStatusDataExit;
  }


  //
  // Retrieve Data
  //
  
  status = WmiQueryAllData(wmiStatusHandle,
                           &sizeNeeded,
                           buffer);

  if (status != ERROR_SUCCESS) {
    _tprintf(TEXT("GetInstanceName: WmiQueryAllData() Failed! rc=0x%x\n"), status);
    goto GetProcessorPerformanceStatusDataExit;
  }
  
  //
  // Get instance name.
  //

  instanceNameOffset = (ULONG) buffer[((PWNODE_ALL_DATA)buffer)->OffsetInstanceNameOffsets];
  instanceName = (PTSTR) &buffer[instanceNameOffset + sizeof(USHORT)];

  
  //
  // Copy instance name
  //
  
  if (instanceName && Buffer) {

    ULONG nameSize = lstrlen(instanceName) + sizeof(TCHAR);
    
    *Buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nameSize);

    if (!(*Buffer)) {
      status = ERROR_INSUFFICIENT_BUFFER;
      goto GetProcessorPerformanceStatusDataExit;
    }
    
    lstrcpyn(*Buffer, instanceName, nameSize);
  }


  //
  // Close connection
  //

  WmiCloseBlock(wmiStatusHandle);
  
  
  
GetProcessorPerformanceStatusDataExit:

  if (buffer) {
    //HeapFree(GetProcessHeap(), 0, buffer);
  }
  
  return status;
  
}


VOID
DisplayProcessorData (
  IN PPROCESSOR_WMI_STATUS_DATA Data,
  IN PTSTR InstanceName
  )
/*++

  Routine Description:
  
    DisplayProcessorData()
  
  
  Arguments:
  
  
  
  Return Value:


--*/
{
  ULONG index;

  _tprintf(TEXT("\n"));
  _tprintf(TEXT("Processor Performance States\n"));
  _tprintf(TEXT("  Current Performance State:    %u\n"), Data->CurrentPerfState);
  _tprintf(TEXT("  Last Requested Throttle:      %u%%\n"), Data->LastRequestedThrottle);
  _tprintf(TEXT("  Last Transition Result:       %s (0x%x)\n"), (Data->LastTransitionResult ? TEXT("Failed") : TEXT("Succeeded")),
                                                                Data->LastTransitionResult);
  _tprintf(TEXT("  Current Throttle Value:       %u\n"), Data->ThrottleValue);
  _tprintf(TEXT("  Lowest Performance State:     %u\n"), Data->LowestPerfState);
  _tprintf(TEXT("  Using Legacy Interface:       %s\n"), Data->UsingLegacyInterface ? TEXT("Yes") : TEXT("No"));
  _tprintf(TEXT("\n"));
  _tprintf(TEXT("  PerfStates:\n"));
  _tprintf(TEXT("    Max Transition Latency:  %u us\n"), Data->PerfStates.TransitionLatency);
  _tprintf(TEXT("    Number of States:        %u\n\n"), Data->PerfStates.Count);

  _tprintf(TEXT("    State  Speed (Mhz)    Type\n")); 
  _tprintf(TEXT("    -----  ------------   ----\n"));
    
  for (index = 0; index < Data->PerfStates.Count; index++) {

    
    _tprintf(TEXT("      %-5u %4u (%3u%%)    %-7s\n"), 
             index, 
             Data->PerfStates.State[index].Frequency,
             Data->PerfStates.State[index].PercentFrequency,
             (((Data->PerfStates.State[index].Flags) & PROCESSOR_STATE_TYPE_PERFORMANCE) ?
             "Performance" : "Throttle"));
  
  }
  _tprintf(TEXT("\n"));
}


VOID
FreeData(
  IN PVOID Data
  )
/*++

  Routine Description:
  
    FreeInstanceName()
  
  
  Arguments:
  
  
  
  Return Value:


--*/
{
  if (Data) {
    HeapFree(GetProcessHeap(), 0, Data);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\viac3\legacy.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    legacy.h

Abstract:

    

Author:

    Tom Brown (t-tbrown) 2001-06-11 - created file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#ifndef _LEGACY_H
#define _LEGACY_H

#include "..\lib\processor.h"

#define MAX_V_STEP 50 // mV

extern ULONG NextTransitionThrottle; // Next state that a worker thread will transition to, or INVALID_THROTTLE if no worker thread is queued
#define INVALID_THROTTLE MAXULONG




VOID
InitializeCPU();

VOID
IdentifyCPUVersion();

NTSTATUS
TransitionNow(
    IN ULONG Fid,
    IN BOOLEAN EnableFid,
    IN ULONG Vid,
    IN BOOLEAN EnableVid
    );

NTSTATUS
TransitionToState(
    IN PACPI_PSS_DESCRIPTOR Pss
    );

NTSTATUS
QueueTransition( 
    IN PFDO_DATA DeviceExtension,
    IN ULONG NewState
);

#ifdef DBG
VOID
DebugShowCurrent();
#endif


#endif // _LEGACY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\tools\finde980\finde980.c ===
/*++

  Copyright (c) 1998  Microsoft Corporation
  
  Module Name:
  
      findE980.c
  
  Abstract:
  
      Looks in the registry to find the Intel Legacy Geyserville INT 15 /E980
      table.
      
  Author:
  
      Todd Carpenter
  
  Environment:
  
      user mode
  
  
  Revision History:
  
      08-08-00 : created, toddcar

--*/

#include "finde980.h"


    
VOID
_cdecl
main (
  INT    Argc,
  CHAR** Argv
  )
/*++

  Routine Description:

        
  Arguments:

   
  Return Value:

  
--*/
{
  LONG rc;
  PACPI_BIOS_MULTI_NODE     multiNode;
  PLEGACY_GEYSERVILLE_INT15 int15Info;

 
  rc = AcpiFindRsdt(&multiNode);

  if (rc != ERROR_SUCCESS) {
    printf("AcpiFindRsdt Failed!\n");
    return;
  }


  //
  // Geyserville BIOS information is appended to the E820 entries.
  //
  
  int15Info = (PLEGACY_GEYSERVILLE_INT15) &(multiNode->E820Entry[multiNode->Count]);
  
  if (int15Info->Signature == 'GS') {

    //
    // Dump E980 Structure
    //

    printf("\n");
    printf("Intel Geyserville INT 15 Interface:\n\n");
    printf("  Signature:               0x%x (GS)\n", int15Info->Signature);
    printf("  Smi Command Port:        0x%x\n", int15Info->CommandPortAddress);
    printf("  Smi Event Port:          0x%x\n", int15Info->EventPortAddress);
    printf("  Polling Interval:        0x%x\n", int15Info->PollInterval);
    printf("  Smi Command Data Value:  0x%x\n", int15Info->CommandDataValue);
    printf("  Event Port Bitmask:      0x%x\n", int15Info->EventPortBitmask);
    printf("  Max Perf Level on AC:    0x%x\n", int15Info->MaxLevelAc);
    printf("  Max Perf Level on DC:    0x%x\n", int15Info->MaxLevelDc);

  } else {

    printf("\n");
    printf("Geyserville Int 15 Interface is NOT supported.\n");

  }
  

}


LONG
AcpiFindRsdt (
  OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
  )
/*++

  Routine Description:
  
      This function looks into the registry to find the ACPI RSDT,
      which was stored there by ntdetect.com.
  
  Arguments:
  
      RsdtPtr - Pointer to a buffer that contains the ACPI
                Root System Description Pointer Structure.
                The caller is responsible for freeing this
                buffer.  Note:  This is returned in non-paged
                pool.
  
  Return Value:
  
      A NTSTATUS code to indicate the result of the initialization.

--*/
{
#define ACPI_CONFIGURATION_DATA   "Configuration Data"
#define ACPI_INDENTIFIER          "Identifier"
#define ACPI_BIOS_IDENTIFIER      "ACPI BIOS"

  CHAR  multiFunctionAdapter[] = "Hardware\\Description\\System\\MultifunctionAdapter\\0\0";
  ULONG adapterNumberOffset = sizeof(multiFunctionAdapter) - 3;
  CHAR  acpiBiosIdentifier[sizeof(ACPI_BIOS_IDENTIFIER)];
  ULONG acpiBiosIdentifierSize = sizeof(acpiBiosIdentifier);
  ULONG regDataSize;
  
  PCM_PARTIAL_RESOURCE_LIST prl;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
  PACPI_BIOS_MULTI_NODE multiNode;
  ULONG multiNodeSize;
  PLEGACY_GEYSERVILLE_INT15 int15Info;

  HKEY   regKeyAcpi;
  LONG   rc;
  ULONG  valueType, i;
  PUCHAR configData = NULL;


  //
  // Look in the registry for the "ACPI BIOS bus" data
  //

  for (i = 0; TRUE; i++) { 
   
    regDataSize = acpiBiosIdentifierSize;
    
    //
    // Check every subkey of HKLM\Hardware\Description\System\MultifunctionAdapter
    // for Acpi bios data
    //

    _itoa(i, &multiFunctionAdapter[adapterNumberOffset], 10);

    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      multiFunctionAdapter,
                      0,
                      KEY_READ,
                      &regKeyAcpi);


    if (rc != ERROR_SUCCESS) {
      printf("AcpiFindRsdt: RegOpenKeyEx(%s) Failed!\n", multiFunctionAdapter); 
      RegCloseKey(regKeyAcpi);
      return rc;
    }

    rc = RegQueryValueEx(regKeyAcpi,
                         ACPI_INDENTIFIER,
                         NULL,
                         &valueType,
                         acpiBiosIdentifier,
                         &regDataSize);


    //
    // All subkeys of "MultifunctionAdapter" should have an "Identifier" key
    //
    
    if ((rc != ERROR_SUCCESS) && (rc != ERROR_MORE_DATA)) {
      printf("AcpiFindRsdt: RegQueryValueEx() failed rc = 0x%x\n", rc);
      return rc;  
    }


    //
    // Compare value of "Identifier" key to "ACPI BIOS"
    //

    if (lstrcmp(acpiBiosIdentifier, ACPI_BIOS_IDENTIFIER)) {

      //
      // no match
      //
      
      continue;
    }
    

    //
    // We have a match, get "Configuration Data"
    //

    rc = GetRegistryValue(regKeyAcpi,
                          ACPI_CONFIGURATION_DATA,
                          &configData);


    //
    // All subkeys of "MultifunctionAdapter" should have an "Configuration Data" key
    //
    
    if (rc != ERROR_SUCCESS) {
      printf("AcpiFindRsdt: GetRegistryValue() failed, rc=0x%x\n", rc);
      return rc;  
    }

    
     

    prl = (PCM_PARTIAL_RESOURCE_LIST)(configData);
    prd = &prl->PartialDescriptors[0];
    multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


    break;
  }

  multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                         ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY)) +
                         sizeof(LEGACY_GEYSERVILLE_INT15);
  
  *AcpiMulti = HeapAlloc(GetProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         multiNodeSize);
                                                    
  if (*AcpiMulti == NULL) {  
    return ERROR_OUTOFMEMORY;
  }

  memcpy(*AcpiMulti, multiNode, multiNodeSize - sizeof(LEGACY_GEYSERVILLE_INT15));
  
  //
  // Geyserville BIOS information is appended to the E820 entries.  Unfortunately,
  // there is no way to know if it is there.  So wrap the code in a try/except.
  //
  
  try {
      
    int15Info = (PLEGACY_GEYSERVILLE_INT15)&(multiNode->E820Entry[multiNode->Count]);
    
    if (int15Info->Signature == 'GS') {
  
      //
      // This BIOS supports Geyserville.
      //
  
      memcpy(((PUCHAR)*AcpiMulti + multiNodeSize - sizeof(LEGACY_GEYSERVILLE_INT15)),
              int15Info, 
              sizeof(LEGACY_GEYSERVILLE_INT15));
  
    }
    
  } except (EXCEPTION_EXECUTE_HANDLER) {
      
      *((PUSHORT)((PUCHAR)*AcpiMulti + multiNodeSize - sizeof(LEGACY_GEYSERVILLE_INT15))) = 0;
  }
  

  return ERROR_SUCCESS;
}


LONG
GetRegistryValue(
    IN HKEY    KeyHandle,
    IN LPTSTR  ValueName,
    OUT PUCHAR *Information
    )
/*++

  Routine Description:
   
  
  Arguments:

  
  Return Value:


  Note:

   It is the responsibility of the caller to free the buffer.

--*/

{
  LONG   rc;
  ULONG  keyValueLength;
  PUCHAR infoBuffer;
  ULONG  type;
   
  //
  // Figure out how big the data value is so that a buffer of the
  // appropriate size can be allocated.
  //
  
  rc = RegQueryValueEx(KeyHandle,
                       ValueName,
                       NULL,
                       &type,
                       NULL,
                       &keyValueLength);
                           
  if (rc != ERROR_SUCCESS) {
    printf("RegQueryValueKey() Failed, rc=0x%x\n",rc);
    return rc;
  }
  
  //
  // Allocate a buffer large enough to contain the entire key data value.
  //
  
  infoBuffer = HeapAlloc(GetProcessHeap(),
                         HEAP_ZERO_MEMORY,
                         keyValueLength);
                         
  if (!infoBuffer) {
    return ERROR_OUTOFMEMORY;
  }
  
  //
  // Query the data for the key value.
  //
  
  rc = RegQueryValueEx(KeyHandle,
                       ValueName,
                       NULL,
                       &type,
                       infoBuffer,
                       &keyValueLength);
                        
                           
  if (rc != ERROR_SUCCESS) {
    HeapFree(GetProcessHeap, 0, infoBuffer);
    return rc;
  }
  
  //
  // Everything worked, so simply return the address of the allocated
  // buffer to the caller, who is now responsible for freeing it.
  //
  
  *Information = infoBuffer;
  return ERROR_SUCCESS;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\tools\finde980\finde980.h ===
/*++

  Copyright (c) 1998  Microsoft Corporation
  
  Module Name:
  
      findE980.h
  
  Environment:
  
      user mode
  
  
  Revision History:
  
      08-08-00 : created, toddcar

--*/
#include <windows.h>
#include <winreg.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <regstr.h>

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef struct {
    PHYSICAL_ADDRESS    Base;
    LARGE_INTEGER       Length;
    ULONG               Type;
    ULONG               Reserved;
} ACPI_E820_ENTRY, far *FPACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONG               Count;
    ULONG               Reserved;       // don't use this.  W2K depends on it being zero - oops
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE, *PACPI_BIOS_MULTI_NODE;

typedef struct {
    USHORT  Signature;
    USHORT  CommandPortAddress;
    USHORT  EventPortAddress;
    USHORT  PollInterval;
    UCHAR   CommandDataValue;
    UCHAR   EventPortBitmask;
    UCHAR   MaxLevelAc;
    UCHAR   MaxLevelDc;
} LEGACY_GEYSERVILLE_INT15, *PLEGACY_GEYSERVILLE_INT15;


LONG
AcpiFindRsdt (
  PACPI_BIOS_MULTI_NODE  *AcpiMulti
  );
  
LONG
GetRegistryValue(
  HKEY    KeyHandle,
  LPTSTR  ValueName,
  PUCHAR *Information
  );


//
// Taken from ntddk.h ...
// 

#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            KAFFINITY Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\viac3\viac3.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    viac3.h

Abstract:

    

Author:

    Tom Brown (t-tbrown) 2001-06-26 - created file

Environment:

    Kernel mode

Notes:

Revision History:

--*/
#ifndef _VIAC3_H
#define _VIAC3_H

#define VIAC3_PARAMETERS_KEY      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ViaC3\\Parameters"

#include "..\lib\processor.h"

//
// set in IdentifyCPUVersion according to data in
// "Samuel 2, Ezra, and C5M LongHaul Programmer's Guide (Version 3.0.0 Gamma)"
//

// Encoding of the LongHaul revision set by IdentifyCPUVersion. Use it with 
// the following macros
extern ULONG LongHaulFlags;

// CPU has the LongHaul MSR at 110Ah
#define SUPPORTS_MSR_FLAG (0x1)

// Supports changing the bus ratio to change the core frequency
#define SUPPORTS_SOFTBR_FLAG (0x2) 

// Supports changing the core voltage
#define SUPPORTS_SOFTVID_FLAG (0x4) 

// Can not change the core voltage by more than 50mV at a time
#define NEEDS_VOLTAGE_STEPPING_FLAG (0x8) 

// Copy bits of MSR from 40:36 to 24:20 so that softVID is initalized
#define SET_MAXV_AT_STARTUP_FLAG (0x10) 

#define SUPPORTS_MSR           (LongHaulFlags & SUPPORTS_MSR_FLAG)
#define SUPPORTS_SOFTBR        (LongHaulFlags & SUPPORTS_SOFTBR_FLAG)
#define SUPPORTS_SOFTVID       (LongHaulFlags & SUPPORTS_SOFTVID_FLAG)
#define NEEDS_VOLTAGE_STEPPING (LongHaulFlags & NEEDS_VOLTAGE_STEPPING_FLAG)
#define SET_MAXV_AT_STARTUP    (LongHaulFlags & SET_MAXV_AT_STARTUP_FLAG)



// Flags used to read hack bits from the registry
#define DISABLE_ALL_HACK_FLAG (0x1)
#define NO_SOFTVID_HACK_FLAG (0x2)
#define NO_VOLTAGE_STEPPING_HACK_FLAG (0x4)

#define MSR_LONGHAUL_ADDR 0x110A
#define EBL_CR_POWERON_MSR     0x2A
#define MSR_1147_ADDR 0x1147
#define INVALID_BR -1
#define CPUID_FUNC0_EBX 0x746E6543
#define CPUID_FUNC0_EDX 0x48727561
#define CPUID_FUNC0_ECX 0x736C7561 

typedef struct {
    union {
        struct {
            ULONG  Stepping:4;          // 3:0
            ULONG  Model:4;    // 7:4
            ULONG  Family:4;          // 11:8
        };
        ULONG AsDWord;
    };
} CPUID_FUNC1, *PCPUID_FUNC1;

typedef struct {
    union {
        struct {
        ULONG Unknown:22;    // 21:0
        ULONG ClockMult:4;    // 25:22
        };
        ULONGLONG AsQWord;
    };
} EBL_CR_POWERON, *PEBL_CR_POWERON;

typedef struct {
    union {
        struct {
        ULONG Unknown:19;    // 18:0
        ULONG Enable_Change:1; // 19
        ULONG Unknown2:3;    // 22:20
        ULONG Clock_Mult:4;    // 26:23
        };
        ULONGLONG AsQWord;
    };
} MSR_1147, *PMSR_1147;

#define VRM85 0
typedef struct {
    union {
        struct {
        ULONG RevisionID:4;         // 3:0
        ULONG RevisionKey:4;        // 7:4
        ULONG EnableSoftBusRatio:1; // 8
        ULONG EnableSoftVID:1;      // 9
        ULONG EnableSoftBSEL:1;     // 10
        ULONG Reserved1:1;          // 11
        ULONG Reserved2:1;          // 12
        ULONG Reserved3:1;          // 13
        ULONG SoftBusRatio4:1;      // 14
        ULONG VRMRev:1;             // 15
        ULONG SoftBusRatio0:4;      // 19:16
        ULONG SoftVID:5;            // 24:20
        ULONG Reserved4:3;          // 27:25
        ULONG SoftBSEL:2;           // 29:28
        ULONG Reserved5:2;          // 31:30
        ULONG MaxMHzBR0:4;          // 35:32
        ULONG MaximumVID:5;         // 40:36
        ULONG MaxMHzFSB:2;          // 42:41
        ULONG MaxMHzBR4:1;          // 43
        ULONG Reserved6:4;          // 47:44
        ULONG MinMHzBR0:4;          // 51:48
        ULONG MinimumVID:5;         // 56:52
        ULONG MinMHzFSB:2;          // 58:57
        ULONG MinMHzBR4:1;          // 59
        ULONG Reserved7:4;          // 63:60
        };
        ULONGLONG AsQWord;
    };
} LONGHAUL_MSR, *PLONGHAUL_MSR;

typedef struct {
  union {
    struct {                // family/model/stepping             6/7/1-f,6/8/*
      ULONG  Fid:8;         // 7:0                               MSR 110Ah[14,19:16]
      ULONG  EnableFid:1;   // 8                                 MSR 110Ah[8]
      ULONG  Reserved1:7;   // 15:9
      ULONG  Vid:8;         // 23:16                             MSR 110Ah[24:20]
      ULONG  EnableVid:1;   // 24                                MSR 110Ah[9]
      ULONG  Reserved2:7;   // 31:25
    };
    ULONG AsDWord;
  };
} PSS_CONTROL, *PPSS_CONTROL;

typedef struct {
  union {
    struct {
      ULONG  Fid:8;         // 7:0
      ULONG  Reserved1:8;   // 15:8
      ULONG  Vid:8;         // 23:16
      ULONG  Reserved2:8;   // 31:24
    };
    ULONG AsDWord;
  };
} PSS_STATUS, *PPSS_STATUS;


#endif // _VIAC3_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\viac3\inf\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
_INF=obj\$(TARGET_DIRECTORY)

make_infs:\
    $(_INF)\viac3.inf

#
# Explicit dependencies.
#

#
# 'Standard' infs. The rules are all the same.
#

$(_INF)\viac3.inf: $(_INX)\viac3.inx $(_LNG)\viac3.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\viac3\viac3.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    viac3.c

Abstract:

    This module implements code that works on Cyrix processors with LongHaul power management support.

Author:

    Tom Brown (t-tbrown) 07-Jun-2001

Environment:

    Kernel mode

Notes:

    DeviceInst  = "ACPI\CentaurHauls_-_x86_Family_6_Model_7"
    DeviceInst  = "ACPI\CentaurHauls_-_x86_Family_6_Model_8"
    ServiceName = "viac3"

Revision History:

--*/
#include "..\lib\processor.h"
#include "legacy.h"
#include "viac3.h"


//
// Must define for debug output
//

#if DBG
PUCHAR DebugName = "viac3.sys";
#endif

PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
UCHAR DevExtIndex;

extern GLOBALS Globals;


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeNonAcpiPerformanceStates)
#pragma alloc_text (PAGE, InitializeAcpi2PStates)
#pragma alloc_text (PAGE, InitializeAcpi2Cstates)
#pragma alloc_text (PAGE, MergePerformanceStates)
#endif



NTSTATUS
InitializeDriver(
    IN PUNICODE_STRING ServiceKeyRegPath
    )

/*++

Routine Description:

    Initializes the LongHaul flags be getting information from the CPU and reading
    the HackFlagsOn and HackFlagsOff keys.
    
Arguments:

    ServiceKeyRegPath - This proc drivers key in the registry
    
Return Value:

    NTSTATUS - STATUS_SUCCESS or an error
    
--*/

{
    ULONG flags;
 
    LongHaulFlags = 0x0;

    // This driver is not MP safe, and most likely never will
    if ( Globals.SingleProcessorProfile == FALSE ) {
        return STATUS_DRIVER_UNABLE_TO_LOAD;    // Lib ignores this return value
    }

    // Just loaded, there are no queued work items
    NextTransitionThrottle = INVALID_THROTTLE;

    IdentifyCPUVersion();

    // Add and remove flags according to registry
    // HackFlagsOn will be set, then
    // HackFlagsOff will be cleared
    GetRegistryDwordValue((PWCHAR) VIAC3_PARAMETERS_KEY, 
                        L"HackFlags", 
                        &flags);

    if( flags & DISABLE_ALL_HACK_FLAG ) {
        DebugPrint((WARN, "All legacy functionality disabled by DISABLE_ALL_HACK_FLAG.\n"));
        LongHaulFlags = 0x0;
    } else if( flags & NO_SOFTVID_HACK_FLAG ) {
        DebugPrint((WARN, "softVID disabled by NO_SOFTVID_HACK_FLAG.\n"));
        LongHaulFlags &= ~SUPPORTS_SOFTVID_FLAG;        
    } else if( flags & NO_VOLTAGE_STEPPING_HACK_FLAG ) {
        DebugPrint((WARN, "Will not transition voltage in steps. Can cause crashes. Set by NO_VOLTAGE_STEPPING_HACK_FLAG.\n"));
        LongHaulFlags &= ~NEEDS_VOLTAGE_STEPPING_FLAG;
    }
       
    InitializeCPU();

    #ifdef DBG
    DebugShowCurrent();
    #endif

    return STATUS_SUCCESS;
}


NTSTATUS
FASTCALL
SetPerfLevel(
    IN UCHAR Throttle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();


  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }
  
  //
  // Get the DeviceExtension.
  //
  DeviceExtension = DeviceExtensions[index];

  return SetPerfLevelGeneric(Throttle, DeviceExtension);

}


NTSTATUS
FASTCALL
SetThrottleLevel(
    IN UCHAR Throttle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();

  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }

  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];
  

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetThrottleLevelGeneric(Throttle, DeviceExtension);

}


NTSTATUS
GetProcessorBrandString (
    PUCHAR BrandString,
    PULONG Size
    )
/*++

Routine Description:
  
Arguments:
  
Return Value:

--*/
{
  //
  // With the generic driver we only try to find the Processor Brand String 
  // via the CPUID
  //
  
  return GetCPUIDProcessorBrandString(BrandString, Size);
}


NTSTATUS
InitializeAcpi2PStates(
    IN PFDO_DATA DevExt
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS status;

  status = InitializeAcpi2PStatesGeneric(DevExt);
  
  //
  // Check that we only access FFH  
  //
  
  if (NT_SUCCESS(status)) {
  
    if ((DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceFixedFunction) ||
        (DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceFixedFunction)) {

      DebugPrint((ERROR, "This driver ONLY supports FFH addresses for Acpi 2.0\n"));
      status = STATUS_NOT_FOUND;
      goto InitializeAcpi2PStatesExit;
    }

    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DevExt);

    //
    // Need to merge this new data with our perfstates
    //
  
    MergePerformanceStates(DevExt);

  }

InitializeAcpi2PStatesExit:
  return status;
}


NTSTATUS
InitializeAcpi2Cstates(
    PFDO_DATA DevExt
    )
/*++

Routine Description:

    This function looks to see if there is an ACPI 2.0 _CST object in the
    namespace, and, if there is, it replaces the functions found by
    InitializeAcpi1Cstates.

    Further note:  This function leaves the filling in of throttling functions
    to the InitializePerformanceStates functions.

Arguments:

    DeviceExtension

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
  ULONG  apicId;
  ULONG  index = 0;

  DebugEnter();

  
  //
  // Record the address of this processor's DeviceExtension, as the
  // throttling API doesn't give it to us.
  //

  if (!Globals.SingleProcessorProfile) {

    //
    // save the index into the DeviceExtension[] for later retrieval based
    // on APIC Id.
    //
    
    apicId = Globals.ProcInfo.ProcIdToApicId[DevExt->ProcObjInfo.PhysicalID];  
    Globals.ProcInfo.ApicIdToDevExtIndex[apicId] = DevExtIndex;

    index = DevExtIndex++;
    
  }

  
  //
  // save Device Extension pointer
  //
  
  DeviceExtensions[index] = DevExt;
  


  //
  //  This processor driver only supports I/O Space based Cstates.
  //  InitializeAcpi2IoSpaceCstates() will fail if it finds Cstates with
  //  non AcpiGenericSpaceIO type addresses.
  //

  return InitializeAcpi2IoSpaceCstates(DevExt);

}

NTSTATUS
MergePerformanceStates(
  IN  PFDO_DATA DeviceExtension
  )
/*++
  Routine Description:
      This routine looks at the performance states stored in the device extension.

  Arguments:
      DeviceExtension

  Return Value:
      A NTSTATUS code to indicate the result of the initialization.

  NOTE:
      - The caller must hold PerfStateLock.
      - This is called during START_DEVICE, and after recieving a Notify(0x80)
        on the processor.
--*/
{

  DebugEnter();

  return MergePerformanceStatesGeneric(DeviceExtension);

}


NTSTATUS
Acpi2PerfStateTransition(
    IN PFDO_DATA DeviceExtension,
    IN ULONG NewState
    )
    
/*++

Routine Description:
    This routine changes the performance state of the processor
    based on ACPI 2.0 performance state objects.

Arguments:

    DeviceExtension - The device extension for this object
    
    NewState - Index into _PSS object

Return Value:

    None

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    
    DebugEnter();
    DebugAssert(DeviceExtension->PssPackage)
    DebugAssert(NewState >= DeviceExtension->PpcResult);
    DebugAssert(NewState < DeviceExtension->PssPackage->NumPStates);
    DebugAssert(DeviceExtension->PssPackage->State[NewState].CoreFrequency);

    if (DeviceExtension->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceFixedFunction) {
        DebugAssert(!"Acpi2PerfStateTransition ONLY understands FFH addresses");
        status = STATUS_UNSUCCESSFUL;
        goto Acpi2PerfStateTransitionExit;
    }

    if (NewState == DeviceExtension->CurrentPssState) {
        DebugPrint((WARN, "Acpi2PerfStateTransition() CurrentState == TargetState, exiting...\n"));
        goto Acpi2PerfStateTransitionExit;
    }

    // Queue the transition so it always run at PASSIVE irql
    status = QueueTransition( DeviceExtension, NewState);

    if( NT_SUCCESS(status) ) {
        DeviceExtension->CurrentPssState = NewState;
    }

    Acpi2PerfStateTransitionExit:

    DebugExitStatus(status);
    return status;

}


NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();

  //
  // if we are resuming from Hibernate, and this is an Acpi 2.0 system,
  // we must re-claim perf state and cstate control from the bios.
  //

  if (PreviousState == PowerSystemHibernate) {

    if (DeviceExtension->PssPackage) {
      AssumeProcessorPerformanceControl();
    }
    
    if (DeviceExtension->CstPresent) {
      AssumeCStateControl();
    }
    
  }

  //
  // restore previous state
  //

  return RestoreToSavedPerformanceState(DeviceExtension);

}


NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{ 
  DebugEnter();

  //
  // save current state, transition to lowest non-throttled perf state
  //

  return SaveCurrentStateGoToLowVolts(DeviceExtension);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\viac3\legacy.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    legacy.c

Abstract:

    This module implements code that works on Cyrix processors with LongHaul power management support.

Author:

    Tom Brown (t-tbrown) 11-Jun-2001

Environment:

    Kernel mode

Revision History:

--*/

#include <ntddk.h>

#include "..\lib\processor.h"
#include "legacy.h"
#include "viac3.h"

extern PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
extern UCHAR DevExtIndex;

extern GLOBALS Globals;



// set in IdentifyCPUVersion according to data in
// "Samuel 2, Ezra, and C5M LongHaul Programmer's Guide (Version 3.0.0 Gamma)"
ULONG LongHaulFlags; // Encoding of the LongHaul revision set by IdentifyCPUVersion. Use it with the following macros

ULONG FsbFreq; // (MHz) Front Side Bus frequency
#define POWER_V 1200 // Power is measured in mW, but this is a hack value used for states that have an unknown mV
#define ABSOLUTE_MIN_FREQ 300
#define DEFAULT_LATENCY_US 500000 // Set default latency to 500ms in microseconds, because transitions suck (take a long time, occupy whole proc)

ULONG NextTransitionThrottle; // (%) Next state (as percentage of total speed) that a worker thread will transition to, or INVALID_THROTTLE if no worker thread is queued


#define RESV (-1) // A reserved value in the tables

#define BR_MULT 2   // Used to avoid putting floats in the BR tables
                    // divide by 2 is optimised to a shift by the compiler 


#define LH_SOFTBR_MIN 1 // index of lowest value in LH_SOFTBR
const ULONG LH_SOFTBR [32] = {  // Indexed by bits written to softBR(14,19:16) to the BR that the bits represent
    20,     6,      8,      18, // Actual bus ratio = LH_SOFTBR[i] / BR_MULT
    19,     7,      9,      11,
    12,     14,     16,     10,
    13,     15,     17,     24,
    RESV,   22,     24,     RESV,
    21,     23,     25,     27,
    28,     30,     32,     26,
    29,     31,     RESV,   RESV
};
const ULONG LH_SOFTBR_SORT [32] = { // Indexes of LH_SOFTBR, sorted decreasing by value
    26,     29,     25,     28,     // BRs are put into the pss in decreasing order
    24,     23,     27,     22,
    18,     21,     17,     20,  // LH_SOFTBR[15] is never used because there are two entries for 12.0X(24)
    0,      4,      3,      14,
    10,     13,     9,      12,
    8,      7,      11,     6,
    2,      5,      1,      RESV,
    RESV,   RESV,   RESV,   RESV
    
};
#define LH_SOFTBR_SIZE (sizeof(LH_SOFTBR) / sizeof(ULONG))

ULONG const* LhSoftVid; // Set to LH_SOFTVID_VRM85 or LH_SOFTVID_MOBILE
ULONG const* LhSoftVidSort; // Set to LH_SOFTVID_VRM85_SORT or LH_SOFTVID_MOBILE_SORT
ULONG LhSoftVidSize; // Set to LH_SOFTVID_VRM85_SIZE or LH_SOFTVID_MOBILE_SIZE

const ULONG LH_SOFTVID_VRM85 [32] = { // mVolts with a VRM 8.5
    // VRM 8.5, bit15=0
    1250,   1200,   1150,   1100,
    1050,   1800,   1750,   1700,
    1650,   1600,   1550,   1500,
    1450,   1400,   1350,   1300,
    1275,   1225,   1175,   1125,
    1075,   1825,   1775,   1725,
    1675,   1625,   1575,   1525,
    1475,   1425,   1375,   1325
};
const ULONG LH_SOFTVID_VRM85_SORT [32] = { // Indexes of LH_SOFTVID_VRM85, sorted decreasing by value
    21,     5,      22,     6,             // voltage levels are used in decreasing order in the pss
    23,     7,      24,     8,
    25,     9,      26,     10,
    27,     11,     28,     12,
    29,     13,     30,     14,
    31,     15,     16,     0,
    17,     1,      18,     2,
    19,     3,      20,     4
};
#define LH_SOFTVID_VRM85_SIZE (sizeof(LH_SOFTVID_VRM85) / sizeof(ULONG))

const ULONG LH_SOFTVID_MOBILE [32] = { // mVolts with a Mobile VRM
    // Mobile VRM, bit15=1
    2000,   1950,   1900,   1850,
    1800,   1750,   1700,   1650,
    1600,   1550,   1500,   1450,
    1400,   1350,   1300,   RESV,
    1275,   1250,   1225,   1200,
    1175,   1150,   1125,   1100,
    1075,   1050,   1025,   1000,
    975,    950,    925,    RESV
};
const ULONG LH_SOFTVID_MOBILE_SORT [32] = { // Indexes of LH_SOFTVID_MOBILE, sorted decreasing by value
    0,      1,      2,      3,              // voltage levels are used in decreasing order in the pss
    4,      5,      6,      7,
    8,      9,      10,     11,
    12,     13,     14,     16,
    17,     18,     19,     20,
    21,     22,     23,     24,
    25,     26,     27,     28,
    29,     30,     RESV,   RESV
};
#define LH_SOFTVID_MOBILE_SIZE (sizeof(LH_SOFTVID_MOBILE) / sizeof(ULONG))


// Indexed by bits MSR[43,35:32] to the BR*BR_MULT they represent
const ULONG LH_MAX_BR [32] = {
    // bit 43=0
    10,     6,      8,      20,  // DIVIDE these values by BR_MULT to get actual BR!
    11,     7,      9,      19,
    18,     14,     16,     12,
    24,     15,     17,     13,
    // bit 43=1
    RESV,   22,     24,     RESV,
    27,     23,     25,     21,
    26,     30,     32,     28,
    RESV,   31,     RESV,   29
    };
#define LH_MAX_BR_SIZE (sizeof(LH_MAX_BR) / sizeof(ULONG))


// Indexed by bits MSR[59,51:48] to the BR*BR_MULT they represent
const ULONG LH_MIN_BR [32] = {
    // bit 59=0
    10,     6,      8,      20,  // DIVIDE these values by BR_MULT to get actual BR!
    11,     7,      9,      19,
    18,     14,     16,     12,
    24,     15,     17,     13,
    // bit 59=1
    RESV,   RESV,   RESV,   RESV,
    RESV,   RESV,   RESV,   RESV,
    RESV,   RESV,   RESV,   RESV,
    RESV,   RESV,   RESV,   RESV
    };
#define LH_MIN_BR_SIZE (sizeof(LH_MIN_BR) / sizeof(ULONG))

const ULONG LH_FSB [4] = {  // (MHz) Frequency of FSB
    133,
    100,
    RESV,
    66
};



VOID
InitializeCPU()

/*++

    Routine Description:
    
        Optionally initializes the softVID value in the MSR to MaximumVID.
        
    Arguments:
    
        None
        
    Return Value:
    
        None
        
--*/

{
    LONGHAUL_MSR longhaul_msr;

    
    // Need to initilize the MSR since it boots with an undetermined value.
    // The transition routine needs the value to be correct since it may need
    // to avoid taking voltage steps larger than MAX_V_STEP mV.
    if( SUPPORTS_SOFTVID && SET_MAXV_AT_STARTUP ) {
        longhaul_msr.AsQWord = ReadMSR(MSR_LONGHAUL_ADDR);

        ExSetTimerResolution (10032,TRUE);
        TransitionNow( RESV, FALSE, longhaul_msr.MaximumVID, TRUE );
        ExSetTimerResolution (0, FALSE);
    }
    
}



VOID
IdentifyLongHaulParameters()

/*++

Routine Description:
    
    Read LondHaulMSR RevisionID. Make sure this software supports the revision
    and set the flags.
    Sets LhSoftVid, LhSoftVidSort, LhSoftVidSize to the correct constant.
    
Arguments:

    None
    
Return Value:

    None
    
--*/

{
    LONGHAUL_MSR longhaul_msr;
    ULONG freq;
    ACPI_PSS_DESCRIPTOR pss;
    PSS_CONTROL control;

    longhaul_msr.AsQWord = ReadMSR(MSR_LONGHAUL_ADDR);
    if( longhaul_msr.RevisionID == 0 ) {
        LongHaulFlags |= SUPPORTS_MSR_FLAG | SUPPORTS_SOFTBR_FLAG;
    } else if( longhaul_msr.RevisionID == 1 ) {
        LongHaulFlags |= SUPPORTS_MSR_FLAG | SUPPORTS_SOFTBR_FLAG | SUPPORTS_SOFTVID_FLAG | NEEDS_VOLTAGE_STEPPING_FLAG | SET_MAXV_AT_STARTUP_FLAG;
    } else if( longhaul_msr.RevisionID == 2 ) {
        LongHaulFlags |= SUPPORTS_MSR_FLAG | SUPPORTS_SOFTBR_FLAG | SUPPORTS_SOFTVID_FLAG | NEEDS_VOLTAGE_STEPPING_FLAG | SET_MAXV_AT_STARTUP_FLAG;
    } else {
        DebugPrint((WARN, "Unknown LongHaul revision %u.\n", longhaul_msr.RevisionID));
        return;
    }

    if( SUPPORTS_SOFTVID ) {
        if( longhaul_msr.VRMRev == VRM85 ) {
            LhSoftVid = LH_SOFTVID_VRM85;
            LhSoftVidSort = LH_SOFTVID_VRM85_SORT;
            LhSoftVidSize = LH_SOFTVID_VRM85_SIZE;
        } else {
            // Mobile VRM
            LhSoftVid = LH_SOFTVID_MOBILE;
            LhSoftVidSort = LH_SOFTVID_MOBILE_SORT;
            LhSoftVidSize = LH_SOFTVID_MOBILE_SIZE;
        }

    }
    
}



VOID
IdentifyCPUVersion()

/*++

Routine Description:

    Set the LongHaul flags according to what is known about the hardware. Expects
    flags to be cleared when called.
    
Arguments:

    None
    
Return Value:

    None
    
--*/

{
    ULONG eax, ebx, ecx, edx;
    CPUID_FUNC1 cpuid_result;
    
    // Check CPUID Function 0 returns vendor string EBX:EDX:ECX = "CentaurHauls"
    CPUID(0x0, &eax, &ebx, &ecx, &edx);
    if ( ebx != CPUID_FUNC0_EBX || edx != CPUID_FUNC0_EDX || ecx != CPUID_FUNC0_ECX ) {
        DebugPrint((WARN, "Invalid result from CPUID Function 0.\n"));
        return;
    }

    // Get Family/Model/Stepping from CPUID Function 1
    CPUID(0x1, &cpuid_result.AsDWord, &ebx, &ecx, &edx);
    if (cpuid_result.Family == 6 ) {
        if ( cpuid_result.Model == 6 ) {
            DebugPrint((TRACE, "Found VIA C3 Samuel 1 (C5A).\n" ));
            return;
        }

        if ( cpuid_result.Model == 7 ) {
            if( cpuid_result.Stepping==0) {
                DebugPrint((TRACE, "Found VIA C3 Samuel 2 (C5B), stepping 0.\n" ));
                return;
            } else if ( cpuid_result.Stepping <= 7 ) {
                DebugPrint((TRACE, "Found VIA C3 Samuel 2 (C5B), stepping 1-7.\n" ));
                IdentifyLongHaulParameters();
                return;
            } else {
                DebugPrint((TRACE, "Found VIA C3 Ezra (C5C).\n" ));
                IdentifyLongHaulParameters();
                return;
            }
        }

        if ( cpuid_result.Model == 8 ) {
            DebugPrint((TRACE, "Found VIA C3 Ezra-T (C5M).\n" ));
            IdentifyLongHaulParameters();
            return;
        }
    }
    
    DebugPrint((WARN, "Unknown CPU family/model/stepping %u/%u/%u is not supported.\n", 
        cpuid_result.Family,
        cpuid_result.Model,
        cpuid_result.Stepping
    ));
    return;    
}

#ifdef DBG


VOID
DebugShowPossibleLongHaulMSR()

/*++

Routine Description:

    Debug spew the contents of the LongHaul MSR.
    
Arguments:

    None
    
Return Value:

    None
    
--*/

{
    LONGHAUL_MSR longhaul_msr;

    DebugAssert( SUPPORTS_MSR );

    longhaul_msr.AsQWord = ReadMSR(MSR_LONGHAUL_ADDR);
    DebugPrint((TRACE,"  RevisionID: %i\n",longhaul_msr.RevisionID));
    DebugPrint((TRACE,"  RevisionKey: %i\n", longhaul_msr.RevisionKey));
    DebugPrint((TRACE,"  EnableSoftBusRatio: %i\n", longhaul_msr.EnableSoftBusRatio));
    DebugPrint((TRACE,"  EnableSoftVID: %i\n", longhaul_msr.EnableSoftVID));
    DebugPrint((TRACE,"  EnableSoftBSEL: %i\n", longhaul_msr.EnableSoftBSEL));
    DebugPrint((TRACE,"  Reserved1: %i\n", longhaul_msr.Reserved1));
    DebugPrint((TRACE,"  Reserved2: %i\n", longhaul_msr.Reserved2));
    DebugPrint((TRACE,"  Reserved3: %i\n", longhaul_msr.Reserved3));
    DebugPrint((TRACE,"  VRMRev: %i\n", longhaul_msr.VRMRev));
    DebugPrint((TRACE,"  SoftBusRatio: %i\n", longhaul_msr.SoftBusRatio4<<4 | longhaul_msr.SoftBusRatio0));
    DebugPrint((TRACE,"  SoftVID: %i\n", longhaul_msr.SoftVID));
    DebugPrint((TRACE,"  Reserved4: %i\n", longhaul_msr.Reserved4));
    DebugPrint((TRACE,"  SoftBSEL: %i\n", longhaul_msr.SoftBSEL));
    DebugPrint((TRACE,"  Reserved5: %i\n", longhaul_msr.Reserved5));
    DebugPrint((TRACE,"  MaxMHzBR: %i\n", longhaul_msr.MaxMHzBR4<<4 | longhaul_msr.MaxMHzBR0));
    DebugPrint((TRACE,"  MaximumVID: %i\n", longhaul_msr.MaximumVID));
    DebugPrint((TRACE,"  MaxMHzFSB: %i\n", longhaul_msr.MaxMHzFSB));
    DebugPrint((TRACE,"  Reserved6: %i\n", longhaul_msr.Reserved6));
    DebugPrint((TRACE,"  MinMHzBR: %i\n", longhaul_msr.MinMHzBR4<<4 | longhaul_msr.MinMHzBR0));
    DebugPrint((TRACE,"  MinimumVID: %i\n", longhaul_msr.MinimumVID));
    DebugPrint((TRACE,"  MinMHzFSB: %i\n", longhaul_msr.MinMHzFSB));
    DebugPrint((TRACE,"  Reserved7: %i\n", longhaul_msr.Reserved7));
}



VOID
DebugShowCurrent()

/*++

Routine Description:

    Show some information about the current state of the CPU.

Arguments:

    None
    
Return Value:

    None

--*/

{
    ULONG freq;

    DebugPrint((TRACE,"Reading current CPU power state\n"));

    CalculateCpuFrequency( &freq );
    DebugPrint((TRACE," running at %iMhz\n", freq));
    
    if( SUPPORTS_MSR ) {
        DebugShowPossibleLongHaulMSR();
    } else {
        DebugPrint((ERROR," Unknown CPU.\n"));
    }
    
}
#endif // DBG



VOID
TransitionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    Run by a system worker thread as a work item. 
    
Arguments:

    DeviceObject - Device object
    
    Context - Pointer to ACPI_PSS_DESCRIPTOR for the state to transition to 
    
Return Value:

    None
    
--*/

{
    ULONG Throttle;
    ULONG OldThrottle;
    ULONG newState;
    PFDO_DATA DeviceExtension;
    
    DebugEnter();

    DeviceExtension = (PFDO_DATA) DeviceObject->DeviceExtension;

    do {
        // Get the next state
        Throttle = NextTransitionThrottle;
        DebugAssert( INVALID_PERF_STATE > 100 ); // Check 
        
        // Run through the performance states looking for one
        // that matches this throttling level.
        for (newState = 0; newState < DeviceExtension->PerfStates->Count; newState++) {
            if (DeviceExtension->PerfStates->State[newState].PercentFrequency <= Throttle) {
                DebugPrint((TRACE, "TransitionRoutine found match. PerfState = %u, Freq %u%%\n",
                        newState,
                        DeviceExtension->PerfStates->State[newState].PercentFrequency));
                break;
            }
        }
        if( newState >= DeviceExtension->PerfStates->Count ) {
            DebugAssert( !"Invalid throttle or perf state not found" );
            return;
        }

        // Convert index in PerfStates to index in PssPackage
        newState = newState + DeviceExtension->PpcResult;
    
        TransitionToState( &(DeviceExtension->PssPackage->State[newState]) );

        // If NextTransitionThrottle is still Throttle then set
        // NextTransitionThrottle to INVALID_PERF_STATE and exit.
        // If NextTransitionThrottle is a different value from the top
        // of this do...while then loop to perform transition to that throttle.
        OldThrottle = InterlockedCompareExchange(
                &NextTransitionThrottle,  // pointer to data that will be read, compared, and optionly changed
                INVALID_PERF_STATE, // data that will be written if NextTransitionThrottle=Throttle
                Throttle ); // Throttle we just transitioned to. Check if NextTransitionThrottle still has this value
                
        DebugAssert( OldThrottle!=INVALID_PERF_STATE ); // OldThrottle could only be INVALID_PERF_STATE here if another thread in TransitionRoutine had cleared it, QueueTransition is designied to prevent that happening.
    } while( OldThrottle!=Throttle );
 
    IoFreeWorkItem((PIO_WORKITEM)Context);

    DebugExit();
}



NTSTATUS
QueueTransition( 
    IN PFDO_DATA DeviceExtension,
    IN ULONG NewState
    )
    
/*++

Routine Description:

    Setup a transition to be executed by a system worker thread and return.
    Needed because the transition code must be run at IRQL < DISPATCH_LEVEL.
    Creates a new queued work item if NextTransitionThrottle was INVALID_PERF_STATE.
    
Arguments:

    DeviceExtension - Device object
    
    NewState - Number of the state to transition to in the PerfStates table
    
Return Value:

    NTSTATUS - success if transition was successfully completed
    
--*/
{
    PIO_WORKITEM pWorkItem;
    ULONG old_next_transition;

    DebugAssert( NewState < DeviceExtension->PerfStates->Count );
    
    
    old_next_transition = InterlockedExchange(
        &NextTransitionThrottle,
        DeviceExtension->PerfStates->State[NewState].PercentFrequency );

    if ( old_next_transition == INVALID_THROTTLE ) {
        DebugPrint((TRACE,"No worker thread item was in the queue. Making new work item to transition to %i%%.\n",
            DeviceExtension->PerfStates->State[NewState].PercentFrequency));
        
        pWorkItem = IoAllocateWorkItem( DeviceExtension->Self );
        IoQueueWorkItem(
            pWorkItem,
            TransitionRoutine,
            DelayedWorkQueue,
            pWorkItem
        );
    } else {
        DebugPrint((TRACE,"Worker thread item was going to transition to  %i%%. Now going to %i%%.\n",
            old_next_transition, DeviceExtension->PerfStates->State[NewState].PercentFrequency));
    }

    return STATUS_SUCCESS;
}



ULONG
CalcNextVoltageStep(
    IN ULONG VidFinal,
    IN ULONG VidCurrent
    )

/*++

Routine Description:

    Calculate the next safe vid. Part of a hack that only changes voltage in
    MAX_V_STEP (mV) steps.

Arguments:

    vidFinal - Final goal vid(index into LhSoftVid)

    vidCurrent - Current vid

Return Value:

    Next vid which the CPU can change to.

--*/

{
    ULONG pos;  // position in the LhSoftVidSort table
    
    if( (!NEEDS_VOLTAGE_STEPPING) || VidFinal==VidCurrent || LhSoftVid[VidFinal]==LhSoftVid[VidCurrent]) {
        return VidFinal;
    }

    // Search for vidCurrent in LhSoftVidSort
    pos = 0;
    while( pos<LhSoftVidSize && LhSoftVidSort[pos]!=VidCurrent ) {
        ++pos;
    }
    DebugAssert( LhSoftVidSort[pos]==VidCurrent ); // Must find the vidCurrent in the LhSoftVidSort

    if( LhSoftVid[VidFinal] > LhSoftVid[VidCurrent] ) {
        // need to move pos backwards in LhSoftVidSort
        DebugAssert( pos != 0 ); // can't be first in table unless it is highest
        do {
            --pos;
            if( pos == 0 ) {
                break;
            }
        } while( LhSoftVidSort[pos] != VidFinal
                && LhSoftVid[LhSoftVidSort[pos]]-LhSoftVid[VidCurrent] < MAX_V_STEP );
        DebugAssert( LhSoftVid[LhSoftVidSort[pos]]-LhSoftVid[VidCurrent] <= MAX_V_STEP );
    } else{
        // Need to move pos forwards in LhSoftVidSort
        DebugAssert( LhSoftVid[VidFinal] < LhSoftVid[VidCurrent] );
        DebugAssert( pos+1 < LhSoftVidSize );
        do {
            ++pos;
        } while( pos+1<LhSoftVidSize && LhSoftVidSort[pos] != VidFinal
                && LhSoftVid[VidCurrent]-LhSoftVid[LhSoftVidSort[pos]] < MAX_V_STEP );
        DebugAssert( LhSoftVid[VidCurrent]-LhSoftVid[LhSoftVidSort[pos]] <= MAX_V_STEP );
    }
    
    return LhSoftVidSort[pos];
}



NTSTATUS
TransitionNow(
    IN ULONG Fid,
    IN BOOLEAN EnableFid,
    IN ULONG Vid,
    IN BOOLEAN EnableVid
    )

/*++

Routine Description:

    Set the clock to 1ms BEFORE calling TransitionNow.
    Perform the state transition now and return success or not.

Arguments:

    fid - fid(BR) to transition to

    enableFid - should enable fid(softBR) transition

    vid - vid to transition to

    enableVid - should enable vid(softVID) transition

Return Value:

    NTSTATUS - success if transition was successfully completed

--*/

{
    LONGHAUL_MSR msr;
    KIRQL irql;
    
    DebugAssert( SUPPORTS_MSR );

    msr.AsQWord = ReadMSR(MSR_LONGHAUL_ADDR);
    msr.RevisionKey = msr.RevisionID; // Need to copy to RevisionKey for each write
    if( EnableFid ) {
        msr.EnableSoftBusRatio = 1;
        msr.SoftBusRatio0 = Fid & 0x0F; // Write the 4 LS bits of the BR
        msr.SoftBusRatio4 = Fid >> 4;   // Write the MS bit of the BR
        DebugPrint((TRACE,"changing to fid=%i(%i/%i)\n",
                Fid, LH_SOFTBR[Fid], BR_MULT ));
    }
    if( EnableVid ) {
        DebugAssert( SUPPORTS_SOFTVID );
        msr.EnableSoftVID = 1;
        msr.SoftVID = Vid;
        DebugPrint((TRACE,"changing to vid=%i(%imV)\n",
                Vid, LhSoftVid[Vid] ));
    }

    // Raise the IRQL to mask off all interrupts except the timer
    KeRaiseIrql(CLOCK1_LEVEL-1, &irql);
    DebugPrint((TRACE,"Raised IRQL from %i to %i\n", irql, KeGetCurrentIrql()));

    WriteMSR(MSR_LONGHAUL_ADDR, msr.AsQWord);
    
    // Halt twice to guarantee that second halt lasts a full 1 ms before the timer interrupt
    // Possible optimization!! use a timer to see if the first halt last long enough to meet
    // the hardware specs
    DebugPrint((TRACE,"Calling halt\n"));
    _asm {
       hlt
       hlt
    }

    // Clean up as needed
    msr.AsQWord = ReadMSR(MSR_LONGHAUL_ADDR);
    msr.RevisionKey = msr.RevisionID; // Need to copy to RevisionKey for each write
    msr.EnableSoftBusRatio = 0;
    msr.EnableSoftVID = 0;
    WriteMSR(MSR_LONGHAUL_ADDR, msr.AsQWord);
    
    // Bring the IRQL back down to its previous value
    KeLowerIrql(irql);
    DebugPrint((TRACE,"Restored IRQL. Now %i\n", KeGetCurrentIrql()));


}



NTSTATUS
TransitionToState(
    IN PACPI_PSS_DESCRIPTOR Pss
    )
    
/*++

Routine Description:

    Perform the state transition now and return success or not.

Arguments:

    Pss - pointer to the ACPI_PSS_DESCRIPTOR of the state to transition to

Return Value:

    NTSTATUS - success if transition was successfully completed

--*/

{
    ULONG set_timer_result;
    PSS_CONTROL pssControl;
    ULONG vidNext;
    LONGHAUL_MSR msr_longhaul;

    DebugEnter();

    // Copy state control bits
    pssControl.AsDWord = Pss->Control;

    DebugAssert( KeGetCurrentIrql() < DISPATCH_LEVEL ); // Callers of ExSetTimerResolution must be running at IRQL < DISPATCH_LEVEL

    do {

        // Change the timer resolution to the smallest safe amount, 1ms
        // Since we are at a low irql another thread may have changed it so
        // set it each time we call TransitionNow
        set_timer_result = ExSetTimerResolution (10032,TRUE);   // Set timer to 1ms in 100ns units, fudged to what ExSetTimerResolution normally returns
        DebugPrint((TRACE,"Set the timer, returned value %lu\n", set_timer_result));
    
        // Read the current state of the msr
        msr_longhaul.AsQWord = ReadMSR(MSR_LONGHAUL_ADDR);

        DebugPrint((TRACE,"current vid=%i(%imV) fid=%i(%i)\n",
              msr_longhaul.SoftVID, LhSoftVid[msr_longhaul.SoftVID],
              (msr_longhaul.SoftBusRatio4<<4) + msr_longhaul.SoftBusRatio0, LH_SOFTBR[msr_longhaul.SoftBusRatio4<<4 | msr_longhaul.SoftBusRatio0] ));
        
        if( pssControl.EnableVid ) {
            vidNext = CalcNextVoltageStep(pssControl.Vid,msr_longhaul.SoftVID);
            if( LhSoftVid[vidNext] >= LhSoftVid[pssControl.Vid] 
                && pssControl.EnableFid ) {
                // Can set the freq and voltage
                DebugPrint((TRACE," vidNext=%i(%imV)  pssControl.Vid=%i(%imV)\n",
                        vidNext, LhSoftVid[vidNext],
                        pssControl.Vid, LhSoftVid[pssControl.Vid] ));
                TransitionNow( pssControl.Fid, TRUE, vidNext, TRUE );
            } else {
                // only set the voltage
                TransitionNow( RESV, FALSE, vidNext, TRUE );
            }
        } else {
            DebugAssert( pssControl.EnableFid ); // every state should have EnableVid or EnableFid
            // No voltage transition
            TransitionNow( pssControl.Fid, TRUE, RESV, FALSE );
       }

    }while( pssControl.EnableVid && pssControl.Vid != vidNext );

    // Reset the timer to its default value
    set_timer_result = ExSetTimerResolution (0, FALSE);
    DebugPrint((TRACE,"Reset the timer, returned value %lu\n", set_timer_result));

    DebugExit();
    return STATUS_SUCCESS;
}



VOID
MeasureFSBFreq()

/*++

Routine Description:

    Measure the frequency the front side bus is running by setting the bus 
    ratio to a known safe value and timing the core frequency.
    Value is put in global FsbFreq.
        
Arguments:

    None

Return Value:

    None

--*/

{
    PSS_CONTROL control;
    ACPI_PSS_DESCRIPTOR pss;
    ULONG freq;
    
    // Set the BR to a known, safe, constant
    control.EnableFid = 1;
    control.Fid = LH_SOFTBR_MIN;
    control.EnableVid = 0;
    control.Vid = 0;
    pss.Control = control.AsDWord;
    TransitionToState(&pss);

    // Time the fsb
    CalculateCpuFrequency( &freq );
    FsbFreq = freq * BR_MULT / LH_SOFTBR[LH_SOFTBR_MIN];
    DebugPrint((TRACE, "Set BR to %i(%i.%i), measured CPU at %iMHz, meaning FSB at %iMHz\n",
            LH_SOFTBR_MIN,
            LH_SOFTBR[LH_SOFTBR_MIN]/BR_MULT, (100/BR_MULT) * (LH_SOFTBR[LH_SOFTBR_MIN]%BR_MULT),
            freq,
            FsbFreq));
}



ULONG
CalcMaxFreq(
    IN ULONG V,
    IN ULONG Vmin,
    IN ULONG Fmin,
    IN ULONG Vmax,
    IN ULONG Fmax
    )
    
/*++

Routine Description:

    Calculate the maximum operating frequency allowed at a particular voltage 
    given parameters from the LongHaul MSR.
    Picks the max frequency that is below a line formed between two points on 
    a voltage vs. frequency graph.
    The two points are (Vmin,Fmin) and (Vmax,Fmax)

Arguments:

    V - The voltage at which you want to know the max freq
    
    Vmin - Min allowed voltage
    
    Fmin - Max allowed frequency
    
    Vmax - Max allowed voltage
    
    Fmax - Min allowed frequency

Return Value:

    The maximum operating frequency at a specific voltage.

--*/

{
    return ((Fmax-Fmin)*(V-Vmin) + Fmin*(Vmax-Vmin)) / (Vmax-Vmin);
}



NTSTATUS
FindAcpiPerformanceStatesLongHaul(
    OUT PACPI_PSS_PACKAGE* Pss
    )

/*++

Routine Description:

    Build a new pss containing all the available states on this CPU.
    Only call if supports_longhaul_msr and supports_softBR.
    Function will either succeed and return STATUS_SUCCESS or fail and not 
    touch pPss.

Arguments:

    Pss - Reference to a pointer to a pss. The pointer must point to NULL when this function is called.

Return Value:

    NT status code
    
--*/

{
    LONGHAUL_MSR longhaul_msr;
    PACPI_PSS_PACKAGE tmpPss;
    ULONG iPssSize;
    ULONG vidStart; // index in LhSoftVidSort of the greatest possible vid
    ULONG vidEnd; // index+1 in LhSoftVidSort of the smallest possible vid
    ULONG fidStart; // index in LH_SOFTBR_SORT of the greatest possible fid
    ULONG fidEnd; // index+1 in LH_SOFTBR_SORT of the smallest possible fid
    ULONG vid;
    ULONG fid;
    ULONG freq; // temp var used for frequencies
    ULONG numPStates;
    ULONG pssState;
    
    DebugAssert( Pss );
    DebugAssert( *Pss == NULL );
    
    DebugAssert( SUPPORTS_MSR && SUPPORTS_SOFTBR ); // Must support the LongHaul MSR and softBR

    MeasureFSBFreq();

    
    longhaul_msr.AsQWord= ReadMSR(MSR_LONGHAUL_ADDR);

    if( SUPPORTS_SOFTVID ) {
        // Search for the greatest vid
        vidStart = 0;
        while( vidStart < LhSoftVidSize
                && LhSoftVidSort[vidStart] != longhaul_msr.MaximumVID ) {
            ++vidStart;
        }
        DebugAssert( vidStart < LhSoftVidSize );

        // search for the smallest vid, which should come after vidStart
        // set vidEnd to one more than that
        vidEnd = vidStart;
        while( vidEnd < LhSoftVidSize
                && LhSoftVidSort[vidEnd] != longhaul_msr.MinimumVID ) {
            ++vidEnd;
        }
        DebugAssert( vidEnd < LhSoftVidSize );
        ++vidEnd;

        // Find the max freq at min volts in LH_SOFTBR_SORT
        freq = LH_MIN_BR[longhaul_msr.MinMHzBR4<<4 | longhaul_msr.MinMHzBR0] * LH_FSB[longhaul_msr.MinMHzFSB]; // freq is MHz*BR_MULT
        fidStart = 0;
        while( fidStart < LH_SOFTBR_SIZE
                && LH_SOFTBR_SORT[fidStart] != RESV
                && LH_SOFTBR[LH_SOFTBR_SORT[fidStart]] > (freq / FsbFreq) ) {
            ++fidStart;
        }
        if( fidStart == LH_SOFTBR_SIZE || LH_SOFTBR_SORT[fidStart] == RESV) {
            DebugAssert( fidStart > 0 );
            --fidStart;
        }

        DebugPrint((TRACE, " vidStart: %u(%u,%u)  vidEnd-1: %u(%u,%u)\n",
            vidStart, LhSoftVidSort[vidStart], LhSoftVid[LhSoftVidSort[vidStart]],
            vidEnd-1, LhSoftVidSort[vidEnd-1], LhSoftVid[LhSoftVidSort[vidEnd-1]] ));
    } else {
        // no vids
        vidStart = vidEnd = 0;

        // Find top fid, the max freq
        freq = LH_MAX_BR[longhaul_msr.MaxMHzBR4<<4 | longhaul_msr.MaxMHzBR0] * LH_FSB[longhaul_msr.MaxMHzFSB];
        fidStart = 0;
        while( fidStart < LH_SOFTBR_SIZE
                && LH_SOFTBR_SORT[fidStart] != RESV
                && LH_SOFTBR[LH_SOFTBR_SORT[fidStart]] > freq/FsbFreq ) {
            ++fidStart;
        }
        if( fidStart == LH_SOFTBR_SIZE || LH_SOFTBR_SORT[fidStart] == RESV) {
            DebugAssert( fidStart > 0 );
            --fidStart;
        }
    }

    fidEnd = fidStart;
    // Set fidEnd to index+1 in the LH_SOFTBR_SORT table of the lowest possible
    // BR at the lowest possible voltage
    while( fidEnd < LH_SOFTBR_SIZE
            && LH_SOFTBR_SORT[fidEnd] != RESV
            && LH_SOFTBR[LH_SOFTBR_SORT[fidEnd]] >= ABSOLUTE_MIN_FREQ/FsbFreq*BR_MULT) {
        ++fidEnd;
    }
    DebugAssert( fidStart <= fidEnd ); // Last fid to go in PSS must be slower than first fid, or they are the same for no freq only states
    DebugAssert( LH_SOFTBR_SORT[fidEnd-1]!=RESV || fidStart==fidEnd);
    DebugAssert( LH_SOFTBR[LH_SOFTBR_SORT[fidEnd-1]]>=(ABSOLUTE_MIN_FREQ/FsbFreq*BR_MULT) || fidStart==fidEnd);

    DebugPrint((TRACE, " fidStart: %u(%u,%u)  fidEnd-1: %u(%u,%u)\n",
        fidStart, LH_SOFTBR_SORT[fidStart], LH_SOFTBR[LH_SOFTBR_SORT[fidStart]],
        fidEnd-1, LH_SOFTBR_SORT[fidEnd-1], LH_SOFTBR[LH_SOFTBR_SORT[fidEnd-1]] ));

    numPStates = fidEnd - fidStart;
    if( vidStart != vidEnd ) {
        // Have some vid states, add them without double counting the state that is both a vid and fid
        numPStates += vidEnd - vidStart - 1;
    }
    
    iPssSize = (sizeof(ACPI_PSS_DESCRIPTOR) * (numPStates - 1) ) +
              sizeof(ACPI_PSS_PACKAGE);
    tmpPss = ExAllocatePoolWithTag(NonPagedPool,
                                  iPssSize,
                                  PROCESSOR_POOL_TAG);

    if( ! tmpPss ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
        
    RtlZeroMemory(tmpPss, iPssSize);
    tmpPss->NumPStates = (UCHAR) numPStates;

    pssState = 0;
    if( SUPPORTS_SOFTVID ) {
        // Add the voltage states
        DebugAssert( vidStart != vidEnd ); // must have some states
        for( vid = vidStart; vid+1 < vidEnd; ++vid ) { // Last vid state is top fid state
            PSS_CONTROL pssControl = {0};
            PSS_STATUS  pssStatus  = {0};

            freq = CalcMaxFreq(
                LhSoftVid[LhSoftVidSort[vid]],
                LhSoftVid[longhaul_msr.MinimumVID],
                LH_MIN_BR[longhaul_msr.MinMHzBR4<<4 | longhaul_msr.MinMHzBR0] * LH_FSB[longhaul_msr.MinMHzFSB],
                LhSoftVid[longhaul_msr.MaximumVID],
                LH_MAX_BR[longhaul_msr.MaxMHzBR4<<4 | longhaul_msr.MaxMHzBR0] * LH_FSB[longhaul_msr.MaxMHzFSB]
            ); // freq is in MHz * BR_MULT
 
            DebugPrint((TRACE, "Max freq at %i volts: %i\n",
                    LhSoftVid[LhSoftVidSort[vid]],
                    freq/BR_MULT));
            fid = 0;
            while( fid < LH_SOFTBR_SIZE
                    && LH_SOFTBR_SORT[fid] != RESV
                    && LH_SOFTBR[LH_SOFTBR_SORT[fid]] > freq/FsbFreq ) {
                ++fid;
            }
            DebugAssert( fid < LH_SOFTBR_SIZE );
            DebugAssert( LH_SOFTBR[LH_SOFTBR_SORT[fid]] != RESV );
            pssStatus.Fid = pssControl.Fid = LH_SOFTBR_SORT[fid];
            pssControl.EnableFid = 1;
            pssStatus.Vid = pssControl.Vid = LhSoftVidSort[vid];
            pssControl.EnableVid = 1;
                        
            tmpPss->State[pssState].Control = pssControl.AsDWord;
            tmpPss->State[pssState].Status = pssStatus.AsDWord;
            tmpPss->State[pssState].CoreFrequency =
                    FsbFreq * LH_SOFTBR[LH_SOFTBR_SORT[fid]] / BR_MULT;
            tmpPss->State[pssState].Power = LhSoftVid[LhSoftVidSort[vid]];
            tmpPss->State[pssState].Latency = DEFAULT_LATENCY_US;
            DebugPrint((TRACE, "Adding state[%i]:  Control:%x  Status:%x  CoreFreq:%i  Power:%i  V:%i  F:%i/%i\n",
                    pssState, tmpPss->State[pssState].Control, tmpPss->State[pssState].Status,
                    tmpPss->State[pssState].CoreFrequency, tmpPss->State[pssState].Power,
                    LhSoftVid[LhSoftVidSort[vid]], LH_SOFTBR[LH_SOFTBR_SORT[fid]], BR_MULT));
            ++pssState;
        }

        DebugAssert(vid == vidEnd-1); // all fid states are at low volts
        for( fid = fidStart; fid < fidEnd; ++fid ) {
            PSS_CONTROL pssControl = {0};
            PSS_STATUS  pssStatus  = {0};

            pssStatus.Fid = pssControl.Fid = LH_SOFTBR_SORT[fid];
            pssControl.EnableFid = 1;
            pssStatus.Vid = pssControl.Vid = LhSoftVidSort[vidEnd-1];
            pssControl.EnableVid = 1;
            
            tmpPss->State[pssState].Control = pssControl.AsDWord;
            tmpPss->State[pssState].Status = pssStatus.AsDWord;
            tmpPss->State[pssState].CoreFrequency =
                    FsbFreq * LH_SOFTBR[LH_SOFTBR_SORT[fid]] / BR_MULT;
            tmpPss->State[pssState].Power = LhSoftVid[LhSoftVidSort[vid]];
            tmpPss->State[pssState].Latency = DEFAULT_LATENCY_US;
            DebugPrint((TRACE, "Adding state[%i]:  Control:%x  Status:%x  CoreFreq:%i  Power:%i  V:%i  F:%i/%i\n",
                    pssState, tmpPss->State[pssState].Control, tmpPss->State[pssState].Status,
                    tmpPss->State[pssState].CoreFrequency, tmpPss->State[pssState].Power,
                    LhSoftVid[LhSoftVidSort[vid]], LH_SOFTBR[LH_SOFTBR_SORT[fid]], BR_MULT));
            ++pssState;
       }
    } else {
        for( fid = fidStart; fid < fidEnd; ++fid ) {
            PSS_CONTROL pssControl = {0};
            PSS_STATUS  pssStatus  = {0};

            pssStatus.Fid = pssControl.Fid = LH_SOFTBR_SORT[fid];
            pssControl.EnableFid = 1;
            pssControl.EnableVid = 0;
            
            tmpPss->State[pssState].Control = pssControl.AsDWord;
            tmpPss->State[pssState].Status = pssStatus.AsDWord;
            tmpPss->State[pssState].CoreFrequency =
                    FsbFreq * LH_SOFTBR[LH_SOFTBR_SORT[fid]] / BR_MULT;
            tmpPss->State[pssState].Power = POWER_V;
            tmpPss->State[pssState].Latency = DEFAULT_LATENCY_US;
            DebugPrint((TRACE, "Adding state[%i]:  Control:%x  Status:%x  CoreFreq:%i  Power:%i  F:%i/%i\n",
                    pssState, tmpPss->State[pssState].Control, tmpPss->State[pssState].Status,
                    tmpPss->State[pssState].CoreFrequency, tmpPss->State[pssState].Power,
                    LH_SOFTBR[LH_SOFTBR_SORT[fid]], BR_MULT));
            ++pssState;
       }
    }
    
    *Pss = tmpPss;
    return STATUS_SUCCESS;
}



NTSTATUS
InitializeNonAcpiPerformanceStates(
    IN  PFDO_DATA   DeviceExtension
    )

/*++

Routine Description:
    
    Create a PSS table for the legacy CPU states.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    NTSTATUS - NT status code
    
--*/

{
    NTSTATUS status = STATUS_SUCCESS;  
    
    DebugEnter();
    PAGED_CODE();


    if ( !(SUPPORTS_MSR && SUPPORTS_SOFTBR) ) {
        DebugPrint((ERROR,"CPU not supported.\n"));
        status = STATUS_NOT_SUPPORTED;
        goto InitializeNonAcpiPerformanceStatesExit;
    }
    
    DeviceExtension->CurrentPerfState = INVALID_PERF_STATE;
    
    DeviceExtension->LegacyInterface = TRUE;

    // Set up _PCT
    DeviceExtension->PctPackage.Control.AddressSpaceID = AcpiGenericSpaceFixedFunction;
    DeviceExtension->PctPackage.Status.AddressSpaceID = AcpiGenericSpaceFixedFunction;

    status = FindAcpiPerformanceStatesLongHaul(&(DeviceExtension->PssPackage));

    if (!NT_SUCCESS(status)) {
        goto InitializeNonAcpiPerformanceStatesExit;
    }

    // Need to merge this new data with our perfstates
    status = MergePerformanceStates(DeviceExtension);
    
    InitializeNonAcpiPerformanceStatesExit:   
    if (!NT_SUCCESS(status)) {
        if (DeviceExtension->PssPackage) {
            // Need to undo what has been done
            ExFreePool(DeviceExtension->PssPackage);
            DeviceExtension->PssPackage = NULL;
        }
        DeviceExtension->LegacyInterface = FALSE;
    }

    DebugExitStatus(status);
    return status;
}


NTSTATUS
AcpiLegacyPerfStateTransition(
    IN PFDO_DATA    DeviceExtension,
    IN ULONG        State
    )

/*++

Routine Description:

    Perform a transition using the FFH on LongHaul viac3 chips

Arguments:

    DeviceExtension - pointer to the device extension
    
    State - Target State

Return Value:

    NT Status
    
--*/

{
    return Acpi2PerfStateTransition(DeviceExtension, State + DeviceExtension->PpcResult);
}



NTSTATUS
GetLegacyMaxProcFrequency(
    OUT PULONG CpuSpeed
    )
    
/*++

Routine Description:

    Don't use

Arguments:

    CpuSpeed - pointer to a ULONG

Return Value:

    NTSTATUS - Always returns STATUS_NOT_FOUND
    
--*/

{

  TRAP();
  return STATUS_NOT_FOUND;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\addops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    addops.c

Abstract:

    This module implements the code to emulate the add, sub, adc, sbb,
    inc, dec, and neg opcodes.

Author:

    David N. Cutler (davec) 2-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced prototypes.
//

VOID
XmAddOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Carry
    );

VOID
XmSubOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Borrow
    );

VOID
XmAddOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an add opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Add operands and store result.
    //

    XmAddOperands(P, 0);
    return;
}

VOID
XmAdcOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an add with carry opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Add operands with carry and store result.
    //

    XmAddOperands(P, P->Eflags.EFLAG_CF);
    return;
}

VOID
XmSbbOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a subtract with borrow opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Source;

    //
    // Subtract operands with borrow and store result.
    //

    XmSubOperands(P, P->Eflags.EFLAG_CF);
    return;
}

VOID
XmSubOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a subtract opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Subtract operands and store result.
    //

    XmSubOperands(P, 0);
    return;
}

VOID
XmCmpOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmp opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Subtract operands to perform comparison operation.
    //

    XmSubOperands(P, 0);
    return;
}

VOID
XmCmpxchgOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmpxchg opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Accumulator;
    ULONG Destination;

    //
    // Compare the destination with the accumulator. If the destination
    // operand is equal to the accumulator, then set ZF and store the
    // source operand value in the destination opperand. Otherwise, clear
    // ZF and store the destination operand in the accumlator.
    //

    Destination = P->DstValue.Long;
    if (P->DataType == BYTE_DATA) {
        Accumulator = P->Gpr[AL].Xl;

    } else if (P->DataType == LONG_DATA) {
        Accumulator = P->Gpr[EAX].Exx;

    } else {
        Accumulator = P->Gpr[AX].Xx;
    }

    if (Destination == Accumulator) {
        P->Eflags.EFLAG_ZF = 1;
        XmStoreResult(P, P->SrcValue.Long);

    } else {
        P->Eflags.EFLAG_ZF = 0;
        P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
        XmStoreResult(P, P->DstValue.Long);
    }

    //
    // Subtract operands to perform comparison operation.
    //

    P->SrcValue.Long = P->DstValue.Long;
    P->DstValue.Long = Accumulator;
    XmSubOperands(P, 0);
    return;
}

VOID
XmDecOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a decrement opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Subtract operands and store result.
    //
    //

    P->SrcValue.Long = 1;
    XmSubOperands(P, 0);
    return;
}

VOID
XmIncOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an increment opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Add operands and store result.
    //

    P->SrcValue.Long = 1;
    XmAddOperands(P, 0);
    return;
}

VOID
XmNegOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a neg opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{


    //
    // Subtract operand from zero and store result.
    //

    P->SrcValue.Long = P->DstValue.Long;
    P->DstValue.Long = 0;
    XmSubOperands(P, 0);
    return;
}

VOID
XmXaddOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an xadd opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Destination;

    //
    // Exchange add operands and store result.
    //

    Destination = P->DstValue.Long;
    XmAddOperands(P, 0);
    P->DstLong = P->SrcLong;
    XmStoreResult(P, Destination);
    return;
}

VOID
XmAddOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Carry
    )

/*++

Routine Description:

    This function adds two operands and computes the resulting condition
    codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Carry - Supplies the carry value.

Return Value:

    None.

--*/

{

    ULONG CarryFlag;
    ULONG Shift;
    union {
        UCHAR ResultByte;
        ULONG ResultLong;
        USHORT ResultWord;
    } u;

    u.ResultLong = 0;
    if (P->DataType == BYTE_DATA) {
        u.ResultByte = P->SrcValue.Byte + (UCHAR)Carry;
        CarryFlag = u.ResultByte < (UCHAR)Carry;
        u.ResultByte += P->DstValue.Byte;
        CarryFlag |= (u.ResultByte < P->DstValue.Byte);
        Shift = 7;

    } else if (P->DataType == LONG_DATA) {
        u.ResultLong = P->SrcValue.Long + Carry;
        CarryFlag = (u.ResultLong < Carry);
        u.ResultLong += P->DstValue.Long;
        CarryFlag |= (u.ResultLong < P->DstValue.Long);
        Shift = 31;

    } else {
        u.ResultWord = P->SrcValue.Word + (USHORT)Carry;
        CarryFlag = (u.ResultWord < (USHORT)Carry);
        u.ResultWord += P->DstValue.Word;
        CarryFlag |= (u.ResultWord < P->DstValue.Word);
        Shift = 15;
    }

    //
    // Store the result.
    //

    XmStoreResult(P, u.ResultLong);

    //
    // If the function is not an increment, then store the carry flag.
    //

    if (P->FunctionIndex != X86_INC_OP) {
        P->Eflags.EFLAG_CF = CarryFlag;
    }

    //
    // Compute and store the parity and auxiliary carry flags.
    //

    P->Eflags.EFLAG_PF = XmComputeParity(u.ResultLong);
    P->Eflags.EFLAG_AF = ((P->DstValue.Byte & 0xf) +
                                        (P->SrcValue.Long & 0xf) + Carry) >> 4;

    //
    // Compute and store the zero and sign flags.
    //

    P->Eflags.EFLAG_ZF = (u.ResultLong == 0);
    P->Eflags.EFLAG_SF = u.ResultLong >> Shift;

    //
    // The overflow flag is computed as the carry into the sign bit
    // compared with the carry out of the sign bit.
    //

    P->Eflags.EFLAG_OF = (((P->SrcValue.Long ^ P->DstValue.Long) ^
                                        u.ResultLong) >> Shift) ^ CarryFlag;

    return;
}

VOID
XmSubOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Borrow
    )

/*++

Routine Description:

    This function adds to operands and computes the resulting condition
    codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Borrow - Supplies the boorow value.

Return Value:

    None.

--*/

{

    ULONG CarryFlag;
    ULONG Shift;
    union {
        UCHAR ResultByte;
        ULONG ResultLong;
        USHORT ResultWord;
    } u;

    u.ResultLong = 0;
    if (P->DataType == BYTE_DATA) {
        CarryFlag = (P->DstValue.Byte < (UCHAR)Borrow);
        u.ResultByte = P->DstValue.Byte - (UCHAR)Borrow;
        CarryFlag |= (u.ResultByte < P->SrcValue.Byte);
        u.ResultByte -= P->SrcValue.Byte;
        Shift = 7;

    } else if (P->DataType == LONG_DATA) {
        CarryFlag = (P->DstValue.Long < Borrow);
        u.ResultLong = P->DstValue.Long - Borrow;
        CarryFlag |= (u.ResultLong < P->SrcValue.Long);
        u.ResultLong -= P->SrcValue.Long;
        Shift = 31;

    } else {
        CarryFlag = (P->DstValue.Word < (USHORT)Borrow);
        u.ResultWord = P->DstValue.Word - (USHORT)Borrow;
        CarryFlag |= (u.ResultWord < P->SrcValue.Word);
        u.ResultWord -= P->SrcValue.Word;
        Shift = 15;
    }

    //
    // If the fucntion is not a compare or a compare and swap, then store
    // result.
    //

    if ((P->FunctionIndex != X86_CMP_OP) && (P->FunctionIndex != X86_CMPXCHG_OP)) {
        XmStoreResult(P, u.ResultLong);
    }

    //
    // If the function is not a decrement, then store the carry flag.
    //

    if (P->FunctionIndex != X86_DEC_OP) {
        P->Eflags.EFLAG_CF = CarryFlag;
    }

    //
    // Compute and store the parity and auxiliary carry flags.
    //

    P->Eflags.EFLAG_PF = XmComputeParity(u.ResultLong);
    P->Eflags.EFLAG_AF = ((P->DstValue.Byte & 0xf) -
                                        (P->SrcValue.Byte & 0xf) - Borrow) >> 4;

    //
    // If the function is not a compare and swap, then compute the zero flag.
    //

    if (P->FunctionIndex != X86_CMPXCHG_OP) {
        P->Eflags.EFLAG_ZF = (u.ResultLong == 0);
    }

    //
    // Compute and store the sign flag.
    //

    P->Eflags.EFLAG_SF = u.ResultLong >> Shift;

    //
    // The overflow flag is computed as the borrow from the sign bit
    // compared with the borrow into the sign bit.
    //

    P->Eflags.EFLAG_OF = (((P->SrcValue.Long ^ P->DstValue.Long) ^ u.ResultLong) >> Shift) ^ CarryFlag;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\asciiops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    asciiops.c

Abstract:

    This module implements the code to emulate the ASCII opcodes.

Author:

    David N. Cutler (davec) 12-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmAaaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aaa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 9) || (P->Eflags.EFLAG_AF != 0)) {
        Carry = (P->Gpr[AX].Xl > 0xf9);
        P->Gpr[AX].Xl = (P->Gpr[AX].Xl + 6) & 0xf;
        P->Gpr[AX].Xh += (UCHAR)(1 + Carry);
        P->Eflags.EFLAG_CF = 1;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Gpr[AX].Xl &= 0xf;
        P->Eflags.EFLAG_CF = 0;
        P->Eflags.EFLAG_AF = 0;
    }

    return;
}

VOID
XmAadOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aad opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Pack AH and AL into AX before division by scaling AH by 10 and
    // adding AL.
    //

    P->Gpr[AX].Xl = (P->Gpr[AX].Xh * P->SrcValue.Byte) + P->Gpr[AX].Xl;
    P->Gpr[AX].Xh = 0;
    P->Eflags.EFLAG_SF = (P->Gpr[AX].Xx >> 15) & 0x1;
    P->Eflags.EFLAG_ZF = (P->Gpr[AX].Xx == 0);
    P->Eflags.EFLAG_PF = XmComputeParity(P->Gpr[AX].Xx);
    return;
}

VOID
XmAamOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aam opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Unpack AL into AL and AH after multiplication by dividing by 10
    // and storing the quotient in AH and the remainder in AL.
    //

    P->Gpr[AX].Xh = P->Gpr[AX].Xl / P->SrcValue.Byte;
    P->Gpr[AX].Xl = P->Gpr[AX].Xl % P->SrcValue.Byte;
    P->Eflags.EFLAG_SF = (P->Gpr[AX].Xx >> 15) & 0x1;
    P->Eflags.EFLAG_ZF = (P->Gpr[AX].Xx == 0);
    P->Eflags.EFLAG_PF = XmComputeParity(P->Gpr[AX].Xx);
    return;
}

VOID
XmAasOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aaa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Borrow;

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 9) || (P->Eflags.EFLAG_AF != 0)) {
        Borrow = (P->Gpr[AX].Xl < 0x6);
        P->Gpr[AX].Xl = (P->Gpr[AX].Xl - 6) & 0xf;
        P->Gpr[AX].Xh -= (UCHAR)(1 + Borrow);
        P->Eflags.EFLAG_CF = 1;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Gpr[AX].Xl &= 0xf;
        P->Eflags.EFLAG_CF = 0;
        P->Eflags.EFLAG_AF = 0;
    }

    return;
}

VOID
XmDaaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a daa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 0x9) || (P->Eflags.EFLAG_AF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl + 6;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Eflags.EFLAG_AF = 0;
    }

    //
    // If AL is greater than 9 or CF is set, then adjust ASCII result.
    //

    if ((P->Gpr[AX].Xl > 9) || (P->Eflags.EFLAG_CF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl + 0x60;
        P->Eflags.EFLAG_CF = 1;

    } else {
        P->Eflags.EFLAG_CF = 0;
    }

    return;
}

VOID
XmDasOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a daa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 0x9) || (P->Eflags.EFLAG_AF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl - 6;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Eflags.EFLAG_AF = 0;
    }

    //
    // If AL is greater than 9 or CF is set, then adjust ASCII result.
    //

    if ((P->Gpr[AX].Xl > 9) || (P->Eflags.EFLAG_CF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl - 0x60;
        P->Eflags.EFLAG_CF = 1;

    } else {
        P->Eflags.EFLAG_CF = 0;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\bitops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    bitops.c

Abstract:

    This module implements the code to emulate the bit opcodes.

Author:

    David N. Cutler (davec) 12-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmBsfOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bsf opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Result;
    ULONG Source;

    //
    // If the source operand is zero, then set ZF and set the destination
    // to zero, Otherwise, find the first bit set scanning from right to
    // left.
    //

    Result = 0;
    Source = P->SrcValue.Long;
    P->Eflags.EFLAG_ZF = 1;
    while (Source != 0) {
        if ((Source & 1) != 0) {
            P->Eflags.EFLAG_ZF = 0;
            break;
        }

        Result += 1;
        Source >>= 1;
    };

    XmStoreResult(P, Result);
    return;
}

VOID
XmBsrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bsr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Result;
    ULONG Source;

    //
    // If the source operand is zero, then set ZF and set the destination
    // to zero, Otherwise, find the first bit set scanning from left to
    // right.
    //

    Result = ((P->DataType + 1) << 3) - 1;
    Source = P->SrcValue.Long;
    P->Eflags.EFLAG_ZF = 1;
    while (Source != 0) {
        if (((Source >> Result) & 1) != 0) {
            P->Eflags.EFLAG_ZF = 0;
            break;
        }

        Result -= 1;
    };

    XmStoreResult(P, Result);
    return;
}

VOID
XmBtOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bt opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test the specified bit and store the bit in CF.
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    return;
}

VOID
XmBtsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bts opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test and set the specified bit and store the bit in CF.
    //
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    P->DstValue.Long |= (1 << P->SrcValue.Long);
    XmStoreResult(P, P->DstValue.Long);
    return;
}

VOID
XmBtrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an btr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test and reset the specified bit and store the bit in CF.
    //
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    P->DstValue.Long &= ~(1 << P->SrcValue.Long);
    XmStoreResult(P, P->DstValue.Long);
    return;
}

VOID
XmBtcOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an btc opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test and reset the specified bit and store the bit in CF.
    //
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    P->DstValue.Long ^= (1 << P->SrcValue.Long);
    XmStoreResult(P, P->DstValue.Long);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\condops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    condops.c

Abstract:

    This module implements the code to emulate condition code opcodes.

Author:

    David N. Cutler (davec) 22-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmClcOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a clc opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Clear carry flag.
    //

    P->Eflags.EFLAG_CF = 0;
    return;
}

VOID
XmCldOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cld opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Clear direction flag.
    //

    P->Eflags.EFLAG_DF = 0;
    return;
}

VOID
XmCliOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cli opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Clear interrupt flag.
    //

    P->Eflags.EFLAG_IF = 0;
    return;
}

VOID
XmCmcOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmc opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Complement carry flag.
    //

    P->Eflags.EFLAG_CF ^= 1;
    return;
}

VOID
XmStcOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a stc opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set carry flag.
    //

    P->Eflags.EFLAG_CF = 1;
    return;
}

VOID
XmStdOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a std opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set direction flag.
    //

    P->Eflags.EFLAG_DF = 1;
    return;
}

VOID
XmStiOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a sti opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set interrupt flag.
    //

    P->Eflags.EFLAG_IF = 1;
    return;
}

VOID
XmLahfOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a lahf opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Load flags into AH.
    //

    P->DataType = BYTE_DATA;
    P->DstByte = &P->Gpr[AX].Xh;
    XmStoreResult(P, (ULONG)P->AhFlags);
    return;
}

VOID
XmSahfOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a sahf opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Store CF, PF, AF, ZF, SF of AH in flags.
    //

    P->AhFlags = P->Gpr[AX].Xh;
    P->Eflags.EFLAG_MBO = 1;
    P->Eflags.EFLAG_SBZ0 = 0;
    P->Eflags.EFLAG_SBZ1 = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\data.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for the x86 bios emulator.

Author:

    David N. Cutler (davec) 10-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define emulator initialized variable.
//

BOOLEAN XmEmulatorInitialized = FALSE;

//
// Define emulator context structure.
//

XM_CONTEXT XmContext;

//
// Define operand decode table.
//
// This table contains the execution routine for each of the operand types.
//
// N.B. There is a cross indexing between the operand decode field of the
//      opcode control array and the decode table.
//

const POPERAND_DECODE XmOperandDecodeTable[] = {
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmGroup1General,
    XmGroup1Immediate,
    XmGroup2By1,
    XmGroup2ByCL,
    XmGroup2ByByte,
    XmGroup3General,
    XmGroup45General,
    XmGroup45General,
    XmGroup8BitOffset,
    XmOpcodeRegister,
    XmLongJump,
    XmShortJump,
    XmSetccByte,
    XmAccumImmediate,
    XmAccumRegister,
    XmMoveGeneral,
    XmMoveImmediate,
    XmMoveRegImmediate,
    XmSegmentOffset,
    XmMoveSegment,
    XmMoveXxGeneral,
    XmFlagsRegister,
    XmPushImmediate,
    XmPopGeneral,
    XmImulImmediate,
    XmStringOperands,
    XmEffectiveOffset,
    XmImmediateJump,
    XmImmediateEnter,
    XmGeneralBitOffset,
    XmShiftDouble,
    XmPortImmediate,
    XmPortDX,
    XmBitScanGeneral,
    XmByteImmediate,
    XmXlatOpcode,
    XmGeneralRegister,
    XmNoOperands,
    XmOpcodeEscape,
    XmPrefixOpcode
};

//
// Define opcode function table.
//
// This table contains the execution routine for each opcode.
//
// N.B. There is cross indexing between the function index field of the
//      opcode control array and the function table. The function index
//      in the opcode control array may be the index of the execution
//      function, the base index of the execution function, or a switch
//      value to be used in selecting the function (i.e., prefix opcodes).
//

const POPCODE_FUNCTION XmOpcodeFunctionTable[] = {

    //
    // ASCII operators.
    //

    XmAaaOp,
    XmAadOp,
    XmAamOp,
    XmAasOp,
    XmDaaOp,
    XmDasOp,

    //
    // Group 1 operators.
    //

    XmAddOp,
    XmOrOp,
    XmAdcOp,
    XmSbbOp,
    XmAndOp,
    XmSubOp,
    XmXorOp,
    XmCmpOp,

    //
    // Group 2 operators.
    //

    XmRolOp,
    XmRorOp,
    XmRclOp,
    XmRcrOp,
    XmShlOp,
    XmShrOp,
    XmIllOp,
    XmSarOp,

    //
    // Group 3 operators.
    //

    XmTestOp,
    XmIllOp,
    XmNotOp,
    XmNegOp,
    XmMulOp,
    XmImulxOp,
    XmDivOp,
    XmIdivOp,

    //
    // Group 4 and 5 operators.
    //

    XmIncOp,
    XmDecOp,
    XmCallOp,
    XmCallOp,
    XmJmpOp,
    XmJmpOp,
    XmPushOp,
    XmIllOp,

    //
    // Group 8 operators.
    //

    XmBtOp,
    XmBtsOp,
    XmBtrOp,
    XmBtcOp,

    //
    // Stack push and pop operators.
    //

    XmPopOp,
    XmPushaOp,
    XmPopaOp,

    //
    // Conditional jump operators.
    //

    XmJxxOp,
    XmLoopOp,
    XmJcxzOp,

    //
    // Control operators.
    //

    XmEnterOp,
    XmHltOp,
    XmIntOp,
    XmIretOp,
    XmLeaveOp,
    XmRetOp,

    //
    // Set boolean byte value based on condition.
    //

    XmSxxOp,

    //
    // Condition code operators.
    //

    XmCmcOp,
    XmClcOp,
    XmStcOp,
    XmCliOp,
    XmStiOp,
    XmCldOp,
    XmStdOp,
    XmLahfOp,
    XmSahfOp,

    //
    // General move operators.
    //

    XmMovOp,
    XmXchgOp,

    //
    // Convert operators.
    //

    XmCbwOp,
    XmCwdOp,

    //
    // Single multiply operator.
    //

    XmImulOp,

    //
    // String operators.
    //

    XmCmpsOp,
    XmInsOp,
    XmLodsOp,
    XmMovsOp,
    XmOutsOp,
    XmScasOp,
    XmStosOp,

    //
    // Effective address operators.
    //

    XmBoundOp,
    XmMovOp,

    //
    // Double Shift operators.
    //

    XmShldOp,
    XmShrdOp,

    //
    // I/O operators.
    //

    XmInOp,
    XmOutOp,

    //
    // Bit scan operators.
    //

    XmBsfOp,
    XmBsrOp,

    //
    // Byte swap operators.
    //

    XmBswapOp,

    //
    // Add/Compare exchange operators.
    //

    XmXaddOp,
    XmCmpxchgOp,

    //
    // No operation.
    //

    XmNopOp,

    //
    // Illegal opcode.
    //

    XmIllOp
};

//
// Define opcode control table.
//
// There are two opcode tables which control the emulation of each x86
// opcode. One table is for single byte opcodes and the other is for
// two byte opcodes.
//

const OPCODE_CONTROL XmOpcodeControlTable1[] = {
    {X86_ADD_OP,   FormatGroup1General},     // 0x00 - add Eb,Gb
    {X86_ADD_OP,   FormatGroup1General},     // 0x01 - add Ev,Gv
    {X86_ADD_OP,   FormatGroup1General},     // 0x02 - add Gb,Eb
    {X86_ADD_OP,   FormatGroup1General},     // 0x03 - add Gv,Ev
    {X86_ADD_OP,   FormatAccumImmediate},    // 0x04 - add AL,Ib
    {X86_ADD_OP,   FormatAccumImmediate},    // 0x05 - add eAX,Iv
    {X86_PUSH_OP,  FormatSegmentES},         // 0x06 - push ES
    {X86_POP_OP,   FormatSegmentES},         // 0x07 - pop  ES
    {X86_OR_OP,    FormatGroup1General},     // 0x08 - or Eb,Gb
    {X86_OR_OP,    FormatGroup1General},     // 0x09 - or Ev,Gv
    {X86_OR_OP,    FormatGroup1General},     // 0x0a - or Gb,Eb
    {X86_OR_OP,    FormatGroup1General},     // 0x0b - or Gv,Ev
    {X86_OR_OP,    FormatAccumImmediate},    // 0x0c - or AL,Ib
    {X86_OR_OP,    FormatAccumImmediate},    // 0x0d - or eAX,Iv
    {X86_PUSH_OP,  FormatSegmentCS},         // 0x0e - push CS
    {0,            FormatOpcodeEscape},      // 0x0f - escape:
    {X86_ADC_OP,   FormatGroup1General},     // 0x10 - adc Eb,Gb
    {X86_ADC_OP,   FormatGroup1General},     // 0x11 - adc Ev,Gv
    {X86_ADC_OP,   FormatGroup1General},     // 0x12 - adc Gb,Eb
    {X86_ADC_OP,   FormatGroup1General},     // 0x13 - adc Gv,Ev
    {X86_ADC_OP,   FormatAccumImmediate},    // 0x14 - adc AL,Ib
    {X86_ADC_OP,   FormatAccumImmediate},    // 0x15 - adc eAX,Iv
    {X86_PUSH_OP,  FormatSegmentSS},         // 0x16 - push SS
    {X86_POP_OP,   FormatSegmentSS},         // 0x17 - pop  SS
    {X86_SBB_OP,   FormatGroup1General},     // 0x18 - sbb Eb,Gb
    {X86_SBB_OP,   FormatGroup1General},     // 0x19 - sbb Ev,Gv
    {X86_SBB_OP,   FormatGroup1General},     // 0x1a - sbb Gb,Eb
    {X86_SBB_OP,   FormatGroup1General},     // 0x1b - sbb Gv,Ev
    {X86_SBB_OP,   FormatAccumImmediate},    // 0x1c - sbb AL,Ib
    {X86_SBB_OP,   FormatAccumImmediate},    // 0x1d - sbb eAX,Iv
    {X86_PUSH_OP,  FormatSegmentDS},         // 0x1e - push DS
    {X86_POP_OP,   FormatSegmentDS},         // 0x1f - pop  DS
    {X86_AND_OP,   FormatGroup1General},     // 0x20 - and Eb,Gb
    {X86_AND_OP,   FormatGroup1General},     // 0x21 - and Ev,Gv
    {X86_AND_OP,   FormatGroup1General},     // 0x22 - and Gb,Eb
    {X86_AND_OP,   FormatGroup1General},     // 0x23 - and Gv,Ev
    {X86_AND_OP,   FormatAccumImmediate},    // 0x24 - and AL,Ib
    {X86_AND_OP,   FormatAccumImmediate},    // 0x25 - and eAX,Iv
    {X86_ES_OP,    FormatPrefixOpcode},      // 0x26 - ES:
    {X86_DAA_OP,   FormatNoOperands},        // 0x27 - daa
    {X86_SUB_OP,   FormatGroup1General},     // 0x28 - sub Eb,Gb
    {X86_SUB_OP,   FormatGroup1General},     // 0x29 - sub Ev,Gv
    {X86_SUB_OP,   FormatGroup1General},     // 0x2a - sub Gb,Eb
    {X86_SUB_OP,   FormatGroup1General},     // 0x2b - sub Gv,Ev
    {X86_SUB_OP,   FormatAccumImmediate},    // 0x2c - sub AL,Ib
    {X86_SUB_OP,   FormatAccumImmediate},    // 0x2d - sub eAX,Iv
    {X86_CS_OP,    FormatPrefixOpcode},      // 0x2e - CS:
    {X86_DAS_OP,   FormatNoOperands},        // 0x2f - das
    {X86_XOR_OP,   FormatGroup1General},     // 0x30 - xor Eb,Gb
    {X86_XOR_OP,   FormatGroup1General},     // 0x31 - xor Ev,Gv
    {X86_XOR_OP,   FormatGroup1General},     // 0x32 - xor Gb,Eb
    {X86_XOR_OP,   FormatGroup1General},     // 0x33 - xor Gv,Ev
    {X86_XOR_OP,   FormatAccumImmediate},    // 0x34 - xor AL,Ib
    {X86_XOR_OP,   FormatAccumImmediate},    // 0x35 - xor eAX,Iv
    {X86_SS_OP,    FormatPrefixOpcode},      // 0x36 - SS:
    {X86_AAA_OP,   FormatNoOperands},        // 0x37 - aaa
    {X86_CMP_OP,   FormatGroup1General},     // 0x38 - cmp Eb,Gb
    {X86_CMP_OP,   FormatGroup1General},     // 0x39 - cmp Ev,Gv
    {X86_CMP_OP,   FormatGroup1General},     // 0x3a - cmp Gb,Eb
    {X86_CMP_OP,   FormatGroup1General},     // 0x3b - cmp Gv,Ev
    {X86_CMP_OP,   FormatAccumImmediate},    // 0x3c - cmp AL,Ib
    {X86_CMP_OP,   FormatAccumImmediate},    // 0x3d - cmp eAX,Iv
    {X86_DS_OP,    FormatPrefixOpcode},      // 0x3e - DS:
    {X86_AAS_OP,   FormatNoOperands},        // 0x3f - aas
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x40 - inc eAX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x41 - inc eCX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x42 - inc eDX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x43 - inc eBX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x44 - inc eSP
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x45 - inc eBP
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x46 - inc eSI
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x47 - inc eDI
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x48 - dec eAX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x49 - dec eCX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4a - dec eDX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4b - dec eBX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4c - dec eSP
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4d - dec eBP
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4e - dec eSI
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4f - dec eDI
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x50 - push eAX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x51 - push eCX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x52 - push eDX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x53 - push eBX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x54 - push eSP
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x55 - push eBP
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x56 - push eSI
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x57 - push eDI
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x58 - pop eAX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x59 - pop eCX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5a - pop eDX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5b - pop eBX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5c - pop eSP
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5d - pop eBP
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5e - pop eSI
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5f - pop eDI
    {X86_PUSHA_OP, FormatNoOperands},        // 0x60 - pusha
    {X86_POPA_OP,  FormatNoOperands},        // 0x61 - popa
    {X86_BOUND_OP, FormatEffectiveOffset},   // 0x62 - bound Gv,Ma
    {X86_ILL_OP,   FormatNoOperands},        // 0x63 - arpl Ew,Rw
    {X86_FS_OP,    FormatPrefixOpcode},      // 0x64 - FS:
    {X86_GS_OP,    FormatPrefixOpcode},      // 0x65 - GS:
    {X86_OPSZ_OP,  FormatPrefixOpcode},      // 0x66 - opsize
    {X86_ADSZ_OP,  FormatPrefixOpcode},      // 0x67 - opaddr
    {X86_PUSH_OP,  FormatPushImmediate},     // 0x68 - push iv
    {X86_IMUL_OP,  FormatImulImmediate},     // 0x69 - imul
    {X86_PUSH_OP,  FormatPushImmediate},     // 0x6a - push ib
    {X86_IMUL_OP,  FormatImulImmediate},     // 0x6b - imul
    {X86_INS_OP,   FormatPortDX},            // 0x6c - insb
    {X86_INS_OP,   FormatPortDX},            // 0x6d - insw/d
    {X86_OUTS_OP,  FormatPortDX},            // 0x6e - outsb
    {X86_OUTS_OP,  FormatPortDX},            // 0x6f - outsw/d
    {X86_JXX_OP,   FormatShortJump},         // 0x70 - jo   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x71 - jno  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x72 - jb   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x73 - jnb  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x74 - jz   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x75 - jnz  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x76 - jbe  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x77 - jnbe jb
    {X86_JXX_OP,   FormatShortJump},         // 0x78 - js   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x79 - jns  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7a - jp   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7b - jnp  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7c - jl   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7d - jnl  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7e - jle  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7f - jnle jb
    {X86_ADD_OP,   FormatGroup1Immediate},   // 0x80 - group1 Eb,Ib
    {X86_ADD_OP,   FormatGroup1Immediate},   // 0x81 - group1 Ev,Iv
    {X86_ILL_OP,   FormatNoOperands},        // 0x82 - illegal
    {X86_ADD_OP,   FormatGroup1Immediate},   // 0x83 - group1 Ev,Ib
    {X86_TEST_OP,  FormatGroup1General},     // 0x84 - test Eb,Gb
    {X86_TEST_OP,  FormatGroup1General},     // 0x85 - test Ev,Gv
    {X86_XCHG_OP,  FormatGroup1General},     // 0x86 - xchg Eb,Gb
    {X86_XCHG_OP,  FormatGroup1General},     // 0x87 = xchg Ev,Gv
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x88 - mov Eb,Gb
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x89 - mov Ev,Gv
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x8a - mov Gb,Eb
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x8b - mov Gv,Ev
    {X86_MOV_OP,   FormatMoveSegment},       // 0x8c - mov Ew,Sw
    {X86_LEA_OP,   FormatEffectiveOffset},   // 0x8d - lea Gv,Ma
    {X86_MOV_OP,   FormatMoveSegment},       // 0x8e - mov Sw,Ew
    {X86_POP_OP,   FormatPopGeneral},        // 0x8f - pop Ev
    {X86_NOP_OP,   FormatNoOperands},        // 0x90 - nop
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x91 - xchg eCX,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x92 - xchg eDX,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x93 - xchg eBX,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x94 - xchg eSP,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x95 - xchg eBP,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x96 - xchg eSI,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x97 - xchg eDI,eAX
    {X86_CBW_OP,   FormatNoOperands},        // 0x98 - cbw
    {X86_CWD_OP,   FormatNoOperands},        // 0x99 - cwd
    {X86_CALL_OP,  FormatImmediateJump},     // 0x9a - call Ap
    {X86_NOP_OP,   FormatNoOperands},        // 0x9b - wait
    {X86_PUSH_OP,  FormatFlagsRegister},     // 0x9c - pushf
    {X86_POP_OP,   FormatFlagsRegister},     // 0x9d - popf
    {X86_SAHF_OP,  FormatNoOperands},        // 0x9e - sahf
    {X86_LAHF_OP,  FormatNoOperands},        // 0x9f - lahf
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa0 - mov AL,Ob
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa1 - mov eAX,Ov
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa2 - mov Ob,AL
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa3 - mov Ov,eAX
    {X86_MOVS_OP,  FormatStringOperands},    // 0xa4 - movsb
    {X86_MOVS_OP,  FormatStringOperands},    // 0xa5 - movsw/d
    {X86_CMPS_OP,  FormatStringOperands},    // 0xa6 - cmpsb
    {X86_CMPS_OP,  FormatStringOperands},    // 0xa7 - cmpsw/d
    {X86_TEST_OP,  FormatAccumImmediate},    // 0xa8 - test AL,Ib
    {X86_TEST_OP,  FormatAccumImmediate},    // 0xa9 - test eAX,Iv
    {X86_STOS_OP,  FormatStringOperands},    // 0xaa - stosb
    {X86_STOS_OP,  FormatStringOperands},    // 0xab - stosw/d
    {X86_LODS_OP,  FormatStringOperands},    // 0xac - lodsb
    {X86_LODS_OP,  FormatStringOperands},    // 0xad - lodsw.d
    {X86_SCAS_OP,  FormatStringOperands},    // 0xae - scasb
    {X86_SCAS_OP,  FormatStringOperands},    // 0xaf - scasw/d
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb0 mov AL,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb1 mov Cl,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb2 mov DL,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb3 mov BL,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb4 mov AH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb5 mov CH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb6 mov DH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb7 mov BH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb8 mov eAX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb9 mov eCX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xba mov eDX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbb mov eBX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbc mov eSP,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbd mov eBP,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbe mov eSI,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbf mov eDI,Iv
    {X86_ROL_OP,   FormatGroup2ByByte},      // 0xc0 - group2 Eb,Ib
    {X86_ROL_OP,   FormatGroup2ByByte},      // 0xc1 - group2 Ev,Ib
    {X86_RET_OP,   FormatNoOperands},        // 0xc2 - ret Iw (near)
    {X86_RET_OP,   FormatNoOperands},        // 0xc3 - ret (near)
    {X86_MOV_OP,   FormatLoadSegmentES},     // 0xc4 - les Gv,Mp
    {X86_MOV_OP,   FormatLoadSegmentDS},     // 0xc5 - lds Gv,Mp
    {X86_MOV_OP,   FormatMoveImmediate},     // 0xc6 - mov Eb,Ib
    {X86_MOV_OP,   FormatMoveImmediate},     // 0xc7 - mov Ev,Iv
    {X86_ENTER_OP, FormatImmediateEnter},    // 0xc8 - enter Iw,Ib
    {X86_LEAVE_OP, FormatNoOperands},        // 0xc9 - leave
    {X86_RET_OP,   FormatNoOperands},        // 0xca - ret Iw (far)
    {X86_RET_OP,   FormatNoOperands},        // 0xcb - ret (far)
    {X86_INT_OP,   FormatNoOperands},        // 0xcc - int 3
    {X86_INT_OP,   FormatByteImmediate},     // 0xcd - int Ib
    {X86_INT_OP,   FormatNoOperands},        // 0xce - into
    {X86_IRET_OP,  FormatNoOperands},        // 0xcf - iret
    {X86_ROL_OP,   FormatGroup2By1},         // 0xd0 - group2 Eb,1
    {X86_ROL_OP,   FormatGroup2By1},         // 0xd1 - group2 Ev,1
    {X86_ROL_OP,   FormatGroup2ByCL},        // 0xd2 - group2 Eb,CL
    {X86_ROL_OP,   FormatGroup2ByCL},        // 0xd3 - group2 Ev,CL
    {X86_AAM_OP,   FormatByteImmediate},     // 0xd4 - aam
    {X86_AAD_OP,   FormatByteImmediate},     // 0xd5 - aad
    {X86_ILL_OP,   FormatNoOperands},        // 0xd6 - illegal
    {X86_MOV_OP,   FormatXlatOpcode},        // 0xd7 - xlat
    {X86_ILL_OP,   FormatNoOperands},        // 0xd8 - esc0
    {X86_ILL_OP,   FormatNoOperands},        // 0xd9 - esc1
    {X86_ILL_OP,   FormatNoOperands},        // 0xda - esc2
    {X86_ILL_OP,   FormatNoOperands},        // 0xdb - esc3
    {X86_ILL_OP,   FormatNoOperands},        // 0xdc - esc4
    {X86_ILL_OP,   FormatNoOperands},        // 0xdd - esc5
    {X86_ILL_OP,   FormatNoOperands},        // 0xde - esc6
    {X86_ILL_OP,   FormatNoOperands},        // 0xdf - esc7
    {X86_LOOP_OP,  FormatShortJump},         // 0xe0 - loopnz
    {X86_LOOP_OP,  FormatShortJump},         // 0xe1 - loopz
    {X86_LOOP_OP,  FormatShortJump},         // 0xe2 - loop
    {X86_JCXZ_OP,  FormatShortJump},         // 0xe3 - jcxz
    {X86_IN_OP,    FormatPortImmediate},     // 0xe4 - inb AL,Ib
    {X86_IN_OP,    FormatPortImmediate},     // 0xe5 - inw/d eAX,Ib
    {X86_OUT_OP,   FormatPortImmediate},     // 0xe6 - outb Ib,AL
    {X86_OUT_OP,   FormatPortImmediate},     // 0xe7 - outw/d Ib,eAX
    {X86_CALL_OP,  FormatLongJump},          // 0xe8 - call Jv
    {X86_JMP_OP,   FormatLongJump},          // 0xe9 - jmp Jv
    {X86_JMP_OP,   FormatImmediateJump},     // 0xea - jmp Ap
    {X86_JMP_OP,   FormatShortJump},         // 0xeb - jmp Jb
    {X86_IN_OP,    FormatPortDX},            // 0xec - inb AL,DX
    {X86_IN_OP,    FormatPortDX},            // 0xed - inw/d eAX,DX
    {X86_OUT_OP,   FormatPortDX},            // 0xee - outb Ib,DX
    {X86_OUT_OP,   FormatPortDX},            // 0xef - outw/d eAX,DX
    {X86_LOCK_OP,  FormatPrefixOpcode},      // 0xf0 - lock
    {X86_ILL_OP,   FormatNoOperands},        // 0xf1 - illegal
    {X86_REPNZ_OP, FormatPrefixOpcode},      // 0xf2 - repnz
    {X86_REPZ_OP,  FormatPrefixOpcode},      // 0xf3 - repz
    {X86_HLT_OP,   FormatNoOperands},        // 0xf4 - hlt
    {X86_CMC_OP,   FormatNoOperands},        // 0xf5 - cmc
    {X86_TEST_OP,  FormatGroup3General},     // 0xf6 - group3 Eb,?
    {X86_TEST_OP,  FormatGroup3General},     // 0xf7 - group3 Ev,?
    {X86_CLC_OP,   FormatNoOperands},        // 0xf8 - clc
    {X86_STC_OP,   FormatNoOperands},        // 0xf9 - stc
    {X86_CLI_OP,   FormatNoOperands},        // 0xfa - cli
    {X86_STI_OP,   FormatNoOperands},        // 0xfb - sti
    {X86_CLD_OP,   FormatNoOperands},        // 0xfc - cld
    {X86_STD_OP,   FormatNoOperands},        // 0xfd - std
    {X86_INC_OP,   FormatGroup4General},     // 0xfe - group4 Eb
    {X86_INC_OP,   FormatGroup5General},     // 0xff - group5 Ev
};

const OPCODE_CONTROL XmOpcodeControlTable2[] = {
    {X86_ILL_OP,   FormatNoOperands},        // 0x00 - group6
    {X86_ILL_OP,   FormatNoOperands},        // 0x01 - group7
    {X86_ILL_OP,   FormatNoOperands},        // 0x02 - lar
    {X86_ILL_OP,   FormatNoOperands},        // 0x03 - lsl
    {X86_ILL_OP,   FormatNoOperands},        // 0x04 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x05 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x06 - clts
    {X86_ILL_OP,   FormatNoOperands},        // 0x07 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x08 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x09 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x10 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x11 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x12 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x13 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x14 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x15 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x16 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x17 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x18 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x19 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x20 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x21 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x22 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x23 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x34 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x25 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x26 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x27 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x28 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x29 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x30 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x31 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x32 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x33 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x34 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x35 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x36 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x37 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x38 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x39 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x40 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x41 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x42 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x43 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x44 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x45 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x46 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x47 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x48 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x49 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x50 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x51 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x52 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x53 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x54 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x55 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x56 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x57 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x58 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x59 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x60 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x61 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x62 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x63 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x64 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x65 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x66 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x67 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x68 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x69 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x70 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x71 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x72 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x73 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x74 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x75 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x76 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x77 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x78 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x79 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7f - illegal
    {X86_JXX_OP,   FormatLongJump},          // 0x80 - jo   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x81 - jno  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x82 - jb   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x83 - jnb  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x84 - jz   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x85 - jnz  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x86 - jbe  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x87 - jnbe jv
    {X86_JXX_OP,   FormatLongJump},          // 0x88 - js   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x89 - jns  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8a - jp   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8b - jnp  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8c - jl   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8d - jnl  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8e - jle  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8f - jnle jv
    {X86_SXX_OP,   FormatSetccByte},         // 0x90 - seto   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x91 - setno  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x92 - setb   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x93 - setnb  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x94 - setz   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x95 - setnz  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x96 - setbe  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x97 - setnbe Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x98 - sets   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x99 - setns  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9a - setp   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9b - setnp  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9c - setl   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9d - setnl  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9e - setle  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9f - setnle Eb
    {X86_PUSH_OP,  FormatSegmentFS},         // 0xa0 - push FS
    {X86_POP_OP,   FormatSegmentFS},         // 0xa1 - pop  FS
    {X86_ILL_OP,   FormatNoOperands},        // 0xa2 - illegal
    {X86_BT_OP,    FormatGeneralBitOffset},  // 0xa3 - bt Ev,Gv
    {X86_SHLD_OP,  FormatShiftDouble},       // 0xa4 - shld Ev,Gv,Ib
    {X86_SHLD_OP,  FormatShiftDouble},       // 0xa5 - shld Ev,Gv,cl
    {X86_ILL_OP,   FormatNoOperands},        // 0xa6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xa6 - illegal
    {X86_PUSH_OP,  FormatSegmentGS},         // 0xa8 - push GS
    {X86_POP_OP,   FormatSegmentGS},         // 0xa9 - pop  GS
    {X86_ILL_OP,   FormatNoOperands},        // 0xaa - illegal
    {X86_BTS_OP,   FormatGeneralBitOffset},  // 0xab - bts Ev,Gv
    {X86_SHRD_OP,  FormatShiftDouble},       // 0xac - shdr Ev,Gv,Ib
    {X86_SHRD_OP,  FormatShiftDouble},       // 0xad - shdr Rv,Gv,cl
    {X86_ILL_OP,   FormatNoOperands},        // 0xae - illegal
    {X86_IMUL_OP,  FormatGroup1General},     // 0xaf - imul Gv,Ev
    {X86_CMPXCHG_OP, FormatGroup1General},   // 0xb0 - cmpxchg Eb,Gb
    {X86_CMPXCHG_OP, FormatGroup1General},   // 0xb1 - cmpxchg Ev,Gv
    {X86_MOV_OP,   FormatLoadSegmentSS},     // 0xb2 - lss Gv,Mp
    {X86_BTR_OP,   FormatGeneralBitOffset},  // 0xb3 - btr Ev,Gv
    {X86_MOV_OP,   FormatLoadSegmentFS},     // 0xb4 - lfs Gv,Mp
    {X86_MOV_OP,   FormatLoadSegmentGS},     // 0xb5 - lgd Gv,Mp
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xb6 - movzb Gv,Eb
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xb7 - movsw Gv,Ew
    {X86_ILL_OP,   FormatNoOperands},        // 0xb8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xb9 - illegal
    {X86_BT_OP,    FormatGroup8BitOffset},   // 0xba - group8 Ev,Ib
    {X86_BTC_OP,   FormatGeneralBitOffset},  // 0xbb - btc Ev,Gv
    {X86_BSF_OP,   FormatBitScanGeneral},    // 0xbc - bsf Gv,Ev
    {X86_BSR_OP,   FormatBitScanGeneral},    // 0xbd - bsr Gv,Ev
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xbe - movsb Gv,Eb
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xbf - movsw Gv,Ew
    {X86_XADD_OP,  FormatGroup1General},     // 0xc0 - xadd Eb,Gb
    {X86_XADD_OP,  FormatGroup1General},     // 0xc1 - xadd Ev,Gv
    {X86_ILL_OP,   FormatNoOperands},        // 0xc2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc7 - illegal
    {X86_BSWAP_OP, FormatGeneralRegister},   // 0xc8 - bswap Gv
    {X86_ILL_OP,   FormatNoOperands},        // 0xc9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xca - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcc - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcd - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xce - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcf - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd0 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd1 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd7 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xda - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdc - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdd - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xde - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdf - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe0 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe1 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe7 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xea - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xeb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xec - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xed - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xee - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xef - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf0 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf1 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf7 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfa - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfc - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfd - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfe - illegal
    {X86_ILL_OP,   FormatNoOperands}         // 0xff - illegal
};

//
// Define opcode name tables.
//

#if defined(XM_DEBUG)

const PCHAR XmOpcodeNameTable1[] = {
    "add Eb,Gb    ", // 0x00
    "add Ev,Gv    ", // 0x01
    "add Gb,Eb    ", // 0x02
    "add Gv,Ev    ", // 0x03
    "add AL,Ib    ", // 0x04
    "add eAX,Iv   ", // 0x05
    "push ES      ", // 0x06
    "pop  ES      ", // 0x07
    "or  Eb,Gb    ", // 0x08
    "or  Ev,Gv    ", // 0x09
    "or  Gb,Eb    ", // 0x0a
    "or  Gv,Ev    ", // 0x0b
    "or  AL,Ib    ", // 0x0c
    "or  eAX,Iv   ", // 0x0d
    "push CS      ", // 0x0e
    "escape:      ", // 0x0f
    "adc Eb,Gb    ", // 0x10
    "adc Ev,Gv    ", // 0x11
    "adc Gb,Eb    ", // 0x12
    "adc Gv,Ev    ", // 0x13
    "adc AL,Ib    ", // 0x14
    "adc eAX,Iv   ", // 0x15
    "push SS      ", // 0x16
    "pop  SS      ", // 0x17
    "sbb Eb,Gb    ", // 0x18
    "sbb Ev,Gv    ", // 0x19
    "sbb Gb,Eb    ", // 0x1a
    "sbb Gv,Ev    ", // 0x1b
    "sbb AL,Ib    ", // 0x1c
    "sbb eAX,Iv   ", // 0x1d
    "push DS      ", // 0x1e
    "pop  DS      ", // 0x1f
    "and Eb,Gb    ", // 0x20
    "and Ev,Gv    ", // 0x21
    "and Gb,Eb    ", // 0x22
    "and Gv,Ev    ", // 0x23
    "and AL,Ib    ", // 0x24
    "and eAX,Iv   ", // 0x25
    "ES:          ", // 0x26
    "daa          ", // 0x27
    "sub Eb,Gb    ", // 0x28
    "sub Ev,Gv    ", // 0x29
    "sub Gb,Eb    ", // 0x2a
    "sub Gv,Ev    ", // 0x2b
    "sub AL,Ib    ", // 0x2c
    "sub eAX,Iv   ", // 0x2d
    "CS:          ", // 0x2e
    "das          ", // 0x2f
    "xor Eb,Gb    ", // 0x30
    "xor Ev,Gv    ", // 0x31
    "xor Gb,Eb    ", // 0x32
    "xor Gv,Ev    ", // 0x33
    "xor AL,Ib    ", // 0x34
    "xor eAX,Iv   ", // 0x35
    "SS:          ", // 0x36
    "aaa          ", // 0x37
    "cmp Eb,Gb    ", // 0x38
    "cmp Ev,Gv    ", // 0x39
    "cmp Gb,Eb    ", // 0x3a
    "cmp Gv,Ev    ", // 0x3b
    "cmp AL,Ib    ", // 0x3c
    "cmp eAX,Iv   ", // 0x3d
    "DS:          ", // 0x3e
    "aas          ", // 0x3f
    "inc eAX      ", // 0x40
    "inc eCX      ", // 0x41
    "inc eDX      ", // 0x42
    "inc eBX      ", // 0x43
    "inc eSP      ", // 0x44
    "inc eBP      ", // 0x45
    "inc eSI      ", // 0x46
    "inc eDI      ", // 0x47
    "dec eAX      ", // 0x48
    "dec eCX      ", // 0x49
    "dec eDX      ", // 0x4a
    "dec eBX      ", // 0x4b
    "dec eSP      ", // 0x4c
    "dec eBP      ", // 0x4d
    "dec eSI      ", // 0x4e
    "dec eDI      ", // 0x4f
    "push eAX     ", // 0x50
    "push eCX     ", // 0x51
    "push eDX     ", // 0x52
    "push eBX     ", // 0x53
    "push eSP     ", // 0x54
    "push eBP     ", // 0x55
    "push eSI     ", // 0x56
    "push eDI     ", // 0x57
    "pop eAX      ", // 0x58
    "pop eCX      ", // 0x59
    "pop eDX      ", // 0x5a
    "pop eBX      ", // 0x5b
    "pop eSP      ", // 0x5c
    "pop eBP      ", // 0x5d
    "pop eSI      ", // 0x5e
    "pop eDI      ", // 0x5f
    "pusha        ", // 0x60
    "popa         ", // 0x61
    "bound Gv,Ma  ", // 0x62
    "arpl Ew,Rw   ", // 0x63
    "FS:          ", // 0x64
    "GS:          ", // 0x65
    "opsize:      ", // 0x66
    "opaddr:      ", // 0x67
    "push Iv      ", // 0x68
    "imul Gv,Ev,Iv ", // 0x69
    "push Ib      ", // 0x6a
    "imul Gv,Ev,Ib ", // 0x6b
    "insb         ", // 0x6c
    "insw/d       ", // 0x6d
    "outsb        ", // 0x6e
    "outsw/d      ", // 0x6f
    "jo Jb        ", // 0x70
    "jno Jb       ", // 0x71
    "jb Jb        ", // 0x72
    "jnb Jb       ", // 0x73
    "jz Jb        ", // 0x74
    "jnz Jb       ", // 0x75
    "jbe Jb       ", // 0x76
    "jnbe Jb      ", // 0x77
    "js Jb        ", // 0x78
    "jns Jb       ", // 0x79
    "jp Jb        ", // 0x7a
    "jnp Jb       ", // 0x7b
    "jl Jb        ", // 0x7c
    "jnl Jb       ", // 0x7d
    "jle Jb       ", // 0x7e
    "jnle Jb      ", // 0x7f
    "group1 Eb,Ib ", // 0x80
    "group1 Ev,Ib ", // 0x81
    "illegal      ", // 0x82
    "group1 Ev,Ib ", // 0x83
    "test Eb,Gb   ", // 0x84
    "test Ev,Gv   ", // 0x85
    "xchg Eb,Gb   ", // 0x86
    "xchg Ev,Gv   ", // 0x87
    "mov Eb,Gb    ", // 0x88
    "mov Ev,Gv    ", // 0x89
    "mov Gb,Eb    ", // 0x8a
    "mov Gv,Ev    ", // 0x8b
    "mov Ew,Sw    ", // 0x8c
    "lea Gv,Ma    ", // 0x8d
    "mov Sw,Ew    ", // 0x8e
    "pop Ev       ", // 0x8f
    "nop          ", // 0x90
    "xchg eCX,eAX ", // 0x91
    "xchg eDX,eAX ", // 0x92
    "xchg eBX,eAX ", // 0x93
    "xchg eSP,eAX ", // 0x94
    "xchg eBP,eAX ", // 0x95
    "xchg eSI,eAX ", // 0x96
    "xchg eDI,eAX ", // 0x97
    "cbw          ", // 0x98
    "cwd          ", // 0x99
    "call Ap      ", // 0x9a
    "wait         ", // 0x9b
    "pushf        ", // 0x9c
    "popf         ", // 0x9d
    "sahf         ", // 0x9e
    "lahf         ", // 0x9f
    "mov AL,Ob    ", // 0xa0
    "mov eAX,Ov   ", // 0xa1
    "mov Ob,AL    ", // 0xa2
    "mov Ov,eAX   ", // 0xa3
    "movsb        ", // 0xa4
    "movsw/d      ", // 0xa5
    "cmpsb        ", // 0xa6
    "cmpsw/d      ", // 0xa7
    "test AL,Ib   ", // 0xa8
    "test eAX,Iv  ", // 0xa9
    "stosb        ", // 0xaa
    "stosw/d      ", // 0xab
    "lodsb        ", // 0xac
    "lodsw/d      ", // 0xad
    "scasb        ", // 0xae
    "scasw/d      ", // 0xaf
    "mov AL,Ib    ", // 0xb0
    "mov Cl,Ib    ", // 0xb1
    "mov DL,Ib    ", // 0xb2
    "mov BL,Ib    ", // 0xb3
    "mov AH,Ib    ", // 0xb4
    "mov CH,Ib    ", // 0xb5
    "mov DH,Ib    ", // 0xb6
    "mov BH,Ib    ", // 0xb7
    "mov eAX,Iv   ", // 0xb8
    "mov eCX,Iv   ", // 0xb9
    "mov eDX,Iv   ", // 0xba
    "mov eBX,Iv   ", // 0xbb
    "mov eSP,Iv   ", // 0xbc
    "mov eBP,Iv   ", // 0xbd
    "mov eSI,Iv   ", // 0xbe
    "mov eDI,Iv   ", // 0xbf
    "group2 Eb,Ib ", // 0xc0
    "group2 Ev,Ib ", // 0xc1
    "ret Iw near  ", // 0xc2
    "ret near     ", // 0xc3
    "les Gv,Mp    ", // 0xc4
    "lds Gv,Mp    ", // 0xc5
    "mov Eb,Ib    ", // 0xc6
    "mov Ev,Iv    ", // 0xc7
    "enter Iw,Ib  ", // 0xc8
    "leave        ", // 0xc9
    "ret Iw far   ", // 0xca
    "ret far      ", // 0xcb
    "int 3        ", // 0xcc
    "int Ib       ", // 0xcd
    "into         ", // 0xce
    "iret         ", // 0xcf
    "group2 Eb,1  ", // 0xd0
    "group2 Ev,1  ", // 0xd1
    "group2 Eb,CL ", // 0xd2
    "group2 Ev,Cl ", // 0xd3
    "aam          ", // 0xd4
    "aad          ", // 0xd5
    "illegal      ", // 0xd6
    "xlat         ", // 0xd7
    "illegal      ", // 0xd8
    "illegal      ", // 0xd9
    "illegal      ", // 0xda
    "illegal      ", // 0xdb
    "illegal      ", // 0xdc
    "illegal      ", // 0xdd
    "illegal      ", // 0xde
    "illegal      ", // 0xdf
    "loopnz       ", // 0xe0
    "loopz        ", // 0xe1
    "loop         ", // 0xe2
    "jcxz         ", // 0xe3
    "inb AL,Ib    ", // 0xe4
    "inw/d eAX,Ib ", // 0xe5
    "outb Ib,AL   ", // 0xe6
    "outw/d Ib,eAX ", // 0xe7
    "call Jv      ", // 0xe8
    "jmp Jv       ", // 0xe9
    "jmp Ap       ", // 0xea
    "jmp Jb       ", // 0xeb
    "inb AL,DX    ", // 0xec
    "inw/d Ib,DX  ", // 0xed
    "outb DX,AL   ", // 0xee
    "outw/d DX,eAX ", // 0xef
    "lock:        ", // 0xf0
    "illegal      ", // 0xf1
    "repnz:       ", // 0xf2
    "repz:        ", // 0xf3
    "hlt          ", // 0xf4
    "cmc          ", // 0xf5
    "group3 Eb,?  ", // 0xf6
    "group3 Ev,?  ", // 0xf7
    "clc          ", // 0xf8
    "stc          ", // 0xf9
    "cli          ", // 0xfa
    "sti          ", // 0xfb
    "cld          ", // 0xfc
    "std          ", // 0xfd
    "group4 Eb    ", // 0xfe
    "group5 Ev    "  // 0xff
};

const PCHAR XmOpcodeNameTable2[] = {
    "group6       ", // 0x00
    "group7       ", // 0x01
    "lar          ", // 0x02
    "lsl          ", // 0x03
    "illegal      ", // 0x04
    "illegal      ", // 0x05
    "clts         ", // 0x06
    "illegal      ", // 0x07
    "illegal      ", // 0x08
    "illegal      ", // 0x09
    "illegal      ", // 0x0a
    "illegal      ", // 0x0b
    "illegal      ", // 0x0c
    "illegal      ", // 0x0d
    "illegal      ", // 0x0e
    "illegal      ", // 0x0f
    "illegal      ", // 0x10
    "illegal      ", // 0x11
    "illegal      ", // 0x12
    "illegal      ", // 0x13
    "illegal      ", // 0x14
    "illegal      ", // 0x15
    "illegal      ", // 0x16
    "illegal      ", // 0x17
    "illegal      ", // 0x18
    "illegal      ", // 0x19
    "illegal      ", // 0x1a
    "illegal      ", // 0x1b
    "illegal      ", // 0x1c
    "illegal      ", // 0x1d
    "illegal      ", // 0x1e
    "illegal      ", // 0x1f
    "mov Cd,Rd    ", // 0x20
    "mov Dd,Rd    ", // 0x21
    "mov Rd,Cd    ", // 0x22
    "mov Rd,Dd    ", // 0x23
    "mov Td,Rd    ", // 0x24
    "illegal      ", // 0x25
    "mov Rd,Td    ", // 0x26
    "illegal      ", // 0x27
    "illegal      ", // 0x28
    "illegal      ", // 0x29
    "illegal      ", // 0x2a
    "illegal      ", // 0x2b
    "illegal      ", // 0x2c
    "illegal      ", // 0x2d
    "illegal      ", // 0x2e
    "illegal      ", // 0x2f
    "illegal      ", // 0x30
    "illegal      ", // 0x31
    "illegal      ", // 0x32
    "illegal      ", // 0x33
    "illegal      ", // 0x34
    "illegal      ", // 0x35
    "illegal      ", // 0x36
    "illegal      ", // 0x37
    "illegal      ", // 0x38
    "illegal      ", // 0x39
    "illegal      ", // 0x3a
    "illegal      ", // 0x3b
    "illegal      ", // 0x3c
    "illegal      ", // 0x3d
    "illegal      ", // 0x3e
    "illegal      ", // 0x3f
    "illegal      ", // 0x40
    "illegal      ", // 0x41
    "illegal      ", // 0x42
    "illegal      ", // 0x43
    "illegal      ", // 0x44
    "illegal      ", // 0x45
    "illegal      ", // 0x46
    "illegal      ", // 0x47
    "illegal      ", // 0x48
    "illegal      ", // 0x49
    "illegal      ", // 0x4a
    "illegal      ", // 0x4b
    "illegal      ", // 0x4c
    "illegal      ", // 0x4d
    "illegal      ", // 0x4e
    "illegal      ", // 0x4f
    "illegal      ", // 0x50
    "illegal      ", // 0x51
    "illegal      ", // 0x52
    "illegal      ", // 0x53
    "illegal      ", // 0x54
    "illegal      ", // 0x55
    "illegal      ", // 0x56
    "illegal      ", // 0x57
    "illegal      ", // 0x58
    "illegal      ", // 0x59
    "illegal      ", // 0x5a
    "illegal      ", // 0x5b
    "illegal      ", // 0x5c
    "illegal      ", // 0x5d
    "illegal      ", // 0x5e
    "illegal      ", // 0x5f
    "illegal      ", // 0x60
    "illegal      ", // 0x61
    "illegal      ", // 0x62
    "illegal      ", // 0x63
    "illegal      ", // 0x64
    "illegal      ", // 0x65
    "illegal      ", // 0x66
    "illegal      ", // 0x67
    "illegal      ", // 0x68
    "illegal      ", // 0x69
    "illegal      ", // 0x6a
    "illegal      ", // 0x6b
    "illegal      ", // 0x6c
    "illegal      ", // 0x6d
    "illegal      ", // 0x6e
    "illegal      ", // 0x6f
    "illegal      ", // 0x70
    "illegal      ", // 0x71
    "illegal      ", // 0x72
    "illegal      ", // 0x73
    "illegal      ", // 0x74
    "illegal      ", // 0x75
    "illegal      ", // 0x76
    "illegal      ", // 0x77
    "illegal      ", // 0x78
    "illegal      ", // 0x79
    "illegal      ", // 0x7a
    "illegal      ", // 0x7b
    "illegal      ", // 0x7c
    "illegal      ", // 0x7d
    "illegal      ", // 0x7e
    "illegal      ", // 0x7f
    "jo Jv        ", // 0x80
    "jno Jv       ", // 0x81
    "jb Jv        ", // 0x82
    "jnb Jv       ", // 0x83
    "jz Jv        ", // 0x84
    "jnz Jv       ", // 0x85
    "jbe Jv       ", // 0x86
    "jnbe Jv      ", // 0x87
    "js Jv        ", // 0x88
    "jns Jv       ", // 0x89
    "jp Jv        ", // 0x8a
    "jnp Jv       ", // 0x8b
    "jl Jv        ", // 0x8c
    "jnl Jv       ", // 0x8d
    "jle Jv       ", // 0x8e
    "jnle Jv      ", // 0x8f
    "seto         ", // 0x90
    "setno        ", // 0x91
    "setb         ", // 0x92
    "setnb        ", // 0x93
    "setz         ", // 0x94
    "setnz        ", // 0x95
    "setbe        ", // 0x96
    "setnbe       ", // 0x97
    "sets         ", // 0x98
    "setns        ", // 0x99
    "setp         ", // 0x9a
    "setnp        ", // 0x9b
    "setl         ", // 0x9c
    "setnl        ", // 0x9d
    "setle        ", // 0x9e
    "setnle       ", // 0x9f
    "push FS      ", // 0xa0
    "pop FS       ", // 0xa1
    "illegal      ", // 0xa2
    "bt Ev,Gv     ", // 0xa3
    "shld Ev,Gv,Ib ", // 0xa4
    "Shld Ev,Gv,vl ", // 0xa5
    "illegal      ", // 0xa6
    "illegal      ", // 0xa7
    "push GS      ", // 0xa8
    "pop GS       ", // 0xa9
    "illegal      ", // 0xaa
    "bts Ev,Gv    ", // 0xab
    "shrd Ev,Gv,Ib ", // 0xac
    "shrd Ev,Gv,cl ", // 0xad
    "illegal      ", // 0xae
    "imul Gv,Ev   ", // 0xaf
    "cmpxchg Eb,Gv ", // 0xb0
    "cmpxchg Ev,Gv ", // 0xb1
    "lss Gv,Mp    ", // 0xb2
    "btr Ev,Gv    ", // 0xb3
    "lfs Gv,Mp    ", // 0xb4
    "lgs Gv,Mp    ", // 0xb5
    "movzb Gv,Eb  ", // 0xb6
    "movzw Gv,Ew  ", // 0xb7
    "illegal      ", // 0xb8
    "illegal      ", // 0xb9
    "group8 Ev,Ib ", // 0xba
    "btc Ev,Gv    ", // 0xbb
    "bsf Gv,Ev    ", // 0xbc
    "bsr Gv,Ev    ", // 0xbd
    "movsb Gv,Eb  ", // 0xbe
    "movsw Gv,Ew  ", // 0xbf
    "xadd Eb,Gb   ", // 0xc0
    "xadd Ev,Gv   ", // 0xc1
    "illegal      ", // 0xc2
    "illegal      ", // 0xc3
    "illegal      ", // 0xc4
    "illegal      ", // 0xc5
    "illegal      ", // 0xc6
    "illegal      ", // 0xc7
    "bswap Gv     ", // 0xc8
    "illegal      ", // 0xc9
    "illegal      ", // 0xca
    "illegal      ", // 0xcb
    "illegal      ", // 0xcc
    "illegal      ", // 0xcd
    "illegal      ", // 0xce
    "illegal      ", // 0xcf
    "illegal      ", // 0xd0
    "illegal      ", // 0xd1
    "illegal      ", // 0xd2
    "illegal      ", // 0xd3
    "illegal      ", // 0xd4
    "illegal      ", // 0xd5
    "illegal      ", // 0xd6
    "illegal      ", // 0xd7
    "illegal      ", // 0xd8
    "illegal      ", // 0xd9
    "illegal      ", // 0xda
    "illegal      ", // 0xdb
    "illegal      ", // 0xdc
    "illegal      ", // 0xdd
    "illegal      ", // 0xde
    "illegal      ", // 0xdf
    "illegal      ", // 0xe0
    "illegal      ", // 0xe1
    "illegal      ", // 0xe2
    "illegal      ", // 0xe3
    "illegal      ", // 0xe4
    "illegal      ", // 0xe5
    "illegal      ", // 0xe6
    "illegal      ", // 0xe7
    "illegal      ", // 0xe8
    "illegal      ", // 0xe9
    "illegal      ", // 0xea
    "illegal      ", // 0xeb
    "illegal      ", // 0xec
    "illegal      ", // 0xed
    "illegal      ", // 0xee
    "illegal      ", // 0xef
    "illegal      ", // 0xf0
    "illegal      ", // 0xf1
    "illegal      ", // 0xf2
    "illegal      ", // 0xf3
    "illegal      ", // 0xf4
    "illegal      ", // 0xf5
    "illegal      ", // 0xf6
    "illegal      ", // 0xf7
    "illegal      ", // 0xf8
    "illegal      ", // 0xf9
    "illegal      ", // 0xfa
    "illegal      ", // 0xfb
    "illegal      ", // 0xfc
    "illegal      ", // 0xfd
    "illegal      ", // 0xfe
    "illegal      "  // 0xff
};

ULONG XmDebugFlags = 0x00; //0x7f;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements utility functions.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

#if defined(XM_DEBUG)


//
// Define counter used to control flag tracing.
//

ULONG XmTraceCount = 0;

VOID
XmTraceDestination (
    IN PRXM_CONTEXT P,
    IN ULONG Destination
    )

/*++

Routine Description:

    This function traces the destination value if the TRACE_OPERANDS
    flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Result - Supplies the destination value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace result of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (P->DataType == BYTE_DATA) {
            DEBUG_PRINT(("\n    Dst - %02lx", Destination));

        } else if (P->DataType == WORD_DATA) {
            DEBUG_PRINT(("\n    Dst - %04lx", Destination));

        } else {
            DEBUG_PRINT(("\n    Dst - %08lx", Destination));
        }
    }

    return;
}

VOID
XmTraceFlags (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces the condition flags if the TRACE_FLAGS flag
    is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Trace flags.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        DEBUG_PRINT(("\n    OF-%lx, DF-%lx, SF-%lx, ZF-%lx, AF-%lx, PF-%lx, CF-%lx",
                     (ULONG)P->Eflags.EFLAG_OF,
                     (ULONG)P->Eflags.EFLAG_DF,
                     (ULONG)P->Eflags.EFLAG_SF,
                     (ULONG)P->Eflags.EFLAG_ZF,
                     (ULONG)P->Eflags.EFLAG_AF,
                     (ULONG)P->Eflags.EFLAG_PF,
                     (ULONG)P->Eflags.EFLAG_CF));
    }

    //
    // Increment the trace count and if the result is even, then put
    // out a new line.
    //

    XmTraceCount += 1;
    if (((XmTraceCount & 1) == 0) && (XmDebugFlags != 0)) {
        DEBUG_PRINT(("\n"));
    }

    return;
}

VOID
XmTraceJumps (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces jump operations if the TRACE_JUMPS flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Trace jumps.
    //

    if ((XmDebugFlags & TRACE_JUMPS) != 0) {
        DEBUG_PRINT(("\n    Jump to %04lx:%04lx",
                     (ULONG)P->SegmentRegister[CS],
                     (ULONG)P->Eip));
    }

    return;
}

VOID
XmTraceInstruction (
    IN XM_OPERATION_DATATYPE DataType,
    IN ULONG Instruction
    )

/*++

Routine Description:

    This function traces instructions if the TRACE_OPERANDS flag is
    set.

Arguments:

    DataType - Supplies the data type of the instruction value.

    Instruction - Supplies the instruction value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace instruction stream of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (DataType == BYTE_DATA) {
            DEBUG_PRINT(("%02lx ", Instruction));

        } else if (DataType == WORD_DATA) {
            DEBUG_PRINT(("%04lx ", Instruction));

        } else {
            DEBUG_PRINT(("%08lx ", Instruction));
        }
    }

    return;
}

VOID
XmTraceOverride (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces segment override prefixes.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    PCHAR Name = "ECSDFG";
    ULONG Segment;

    //
    // Trace segment override.
    //

    if ((XmDebugFlags & TRACE_OVERRIDE) != 0) {
        Segment = P->DataSegment;
        DEBUG_PRINT(("\n    %cS:Selector - %04lx, Limit - %04lx",
                     (ULONG)Name[Segment],
                     (ULONG)P->SegmentRegister[Segment],
                     P->SegmentLimit[Segment]));
    }

    return;
}

VOID
XmTraceRegisters (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces emulator registers.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Trace general register.
    //

    if ((XmDebugFlags & TRACE_GENERAL_REGISTERS) != 0) {
        DEBUG_PRINT(("\n    EAX-%08lx ECX-%08lx EDX-%08lx EBX-%08lx",
                     P->Gpr[EAX].Exx,
                     P->Gpr[ECX].Exx,
                     P->Gpr[EDX].Exx,
                     P->Gpr[EBX].Exx));

        DEBUG_PRINT(("\n    ESP-%08lx EBP-%08lx ESI-%08lx EDI-%08lx",
                     P->Gpr[ESP].Exx,
                     P->Gpr[EBP].Exx,
                     P->Gpr[ESI].Exx,
                     P->Gpr[EDI].Exx));

        DEBUG_PRINT(("\n    ES:%04lx CS:%04lx SS:%04lx DS:%04lx FS:%04lx GS:%04lx",
                     (ULONG)P->SegmentRegister[ES],
                     (ULONG)P->SegmentRegister[CS],
                     (ULONG)P->SegmentRegister[SS],
                     (ULONG)P->SegmentRegister[DS],
                     (ULONG)P->SegmentRegister[FS],
                     (ULONG)P->SegmentRegister[GS]));
    }

    return;
}

VOID
XmTraceResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    )

/*++

Routine Description:

    This function traces the result value if the TRACE_OPERANDS
    flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Result - Supplies the result value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace result of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (P->DataType == BYTE_DATA) {
            DEBUG_PRINT(("\n    Rsl - %02lx", Result));

        } else if (P->DataType == WORD_DATA) {
            DEBUG_PRINT(("\n    Rsl - %04lx", Result));

        } else {
            DEBUG_PRINT(("\n    Rsl - %08lx", Result));
        }
    }

    return;
}

VOID
XmTraceSpecifier (
    IN UCHAR Specifier
    )

/*++

Routine Description:

    This function traces the specifiern if the TRACE_OPERANDS flag is
    set.

Arguments:

    Specifier - Supplies the specifier value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace instruction stream of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        DEBUG_PRINT(("%02lx ", Specifier));
        if ((XmDebugFlags & TRACE_SPECIFIERS) != 0) {
            DEBUG_PRINT(("(mod-%01lx reg-%01lx r/m-%01lx) ",
                         (Specifier >> 6) & 0x3,
                         (Specifier >> 3) & 0x7,
                         (Specifier >> 0) & 0x7));
        }
    }

    return;
}

VOID
XmTraceSource (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    )

/*++

Routine Description:

    This function traces the source value if the TRACE_OPERANDS
    flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Source - Supplies the source value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace result of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (P->DataType == BYTE_DATA) {
            DEBUG_PRINT(("\n    Src - %02lx", Source));

        } else if (P->DataType == WORD_DATA) {
            DEBUG_PRINT(("\n    Src - %04lx", Source));

        } else {
            DEBUG_PRINT(("\n    Src - %08lx", Source));
        }
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\ctrlops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ctrlops.c

Abstract:

    This module implements the code to emulate call, retunr, and various
    control operations.

Author:

    David N. Cutler (davec) 10-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmCallOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a call opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Target;
    ULONG Source;

    //
    // Save the target address, push the current segment, if required, and
    // push the current IP, set the destination segment, if required, and
    // set the new IP.
    //

    Target = P->DstValue.Long;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if ((P->CurrentOpcode == 0x9a) || (P->FunctionIndex != X86_CALL_OP)) {
        XmPushStack(P, P->SegmentRegister[CS]);
        XmPushStack(P, P->Eip);
        P->SegmentRegister[CS] = P->DstSegment;

    } else {
        XmPushStack(P, P->Eip);
    }

    P->Eip = Target;
    XmTraceJumps(P);
    return;
}

VOID
XmEnterOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an enter opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Allocate;
    ULONG Frame;
    ULONG Number;

    //
    // set the number of bytes to allocate on the stack and the number
    // of nesting levels.
    //

    Allocate = P->SrcValue.Long;
    Number = P->DstValue.Long;

    //
    // Set the data type and save the frame pointer on the stack.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        XmPushStack(P, P->Gpr[EBP].Exx);
        Frame = P->Gpr[ESP].Exx;

    } else {
        P->DataType = WORD_DATA;
        XmPushStack(P, P->Gpr[BP].Xx);
        Frame = P->Gpr[SP].Xx;
    }

    //
    // Save the current stack pointer and push parameters on the stack.
    //

    if (Number != 0) {

        //
        // If the level number is not one, then raise an exception.
        //
        // N.B. Level numbers greater than one are not supported.
        //

        if (Number != 1) {
            longjmp(&P->JumpBuffer[0], XM_ILLEGAL_LEVEL_NUMBER);
        }

        XmPushStack(P, Frame);
    }

    //
    // Allocate local storage on stack.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->Gpr[EBP].Exx = Frame;
        P->Gpr[ESP].Exx = P->Gpr[ESP].Exx - Allocate;

    } else {
        P->Gpr[BP].Xx = (USHORT)Frame;
        P->Gpr[SP].Xx = (USHORT)(P->Gpr[SP].Xx - Allocate);
    }

    return;
}

VOID
XmHltOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a hlt opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Halt instructions are not supported by the emulator.
    //

    longjmp(&P->JumpBuffer[0], XM_HALT_INSTRUCTION);
    return;
}

VOID
XmIntOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an int opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Number;
    PULONG Vector;

    //
    // If the int instruction is an int 3, then set the interrupt vector
    // to 3. Otherwise, if the int instruction is an into, then set the
    // vector to 4 if OF is set. use the source interrupt vector.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if (P->CurrentOpcode == 0xcc) {
        Number = 3;

    } else if (P->CurrentOpcode == 0xce) {
        if (P->Eflags.EFLAG_OF == 0) {
            return;
        }

        Number = 4;

    } else {
        Number = P->SrcValue.Byte;
    }

    //
    // If the vector number is 0x42, then nop the interrupt. This is the
    // standard EGA video driver entry point in a PC's motherboard BIOS
    // for which there is no code.
    //

#if !defined(_PURE_EMULATION_)

    if (Number == 0x42) {
        return;
    }

#endif

    //
    // If the vector number is 0x1a, then attempt to emulate the PCI BIOS
    // if it is enabled.
    //

#if !defined(_PURE_EMULATION_)

    if ((Number == 0x1a) && (XmExecuteInt1a(P) != FALSE)) {
        return;
    }

#endif

    //
    // Push the current flags, code segment, and EIP on the stack.
    //

    XmPushStack(P, P->AllFlags);
    XmPushStack(P, P->SegmentRegister[CS]);
    XmPushStack(P, P->Eip);

    //
    // Set the new coded segment and IP from the specified interrupt
    // vector.
    //

    Vector = (PULONG)(P->TranslateAddress)(0, 0);
    P->SegmentRegister[CS] = (USHORT)(Vector[Number] >> 16);
    P->Eip = (USHORT)(Vector[Number] & 0xffff);
    XmTraceJumps(P);
    return;
}

VOID
XmIretOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an iret opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set the data type and restore the return address, code segment,
    // and flags.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    P->Eip = XmPopStack(P);
    P->SegmentRegister[CS] = (USHORT)XmPopStack(P);
    P->AllFlags = XmPopStack(P);
    XmTraceJumps(P);

    //
    // Check for emulator exit conditions.
    //

    if ((P->Eip == 0xffff) && (P->SegmentRegister[CS] == 0xffff)) {
        longjmp(&P->JumpBuffer[0], XM_SUCCESS);
    }

    return;
}

VOID
XmLeaveOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a leave opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set the data type, restore the stack pointer, and restore the frame
    // pointer.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        P->Gpr[ESP].Exx = P->Gpr[EBP].Exx;
        P->Gpr[EBP].Exx = XmPopStack(P);

    } else {
        P->DataType = WORD_DATA;
        P->Gpr[SP].Xx = P->Gpr[BP].Xx;
        P->Gpr[BP].Xx = (USHORT)XmPopStack(P);
    }

    return;
}

VOID
XmRetOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a ret opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Adjust;

    //
    // Compute the number of bytes that are to be removed from the stack
    // after having removed the return address and optionally the new CS
    // segment value.
    //

    if ((P->CurrentOpcode & 0x1) == 0) {
        Adjust = XmGetWordImmediate(P);

    } else {
        Adjust = 0;
    }

    //
    // Remove the return address from the stack and set the new IP.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    P->Eip = XmPopStack(P);

    //
    // If the current opcode is a far return, then remove the new CS segment
    // value from the stack.
    //

    if ((P->CurrentOpcode & 0x8) != 0) {
        P->SegmentRegister[CS] = (USHORT)XmPopStack(P);
    }

    //
    // Remove the specified number of bytes from the stack.
    //

    P->Gpr[ESP].Exx += Adjust;
    XmTraceJumps(P);

    //
    // Check for emulator exit conditions.
    //

    if ((P->Eip == 0xffff) && (P->SegmentRegister[CS] == 0xffff)) {
        longjmp(&P->JumpBuffer[0], XM_SUCCESS);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\divops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mulops.c

Abstract:

    This module implements the code to emulate the div and idiv opcodes.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmDivOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an unsigned div opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    UNALIGNED ULONG *DstHigh;
    ULONG Dividend;
    ULONG Divisor;
    ULARGE_INTEGER Large;
    ULONG Quotient;
    ULONG Remainder;

    //
    // Divide the unsigned operands and store result.
    //

    Divisor = P->SrcValue.Long;
    if (Divisor == 0) {
        longjmp(&P->JumpBuffer[0], XM_DIVIDE_BY_ZERO);
    }

    if (P->DataType == BYTE_DATA) {
        Dividend = (ULONG)P->Gpr[AX].Xx;
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[AX].Xh);
        Dividend >>= 8;

    } else if (P->DataType == WORD_DATA) {
        Dividend = (P->Gpr[DX].Xx << 16) | P->Gpr[AX].Xx;
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[DX].Xx);
        Dividend >>= 16;

    } else {
        Dividend = P->Gpr[EDX].Exx;
        Large.HighPart = Dividend;
        Large.LowPart = P->Gpr[EAX].Exx;
        Quotient = (ULONG)(Large.QuadPart / (ULONGLONG)Divisor);
        Remainder = (ULONG)(Large.QuadPart % (ULONGLONG)Divisor);
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
    }

    if (Dividend >= Divisor) {
        longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
    }

    XmStoreResult(P, Quotient);
    P->DstLong = DstHigh;
    XmStoreResult(P, Remainder);
    return;
}

VOID
XmIdivOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a signed idiv opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    UNALIGNED ULONG *DstHigh;
    LONG Dividend;
    LONG Divisor;
    LARGE_INTEGER Large;
    LONG Quotient;
    LONG Remainder;
    LARGE_INTEGER Result;

    //
    // Divide the signed operands and store result.
    //

    if (P->SrcValue.Long == 0) {
        longjmp(&P->JumpBuffer[0], XM_DIVIDE_BY_ZERO);
    }

    if (P->DataType == BYTE_DATA) {
        Divisor = (LONG)((SCHAR)P->SrcValue.Byte);
        Dividend = (LONG)((SHORT)P->Gpr[AX].Xx);
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[AX].Xh);
        if ((Quotient >> 8) != ((Quotient << 24) >> 31)) {
            longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
        }

        Quotient &= 0xff;
        Remainder &= 0xff;

    } else if (P->DataType == WORD_DATA) {
        Divisor = (LONG)((SHORT)P->SrcValue.Word);
        Dividend = (LONG)((P->Gpr[DX].Xx << 16) | P->Gpr[AX].Xx);
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[DX].Xx);
        if ((Quotient >> 16) != ((Quotient << 16) >> 31)) {
            longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
        }

        Quotient &= 0xffff;
        Remainder &= 0xfff;

    } else {
        Divisor = (LONG)(P->SrcValue.Long);
        Large.HighPart = (LONG)P->Gpr[EDX].Exx;
        Large.LowPart = P->Gpr[EAX].Exx;
        Result.QuadPart = Large.QuadPart / (LONGLONG)Divisor;
        Quotient = Result.LowPart;
        Remainder = (LONG)(Large.QuadPart % (LONGLONG)Divisor);
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
        if (Result.HighPart != ((LONG)Result.LowPart >> 31)) {
            longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
        }
    }

    XmStoreResult(P, Quotient);
    P->DstLong = DstHigh;
    XmStoreResult(P, Remainder);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\emulate.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    emulate.c

Abstract:

    This module implements an instruction level emulator for the execution
    of x86 code. It is a complete 386/486 emulator, but only implements
    real mode execution. Thus 32-bit addressing and operands are supported,
    but paging and protected mode operations are not supported. The code is
    written with the primary goals of being complete and small. Thus speed
    of emulation is not important.

Author:

    David N. Cutler (davec) 2-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmInitializeEmulator (
    IN USHORT StackSegment,
    IN USHORT StackOffset,
    IN PXM_READ_IO_SPACE ReadIoSpace,
    IN PXM_WRITE_IO_SPACE WriteIoSpace,
    IN PXM_TRANSLATE_ADDRESS TranslateAddress
    )

/*++

Routine Description:

    This function initializes the state of the x86 emulator.

Arguments:

    StackSegment - Supplies the stack segment value.

    StackOffset - Supplies the stack offset value.

    ReadIoSpace - Supplies a pointer to a the function that reads from
        I/O space given a datatype and port number.

    WriteIoSpace - Supplies a pointer to a function that writes to I/O
        space given a datatype, port number, and value.

    TranslateAddress - Supplies a pointer to the function that translates
        segment/offset address pairs into a pointer to memory or I/O space.

Return Value:

    None.

--*/

{

    LONG Index;
    PRXM_CONTEXT P = &XmContext;
    PULONG Vector;

    //
    // Clear the emulator context.
    //

    memset((PCHAR)P, 0, sizeof(XM_CONTEXT));

    //
    // Initialize the segment registers.
    //

    Index = GS;
    do {
        P->SegmentLimit[Index] = 0xffff;
        Index -= 1;
    } while (Index >= ES);

    //
    // Initialize the stack segment register and offset.
    //

    P->SegmentRegister[SS] = StackSegment;
    P->Gpr[ESP].Exx = StackOffset;

    //
    // Set the address of the read I/O space, write I/O space, and translate
    // functions.
    //

    P->ReadIoSpace = ReadIoSpace;
    P->WriteIoSpace = WriteIoSpace;
    P->TranslateAddress = TranslateAddress;

    //
    // Get address of interrupt vector table and initialize all vector to
    // point to an iret instruction at location 0x500.
    //
    //
    // N.B. It is assumed that the vector table is contiguous in emulated
    //      memory.
    //

    Vector = (PULONG)(P->TranslateAddress)(0, 0);
    Vector[0x500 / 4] = 0x000000cf;
    Index = 0;
    do {
        Vector[Index] = 0x00000500;
        Index += 1;
    } while (Index < 256);


    XmEmulatorInitialized = TRUE;
    return;
}

XM_STATUS
XmEmulateFarCall (
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    )

/*++

Routine Description:

    This function emulates a far call by pushing a special exit
    sequence on the stack and then starting instruction execution
    at the address specified by the respective segment and offset.

Arguments:

    Segment - Supplies the segment in which to start execution.

    Offset - Supplies the offset within the code segment to start
        execution.

    Context - Supplies a pointer to an x86 context structure.

Return Value:

    The emulation completion status.

--*/

{

    PRXM_CONTEXT P = &XmContext;
    PUSHORT Stack;

    //
    // If the emulator has not been initialized, return an error.
    //

    if (XmEmulatorInitialized == FALSE) {
        return XM_EMULATOR_NOT_INITIALIZED;
    }

    //
    // Get address of current stack pointer, push exit markers, and
    // update stack pointer.
    //
    // N.B. It is assumed that the stack pointer is within range and
    //      contiguous in emulated memory.
    //

    Stack = (PUSHORT)(P->TranslateAddress)(P->SegmentRegister[SS], P->Gpr[SP].Xx);
    *--Stack = 0xffff;
    *--Stack = 0xffff;
    P->Gpr[SP].Xx -= 4;

    //
    // Emulate the specified instruction stream and return the final status.
    //

    return XmEmulateStream(&XmContext, Segment, Offset, Context);
}

XM_STATUS
XmEmulateInterrupt (
    IN UCHAR Interrupt,
    IN OUT PXM86_CONTEXT Context
    )

/*++

Routine Description:

    This function emulates an interrrupt by pushing a special exit
    sequence on the stack and then starting instruction execution
    at the address specified by the respective interrupt vector.

Arguments:

    Interrupt - Supplies the number of the interrupt that is emulated.

    Context - Supplies a pointer to an x86 context structure.

Return Value:

    The emulation completion status.

--*/

{

    PRXM_CONTEXT P = &XmContext;
    USHORT Segment;
    USHORT Offset;
    PUSHORT Stack;
    PULONG Vector;

    //
    // If the emulator has not been initialized, return an error.
    //

    if (XmEmulatorInitialized == FALSE) {
        return XM_EMULATOR_NOT_INITIALIZED;
    }

    //
    // Get address of current stack pointer, push exit markers, and
    // update stack pointer.
    //
    // N.B. It is assumed that the stack pointer is within range and
    //      contiguous in emulated memory.
    //

    Stack = (PUSHORT)(P->TranslateAddress)(P->SegmentRegister[SS], P->Gpr[SP].Xx);
    *--Stack = 0;
    *--Stack = 0xffff;
    *--Stack = 0xffff;
    P->Gpr[SP].Xx -= 6;

    //
    // Get address of interrupt vector table and set code segment and IP
    // values.
    //
    //
    // N.B. It is assumed that the vector table is contiguous in emulated
    //      memory.
    //

    Vector = (PULONG)(P->TranslateAddress)(0, 0);
    Segment = (USHORT)(Vector[Interrupt] >> 16);
    Offset = (USHORT)(Vector[Interrupt] & 0xffff);

    //
    // Emulate the specified instruction stream and return the final status.
    //

    return XmEmulateStream(&XmContext, Segment, Offset, Context);
}

XM_STATUS
XmEmulateStream (
    PRXM_CONTEXT P,
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    )

/*++

Routine Description:

    This function establishes the specfied context and emulates the
    specified instruction stream until exit conditions are reached..

Arguments:

    Segment - Supplies the segment in which to start execution.

    Offset - Supplies the offset within the code segment to start
        execution.

    Context - Supplies a pointer to an x86 context structure.

Return Value:

    The emulation completion status.

--*/

{

    XM_STATUS Status;

    //
    // Set the x86 emulator registers from the specified context.
    //

    P->Gpr[EAX].Exx = Context->Eax;
    P->Gpr[ECX].Exx = Context->Ecx;
    P->Gpr[EDX].Exx = Context->Edx;
    P->Gpr[EBX].Exx = Context->Ebx;
    P->Gpr[EBP].Exx = Context->Ebp;
    P->Gpr[ESI].Exx = Context->Esi;
    P->Gpr[EDI].Exx = Context->Edi;
    P->SegmentRegister[DS] = Context->SegDs;
    P->SegmentRegister[ES] = Context->SegEs;

    //
    // Set the code segment, offset within segment, and emulate code.
    //

    P->SegmentRegister[CS] = Segment;
    P->Eip = Offset;
    if ((Status = setjmp(&P->JumpBuffer[0])) == 0) {

        //
        // Emulate x86 instruction stream.
        //

        do {

            //
            // Initialize instruction decode variables.
            //

            P->ComputeOffsetAddress = FALSE;
            P->DataSegment = DS;
            P->LockPrefixActive = FALSE;
            P->OpaddrPrefixActive = FALSE;
            P->OpsizePrefixActive = FALSE;
            P->RepeatPrefixActive = FALSE;
            P->SegmentPrefixActive = FALSE;
            P->OpcodeControlTable = &XmOpcodeControlTable1[0];

#if defined(XM_DEBUG)

            P->OpcodeNameTable = &XmOpcodeNameTable1[0];

#endif

            //
            // Get the next byte from the instruction stream and decode
            // operands. If the byte is a prefix or an escape, then the
            // next byte will be decoded. Decoding continues until an
            // opcode byte is reached with a terminal decode condition.
            //
            // N.B. There is no checking for legitimate sequences of prefix
            //      and/or two byte opcode escapes. Redundant or invalid
            //      prefixes or two byte escape opcodes have no effect and
            //      are benign.
            //

            do {
                P->CurrentOpcode = XmGetCodeByte(P);

#if defined(XM_DEBUG)

                if ((XmDebugFlags & TRACE_INSTRUCTIONS) != 0) {
                    DEBUG_PRINT(("\n%04lx %s %02lx ",
                                 P->Eip - 1,
                                 P->OpcodeNameTable[P->CurrentOpcode],
                                 (ULONG)P->CurrentOpcode));
                }

#endif

                P->OpcodeControl = P->OpcodeControlTable[P->CurrentOpcode];
                P->FunctionIndex = P->OpcodeControl.FunctionIndex;
            } while (XmOperandDecodeTable[P->OpcodeControl.FormatType](P) == FALSE);

            //
            // Emulate the instruction.
            //

            XmTraceFlags(P);
            XmOpcodeFunctionTable[P->FunctionIndex](P);
            XmTraceFlags(P);
            XmTraceRegisters(P);

#if defined(XM_DEBUG)

            if ((XmDebugFlags & TRACE_SINGLE_STEP) != 0) {
                DEBUG_PRINT(("\n"));
                DbgBreakPoint();
            }

#endif

        } while (TRUE);
    }

    //
    // Set the x86 return context to the current emulator registers.
    //

    Context->Eax = P->Gpr[EAX].Exx;
    Context->Ecx = P->Gpr[ECX].Exx;
    Context->Edx = P->Gpr[EDX].Exx;
    Context->Ebx = P->Gpr[EBX].Exx;
    Context->Ebp = P->Gpr[EBP].Exx;
    Context->Esi = P->Gpr[ESI].Exx;
    Context->Edi = P->Gpr[EDI].Exx;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\emulate.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    emulate.h

Abstract:

    This module contains the private header file for the x86 bios
    emulation.

Author:

    David N. Cutler (davec) 2-Sep-1994

Revision History:

--*/

#ifndef _EMULATE_
#define _EMULATE_

#include "setjmp.h"
#include "xm86.h"
#include "x86new.h"

//
// Define debug tracing flags.
//

//#define XM_DEBUG 1  // ****** temp ******

#define TRACE_INSTRUCTIONS 0x1
#define TRACE_OPERANDS 0x2
#define TRACE_GENERAL_REGISTERS 0x4
#define TRACE_OVERRIDE 0x8
#define TRACE_JUMPS 0x10
#define TRACE_SPECIFIERS 0x20
#define TRACE_SINGLE_STEP 0x40

//
// Define opcode function table indexes.
//
// N.B. This values must correspond exactly one for one with the function
//      table entries. If the C language had indexed initializers this
//      type would not be necessary.
//

typedef enum _XM_FUNCTION_TABLE_INDEX {

    //
    // ASCII operators.
    //

    X86_AAA_OP,
    X86_AAD_OP,
    X86_AAM_OP,
    X86_AAS_OP,
    X86_DAA_OP,
    X86_DAS_OP,

    //
    // Group 1 operators.
    //

    X86_ADD_OP,
    X86_OR_OP,
    X86_ADC_OP,
    X86_SBB_OP,
    X86_AND_OP,
    X86_SUB_OP,
    X86_XOR_OP,
    X86_CMP_OP,

    //
    // Group 2 operators.
    //

    X86_ROL_OP,
    X86_ROR_OP,
    X86_RCL_OP,
    X86_RCR_OP,
    X86_SHL_OP,
    X86_SHR_OP,
    X86_FILL0_OP,
    X86_SAR_OP,

    //
    // Group 3 operators.
    //

    X86_TEST_OP,
    X86_FILL1_OP,
    X86_NOT_OP,
    X86_NEG_OP,
    X86_MUL_OP,
    X86_IMULX_OP,
    X86_DIV_OP,
    X86_IDIV_OP,

    //
    // Group 4 and 5 operators.
    //

    X86_INC_OP,
    X86_DEC_OP,
    X86_CALL_OP,
    X86_FILL2_OP,
    X86_JMP_OP,
    X86_FILL3_OP,
    X86_PUSH_OP,
    X86_FILL4_OP,

    //
    // Group 8 operators.
    //

    X86_BT_OP,
    X86_BTS_OP,
    X86_BTR_OP,
    X86_BTC_OP,

    //
    // Stack push and pop operators.
    //

    X86_POP_OP,
    X86_PUSHA_OP,
    X86_POPA_OP,

    //
    // Jump operators.
    //

    X86_JXX_OP,
    X86_LOOP_OP,
    X86_JCXZ_OP,

    //
    // Control operators.
    //

    X86_ENTER_OP,
    X86_HLT_OP,
    X86_INT_OP,
    X86_IRET_OP,
    X86_LEAVE_OP,
    X86_RET_OP,

    //
    // Set boolean byte value based on condition.
    //

    X86_SXX_OP,

    //
    // Condition code operators.
    //

    X86_CMC_OP,
    X86_CLC_OP,
    X86_STC_OP,
    X86_CLI_OP,
    X86_STI_OP,
    X86_CLD_OP,
    X86_STD_OP,
    X86_LAHF_OP,
    X86_SAHF_OP,

    //
    // General move operators.
    //

    X86_MOV_OP,
    X86_XCHG_OP,

    //
    // Convert operations.
    //

    X86_CBW_OP,
    X86_CWD_OP,

    //
    // Single multiply operator.
    //

    X86_IMUL_OP,

    //
    // String operators.
    //

    X86_CMPS_OP,
    X86_INS_OP,
    X86_LODS_OP,
    X86_MOVS_OP,
    X86_OUTS_OP,
    X86_SCAS_OP,
    X86_STOS_OP,

    //
    // Effective address operators.
    //

    X86_BOUND_OP,
    X86_LEA_OP,

    //
    // Double shift operators.
    //

    X86_SHLD_OP,
    X86_SHRD_OP,

    //
    // I/O operators.
    //

    X86_IN_OP,
    X86_OUT_OP,

    //
    // Bit scan operators.
    //

    X86_BSF_OP,
    X86_BSR_OP,

    //
    // Byte swap operators.
    //

    X86_BSWAP_OP,

    //
    // Add/compare and exchange operators.
    //

    X86_XADD_OP,
    X86_CMPXCHG_OP,

    //
    // No operation.
    //

    X86_NOP_OP,

    //
    // Illegal opcode.
    //

    X86_ILL_OP,
    X86_MAXIMUM_INDEX
} XM_FUNCTION_TABLE_INDEX;

//
// Define 8-bit register numbers.
//

typedef enum _X86_8BIT_REGISTER {
    AL,
    CL,
    DL,
    BL,
    AH,
    CH,
    DH,
    BH
} X86_8BIT_REGISTER;

//
// Define 16-bit register numbers.
//

typedef enum _X86_16BIT_REGISTER {
    AX,
    CX,
    DX,
    BX,
    SP,
    BP,
    SI,
    DI
} X86_16BIT_REGISTER;

//
// Define 32-bit register numbers.
//

typedef enum _X86_32BIT_REGISTER {
    EAX,
    ECX,
    EDX,
    EBX,
    ESP,
    EBP,
    ESI,
    EDI
} X86_32BIT_REGISTER;

//
// Define general register structure.
//

typedef union _X86_GENERAL_REGISTER {
    ULONG Exx;
    union {
        USHORT Xx;
        struct {
            UCHAR Xl;
            UCHAR Xh;
        };
    };
} X86_GENERAL_REGISTER, *PX86_GENERAL_REGISTER;

//
// Define segment register numbers.
//

typedef enum _X86_SEGMENT_REGISTER {
    ES,
    CS,
    SS,
    DS,
    FS,
    GS
} X86_SEGMENT_REGISTER;

//
// Define instruction format types.
//

typedef enum _XM_FORMAT_TYPE {

    //
    // N.B. These format codes MUST be the first codes and MUST be
    //      exactly in this order since the ordering corresponds to
    //      segment numbers.
    //

    FormatSegmentES,
    FormatSegmentCS,
    FormatSegmentSS,
    FormatSegmentDS,
    FormatSegmentFS,
    FormatSegmentGS,

    //
    // N.B. These format codes MUST be the second codes and MUST be
    //      exactly in this order since the ordering corresponds to
    //      biased segment number. The entry for the code segment is
    //      a dummy entry to make the indexing work right.
    //

    FormatLoadSegmentES,
    FormatLoadSegmentCS,
    FormatLoadSegmentSS,
    FormatLoadSegmentDS,
    FormatLoadSegmentFS,
    FormatLoadSegmentGS,

    //
    // The following codes can be in any order.
    //

    FormatGroup1General,
    FormatGroup1Immediate,
    FormatGroup2By1,
    FormatGroup2ByCL,
    FormatGroup2ByByte,
    FormatGroup3General,
    FormatGroup4General,
    FormatGroup5General,
    FormatGroup8BitOffset,
    FormatOpcodeRegister,
    FormatLongJump,
    FormatShortJump,
    FormatSetccByte,
    FormatAccumImmediate,
    FormatAccumRegister,
    FormatMoveGeneral,
    FormatMoveImmediate,
    FormatMoveRegImmediate,
    FormatSegmentOffset,
    FormatMoveSegment,
    FormatMoveXxGeneral,
    FormatFlagsRegister,
    FormatPushImmediate,
    FormatPopGeneral,
    FormatImulImmediate,
    FormatStringOperands,
    FormatEffectiveOffset,
    FormatImmediateJump,
    FormatImmediateEnter,
    FormatGeneralBitOffset,
    FormatShiftDouble,
    FormatPortImmediate,
    FormatPortDX,
    FormatBitScanGeneral,
    FormatByteImmediate,
    FormatXlatOpcode,
    FormatGeneralRegister,
    FormatNoOperands,
    FormatOpcodeEscape,
    FormatPrefixOpcode
} XM_FORMAT_TYPE;

//
// Defined opcode modifier bit masks.
//

#define WIDTH_BIT 0x1                   // operand size control
#define DIRECTION_BIT 0x2               // direction of operation
#define SIGN_BIT 0x2                    // sign extended byte

//
// Define prefix opcode function index values.
//

typedef enum _XM_PREFIX_FUNCTION_INDEX {
    X86_ES_OP = ES,
    X86_CS_OP = CS,
    X86_SS_OP = SS,
    X86_DS_OP = DS,
    X86_FS_OP = FS,
    X86_GS_OP = GS,
    X86_LOCK_OP,
    X86_ADSZ_OP,
    X86_OPSZ_OP,
    X86_REPZ_OP,
    X86_REPNZ_OP
} XM_PREFIX_FUNCTION_INDEX;

//
// Define two byte opcode escape.
//

#define TWO_BYTE_ESCAPE 0x0f

//
// Define opcode control table structure.
//
// This table controls the decoding of instructions and there operands.
//

typedef struct _OPCODE_CONTROL {
    UCHAR FunctionIndex;
    UCHAR FormatType;
} OPCODE_CONTROL, *POPCODE_CONTROL;

//
// Define emulator context structure.
//
// This structure holds the global emulator state.
//

typedef struct _XM_CONTEXT {

    //
    // Pointers to the opcode control table and the opcode name table.
    //

    const OPCODE_CONTROL *OpcodeControlTable;
    const CHAR **OpcodeNameTable;

    //
    // x86 extended flags register.
    //

    union {
        UCHAR AhFlags;
        USHORT Flags;
        ULONG AllFlags;
        struct {
            ULONG EFLAG_CF : 1;
            ULONG EFLAG_MBO : 1;
            ULONG EFLAG_PF : 1;
            ULONG EFLAG_SBZ0 : 1;
            ULONG EFLAG_AF : 1;
            ULONG EFLAG_SBZ1 : 1;
            ULONG EFLAG_ZF : 1;
            ULONG EFLAG_SF : 1;
            ULONG EFLAG_TF : 1;
            ULONG EFLAG_IF : 1;
            ULONG EFLAG_DF : 1;
            ULONG EFLAG_OF : 1;
            ULONG EFLAG_IOPL : 2;
            ULONG EFLAG_NT : 1;
            ULONG EFLAG_SBZ2 : 1;
            ULONG EFLAG_RF : 1;
            ULONG EFLAG_VM : 1;
            ULONG EFLAG_AC : 1;
            ULONG EFLAG_SBZ3 : 13;
        } Eflags;
    };

    //
    // x86 instruction pointer.
    //

    union {
        USHORT Ip;
        ULONG Eip;
    };

    //
    // x86 general registers.
    //

    X86_GENERAL_REGISTER Gpr[8];

    //
    // x86 segment registers.
    //

    USHORT SegmentRegister[6];

    //
    // Emulator segment descriptors.
    //

    USHORT SegmentLimit[6];

    //
    // Instruction opcode control information read from the opcode
    // control table.
    //

    OPCODE_CONTROL OpcodeControl;

    //
    // Call or jmp destination segment segment.
    //

    USHORT DstSegment;

    //
    // Source and destination address and value.
    //

    union {
        UCHAR UNALIGNED *DstByte;
        USHORT UNALIGNED *DstWord;
        ULONG UNALIGNED *DstLong;
    };

    union {
        UCHAR UNALIGNED *SrcByte;
        USHORT UNALIGNED *SrcWord;
        ULONG UNALIGNED *SrcLong;
    };

    union {
        UCHAR Byte;
        ULONG Long;
        USHORT Word;
    } DstValue;

    union {
        UCHAR Byte;
        ULONG Long;
        USHORT Word;
    } SrcValue;

    //
    // Current opcode, data segment register to be used to access
    // data operands, function index, and operand data type, and
    // effective address offset.
    //

    ULONG CurrentOpcode;
    ULONG DataSegment;
    ULONG DataType;
    ULONG FunctionIndex;
    ULONG Offset;

    //
    // Prefix control information.
    //

    BOOLEAN LockPrefixActive;
    BOOLEAN OpaddrPrefixActive;
    BOOLEAN OpsizePrefixActive;
    BOOLEAN RepeatPrefixActive;
    BOOLEAN SegmentPrefixActive;
    UCHAR RepeatZflag;

    //
    // Effective address computation control.
    //

    BOOLEAN RegisterOffsetAddress;
    BOOLEAN ComputeOffsetAddress;

    //
    // Shift count.
    //

    UCHAR Shift;

    //
    // Jump buffer.
    //

    _JBTYPE JumpBuffer[_JBLEN];

    //
    // Address of read I/O space, write I/O space, and translation address
    // routines.
    //

    PXM_READ_IO_SPACE ReadIoSpace;
    PXM_WRITE_IO_SPACE WriteIoSpace;
    PXM_TRANSLATE_ADDRESS TranslateAddress;
} XM_CONTEXT, *PXM_CONTEXT, *RESTRICTED_POINTER PRXM_CONTEXT;

//
// Define opcode function and decode operand types.
//

typedef
ULONG
(*POPERAND_DECODE) (
    IN PRXM_CONTEXT P
    );

typedef
VOID
(*POPCODE_FUNCTION) (
    IN PRXM_CONTEXT P
    );

//
// Operand decode prototypes.
//

ULONG
XmPushPopSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmLoadSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup1General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup1Immediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2By1 (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2ByCL (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2ByByte (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup3General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup45General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup8BitOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmOpcodeRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmLongJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmShortJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmSetccByte (
    IN PRXM_CONTEXT P
    );

ULONG
XmAccumImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmAccumRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveRegImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmSegmentOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveXxGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmFlagsRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmPushImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPopGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmImulImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmStringOperands (
    IN PRXM_CONTEXT P
    );

ULONG
XmEffectiveOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmImmediateJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmImmediateEnter (
    IN PRXM_CONTEXT P
    );

ULONG
XmGeneralBitOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmShiftDouble (
    IN PRXM_CONTEXT P
    );

ULONG
XmPortImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPortDX (
    IN PRXM_CONTEXT P
    );

ULONG
XmBitScanGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmByteImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmXlatOpcode (
    IN PRXM_CONTEXT P
    );

ULONG
XmGeneralRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmOpcodeEscape (
    IN PRXM_CONTEXT P
    );

ULONG
XmPrefixOpcode (
    IN PRXM_CONTEXT P
    );

ULONG
XmNoOperands (
    IN PRXM_CONTEXT P
    );

//
// Define miscellaneous prototypes.
//

ULONG
XmComputeParity (
    IN ULONG Result
    );

XM_STATUS
XmEmulateStream (
    IN PRXM_CONTEXT P,
    USHORT Segment,
    USHORT Offset,
    PXM86_CONTEXT Context
    );

UCHAR
XmGetCodeByte (
    IN PRXM_CONTEXT P
    );

UCHAR
XmGetByteImmediate (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetByteImmediateToWord (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetByteImmediateToLong (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetSignedByteImmediateToWord (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetSignedByteImmediateToLong (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetWordImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetLongImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPopStack (
    IN PRXM_CONTEXT P
    );

VOID
XmPushStack (
    IN PRXM_CONTEXT P,
    IN ULONG Value
    );

VOID
XmSetDataType (
    IN PRXM_CONTEXT P
    );

VOID
XmStoreResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

//
// Define operand specifier prototypes.
//

PVOID
XmEvaluateAddressSpecifier (
    IN PRXM_CONTEXT P,
    OUT PLONG Register
    );

PVOID
XmGetOffsetAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Offset
    );

PVOID
XmGetRegisterAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Number
    );

PVOID
XmGetStringAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Segment,
    IN ULONG Register
    );

VOID
XmSetDestinationValue (
    IN PRXM_CONTEXT P,
    IN PVOID Destination
    );

VOID
XmSetSourceValue (
    IN PRXM_CONTEXT P,
    IN PVOID Source
    );

ULONG
XmGetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG ByteFlag
    );

VOID
XmSetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    );

//
// ASCII operators.
//

VOID
XmAaaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAadOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAamOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAasOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDaaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDasOp (
    IN PRXM_CONTEXT P
    );

//
// Group 1 operations.
//

VOID
XmAddOp (
    IN PRXM_CONTEXT P
    );

VOID
XmOrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAdcOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSbbOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAndOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSubOp (
    IN PRXM_CONTEXT P
    );

VOID
XmXorOp (
    IN PRXM_CONTEXT P
    );

VOID
XmCmpOp (
    IN PRXM_CONTEXT P
    );

//
// Group 2 operations.
//

VOID
XmRolOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRorOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRclOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRcrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmShlOp (
    IN PRXM_CONTEXT P
    );

VOID
XmShrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSarOp (
    IN PRXM_CONTEXT P
    );

//
// Group 3 operations.
//

VOID
XmTestOp (
    IN PRXM_CONTEXT P
    );

VOID
XmNotOp (
    IN PRXM_CONTEXT P
    );

VOID
XmNegOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDivOp (
    IN PRXM_CONTEXT P
    );

VOID
XmIdivOp (
    IN PRXM_CONTEXT P
    );

VOID
XmImulOp (
    IN PRXM_CONTEXT P
    );

VOID
XmImulxOp (
    IN PRXM_CONTEXT P
    );

VOID
XmMulOp (
    IN PRXM_CONTEXT P
    );

//
// Group 4 and 5 operators.
//

VOID
XmIncOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDecOp (
    IN PRXM_CONTEXT P
    );

VOID
XmCallOp (
    PRXM_CONTEXT P
    );

VOID
XmJmpOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPushOp (
    IN PRXM_CONTEXT P
    );

//
// Group 8 operators.
//

VOID
XmBtOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtsOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtcOp (
    IN PRXM_CONTEXT P
    );

//
// Stack operations.
//

VOID
XmPopOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPushaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPopaOp (
    IN PRXM_CONTEXT P
    );

//
// Conditional jump and set conditional operations.
//

VOID
XmJxxOp (
    IN PRXM_CONTEXT P
    );

VOID
XmLoopOp (
    IN PRXM_CONTEXT P
    );

VOID
XmJcxzOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSxxOp (
    IN PRXM_CONTEXT P
    );

//
// Condition code operations.
//

VOID
XmClcOp (
    PRXM_CONTEXT P
    );

VOID
XmCldOp (
    PRXM_CONTEXT P
    );

VOID
XmCliOp (
    PRXM_CONTEXT P
    );

VOID
XmCmcOp (
    PRXM_CONTEXT P
    );

VOID
XmStcOp (
    PRXM_CONTEXT P
    );

VOID
XmStdOp (
    PRXM_CONTEXT P
    );

VOID
XmStiOp (
    PRXM_CONTEXT P
    );

VOID
XmLahfOp (
    PRXM_CONTEXT P
    );

VOID
XmSahfOp (
    PRXM_CONTEXT P
    );

//
// Move operations.
//

VOID
XmMovOp (
    PRXM_CONTEXT P
    );

VOID
XmXchgOp (
    PRXM_CONTEXT P
    );

//
// Convert operations.
//

VOID
XmCbwOp (
    PRXM_CONTEXT P
    );

VOID
XmCwdOp (
    PRXM_CONTEXT P
    );

//
// Control operations.
//

VOID
XmEnterOp (
    PRXM_CONTEXT P
    );

VOID
XmHltOp (
    PRXM_CONTEXT P
    );

VOID
XmIntOp (
    PRXM_CONTEXT P
    );

VOID
XmIretOp (
    PRXM_CONTEXT P
    );

VOID
XmLeaveOp (
    PRXM_CONTEXT P
    );

VOID
XmRetOp (
    PRXM_CONTEXT P
    );

//
// String operations.
//

VOID
XmCmpsOp (
    PRXM_CONTEXT P
    );

VOID
XmInsOp (
    PRXM_CONTEXT P
    );

VOID
XmLodsOp (
    PRXM_CONTEXT P
    );

VOID
XmMovsOp (
    PRXM_CONTEXT P
    );

VOID
XmOutsOp (
    PRXM_CONTEXT P
    );

VOID
XmScasOp (
    PRXM_CONTEXT P
    );

VOID
XmStosOp (
    PRXM_CONTEXT P
    );

//
// Shift double operators.
//

VOID
XmShldOp (
    PRXM_CONTEXT P
    );

VOID
XmShrdOp (
    PRXM_CONTEXT P
    );

//
// I/O operators.
//

VOID
XmInOp (
    PRXM_CONTEXT P
    );

VOID
XmOutOp (
    PRXM_CONTEXT P
    );

//
// Bit scan operators.
//

VOID
XmBsfOp (
    PRXM_CONTEXT P
    );

VOID
XmBsrOp (
    PRXM_CONTEXT P
    );

//
// MIscellaneous operations.
//

VOID
XmXaddOp (
    PRXM_CONTEXT P
    );

VOID
XmBoundOp (
    PRXM_CONTEXT P
    );

VOID
XmBswapOp (
    PRXM_CONTEXT P
    );

VOID
XmCmpxchgOp (
    PRXM_CONTEXT P
    );

VOID
XmIllOp (
    PRXM_CONTEXT P
    );

VOID
XmNopOp (
    PRXM_CONTEXT P
    );

//
// PCI Bios emulation routines.
//

#if !defined(_PURE_EMULATION_)

BOOLEAN
XmExecuteInt1a (
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aPciBiosPresent(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aFindPciClassCode(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aFindPciDevice(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aGenerateSpecialCycle(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aGetRoutingOptions(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aSetPciIrq(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aReadConfigRegister(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aWriteConfigRegister(
    IN OUT PRXM_CONTEXT Context
    );

#endif

//
// Debug routines.
//

#if XM_DEBUG

#include "stdio.h"
//#define DEBUG_PRINT(_X_) DbgPrint _X_
#define DEBUG_PRINT(_X_) printf _X_

VOID
XmTraceDestination (
    IN PRXM_CONTEXT P,
    IN ULONG Destination
    );

VOID
XmTraceFlags (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceInstruction (
    IN XM_OPERATION_DATATYPE DataType,
    IN ULONG Instruction
    );

VOID
XmTraceJumps (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceOverride (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceRegisters (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

VOID
XmTraceSpecifier (
    IN UCHAR Specifier
    );

VOID
XmTraceSource (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    );

#else

#define XmTraceDestination(P, Destination)
#define XmTraceInstruction(DataType, Instruction)
#define XmTraceFlags(P)
#define XmTraceJumps(P)
#define XmTraceOverride(P)
#define XmTraceRegisters(P)
#define XmTraceResult(P, Result)
#define XmTraceSpecifier(Specifier)
#define XmTraceSource(P, Source)

#endif

//
// Define global data.
//

extern XM_CONTEXT XmContext;
extern BOOLEAN XmEmulatorInitialized;
extern const OPCODE_CONTROL XmOpcodeControlTable1[];
extern const OPCODE_CONTROL XmOpcodeControlTable2[];
extern const POPCODE_FUNCTION XmOpcodeFunctionTable[];
extern const POPERAND_DECODE XmOperandDecodeTable[];

#if !defined(_PURE_EMULATION)

extern UCHAR XmNumberPciBusses;
extern BOOLEAN XmPciBiosPresent;
extern PGETSETPCIBUSDATA XmGetPciData;
extern PGETSETPCIBUSDATA XmSetPciData;

#endif

#if XM_DEBUG

extern ULONG XmDebugFlags;
extern const PCHAR XmOpcodeNameTable1[];
extern const PCHAR XmOpcodeNameTable2[];

#endif

#endif // _EMULATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\inoutops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inoutops.c

Abstract:

    This module implements the code to emulate the in and out opcodes.

Author:

    David N. Cutler (davec) 7-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmInOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a inb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Check if the I/O port number is valid.
    //

    if ((P->SrcValue.Long + P->DataType) > 0xffff) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_PORT_NUMBER);
    }

    //
    // Set the destination address, input from the specified port, and
    // store the result.
    //

    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
    XmStoreResult(P, (P->ReadIoSpace)(P->DataType, P->SrcValue.Word));
    return;
}

VOID
XmInsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a insb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;
    USHORT PortNumber;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Move items from the input port to the destination string.
    //

    PortNumber = P->SrcValue.Word;
    while (Count != 0) {

        //
        // Set the destination address, input from the specified port, and
        // store the result.
        //

        P->DstLong = (ULONG UNALIGNED *)XmGetStringAddress(P, ES, EDI);
        XmStoreResult(P, (P->ReadIoSpace)(P->DataType, PortNumber));
        Count -= 1;
    }

    return;
}

VOID
XmOutOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a outb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    USHORT PortNumber;

    //
    // Check if the I/O port number is valid.
    //

    if ((P->SrcValue.Long + P->DataType) > 0xffff) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_PORT_NUMBER);
    }

    //
    // Save the port number, get the source value, and output to the port.
    //

    PortNumber = P->SrcValue.Word;
    XmSetSourceValue(P, &P->Gpr[EAX].Exx);
    (P->WriteIoSpace)(P->DataType, PortNumber, P->SrcValue.Long);
    return;
}

VOID
XmOutsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a outsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;
    USHORT PortNumber;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Move items from the source string to the output port.
    //

    PortNumber = P->SrcValue.Word;
    while (Count != 0) {

        //
        // Set the source value and output to the specified port.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        (P->WriteIoSpace)(P->DataType, PortNumber, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\jmpops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    jmpops.c

Abstract:

    This module implements the code to emulate jump opcodes.

Author:

    David N. Cutler (davec) 13-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmJcxzOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a jcxz instruction.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Condition;

    //
    // If eCX is zero, then set the new IP value.
    //

    if (P->OpsizePrefixActive != FALSE) {
        Condition = P->Gpr[ECX].Exx;

    } else {
        Condition = P->Gpr[CX].Xx;
    }

    if (Condition == 0) {
        P->Eip = P->DstValue.Word;
        XmTraceJumps(P);
    }

    return;
}

VOID
XmJmpOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a jmp near relative instruction.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Set the destination segment, if required, and set the new IP.
    //

    P->Eip = P->DstValue.Long;
    if ((P->CurrentOpcode == 0xea) || (P->FunctionIndex != X86_JMP_OP)) {
        P->SegmentRegister[CS] = P->DstSegment;
    }

    XmTraceJumps(P);
    return;
}

VOID
XmJxxOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates conditional jump instructions.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Complement;
    ULONG Condition;

    //
    // Case on the jump control value.
    //

    Complement = P->SrcValue.Long & 1;
    switch (P->SrcValue.Long >> 1) {

        //
        // Jump if overflow/not overflow.
        //

    case 0:
        Condition = P->Eflags.EFLAG_OF;
        break;

        //
        // Jump if below/not below.
        //

    case 1:
        Condition = P->Eflags.EFLAG_CF;
        break;

        //
        // Jump if zero/not zero.
        //

    case 2:
        Condition = P->Eflags.EFLAG_ZF;
        break;

        //
        // Jump if below or equal/not below or equal.
        //

    case 3:
        Condition = P->Eflags.EFLAG_CF | P->Eflags.EFLAG_ZF;
        break;

        //
        // Jump if signed/not signed.
        //

    case 4:
        Condition = P->Eflags.EFLAG_SF;
        break;

        //
        // Jump if parity/not parity.
        //

    case 5:
        Condition = P->Eflags.EFLAG_PF;
        break;

        //
        // Jump if less/not less.
        //

    case 6:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF);
        break;

        //
        // Jump if less or equal/not less or equal.
        //

    case 7:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF) | P->Eflags.EFLAG_ZF;
        break;
    }

    //
    // If the specified condition is met, then set the new IP value.
    //

    if ((Condition ^ Complement) != 0) {
        P->Eip = P->DstValue.Word;
        XmTraceJumps(P);
    }

    return;
}

VOID
XmLoopOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates loop, loopz, or a loopnz instructions.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Condition;
    ULONG Result;
    ULONG Type;

    //
    // Set the address of the destination and compute the result value.
    //

    Result = P->Gpr[ECX].Exx - 1;
    P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[ECX].Exx);
    if (P->OpaddrPrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
        Result &= 0xffff;
    }

    XmStoreResult(P, Result);

    //
    // Isolate the loop type and test the appropriate condition.
    //
    // Type 0 - loopnz
    //      1 - loopz
    //      2 - loop
    //

    Type = P->CurrentOpcode & 3;
    if (Type == 0) {
        Condition = P->Eflags.EFLAG_ZF ^ 1;

    } else if (Type == 1) {
        Condition = P->Eflags.EFLAG_ZF;

    } else {
        Condition = TRUE;
    }

    //
    // If the loop condition is met, then set the new IP value.
    //

    if ((Condition != FALSE) && (Result != 0)) {
        P->Eip = P->DstValue.Word;
        XmTraceJumps(P);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\main.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86test.c

Abstract:

    This module implements a series of tests for the x86 ROM Bios emulator.

Author:

    David N. Cutler (davec) 13-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "stdio.h"
#include "string.h"
#include "memory.h"
#include "emulate.h"

//
// Define global instruction execution data.
//

UCHAR CodeStream[] = {0xeb, 0x07,                   // jmp .+7
                      0xc3,                         // ret (near)
                      0xcb,                         // ret (far)
                      0x66, 0xc3,                   // ret (near)
                      0x66, 0xcb,                   // ret (far)
                      0xcf,                         // iret
                      0xe9, 0x00, 0x00,             // jmp .+1
                      0x66, 0xe9, 0x00, 0x00, 0x00, 0x00, // jmp .+1
                      0xea, 0x17, 0x00, 0x00, 0x20, // jmp 0x0017:0x2000
                      0x66, 0xea, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x20, // jmp 0x0000001f:0x2000
                      0x66, 0xb8, 0x2e, 0x00, 0x00, 0x20, // mov eax, 0x2000002e
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x26, 0x04, 0x00,       // jmp ds:0x0004
                      0x66, 0xb8, 0x3d, 0x00, 0x00, 0x20, // mov eax, 0x2000003d
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x2e, 0x04, 0x00,       // jmp ds:0x0004
                      0x9b,                         // wait (nop)
/*                      0x00, 0xc0,                   // add al, al
                      0x00, 0xc9,                   // add cl, cl
                      0x00, 0xd2,                   // add dl, dl
                      0x00, 0xdb,                   // add bl, bl
                      0x00, 0xe4,                   // add ah, ah
                      0x00, 0xed,                   // add ch, ch
                      0x00, 0xf6,                   // add dh, dh
                      0x00, 0xff,                   // add bh, bh
                      0x01, 0xc0,                   // add ax, ax
                      0x01, 0xc9,                   // add cx, cx
                      0x01, 0xd2,                   // add dx, dx
                      0x01, 0xdb,                   // add bx, bx
                      0x01, 0xed,                   // add bp, bp
                      0x01, 0xf6,                   // add si, si
                      0x01, 0xff,                   // add di, di
                      0x66, 0x01, 0xc0,             // add eax, eax
                      0x66, 0x01, 0xc9,             // add ecx, ecx
                      0x66, 0x01, 0xd2,             // add edx, edx
                      0x66, 0x01, 0xdb,             // add ebx, ebx
                      0x66, 0x01, 0xed,             // add ebp, ebp
                      0x66, 0x01, 0xf6,             // add esi, esi
                      0x66, 0x01, 0xff,             // add edi, edi
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x04, 0xf0,                   // add al, 0xf0
                      0x41,                         // inc CX
                      0x41,                         // inc CX
                      0xc0, 0xc0, 0x05,             // rol al, 0x05
                      0xd0, 0xc0,                   // rol al, 1
                      0xd2, 0xc0,                   // rol al, CL
                      0x05, 0x0f, 0x00,             // add ax, 0x000f
                      0xc1, 0xc0, 0x0d,             // rol ax, 0x0d
                      0xd1, 0xc0,                   // rol ax, 1
                      0xd3, 0xc0,                   // rol ax, CL
                      0x05, 0x00, 0xff,             // add ax, 0xff00
                      0x66, 0xc1, 0xc0, 0x1d,       // rol eax, 0x1d
                      0x66, 0xd1, 0xc0,             // rol eax, 1
                      0x66, 0xd3, 0xc0,             // rol eax, CL
                      0xf8,                         // clc
                      0xf9,                         // stc
                      0xf8,                         // clc
                      0xf5,                         // cmc
                      0xf5,                         // cmc
                      0xfa,                         // cli
                      0xfb,                         // sti
                      0xfc,                         // cld
                      0xfd,                         // std
                      0xfc,                         // cld
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x66, 0x05, 0xf0, 0x3c, 0x0f, 0x0f, // add eax, 0x0f0f3cf0
                      0x66, 0x89, 0xc2,             // mov edx,eax
                      0x31, 0xd2,                   // xor dx, dx
                      0x88, 0xc3,                   // mov bl, al
                      0x88, 0xe7,                   // mov bh, ah
                      0x89, 0xda,                   // mov dx, bx
                      0x66, 0x89, 0xc6,             // mov esi, eax
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x8b, 0xc6,             // mov eax, esi
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x66, 0xb8, 0x11, 0x11, 0x11, 0x11, // mov EAX, 0x11111111
                      0x66, 0xb9, 0x22, 0x22, 0x22, 0x22, // mov ECX, 0x22222222
                      0x66, 0xba, 0x33, 0x33, 0x33, 0x33, // mov EDX, 0x33333333
                      0x66, 0xbb, 0x44, 0x44, 0x44, 0x44, // mov EBX, 0x44444444
                      0x66, 0xbd, 0x66, 0x66, 0x66, 0x66, // mov EBP, 0x66666666
                      0x66, 0xbe, 0x77, 0x77, 0x77, 0x77, // mov ESI, 0x77777777
                      0x66, 0xbf, 0x88, 0x88, 0x88, 0x88, // mov EDI, 0x88888888
                      0xb8, 0x08, 0x01,             // mov AX, 0x0108
                      0xb9, 0x09, 0x02,             // mov CX, 0x0209
                      0xba, 0x0a, 0x03,             // mov DX, 0x030a
                      0xbb, 0x0b, 0x04,             // mov BX, 0x040b
                      0xbd, 0x0d, 0x06,             // mov BP, 0x060d
                      0xbe, 0x0e, 0x07,             // mov SI, 0x070e
                      0xbf, 0x0f, 0x08,             // mov DI, 0x080f
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x02,                   // mov cl, 0x02
                      0xb2, 0x03,                   // mov dl, 0x03
                      0xb3, 0x04,                   // mov bl, 0x04
                      0xb4, 0x05,                   // mov ah, 0x05
                      0xb5, 0x06,                   // mov ch, 0x06
                      0xb6, 0x07,                   // mov dh, 0x07
                      0xb7, 0x08,                   // mov bh, 0x08
                      0x91,                         // xchg cx, ax
                      0x92,                         // xchg dx, ax
                      0x93,                         // xchg bx, ax
                      0x95,                         // xchg bp, ax
                      0x96,                         // xchg si, ax
                      0x97,                         // xchg di, ax
                      0x66, 0x91,                   // xchg ecx, eax
                      0x66, 0x92,                   // xchg edx, eax
                      0x66, 0x93,                   // xchg ebx, eax
                      0x66, 0x95,                   // xchg ebp, eax
                      0x66, 0x96,                   // xchg esi, eax
                      0x66, 0x97,                   // xchg edi, eax
                      0x86, 0xd9,                   // xchg bl, cl
                      0x87, 0xd9,                   // xchg bx, cx
                      0x66, 0x87, 0xd9,             // xchg ebx, ecx
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x98,                         // cbw
                      0xb0, 0x83,                   // mov al, 0x83
                      0x98,                         // cbw
                      0xb8, 0x01, 0x08,             // mov AX, 0x0801
                      0x99,                         // cwd
                      0xb8, 0x01, 0x80,             // mov AX, 0x8001
                      0x99,                         // cwd
                      0xb4, 0xfd,                   // mov ah, 0xfd
                      0x9e,                         // sahf
                      0xb4, 0x77,                   // mov ah, 0x77
                      0x9f,                         // lahf
                      0xc6, 0xc0, 0xed,             // mov al, 0xed
                      0xc6, 0xc4, 0xde,             // mov ah, 0xde
                      0xc7, 0xc0, 0xcc, 0xdd,       // mov ax, 0xddcc
                      0x66, 0xc7, 0xc0, 0xdd, 0xcc, 0xbb, 0xaa, // mov eax, 0xaabbccdd
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x90, 0xc0,             // seto al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x91, 0xc0,             // setno al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x92, 0xc0,             // setb al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x93, 0xc0,             // setnb al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x94, 0xc0,             // setz al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x95, 0xc0,             // setnz al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x96, 0xc0,             // setbe al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x97, 0xc0,             // setnbe al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x98, 0xc0,             // sets al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x99, 0xc0,             // setns al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9a, 0xc0,             // setp al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9b, 0xc0,             // setnp al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9c, 0xc0,             // setl al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9d, 0xc0,             // setnl al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9e, 0xc0,             // setle al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9f, 0xc0,             // setnle al
                      0x66, 0xb8, 0xfe, 0xff, 0x01, 0x00, // mov eax, 0x0001fffe
                      0x40,                         // inc ax
                      0x66, 0x40,                   // inc eax
                      0x66, 0x48,                   // dec eax
                      0x48,                         // dec ax
                      0x66, 0xb9, 0xfe, 0xff, 0x01, 0x00, // mov ecx, 0x0001fffe
                      0x41,                         // inc cx
                      0x66, 0x41,                   // inc ecx
                      0x66, 0x49,                   // dec ecxx
                      0x49,                         // dec cx
                      0x66, 0xba, 0xfe, 0xff, 0x01, 0x00, // mov edx, 0x0001fffe
                      0x42,                         // inc dx
                      0x66, 0x42,                   // inc edx
                      0x66, 0x4a,                   // dec edx
                      0x4a,                         // dec dx
                      0x66, 0xbb, 0xfe, 0xff, 0x01, 0x00, // mov ebx, 0x0001fffe
                      0x43,                         // inc bx
                      0x66, 0x43,                   // inc ebx
                      0x66, 0x4b,                   // dec ebx
                      0x4b,                         // dec bx
                      0x66, 0xbd, 0xfe, 0xff, 0x01, 0x00, // mov ebp, 0x0001fffe
                      0x45,                         // inc bp
                      0x66, 0x45,                   // inc ebp
                      0x66, 0x4d,                   // dec ebp
                      0x4d,                         // dec bp
                      0x66, 0xbe, 0xfe, 0xff, 0x01, 0x00, // mov esi, 0x0001fffe
                      0x46,                         // inc si
                      0x66, 0x46,                   // inc esi
                      0x66, 0x4e,                   // dec esix
                      0x4e,                         // dec si
                      0x66, 0xbf, 0xfe, 0xff, 0x01, 0x00, // mov edi, 0x0001fffe
                      0x47,                         // inc di
                      0x66, 0x47,                   // inc edi
                      0x66, 0x4f,                   // dec edix
                      0x4f,                         // dec di
                      0x26, 0x90,                   // ES: nop
                      0x2e, 0x90,                   // CS: nop
                      0x36, 0x90,                   // SS: nop
                      0x3e, 0x90,                   // DS: nop
                      0x64, 0x90,                   // FS: nop
                      0x65, 0x90,                   // GS: nop
                      0xb8, 0xb8, 0xb8,             // mov ax, 0xb8b8
                      0xb9, 0xb9, 0xb9,             // mov cx, 0xb9b9
                      0xba, 0xba, 0xba,             // mov dx, 0xbaba
                      0xbb, 0xbb, 0xbb,             // mov bx, 0xbbbb
                      0xbd, 0xbd, 0xbd,             // mov bp, 0xbdbd
                      0xbe, 0xbe, 0xbe,             // mov si, 0xbebe
                      0xbf, 0xbf, 0xbf,             // mov di, 0xbfbf
                      0x66, 0x50,                   // push eax
                      0x66, 0x51,                   // push ecx
                      0x66, 0x52,                   // push edx
                      0x66, 0x53,                   // push ebx
                      0x66, 0x54,                   // push esp
                      0x66, 0x55,                   // push ebp
                      0x66, 0x56,                   // push esi
                      0x66, 0x57,                   // push edi
                      0x50,                         // push ax
                      0x51,                         // push cx
                      0x52,                         // push dx
                      0x53,                         // push bx
                      0x54,                         // push sp
                      0x55,                         // push bp
                      0x56,                         // push si
                      0x57,                         // push di
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x00, 0x00,             // mov cx, 0x0000
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xbb, 0x00, 0x00,             // mov bx, 0x0000
                      0xbd, 0x00, 0x00,             // mov bp, 0x0000
                      0xbe, 0x00, 0x00,             // mov si, 0x0000
                      0xbf, 0x00, 0x00,             // mov di, 0x0000
                      0x5f,                         // pop di
                      0x5e,                         // pop si
                      0x5d,                         // pop bp
                      0x5c,                         // pop sp
                      0x5b,                         // pop bx
                      0x5a,                         // pop dx
                      0x59,                         // pop cx
                      0x58,                         // pop ax
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x00, 0x00,             // mov cx, 0x0000
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xbb, 0x00, 0x00,             // mov bx, 0x0000
                      0xbd, 0x00, 0x00,             // mov bp, 0x0000
                      0xbe, 0x00, 0x00,             // mov si, 0x0000
                      0xbf, 0x00, 0x00,             // mov di, 0x0000
                      0x66, 0x5f,                   // pop edi
                      0x66, 0x5e,                   // pop esi
                      0x66, 0x5d,                   // pop ebp
                      0x66, 0x5c,                   // pop esp
                      0x66, 0x5b,                   // pop ebx
                      0x66, 0x5a,                   // pop edx
                      0x66, 0x59,                   // pop ecx
                      0x66, 0x58,                   // pop eax
                      0x06,                         // push ES
                      0x0e,                         // push CS
                      0x16,                         // push SS
                      0x1e,                         // push DS
                      0x0f, 0xa0,                   // push FS
                      0x0f, 0xa8,                   // push GS
                      0x0f, 0xa9,                   // pop GS
                      0x0f, 0xa1,                   // pop FS
                      0x1f,                         // pop DS
                      0x17,                         // pop SS
                      0x58,                         // pop ax
                      0x07,                         // pop ES
                      0x90,                         // nop
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x20, 0xc1,                   // and cl, al
                      0xb0, 0x55,                   // mov al, 0x55
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x20, 0xc1,                   // and cl, al
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0x7e,                   // mov cl, 0x7e
                      0x20, 0xc1,                   // and cl, al
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x21, 0xc1,                   // and cx, ax
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x21, 0xc1,                   // and cx, ax
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0x7e, 0x7e,             // mov cx, 0x7e7e
                      0x21, 0xc1,                   // and cx, ax
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x21, 0xc1,             // and ecx, eax
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x21, 0xc1,             // and ecx, eax
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0x7e, 0x7e, 0x7e, 0x7e, // mov ecx, 0x7e7e7e7e
                      0x66, 0x21, 0xc1,             // and ecx, eax
                      0xb1, 0x80,                   // mov cl, 0x80
                      0x80, 0xe1, 0xff,             // and cl, 0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x81, 0xe1, 0xff, 0xff,       // and cx, 0xffff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x81, 0xe1, 0xff, 0xff, 0xff, 0xff, // and ecx, 0xffffffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xe1, 0x7f,             // and cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xe1, 0x7f,       // and ecx, (sign)0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xe1, 0xf7,             // and cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xe1, 0xf7,       // and ecx, (sign)0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x08, 0xc1,                   // or cl, al
                      0xb0, 0x55,                   // mov al, 0x55
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x08, 0xc1,                   // or cl, al
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0x7e,                   // mov cl, 0x7e
                      0x08, 0xc1,                   // or cl, al
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x09, 0xc1,                   // or cx, ax
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x09, 0xc1,                   // or cx, ax
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0x7e, 0x7e,             // mov cx, 0x7e7e
                      0x09, 0xc1,                   // or cx, ax
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0x7e, 0x7e, 0x7e, 0x7e, // mov ecx, 0x7e7e7e7e
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0xb1, 0x80,                   // mov cl, 0x80
                      0x80, 0xc9, 0xff,             // or cl, 0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x81, 0xc9, 0xff, 0xff,       // or cx, 0xffff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x81, 0xc9, 0xff, 0xff, 0xff, 0xff, // or ecx, 0xffffffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xc9, 0x7f,             // or cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xc9, 0x7f,       // or ecx, (sign)0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xc9, 0xf7,             // or cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xc9, 0xf7,       // or ecx, (sign)0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x30, 0xc1,                   // xor cl, al
                      0xb0, 0x55,                   // mov al, 0x55
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x30, 0xc1,                   // xor cl, al
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0x7e,                   // mov cl, 0x7e
                      0x30, 0xc1,                   // xor cl, al
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x31, 0xc1,                   // xor cx, ax
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x31, 0xc1,                   // xor cx, ax
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0x7e, 0x7e,             // mov cx, 0x7e7e
                      0x31, 0xc1,                   // xor cx, ax
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x31, 0xc1,             // xor ecx, eax
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x31, 0xc1,             // xor ecx, eax
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0x7e, 0x7e, 0x7e, 0x7e, // mov ecx, 0x7e7e7e7e
                      0x66, 0x31, 0xc1,             // xor ecx, eax
                      0xb1, 0x80,                   // mov cl, 0x80
                      0x80, 0xf1, 0xff,             // xor cl, 0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x81, 0xf1, 0xff, 0xff,       // xor cx, 0xffff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x81, 0xf1, 0xff, 0xff, 0xff, 0xff, // xor ecx, 0xffffffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xf1, 0x7f,             // xor cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xf1, 0x7f,       // xor ecx, (sign)0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xf1, 0xf7,             // xor cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xf1, 0xf7,       // xor ecx, (sign)0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xa8, 0xff,                   // test al, 0xff
                      0xb0, 0x55,                   // mov al, 0x55
                      0xa8, 0xff,                   // test al, 0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xa8, 0x7e,                   // test al, 0x7e
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xa9, 0xff, 0xff,             // test ax, 0xffff
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xa9, 0xff, 0xff,             // test ax, 0xffff
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xa9, 0x7e, 0x7e,             // test ax, 0x7e7e
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xa9, 0xff, 0xff, 0xff, 0xff, // test ecx, 0xffffffff
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xa9, 0xff, 0xff, 0xff, 0xff, // test eax, 0xffffffff
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xa9, 0x7e, 0x7e, 0x7e, 0x7e, // test eax, 0x7e7e7e7e
                      0xb2, 0x81,                    // mov dl, 0x81
                      0xf6, 0xd2,                    // not dl
                      0xba, 0x7e, 0x7e,              // mov dx, 0xfe7e
                      0xf7, 0xd2,                    // not dx
                      0x66, 0xba, 0x5a, 0xa5, 0x5a, 0xa5, // mov edx, 0xa55aa55a
                      0x66, 0xf7, 0xd2,              // not edx
                      0xb1, 0x81,                   // mov cl, 0x81
                      0xf6, 0xc1, 0xff,             // test cl, 0xff
                      0xb1, 0x55,                   // mov cl, 0x55
                      0xf6, 0xc1, 0xff,             // test cl, 0xff
                      0xb1, 0x81,                   // mov cl, 0x81
                      0xf6, 0xc1, 0x7e,             // test cl, 0x7e
                      0xb9, 0x81, 0x81,             // mov cx, 0x8181
                      0xf7, 0xc1, 0xff, 0xff,       // test cx, 0xffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0xf7, 0xc1, 0xff, 0xff,       // test cx, 0xffff
                      0xb9, 0x81, 0x81,             // mov cx, 0x8181
                      0xf7, 0xc1, 0x7e, 0x7e,       // test cx, 0x7e7e
                      0x66, 0xb9, 0x81, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0xf7, 0xc1, 0xff, 0xff, 0xff, 0xff, // test ecx, 0xffffffff
                      0x66, 0xb9, 0x55, 0x55, 0x55, 0x55, // mov ecx, 0x55555555
                      0x66, 0xf7, 0xc1, 0xff, 0xff, 0xff, 0xff, // test ecx, 0xffffffff
                      0x66, 0xb9, 0x81, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0xf7, 0xc1, 0x7e, 0x7e, 0x7e, 0x7e, // test ecx, 0x7e7e7e7e
                      0xb2, 0x81,                    // mov dl, 0x81
                      0xf6, 0xda,                    // neg dl
                      0xba, 0x7e, 0xfe,              // mov dx, 0xfe7e
                      0xf7, 0xda,                    // neg dx
                      0x66, 0xba, 0x5a, 0xa5, 0x5a, 0xa5, // mov edx, 0xa55aa55a
                      0x66, 0xf7, 0xda,              // neg edx
                      0xb2, 0x7f,                    // mov dl, 0x7f
                      0xf6, 0xda,                    // neg dl
                      0xba, 0x7e, 0x7e,              // mov dx, 0x7e7e
                      0xf7, 0xda,                    // neg dx
                      0x66, 0xba, 0xa5, 0x5a, 0xa5, 0x5a, // mov edx, 0x5aa55aa5
                      0x66, 0xf7, 0xda,              // neg edx
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x98,                         // cbw
                      0xb0, 0x83,                   // mov al, 0x83
                      0x98,                         // cbw
                      0xb8, 0x01, 0x08,             // mov ax, 0x0801
                      0x99,                         // cwd
                      0xb8, 0x01, 0x80,             // mov ax, 0x8001
                      0x99,                         // cwd
                      0xb8, 0x7f, 0x7f,             // mov ax, 0x7f7f
                      0x66, 0x98,                   // cwde
                      0xb8, 0x83, 0x83,             // mov ax, 0x8383
                      0x66, 0x98,                   // cwde
                      0x66, 0xb8, 0x01, 0x08, 0x01, 0x08, // mov eax, 0x08010801
                      0x66, 0x99,                   // cdq
                      0x66, 0xb8, 0x01, 0x80, 0x01, 0x80, // mov eax, 0x80018001
                      0x66, 0x99,                   // cdq
                      0x66, 0x9c,                   // pushaf
                      0x9c,                         // pushf
                      0x66, 0xb8, 0xd7, 0x0c, 0x06, 0x00, // mov eax, 0x00060cd7
                      0x66, 0x50,                   // push eax
                      0x50,                         // push ax
                      0x9d,                         // popf
                      0x66, 0x9d,                   // popaf
                      0x9d,                         // popf
                      0x66, 0x9d,                   // popaf
                      0x68, 0xef, 0xfe,             // push 0xfeef
                      0x68, 0x11, 0x11,             // push 0x1111
                      0x66, 0x68, 0xef, 0xfe, 0xef, 0xfe, // push 0xfeeffeef
                      0x6a, 0xfe,                   // push 0xfe -> 0xfffe
                      0x6a, 0x7f,                   // push 0x7f -> 0x007f
                      0x66, 0x6a, 0xfe,             // push 0xfe -> 0xfffffffe
                      0x66, 0x6a, 0x7f,             // push 0x7f -> 0x0000007f
                      0x66, 0x9d,                   // popaf
                      0x66, 0x9d,                   // popaf
                      0x9d,                         // popf
                      0x9d,                         // popf
                      0x66, 0x9d,                   // popaf
                      0x9d,                         // popf
                      0x9d,                         // popf
                      0x60,                         // pusha
                      0x66, 0x60,                   // pushad
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x66, 0x61,                   // popad
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x61,                         // popa
                      0xb4, 0x40,                   // mov ah, 0x40 (ZF)
                      0x9e,                         // sahf
                      0x74, 0x00,                   // jz Ib .+1
                      0x75, 0x00,                   // jnz Ib .+1
                      0x0f, 0x84, 0x00, 0x00,       // jz Iv .+1
                      0x0f, 0x85, 0x00, 0x00,       // jnz Iv .+1
                      0x66, 0x0f, 0x84, 0x00, 0x00, 0x00, 0x00,  // jz Iv .+1
                      0x66, 0x0f, 0x85, 0x00, 0x00, 0x00, 0x00,  // jnz Iv .+1
                      0xb4, 0x01,                   // mov ah, 0x01 (CF)
                      0x9e,                         // sahf
                      0x72, 0x00,                   // jb Ib .+1
                      0x73, 0x00,                   // jnb Ib .+1
                      0x0f, 0x82, 0x00, 0x00,       // jb Iv .+1
                      0x0f, 0x83, 0x00, 0x00,       // jnb Iv .+1
                      0x66, 0x0f, 0x82, 0x00, 0x00, 0x00, 0x00,  // jb Iv .+1
                      0x66, 0x0f, 0x83, 0x00, 0x00, 0x00, 0x00,  // jnb Iv .+1
                      0xb4, 0x41,                   // mov ah, 0x41 (ZF-CF)
                      0x9e,                         // sahf
                      0x76, 0x00,                   // jbe Ib .+1
                      0x77, 0x00,                   // jnbe Ib .+1
                      0x0f, 0x86, 0x00, 0x00,       // jbe Iv .+1
                      0x0f, 0x87, 0x00, 0x00,       // jnbe Iv .+1
                      0x66, 0x0f, 0x86, 0x00, 0x00, 0x00, 0x00,  // jbe Iv .+1
                      0x66, 0x0f, 0x87, 0x00, 0x00, 0x00, 0x00,  // jnbe Iv .+1
                      0xb4, 0x80,                   // mov ah, 0x80 (SF)
                      0x9e,                         // sahf
                      0x78, 0x00,                   // js Ib .+1
                      0x79, 0x00,                   // jns Ib .+1
                      0x0f, 0x88, 0x00, 0x00,       // js Iv .+1
                      0x0f, 0x89, 0x00, 0x00,       // jns Iv .+1
                      0x66, 0x0f, 0x88, 0x00, 0x00, 0x00, 0x00,  // js Iv .+1
                      0x66, 0x0f, 0x89, 0x00, 0x00, 0x00, 0x00,  // jns Iv .+1
                      0xb4, 0x04,                   // mov ah, 0x04 (PF)
                      0x9e,                         // sahf
                      0x7a, 0x00,                   // jp Ib .+1
                      0x7b, 0x00,                   // jnp Ib .+1
                      0x0f, 0x8a, 0x00, 0x00,       // jp Iv .+1
                      0x0f, 0x8b, 0x00, 0x00,       // jnp Iv .+1
                      0x66, 0x0f, 0x8a, 0x00, 0x00, 0x00, 0x00,  // jp Iv .+1
                      0x66, 0x0f, 0x8b, 0x00, 0x00, 0x00, 0x00,  // jnp Iv .+1
                      0xb4, 0x80,                   // mov ah, 0x80 (SF)
                      0x9e,                         // sahf
                      0x7c, 0x00,                   // jl Ib .+1
                      0x7d, 0x00,                   // jnl Ib .+1
                      0x0f, 0x8c, 0x00, 0x00,       // jl Iv .+1
                      0x0f, 0x8d, 0x00, 0x00,       // jnl Iv .+1
                      0x66, 0x0f, 0x8c, 0x00, 0x00, 0x00, 0x00,  // jl Iv .+1
                      0x66, 0x0f, 0x8d, 0x00, 0x00, 0x00, 0x00,  // jnl Iv .+1
                      0xb4, 0xc0,                   // mov ah, 0xc0 (SF-ZF)
                      0x9e,                         // sahf
                      0x7e, 0x00,                   // jle Ib .+1
                      0x7f, 0x00,                   // jnle Ib .+1
                      0x0f, 0x8e, 0x00, 0x00,       // jle Iv .+1
                      0x0f, 0x8f, 0x00, 0x00,       // jnle Iv .+1
                      0x66, 0x0f, 0x8e, 0x00, 0x00, 0x00, 0x00,  // jle Iv .+1
                      0x66, 0x0f, 0x8f, 0x00, 0x00, 0x00, 0x00,  // jnle Iv .+1
                      0xb0, 0x80,                   // mov al, 0x80
                      0xd0, 0xc0,                   // rol al, 1
                      0x70, 0x00,                   // jo Ib .+1
                      0x71, 0x00,                   // jno Ib .+1
                      0x0f, 0x80, 0x00, 0x00,       // jo Iv .+1
                      0x0f, 0x81, 0x00, 0x00,       // jno Iv .+1
                      0x66, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00,  // jo Iv .+1
                      0x66, 0x0f, 0x81, 0x00, 0x00, 0x00, 0x00,  // jno Iv .+1
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe2, 0xfd,                   // loop .-3
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0xb9, 0x02, 0x00, 0x00, 0x00, // mov ecx, 0x00000001
                      0x66, 0x40,                   // inc eax
                      0x67, 0xe2, 0xfb,             // loop .-5
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe1, 0xfd,                   // loopz .-3
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe0, 0xfd,                   // loopnz .-3
                      0x31, 0xc0,                   // xor ax, ax
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe0, 0xfd,                   // loopnz .-3
                      0x31, 0xc0,                   // xor ax, ax
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x90,                         // nop
                      0xe1, 0xfd,                   // loopz .-3
                      0xeb, 0x00,                   // jmp .+1
                      0xe9, 0x00, 0x00,             // jmp .+1
                      0x66, 0xe9, 0x00, 0x00, 0x00, 0x00, // jmp .+1
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x0f, 0xb6, 0xc8,             // movzb cx,al
                      0x0f, 0xbe, 0xc8,             // movsb cx,al
                      0xb0, 0x8f,                   // mov al, 0x8f
                      0x0f, 0xb6, 0xc8,             // movzb cx,al
                      0x0f, 0xbe, 0xc8,             // movsb cx,al
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x66, 0x0f, 0xb6, 0xc8,       // movzb ecx,al
                      0x66, 0x0f, 0xbe, 0xc8,       // movsb ecx,al
                      0xb0, 0x8f,                   // mov al, 0x8f
                      0x66, 0x0f, 0xb6, 0xc8,       // movzb ecx,al
                      0x66, 0x0f, 0xbe, 0xc8,       // movsb ecx,al
                      0xb8, 0x00, 0x7f,             // mov ax, 0x7f00
                      0x0f, 0xb7, 0xc8,             // movzw cx,ax
                      0x0f, 0xbf, 0xc8,             // movsw cx,ax
                      0xb8, 0x00, 0x8f,             // mov ax, 0x8f00
                      0x66, 0x0f, 0xb7, 0xc8,       // movzw ecx,ax
                      0x66, 0x0f, 0xbf, 0xc8,       // movsw ecx,ax
                      0xb8, 0x55, 0xaa,             // mov ax, 0xaa55
                      0x8e, 0xe0,                   // mov fs, ax
                      0x8c, 0xe1,                   // mov cx, fs
                      0x8e, 0xe9,                   // mov gs, cx
                      0x68, 0xef, 0xfe,             // push 0xfeef
                      0x68, 0x11, 0x11,             // push 0x1111
                      0x66, 0x68, 0xef, 0xfe, 0xef, 0xfe, // push 0xfeeffeef
                      0x66, 0x8f, 0xc1,             // pop ecx
                      0x8f, 0xc1,                   // pop cx
                      0x8f, 0xc2,                   // pop dx
                      0xb0, 0x03,                   // mov al, 0x03
                      0xb1, 0x05,                   // mov cl, 0x05
                      0xf6, 0xe1,                   // mul al, cl
                      0xb0, 0xff,                   // mov al, 0xff
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xe1,                   // mul al, cl
                      0xb8, 0x03, 0x00,             // mov ax, 0x03
                      0xb9, 0x05, 0x00,             // mov cx, 0x05
                      0xf7, 0xe1,                   // mul ax, cx
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0xf7, 0xe1,                   // mul ax, cx
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0xb9, 0x05, 0x00, 0x00, 0x00, // mov ecx, 0x00000005
                      0x66, 0xf7, 0xe1,             // mul eax, ecx
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xe1,             // mul eax, ecx
                      0xb0, 0x03,                   // mov al, 0x03
                      0xb1, 0x05,                   // mov cl, 0x05
                      0xf6, 0xe9,                   // imul al, cl
                      0xb0, 0xff,                   // mov al, 0xff
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xe9,                   // imul al, cl
                      0xb8, 0x03, 0x00,             // mov ax, 0x03
                      0xb9, 0x05, 0x00,             // mov cx, 0x05
                      0xf7, 0xe9,                   // imul ax, cx
                      0xb8, 0xff, 0xff,             // mov ax, 0xffff
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0xf7, 0xe9,                   // imul ax, cx
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0xf7, 0xe9,                   // imul ax, cx
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0xb9, 0x05, 0x00, 0x00, 0x00, // mov ecx, 0x00000005
                      0x66, 0xf7, 0xe9,             // imul eax, ecx
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xe9,             // imul eax, ecx
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x6b, 0xc8, 0x05,             // imul cx, ax, 0x05
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0x6b, 0xc8, 0x10,             // imul cx, ax, 0x10
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0x6b, 0xc8, 0x10,             // imul cx, ax, 0x10
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0x6b, 0xc8, 0xf0,             // imul cx, ax, 0xf0
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0x6b, 0xc8, 0x05,             // imul ecx, eax, 0x05
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0x6b, 0xc8, 0x10,             // imul ecx, eax, 0x10
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0x6b, 0xc8, 0x10,             // imul ecx, eax, 0x10
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x10, // mov eax, 0x1000
                      0x66, 0x6b, 0xc8, 0xf0,             // imul ecx, eax, 0xf0
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x69, 0xc8, 0x05, 0x00,       // imul cx, ax, 0x0005
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0x69, 0xc8, 0x10, 0x00,       // imul cx, ax, 0x0010
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0x69, 0xc8, 0x10, 0x00,       // imul cx, ax, 0x0010
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0x69, 0xc8, 0x00, 0xf0,       // imul cx, ax, 0xf000
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0x69, 0xc8, 0x05, 0x00, 0x00, 0x00, // imul ecx, eax, 0x00000005
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0x69, 0xc8, 0x10, 0x00, 0x00, 0x00, // imul ecx, eax, 0x00000010
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0x69, 0xc8, 0x10, 0x00, 0x00, 0x00, // imul ecx, eax, 0x00000010
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x10, // mov eax, 0x10000000
                      0x66, 0x69, 0xc8, 0xf0, 0xff, 0xff, 0xff, // imul ecx, eax, 0xfffffff0
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0xb9, 0x05, 0x00,             // mov cx, 0x0005
                      0x0f, 0xaf, 0xc8,             // imul cx, ax
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0x0f, 0xaf, 0xc8,             // imul cx,ax
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0x0f, 0xaf, 0xc8,             // imul cx,ax
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0xb9, 0x00, 0xf0,             // mov cx, 0xf000
                      0x0f, 0xaf, 0xc8,             // imul cx,ax
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0xb9, 0x05, 0x00, 0x00, 0x00, // mov ecx, 0x00000005
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x10, // mov eax, 0x10000000
                      0x66, 0xb9, 0xf0, 0xff, 0xff, 0xff, // mov ecx, 0xfffffff0
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0xb1, 0xfe,                   // mov cl, 0xfe
                      0xfe, 0xc1,                   // inc cl
                      0xfe, 0xc1,                   // inc cl
                      0xfe, 0xc9,                   // dec cl
                      0xfe, 0xc9,                   // dec cl
                      0xb9, 0xfe, 0xff,             // mov cx, 0xfffe
                      0xff, 0xc1,                   // inc cx
                      0xff, 0xc1,                   // inc cx
                      0xff, 0xc9,                   // dec cx
                      0xff, 0xc9,                   // dec cx
                      0x66, 0xb9, 0xfe, 0xff, 0xff, 0xff, // mov ecx, 0xfffffffe
                      0x66, 0xff, 0xc1,             // inc ecx
                      0x66, 0xff, 0xc1,             // inc ecx
                      0x66, 0xff, 0xc9,             // dec ecx
                      0x66, 0xff, 0xc9,             // dec ecx
                      0xff, 0xf2,                   // push dx
                      0x8f, 0xc3,                   // pop bx
                      0x66, 0xff, 0xf5,             // push ebp
                      0x66, 0x8f, 0xc6,             // pop esi
                      0xb8, 0x7f, 0x00,             // mov ax, 0x007f
                      0xb1, 0x04,                   // mov cl, 0x04
                      0xf6, 0xf1,                   // div ah:al, cl
                      0xb8, 0x80, 0x00,             // mov ax, 0x0080
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xf1,                   // div ah:al, cl
                      0xb8, 0x0f, 0x7f,             // mov ax, 0x7f0f
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xb9, 0x04, 0x00,             // mov cx, 0x04
                      0xf7, 0xf1,                   // div dx:ax, cx
                      0xb8, 0x00, 0x80,             // mov ax, 0x8000
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xb9, 0x10, 0x00,             // mov cx, 0x10
                      0xf7, 0xf1,                   // div dx:ax, cx
                      0x66, 0xb8, 0x0f, 0x00, 0x00, 0x7f, // mov eax, 0x7f00000f
                      0x66, 0xba, 0x00, 0x00, 0x00, 0x00, // mov edx, 0x00000000
                      0x66, 0xb9, 0x04, 0x00, 0x00, 0x00, // mov ecx, 0x00000004
                      0x66, 0xf7, 0xf1,                   // div edx:eax, ecx
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x80, // mov eax, 0x80000000
                      0x66, 0xba, 0x00, 0x00, 0x00, 0x00, // mov edx, 0x00000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xf1,                   // div edx:eax, ecx
                      0xb8, 0x7f, 0x00,             // mov ax, 0x007f
                      0xb1, 0x04,                   // mov cl, 0x04
                      0xf6, 0xf9,                   // idiv ah:al, cl
                      0xb8, 0x81, 0xff,             // mov ax, 0xff81
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xf9,                   // idiv ah:al, cl
                      0xb8, 0x0f, 0x7f,             // mov ax, 0x7f0f
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xb9, 0x04, 0x00,             // mov cx, 0x04
                      0xf7, 0xf9,                   // idiv dx:ax, cx
                      0xb8, 0x01, 0x80,             // mov ax, 0x8001
                      0xba, 0xff, 0xff,             // mov dx, 0xffff
                      0xb9, 0x10, 0x00,             // mov cx, 0x10
                      0xf7, 0xf9,                   // idiv dx:ax, cx
                      0x66, 0xb8, 0x0f, 0x00, 0x00, 0x7f, // mov eax, 0x7f00000f
                      0x66, 0xba, 0x00, 0x00, 0x00, 0x00, // mov edx, 0x00000000
                      0x66, 0xb9, 0x04, 0x00, 0x00, 0x00, // mov ecx, 0x00000004
                      0x66, 0xf7, 0xf9,                   // idiv edx:eax, ecx
                      0x66, 0xb8, 0x01, 0x00, 0x00, 0x80, // mov eax, 0x80000001
                      0x66, 0xba, 0xff, 0xff, 0xff, 0xff, // mov edx, 0xffffffff
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xf9,                   // idiv edx:eax, ecx
                      0x66, 0xb8, 0x05, 0x50, 0x0a, 0xa0, // mov eax, 0xa00a5005
                      0xa2, 0x00, 0x00,             // mov 0x0000, al
                      0x67, 0xa2, 0x04, 0x00, 0x00, 0x00, // mov 0x00000004, al
                      0xa3, 0x08, 0x00,             // mov 0x0008, ax
                      0x67, 0xa3, 0x0c, 0x00, 0x00, 0x00, // mov 0x0000000c, ax
                      0x66, 0xa3, 0x10, 0x00,             // mov 0x0010, eax
                      0x66, 0x67, 0xa3, 0x14, 0x00, 0x00, 0x00, // mov 0x00000014, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0xa0, 0x00, 0x00,             // mov al, ds:0x0000
                      0xb0, 0x00,                   // mov al, 0x00
                      0x67, 0xa0, 0x04, 0x00, 0x00, 0x00, // al, mov ds:0x00000004
                      0xb0, 0x00,                   // mov al, 0x00
                      0xa1, 0x08, 0x00,             // mov ax, ds:0x0008
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0x67, 0xa1, 0x0c, 0x00, 0x00, 0x00, // mov ax, ds:0x0000000c
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0x66, 0xa1, 0x10, 0x00,       // mov eax, ds:0x0010
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0x67, 0xa1, 0x14, 0x00, 0x00, 0x00, // eax, ds:mov 0x00000014
                      0x66, 0xb9, 0x00, 0x00, 0x10, 0x10, // mov ecx, 0x10100000
                      0xe3, 0x00,                   // jcxz .+1
                      0xb9, 0x01, 0x01,             // mov cx, 0x0101
                      0xe3, 0x00,                   // jcxz .+1
                      0x66, 0xe3, 0x00,             // jecxz .+1
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x00, // mov ecx, 0x00000000
                      0x66, 0xe3, 0x00,             // jecxz .+1
                      0xb8, 0x01, 0x00,             // mov ax, 0x0001
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0xba, 0x03, 0x00,             // mov dx, 0x0003
                      0xbb, 0x04, 0x00,             // mov bx, 0x0004
                      0xbd, 0x06, 0x00,             // mov bp, 0x0006
                      0xbe, 0x07, 0x00,             // mov si, 0x0007
                      0xbf, 0x08, 0x00,             // mov di, 0x0008
                      0x66, 0x8d, 0x80, 0x10, 0x10, // lea eax,[bx + si + 0x1010]
                      0x66, 0x8d, 0x81, 0x10, 0x10, // lea eax,[bx + di + 0x1010]
                      0x66, 0x8d, 0x82, 0x10, 0x10, // lea eax,[bp + si + 0x1010]
                      0x66, 0x8d, 0x83, 0x10, 0x10, // lea eax,[bp + di + 0x1010]
                      0x66, 0x8d, 0x84, 0x10, 0x10, // lea eax,[si + 0x1010]
                      0x66, 0x8d, 0x85, 0x10, 0x10, // lea eax,[di + 0x1010]
                      0x66, 0x8d, 0x86, 0x10, 0x10, // lea eax,[bp + 0x1010]
                      0x66, 0x8d, 0x87, 0x10, 0x10, // lea eax,[bx + 0x1010]
                      0x66, 0x8d, 0x40, 0x10,       // lea eax,[bx + si + 0x10]
                      0x66, 0x8d, 0x41, 0x10,       // lea eax,[bx + di + 0x10]
                      0x66, 0x8d, 0x42, 0x10,       // lea eax,[bp + si + 0x10]
                      0x66, 0x8d, 0x43, 0x10,       // lea eax,[bp + di + 0x10]
                      0x66, 0x8d, 0x44, 0x10,       // lea eax,[si + 0x10]
                      0x66, 0x8d, 0x45, 0x10,       // lea eax,[di + 0x10]
                      0x66, 0x8d, 0x46, 0x10,       // lea eax,[bp + 0x10]
                      0x66, 0x8d, 0x47, 0x10,       // lea eax,[bx + 0x10]
                      0x66, 0x8d, 0x00,             // lea eax,[bx + si]
                      0x66, 0x8d, 0x01,             // lea eax,[bx + di]
                      0x66, 0x8d, 0x02,             // lea eax,[bp + si]
                      0x66, 0x8d, 0x03,             // lea eax,[bp + di]
                      0x66, 0x8d, 0x04,             // lea eax,[si]
                      0x66, 0x8d, 0x05,             // lea eax,[di]
                      0x66, 0x8d, 0x06, 0xff, 0xee, // lea eax,[0xffee]
                      0x66, 0x8d, 0x07,             // lea eax,[bx]
                      0x8d, 0x80, 0x10, 0x10,       // lea ax,[bx + si + 0x1010]
                      0x8d, 0x81, 0x10, 0x10,       // lea ax,[bx + di + 0x1010]
                      0x8d, 0x82, 0x10, 0x10,       // lea ax,[bp + si + 0x1010]
                      0x8d, 0x83, 0x10, 0x10,       // lea ax,[bp + di + 0x1010]
                      0x8d, 0x84, 0x10, 0x10,       // lea ax,[si + 0x1010]
                      0x8d, 0x85, 0x10, 0x10,       // lea ax,[di + 0x1010]
                      0x8d, 0x86, 0x10, 0x10,       // lea ax,[bp + 0x1010]
                      0x8d, 0x87, 0x10, 0x10,       // lea ax,[bx + 0x1010]
                      0x8d, 0x40, 0x10,             // lea ax,[bx + si + 0x10]
                      0x8d, 0x41, 0x10,             // lea ax,[bx + di + 0x10]
                      0x8d, 0x42, 0x10,             // lea ax,[bp + si + 0x10]
                      0x8d, 0x43, 0x10,             // lea ax,[bp + di + 0x10]
                      0x8d, 0x44, 0x10,             // lea ax,[si + 0x10]
                      0x8d, 0x45, 0x10,             // lea ax,[di + 0x10]
                      0x8d, 0x46, 0x10,             // lea ax,[bp + 0x10]
                      0x8d, 0x47, 0x10,             // lea ax,[bx + 0x10]
                      0x8d, 0x00,                   // lea ax,[bx + si]
                      0x8d, 0x01,                   // lea ax,[bx + di]
                      0x8d, 0x02,                   // lea ax,[bp + si]
                      0x8d, 0x03,                   // lea ax,[bp + di]
                      0x8d, 0x04,                   // lea ax,[si]
                      0x8d, 0x05,                   // lea ax,[di]
                      0x8d, 0x06, 0xff, 0xee,       // lea ax,[0xffee]
                      0x8d, 0x07,                   // lea ax,[bx]
                      0xb8, 0x01, 0x00,             // mov ax, 0x0001
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0xba, 0x03, 0x00,             // mov dx, 0x0003
                      0xbb, 0x04, 0x00,             // mov bx, 0x0004
                      0xbd, 0x06, 0x00,             // mov bp, 0x0006
                      0xbe, 0x07, 0x00,             // mov si, 0x0007
                      0xbf, 0x08, 0x00,             // mov di, 0x0008
                      0x67, 0x8d, 0x00,             // lea ax,[eax]
                      0x67, 0x8d, 0x01,             // lea ax,[ecx]
                      0x67, 0x8d, 0x02,             // lea ax,[edx]
                      0x67, 0x8d, 0x03,             // lea ax,[ebx]
                      0x67, 0x8d, 0x05, 0xff, 0xee, 0xdd, 0xcc, // lea ax,[0xccddeeff]
                      0x67, 0x8d, 0x06,             // lea ax,[esi]
                      0x67, 0x8d, 0x07,             // lea ax,[edi]
                      0x67, 0x8d, 0x40, 0x10,       // lea ax,[eax + 0x10]
                      0x67, 0x8d, 0x41, 0x10,       // lea ax,[ecx + 0x10]
                      0x67, 0x8d, 0x42, 0x10,       // lea ax,[edx + 0x10]
                      0x67, 0x8d, 0x43, 0x10,       // lea ax,[ebx + 0x10]
                      0x67, 0x8d, 0x45, 0x10,       // lea ax,[ebp + 0x10]
                      0x67, 0x8d, 0x46, 0x10,       // lea ax,[esi + 0x10]
                      0x67, 0x8d, 0x47, 0x10,       // lea ax,[edi + 0x10]
                      0x67, 0x8d, 0x80, 0x10, 0x10, 0x10, 0x10, // lea ax,[eax + 0x10101010]
                      0x67, 0x8d, 0x81, 0x10, 0x10, 0x10, 0x10, // lea ax,[ecx + 0x10101010]
                      0x67, 0x8d, 0x82, 0x10, 0x10, 0x10, 0x10, // lea ax,[edx + 0x10101010]
                      0x67, 0x8d, 0x83, 0x10, 0x10, 0x10, 0x10, // lea ax,[ebx + 0x10101010]
                      0x67, 0x8d, 0x85, 0x10, 0x10, 0x10, 0x10, // lea ax,[ebp + 0x10101010]
                      0x67, 0x8d, 0x86, 0x10, 0x10, 0x10, 0x10, // lea ax,[esi + 0x10101010]
                      0x67, 0x8d, 0x87, 0x10, 0x10, 0x10, 0x10, // lea ax,[edi + 0x10101010]
                      0x66, 0x67, 0x8d, 0x00,       // lea eax,[eax]
                      0x66, 0x67, 0x8d, 0x01,       // lea eax,[ecx]
                      0x66, 0x67, 0x8d, 0x02,       // lea eax,[edx]
                      0x66, 0x67, 0x8d, 0x03,       // lea eax,[ebx]
                      0x66, 0x67, 0x8d, 0x05, 0x10, 0x10, 0x10, 0x10, // lea eax,[0x10101010]
                      0x66, 0x67, 0x8d, 0x06,       // lea eax,[esi]
                      0x66, 0x67, 0x8d, 0x07,       // lea eax,[edi]
                      0x66, 0x67, 0x8d, 0x40, 0x10, // lea eax,[eax + 0x10]
                      0x66, 0x67, 0x8d, 0x41, 0x10, // lea eax,[ecx + 0x10]
                      0x66, 0x67, 0x8d, 0x42, 0x10, // lea eax,[edx + 0x10]
                      0x66, 0x67, 0x8d, 0x43, 0x10, // lea eax,[ebx + 0x10]
                      0x66, 0x67, 0x8d, 0x45, 0x10, // lea eax,[ebp + 0x10]
                      0x66, 0x67, 0x8d, 0x46, 0x10, // lea eax,[esi + 0x10]
                      0x66, 0x67, 0x8d, 0x47, 0x10, // lea eax,[edi + 0x10]
                      0x66, 0x67, 0x8d, 0x80, 0x10, 0x10, 0x10, 0x10, // lea eax,[eax + 0x10101010]
                      0x66, 0x67, 0x8d, 0x81, 0x10, 0x10, 0x10, 0x10, // lea eax,[ecx + 0x10101010]
                      0x66, 0x67, 0x8d, 0x82, 0x10, 0x10, 0x10, 0x10, // lea eax,[edx + 0x10101010]
                      0x66, 0x67, 0x8d, 0x83, 0x10, 0x10, 0x10, 0x10, // lea eax,[ebx + 0x10101010]
                      0x66, 0x67, 0x8d, 0x85, 0x10, 0x10, 0x10, 0x10, // lea eax,[ebp + 0x10101010]
                      0x66, 0x67, 0x8d, 0x86, 0x10, 0x10, 0x10, 0x10, // lea eax,[esi + 0x10101010]
                      0x66, 0x67, 0x8d, 0x87, 0x10, 0x10, 0x10, 0x10, // lea eax,[edi + 0x10101010]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x80,       // lea ax,[eax + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x81,       // lea ax,[ecx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x82,       // lea ax,[edx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x83,       // lea ax,[ebx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x84,       // lea ax,[esp + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x85, 0x10, 0x10, 0x10, 0x10, // lea ax,[0x10101010 + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x86,       // lea ax,[esi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x87,       // lea ax,[edi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x80,       // lea eax,[eax + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x81,       // lea eax,[ecx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x82,       // lea eax,[edx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x83,       // lea eax,[ebx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x84,       // lea eax,[esp + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x85, 0x10, 0x10, 0x10, 0x10, // lea eax,[0x10101010 + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x86,       // lea eax,[esi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x87,       // lea eax,[edi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x80, 0x10, // lea eax,[eax + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x81, 0x10, // lea eax,[ecx + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x82, 0x10, // lea eax,[edx + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x83, 0x10, // lea eax,[ebx + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x84, 0x10, // lea eax,[esp + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x85, 0x10, // lea eax,[ebp + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x86, 0x10, // lea eax,[esi + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x87, 0x10, // lea eax,[edi + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x80, 0x10, 0x00, 0x00, 0x10, // lea eax,[eax + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x81, 0x10, 0x00, 0x00, 0x10, // lea eax,[ecx + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x82, 0x10, 0x00, 0x00, 0x10, // lea eax,[edx + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x83, 0x10, 0x00, 0x00, 0x10, // lea eax,[ebx + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x84, 0x10, 0x00, 0x00, 0x10, // lea eax,[esp + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x85, 0x10, 0x00, 0x00, 0x10, // lea eax,[ebp + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x86, 0x10, 0x00, 0x00, 0x10, // lea eax,[esi + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x87, 0x10, 0x00, 0x00, 0x10, // lea eax,[edi + eax * 2 + 0x10000010]
                      0x90,                         // nop
                      0xfc,                         // cld
                      0xbe, 0x00, 0x00,             // mov si, 0x0000
                      0xbf, 0x02, 0x00,             // mov di, 0x0002
                      0xa4,                         // movsb
                      0x66, 0xb8, 0xaa, 0x55, 0xf0, 0x0f, // mov eax, 0x0ff055aa
                      0xbf, 0x00, 0x00,             // mov di, 0x0000
                      0xaa,                         // stosb
                      0xaa,                         // stosb
                      0xab,                         // stosw
                      0x66, 0xab,                   // stosd
                      0xb9, 0x04, 0x00,             // mov cx, 0x0004
                      0xf3, 0x66, 0xab,             // rep stosd
                      0x66, 0xb8, 0x5a, 0xa5, 0x00, 0xff, // mov eax, 0x0ff055aa
                      0xb9, 0x06, 0x00,             // mov cx, 0x0006
                      0xbf, 0x2c, 0x00,             // mov di, 0x002c
                      0xfd,                         // std
                      0xf3, 0x66, 0xab,             // rep stosd
                      0xc8, 0x00, 0x02, 0x00,       // enter 0x0200, 0x00
                      0xc9,                         // leave
                      0xc8, 0x00, 0x02, 0x01,       // enter 0x0200, 0x01
                      0xc9,                         // leave
                      0x66, 0xc8, 0x00, 0x02, 0x00, // enter 0x0200, 0x00
                      0x66, 0xc9,                   // leave
                      0x66, 0xc8, 0x00, 0x02, 0x01, // enter 0x0200, 0x01
                      0x66, 0xc9,                   // leave
                      0x66, 0xb8, 0x02, 0x00, 0xfe, 0xfe, // mov eax, 0xfefe0002
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0xc4, 0x06, 0x04, 0x00,       // les ax,d:0x0004
                      0x0f, 0xb4, 0x0e, 0x04, 0x00, // lfs cx,d:0x0004
                      0x0f, 0xb5, 0x16, 0x04, 0x00, // lgs dx,d:0x0004
                      0x66, 0xc4, 0x1e, 0x04, 0x00, // les ebx,d:0x0004
                      0x66, 0x0f, 0xb4, 0x36, 0x04, 0x00, // lfs esi,d:0x0004
                      0x66, 0x0f, 0xb5, 0x3e, 0x04, 0x00, // lgs edi,d:0x0004
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0x27,                         // daa
                      0x2f,                         // das
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xb8, 0x05, 0x00,             // mov ax, 0x0005
                      0xb9, 0x20, 0x00,             // mov cx, 0x0020
                      0xf8,                         // clc
                      0x0f, 0xa3, 0xc1,             // bt cx, ax
                      0xf8,                         // clc
                      0x0f, 0xb3, 0xc1,             // btr cx, ax
                      0xf9,                         // stc
                      0x0f, 0xab, 0xc1,             // bts cx, ax
                      0xf8,                         // clc
                      0x0f, 0xbb, 0xc1,             // btc cx, ax
                      0x66, 0xb8, 0x15, 0x00, 0x00, 0x00, // mov eax, 0x00000015
                      0x66, 0xb9, 0x00, 0x00, 0x20, 0x00, // mov ecx, 0x00200000
                      0xf8,                         // clc
                      0x66, 0x0f, 0xa3, 0xc1,       // bt ecx, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xb3, 0xc1,       // btr ecx, eax
                      0xf9,                         // stc
                      0x66, 0x0f, 0xab, 0xc1,       // bts ecx, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xbb, 0xc1,       // btc ecx, eax
                      0xb9, 0x20, 0x00,             // mov cx, 0x0020
                      0xf8,                         // clc
                      0x0f, 0xba, 0xe1, 0x05,       // bt cx, 0x05
                      0xf8,                         // clc
                      0x0f, 0xba, 0xf1, 0x05,       // btr cx, 0x05
                      0xf9,                         // stc
                      0x0f, 0xba, 0xe9, 0x05,       // bts cx, 0x05
                      0xf8,                         // clc
                      0x0f, 0xba, 0xf9, 0x05,       // btc cx, 0x05
                      0x66, 0xb9, 0x00, 0x00, 0x20, 0x00, // mov ecx, 0x00200000
                      0xf8,                         // clc
                      0x66, 0x0f, 0xba, 0xe1, 0x15, // bt ecx, 0x15
                      0xf8,                         // clc
                      0x66, 0x0f, 0xba, 0xf1, 0x15, // btr ecx, 0x15
                      0xf9,                         // stc
                      0x66, 0x0f, 0xba, 0xe9, 0x15, // bts ecx, 0x15
                      0xf8,                         // clc
                      0x66, 0x0f, 0xba, 0xf9, 0x15, // btc ecx, 0x15
                      0x66, 0xb8, 0x20, 0x00, 0x00, 0x00, // mov eax, 0x00000020
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0xb8, 0x45, 0x00,             // mov ax, 0x0045
                      0xf8,                         // clc
                      0x0f, 0xa3, 0x06, 0x00, 0x00, // bt ds:0x0000, ax
                      0xf8,                         // clc
                      0x0f, 0xb3, 0x06, 0x00, 0x00, // btr ds:0x0000, ax
                      0xf9,                         // stc
                      0x0f, 0xab, 0x06, 0x00, 0x00, // bts ds:0x0000, ax
                      0xf8,                         // clc
                      0x0f, 0xbb, 0x06, 0x00, 0x00, // btc ds:0x0000, ax
                      0x66, 0xb8, 0x00, 0x00, 0x20, 0x00, // mov eax, 0x00200000
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0x66, 0xb8, 0x55, 0x00, 0x00, 0x00, // mov eax, 0x00000055
                      0xf8,                         // clc
                      0x66, 0x0f, 0xa3, 0x06, 0x00, 0x00, // bt ds:0x0000, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xb3, 0x06, 0x00, 0x00, // btr ds:0x0000, eax
                      0xf9,                         // stc
                      0x66, 0x0f, 0xab, 0x06, 0x00, 0x00, // bts ds:0x0000, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xbb, 0x06, 0x00, 0x00, // btc ds:0x0000, eax
                      0xb8, 0xab, 0xab,             // mov ax, 0xabab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0xba, 0xfe, 0xfe,             // mov dx, 0xfefe
                      0x0f, 0xa4, 0xc2, 0x04,       // shld dx, ax, 0x04
                      0x0f, 0xa5, 0xc2,             // shld dx, ax, cl
                      0x66, 0xb8, 0xab, 0xab, 0xa5, 0x5a, // mov eax, 0x5aa5abab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0x66, 0xba, 0xfe, 0xfe, 0x12, 0x21, // mov edx, 0x2112fefe
                      0x66, 0x0f, 0xa4, 0xc2, 0x04, // shld edx, eax, 0x04
                      0x66, 0x0f, 0xa5, 0xc2,       // shld edx, eax, cl
                      0xb8, 0xab, 0xab,             // mov ax, 0xabab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0xba, 0xfe, 0xfe,             // mov dx, 0xfefe
                      0x0f, 0xac, 0xd0, 0x04,       // shld ax, dx, 0x04
                      0x0f, 0xad, 0xd0,             // shld ax, dx, cl
                      0x66, 0xb8, 0xab, 0xab, 0xa5, 0x5a, // mov eax, 0x5aa5abab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0x66, 0xba, 0xfe, 0xfe, 0x12, 0x21, // mov edx, 0x2112fefe
                      0x66, 0x0f, 0xac, 0xd0, 0x04, // shld eax, edx, 0x04
                      0x66, 0x0f, 0xad, 0xd0,       // shld eax, edx, cl
                      0xb0, 0xaa,                   // mov al, 0xaa
                      0xc0, 0xe0, 0x02,             // shl al, 0x02
                      0xb0, 0xaa,                   // mov al, 0xaa
                      0xc0, 0xe8, 0x03,             // shl al, 0x03
                      0xb0, 0xaa,                   // mov al, 0xaa
                      0xc0, 0xf8, 0x04,             // shl al, 0x04
//                      0xe8, 0x02, 0x00,             // call 0x0002
                      0x9a, 0x03, 0x00, 0x00, 0x20, // call 0x0003:0x2000
//                      0x66, 0xe8, 0x04, 0x00, 0x00, 0x00, // call 0x00000004
                      0x66, 0x9a, 0x06, 0x00, 0x00, 0x00, 0x00, 0x20, // call 0x00000006:0x2000
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x20, // mov eax, 0x20000002
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x16, 0x04, 0x00,       // call ds:0x0004
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x20, // mov eax, 0x20000003
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x1e, 0x04, 0x00,       // call ds:0x0004
                      0xb8, 0xaa, 0xaa,             // mov ax, 0xaaaa
                      0xc1, 0xe0, 0x02,             // shl ax, 0x02
                      0xb8, 0xaa, 0xaa,             // mov ax, 0xaaaa
                      0xc1, 0xe8, 0x03,             // shl ax, 0x03
                      0xb8, 0xaa, 0xaa,             // mov ax, 0xaaaa
                      0xc1, 0xf8, 0x04,             // shl ax, 0x04
                      0x66, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, // mov eax, 0xaaaaaaaa
                      0x66, 0xc1, 0xe0, 0x02,       // shl eax, 0x02
                      0x66, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, // mov eax, 0xaaaaaaaa
                      0x66, 0xc1, 0xe8, 0x03,       // shl eax, 0x03
                      0x66, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, // mov eax, 0xaaaaaaaa
                      0x66, 0xc1, 0xf8, 0x04,       // shl eax, 0x04
                      0xf0, 0x90,                   // lock nop
                      0x66, 0xb8, 0x12, 0x34, 0x56, 0x78, // mov eax, 0x78563412
                      0xe6, 0x04,                   // outb 0x04, al
                      0xe7, 0x08,                   // outw 0x09, ax
                      0x66, 0xe7, 0x0c,             // outd 0x0c, eax
                      0xba, 0x40, 0x00,             // mov dx, 0x0040
                      0xee,                         // outb dx, al
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0xef,                         // outw dx, ax
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0x66, 0xef,                   // outd dx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0xe4, 0x04,                   // inb al, 0x04
                      0xe5, 0x08,                   // inw ax, 0x08
                      0x66, 0xe5, 0x0c,             // ind eax, 0x0c
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0xba, 0x40, 0x00,             // mov dx, 0x0040
                      0xec,                         // inb al, dx
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0xed,                         // inw ax, dx
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0x66, 0xed,                   // ind eax, dx
//                      0xf4,                         // hlt (nop)
                      0xb8, 0x00, 0x00,              // mov ax, 0x0000
                      0x0f,0xbc, 0xc8,              // bsf cx, ax
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0x0f,0xbc, 0xc8,              // bsf cx, ax
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0x0f,0xbd, 0xc8,              // bsr cx, ax
                      0xb8, 0x10, 0x10,             // mov ax, 0x1010
                      0x0f,0xbd, 0xc8,              // bsr cx, ax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0x0f,0xbc, 0xc8,        // bsf ecx, eax
                      0x66, 0xb8, 0x00, 0x10, 0x00, 0x00, // mov eax, 0x00001000
                      0x66, 0x0f,0xbc, 0xc8,        // bsf ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0x0f,0xbd, 0xc8,        // bsr ecx, eax
                      0x66, 0xb8, 0x10, 0x10, 0x00, 0x00, // mov eax, 0x00001010
                      0x66, 0x0f,0xbd, 0xc8,        // bsr ecx, eax
                      0xcc,                         // int 3
                      0xcd, 0x04,                   // int 0x04
                      0xcd, 0x05,                   // int 0x05
*/                      0x90,                         // nop
                      0x66, 0xb8, 0x11, 0x22, 0x33, 0x44, // mov eax, 0x44332211
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xb0, 0x01,                   // mov al, 0x01
                      0xbb, 0x03, 0x00,             // mov bx, 0x0003
                      0xd7,                         // xlat
                      0xb0, 0x02,                   // mov al, 0x01
                      0x66, 0xbb, 0x04, 0x00, 0x00, 0x00,  // mov ebx, 0x00000004
                      0x67, 0xd7,                   // xlat
                      0x66, 0xb8, 0x04, 0x00, 0x08, 0x00, // mov eax, 0x00080004
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0x66, 0xb8, 0x04, 0x00, 0x08, 0x01, // mov eax, 0x01080004
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0xb9, 0x04, 0x00,             // mov cx, 0x0004
                      0x62, 0x0e, 0x04, 0x00,       // bound cx, ds:0x0004
                      0x66, 0xb9, 0x04, 0x00, 0x08, 0x01, // mov ecx, 0x01080004
                      0x66, 0x62, 0x0e, 0x04, 0x00, // bound ecx, ds:0x0004
                      0x66, 0xb8, 0x11, 0x22, 0x33, 0x44, // mov eax, 0x44332211
                      0x0f, 0xc8, 0xc0,             // bswap ax
                      0x66, 0xb8, 0x11, 0x22, 0x33, 0x44, // mov eax, 0x44332211
                      0x66, 0x0f, 0xc8, 0xc0,       // bswap eax
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x01,                   // mov cl, 0x01
                      0xb2, 0xff,                   // mov dl, 0xff
                      0x0f, 0xb0, 0xd1,             // cmpxchg cl,dl
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x02,                   // mov cl, 0x02
                      0xb2, 0xff,                   // mov dl, 0xff
                      0x0f, 0xb0, 0xd1,             // cmpxchg cl,dl
                      0xb8, 0x01, 0x00,             // mov ax, 0x01
                      0xb9, 0x01, 0x00,             // mov cx, 0x01
                      0xba, 0xff, 0x00,             // mov dx, 0xff
                      0x0f, 0xb1, 0xd1,             // cmpxchg cx,dx
                      0xb8, 0x01, 0x00,             // mov ax, 0x01
                      0xb9, 0x02, 0x00,             // mov cx, 0x02
                      0xba, 0xff, 0x00,             // mov dx, 0xff
                      0x0f, 0xb1, 0xd1,             // cmpxchg cx,dx
                      0x66, 0xb8, 0x01, 0x00, 0x00, 0x00, // mov eax, 0x00000001
                      0x66, 0xb9, 0x01, 0x00, 0x00, 0x00, // mov ecx, 0x00000001
                      0x66, 0xba, 0xff, 0x00, 0x00, 0x00, // mov edx, 0x000000ff
                      0x66, 0x0f, 0xb1, 0xd1,             // cmpxchg ecx,edx
                      0x66, 0xb8, 0x01, 0x00, 0x00, 0x00, // mov eax, 0x00000001
                      0x66, 0xb9, 0x02, 0x00, 0x00, 0x00, // mov ecx, 0x00000002
                      0x66, 0xba, 0xff, 0x00, 0x00, 0x00, // mov edx, 0x000000ff
                      0x66, 0x0f, 0xb1, 0xd1,             // cmpxchg ecx,edx
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x02,                   // mov cl, 0x02
                      0x0f, 0xc0, 0xc8,             // xadd al,cl
                      0xb8, 0x01, 0x01,             // mov ax, 0x0101
                      0xb9, 0x02, 0x02,             // mov cx, 0x0202
                      0x0f, 0xc1, 0xc8,             // xadd ax,cx
                      0x66, 0xb8, 0x01, 0x01, 0x01, 0x01, // mov eax, 0x01010101
                      0x66, 0xb9, 0x02, 0x02, 0x02, 0x02, // mov ecx, 0x02020202
                      0x66, 0x0f, 0xc1, 0xc8,             // xadd eax,ecx
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0x27,                         // daa
                      0x2f,                         // das
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x90, 0xc0,             // seto al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x91, 0xc0,             // setno al
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x80, // mov eax, 0x80000000
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x80, // mov ecx, 0x80000000
                      0x66, 0x01, 0xc1,             // add ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x80, // mov eax, 0x80000000
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x80, // mov ecx, 0x80000000
                      0x66, 0x29, 0xc1,             // sub ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xb0, // mov eax, 0xb0000000
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x50, // mov ecx, 0x50000000
                      0x66, 0x01, 0xc1,             // add ecx, eax
                      0x66, 0xb8, 0xac, 0x08, 0x02, 0x08, // mov eax, 0x080208ac
                      0x66, 0xb9, 0x9b, 0x2a, 0xa4, 0xc8, // mov ecx, 0xc8a42a9b
                      0xf9,                         // stc
                      0x66, 0x1b, 0xc1,             // sbb eax, ecx
                      0x66, 0xb8, 0xcf, 0x33, 0xeb, 0xaf, // mov eax, 0xafeb33cf
                      0x66, 0xb9, 0x85, 0xed, 0xa5, 0xd0, // mov ecx, 0xd0a5ed85
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0xb4, 0xb3,                   // mov ah, 0xb3
                      0xb5, 0x0e,                   // mov ch, 0x0e
                      0x28, 0xe5,                   // sub ch, ah
                      0x66, 0xbf, 0x64, 0x4b, 0x7d, 0xdc, // mov edi, 0xdc7d4b64
                      0x66, 0xd1, 0xc7,             // rol edi, 1
                      0x66, 0xbe, 0xe7, 0x8b, 0x26, 0x34, // mov esi, 0x34268be7
                      0x66, 0xb9, 0x88, 0x00, 0x00, 0x00, // mov ecx, 0x00000088
                      0x66, 0xbf, 0x64, 0x4b, 0x7d, 0x8c, // mov edi, 0x8c7d4b64
                      0x66, 0xd1, 0xc7,             // rol edi, 1
                      0x66, 0x0f, 0xa4, 0xce, 0x1b, // shld esi, ecx, 0x1b
                      0x66, 0xbe, 0x98, 0x07, 0xe1, 0xeb, // mov esi, 0xebe10798
                      0x66, 0xb9, 0xa6, 0x50, 0x9b, 0xee, // mov ecx, 0xee9b50a6
                      0x66, 0xbf, 0x64, 0x4b, 0x7d, 0xdc, // mov edi, 0xdc7d4b64
                      0x66, 0xd1, 0xc7,             // rol edi, 1
                      0x66, 0x0f, 0xac, 0xce, 0x17, // shrd esi, ecx, 0x17
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb7, 0x04,                   // mov bh, 0x04
                      0x0f, 0xb0, 0xc7,             // cmpxchg bh, al
                      0xcf,                         // iret
                      0xff};

//
// Define stack storage space.
//

ULONG StackSpace[4096 / 4];
ULONG DataSpace[4096 / 4];
ULONG IoSpace[4096 / 4];

//
// Define read and write I/O space functions.
//

ULONG
ReadIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    )

{
    if (DataType == BYTE_DATA) {
        return *((UCHAR UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber));

    } else if (DataType == LONG_DATA) {
        return *((ULONG UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber));

    } else {
        return *((USHORT UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber));
    }
}

VOID
WriteIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    )

{

    if (DataType == BYTE_DATA) {
        *((UCHAR UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber)) = (UCHAR)Value;

    } else if (DataType == LONG_DATA) {
        *((ULONG UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber)) = Value;

    } else {
        *((USHORT UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber)) = (USHORT)Value;
    }

    return;
}

//
// Define address translation routine.
//

PVOID
TranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    )

{

    ULONG Value;

    //
    // Case on high hex digit of segment.
    //

    Value = Offset + (Segment << 4);
    Offset = (USHORT)Value;
    Value &= 0xf0000;
    switch ((Value >> 16) & 0xf) {

        //
        // Interrupt vector/stack space.
        //

    case 0x0:
        return (PVOID)((PUCHAR)&StackSpace + Offset);

        //
        // Data space.
        //

    case 0x1:
        return (PVOID)((PUCHAR)&DataSpace + Offset);

        //
        // Code space.
        //

    case 0x2:
        return (PVOID)((PUCHAR)&CodeStream + Offset);

        //
        // No valid translation.
        //

    default:
        return NULL;
    }
}

VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    XM86_CONTEXT Context;
    PULONG Vector = &StackSpace[0];

    //
    // Initialize the emulator.
    //

    XmInitializeEmulator(0,
                         0x1000,
                         ReadIoSpace,
                         WriteIoSpace,
                         TranslateAddress);

    //
    // Initialize vector 255 and emulate an interrupt through that
    // vector.
    //

    Vector[3] = (0x2000 << 16) | 0x0008;
    Vector[4] = (0x2000 << 16) | 0x0008;
    Vector[5] = (0x2000 << 16) | 0x0008;
    Vector[255] = (0x2000 << 16) | 0x0000;
    Context.Eax = 0;
    Context.Ecx = 0;
    Context.Edx = 0;
    Context.Ebx = 0;
    Context.Ebp = 0;
    Context.Esi = 0;
    Context.Edi = 0;
    XmContext.SegmentRegister[DS] = 0x1000;
    XmEmulateInterrupt(255, &Context);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\logops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    logops.c

Abstract:

    This module implements the code to emulate the and, or, test, xor,
    and not opcodes.

Author:

    David N. Cutler (davec) 12-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced prototypes.
//

VOID
XmSetLogicalResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

VOID
XmAndOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an and opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // And operands and store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long & P->SrcValue.Long);
    return;
}

VOID
XmOrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an or opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Or operands and store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long | P->SrcValue.Long);
    return;
}

VOID
XmTestOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a test opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // And operands but don't store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long & P->SrcValue.Long);
    return;
}

VOID
XmXorOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a xor opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Xor operands and store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long ^ P->SrcValue.Long);
    return;
}

VOID
XmNotOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a not opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Mask;
    ULONG Shift;

    //
    // Complement operand and store result.
    //

    Shift = Shift = ((P->DataType + 1) << 3) - 1;
    Mask = ((1 << Shift) - 1) | (1 << Shift);
    XmStoreResult(P, ~P->DstValue.Long & Mask);
    return;
}

VOID
XmSetLogicalResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    )

/*++

Routine Description:

    This function conditionally stores the result of a logical operation
    and computes the resultant condtion codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Result - Supplies the result value (note that the result is always
        zero extended to a long with no carry bits into the zero extended
        part).

Return Value:

    None.

--*/

{

    ULONG Shift;

    //
    // Store the result and compute auxilary carry flag, parity flag, sign
    // and zero flags.
    //

    if (P->FunctionIndex != X86_TEST_OP) {
        XmStoreResult(P, Result);
    }

    Shift = Shift = ((P->DataType + 1) << 3) - 1;
    P->Eflags.EFLAG_CF = 0;
    P->Eflags.EFLAG_PF = XmComputeParity(Result);
    P->Eflags.EFLAG_AF = 0;
    P->Eflags.EFLAG_ZF = (Result == 0);
    P->Eflags.EFLAG_SF = Result >> Shift;
    P->Eflags.EFLAG_OF = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\miscops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    miscops.c

Abstract:

    This module implements the code to emulate miscellaneous opcodes.

Author:

    David N. Cutler (davec) 22-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmBoundOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a bound opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    union {
        LONG Long;
        SHORT Word;
    } LowerBound;

    union {
        LONG Long;
        SHORT Word;
    } UpperBound;

    ULONG Offset;

    //
    // Get lower and upper bounds and check index against index value.
    //

    Offset = P->SrcValue.Long;
    XmSetSourceValue(P, XmGetOffsetAddress(P, Offset));
    LowerBound.Long = P->SrcValue.Long;
    XmSetSourceValue(P, XmGetOffsetAddress(P, Offset + P->DataType + 1));
    UpperBound.Long = P->SrcValue.Long;
    if (P->DataType == LONG_DATA) {
        if (((LONG)(*P->DstLong) < LowerBound.Long) ||
            ((LONG)(*P->DstLong) > (UpperBound.Long + (LONG)(P->DataType + 1)))) {
            longjmp(&P->JumpBuffer[0], XM_INDEX_OUT_OF_BOUNDS);
        }

    } else {
        if (((SHORT)(*P->DstWord) < LowerBound.Word) ||
            ((SHORT)(*P->DstWord) > (UpperBound.Word + (SHORT)(P->DataType + 1)))) {
            longjmp(&P->JumpBuffer[0], XM_INDEX_OUT_OF_BOUNDS);
        }
    }

    return;
}

VOID
XmBswapOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a bswap opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Result;

    //
    // Swap bytes and set result value.
    //

    Result = (P->SrcValue.Long << 24) | ((P->SrcValue.Long & 0xff00) << 8) |
             (P->SrcValue.Long >> 24) | ((P->SrcValue.Long >> 8) & 0xff00);

    XmStoreResult(P, Result);
    return;
}

VOID
XmIllOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an illegal opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Raise an illegal opcode exception.
    //

    longjmp(&P->JumpBuffer[0], XM_ILLEGAL_INSTRUCTION_OPCODE);
    return;
}

VOID
XmNopOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a nop opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\moveops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    movops.c

Abstract:

    This module implements the code to emulate the move and exchange
    opcodes.

Author:

    David N. Cutler (davec) 22-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmCbwOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cbw opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Sign extend byte to word or word to double.
    //

    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        XmStoreResult(P, (ULONG)((LONG)((SHORT)P->Gpr[AX].Xx)));

    } else {
        P->DataType = WORD_DATA;
        XmStoreResult(P, (ULONG)((USHORT)((SCHAR)P->Gpr[AL].Xl)));
    }

    return;
}

VOID
XmCwdOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cwd opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Sign extend word to double or double to quad.
    //

    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EDX].Exx);
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        XmStoreResult(P, (ULONG)((LONG)P->Gpr[EAX].Exx >> 31));

    } else {
        P->DataType = WORD_DATA;
        XmStoreResult(P, (ULONG)((USHORT)((SHORT)P->Gpr[AX].Xx >> 16)));
    }

    return;
}

VOID
XmMovOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a move general opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Move source to destination.
    //

    XmStoreResult(P, P->SrcValue.Long);
    return;
}

VOID
XmXchgOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a xchg opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Exchange source with destination.
    //

    if (P->DataType == BYTE_DATA) {
        *P->SrcByte = P->DstValue.Byte;

    } else if (P->DataType == LONG_DATA) {
        *P->SrcLong = P->DstValue.Long;

    } else {
        *P->SrcWord = P->DstValue.Word;
    }

    XmStoreResult(P, P->SrcValue.Long);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\mulops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mulops.c

Abstract:

    This module implements the code to emulate the mul and imul opcodes.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmImulOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an imul opcode with a single destination.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    LARGE_INTEGER Product;
    ULONG UpperEqual;

    //
    // Multiply the signed operands and store result.
    //

    if (P->DataType == BYTE_DATA) {
        Product.QuadPart = Int32x32To64((LONG)((SCHAR)P->DstValue.Byte),
                                        (LONG)((SCHAR)P->SrcValue.Byte));

        XmStoreResult(P, Product.LowPart & 0xff);
        UpperEqual = ((UCHAR)((Product.LowPart >> 8) & 0xff) !=
                      (UCHAR)((SCHAR)Product.LowPart >> 7));

    } else if (P->DataType == LONG_DATA) {
        Product.QuadPart = Int32x32To64((LONG)P->DstValue.Long,
                                        (LONG)P->SrcValue.Long);

        XmStoreResult(P, Product.LowPart);
        UpperEqual = (Product.HighPart != (LONG)Product.LowPart >> 31);

    } else {
        Product.QuadPart = Int32x32To64((LONG)((SHORT)P->DstValue.Word),
                                        (LONG)((SHORT)P->SrcValue.Word));

        XmStoreResult(P, Product.LowPart & 0xffff);
        UpperEqual = ((USHORT)((Product.LowPart >> 16) & 0xffff) !=
                      (USHORT)((SHORT)Product.LowPart >> 15));
    }

    P->Eflags.EFLAG_CF = UpperEqual;
    P->Eflags.EFLAG_OF = UpperEqual;
    return;
}

VOID
XmImulxOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an imul opcode with an extended destination.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    LARGE_INTEGER Product;
    ULONG UpperEqual;

    //
    // Multiply the signed operands and store the result and the extended
    // result.
    //

    if (P->DataType == BYTE_DATA) {
        Product.QuadPart = Int32x32To64((LONG)((SCHAR)P->DstValue.Byte),
                                        (LONG)((SCHAR)P->SrcValue.Byte));

        P->DataType = WORD_DATA;
        XmStoreResult(P, Product.LowPart & 0xffff);
        UpperEqual = (P->Gpr[AX].Xh != (UCHAR)((SCHAR)P->Gpr[AX].Xl >> 7));

    } else if (P->DataType == LONG_DATA) {
        Product.QuadPart = Int32x32To64((LONG)P->DstValue.Long,
                                        (LONG)P->SrcValue.Long);

        XmStoreResult(P, Product.LowPart);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
        XmStoreResult(P, (ULONG)Product.HighPart);
        UpperEqual = (Product.HighPart != (LONG)Product.LowPart >> 31);

    } else {
        Product.QuadPart = Int32x32To64((LONG)((SHORT)P->DstValue.Word),
                                        (LONG)((SHORT)P->SrcValue.Word));

        XmStoreResult(P, Product.LowPart & 0xffff);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[DX].Exx);
        XmStoreResult(P, Product.LowPart >> 16);
        UpperEqual = (P->Gpr[DX].Xx != (USHORT)((SHORT)P->Gpr[AX].Xx >> 15));
    }

    P->Eflags.EFLAG_CF = UpperEqual;
    P->Eflags.EFLAG_OF = UpperEqual;
    return;
}

VOID
XmMulOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a mul opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULARGE_INTEGER Product;
    ULONG UpperZero;

    //
    // Multiply the unsigned operands and store result.
    //

    Product.QuadPart = UInt32x32To64(P->DstValue.Long, P->SrcValue.Long);
    if (P->DataType == BYTE_DATA) {
        P->DataType = WORD_DATA;
        XmStoreResult(P, Product.LowPart);
        UpperZero = (P->Gpr[AX].Xh != 0);

    } else if (P->DataType == LONG_DATA) {
        XmStoreResult(P, Product.LowPart);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
        XmStoreResult(P, Product.HighPart);
        UpperZero = (Product.HighPart != 0);

    } else {
        XmStoreResult(P, Product.LowPart & 0xffff);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[DX].Exx);
        XmStoreResult(P, Product.LowPart >> 16);
        UpperZero = (P->Gpr[DX].Xx != 0);
    }

    P->Eflags.EFLAG_CF = UpperZero;
    P->Eflags.EFLAG_OF = UpperZero;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\operand.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    operand.c

Abstract:

    This module implements the operand functions necessary to decode x86
    instruction operands.

Author:

    David N. Cutler (davec) 3-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

ULONG
XmPushPopSegment (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Index;

    //
    // Push or pop segment register.
    //

    Index = P->OpcodeControl.FormatType;
    P->DataType = WORD_DATA;
    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, (PVOID)(&P->SegmentRegister[Index]));

    } else {
        XmSetDestinationValue(P, (PVOID)(&P->SegmentRegister[Index]));
    }

    return TRUE;
}

ULONG
XmLoadSegment (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Index;
    ULONG DataType;
    PVOID Operand;
    ULONG Number;

    //
    // Load a segment register and a displacement value into register.
    //

    Index = P->OpcodeControl.FormatType;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if (P->RegisterOffsetAddress != FALSE) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_REGISTER_SPECIFIER);
    }

    XmSetSourceValue(P, Operand);
    DataType = P->DataType;
    P->DataType = WORD_DATA;
    Operand = XmGetOffsetAddress(P, P->Offset + DataType + 1);
    XmSetDestinationValue(P, Operand);
    P->SegmentRegister[Index - FormatLoadSegmentES] = P->DstValue.Word;
    P->DataType = DataType;
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmGroup1General (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Group 1 opcodes with general operand specifier and a direction
    // bit.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        XmSetDestinationValue(P, Operand);
        XmSetSourceValue(P, XmGetRegisterAddress(P, Number));

    } else {
        XmSetDestinationValue(P, XmGetRegisterAddress(P, Number));
        XmSetSourceValue(P, Operand);
    }

    return TRUE;
}

ULONG
XmGroup1Immediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 1 opcode with general operand specifier and an immediate
    // operand.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Source = XmGetImmediateSourceValue(P, P->CurrentOpcode & SIGN_BIT);
    XmSetDestinationValue(P, Operand);
    XmSetImmediateSourceValue(P, Source);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup2By1 (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 2 shift opcodes with a general operand specifier and a
    // shift count of 1.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    Source = 1;
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup2ByCL (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 2 shift opcodes with a general operand specifier and a
    // CL shift count.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    Source = (ULONG)P->Gpr[CL].Xl & 0x1f;
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup2ByByte (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 2 shift opcodes with a general operand specifier and a
    // byte immediate shift count.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Source = XmGetByteImmediate(P) & 0x1f;
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup3General (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 3 opcodes with general operand specifier.
    //
    // N.B. The test operator for this group has an immediate operand
    //      and the multiply and divide operators use the accumulator
    //      as a source. The not and neg operators are unary.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    P->FunctionIndex += Number;
    if (P->FunctionIndex == X86_TEST_OP) {
        Source = XmGetImmediateSourceValue(P, 0);
        XmSetDestinationValue(P, Operand);
        XmSetImmediateSourceValue(P, Source);

    } else {

        //
        // If the operation is a mulitply or divide, then there is an
        // implied operand which is AL, AX, or EAX. If the operation is
        // a divide, then there is an additional implied operand which
        // is AH, DX, or EDX.
        //

        if ((Number & 0x4) != 0) {
            if ((Number & 0x2) == 0) {
                XmSetDestinationValue(P, (PVOID)(&P->Gpr[EAX].Exx));

            } else {
                P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[EAX].Exx);
            }

            XmSetSourceValue(P, Operand);

        } else {
            XmSetDestinationValue(P, Operand);
        }
    }

    return TRUE;
}

ULONG
XmGroup45General (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG DataType;
    PVOID Operand;
    ULONG Number;

    //
    // Group 4 and group 5 unary opcodes with general operand specifier.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if (P->OpcodeControl.FormatType == FormatGroup4General) {
        Number &= 0x1;
    }

    P->FunctionIndex += Number;
    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, Operand);

    } else {

        //
        // If the operation is a call or jump that specifies a segment,
        // then get the segment value.
        //

        XmSetDestinationValue(P, Operand);
        if ((Number == 3) || (Number == 5)) {
            if (P->RegisterOffsetAddress != FALSE) {
                longjmp(&P->JumpBuffer[0], XM_ILLEGAL_REGISTER_SPECIFIER);
            }

            DataType = P->DataType;
            P->DataType = WORD_DATA;
            Operand = XmGetOffsetAddress(P, P->Offset + DataType + 1);
            XmSetSourceValue(P, Operand);
            P->DstSegment = P->SrcValue.Word;
            P->DataType = DataType;
        }
    }

    return TRUE;
}

ULONG
XmGroup8BitOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;
    ULONG Number;

    //
    // Bit test opcodes with an immediate bit offset and a memory or
    // register operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Offset = XmGetByteImmediate(P);
    XmSetImmediateSourceValue(P, Offset);
    if (P->RegisterOffsetAddress == FALSE) {
        if (P->DataType == LONG_DATA) {
            Offset = (P->SrcValue.Long >> 5) << 2;

        } else {
            Offset = (P->SrcValue.Long >> 4) << 1;
        }

        Operand = XmGetOffsetAddress(P, Offset + P->Offset);
    }

    if (P->DataType == LONG_DATA) {
        P->SrcValue.Long &= 0x1f;

    } else {
        P->SrcValue.Long &= 0xf;
    }

    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += (Number & 0x3);
    return TRUE;
}

ULONG
XmOpcodeRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // Unary opodes with a general register encoded in the low
    // 3 bits of the opcode value.
    //

    Number = P->CurrentOpcode & 0x7;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));

    } else {
        XmSetDestinationValue(P, (PVOID)(&P->Gpr[Number].Exx));
    }

    return TRUE;
}

ULONG
XmLongJump (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Offset;

    //
    // Long jump with opcode containing the control for conditional
    // jumps. The destination of the jump is stored in the destination
    // value and the jump control is stored in the sources value.
    //

    if (P->OpsizePrefixActive != FALSE) {
        Offset = XmGetLongImmediate(P);
        P->DstValue.Long = P->Eip + Offset;

    } else {
        Offset = XmGetWordImmediate(P);
        P->DstValue.Long = (USHORT)(Offset + P->Eip);
    }

    P->SrcValue.Long = P->CurrentOpcode & 0xf;
    return TRUE;
}

ULONG
XmShortJump (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Offset;

    //
    // Short jump with opcode containing the control for conditional
    // jumps. The destination of the jump is stored in the destination
    // value and the jump control is stored in the sources value.
    //

    Offset = (ULONG)XmGetSignedByteImmediateToWord(P);
    P->DstValue.Long = (USHORT)(Offset + P->Eip);
    P->SrcValue.Long = P->CurrentOpcode & 0xf;
    return TRUE;
}

ULONG
XmSetccByte (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // General byte destination with reg field ignored and the opcode
    // containing the condition control.
    //

    P->DataType = BYTE_DATA;
    P->DstByte = (UCHAR UNALIGNED *)XmEvaluateAddressSpecifier(P, &Number);
    P->SrcValue.Long = P->CurrentOpcode & 0xf;
    return TRUE;
}

ULONG
XmAccumImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // Accumulator destination and immediate source operands.
    //

    XmSetDataType(P);
    Source = XmGetImmediateSourceValue(P, 0);
    XmSetDestinationValue(P, (PVOID)(&P->Gpr[EAX].Exx));
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmAccumRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // Accumulator destination and a general register source encoded in
    // the low 3-bits of the opcode value.
    //

    Number = P->CurrentOpcode & 0x7;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    XmSetDestinationValue(P, (PVOID)(&P->Gpr[EAX].Exx));
    return TRUE;
}

ULONG
XmMoveGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Move opcodes with general operand specifier and a direction bit.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        P->DstLong = (ULONG UNALIGNED *)Operand;
        XmSetSourceValue(P, XmGetRegisterAddress(P, Number));

    } else {
        P->DstLong = (ULONG UNALIGNED *)XmGetRegisterAddress(P, Number);
        XmSetSourceValue(P, Operand);
    }

    return TRUE;
}

ULONG
XmMoveImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Move opcodes with general operand specifier and an immediate
    // operand.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    P->DstLong = (ULONG UNALIGNED *)Operand;
    Source = XmGetImmediateSourceValue(P, 0);
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmMoveRegImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // Move register immediate opcodes with a general register encoded
    // in the low 3-bits of the opcode value and an immediate operand.
    //

    Number = P->CurrentOpcode & 0x7;
    if ((P->CurrentOpcode & 0x8) == 0) {
        P->DataType = BYTE_DATA;

    } else {
        if (P->OpsizePrefixActive != FALSE) {
            P->DataType = LONG_DATA;

        } else {
            P->DataType = WORD_DATA;
        }
    }

    P->DstLong = (ULONG UNALIGNED *)XmGetRegisterAddress(P, Number);
    XmSetImmediateSourceValue(P, XmGetImmediateSourceValue(P, 0));
    return TRUE;
}

ULONG
XmSegmentOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;

    //
    // Move opcodes with an implied accumlator operand and an immediate
    // segment offset and a direction bit.
    //

    XmSetDataType(P);
    if (P->OpaddrPrefixActive != FALSE) {
        Offset = XmGetLongImmediate(P);

    } else {
        Offset = XmGetWordImmediate(P);
    }

    Operand = XmGetOffsetAddress(P, Offset);
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
        XmSetSourceValue(P, Operand);

    } else {
        P->DstLong = (ULONG UNALIGNED *)Operand;
        XmSetSourceValue(P, &P->Gpr[EAX].Exx);
    }

    return TRUE;
}

ULONG
XmMoveSegment (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Move segment opcodes with general operand specifier and a direction
    // bit.
    //

    P->DataType = WORD_DATA;
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        P->DstLong = (ULONG UNALIGNED *)Operand;
        XmSetSourceValue(P, (PVOID)(&P->SegmentRegister[Number]));

    } else {
        P->DstLong = (ULONG UNALIGNED *)(&P->SegmentRegister[Number]);
        XmSetSourceValue(P, Operand);
    }

    return TRUE;
}

ULONG
XmMoveXxGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Move zero or sign extended opcodes with general operand specifier.
    //

    if ((P->CurrentOpcode & WIDTH_BIT) == 0) {
        P->DataType = BYTE_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    XmSetSourceValue(P, Operand);
    if (P->DataType == BYTE_DATA) {
        if ((P->CurrentOpcode & 0x8) == 0) {
            P->SrcValue.Long = (ULONG)P->SrcValue.Byte;

        } else {
            P->SrcValue.Long = (ULONG)((LONG)((SCHAR)P->SrcValue.Byte));
        }

    } else {
        if ((P->CurrentOpcode & 0x8) == 0) {
            P->SrcValue.Long = (ULONG)P->SrcValue.Word;

        } else {
            P->SrcValue.Long = (ULONG)((LONG)((SHORT)P->SrcValue.Word));
        }
    }

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
        P->SrcValue.Long &= 0xffff;
    }

    P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmFlagsRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // Flags register source or destination with a stack source or
    // destination.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, (PVOID)(&P->AllFlags));

    } else {
        XmSetDestinationValue(P, (PVOID)(&P->AllFlags));
    }

    return TRUE;
}

ULONG
XmPushImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // Push opcode with an immediate operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Source = XmGetImmediateSourceValue(P, P->CurrentOpcode & SIGN_BIT);
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmPopGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Pop opcode with a general specifier.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    XmSetDestinationValue(P, Operand);
    return TRUE;
}

ULONG
XmImulImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;
    PVOID Operand;
    ULONG Source;

    //
    // Multiply signed opcode with a general specifier and an immediate
    // operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Source = XmGetImmediateSourceValue(P, P->CurrentOpcode & SIGN_BIT);
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmStringOperands (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // String opcode with implicit operands of eSI and eDI.
    //

    XmSetDataType(P);
    return TRUE;
}

ULONG
XmEffectiveOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Effective offset opcodes with general operand specifier.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    P->ComputeOffsetAddress = TRUE;
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (P->RegisterOffsetAddress != FALSE) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_REGISTER_SPECIFIER);
    }

    P->SrcValue.Long = (ULONG)((ULONG_PTR)Operand);
    XmTraceSource(P, P->SrcValue.Long);
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmImmediateJump (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // Immediate long jump with the destination offset and new CS
    // segment value. The destination of the jump is stored in the
    // destination value and the new CS segment value is stored in
    // destination segment.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DstValue.Long = XmGetLongImmediate(P);

    } else {
        P->DstValue.Long = XmGetWordImmediate(P);
    }

    P->DstSegment = XmGetWordImmediate(P);
    return TRUE;
}

ULONG
XmImmediateEnter (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    enter

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // Enter operands with an allocation size and level number.
    //

    P->SrcValue.Long = XmGetWordImmediate(P);
    P->DstValue.Long = XmGetByteImmediate(P) & 0x1f;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    return TRUE;
}

ULONG
XmGeneralBitOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;
    ULONG Number;

    //
    // Bit test opcodes with a register bit offset and a memory or
    // register operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    if (P->RegisterOffsetAddress == FALSE) {
        if (P->DataType == LONG_DATA) {
            Offset = (P->SrcValue.Long >> 5) << 2;

        } else {
            Offset = (P->SrcValue.Long >> 4) << 1;
        }

        Operand = XmGetOffsetAddress(P, Offset + P->Offset);
    }

    if (P->DataType == LONG_DATA) {
        P->SrcValue.Long &= 0x1f;

    } else {
        P->SrcValue.Long &= 0xf;
    }

    XmSetDestinationValue(P, Operand);
    return TRUE;
}

ULONG
XmShiftDouble (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    shld    shrd

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Shift double operators with an immediate byte or cl shift count.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if ((P->CurrentOpcode & 0x1) == 0) {
        Source = XmGetByteImmediate(P);

    } else {
        Source = P->Gpr[CX].Xl;
    }

    if (P->DataType == LONG_DATA) {
        P->Shift = (UCHAR)(Source & 0x1f);

    } else {
        P->Shift = (UCHAR)(Source & 0xf);
    }

    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    XmSetDestinationValue(P, Operand);
    return TRUE;
}

ULONG
XmPortImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // In/out opcodes with an immediate port and all other operands implied.
    //

    Source = (ULONG)XmGetByteImmediate(P);
    P->DataType = WORD_DATA;
    XmSetImmediateSourceValue(P, Source);
    XmSetDataType(P);
    return TRUE;
}

ULONG
XmPortDX (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // In/out opcodes with a port in DX with all other operands implied.
    //

    Source = P->Gpr[DX].Xx;
    P->DataType = WORD_DATA;
    XmSetImmediateSourceValue(P, Source);
    XmSetDataType(P);
    return TRUE;
}

ULONG
XmBitScanGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Bit scan general opcodes with general operand specifier.
    // bit.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    XmSetSourceValue(P, Operand);
    return TRUE;
}

ULONG
XmByteImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    int     xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // int opcode with an immediate operand.
    //

    P->DataType = BYTE_DATA;
    Source = XmGetImmediateSourceValue(P, 0);
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmXlatOpcode (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xlat

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;

    //
    // xlat opcode with zero extended [AL] + [eBX] as the effective
    // address.
    //

    P->DataType = BYTE_DATA;
    if (P->OpaddrPrefixActive != FALSE) {
        Offset = P->Gpr[EBX].Exx + P->Gpr[AL].Xl;

    } else {
        Offset = P->Gpr[BX].Xx + P->Gpr[AL].Xl;
    }

    Operand = XmGetOffsetAddress(P, Offset);
    XmSetSourceValue(P, Operand);
    P->DstByte = (UCHAR UNALIGNED *)(&P->Gpr[AL].Xl);
    return TRUE;
}

ULONG
XmGeneralRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    bswap

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // General register source and destination.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (P->RegisterOffsetAddress == FALSE) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_GENERAL_SPECIFIER);
    }

    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmOpcodeEscape (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    2-byte escape

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of xx is returned as the function value.

--*/

{

    //
    // Two byte opcode escape.
    //

    P->OpcodeControlTable = &XmOpcodeControlTable2[0];

#if defined(XM_DEBUG)

    P->OpcodeNameTable = &XmOpcodeNameTable2[0];

#endif

    return FALSE;
}

ULONG
XmPrefixOpcode (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    CS:     DS;     ES:     SS:     FS:     GS:     lock    adrsize
    opsize  repz    repnz

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of FALSE is returned as the function value.

--*/

{

    //
    // Case on the function index.
    //

    switch (P->FunctionIndex) {

        //
        // Segment override prefix.
        //
        // Set the segment override prefix flags and the data segment
        // number.
        //

    case X86_ES_OP:
    case X86_CS_OP:
    case X86_SS_OP:
    case X86_DS_OP:
    case X86_FS_OP:
    case X86_GS_OP:
        P->SegmentPrefixActive = TRUE;
        P->DataSegment = P->FunctionIndex;
        XmTraceOverride(P);
        break;

        //
        // Lock prefix.
        //
        // Set the lock prefix flags.
        //

    case X86_LOCK_OP:
        P->LockPrefixActive = TRUE;
        break;

        //
        // Address size prefix.
        //
        // Set the address size prefix flag.
        //

    case X86_ADSZ_OP:
        P->OpaddrPrefixActive = TRUE;
        break;

        //
        // Operand size prefix.
        //
        // Set the operand size prefix flag.
        //


    case X86_OPSZ_OP:
        P->OpsizePrefixActive = TRUE;
        break;

        //
        // Repeat until ECX or ZF equals zero
        //
        // Set up repeat until ECX or ZF equals zero prefix flags.
        //

    case X86_REPZ_OP:
        P->RepeatPrefixActive = TRUE;
        P->RepeatZflag = 1;
        break;

        //
        // Repeat until ECX equals zero or ZF equals one.
        //
        // Set up repeat until ECX equals zero or ZF equals one prefix
        // flags.
        //

    case X86_REPNZ_OP:
        P->RepeatPrefixActive = TRUE;
        P->RepeatZflag = 0;
        break;
    }

    return FALSE;
}

ULONG
XmNoOperands (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\setops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    setops.c

Abstract:

    This module implements the code to emulate set opcodes.

Author:

    David N. Cutler (davec) 13-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmSxxOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates set byte on condition opcodes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Complement;
    ULONG Condition;

    //
    // Case on the set control value.
    //

    Complement = P->SrcValue.Long & 1;
    switch (P->SrcValue.Long >> 1) {

        //
        // Set if overflow/not overflow.
        //

    case 0:
        Condition = P->Eflags.EFLAG_OF;
        break;

        //
        // Set if below/not below.
        //

    case 1:
        Condition = P->Eflags.EFLAG_CF;
        break;

        //
        // Set if zero/not zero.
        //

    case 2:
        Condition = P->Eflags.EFLAG_ZF;
        break;

        //
        // Set if below or equal/not below or equal.
        //

    case 3:
        Condition = P->Eflags.EFLAG_CF | P->Eflags.EFLAG_ZF;
        break;

        //
        // Set if signed/not signed.
        //

    case 4:
        Condition = P->Eflags.EFLAG_SF;
        break;

        //
        // Set if parity/not parity.
        //

    case 5:
        Condition = P->Eflags.EFLAG_PF;
        break;

        //
        // Set if less/not less.
        //

    case 6:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF);
        break;

        //
        // Set if less or equal/not less or equal.
        //

    case 7:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF) | P->Eflags.EFLAG_ZF;
        break;
    }

    //
    // If the specified condition is met, then set the byte destination
    // value to one. Otherwise, set the byte destination value to zero.
    //

    XmStoreResult(P, (ULONG)(Condition ^ Complement));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\shiftops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mulops.c

Abstract:

    This module implements the code to emulate the shift opcodes.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmRolOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a rol opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Mask;
    ULONG Shift;
    ULONG Value;

    //
    // Rotate destination left and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Mask = ((1 << Shift) - 1) | (1 << Shift);
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ (Value >> (Shift - 1));
        }

        do {
            Carry = Value >> Shift;
            Value = Carry | ((Value << 1) & Mask);
            Count -= 1;
        } while (Count != 0);

        P->Eflags.EFLAG_CF = Carry;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmRorOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a ror opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Shift;
    ULONG Value;

    //
    // Rotate destination right and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ (Value & 0x1);
        }

        do {
            Carry = Value & 1;
            Value = (Carry << Shift) | (Value >> 1);
            Count -= 1;
        } while (Count != 0  );

        P->Eflags.EFLAG_CF = Carry;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmRclOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a rcl opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Mask;
    ULONG Shift;
    ULONG Temp;
    ULONG Value;

    //
    // Rotate destination left through carry and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Mask = ((1 << Shift) - 1) | (1 << Shift);
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    Carry = P->Eflags.EFLAG_CF;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ (Value >> (Shift - 1));
        }

        do  {
            Temp = Value >> Shift;
            Value = ((Value << 1) & Mask) | Carry;
            Carry = Temp;
            Count -= 1;
        } while (Count != 0);
    }

    XmStoreResult(P, Value);
    P->Eflags.EFLAG_CF = Carry;
    return;
}

VOID
XmRcrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a rcr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Shift;
    ULONG Temp;
    ULONG Value;

    //
    // Rotate destination right through carry and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long & Shift;
    Carry = P->Eflags.EFLAG_CF;
    if (Count != 0) {
        if (Count == 1) {
            P->Eflags.EFLAG_OF = (Value >> Shift) ^ Carry;
        }

        do  {
            Temp = Value & 1;
            Value = (Carry << Shift) | (Value >> 1);
            Carry = Temp;
            Count -= 1;
        } while (Count != 0);
    }

    XmStoreResult(P, Value);
    P->Eflags.EFLAG_CF = Carry;
    return;
}

VOID
XmShlOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shl opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Overflow;
    ULONG Shift;
    ULONG Value;

    //
    // Shift destination left logical and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            Overflow = (Value ^ (Value << 1)) >> 31;
            Carry = Value >> (32 - Count);
            Value <<= Count;

        } else if (P->DataType == WORD_DATA) {
            Overflow = (Value ^ (Value << 1)) >> 15;
            Carry = Value >> (16 - Count);
            Value = (Value << Count) & 0xffff;

        } else {
            Overflow = (Value ^ (Value << 1)) >> 7;
            Carry = Value >> (8 - Count);
            Value = (Value << Count) & 0xff;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_OF = Overflow;
        P->Eflags.EFLAG_PF = XmComputeParity(Value);
        P->Eflags.EFLAG_ZF = (Value == 0);
        P->Eflags.EFLAG_SF = Value >> Shift;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmShrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Overflow;
    ULONG Shift;
    ULONG Value;

    //
    // Shift destination right logical and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = P->DstValue.Long;
    Count = P->SrcValue.Long;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            Overflow = Value >> 31;
            Carry = Value >> (Count - 1);
            Value >>= Count;

        } else if (P->DataType == WORD_DATA) {
            Overflow = Value >> 15;
            Carry = Value >> (Count - 1);
            Value >>= Count;

        } else {
            Overflow = Value >> 7;
            Carry = Value >> (Count - 1);
            Value >>= Count;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_OF = Overflow;
        P->Eflags.EFLAG_PF = XmComputeParity(Value);
        P->Eflags.EFLAG_ZF = (Value == 0);
        P->Eflags.EFLAG_SF = Value >> Shift;
    }

    XmStoreResult(P, Value);
    return;
}

VOID
XmSarOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a sar opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG Shift;
    LONG Value;

    //
    // Shift destination right arithmetic and store result.
    //

    Shift = ((P->DataType + 1) << 3) - 1;
    Value = (LONG)P->DstValue.Long;
    Count = P->SrcValue.Long;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            Carry = Value >> (Count - 1);
            Value >>= Count;

        } else if (P->DataType == WORD_DATA) {
            Carry = Value >> (Count - 1);
            Value = ((Value << 16) >> (Count + 16)) & 0xffff;

        } else {
            Carry = Value >> (Count - 1);
            Value = ((Value << 24) >> (Count + 24)) & 0xff;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_OF = 0;
        P->Eflags.EFLAG_PF = XmComputeParity(Value);
        P->Eflags.EFLAG_ZF = (Value == 0);
        P->Eflags.EFLAG_SF = Value >> Shift;
    }

    XmStoreResult(P, (ULONG)Value);
    return;
}

VOID
XmShldOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shld opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG High;
    ULONG Low;
    ULONG Sign;

    //
    // Double shift left logical and store result.
    //
    // The low 32-bits of the shift are the source.
    // The high 32-bits of the shift are the destination.
    // The shift count has been masked modulo the datatype.
    //
    // This shift is equivalent to extracting the high 32-bits of the left
    // shifted result.
    //

    Low = P->SrcValue.Long;
    High = P->DstValue.Long;
    Count = P->Shift;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = (High ^ (High << 1)) >> 31;
            }

            Carry = High >> (32 - Count);
            High = (High << Count) | (Low >> (32 - Count));
            Sign = High >> 31;

        } else {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = (High ^ (High << 1)) >> 15;
            }

            Carry = High >> (16 - Count);
            High = ((High << Count) | (Low >> (16 - Count))) & 0xffff;
            Sign = High >> 15;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_PF = XmComputeParity(High);
        P->Eflags.EFLAG_ZF = (High == 0);
        P->Eflags.EFLAG_SF = Sign;
    }

    XmStoreResult(P, High);
    return;
}

VOID
XmShrdOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a shrd opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;
    ULONG Count;
    ULONG High;
    ULONG Low;
    ULONG Sign;

    //
    // Double shift right logical and store result.
    //
    // The high 32-bits of the shift are the source.
    // The low 32-bits of the shift are the destination.
    // The shift count has been masked modulo the datatype.
    //
    // This shift is equivalent to extracting the low 32-bits of the right
    // shifted result.
    //

    High = P->SrcValue.Long;
    Low = P->DstValue.Long;
    Count = P->Shift;
    if (Count != 0) {
        if (P->DataType == LONG_DATA) {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = High ^ (Low >> 31);
            }

            Carry = Low >> (Count - 1);
            Low = (High << (32 - Count)) | (Low >> Count);
            Sign = Low >> 31;

        } else {
            if (Count == 1) {
                P->Eflags.EFLAG_OF = High ^ (Low >> 15);
            }

            Carry = Low >> (Count - 1);
            Low = ((High << (16 - Count)) | (Low >> Count)) & 0xffff;
            Sign = Low >> 15;
        }

        P->Eflags.EFLAG_CF = Carry;
        P->Eflags.EFLAG_PF = XmComputeParity(Low);
        P->Eflags.EFLAG_ZF = (Low == 0);
        P->Eflags.EFLAG_SF = Sign;
    }

    XmStoreResult(P, Low);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\stackops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stackops.c

Abstract:

    This module implements the code to emulate the push, pop, pushf, popf,
    pusha, popa, pushSeg, and popSeg.

Author:

    David N. Cutler (davec) 6-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmPushOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a push opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Push source value onto stack.
    //

    XmPushStack(P, P->SrcValue.Long);
    return;
}

VOID
XmPopOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a pop opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Pop the stack and store the result value.
    //

    XmStoreResult(P, XmPopStack(P));
    return;
}

VOID
XmPushaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a pusha opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Temp;

    //
    // Push all registers onto the stack.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Index = EAX;
    Temp = P->Gpr[ESP].Exx;
    do {
        if (Index == ESP) {
            XmSetSourceValue(P, (PVOID)&Temp);

        } else {
            XmSetSourceValue(P, (PVOID)(&P->Gpr[Index].Exx));
        }

        XmPushOp(P);
        Index += 1;
    } while (Index <= EDI);
    return;
}

VOID
XmPopaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a popa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Temp;

    //
    // Pop all register from the stack, but skip over ESP.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Index = EDI + 1;
    Temp = P->Gpr[ESP].Exx;
    do {
        Index -= 1;
        if (Index == ESP) {
            XmSetDestinationValue(P, (PVOID)&Temp);

        } else {
            XmSetDestinationValue(P, (PVOID)(&P->Gpr[Index].Exx));
        }

        XmPopOp(P);
    } while (Index > EAX);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\stringop.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stringop.c

Abstract:

    This module implements the code to emulate the string opcodes.

Author:

    David N. Cutler (davec) 7-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced prototypes.
//

VOID
XmCompareOperands (
    IN PRXM_CONTEXT P
    );

VOID
XmCmpsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmpsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;

        } else {
            Count = P->Gpr[CX].Xx;
        }
    }

    //
    // Compare items from source and destination.
    //

    while (Count != 0) {

        //
        // Set source and destination values.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        XmSetDestinationValue(P, XmGetStringAddress(P, ES, EDI));

        //
        // Compare source with destination operand and decrement loop count.
        // If ZF is not equal to the repeat Z flag condition, then terminate
        // the loop.
        //

        XmCompareOperands(P);
        Count -= 1;
        if (P->Eflags.EFLAG_ZF != P->RepeatZflag) {
            break;
        }
    }

    //
    // If a repeat prefix is active, then set the final count value.
    //

    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            P->Gpr[ECX].Exx = Count;

        } else {
            P->Gpr[CX].Xx = (USHORT)Count;
        }
    }

    return;
}

VOID
XmLodsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a lodsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Set destination address.
    //

    P->DstLong = (ULONG UNALIGNED *)&P->Gpr[EAX].Exx;

    //
    // Move items from source to destination.
    //

    while (Count != 0) {

        //
        // Set source value and store result.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        XmStoreResult(P, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}

VOID
XmMovsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a movsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Move items from source to destination.
    //

    while (Count != 0) {

        //
        // Set source value, set destination address, and store result.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        P->DstLong = (ULONG UNALIGNED *)XmGetStringAddress(P, ES, EDI);
        XmStoreResult(P, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}

VOID
XmScasOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a scasb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;

        } else {
            Count = P->Gpr[CX].Xx;
        }
    }

    //
    // Set source value.
    //

    XmSetSourceValue(P, (PVOID)&P->Gpr[EAX].Exx);

    //
    // Compare items from source and destination.
    //

    while (Count != 0) {

        //
        // Set destination value.
        //

        XmSetDestinationValue(P, XmGetStringAddress(P, ES, EDI));

        //
        // Compare source with destination operand and decrement loop count.
        // If ZF is not equal to the repeat Z flag condition, then terminate
        // the loop.
        //

        XmCompareOperands(P);
        Count -= 1;
        if (P->Eflags.EFLAG_ZF != P->RepeatZflag) {
            break;
        }
    }

    //
    // If a repeat prefix is active, then set the final count value.
    //

    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            P->Gpr[ECX].Exx = Count;

        } else {
            P->Gpr[CX].Xx = (USHORT)Count;
        }
    }

    return;
}

VOID
XmStosOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a stosb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Set source value.
    //

    XmSetSourceValue(P, (PVOID)&P->Gpr[EAX].Exx);

    //
    // Move items from source to destination.
    //

    while (Count != 0) {

        //
        // Set destination address and store result.
        //

        P->DstLong = (ULONG UNALIGNED *)XmGetStringAddress(P, ES, EDI);
        XmStoreResult(P, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}

VOID
XmCompareOperands (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function compares two operands and computes the resulting condition
    codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG CarryFlag;
    ULONG OverflowFlag;
    ULONG SignFlag;
    ULONG ZeroFlag;
    union {
        UCHAR ResultByte;
        ULONG ResultLong;
        USHORT ResultWord;
    } u;

    //
    // Switch on data type.
    //

    switch (P->DataType) {

        //
        // The operation datatype is byte.
        //

    case BYTE_DATA:
        CarryFlag = (P->SrcValue.Byte < P->DstValue.Byte);
        u.ResultByte = P->SrcValue.Byte - P->DstValue.Byte;
        OverflowFlag = (((u.ResultByte ^ P->SrcValue.Byte) &
                        (u.ResultByte ^ P->DstValue.Byte)) >> 7) & 0x1;

        SignFlag = (u.ResultByte >> 7) & 0x1;
        ZeroFlag = (u.ResultByte == 0);
        u.ResultLong = u.ResultByte;
        break;

        //
        // The operation datatype is word.
        //

    case WORD_DATA:
        CarryFlag = (P->SrcValue.Word < P->DstValue.Word);
        u.ResultWord = P->SrcValue.Word - P->DstValue.Word;
        OverflowFlag = (((u.ResultWord ^ P->SrcValue.Word) &
                        (u.ResultWord ^ P->DstValue.Word)) >> 15) & 0x1;

        SignFlag = (u.ResultWord >> 15) & 0x1;
        ZeroFlag = (u.ResultWord == 0);
        u.ResultLong = u.ResultWord;
        break;

        //
        // The operation datatype is long.
        //

    case LONG_DATA:
        CarryFlag = (P->SrcValue.Long < P->DstValue.Long);
        u.ResultLong = P->SrcValue.Long - P->DstValue.Long;
        OverflowFlag = (((u.ResultLong ^ P->SrcValue.Long) &
                        (u.ResultLong ^ P->DstValue.Long)) >> 31) & 0x1;

        SignFlag = (u.ResultLong >> 31) & 0x1;
        ZeroFlag = (u.ResultLong == 0);
        break;
    }

    //
    // Compute auxilary carry flag, parity flag, and store all flags in
    // the flags register.
    //

    P->Eflags.EFLAG_CF = CarryFlag;
    P->Eflags.EFLAG_PF = XmComputeParity(u.ResultLong);
    P->Eflags.EFLAG_AF = ((P->DstValue.Byte & 0xf) + (P->SrcValue.Byte & 0xf)) >> 4;
    P->Eflags.EFLAG_ZF = ZeroFlag;
    P->Eflags.EFLAG_SF = SignFlag;
    P->Eflags.EFLAG_OF = OverflowFlag;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\regmode.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    regmode.c

Abstract:

    This module implements the code necessary to decode the address
    mode specifier byte.

    N.B. This routine could be probably be more tightly encoded with a
        loss of clarity.

Author:

    David N. Cutler (davec) 10-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced function prototypes.
//

ULONG
XmEvaluateIndexSpecifier (
    IN PRXM_CONTEXT P,
    IN ULONG Mode
    );

PVOID
XmEvaluateAddressSpecifier (
    IN PRXM_CONTEXT P,
    OUT PLONG Number
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Number - Supplies a pointer to a variable that receives the register
        number selected by the reg field of the operand specifier.

    Operand - Supplies a pointer to a variable that receives the address
        of the operand specified by the mod-r/m field of the operand
        specifier.

Return Value:

    None.

--*/

{

    ULONG DispatchIndex;
    ULONG Mode;
    ULONG Modifier;
    ULONG Offset;
    ULONG Register;
    UCHAR SpecifierByte;

    PVOID Address;

    //
    // Get the next byte from the instruction stream and isolate
    // the fields. The format of an operand specifier byte is:
    //
    // <7:6> - Mode
    // <5:3> - Operand Register
    // <2:0> - Modifier
    //

    SpecifierByte = XmGetCodeByte(P);
    XmTraceSpecifier(SpecifierByte);
    Mode = (SpecifierByte >> 6) & 0x3;
    Modifier = SpecifierByte & 0x7;
    Register = (SpecifierByte >> 3) & 0x7;
    DispatchIndex = (Mode << 3) | (Modifier);
    P->RegisterOffsetAddress = FALSE;

    //
    // Set the segment base address and select between 16- and 32-bit
    // addressing.
    //

    *Number = Register;
    if (P->OpaddrPrefixActive != FALSE) {

        //
        // 32-bit addressing.
        //
        // Case on dispatch index.
        //

        switch (DispatchIndex) {

            //
            // 00-000 DS:[EAX]
            //

        case 0:
            Offset = P->Gpr[EAX].Exx;
            break;

            //
            // 00-001 DS:[ECX]
            //

        case 1:
            Offset = P->Gpr[ECX].Exx;
            break;

            //
            // 00-010 DS:[EDX]
            //

        case 2:
            Offset = P->Gpr[EDX].Exx;
            break;

            //
            // 00-011 DS:[EBX]
            //

        case 3:
            Offset = P->Gpr[EBX].Exx;
            break;

            //
            // 00-100 - scale index byte
            //

        case 4:
            Offset = XmEvaluateIndexSpecifier(P, Mode);
            break;

            //
            // 00-101 DS:d32
            //

        case 5:
            Offset = XmGetLongImmediate(P);
            break;

            //
            // 00-110 DS:[ESI]
            //

        case 6:
            Offset = P->Gpr[ESI].Exx;
            break;

            //
            // 00-111 DS:[EDI]
            //

        case 7:
            Offset = P->Gpr[EDI].Exx;
            break;

            //
            // 01-000 DS:[EAX + d8]
            //

        case 8:
            Offset = P->Gpr[EAX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-001 DS:[ECX + d8]
            //

        case 9:
            Offset = P->Gpr[ECX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-010 DS:[EDX + d8]
            //

        case 10:
            Offset = P->Gpr[EDX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-011 DS:[EBX + d8]
            //

        case 11:
            Offset = P->Gpr[EBX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-100 - scale index byte
            //

        case 12:
            Offset = XmEvaluateIndexSpecifier(P, Mode);
            break;

            //
            // 01-101 DS:[EBP + d8]
            //

        case 13:
            Offset = P->Gpr[EBP].Exx + XmGetSignedByteImmediateToLong(P);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-110 DS:[ESI + d8]
            //

        case 14:
            Offset = P->Gpr[ESI].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-111 DS:[EDI + d8]
            //

        case 15:
            Offset = P->Gpr[EDI].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 10-000 DS:[EAX + d32]
            //

        case 16:
            Offset = P->Gpr[EAX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-001 DS:[ECX + d32]
            //

        case 17:
            Offset = P->Gpr[ECX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-010 DS:[EDX + d32]
            //

        case 18:
            Offset = P->Gpr[EDX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-011 DS:[EBX + d32]
            //

        case 19:
            Offset = P->Gpr[EBX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-100 - scale index byte
            //

        case 20:
            Offset = XmEvaluateIndexSpecifier(P, Mode);
            break;

            //
            // 10-101 DS:[EBP + d32]
            //

        case 21:
            Offset = P->Gpr[EBP].Exx + XmGetLongImmediate(P);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-110 DS:[ESI + d32]
            //

        case 22:
            Offset = P->Gpr[ESI].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-111 DS:[EDI + d32]
            //

        case 23:
            Offset = P->Gpr[EDI].Exx + XmGetLongImmediate(P);
            break;

            //
            // 11-xxx - Register mode.
            //

        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            P->RegisterOffsetAddress = TRUE;
            return XmGetRegisterAddress(P, Modifier);
        }

    } else {

        //
        // 16-bit addressing.
        //
        // Case on dispatch index.
        //

        switch (DispatchIndex) {

            //
            // 00-000 DS:[BX + SI]
            //

        case 0:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[SI].Xx);
            break;

            //
            // 00-001 DS:[BX + DI]
            //

        case 1:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[DI].Xx);
            break;

            //
            // 00-010 SS:[BP + SI]
            //

        case 2:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[SI].Xx);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 00-011 SS:[BP + DI]
            //

        case 3:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[DI].Xx);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 00-100 DS:[SI]
            //

        case 4:
            Offset = (USHORT)(P->Gpr[SI].Xx);
            break;

            //
            // 00-101 DS:[DI]
            //

        case 5:
            Offset = (USHORT)(P->Gpr[DI].Xx);
            break;

            //
            // 00-110 DS:d16
            //

        case 6:
            Offset = XmGetWordImmediate(P);
            break;

            //
            // 00-111 DS:[BX]
            //

        case 7:
            Offset = (USHORT)(P->Gpr[BX].Xx);
            break;

            //
            // 01-000 DS:[BX + SI + d8]
            //

        case 8:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[SI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-001 DS:[BX + DI + d8]
            //

        case 9:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[DI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-010 SS:[BP + SI + d8]
            //

        case 10:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[SI].Xx + XmGetSignedByteImmediateToWord(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-011 SS:[BP + DI + d8]
            //

        case 11:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[DI].Xx + XmGetSignedByteImmediateToWord(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-100 DS:[SI + d8]
            //

        case 12:
            Offset = (USHORT)(P->Gpr[SI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-101 DS:[DI + d8]
            //

        case 13:
            Offset = (USHORT)(P->Gpr[DI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-110 DS:[BP + d8]
            //

        case 14:
            Offset = (USHORT)(P->Gpr[BP].Xx + XmGetSignedByteImmediateToWord(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-111 DS:[BX + d8]
            //

        case 15:
            Offset = (USHORT)(P->Gpr[BX].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 10-000 DS:[BX + SI + d16]
            //

        case 16:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[SI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-001 DS:[BX + DI + d16]
            //

        case 17:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[DI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-010 SS:[BP + SI + d16]
            //

        case 18:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[SI].Xx + XmGetWordImmediate(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-011 SS:[BP + DI + d16]
            //

        case 19:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[DI].Xx + XmGetWordImmediate(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-100 DS:[SI + d16]
            //

        case 20:
            Offset = (USHORT)(P->Gpr[SI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-101 DS:[DI + d16]
            //

        case 21:
            Offset = (USHORT)(P->Gpr[DI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-110 DS:[BP + d16]
            //

        case 22:
            Offset = (USHORT)(P->Gpr[BP].Xx + XmGetWordImmediate(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-111 DS:[BX + d16]
            //

        case 23:
            Offset = (USHORT)(P->Gpr[BX].Xx + XmGetWordImmediate(P));
            break;

            //
            // 11-xxx - Register mode.
            //

        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            P->RegisterOffsetAddress = TRUE;
            return XmGetRegisterAddress(P, Modifier);
        }
    }

    //
    // If an effective offset is being calculated, then return the offset
    // value. Otherwise, If the offset displacement value plus the datum
    // size is not within the segment limits, then raise an exception.
    // Otherwise, compute the operand address.
    //

    if (P->ComputeOffsetAddress != FALSE) {
        if (P->DataType == WORD_DATA) {
            Offset &= 0xffff;
        }

        P->Offset = Offset;
        Address   = UlongToPtr(Offset);
    } else {
        if ((Offset > P->SegmentLimit[P->DataSegment]) ||
            ((Offset + P->DataType) > P->SegmentLimit[P->DataSegment])) {
            longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);

        } else {
            P->Offset = Offset;
            Address = (PVOID)(ULONG_PTR)(P->TranslateAddress)(P->SegmentRegister[P->DataSegment],
                                                             (USHORT)Offset);
        }
    }

    return Address;
}

ULONG
XmEvaluateIndexSpecifier (
    IN PRXM_CONTEXT P,
    IN ULONG Mode
    )

/*++

Routine Description:

    This function evaluates a index specifier byte.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Mode - Supplies the mode of the address specifier.

Return Value:

    The offset value computes from the index specifier.

--*/

{

    ULONG DispatchIndex;
    ULONG Modifier;
    ULONG Offset;
    ULONG Register;
    ULONG Scale;
    UCHAR SpecifierByte;

    //
    // Get the next byte from the instruction stream and isolate the
    // specifier fields. The format of an scale/index byte is:
    //
    // <7:6> - Scale
    // <5:3> - Index register
    // <2:0> - Modifier
    //

    SpecifierByte = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)SpecifierByte);
    Scale = (SpecifierByte >> 6) & 0x3;
    Modifier = SpecifierByte & 0x7;
    Register = (SpecifierByte >> 3) & 0x7;
    DispatchIndex = (Mode << 3) | (Modifier);

    //
    // Case of dispatch index.
    //

    switch (DispatchIndex) {

        //
        // 00-000 DS:[EAX + scaled index]
        //

    case 0:
        Offset = P->Gpr[EAX].Exx;
        break;

        //
        // 00-001 DS:[ECX + scaled index]
        //

    case 1:
        Offset = P->Gpr[ECX].Exx;
        break;

        //
        // 00-010 DS:[EDX + scaled index]
        //

    case 2:
        Offset = P->Gpr[EDX].Exx;
        break;

        //
        // 00-011 DS:[EBX + scaled index]
        //

    case 3:
        Offset = P->Gpr[EBX].Exx;
        break;

        //
        // 00-100 SS:[ESP + scaled index]
        //

    case 4:
        Offset = P->Gpr[ESP].Exx;
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 00-101 DS:[d32 + scaled index]
        //

    case 5:
        Offset = XmGetLongImmediate(P);
        break;

        //
        // 00-110 DS:[ESI + scaled index]
        //

    case 6:
        Offset = P->Gpr[ESI].Exx;
        break;

        //
        // 00-111 DS:[EDI + scaled index]
        //

    case 7:
        Offset = P->Gpr[EDI].Exx;
        break;

        //
        // 01-000 DS:[EAX + scaled index + d8]
        //

    case 8:
        Offset = P->Gpr[EAX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-001 DS:[ECX + scaled index + d8]
        //

    case 9:
        Offset = P->Gpr[ECX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-010 DS:[EDX + scaled index + d8]
        //

    case 10:
        Offset = P->Gpr[EDX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-011 DS:[EBX + scaled index + d8]
        //

    case 11:
        Offset = P->Gpr[EBX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-100 SS:[ESP + scaled index + d8]
        //

    case 12:
        Offset = P->Gpr[ESP].Exx + XmGetSignedByteImmediateToLong(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 01-101 DS:[EBP + scaled index + d8]
        //

    case 13:
        Offset = P->Gpr[EBP].Exx + XmGetSignedByteImmediateToLong(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }
        break;

        //
        // 01-110 DS:[ESI + scaled index + d8]
        //

    case 14:
        Offset = P->Gpr[ESI].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-111 DS:[EDI + scaled index + d8]
        //

    case 15:
        Offset = P->Gpr[EDI].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 10-000 DS:[EAX + scaled index + d32]
        //

    case 16:
        Offset = P->Gpr[EAX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-001 DS:[ECX + scaled index + d32]
        //

    case 17:
        Offset = P->Gpr[ECX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-010 DS:[EDX + scaled index + d32]
        //

    case 18:
        Offset = P->Gpr[EDX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-011 DS:[EBX + scaled index + d32]
        //

    case 19:
        Offset = P->Gpr[EBX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-100 SS:[ESP + scaled index + d32]
        //

    case 20:
        Offset = P->Gpr[ESP].Exx + XmGetLongImmediate(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 10-101 DS:[EBP + scaled index + d32]
        //

    case 21:
        Offset = P->Gpr[EBP].Exx + XmGetLongImmediate(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 10-110 DS:[ESI + scaled index + d32]
        //

    case 22:
        Offset = P->Gpr[ESI].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-111 DS:[EDI + scaled index + d32]
        //

    case 23:
        Offset = P->Gpr[EDI].Exx + XmGetLongImmediate(P);
        break;

        //
        // Illegal mode specifier.
        //

    default:
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_INDEX_SPECIFIER);
    }

    //
    // Compute the total offset value.
    //

    return Offset + (P->Gpr[Register].Exx << Scale);
}

PVOID
XmGetOffsetAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Offset
    )

/*++

Routine Description:

    This function evaluates a data segment address given a specified
    offset.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Offset - Supplies the offset value.

Return Value:

    A pointer to the operand value.

--*/

{

    //
    // If the offset displacement value plus the datum size is not within
    // the segment limits, then raise an exception. Otherwise, compute the
    // operand address.
    //

    if ((Offset > P->SegmentLimit[P->DataSegment]) ||
        ((Offset + P->DataType) > P->SegmentLimit[P->DataSegment])) {
        longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);
    }

    return (P->TranslateAddress)(P->SegmentRegister[P->DataSegment], (USHORT)Offset);
}

PVOID
XmGetRegisterAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Number
    )

/*++

Routine Description:

    This function computes the address of a register value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Number  - Supplies the register number.

Return Value:

    A pointer to the register value.

--*/

{

    PVOID Value;

    //
    // If the operand width is a byte, then the register is a
    // byte register. Otherwise, the register is a word register.
    //

    if (P->DataType == BYTE_DATA) {
        if (Number < 4) {
            Value = (PVOID)&P->Gpr[Number].Xl;

        } else {
            Value = (PVOID)&P->Gpr[Number - 4].Xh;
        }

    } else if (P->DataType == WORD_DATA) {
        Value = (PVOID)&P->Gpr[Number].Xx;

    } else {
        Value = (PVOID)&P->Gpr[Number].Exx;
    }

    return Value;
}

PVOID
XmGetStringAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Segment,
    IN ULONG Register
    )

/*++

Routine Description:

    This function evaluates a string address.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Segment - Supplies the segment number of the string operand.

    Register - Supplies the register number of the string operand.

Return Value:

    A pointer to the string value.

--*/

{

    ULONG Increment;
    ULONG Offset;

    //
    // Get the offset of the specified address and increment the specified
    // register.
    //

    Increment = P->DataType + 1;
    if (P->Eflags.EFLAG_DF != 0) {
        Increment = ~Increment + 1;
    }

    if (P->OpaddrPrefixActive != FALSE) {
        Offset = P->Gpr[Register].Exx;
        P->Gpr[Register].Exx += Increment;

    } else {
        Offset = P->Gpr[Register].Xx;
        P->Gpr[Register].Xx += (USHORT)Increment;
    }

    //
    // If the offset displacement value plus the datum size is not within
    // the segment limits, then raise an exception. Otherwise, compute the
    // operand address.
    //

    if ((Offset > P->SegmentLimit[Segment]) ||
        ((Offset + P->DataType) > P->SegmentLimit[Segment])) {
        longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);
    }

    return (P->TranslateAddress)(P->SegmentRegister[Segment], (USHORT)Offset);
}

VOID
XmSetDestinationValue (
    IN PRXM_CONTEXT P,
    IN PVOID Destination
    )

/*++

Routine Description:

    This function stores the destination operand value in the emulator
    context.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Destination - Supplies a pointer to the destination operand value.

Return Value:

    None.

--*/

{

    //
    // Set address and value of destination.
    //

    P->DstLong = (ULONG UNALIGNED *)Destination;
    if (P->DataType == BYTE_DATA) {
        P->DstValue.Long = *(UCHAR *)Destination;

    } else if (P->DataType == WORD_DATA) {
        if (((ULONG_PTR)Destination & 0x1) == 0) {
            P->DstValue.Long = *(USHORT *)Destination;

        } else {
            P->DstValue.Long = *(USHORT UNALIGNED *)Destination;
        }

    } else {
        if (((ULONG_PTR)Destination & 0x3) == 0) {
            P->DstValue.Long = *(ULONG *)Destination;

        } else {
            P->DstValue.Long = *(ULONG UNALIGNED *)Destination;
        }
    }

    XmTraceDestination(P, P->DstValue.Long);
    return;
}

VOID
XmSetSourceValue (
    IN PRXM_CONTEXT P,
    IN PVOID Source
    )

/*++

Routine Description:

    This function stores the source operand value in the emulator
    context.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Source - Supplies a pointer to the source operand value.

Return Value:

    None.

--*/

{

    //
    // Set address and value of source.
    //

    P->SrcLong = (ULONG UNALIGNED *)Source;
    if (P->DataType == BYTE_DATA) {
        P->SrcValue.Long = *(UCHAR UNALIGNED *)Source;

    } else if (P->DataType == WORD_DATA) {
        P->SrcValue.Long = *(USHORT UNALIGNED *)Source;

    } else {
        P->SrcValue.Long = *(ULONG UNALIGNED *)Source;
    }

    XmTraceSource(P, P->SrcValue.Long);
    return;
}

ULONG
XmGetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG ByteFlag
    )

/*++

Routine Description:

    This function gets an immediate source from the instruction stream.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    ByteFlag - Supplies a flag value that determines whether the
        immediate value is a sign extended byte.

Return Value:

    None.

--*/

{

    ULONG Value;

    //
    // Get source value.
    //

    if (P->DataType == BYTE_DATA) {
        Value = XmGetByteImmediate(P);

    } else if (P->DataType == WORD_DATA) {
        if (ByteFlag == 0) {
            Value = XmGetWordImmediate(P);

        } else {
            Value = XmGetSignedByteImmediateToWord(P);
        }

    } else {
        if (ByteFlag == 0) {
            Value = XmGetLongImmediate(P);

        } else {
            Value = XmGetSignedByteImmediateToLong(P);
        }
    }

    return Value;
}

VOID
XmSetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    )

/*++

Routine Description:

    This function stores the immediate source operand value in the
    emulator context.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Source - Supplies the source value.

Return Value:

    None.

--*/

{

    //
    // Set source value.
    //

    P->SrcValue.Long = Source;
    XmTraceSource(P, Source);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\pcibios.c ===
/*++

Module Name:

    pcibios.c

Abstract:

    This module implements the INT 1a functions of the
    PCI BIOS Specification revision 2.1, which makes
    it possible to support video BIOSes that expect
    to be able to read and write PCI configuration
    space.

    In order to read and write to PCI configuration
    space, this code needs to call functions in the
    HAL that know how configuration space is
    implemented in the specific machine.  There are
    standard functions exported by the HAL to do
    this, but they aren't usually available (i.e.
    the bus handler code hasn't been set up yet) by
    the time that the video needs to be initialized.
    So the PCI BIOS functions in the emulator make
    calls to XmGetPciData and XmSetPciData, which
    are pointers to functions passed into the
    emulator by the HAL.  It is the responsibility of
    the calling code to provide functions which match
    these prototypes.

Author:

    Jake Oshins (joshins@vnet.ibm.com) 3-15-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"
#include "pci.h"

BOOLEAN
XmExecuteInt1a (
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    The function calls the specific worker functions
    based upon the contents of the registers in Context.

Arguments:

    Context - State of the emulator

Return Value:

    None.

--*/
{
    //
    // If we aren't emulating PCI BIOS,
    // return.
    if (!XmPciBiosPresent) {
        return FALSE;
    }

    //
    // If this is not a call to PCI BIOS,
    // ignore it.
    //
    if (Context->Gpr[EAX].Xh != PCI_FUNCTION_ID) {
        return FALSE;
    }

    //
    // Switch on AL to see which PCI BIOS function
    // has been requested.
    //
    switch (Context->Gpr[EAX].Xl) {
    case PCI_BIOS_PRESENT:

        XmInt1aPciBiosPresent(Context);
        break;

    case PCI_FIND_DEVICE:

        XmInt1aFindPciDevice(Context);
        break;

    case PCI_FIND_CLASS_CODE:

        XmInt1aFindPciClassCode(Context);
        break;

    case PCI_GENERATE_CYCLE:

        XmInt1aGenerateSpecialCycle(Context);
        break;

    case PCI_GET_IRQ_ROUTING:

        XmInt1aGetRoutingOptions(Context);
        break;

    case PCI_SET_IRQ:

        XmInt1aSetPciIrq(Context);
        break;

    case PCI_READ_CONFIG_BYTE:
    case PCI_READ_CONFIG_WORD:
    case PCI_READ_CONFIG_DWORD:

        XmInt1aReadConfigRegister(Context);
        break;

    case PCI_WRITE_CONFIG_BYTE:
    case PCI_WRITE_CONFIG_WORD:
    case PCI_WRITE_CONFIG_DWORD:

        XmInt1aWriteConfigRegister(Context);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

VOID
XmInt1aPciBiosPresent(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements PCI_BIOS_PRESENT.

Arguments:

    Context - State of the emulator

Return Value:

    None.

--*/
{
    Context->Gpr[EDX].Exx = *(PULONG)(&"PCI ");

    // Present status is good:
    Context->Gpr[EAX].Xh = 0x0;

    // Hardware mechanism is:
    // Standard config mechanisms not supported,
    // Special cycles not supported
    // i.e.  We want all accesses to be done through software
    Context->Gpr[EAX].Xl = 0x0;

    // Interface level major version
    Context->Gpr[EBX].Xh = 0x2;

    // Interface level minor version
    Context->Gpr[EBX].Xl = 0x10;

    // Number of last PCI bus in system
    Context->Gpr[ECX].Xl = XmNumberPciBusses;

    // Present status good:
    Context->Eflags.EFLAG_CF = 0x0;
}

VOID
XmInt1aFindPciDevice(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements FIND_PCI_DEVICE.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    FIND_PCI_DEVICE
        [CX]    Device ID (0...65535)
        [DX]    Vendor ID (0...65534)
        [SI]    Index (0..N)


Return Value:

        [BH]    Bus Number
        [BL]    Device Number, Function Number
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR Bus;
    PCI_SLOT_NUMBER Slot;
    ULONG Device;
    ULONG Function;
    ULONG Index = 0;
    ULONG buffer;

    if (Context->Gpr[EAX].Xx == PCI_ILLEGAL_VENDOR_ID) {
        Context->Gpr[EAX].Xh = PCI_BAD_VENDOR_ID;
        Context->Eflags.EFLAG_CF = 1;
        return;
    }

    Slot.u.AsULONG = 0;

    for (Bus = 0; Bus < XmNumberPciBusses; Bus++) {
        for (Device = 0; Device < 32; Device++) {
            for (Function = 0; Function < 8; Function++) {

                Slot.u.bits.DeviceNumber = Device;
                Slot.u.bits.FunctionNumber = Function;

                if (4 != XmGetPciData(Bus,
                                      Slot.u.AsULONG,
                                      &buffer,
                                      0, //offset of vendor ID
                                      4)) {

                    buffer = 0xffffffff;
                }

                //
                // Did we find the right one?
                //
                if (((buffer & 0xffff) == Context->Gpr[EDX].Xx) &&
                    (((buffer >> 16) & 0xffff) == Context->Gpr[ECX].Xx)) {

                    //
                    // Did we find the right occurrence?
                    //
                    if (Index++ == Context->Gpr[ESI].Xx) {

                    Context->Gpr[EBX].Xh = Bus;
                    Context->Gpr[EBX].Xl = (UCHAR)((Device << 3) | Function);
                    Context->Gpr[EAX].Xh = PCI_SUCCESS;
                    Context->Eflags.EFLAG_CF = 0;

                    return;
                    }
                }
            }
        }
    }

    Context->Gpr[EAX].Xh = PCI_DEVICE_NOT_FOUND;
    Context->Eflags.EFLAG_CF = 1;

}

VOID
XmInt1aFindPciClassCode(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements FIND_PCI_CLASS_CODE.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    FIND_PCI_CLASS_CODE
        [ECX]   Class Code (in lower three bytes)
        [SI]    Index (0..N)


Return Value:

        [BH]    Bus Number
        [BL]    Device Number, Function Number
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR Bus;
    PCI_SLOT_NUMBER Slot;
    ULONG Index = 0;
    ULONG class_code;
    ULONG Device;
    ULONG Function;

    Slot.u.AsULONG = 0;

    for (Bus = 0; Bus < XmNumberPciBusses; Bus++) {
        for (Device = 0; Device < 32; Device++) {
            for (Function = 0; Function < 8; Function++) {

                Slot.u.bits.DeviceNumber = Device;
                Slot.u.bits.FunctionNumber = Function;

                if (4 != XmGetPciData(Bus,
                                      Slot.u.AsULONG,
                                      &class_code,
                                      8, //offset of vendor ID
                                      4)) {

                    class_code = 0xffffffff;
                }

                class_code >>= 8;

                //
                // Did we find the right one?
                //
                if (class_code == (Context->Gpr[ECX].Exx & 0xFFFFFF)) {

                    //
                    // Did we find the right occurrence?
                    //
                    if (Index++ == Context->Gpr[ESI].Xx) {

                    Context->Gpr[EBX].Xh = Bus;
                    Context->Gpr[EBX].Xl = (UCHAR)((Device << 3) | (Function));
                    Context->Gpr[EAX].Xh = PCI_SUCCESS;
                    Context->Eflags.EFLAG_CF = 0;

                    return;

                    }
                }
            }
        }
    }

    Context->Gpr[EAX].Xh = PCI_DEVICE_NOT_FOUND;
    Context->Eflags.EFLAG_CF = 1;

}

VOID
XmInt1aGenerateSpecialCycle(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements GENERATE_SPECIAL_CYCLE.  Since
    there is no uniform way to support special cycles from
    the NT HAL, we won't support this function.

Arguments:

    Context - State of the emulator

Return Value:

    [AH]    PCI_NOT_SUPPORTED

--*/
{
    Context->Gpr[EAX].Xh = PCI_NOT_SUPPORTED;
    Context->Eflags.EFLAG_CF = 1;
}

VOID
XmInt1aGetRoutingOptions(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements GET_IRQ_ROUTING_OPTIONS.  We
    won't allow devices to try to specify their own interrupt
    routing, partly because there isn't an easy way to do it,
    partly because this is done later by the HAL, and partly
    because almost no video devices generate interrupts.

Arguments:

    Context - State of the emulator

Return Value:

    [AH]    PCI_NOT_SUPPORTED

--*/
{
    Context->Gpr[EAX].Xh = PCI_NOT_SUPPORTED;
    Context->Eflags.EFLAG_CF = 1;
}

VOID
XmInt1aSetPciIrq(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements SET_PCI_IRQ.  We
    won't allow devices to try to specify their own interrupt
    routing, partly because there isn't an easy way to do it,
    partly because this is done later by the HAL, and partly
    because almost no video devices generate interrupts.

Arguments:

    Context - State of the emulator

Return Value:

    [AH]    PCI_NOT_SUPPORTED

--*/
{
    Context->Gpr[EAX].Xh = PCI_NOT_SUPPORTED;
    Context->Eflags.EFLAG_CF = 1;
}



VOID
XmInt1aReadConfigRegister(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements READ_CONFIG_BYTE,
    READ_CONFIG_WORD and READ_CONFIG_DWORD.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    function
        [BH]    bus number
        [BL]    device number/function number
        [DI]    Register number


Return Value:

        [ECX]   data read
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR length;
    PCI_SLOT_NUMBER Slot;
    ULONG buffer;

    //
    // First, make sure that the register number is valid.
    //
    if (((Context->Gpr[EAX].Xl == PCI_READ_CONFIG_WORD) &&
         (Context->Gpr[EBX].Xl % 2)) ||
        ((Context->Gpr[EAX].Xl == PCI_READ_CONFIG_DWORD) &&
         (Context->Gpr[EBX].Xl % 4))
       )
    {
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
    }

    switch (Context->Gpr[EAX].Xl) {
    case PCI_READ_CONFIG_BYTE:
        length = 1;
        break;

    case PCI_READ_CONFIG_WORD:
        length = 2;
        break;

    case PCI_READ_CONFIG_DWORD:
        length = 4;
    }

    Slot.u.AsULONG = 0;
    Slot.u.bits.DeviceNumber   = Context->Gpr[EBX].Xl >> 3;
    Slot.u.bits.FunctionNumber = Context->Gpr[EBX].Xl;

    if (XmGetPciData(Context->Gpr[EBX].Xh,
                     Slot.u.AsULONG,
                     &buffer,
                     Context->Gpr[EDI].Xx,
                     length
                     ) == 0)
    {
        // This is the only error code supported by this function
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
        return;
    }

    switch (Context->Gpr[EAX].Xl) {
    case PCI_READ_CONFIG_BYTE:
        Context->Gpr[ECX].Xl = (UCHAR)(buffer & 0xff);
        break;

    case PCI_READ_CONFIG_WORD:
        Context->Gpr[ECX].Xx = (USHORT)(buffer & 0xffff);
        break;

    case PCI_READ_CONFIG_DWORD:
        Context->Gpr[ECX].Exx = buffer;
    }

    Context->Gpr[EAX].Xh = PCI_SUCCESS;
    Context->Eflags.EFLAG_CF = 0;

}


VOID
XmInt1aWriteConfigRegister(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements WRITE_CONFIG_BYTE,
    WRITE_CONFIG_WORD and WRITE_CONFIG_DWORD.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    function
        [BH]    bus number
        [BL]    device number/function number
        [DI]    Register number


Return Value:

        [ECX]   data read
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR length;
    PCI_SLOT_NUMBER Slot;
    ULONG buffer;

    //
    // First, make sure that the register number is valid.
    //
    if (((Context->Gpr[EAX].Xl == PCI_WRITE_CONFIG_WORD) &&
         (Context->Gpr[EBX].Xl % 2)) ||
        ((Context->Gpr[EAX].Xl == PCI_WRITE_CONFIG_DWORD) &&
         (Context->Gpr[EBX].Xl % 4))
       )
    {
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
    }

    //
    // Find out how many bytes to write
    //
    switch (Context->Gpr[EAX].Xl) {
    case PCI_WRITE_CONFIG_BYTE:
        length = 1;
        buffer = Context->Gpr[ECX].Xl;
        break;

    case PCI_WRITE_CONFIG_WORD:
        length = 2;
        buffer = Context->Gpr[ECX].Xx;
        break;

    case PCI_WRITE_CONFIG_DWORD:
        length = 4;
        buffer = Context->Gpr[ECX].Exx;
    }

    //
    // Unpack the Slot/Function information
    //
    Slot.u.AsULONG = 0;
    Slot.u.bits.DeviceNumber   = Context->Gpr[EBX].Xl >> 3;
    Slot.u.bits.FunctionNumber = Context->Gpr[EBX].Xl;

    if (XmSetPciData(Context->Gpr[EBX].Xh,
                     Slot.u.AsULONG,
                     &buffer,
                     Context->Gpr[EDI].Xx,
                     length
                     ) == 0)
    {
        Context->Gpr[EAX].Xh = PCI_SUCCESS;
        Context->Eflags.EFLAG_CF = 0;
    } else {
        // This is the only error code supported by this function
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\utility.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    utility.c

Abstract:

    This module implements utility functions.

Author:

    David N. Cutler (davec) 7-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define bit count array.
//

UCHAR XmBitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};

ULONG
XmComputeParity (
    IN ULONG Result
    )

/*++

Routine Description:

    This function computes the parity of the low byte of the specified
    result.

Arguments:

    Result - Supplies the result for which the parity flag is computed.

Return Value:

    The parity flag value.

--*/

{

    ULONG Count;

    //
    // Sum the bits in the result and return the complement of the low bit.
    //

    Count = XmBitCount[Result & 0xf];
    Count += XmBitCount[(Result >> 4) & 0xf];
    return (~Count) & 1;
}

UCHAR
XmGetCodeByte (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets the next code byte from the instruction stream.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte form the instruction stream.

--*/

{

    ULONG Offset;

    //
    // If the current IP is within the code segment, then return the
    // next byte from the instrcution stream and increment the IP value.
    // Otherwise, raise an exception.
    //

    Offset = P->Eip;
    if (Offset > P->SegmentLimit[CS]) {
        longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);
    }

    P->Ip += 1;
    return *(PUCHAR)((P->TranslateAddress)(P->SegmentRegister[CS], (USHORT)Offset));
}

UCHAR
XmGetByteImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a byte value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream.

--*/

{

    UCHAR Byte;

    //
    // Get immediate byte from the code stream.
    //

    Byte = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)Byte);
    return Byte;
}

USHORT
XmGetByteImmediateToWord (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a zero extended byte to word value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream zero extended to a word.

--*/

{

    USHORT Word;

    //
    // Get immediate byte from the code stream.
    //

    Word = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Word));
    return Word;
}

ULONG
XmGetByteImmediateToLong (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a zero extended byte to long value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream zero extended to a long.

--*/

{

    ULONG Long;

    //
    // Get immediate byte from the code stream.
    //

    Long = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Long));
    return Long;
}

USHORT
XmGetSignedByteImmediateToWord (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a sign extended byte to word value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream sign extended to a word.

--*/

{

    USHORT Word;

    //
    // Get immediate byte from the code stream.
    //

    Word = (USHORT)((SHORT)((SCHAR)XmGetCodeByte(P)));
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Word));
    return Word;
}

ULONG
XmGetSignedByteImmediateToLong (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate byte operand from the
    code stream and returns a sign extended byte to long value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next byte from the instruction stream sign extended to a long.

--*/

{

    ULONG Long;

    //
    // Get immediate byte from the code stream.
    //

    Long = (ULONG)((LONG)((SCHAR)XmGetCodeByte(P)));
    XmTraceInstruction(BYTE_DATA, (ULONG)((UCHAR)Long));
    return Long;
}

USHORT
XmGetWordImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate word operand from the
    code stream and returns a word value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next word from the instruction stream.

--*/

{

    USHORT Word;

    //
    // Get immediate word from the code stream.
    //

    Word = XmGetCodeByte(P);
    Word += XmGetCodeByte(P) << 8;
    XmTraceInstruction(WORD_DATA, (ULONG)Word);
    return Word;
}

ULONG
XmGetLongImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function gets an unsigned immediate long operand from the
    code stream and returns a long value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    The next long from the instruction stream.

--*/

{

    ULONG Long;

    //
    // Get immediate long from the code stream.
    //

    Long = XmGetCodeByte(P);
    Long += XmGetCodeByte(P) << 8;
    Long += XmGetCodeByte(P) << 16;
    Long += XmGetCodeByte(P) << 24;
    XmTraceInstruction(LONG_DATA, Long);
    return Long;
}

ULONG
XmPopStack (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function pops an operand from the stack.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Offset;

    //
    // Compute the new stack address and compare against the segment limit.
    // If the new address is greater than the limit, then raise an exception.
    // Otherwise, perform the push operation.
    //

    Offset = P->Gpr[ESP].Exx;
    if (Offset > (ULONG)(P->SegmentLimit[SS] - P->DataType)) {
        longjmp(&P->JumpBuffer[0], XM_STACK_UNDERFLOW);
    }

    P->Gpr[ESP].Exx += (P->DataType + 1);
    XmSetSourceValue(P, (P->TranslateAddress)(P->SegmentRegister[SS], (USHORT)Offset));
    return P->SrcValue.Long;
}

VOID
XmPushStack (
    IN PRXM_CONTEXT P,
    IN ULONG Value
    )

/*++

Routine Description:

    This function pushes an operand on the stack.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Value - Supplies the value to be pushed.

Return Value:

    None.

--*/

{

    ULONG Offset;

    //
    // Compute the new stack address and compare against the segment limit.
    // If the new address is greater than the limit, then raise an exception.
    // Otherwise, perform the push operation.
    //

    Offset = P->Gpr[ESP].Exx - P->DataType - 1;
    if (Offset > (ULONG)(P->SegmentLimit[SS] - P->DataType)) {
        longjmp(&P->JumpBuffer[0], XM_STACK_OVERFLOW);
    }

    P->Gpr[ESP].Exx = Offset;
    P->DstLong = (ULONG UNALIGNED *)((P->TranslateAddress)(P->SegmentRegister[SS],
                                                           (USHORT)Offset));

    XmStoreResult(P, Value);
    return;
}

VOID
XmSetDataType (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function sets the data type of the operation based on the width
    bit of the current opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // If the width bit is zero, then the data type is byte. Otherwise,
    // the datatype is determined by the presence of absence of a operand
    // size prefix.
    //

    if ((P->CurrentOpcode & WIDTH_BIT) == 0) {
        P->DataType = BYTE_DATA;

    } else if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    return;
}

VOID
XmStoreResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    )

/*++

Routine Description:

    This function stores the result of an operation.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Result - Supplies the result value to store.

Return Value:

    None.

--*/

{

    //
    // Store result of operation.
    //

    if (P->DataType == BYTE_DATA) {
        *P->DstByte = (UCHAR)Result;

    } else if (P->DataType == WORD_DATA) {
        if (((ULONG_PTR)P->DstWord & 0x1) == 0) {
            *((PUSHORT)(P->DstWord)) = (USHORT)Result;

        } else {
            *P->DstWord = (USHORT)Result;
        }

    } else {

#ifdef _IA64_

        //
        // Hack to force the compiler to generate unaligned
        // accesses.  We can remove it when the compiler is
        // fixed.
        //

        *P->DstLong = Result;
#else
       
        if (((ULONG_PTR)P->DstLong & 0x3) == 0) {
            *((PULONG)(P->DstLong)) = Result;

        } else {
            *P->DstLong = Result;

       }

#endif // #ifdef _IA64_ 

    }

    XmTraceResult(P, Result);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\x86bios.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86bios.c

Abstract:

    This module implements supplies the HAL interface to the 386/486
    real mode emulator for the purpose of emulating BIOS calls..

Author:

    David N. Cutler (davec) 13-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "hal.h"
#include "xm86.h"
#include "x86new.h"

//
// Define the size of low memory.
//

#define LOW_MEMORY_SIZE 0x800

//
// Define storage for low emulated memory.
//

UCHAR x86BiosLowMemory[LOW_MEMORY_SIZE + 3];
ULONG x86BiosScratchMemory;

//
// Define storage to capture the base address of I/O space, the base address
// of I/O memory space, and the base address of the video frame buffer.
//

ULONG_PTR x86BiosFrameBuffer;
ULONG_PTR x86BiosIoMemory;
ULONG_PTR x86BiosIoSpace;

//
// Define an area of storage to allow for buffer passing between the BIOS
// and native mode code.
//

ULONG_PTR x86BiosTransferMemory = 0;
ULONG x86BiosTransferLength = 0;

//
// Define BIOS initialized state.
//

BOOLEAN x86BiosInitialized = FALSE;

//
// Define storage for PCI BIOS initialization state.
//

UCHAR XmNumberPciBusses = 0;
BOOLEAN XmPciBiosPresent = FALSE;
PGETSETPCIBUSDATA XmGetPciData;
PGETSETPCIBUSDATA XmSetPciData;

ULONG
x86BiosReadIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    )

/*++

Routine Description:

    This function reads from emulated I/O space.

Arguments:

    DataType - Supplies the datatype for the read operation.

    PortNumber - Supplies the port number in I/O space to read from.

Return Value:

    The value read from I/O space is returned as the function value.

    N.B. If an aligned operation is specified, then the individual
        bytes are read from the specified port one at a time and
        assembled into the specified datatype.

--*/

{

    ULONG Result;

    union {
        PUCHAR Byte;
        PUSHORT Word;
        PULONG Long;
    } u;

    //
    // Compute port address and read port.
    //

    u.Long = (PULONG)(x86BiosIoSpace + PortNumber);
    if (DataType == BYTE_DATA) {
        Result = READ_PORT_UCHAR(u.Byte);

    } else if (DataType == LONG_DATA) {
        if (((ULONG_PTR)u.Long & 0x3) != 0) {
            Result = (READ_PORT_UCHAR(u.Byte + 0)) |
                     (READ_PORT_UCHAR(u.Byte + 1) << 8) |
                     (READ_PORT_UCHAR(u.Byte + 2) << 16) |
                     (READ_PORT_UCHAR(u.Byte + 3) << 24);

        } else {
            Result = READ_PORT_ULONG(u.Long);
        }

    } else {
        if (((ULONG_PTR)u.Word & 0x1) != 0) {
            Result = (READ_PORT_UCHAR(u.Byte + 0)) |
                     (READ_PORT_UCHAR(u.Byte + 1) << 8);

        } else {
            Result = READ_PORT_USHORT(u.Word);
        }
    }

    return Result;
}

VOID
x86BiosWriteIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    )

/*++

Routine Description:

    This function write to emulated I/O space.

    N.B. If an aligned operation is specified, then the individual
        bytes are written to the specified port one at a time.

Arguments:

    DataType - Supplies the datatype for the write operation.

    PortNumber - Supplies the port number in I/O space to write to.

    Value - Supplies the value to write.

Return Value:

    None.

--*/

{

    union {
        PUCHAR Byte;
        PUSHORT Word;
        PULONG Long;
    } u;

    //
    // Compute port address and read port.
    //

    u.Long = (PULONG)(x86BiosIoSpace + PortNumber);
    if (DataType == BYTE_DATA) {
        WRITE_PORT_UCHAR(u.Byte, (UCHAR)Value);

    } else if (DataType == LONG_DATA) {
        if (((ULONG_PTR)u.Long & 0x3) != 0) {
            WRITE_PORT_UCHAR(u.Byte + 0, (UCHAR)(Value));
            WRITE_PORT_UCHAR(u.Byte + 1, (UCHAR)(Value >> 8));
            WRITE_PORT_UCHAR(u.Byte + 2, (UCHAR)(Value >> 16));
            WRITE_PORT_UCHAR(u.Byte + 3, (UCHAR)(Value >> 24));

        } else {
            WRITE_PORT_ULONG(u.Long, Value);
        }

    } else {
        if (((ULONG_PTR)u.Word & 0x1) != 0) {
            WRITE_PORT_UCHAR(u.Byte + 0, (UCHAR)(Value));
            WRITE_PORT_UCHAR(u.Byte + 1, (UCHAR)(Value >> 8));

        } else {
            WRITE_PORT_USHORT(u.Word, (USHORT)Value);
        }
    }

    return;
}

PVOID
x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    )

/*++

Routine Description:

    This translates a segment/offset address into a memory address.

Arguments:

    Segment - Supplies the segment register value.

    Offset - Supplies the offset within segment.

Return Value:

    The memory address of the translated segment/offset pair is
    returned as the function value.

--*/

{

    ULONG Value;

    //
    // Compute the logical memory address and case on high hex digit of
    // the resultant address.
    //

    Value = Offset + (Segment << 4);
    Offset = (USHORT)(Value & 0xffff);
    Value &= 0xf0000;
    switch ((Value >> 16) & 0xf) {

        //
        // Interrupt vector/stack space.
        //

    case 0x0:
        if (Offset > LOW_MEMORY_SIZE) {
            x86BiosScratchMemory = 0;
            return (PVOID)&x86BiosScratchMemory;

        } else {
            return (PVOID)(&x86BiosLowMemory[0] + Offset);
        }

        //
        // The memory range from 0x10000 to 0x8ffff reads as zero
        // and writes are ignored.
        //

    case 0x1:
    case 0x3:
    case 0x4:
    case 0x5:
    case 0x6:
    case 0x7:
    case 0x8:
        x86BiosScratchMemory = 0;
        return (PVOID)&x86BiosScratchMemory;

    case 0x9:
	//
	// BUGBUG: Found a VGA adapter loaded in segment 9
	// Emulator assumptions about video adapters needs to be
	// looked at
	//
	return (PVOID)(x86BiosIoMemory + Offset + Value);

        //
        // The memory range from 0x20000 to 0x20fff is used to transfer
        // buffers between native mode and emulated mode.
        //

    case 0x2:
        if (Offset < x86BiosTransferLength) {
            return (PVOID)(x86BiosTransferMemory + Offset);
        } else {
            x86BiosScratchMemory = 0;
            return (PVOID)&x86BiosScratchMemory;
        }

        //
        // The memory range from 0xa0000 to 0xbffff maps to the
        // framebuffer if previously specified, otherwise I/O memory.
        //

    case 0xa:
    case 0xb:
        if (x86BiosFrameBuffer != 0) {
            return (PVOID)(x86BiosFrameBuffer + Offset + Value);
        }

        //
        // The memory range from 0xc0000 to 0xfffff maps to I/O memory
        //

    case 0xc:
    case 0xd:
    case 0xe:
    case 0xf:
        return (PVOID)(x86BiosIoMemory + Offset + Value);

    DEFAULT_UNREACHABLE;
    }
}

VOID
x86BiosInitializeBios (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

Return Value:

    None.

--*/

{

    //
    // Initialize x86 BIOS emulation.
    //

    x86BiosInitializeBiosShadowed(BiosIoSpace,
                                  BiosIoMemory,
                                  NULL);

    return;
}

VOID
x86BiosInitializeBiosEx (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosTransferMemory,
    IN ULONG TransferLength
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

Return Value:

    None.

--*/

{

    //
    // Initialize x86 BIOS emulation.
    //

    x86BiosInitializeBiosShadowed(BiosIoSpace,
                                  BiosIoMemory,
                                  NULL);

    x86BiosTransferMemory = (ULONG_PTR)BiosTransferMemory;
    x86BiosTransferLength = TransferLength;

    return;
}


VOID
x86BiosInitializeBiosShadowed (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

    BiosFrameBuffer - Supplies the base address of the video frame buffer
        to be used for bios emulation.

Return Value:

    None.

--*/

{

    //
    // Zero low memory.
    //

    memset(&x86BiosLowMemory, 0, LOW_MEMORY_SIZE);

    //
    // Save base address of I/O memory and I/O space.
    //

    x86BiosIoSpace = (ULONG_PTR)BiosIoSpace;
    x86BiosIoMemory = (ULONG_PTR)BiosIoMemory;
    x86BiosFrameBuffer = (ULONG_PTR)BiosFrameBuffer;

    //
    // Initialize the emulator and the BIOS.
    //

    XmInitializeEmulator(0,
                         LOW_MEMORY_SIZE,
                         x86BiosReadIoSpace,
                         x86BiosWriteIoSpace,
                         x86BiosTranslateAddress);

    x86BiosInitialized = TRUE;
    return;
}

VOID
x86BiosInitializeBiosShadowedPci (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    )

/*++

Routine Description:

    This function initializes x86 BIOS emulation and also sets up the
    emulator with BIOS shadowed and PCI functions enabled. Since the
    PCI specification requires BIOS shadowing, there isn't any need
    to provide a function that turns on the PCI functions, but doesn't
    shadow the BIOS.

Arguments:

    BiosIoSpace - Supplies the base address of the I/O space to be used
        for BIOS emulation.

    BiosIoMemory - Supplies the base address of the I/O memory to be
        used for BIOS emulation.

    BiosFrameBuffer - Supplies the base address of the video frame buffer
        to be used for bios emulation.

    NumberPciBusses - Supplies the number of PCI busses in the system.

    GetPciData - Supplies the address of a function to read the PCI
        configuration space.

    SetPciData - Supplies the address of a function to write the PCI
        configuration space.

Return Value:

    None.

--*/

{

    //
    // Enable PCI BIOS support.
    //

    XmPciBiosPresent = TRUE;
    XmGetPciData = GetPciData;
    XmSetPciData = SetPciData;
    XmNumberPciBusses = NumberPciBusses;

    //
    // Initialize x86 BIOS emulation.
    //

    x86BiosInitializeBiosShadowed(BiosIoSpace,
                                  BiosIoMemory,
                                  BiosFrameBuffer);

    return;
}

XM_STATUS
x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    )

/*++

Routine Description:

    This function executes an interrupt by calling the x86 emulator.

Arguments:

    Number - Supplies the number of the interrupt that is to be emulated.

    Context - Supplies a pointer to an x86 context structure.

    BiosIoSpace - Supplies an optional base address of the I/O space
        to be used for BIOS emulation.

    BiosIoMemory - Supplies an optional base address of the I/O memory
        to be used for BIOS emulation.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Execute x86 interrupt.
    //

    return x86BiosExecuteInterruptShadowed(Number,
                                           Context,
                                           BiosIoSpace,
                                           BiosIoMemory,
                                           NULL);
}

XM_STATUS
x86BiosExecuteInterruptShadowed (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    )

/*++

Routine Description:

    This function executes an interrupt by calling the x86 emulator.

Arguments:

    Number - Supplies the number of the interrupt that is to be emulated.

    Context - Supplies a pointer to an x86 context structure.

    BiosIoSpace - Supplies an optional base address of the I/O space
        to be used for BIOS emulation.

    BiosIoMemory - Supplies an optional base address of the I/O memory
        to be used for BIOS emulation.

    BiosFrameBuffer - Supplies an optional base address of the video
        frame buffer to be used for bios emulation.

Return Value:

    The emulation completion status.

--*/

{

    XM_STATUS Status;

    //
    // If a new base address is specified, then set the appropriate base.
    //

    if (BiosIoSpace != NULL) {
        x86BiosIoSpace = (ULONG_PTR)BiosIoSpace;
    }

    if (BiosIoMemory != NULL) {
        x86BiosIoMemory = (ULONG_PTR)BiosIoMemory;
    }

    if (BiosFrameBuffer != NULL) {
        x86BiosFrameBuffer = (ULONG_PTR)BiosFrameBuffer;
    }

    //
    // Execute the specified interrupt.
    //

    Status = XmEmulateInterrupt(Number, Context);
    if (Status != XM_SUCCESS) {
        DbgPrint("HAL: Interrupt emulation failed, status %lx\n", Status);
    }

    return Status;
}

XM_STATUS
x86BiosExecuteInterruptShadowedPci (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    )

/*++

Routine Description:

    This function executes an interrupt by calling the x86 emulator.

Arguments:

    Number - Supplies the number of the interrupt that is to be emulated.

    Context - Supplies a pointer to an x86 context structure.

    BiosIoSpace - Supplies an optional base address of the I/O space
        to be used for BIOS emulation.

    BiosIoMemory - Supplies an optional base address of the I/O memory
        to be used for BIOS emulation.

    NumberPciBusses - Supplies the number of PCI busses in the system.

    GetPciData - Supplies the address of a function to read the PCI
        configuration space.

    SetPciData - Supplies the address of a function to write the PCI
        configuration space.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Enable PCI BIOS support.
    //

    XmPciBiosPresent = TRUE;
    XmGetPciData = GetPciData;
    XmSetPciData = SetPciData;
    XmNumberPciBusses = NumberPciBusses;

    //
    // Execute x86 interrupt.
    //

    return x86BiosExecuteInterruptShadowed(Number,
                                           Context,
                                           BiosIoSpace,
                                           BiosIoMemory,
                                           BiosFrameBuffer);
}

XM_STATUS
x86BiosInitializeAdapter(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    )
/*++

Routine Description:

    This function initializes the adapter whose BIOS starts at the
    specified 20-bit address.

Arguments:

    Adpater - Supplies the 20-bit address of the BIOS for the adapter
        to be initialized.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Initialize the specified adapter.
    //

    return x86BiosInitializeAdapterShadowed(Adapter,
                                            Context,
                                            BiosIoSpace,
                                            BiosIoMemory,
                                            NULL);
}

XM_STATUS
x86BiosInitializeAdapterShadowed (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    )

/*++

Routine Description:

    This function initializes the adapter whose BIOS starts at the
    specified 20-bit address.

Arguments:

    Adpater - Supplies the 20-bit address of the BIOS for the adapter
        to be initialized.

Return Value:

    The emulation completion status.

--*/

{

    PUCHAR Byte;
    XM86_CONTEXT State;
    USHORT Offset;
    USHORT Segment;
    XM_STATUS Status;

    //
    // If BIOS emulation has not been initialized, then return an error.
    //

    if (x86BiosInitialized == FALSE) {
        return XM_EMULATOR_NOT_INITIALIZED;
    }

    //
    // If an emulator context is not specified, then use a default
    // context.
    //

    if (ARGUMENT_PRESENT(Context) == FALSE) {
        State.Eax = 0;
        State.Ecx = 0;
        State.Edx = 0;
        State.Ebx = 0;
        State.Ebp = 0;
        State.Esi = 0;
        State.Edi = 0;
        Context = &State;
    }

    //
    // If a new base address is specified, then set the appropriate base.
    //

    if (BiosIoSpace != NULL) {
        x86BiosIoSpace = (ULONG_PTR)BiosIoSpace;
    }

    if (BiosIoMemory != NULL) {
        x86BiosIoMemory = (ULONG_PTR)BiosIoMemory;
    }

    if (BiosFrameBuffer != NULL) {
        x86BiosFrameBuffer = (ULONG_PTR)BiosFrameBuffer;
    }

    //
    // If the specified adpater is not BIOS code, then return an error.
    //

    Segment = (USHORT)((Adapter >> 4) & 0xf000);
    Offset = (USHORT)(Adapter & 0xffff);
    Byte = (PUCHAR)x86BiosTranslateAddress(Segment, Offset);

    if ((*Byte++ != 0x55) || (*Byte != 0xaa)) {
        return XM_ILLEGAL_CODE_SEGMENT;
    }

    //
    // Call the BIOS code to initialize the specified adapter.
    //

    Adapter += 3;
    Segment = (USHORT)((Adapter >> 4) & 0xf000);
    Offset = (USHORT)(Adapter & 0xffff);
    Status = XmEmulateFarCall(Segment, Offset, Context);
    if (Status != XM_SUCCESS) {
        DbgPrint("HAL: Adapter initialization falied, status %lx\n", Status);
    }
    return Status;
}

XM_STATUS
x86BiosInitializeAdapterShadowedPci(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    )

/*++

Routine Description:

    This function initializes the adapter whose BIOS starts at the
    specified 20-bit address.

Arguments:

    Adpater - Supplies the 20-bit address of the BIOS for the adapter
        to be initialized.

Return Value:

    The emulation completion status.

--*/

{

    //
    // Enable PCI BIOS support.
    //

    XmPciBiosPresent = TRUE;
    XmGetPciData = GetPciData;
    XmSetPciData = SetPciData;
    XmNumberPciBusses = NumberPciBusses;

    //
    // Initialize the specified adapter.
    //

    return x86BiosInitializeAdapterShadowed(Adapter,
                                            Context,
                                            BiosIoSpace,
                                            BiosIoMemory,
                                            BiosFrameBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\x86new.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86new.h

Abstract:

    This module contains the public header file that describes the
    HAL interfaces to the 386/486 BIOS emulation.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _X86NEW_
#define _X86NEW_

//
// PCI Bios function code defintitions.
//
// AH:
//

#define PCI_FUNCTION_ID         0xb1

//
// AL:
//

#define PCI_BIOS_PRESENT        0x01
#define PCI_FIND_DEVICE         0x02
#define PCI_FIND_CLASS_CODE     0x03
#define PCI_GENERATE_CYCLE      0x06
#define PCI_READ_CONFIG_BYTE    0x08
#define PCI_READ_CONFIG_WORD    0x09
#define PCI_READ_CONFIG_DWORD   0x0a
#define PCI_WRITE_CONFIG_BYTE   0x0b
#define PCI_WRITE_CONFIG_WORD   0x0c
#define PCI_WRITE_CONFIG_DWORD  0x0d
#define PCI_GET_IRQ_ROUTING     0x0e
#define PCI_SET_IRQ             0x0f

//
// PCI Bios function return code values.
//

#define PCI_SUCCESS             0x00
#define PCI_NOT_SUPPORTED       0x81
#define PCI_BAD_VENDOR_ID       0x83
#define PCI_DEVICE_NOT_FOUND    0x86
#define PCI_BAD_REGISTER        0x87
#define PCI_SET_FAILED          0x88
#define PCI_BUFFER_TOO_SMALL    0x89

//
// Miscellaneous PCI codes.
//

#define PCI_CONFIG_MECHANISM_2  0x02
#define PCI_ILLEGAL_VENDOR_ID   0xffff

//
// Define PCI get/set function type.
//

typedef
ULONG
(*PGETSETPCIBUSDATA)(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Define BIOS emulation interfaces.
//

VOID
x86BiosInitializeBios (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory
    );

VOID
x86BiosInitializeBiosEx (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosTransferMemory,
    IN ULONG TransferLength
    );

VOID
x86BiosInitializeBiosShadowed (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer
    );

VOID
x86BiosInitializeBiosShadowedPci (
    IN PVOID BiosIoSpace,
    IN PVOID BiosIoMemory,
    IN PVOID BiosFrameBuffer,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowed (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosExecuteInterruptShadowedPci (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

XM_STATUS
x86BiosInitializeAdapter (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowed (
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL
    );

XM_STATUS
x86BiosInitializeAdapterShadowedPci(
    IN ULONG Adapter,
    IN OUT PXM86_CONTEXT Context OPTIONAL,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL,
    IN PVOID BiosFrameBuffer OPTIONAL,
    IN UCHAR NumberPciBusses,
    IN PGETSETPCIBUSDATA GetPciData,
    IN PGETSETPCIBUSDATA SetPciData
    );

#endif // _X86NEW_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\x86new\xm86.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    xm86.h

Abstract:

    This module contains the public header file that describes the
    interfaces to the 386/486 real mode emulator.

Author:

    David N. Cutler (davec) 13-Nov-1994

Revision History:

--*/

#ifndef _XM86_
#define _XM86_

//
// Define internal error codes.
//

typedef enum _XM_STATUS {
    XM_SUCCESS = 1,
    XM_DIVIDE_BY_ZERO,
    XM_DIVIDE_QUOTIENT_OVERFLOW,
    XM_EMULATOR_NOT_INITIALIZED,
    XM_HALT_INSTRUCTION,
    XM_ILLEGAL_CODE_SEGMENT,
    XM_ILLEGAL_INDEX_SPECIFIER,
    XM_ILLEGAL_LEVEL_NUMBER,
    XM_ILLEGAL_PORT_NUMBER,
    XM_ILLEGAL_GENERAL_SPECIFIER,
    XM_ILLEGAL_REGISTER_SPECIFIER,
    XM_ILLEGAL_INSTRUCTION_OPCODE,
    XM_INDEX_OUT_OF_BOUNDS,
    XM_SEGMENT_LIMIT_VIOLATION,
    XM_STACK_OVERFLOW,
    XM_STACK_UNDERFLOW,
    XM_MAXIMUM_INTERNAL_CODE
} XM_STATUS;

//
// Define operand data types.
//

typedef enum _XM_OPERATION_DATATYPE {
    BYTE_DATA = 0,
    WORD_DATA = 1,
    LONG_DATA = 3
} XM_OPERATION_DATATYPE;

//
// Define emulator context structure.
//

typedef struct _XM86_CONTEXT {
    ULONG Eax;
    ULONG Ecx;
    ULONG Edx;
    ULONG Ebx;
    ULONG Ebp;
    ULONG Esi;
    ULONG Edi;
    USHORT SegDs;
    USHORT SegEs;
} XM86_CONTEXT, *PXM86_CONTEXT;

//
// Define address translation callback function type.
//

typedef
PVOID
(*PXM_TRANSLATE_ADDRESS) (
    IN USHORT Segment,
    IN USHORT Offset
    );

//
// Define read and write I/O space callback function types.
//

typedef
ULONG
(*PXM_READ_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    );

typedef
VOID
(*PXM_WRITE_IO_SPACE) (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    );

//
// Define emulator public interface function prototypes.
//

XM_STATUS
XmEmulateFarCall (
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    );

XM_STATUS
XmEmulateInterrupt (
    IN UCHAR Interrupt,
    IN OUT PXM86_CONTEXT Context
    );

VOID
XmInitializeEmulator (
    IN USHORT StackSegment,
    IN USHORT StackOffset,
    IN PXM_READ_IO_SPACE ReadIoSpace,
    IN PXM_WRITE_IO_SPACE WriteIoSpace,
    IN PXM_TRANSLATE_ADDRESS TranslateAddress
    );

#endif // _XM86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\bootini.h ===
//***************************************************************************
//
//  bootini.h
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#ifndef _bootini_H_
#define _bootini_H_

#include <wbemprov.h>
#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <wbemcli.h>

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CBootInstPro : public IWbemServices, public IWbemProviderInit
{
protected:
    ULONG              m_cRef;         //Object reference count
    IWbemServices *  m_pNamespace;
public:
    CBootInstPro(BSTR ObjectPath = NULL, BSTR User = NULL, BSTR Password = NULL, IWbemContext * pCtx=NULL);
    ~CBootInstPro(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(LPWSTR pszUser,
                                         LONG lFlags,
                                         LPWSTR pszNamespace,
                                         LPWSTR pszLocale,
                                         IWbemServices *pNamespace,
                                         IWbemContext *pCtx,
                                         IWbemProviderInitSink *pInitSink
                                         );

    //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace( const BSTR Namespace,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
                                             IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT STDMETHODCALLTYPE CancelAsyncCall( IWbemObjectSink __RPC_FAR *pSink) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE QueryObjectSink(long lFlags,
                                              IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
                                              ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE GetObject(const BSTR ObjectPath,
                                        long lFlags,
                                        IWbemContext __RPC_FAR *pCtx,
                                        IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
                                        IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                        ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE GetObjectAsync(const BSTR ObjectPath,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemObjectSink __RPC_FAR *pResponseHandler
                                             );
        
    HRESULT STDMETHODCALLTYPE PutClass(IWbemClassObject __RPC_FAR *pObject,
                                       long lFlags,
                                       IWbemContext __RPC_FAR *pCtx,
                                       IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                       )
     {
         return WBEM_E_NOT_SUPPORTED;
    };
    
    HRESULT STDMETHODCALLTYPE PutClassAsync(IWbemClassObject __RPC_FAR *pObject,
                                            long lFlags,
                                            IWbemContext __RPC_FAR *pCtx,
                                            IWbemObjectSink __RPC_FAR *pResponseHandler
                                            ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE DeleteClass(const BSTR Class,
                                          long lFlags,
                                          IWbemContext __RPC_FAR *pCtx,
                                          IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                          )
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE DeleteClassAsync(const BSTR Class,
                                               long lFlags,
                                               IWbemContext __RPC_FAR *pCtx,
                                               IWbemObjectSink __RPC_FAR *pResponseHandler
                                               ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum(const BSTR Superclass,
                                              long lFlags,
                                              IWbemContext __RPC_FAR *pCtx,
                                              IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
                                              ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(const BSTR Superclass,
                                                   long lFlags,
                                                   IWbemContext __RPC_FAR *pCtx,
                                                   IWbemObjectSink __RPC_FAR *pResponseHandler
                                                   ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE PutInstance(IWbemClassObject __RPC_FAR *pInst,
                                          long lFlags,
                                          IWbemContext __RPC_FAR *pCtx,
                                          IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                          ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE PutInstanceAsync(IWbemClassObject __RPC_FAR *pInst,
                                               long lFlags,
                                               IWbemContext __RPC_FAR *pCtx,
                                               IWbemObjectSink __RPC_FAR *pResponseHandler
                                               );
        
    HRESULT STDMETHODCALLTYPE DeleteInstance(const BSTR ObjectPath,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
                                             ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(const BSTR ObjectPath,
                                                  long lFlags,
                                                  IWbemContext __RPC_FAR *pCtx,
                                                  IWbemObjectSink __RPC_FAR *pResponseHandler
                                                  ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum(const BSTR Class,
                                                 long lFlags,
                                                 IWbemContext __RPC_FAR *pCtx,
                                                 IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
                                                 ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(const BSTR Class,
                                                      long lFlags,
                                                      IWbemContext __RPC_FAR *pCtx,
                                                      IWbemObjectSink __RPC_FAR *pResponseHandler
                                                      )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    HRESULT STDMETHODCALLTYPE ExecQuery(const BSTR QueryLanguage,
                                        const BSTR Query,
                                        long lFlags,
                                        IWbemContext __RPC_FAR *pCtx,
                                        IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecQueryAsync(const BSTR QueryLanguage,
                                             const BSTR Query,
                                             long lFlags,
                                             IWbemContext __RPC_FAR *pCtx,
                                             IWbemObjectSink __RPC_FAR *pResponseHandler
                                             ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery(const BSTR QueryLanguage,
                                                    const BSTR Query,
                                                    long lFlags,
                                                    IWbemContext __RPC_FAR *pCtx,
                                                    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
                                                    ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(const BSTR QueryLanguage,
                                                         const BSTR Query,
                                                         long lFlags,
                                                         IWbemContext __RPC_FAR *pCtx,
                                                         IWbemObjectSink __RPC_FAR *pResponseHandler
                                                         ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    };
        
    HRESULT STDMETHODCALLTYPE ExecMethod(const BSTR, 
                                         const BSTR, 
                                         long, IWbemContext*,
                                         IWbemClassObject*, 
                                         IWbemClassObject**, 
                                         IWbemCallResult**
                                         ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT STDMETHODCALLTYPE ExecMethodAsync(const BSTR, 
                                              const BSTR, 
                                              long,
                                              IWbemContext*, 
                                              IWbemClassObject*, 
                                              IWbemObjectSink*
                                              ) 
    {
        return WBEM_E_NOT_SUPPORTED;
    }

};

typedef CBootInstPro *PCBootInstPro;

// This class is the class factory for CInstPro objects.

class CBootProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CBootProvFactory(void);
        ~CBootProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, 
                                            REFIID,
                                            PPVOID
                                            );

        STDMETHODIMP         LockServer(BOOL);
    };

typedef CBootProvFactory *PCBootProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

// General purpose utilities.  

SCODE 
GetBootLoaderParameters(IWbemServices *m_pNamespace,
                        IWbemClassObject *pNewInst,
                        IWbemContext  *pCtx
                        ); 

extern "C" BOOL WINAPI LibMain32(HINSTANCE hInstance, 
                                 ULONG ulReason, 
                                 LPVOID pvReserved
                                 );

LONG 
SaveBootFile(IWbemClassObject *pInst,
             IWbemClassObject *pClass
             );


HANDLE GetFileHandle(PCHAR data,
                     DWORD dwCreationDisposition,
                     DWORD dwAccess
                     );
PCHAR
GetBootFileName(
    );

typedef struct {
    CHAR Default[256];
    long Delay;
    CHAR Redirect[32];
} BootLoaderParams;
#if DBG==1
LPVOID BPAlloc(int len);
VOID BPFree(LPVOID mem);
#else
#define BPAlloc(x) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x)
#define BPFree(x) HeapFree(GetProcessHeap(), 0, x)
#endif
extern BootLoaderParams blp;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\bootinstprov.cpp ===
//***************************************************************************
//
//  INSTPRO.CPP
//
//  Module: WMI Instance provider code for Boot Parameters
//
//  Purpose: Defines the CInstPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "bootini.h"
#include <process.h>


//***************************************************************************
//
// CBootInstPro::CBootInstPro
// CBootInstPro::~CInstPro
//
//***************************************************************************

CBootInstPro::CBootInstPro(BSTR ObjectPath, BSTR User, BSTR Password, IWbemContext * pCtx)
{
    m_pNamespace = NULL;
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    return;
}

CBootInstPro::~CBootInstPro(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CBootInstPro::QueryInterface
// CBootInstPro::AddRef
// CBootInstPro::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************


STDMETHODIMP CBootInstPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CBootInstPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBootInstPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CBootInstPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CBootInstPro::Initialize(LPWSTR pszUser,
                                  LONG lFlags,
                                  LPWSTR pszNamespace,
                                  LPWSTR pszLocale,
                                  IWbemServices *pNamespace, 
                                  IWbemContext *pCtx,
                                  IWbemProviderInitSink *pInitSink
                                  )
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}




//***************************************************************************
//
// CBootInstPro::GetObjectByPath
// CBootInstPro::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CBootInstPro::GetObjectAsync(const BSTR ObjectPath,
                                   long lFlags,
                                   IWbemContext  *pCtx,
                                   IWbemObjectSink FAR* pHandler
                                   )
{
    SCODE sc;
    int iCnt;
    IWbemClassObject FAR* pNewInst;
    IWbemClassObject FAR* pNewOSInst;
    IWbemClassObject *pClass;
  

    // Do a check of arguments and make sure we have pointer to Namespace

    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;
    if(wcscmp(ObjectPath,L"BootLoaderParameters=@") == 0){
        // fill in the loader parameters and return
        sc = m_pNamespace->GetObject(L"BootLoaderParameters", 0, pCtx, &pClass, NULL);
        if(sc != S_OK){
            return WBEM_E_FAILED;
        }
        sc = pClass->SpawnInstance(0,&pNewInst);
        if(FAILED(sc)){
            return sc;
        }
        pClass->Release();
        sc = GetBootLoaderParameters(m_pNamespace, pNewInst, pCtx);
        if(sc != S_OK){
            pNewInst->Release();
            return sc;
        }
        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
        pHandler->SetStatus(0,sc,NULL, NULL);
        return S_OK;
    }
    return WBEM_E_INVALID_PARAMETER;
 
}

SCODE CBootInstPro::PutInstanceAsync(IWbemClassObject *pInst,
                                     long lFlags,
                                     IWbemContext  *pCtx,
                                     IWbemObjectSink FAR* pHandler
                                     )
{
    IWbemClassObject *pClass;
    IWbemClassObject *pOldInst;
    SCODE sc;


    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;
    sc = m_pNamespace->GetObject(L"OSParameters", 0, pCtx, &pClass, NULL);
    if(sc != S_OK){
        return WBEM_E_FAILED;
    }
    
    LONG ret = SaveBootFile(pInst,pClass);
    pClass->Release();
    if (ret) {
        return WBEM_E_FAILED;
    }
    pHandler->SetStatus(0,sc,NULL, NULL);
    return WBEM_S_NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\debug.cpp ===
#include "bootini.h"

#if DBG==1
VOID LogTrace(ULONG trace,
             PCHAR str
             )
{
    DWORD len;

    HANDLE fh = CreateFile("bootinstprov.log",
                           GENERIC_READ|GENERIC_WRITE,
                           0,// Exclusive Access
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH,
                           NULL
                           );
    len = SetFilePointer(fh,
                         0,
                         NULL,
                         FILE_END
                         );
    if (fh != INVALID_HANDLE_VALUE) {
        WriteFile(fh,
                  str,
                  strlen(str),
                  &len,
                  NULL
                  );
        CloseHandle(fh);
    }
    return;


}
LPVOID BPAlloc(int len)
{

    LPVOID mem = HeapAlloc(GetProcessHeap(),
                           HEAP_ZERO_MEMORY,
                           len);
    CHAR buffer[256];
    sprintf(buffer, "Allocated %d at memory 0x%x\n", len, mem);
    LogTrace(0, buffer);
    return mem;

}

VOID
BPFree(LPVOID mem)
{
    BOOL ret = HeapFree(GetProcessHeap(),
                        0,
                        mem
                        );
    CHAR buffer[256];
    if(ret){
        sprintf(buffer, "Freed at memory 0x%x with TRUE\n",mem);
    }
    else{
        sprintf(buffer, "Freed at memory 0x%x with FALSE\n",mem);
    }
    LogTrace(0, buffer);
    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "bootini.h"

//***************************************************************************
//
// CBootProvFactory::CBootProvFactory
// CBootProvFactory::~CBootProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CBootProvFactory::CBootProvFactory()
{
    m_cRef=0L;
    return;
}

CBootProvFactory::~CBootProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CBootProvFactory::QueryInterface
// CBootProvFactory::AddRef
// CBootProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CBootProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBootProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBootProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CBootProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CBootProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    CBootInstPro *   pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj=new CBootInstPro();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
// CBootProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CBootProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\getparams.cpp ===
//***************************************************************************
//
//  getparams.cpp
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Extracting boot parameters.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include "bootini.h"

SCODE ParseLine(IWbemClassObject *pNewOSInst,
                PCHAR line,
                PCHAR options
                )
{
    PCHAR rest; // the rest of the options cannot be bigger than this.
    int size = strlen(line);
    int len;
    SCODE sc;
    VARIANT v;
    BOOL found=FALSE;

    rest = (PCHAR) BPAlloc(size);
    if (!rest) {
        return WBEM_E_FAILED;
    }
    PWCHAR wstr;
    wstr = (PWCHAR) BPAlloc(size*sizeof(WCHAR));
    if (!wstr) {
        BPFree(rest);
        return WBEM_E_FAILED;
    }
    
    *options = 0; //Later fill in the '=' 
    len = MultiByteToWideChar(CP_ACP,
                              0,
                              line,
                              strlen(line),
                              wstr,
                              size
                              );
    wstr[len] = (WCHAR) 0;
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(wstr);
    sc = pNewOSInst->Put(L"Directory", 0,&v, 0);
    VariantClear(&v);
    PCHAR temp = options + 1;
    *options = '=';
    PCHAR temp1;
    // Rest of the stuff is filled in during initialization
    while(*temp){ // We know line ends with a null
        while(*temp && *temp == ' '){
            temp ++;
        }
        if(*temp == 0) break;
        // Get the new string 
        temp1 = temp;
        if(*temp == '"'){
            // could be the name of the OS
            do {
                temp1++;
            }while(*temp1 && (*temp1 != '"'));
            if(*temp1){
                temp1++;
            }
            else{
                BPFree(rest);
                BPFree(wstr);
                return WBEM_E_FAILED;
            }
            len = MultiByteToWideChar(CP_ACP,
                                      0,
                                      temp,
                                      temp1-temp,
                                      wstr,
                                      size
                                      );
            wstr[len] = (WCHAR) 0;
            v.vt = VT_BSTR;
            v.bstrVal = SysAllocString(wstr);
            sc = pNewOSInst->Put(L"OperatingSystem", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }
        do{
            temp1++;
        }while((*temp1) && (*temp1 != ' ') && (*temp1 != '/'));
                 // Now we have the option between temp1 and temp2.
        if(strncmp(temp,"/redirect", strlen("/redirect")) == 0){
            v.vt = VT_BOOL;
            v.boolVal = TRUE;
            sc = pNewOSInst->Put(L"Redirect", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }
        if(strncmp(temp,"/debug", strlen("/debug")) == 0){
            // fill in the redirect flag.
            v.vt = VT_BOOL;
            v.boolVal = TRUE;
            sc = pNewOSInst->Put(L"Debug", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }

        if(strncmp(temp,"/fastdetect", strlen("/fastdetect")) == 0){
            // fill in the redirect flag.
            v.vt = VT_BOOL;
            v.boolVal = TRUE;
            sc = pNewOSInst->Put(L"Fastdetect", 0,&v, 0);
            VariantClear(&v);
            temp = temp1;
            continue;
        }
        strncat(rest,temp, temp1-temp);
        strcat(rest," ");
        temp = temp1;
    }
    len = MultiByteToWideChar(CP_ACP,
                              0,
                              rest,
                              strlen(rest),
                              wstr,
                              size
                              );
    wstr[len] = (WCHAR) 0;
    v.vt=VT_BSTR;
    v.bstrVal = SysAllocString(wstr);
    sc = pNewOSInst->Put(L"Rest", 0,&v, 0);
    VariantClear(&v);
    BPFree(rest);
    BPFree(wstr);
    return sc;
}


SCODE
ParseBootFile(IWbemClassObject *pClass,
              PCHAR data, 
              PWCHAR *wdef, 
              PCHAR red,
              PLONG pdelay,
              SAFEARRAY **psa
              )
{
    IWbemClassObject FAR* pNewOSInst;
    HRESULT ret;
    int dwRet;
    SCODE sc;
    SAFEARRAYBOUND bound[1];
    long index;
    PCHAR def=NULL;
    PCHAR pChar;
    VARIANT v;
    HRESULT hret;
    CIMTYPE type;
    
    // Ok, start string manipulation.

    // Read each line and glean the required information
    CHAR sep[] = "\r\n";
    PCHAR temp1;

    PCHAR temp = strtok(data,sep);
    int i = 0;
    strcpy(red,"no"); // Put in the default values for these.
    *pdelay = 30;
    while(temp){
        // Ignore spaces
        while(*temp && *temp == ' '){
            temp++;
        }
        if(*temp == ';'){// comment line
            temp = strtok(NULL,sep);
            continue;
        }
        if(strncmp(temp,"[boot loader]",strlen("[boot loader]"))==0){
            do{
                temp1 = strchr(temp,'=');
                if(!temp1){
                    // weird stuff is going on
                    // could be a comment line or some such thing
                    temp = strtok(NULL,sep);
                    continue;
                }
                else{
                    temp1++;
                }
                while(*temp1 && *temp1 == ' ' ){
                    temp1++;
                }
                if(strncmp(temp,"default",strlen("default"))==0){
                    def= temp1;
                    temp = strtok(NULL,sep);
                    continue;
                }
                if(strncmp(temp,"redirect",strlen("redirect"))==0){
                    sscanf(temp1, "%s",red);
                    temp = strtok(NULL,sep);
                    continue;
                }
                if(strncmp(temp,"timeout=",strlen("timeout="))==0){
                    sscanf(temp1, "%d",pdelay);
                }
                temp = strtok(NULL,sep);
            }while(temp && (*temp != '[')); // next section has begun
            continue;
        }
        if(strncmp(temp,"[operating systems]",strlen("[operating systems]")) == 0){
            bound[0].lLbound = 0;
            bound[0].cElements = 0;
            *psa = SafeArrayCreate(VT_UNKNOWN,
                                   1,
                                   bound
                                   );  

            if(*psa == NULL){
                return WBEM_E_FAILED;
            }
            do{

                // Trim leading spaces
                while (*temp == ' '){
                    temp ++;
                }
                // Skip comment lines
                if ( *temp != ';' ){
                    // pChar will point at the directory

                    PCHAR pChar = strchr(temp,'=');

                    // We must have an = sign or this is an invalid string

                    if (pChar){
                        // Punch in a null
                        // Increase the number of elements
                        index = (long) bound[0].cElements;
                        bound[0].cElements += 1;
                        ret = SafeArrayRedim(*psa,
                                             bound
                                             );
                        if(ret != S_OK){
                            SafeArrayDestroy(*psa);
                            return WBEM_E_FAILED;
                        }
                        sc = pClass->SpawnInstance(0,&pNewOSInst);
                        // Start filling in the new instance
                        if(FAILED(sc)){
                            SafeArrayDestroy(*psa);
                            return sc;
                        }
                        sc = ParseLine(pNewOSInst,temp,pChar);
                        if (sc != S_OK) {
                            SafeArrayDestroy(*psa);
                            return sc;
                        }
                        ret = SafeArrayPutElement(*psa,
                                                  &index,
                                                  pNewOSInst
                                                  );
                        if(ret != S_OK){
                            SafeArrayDestroy(*psa);
                            return WBEM_E_FAILED;
                        }
                    }
                }
                temp = strtok(NULL,sep);
            }while(temp && (*temp != '['));
        }
    }

    // Now find out if the default operating system is in one of the
    // Convert the default string to a proper displayable value.
    if(def){
        int size = strlen(def);
        int len;
        *wdef = (PWCHAR) BPAlloc((size+1)*sizeof(WCHAR));
        
        if(*wdef == NULL){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        len = MultiByteToWideChar(CP_ACP,
                                  0,
                                  def,
                                  size,
                                  *wdef,
                                  size
                                  );
        (*wdef)[len] = (WCHAR) 0;
        LONG uBound;
        IWbemClassObject *pOSInst;
        hret = SafeArrayGetUBound(*psa,
                                  1,
                                  &uBound
                                  );
        LONG i;
        for(i = 0; i<=uBound; i++){
            hret = SafeArrayGetElement(*psa,
                                       &i,
                                       &pOSInst
                                       );
            if(hret != S_OK){
                pOSInst->Release();
                SafeArrayDestroy(*psa);
                BPFree(*wdef);
                return WBEM_E_FAILED;
            }
            hret = pOSInst->Get(L"Directory",
                                0,
                                &v,
                                &type,
                                NULL
                                );
            if(hret != WBEM_S_NO_ERROR){
                SafeArrayDestroy(*psa);
                pOSInst->Release();
                BPFree(*wdef);
                return -1;
            }
            if(v.vt != VT_BSTR){
                SafeArrayDestroy(*psa);
                pOSInst->Release();
                BPFree(*wdef);
                return -1;
            }
            if(wcscmp(v.bstrVal,*wdef) == 0){
                VariantClear(&v);
                break;
            }
        }
        BPFree(*wdef);
        if(i > uBound){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        hret=pOSInst->Get(L"OperatingSystem",
                          0,
                          &v,
                          &type,
                          NULL
                          );
        pOSInst->Release();
        if(hret != WBEM_S_NO_ERROR){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        if(v.vt != VT_BSTR){
            SafeArrayDestroy(*psa);
            return WBEM_E_FAILED;
        }
        *wdef = (PWCHAR) BPAlloc(wcslen(v.bstrVal) + sizeof(WCHAR));
        if(*wdef == NULL){
            return -1;
        }
        wcscpy(*wdef,v.bstrVal);
        VariantClear(&v);
    }
    return S_OK;
}

SCODE
GetLoaderParameters(HANDLE BootFile,
                    IWbemClassObject *pNewInst,
                    IWbemClassObject *pClass
                    )
{
    // Read the entire file into memory if you can otherwise forget about it. 
    VARIANT v;
    LONG dwret;
    SCODE sc;
    DWORD dwlen;


    DWORD dwsize = GetFileSize(BootFile,
                               NULL
                               );
    if(dwsize == -1){
        return WBEM_E_FAILED;
    }
    PCHAR data =(PCHAR)  BPAlloc(dwsize + sizeof(CHAR));
    if(!data){
        return WBEM_E_FAILED;
    }
    dwret = ReadFile(BootFile,
                     (LPVOID) data,
                     dwsize,
                     &dwlen,
                     NULL
                     );

    if(dwret == 0){
        BPFree(data);
        return GetLastError();
    }
    
    // Parse the code and return the answers in two arrays, and a safe array
    SAFEARRAY *psa;
    CHAR red[32];
    LONG delay;
    PWCHAR wdef=NULL;
    sc = ParseBootFile(pClass,
                       data, 
                       &wdef, 
                       red,
                       &delay,
                       &psa
                       );
    
    BPFree(data);
    if (sc != S_OK) {
        return sc;
    }

    // fill in the New Instance

    // Fill in the default OS.
    v.vt = VT_BSTR;
    int len;
    v.bstrVal = SysAllocString(wdef);
    sc = pNewInst->Put(L"Default", 0,&v, 0);
    VariantClear(&v);
    BPFree(wdef);
    
    //Fill in the redirect parameter
    WCHAR wred[32];
    len = MultiByteToWideChar(CP_ACP,
                              0,
                              red,
                              strlen(red),
                              wred,
                              32
                              );
    wred[len] = (WCHAR) 0;
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(wred);
    sc = pNewInst->Put(L"Redirect", 0, &v, 0);
    VariantClear(&v);

    // Fill in the delay

    v.vt = VT_I4;
    v.lVal = delay;
    sc = pNewInst->Put(L"Delay", 0, &v, 0);
    VariantClear(&v);

    // Fill in the OS in the file
    v.vt = VT_ARRAY|VT_UNKNOWN;
    v.parray = psa;
    sc = pNewInst->Put(L"operating_systems", 0, &v, 0);
    VariantClear(&v);
    return S_OK;
}

//BOOLEAN first=TRUE;

SCODE
GetBootLoaderParameters(IWbemServices * m_pNamespace,
                        IWbemClassObject *pNewInst,
                        IWbemContext *pCtx
                        )
{
    HANDLE BootFile;
    SCODE sc;
    IWbemClassObject *pClass;
    IWbemObjectTextSrc *pSrc;
    BSTR strText;
    HRESULT hr;
/*
    if (first) {
        first = FALSE;
        return WBEM_E_FAILED;
    }
*/
    // Read the file and set in the values.
    if(pNewInst == NULL){
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get a handle to the boot file.
    PCHAR data = GetBootFileName();
    if(!data){
        return WBEM_E_FAILED;
    }
    BootFile = GetFileHandle(data,OPEN_EXISTING,GENERIC_READ);
    BPFree(data);
    if(BootFile == INVALID_HANDLE_VALUE){
        return WBEM_E_FAILED;
    }
    sc = m_pNamespace->GetObject(L"OSParameters", 0, pCtx, &pClass, NULL);
    if (sc != S_OK) {
        return WBEM_E_FAILED;
    }
    sc = GetLoaderParameters(BootFile, pNewInst, pClass);
    CloseHandle(BootFile);
    pClass->Release();
    if (sc != S_OK) {
        return WBEM_E_FAILED;
    }

    pSrc = NULL;
    IWbemClassObject *pInstance;

    if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER,                            
                                        IID_IWbemObjectTextSrc, (void**) &pSrc))) {
        if (pSrc) {
            if(SUCCEEDED(hr = pSrc->GetText(0, pNewInst, WMI_OBJ_TEXT_WMI_DTD_2_0, pCtx, &strText))) {
                if( SUCCEEDED( hr = pSrc->CreateFromText( 0, strText, WMI_OBJ_TEXT_WMI_DTD_2_0, 
                                                            NULL, &pInstance) ) ) {
                    pInstance->Release();
                    sc = 0;
                } else {
                    sc = hr;
                }
                SysFreeString(strText);
            }
            else {
                printf("GetText failed with %x\n", hr);
            }
            pSrc->Release();
        }

    }
    else
        printf("CoCreateInstance on WbemObjectTextSrc failed with %x\n", hr);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\save.cpp ===
//***************************************************************************
//
//  save.cpp
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Saving boot parameters.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************
#include "bootini.h"

VOID
WriteStringToFile(HANDLE fh,
                  PCHAR str
                  )
{
    DWORD dwlen;
    BOOL ret = WriteFile(fh,
                         str,
                         strlen(str),
                         &dwlen,
                         NULL
                         );
}


ULONG
WriteDefaultParams(IWbemClassObject *pInst,
                   PCHAR data,
                   PCHAR def,
                   SAFEARRAY *psa,
                   HANDLE BootFile,
                   PWCHAR wredir
                   )
{
    VARIANT v,v1;
    CIMTYPE type;
    IWbemClassObject *pOSInst;
    int wlen, slen;
    int len;
    PCHAR str;
    BOOL found;
    
    HRESULT hret = pInst->Get(L"Default",
                              0,
                              &v,
                              &type,
                              NULL
                              );
    if(hret != WBEM_S_NO_ERROR){
        return -1;
    }
    if(v.vt != VT_BSTR){
        return -1;
    }
    LONG uBound;
    hret = SafeArrayGetUBound(psa,
                              1,
                              &uBound
                              );
    for(LONG i = 0; i<=uBound; i++){
        hret = SafeArrayGetElement(psa,
                                   &i,
                                   &pOSInst
                                   );
        if(hret != S_OK){
            pOSInst->Release();
            return -1;
        }
        hret = pOSInst->Get(L"OperatingSystem",
                            0,
                            &v1,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            pOSInst->Release();
            return -1;
        }
        if(v1.vt != VT_BSTR){
            pOSInst->Release();
            return -1;
        }
        if(wcscmp(v.bstrVal,v1.bstrVal) == 0){
            break;
        }
        pOSInst->Release();
    }
    VariantClear(&v);
    VariantClear(&v1);
    PCHAR temp;
    if(i <= uBound){
        hret = pOSInst->Get(L"Directory",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            pOSInst->Release();
            return -1;
        }
        wlen = wcslen(v.bstrVal);
        slen = wlen*sizeof(WCHAR) + 1;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   v.bstrVal,
                                   wlen,
                                   str,
                                   slen-1,
                                   NULL,
                                   NULL
                                   );
        str[len] = (CHAR)0;
        // check to see if this is a valid directory 
        temp = strstr(data,"[operating system]");
        found = FALSE;
        if(temp){
            do{
                // Remove all white spaces
                while(*temp == ' ' || *temp == '\r' || *temp == '\n'){
                    temp ++;
                }
                // check 
                if(strncmp(str,temp,strlen(str)) == 0){
                    found = TRUE;
                    WriteStringToFile(BootFile,
                                      "default="
                                      );
                    WriteStringToFile(BootFile,
                                      str
                                      );
                    WriteStringToFile(BootFile,
                                      "\r\n"
                                      );
                    break;

                }
                // Go to next line
                while(*temp && (*temp != '\r' || *temp != '\n')){
                    temp ++;
                }
            }while (*temp && *temp != '[');
        }
        BPFree(str);
        VariantClear(&v);
        pOSInst->Release();
    }
    if((found == FALSE) && def){
        WriteStringToFile(BootFile,
                          def
                          );
        WriteStringToFile(BootFile,
                          "\r\n"
                          );
    }
    if(wcscmp(wredir,L"no")){
        wlen = wcslen(wredir);
        slen = wlen*sizeof(WCHAR) + 2;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   wredir,
                                   wlen,
                                   str,
                                   slen,
                                   NULL,
                                   NULL
                                   );
        str[len] = (CHAR)0;
        WriteStringToFile(BootFile,
                          "redirect="
                          );
        WriteStringToFile(BootFile,
                          str
                          );
        WriteStringToFile(BootFile,
                          "\r\n"
                          );
        BPFree(str);
    }
    hret = pInst->Get(L"Delay",
                      0,
                      &v,
                      &type,
                      NULL
                      );
    if(hret != WBEM_S_NO_ERROR){
        return -1;
    }

    if(v.vt != VT_I4){
        return -1;
    }
    str = (PCHAR) BPAlloc(32);
    sprintf(str, "%d",v.lVal);
    WriteStringToFile(BootFile,
                      "timeout="
                      );
    WriteStringToFile(BootFile,
                      str
                      );
    WriteStringToFile(BootFile,
                      "\r\n"
                      );
    BPFree(str);
    return 0;

}

LONG
WriteOSLine(HANDLE fh,
            PCHAR line,
            PCHAR pchar,
            SAFEARRAY *psa,
            SAFEARRAY *org,
            IWbemClassObject *pClass,
            BOOL redir
            )
{
    // Search through the entire instance for the 
    // necessary line
    VARIANT v;
    IWbemClassObject *pOSInst;
    HRESULT hret;
    CIMTYPE type;
    int slen,wlen;
    PCHAR str;
    BOOL found = FALSE;
    SAFEARRAYBOUND sb;

    // Code is rendered really inefficient because of error checking 
    // maybe should use the exception mechanism to take care of all 
    // these errors.

    PWCHAR wdata = (PWCHAR)BPAlloc((pchar - line + 1)*sizeof(WCHAR) 
                                   );
    if(!wdata){
        return -1;
    }
    int len =  MultiByteToWideChar(CP_ACP,
                                   0,
                                   line,
                                   pchar-line,
                                   wdata,
                                   pchar-line
                                   );
    wdata[len] = (WCHAR)0;
    LONG uBound;
    hret = SafeArrayGetUBound(org,
                              1,
                              &uBound
                              );
    if (hret != S_OK) {
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
        BPFree(wdata);
        return 0;
    }
    for(LONG i = 0;i <= uBound; i++){
        hret = SafeArrayGetElement(org,
                                   &i,
                                   &pOSInst
                                   );
        if(hret != S_OK){
            BPFree(wdata);
            return -1;
        }
        hret = pOSInst->Get(L"Directory",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(wcscmp(v.bstrVal,wdata)){
            pOSInst->Release();
            VariantClear(&v);
            continue;
        }
        found = TRUE;
        pOSInst->Release();
        VariantClear(&v);
        break;
    }
    if(!found){
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
        BPFree(wdata);
        return 0;

    }
    hret = SafeArrayGetUBound(psa,
                              1,
                              &uBound
                              );
    if (hret != S_OK) {
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
        return 0;
    }
    for(LONG i = 0;i <= uBound; i++){
        hret = SafeArrayGetElement(psa,
                                   &i,
                                   &pOSInst
                                   );
        if(hret != S_OK){
            BPFree(wdata);
            return -1;
        }
        hret = pOSInst->Get(L"Directory",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(wcscmp(v.bstrVal,wdata)){
            pOSInst->Release();
            VariantClear(&v);
            continue;
        }
        VariantClear(&v);

    // form the correct string. 
        hret = pOSInst->Get(L"OperatingSystem",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        wlen = wcslen(v.bstrVal);
        slen = wlen*sizeof(WCHAR) + 1;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   v.bstrVal,
                                   wlen,
                                   str,
                                   slen,
                                   NULL,
                                   NULL
                                   );
        *pchar=0;
        WriteStringToFile(fh,
                          line
                          );
        *pchar = '=';
        WriteStringToFile(fh,
                          "="
                          );
        WriteStringToFile(fh,
                          str
                      );
        BPFree(str);
        VariantClear(&v);
        hret = pOSInst->Get(L"Rest",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BSTR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        wlen = wcslen(v.bstrVal);
        slen = wlen*sizeof(WCHAR) + 1;
        str = (PCHAR) BPAlloc(slen);
        if (!str) {
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        len =  WideCharToMultiByte(CP_ACP,
                                   0,
                                   v.bstrVal,
                                   wlen,
                                   str,
                                   slen,
                                   NULL,
                                   NULL
                                   );
        WriteStringToFile(fh,
                          " "
                          );
        WriteStringToFile(fh,
                          str
                          );
        BPFree(str);
        hret = pOSInst->Get(L"Redirect",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BOOL){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.boolVal && redir){// Loader also must be redirected
            WriteStringToFile(fh,
                              " /redirect"
                              );
        }
        VariantClear(&v);
        hret = pOSInst->Get(L"Fastdetect",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BOOL){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.boolVal){
            WriteStringToFile(fh,
                              " /fastdetect"
                              );
        }
        VariantClear(&v);
        hret = pOSInst->Get(L"Debug",
                            0,
                            &v,
                            &type,
                            NULL
                            );
        if(hret != WBEM_S_NO_ERROR){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.vt != VT_BOOL){
            BPFree(wdata);
            pOSInst->Release();
            return -1;
        }
        if(v.boolVal){
            WriteStringToFile(fh,
                              " /debug"
                              );
        }
        VariantClear(&v);
        WriteStringToFile(fh,
                          "\r\n"
                          );
        pOSInst->Release();
        found = TRUE;
        if(i != uBound){
            // Shorten the array. After all u have a copy
            hret = SafeArrayGetElement(psa,
                                       &uBound,
                                       &pOSInst
                                       );
            if(hret != S_OK){
                BPFree(wdata);
                return -1;
            }
            hret = SafeArrayPutElement(psa,
                                       &i,
                                       pOSInst
                                       );
            pOSInst->Release();
        }
        sb.cElements = uBound;
        sb.lLbound = 0;
        hret = SafeArrayRedim(psa,
                              &sb
                              );
        uBound -= 1;
        i-=1; // so that the currently swapped element is looked at now.
    }
    if(!found){
        WriteStringToFile(fh,
                          line
                          );
        WriteStringToFile(fh,
                          "\r\n"
                          );
    }
    BPFree(wdata);
    return 0;
}



LONG 
SaveBootFile(IWbemClassObject *pInst,
             IWbemClassObject *pClass
             )
{

    VARIANT v;
    VARIANT v1;
    BOOL redir;
    BOOL ret;
    DWORD dwlen;
    CIMTYPE type;
    HRESULT hret;
    PCHAR temp1,pchar;
    SAFEARRAY *org;
    
    temp1 = NULL;
    PCHAR fileName = GetBootFileName();
    HANDLE BootFile = GetFileHandle(fileName,OPEN_EXISTING, GENERIC_READ);
    BPFree(fileName);
    if (BootFile == INVALID_HANDLE_VALUE){
        return -1;
    }
    DWORD dwsize = GetFileSize(BootFile,
                               NULL
                               );
    if(dwsize == -1){
        CloseHandle(BootFile);
        return -1;
    }
    PCHAR data =(PCHAR)  BPAlloc(dwsize + sizeof(CHAR));
    if(!data){
        return -1;
    }

    DWORD dwret = ReadFile(BootFile,
                           (LPVOID) data,
                           dwsize,
                           &dwlen,
                           NULL
                           );

    if(dwret == 0){
        dwret = GetLastError();
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    CloseHandle(BootFile);
    BootFile = GetFileHandle("boot.bak", TRUNCATE_EXISTING, GENERIC_WRITE);
    hret = pInst->Get(L"operating_systems",
                      0,
                      &v,
                      &type,
                      NULL
                      );
    if(hret != WBEM_S_NO_ERROR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }

    VARTYPE t = VT_ARRAY|VT_UNKNOWN;
    if(v.vt != t){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    hret = SafeArrayCopy(v.parray, &org);
    
    if(hret != WBEM_S_NO_ERROR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    hret = pInst->Get(L"Redirect",
                      0,
                      &v1,
                      &type,
                      NULL
                      );
    if(hret != WBEM_S_NO_ERROR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }

    if(v1.vt != VT_BSTR){
        BPFree(data);
        CloseHandle(BootFile);
        return -1;
    }
    redir = FALSE;
    if(wcscmp(v1.bstrVal,L"no")){
        redir = TRUE;
    }
    CHAR sep[] = "\r\n";
    PCHAR temp = strtok(data, sep);
    while(temp){
        // ignore leading spaces
        while(*temp && (*temp == ' ')){
            temp ++;
        }
        if (strncmp(temp,"[boot loader]",strlen("[boot loader]"))==0) {
            // Ok, boot loader section. Write it.
            do{
                pchar = strchr(temp,'=');
                if((!pchar) ||(strncmp(temp,"default",strlen("default"))
                   && strncmp(temp,"redirect",strlen("redirect"))
                   && strncmp(temp,"timeout",strlen("timeout")))){
                    // Write the default string
                    WriteStringToFile(BootFile,temp);
                    WriteStringToFile(BootFile,"\r\n");
                }
                if(strncmp(temp,"default",strlen("default")) == 0){
                    // store the default string
                    temp1 = temp;
                }
                temp = strtok(NULL, sep);
            }while(temp && (*temp != '['));
            if(WriteDefaultParams(pInst,data,temp1,v.parray,BootFile,v1.bstrVal)){
                BPFree(data);
                CloseHandle(BootFile);
                return -1;
            }
            continue;
        }
        if(strcmp(temp,"[operating systems]")==0){
            // dealing with the operating systems line
            // So get the Safe Array
            do{
                temp1 = temp;
                if(*temp1 != ';'){
                    // comment line are ignored. 
                    pchar = strchr(temp,'=');
                    if(pchar){
                        if(WriteOSLine(BootFile,temp1, pchar, org ,v.parray, pClass,redir)){
                            BPFree(data);
                            CloseHandle(BootFile);
                            return -1;
                        }
                        temp = strtok(NULL,sep);
                        continue;
                    }
                }
                WriteStringToFile(BootFile, temp);
                WriteStringToFile(BootFile,"\r\n");
                temp = strtok(NULL,sep);
            }while(temp && (*temp != '['));
            SafeArrayDestroy(org);
            VariantClear(&v);
            continue;
        }
        WriteStringToFile(BootFile,temp);
        WriteStringToFile(BootFile,"\r\n");
        temp = strtok(NULL,sep);
    }
    CloseHandle(BootFile);
    fileName = GetBootFileName();
    if(!fileName){
        return -1;
    }
    ret = CopyFile("boot.bak",
                   fileName,
                   FALSE
                   );
    BPFree(fileName);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\utils.cpp ===
//***************************************************************************
//
//  UTILS.CPP
//
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: General purpose utilities.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <objbase.h>
#include "bootini.h"

LPTSTR IDS_RegBootDirKey = _T("BootDir");
LPTSTR IDS_BootIni = _T("boot.ini");
LPTSTR IDS_CBootIni = _T("c:\\boot.ini");
LPTSTR IDS_RegCurrentNTVersionSetup = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");


PCHAR
GetBootFileName(
    )
{
    HKEY h_key;
    LPTSTR data = NULL;
    DWORD cbdata;
    DWORD type;
    LONG ret;

    ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                       IDS_RegCurrentNTVersionSetup, 
                       0,
                       KEY_READ,
                       &h_key
                       );
    if (ret != ERROR_SUCCESS) {
        return NULL;
    }
    cbdata = 0;

    ret = RegQueryValueEx(h_key,
                          IDS_RegBootDirKey,
                          NULL,
                          &type,
                          (LPBYTE) data,
                          &cbdata
                          );

    if(ret == ERROR_MORE_DATA){
        data = (LPTSTR) BPAlloc(cbdata + 
                                (_tcslen(IDS_BootIni)+1)*sizeof(TCHAR));
        ret=RegQueryValueEx(h_key,
                            IDS_RegBootDirKey,
                            NULL,
                            &type,
                            (LPBYTE) data,
                            &cbdata
                            );

    }
    else{
        data = (LPTSTR) BPAlloc((_tcslen(IDS_CBootIni)+1)*sizeof(TCHAR));
    }
    if(data){
        _tcscat(data, IDS_CBootIni);
    }
    else{
        return NULL;
    }
    return data;
}

HANDLE GetFileHandle(PCHAR data,
                     DWORD dwCreationDisposition,
                     DWORD dwAccess
                     )
{

    LONG ret;
    
    if(!data){
        return INVALID_HANDLE_VALUE;
    }
    HANDLE h = CreateFile(data, 
                          dwAccess, 
                          FILE_SHARE_READ,  // Exclusive Write Access
                          NULL, 
                          dwCreationDisposition, 
                          0, 
                          NULL
                          ) ;
    if(INVALID_HANDLE_VALUE==h){
        ret=GetLastError();

    }
    return h;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\saccommunicator\saccommunicator.cpp ===
// SacCommunicator.cpp: implementation of the CSacCommunicator class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SacCommunicator.h"

#include "Debug.cpp"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LPTSTR CSacCommunicator::s_vctrCommPorts[]= {_T("COM1"), _T("COM2"), NULL};
SacString CSacCommunicator::s_strDummyReponse;

BOOL CSacCommunicator::XReadFile(
		HANDLE hFile,                // handle to file
		LPVOID lpBuffer,             // data buffer
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // number of bytes read
		LPOVERLAPPED lpOverlapped,    // overlapped buffer
		time_t tmTimeout  // time-out
)
{
	time_t tmInitReadTime, tmCurrTime;
	time(&tmInitReadTime); // stamp

	BOOL bLastRead;

	while (!(bLastRead= ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped)) || !*lpNumberOfBytesRead)
	{
		time(&tmCurrTime); // stamp

		if (tmCurrTime-tmInitReadTime>tmTimeout)
			break;
	}

	return bLastRead;
}

CSacCommunicator::CSacCommunicator(int nCommPort, DCB dcb)
{
	_Construct(nCommPort, dcb);
}

CSacCommunicator::~CSacCommunicator()
{
	_Clean();
}

void CSacCommunicator::_Construct(int nCommPort, DCB dcb)
{
	m_nCommPort= nCommPort;
	m_dcb= dcb;

	m_hCommPort= INVALID_HANDLE_VALUE;
}

void CSacCommunicator::_Clean()
{
	if (IsConnected())
		Disconnect();
}

BOOL CSacCommunicator::Connect()
{
	m_hCommPort= CreateFile(s_vctrCommPorts[m_nCommPort], GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// open handle

	if (m_hCommPort!=INVALID_HANDLE_VALUE)
	{
		if (!SetCommMask(m_hCommPort, EV_RXCHAR)) // masking all events but the char. read event
			return FALSE; // init call has to succeed

		COMMTIMEOUTS tmouts;
		ZeroMemory(&tmouts,sizeof(COMMTIMEOUTS));
		tmouts.ReadIntervalTimeout= MAXDWORD; // no blocking

		if (!SetCommTimeouts(m_hCommPort, &tmouts)) // non-blocking read
			return FALSE; // has to succeed as well
	}

	return m_hCommPort!=INVALID_HANDLE_VALUE; // check if succeeded
}

BOOL CSacCommunicator::Disconnect()
{
	CloseHandle(m_hCommPort); // close the handle

	m_hCommPort= INVALID_HANDLE_VALUE;
	return m_hCommPort==INVALID_HANDLE_VALUE; // has to succeed
}

BOOL CSacCommunicator::IsConnected()
{
	return m_hCommPort!=INVALID_HANDLE_VALUE;
}

BOOL CSacCommunicator::PokeSac() // currently disabled
{
	return FALSE;
}

BOOL CSacCommunicator::SacCommand(SAC_STR szRequest, SacString& strResponse, BOOL bPoke, time_t tmTimeout)
{
	time_t tmInitTime, tmCurrTime;
	time(&tmInitTime);

	strResponse= ""; // init response

	if (bPoke) // if asked:
/*		if (!PokeSac()) // poke sac
			return FALSE; // make sure to get response*/
		0; // disabled
		

	DWORD nBytesWritten, nBytesRead;
	SAC_CHAR szReturned[BUF_LEN]; // whatever is written by sac
	
	for (int i= 0; i<SAC_STRLEN(szRequest); i++) // baby-feeding sac
	{
		if (!WriteFile( m_hCommPort, szRequest+i, sizeof(SAC_CHAR), &nBytesWritten, NULL)) // feed sac
			return FALSE; // io must succeed

		time(&tmCurrTime);
		tmTimeout-= tmCurrTime-tmInitTime;
		if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
			return FALSE; // io must succeed && must receive echo back
	}

	time(&tmCurrTime);
	tmTimeout-= tmCurrTime-tmInitTime;
	if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
		return FALSE; // io must succeed && must receive echo back

//	DWORD dwEvtMask;
	
	DWORD dwErrors; // port errors
	COMSTAT stat;   // io status


	time(&tmInitTime);

	do
	{

		//dwEvtMask= 0;
		//while (!(dwEvtMask & EV_RXCHAR)
		//	if (!WaitCommEvent(m_hCommPort, &dwEvtMask, NULL))
		//		return FALSE;

		ClearCommError(m_hCommPort, &dwErrors, &stat); // peek into buffer

		if (!ReadFile(m_hCommPort, szReturned, stat.cbInQue, &nBytesRead, NULL)) // receive echo-back
			return FALSE; // io must succeed
		
		if (!nBytesRead)
			continue; // save some worthless instructions then

		szReturned[nBytesRead]= '\0'; // fix it
		strResponse.append(szReturned); // add to response

		time(&tmCurrTime);
	} while ((strResponse.rfind(SAC_TEXT("SAC>"))==SacString::npos)&&(tmCurrTime-tmInitTime<tmTimeout));

 	int nPosSacPrompt= strResponse.rfind(SAC_TEXT("SAC>"));
	if (!nPosSacPrompt)
		return FALSE; // no prompt back 

	strResponse.erase(nPosSacPrompt, SAC_STRLEN(SAC_TEXT("SAC>")));

	return TRUE; // at last sac echoed back!!!
}

BOOL CSacCommunicator::PagingOff(SacString& strResponse)
{
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // check state
		return TRUE;

	// if we r here then supposedly it's on, need to toggle once more
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // re-check
		return TRUE;

	return FALSE; // desperate
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\bootprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Instance provider code for boot parameters
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include <initguid.h>
#include <objbase.h>
#include "bootini.h"

HMODULE ghModule;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.

DEFINE_GUID(CLSID_instprovider,0x22cb8761, 0x914a, 0x11cf, 0xb7, 0x5, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb8);
// {22CB8761-914A-11cf-B705-00AA0062CBB8}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************

BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
        ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CBootProvFactory *pObj;

    if (CLSID_instprovider!=rclsid)
        return E_FAIL;

    pObj=new CBootProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WMI Boot Instance Provider";
    char * pModel = "Both";
    HKEY hKey1, hKey2;

    // Create the path.

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_instprovider, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("Software\\classes\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\saccommunicator\saccommunicator.h ===
// SacCommunicator.h: interface for the CSacCommunicator class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SACCOMMUNICATOR_H__F1BA07A7_478E_4E36_9780_22B5924F722D__INCLUDED_)
#define AFX_SACCOMMUNICATOR_H__F1BA07A7_478E_4E36_9780_22B5924F722D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <string>

// sac-code definitions
#ifdef _SACUNICODE
	
	typedef		wchar_t		SAC_CHAR, *SAC_STR;
	#define					SAC_STRCMP					wcscmp
	#define					SAC_STRLEN					wcslen
	#define					SAC_TEXT(str)				(L str)

#else

	typedef		char		SAC_CHAR, *SAC_STR;
	#define					SAC_STRCMP					strcmp
	#define					SAC_STRLEN					strlen
	#define					SAC_TEXT(str)				(str)

#endif 

typedef std::basic_string<SAC_CHAR> SacString;

#define BUF_LEN 512 // generic buffer length

class CSacCommunicator  
{

public:

	static LPTSTR s_vctrCommPorts[]; // Supported Communication Port Names Vector
	static SacString s_strDummyReponse;

	static BOOL XReadFile(
		HANDLE hFile,                // handle to file
		LPVOID lpBuffer,             // data buffer
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // number of bytes read
		LPOVERLAPPED lpOverlapped,    // overlapped buffer
		time_t tmTimeout  // time-out
		);

	CSacCommunicator(int nCommPort, DCB dcb);
	virtual ~CSacCommunicator();

	BOOL Connect();			// connect to port
	BOOL Disconnect();		// disconnect

	BOOL IsConnected();		// check whether port open


	BOOL PokeSac();			// verfies that sac is on the line - DISABLED

	BOOL SacCommand(SAC_STR szRequest, SacString& strResponse= s_strDummyReponse, BOOL bPoke= TRUE, time_t tmTimeOut= 5000 /* ms */);
	// sends a sac command and receives the response, can pre-poke to check that sac is listening
	// pre-poking is based on PokeSac() which is currently disabled

	BOOL PagingOff(SacString& strResponse=s_strDummyReponse); // disables paging the display

private:
	
	int				m_nCommPort;	// com port # [1 or 2]
	HANDLE			m_hCommPort;	// handle to the file representing com port

	DCB				m_dcb;			// connection params

	void _Construct(int nCommPort, DCB dcb);
	void _Clean();

};

#endif // !defined(AFX_SACCOMMUNICATOR_H__F1BA07A7_478E_4E36_9780_22B5924F722D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\sacrunner\inclfile.h ===
#ifndef __INCLFILE
#define __INCLFILE

#include <windows.h>
#include <TCHAR.H>


#include <iostream>
#include <fstream>
#include <time.h>


typedef std::basic_fstream<TCHAR> fstream;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\sacrunner\ntlog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       ntlog.cxx
//
//  Contents:   implemntation of CNtLog
//
//  Classes:
//
//  Functions:
//
//  Notes: loginf.h is where app specific setting should go
//
//  History:    8-23-96   benl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
//#include <iostream.h>
#include <ntlog.h>
#include "ntlog.hxx"

// #include "loginf.h"     //put any ntlog settings in here // not needed 4 now
// instead
#define LOG_OPTIONS 0

//constants
const int BUFLEN = 255;


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Init
//
//  Synopsis:   set up logging
//
//  Arguments:  [lpLogFile] -- log file name
//
//  Returns:     TRUE if successful
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL CNtLog::Init(LPCTSTR lpLogFile)
{
    WIN32_FIND_DATA wfd;
    HANDLE h;
    INT iNumExt = 0;

    if (lpLogFile)
    {
        _sntprintf(_lpName,MAX_PATH,_T("%s"),lpLogFile);

        //repeat until we have a name that doesn't exist
        do {
            h = ::FindFirstFile(_lpName,&wfd);
            if ( h != INVALID_HANDLE_VALUE )
            {
                _sntprintf(_lpName,MAX_PATH, _T("%s.%d"),lpLogFile,iNumExt++);
                ::FindClose(h);
            } else break;
        } while (1);

        //Now set up the log
        _hLog = ::tlCreateLog(_lpName, LOG_OPTIONS );
    } else
    {
        //set up log with no associated file
        _lpName[0] = _T('\0');
        _hLog = ::tlCreateLog(NULL, LOG_OPTIONS );

    }

    if ( !_hLog ) {
        _ftprintf(stderr, _T("CNtLog::Init:  tlCreateLog %s failed\n"),
                  lpLogFile);
        if (lpLogFile)
            ::DeleteFile(_lpName);
        return FALSE;
    }

    //Add main thread as a participant
    ::tlAddParticipant(_hLog, 0, 0 );

    _dwLevel = TLS_TEST;

    return TRUE;
} //CNtLog::Init



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Error
//
//  Synopsis:
//
//  Arguments:  [fmt] -- format string like any other printf func.
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Error (LPCTSTR fmt, ...)
{
    va_list vl;
    TCHAR lpBuffer[BUFLEN];

    va_start (vl, fmt);
    _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
    tlLog(_hLog, TLS_BLOCK | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
    _tprintf(_T("Error: %s\n"), lpBuffer);
    va_end (vl);
} //CNtLog::Error //CNtLog::Error


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Warn
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Warn  (LPCTSTR fmt, ...)
{
    va_list vl;
    TCHAR lpBuffer[BUFLEN];

    va_start (vl, fmt);
    _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
    tlLog(_hLog,TLS_WARN | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
    _tprintf(_T("Warning: %s\n"), lpBuffer);
    va_end (vl);
} //CNtLog::Warn



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Info
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Info  (LPCTSTR fmt, ...)
{
    va_list vl;
    TCHAR lpBuffer[BUFLEN];

    va_start (vl, fmt);
    _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
    tlLog(_hLog,TLS_INFO | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
    _tprintf(_T("%s\n"), lpBuffer);
    va_end (vl);
} //CNtLog::Info


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Pass
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-26-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Pass( LPCTSTR fmt, ...)
{
   va_list vl;
   TCHAR lpBuffer[BUFLEN];

   va_start (vl, fmt);
   _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
   tlLog(_hLog,TLS_PASS | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
   //_tprintf(_T("Pass: %s\n"), lpBuffer);
   va_end (vl);
} //CNtLog::Pass


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Fail
//
//  Synopsis:
//
//  Arguments:  [fmt] --
//
//  Returns:
//
//  History:    8-26-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Fail( LPCTSTR fmt, ...)
{
   va_list vl;
   TCHAR lpBuffer[BUFLEN];

   va_start (vl, fmt);
   _vsntprintf(lpBuffer,BUFLEN,fmt,vl);
   tlLog(_hLog,TLS_SEV2 | _dwLevel, TEXT(__FILE__),(int)__LINE__, lpBuffer);
   _tprintf(_T("Fail: %s\n"), lpBuffer);
   va_end (vl);
} //CNtLog::Fail



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::Close
//
//  Synopsis:
//
//  Arguments:  [bDelete] --
//
//  Returns:
//
//  History:    8-23-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::Close(BOOL bDelete)
{

    assert(_hLog != NULL);

    tlReportStats(_hLog);
    tlRemoveParticipant(_hLog);
    tlDestroyLog(_hLog);

    if (bDelete && _lpName[0] != _T('\0'))
        ::DeleteFile(_lpName);

    //cleanup variables
    _lpName[0] = _T('\0');
    _hLog = NULL;
} //CNtLog::Close


//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::AttachThread
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-04-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::AttachThread()
{
    tlAddParticipant(_hLog, 0, 0);
} //CNtLog::AttachThread



//+---------------------------------------------------------------------------
//
//  Member:     CNtLog::DetachThread
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-04-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::DetachThread()
{
    tlRemoveParticipant(_hLog);
} //CNtLog::DetachThread


//+---------------------------------------------------------------------------
//
//  Member:      CNtLog::StartVariation
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-18-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::StartVariation()
{
    _dwLevel = TLS_VARIATION;
    tlStartVariation(_hLog);
} // CNtLog::StartVariation


//+---------------------------------------------------------------------------
//
//  Member:      CNtLog::EndVariation
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-18-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID CNtLog::EndVariation()
{
    DWORD   dwResult;
    _dwLevel = TLS_TEST;
    dwResult = tlEndVariation(_hLog);
    tlLog(_hLog, dwResult | TL_TEST, _T("Variation result"));
} // CNtLog::EndVariation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\sacrunner\saccommunicator.cpp ===
// SacCommunicator.cpp: implementation of the CSacCommunicator class.
//
//////////////////////////////////////////////////////////////////////

#include "inclfile.h"

#include "..\SacCommunicator\SacCommunicator.h"

//#include "Debug.cpp"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

LPTSTR CSacCommunicator::s_vctrCommPorts[]= {_T("COM1"), _T("COM2"), NULL};
SacString CSacCommunicator::s_strDummyReponse;

BOOL CSacCommunicator::XReadFile(
		HANDLE hFile,                // handle to file
		LPVOID lpBuffer,             // data buffer
		DWORD nNumberOfBytesToRead,  // number of bytes to read
		LPDWORD lpNumberOfBytesRead, // number of bytes read
		LPOVERLAPPED lpOverlapped,    // overlapped buffer
		time_t tmTimeout  // time-out
)
{
	time_t tmInitReadTime, tmCurrTime;
	time(&tmInitReadTime); // stamp

	BOOL bLastRead;

	while (!(bLastRead= ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped)) || !*lpNumberOfBytesRead)
	{
		time(&tmCurrTime); // stamp

		if (tmCurrTime-tmInitReadTime>tmTimeout)
			break;
	}

	return bLastRead;
}

CSacCommunicator::CSacCommunicator(int nCommPort, DCB dcb)
{
	_Construct(nCommPort, dcb);
}

CSacCommunicator::~CSacCommunicator()
{
	_Clean();
}

void CSacCommunicator::_Construct(int nCommPort, DCB dcb)
{
	m_nCommPort= nCommPort;
	m_dcb= dcb;

	m_hCommPort= INVALID_HANDLE_VALUE;
}

void CSacCommunicator::_Clean()
{
	if (IsConnected())
		Disconnect();
}

BOOL CSacCommunicator::Connect()
{
	m_hCommPort= CreateFile(s_vctrCommPorts[m_nCommPort], GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// open handle

	if (m_hCommPort!=INVALID_HANDLE_VALUE)
	{
		if (!SetCommMask(m_hCommPort, EV_RXCHAR)) // masking all events but the char. read event
			return FALSE; // init call has to succeed

		COMMTIMEOUTS tmouts;
		ZeroMemory(&tmouts,sizeof(COMMTIMEOUTS));
		tmouts.ReadIntervalTimeout= MAXDWORD; // no blocking

		if (!SetCommTimeouts(m_hCommPort, &tmouts)) // non-blocking read
			return FALSE; // has to succeed as well
	}

	return m_hCommPort!=INVALID_HANDLE_VALUE; // check if succeeded
}

BOOL CSacCommunicator::Disconnect()
{
	CloseHandle(m_hCommPort); // close the handle

	m_hCommPort= INVALID_HANDLE_VALUE;
	return m_hCommPort==INVALID_HANDLE_VALUE; // has to succeed
}

BOOL CSacCommunicator::IsConnected()
{
	return m_hCommPort!=INVALID_HANDLE_VALUE;
}

BOOL CSacCommunicator::PokeSac() // currently disabled
{
	return FALSE;
}

BOOL CSacCommunicator::SacCommand(SAC_STR szRequest, SacString& strResponse, BOOL bPoke, time_t tmTimeout)
{
	time_t tmInitTime, tmCurrTime;
	time(&tmInitTime);

	strResponse= ""; // init response

	if (bPoke) // if asked:
/*		if (!PokeSac()) // poke sac
			return FALSE; // make sure to get response*/
		0; // disabled
		

	DWORD nBytesWritten, nBytesRead;
	SAC_CHAR szReturned[BUF_LEN]; // whatever is written by sac
	
	for (int i= 0; i<SAC_STRLEN(szRequest); i++) // baby-feeding sac
	{
		if (!WriteFile( m_hCommPort, szRequest+i, sizeof(SAC_CHAR), &nBytesWritten, NULL)) // feed sac
			return FALSE; // io must succeed

		time(&tmCurrTime);
		tmTimeout-= tmCurrTime-tmInitTime;
		if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
			return FALSE; // io must succeed && must receive echo back
	}

	time(&tmCurrTime);
	tmTimeout-= tmCurrTime-tmInitTime;
	if (!XReadFile( m_hCommPort, szReturned, sizeof(SAC_CHAR), &nBytesRead, NULL, tmTimeout)||!nBytesRead) // feed sac
		return FALSE; // io must succeed && must receive echo back

//	DWORD dwEvtMask;
	
	DWORD dwErrors; // port errors
	COMSTAT stat;   // io status


	time(&tmInitTime);

	do
	{

		//dwEvtMask= 0;
		//while (!(dwEvtMask & EV_RXCHAR)
		//	if (!WaitCommEvent(m_hCommPort, &dwEvtMask, NULL))
		//		return FALSE;

		ClearCommError(m_hCommPort, &dwErrors, &stat); // peek into buffer

		if (!ReadFile(m_hCommPort, szReturned, stat.cbInQue, &nBytesRead, NULL)) // receive echo-back
			return FALSE; // io must succeed
		
		if (!nBytesRead)
			continue; // save some worthless instructions then

		szReturned[nBytesRead]= '\0'; // fix it
		strResponse.append(szReturned); // add to response

		time(&tmCurrTime);
	} while ((strResponse.rfind(SAC_TEXT("SAC>"))==SacString::npos)&&(tmCurrTime-tmInitTime<tmTimeout));

 	int nPosSacPrompt= strResponse.rfind(SAC_TEXT("SAC>"));
	if (!nPosSacPrompt)
		return FALSE; // no prompt back 

	strResponse.erase(nPosSacPrompt, SAC_STRLEN(SAC_TEXT("SAC>")));

	return TRUE; // at last sac echoed back!!!
}

BOOL CSacCommunicator::PagingOff(SacString& strResponse)
{
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // check state
		return TRUE;

	// if we r here then supposedly it's on, need to toggle once more
	if (!SacCommand(SAC_STR("p\r"), strResponse, FALSE)) // toggle paging
		return FALSE;

	if (strResponse.find(SAC_STR("OFF"))!=SacString::npos) // re-check
		return TRUE;

	return FALSE; // desperate
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\sacrunner\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\admin\console\tcadmin.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcadmin.h
 *
 * Header file for the administration utility.
 * 
 * Sadagopan Rajaram -- Dec 20, 1999
 *
 */


#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>
#include <ntddser.h>
#include <conio.h>
#include "msg.h"
#include "tcsrvc.h"
extern PVOID ResourceImageBase;
extern FARPROC setparams;
extern FARPROC getparams;
extern FARPROC deletekey;
extern HANDLE hConsoleInput;
extern HANDLE hConsoleOutput;
extern TCHAR lastChar;
#ifdef MAX_BUFFER_SIZE
#undef MAX_BUFFER_SIZE
#define MAX_BUFFER_SIZE 257
#endif
#define NUMBER_FIELDS 6
#define NUMBER_OF_STATES 7

#define SERIAL_DEVICE_KEY _T("HARDWARE\\DEVICEMAP\\SERIALCOMM")
#define DEFAULT_BAUD_RATE 9600
#define TCAlloc(x) malloc(x)
#define TCFree(x)  free(x)

BOOL
Browse(
    );


VOID 
DisplayScreen(
    UINT MessageID
    );

int
DisplayEditMenu(
    TCHAR *name,
    int nameLen,
    TCHAR *device,
    int deviceLen,
    UINT *BaudRate,
    UCHAR *WordLen,
    UCHAR *Parity,
    UCHAR *StopBits
    );


LPTSTR
RetreiveMessageText(
    IN     ULONG  MessageId
    );


LONG
GetLine(
    LPTSTR str,
    int index,
    int MaxLength
    );

VOID
DisplayParameters(
    LPCTSTR *message,
    LPCTSTR name,
    LPCTSTR device,
    UINT baudRate,
    UCHAR wordLen,
    UCHAR parity,
    UCHAR stopBits
    );

VOID SendParameterChange(
    );

VOID
GetStatus(
    );

VOID
StartTCService(
    );

VOID
StopTCService(
    );

VOID
AddAllComPorts(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\admin\console\main.c ===
/*
 * Module - main.c
 * 
 * Presents the tcservice data in a simple console mode 
 * application.
 * 
 * 
 * Sadagopan Rajaram - Dec 20 1999.
 * 
 */
 
#include "tcadmin.h"

FARPROC getparams=NULL;
FARPROC setparams=NULL;
FARPROC deletekey = NULL;
PVOID ResourceImageBase=NULL;
HANDLE hConsoleInput=NULL;
HANDLE hConsoleOutput = NULL;
TCHAR lastChar = (TCHAR) 0;

int __cdecl
main(
    IN int argc,
    char *argv[]
    )
{
    // Just load the library.
    HINSTANCE hinstLib;
    TCHAR key;
    LPTSTR buff;
    int result;
    int nameLen,deviceLen;
    UINT BaudRate;
    DWORD len;
    UCHAR WordLen,StopBits,Parity;
    BOOL fFreeResult;
    LONG retVal;
    TCHAR name[MAX_BUFFER_SIZE];
    TCHAR device[MAX_BUFFER_SIZE];
    BOOL cont=TRUE;
    LPTSTR temp;
    BOOL readRet;



    hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);
                         
    if(hConsoleInput != INVALID_HANDLE_VALUE){
        SetConsoleMode(hConsoleInput,
                       ENABLE_PROCESSED_OUTPUT
                       );
    }
    else {
        return 1;
    }
    hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    if(hConsoleOutput != INVALID_HANDLE_VALUE){
        SetConsoleMode(hConsoleOutput,
                       ENABLE_PROCESSED_OUTPUT|
                       ENABLE_WRAP_AT_EOL_OUTPUT
                       );
    }
    else {
        return 1;
    }
    hinstLib = LoadLibrary(_T("tcdata")); 
    RtlPcToFileHeader(main,&ResourceImageBase);
    if(!ResourceImageBase){
        _tprintf(_T("Cannot find image base\n"));
        return 1;
    }
    // If the handle is valid, try to get the function address.
 
    if(!hinstLib){    
        buff=RetreiveMessageText(MSG_CANNOT_LOAD);
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    buff = RetreiveMessageText(MSG_PROCEDURE_NOT_FOUND);
    getparams = GetProcAddress(hinstLib, "GetParametersAtIndex");
    if(!getparams){
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    setparams = GetProcAddress(hinstLib, "SetParameters");
    if(!setparams){
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    deletekey = GetProcAddress(hinstLib, "DeleteKey");
    if(!deletekey){
        if(buff){
            _tprintf(_T("%s"),buff);
        }
        return 1;
    }
    TCFree(buff);
    buff = RetreiveMessageText(MSG_MAIN_SCREEN);
    if(!buff){
        return 1;
    }
    while(cont){
        _tprintf(_T("%s"),buff);
        do{
            readRet = ReadFile(hConsoleInput,
                               &key,
                               sizeof(TCHAR),
                               &len,
                               NULL
                               );
            if(!readRet || !len){
                exit(1);
            }
            if(lastChar != _T('\r') || key != _T('\n')){
                lastChar = key;
                break;
            }
            lastChar = key;
        }while(1);

        switch(key){
        case _T('0'):
            cont=FALSE;
            break;
        case _T('1'):
            // Browse through the registry
            Browse();
            break;
        case _T('2'): 
            // Add a key to the registry 
            // send an add message to the 
            // service if it exists.
            BaudRate = DEFAULT_BAUD_RATE;
            StopBits = STOP_BIT_1;
            Parity = NO_PARITY;
            WordLen = SERIAL_DATABITS_8;

            retVal  = DisplayEditMenu(name,
                                   0,
                                   device,
                                   0,
                                   &BaudRate,
                                   &WordLen,
                                   &Parity,
                                   &StopBits
                                   );
            temp = RetreiveMessageText(MSG_CONFIRM_PROMPT);
            if(!temp){
               return 1;
            }
            temp[_tcslen(temp) -2] = '\0';
            _tprintf(_T("%s"),temp);
            TCFree(temp);
            do{
                readRet = ReadFile(hConsoleInput,
                                   &key,
                                   sizeof(TCHAR),
                                   &len,
                                   NULL
                                   );
                if(!readRet || !len){
                    exit(1);
                }
                if(lastChar != _T('\r') || key != _T('\n')){
                    lastChar = key;
                    break;
                }
                lastChar = key;
            }while(1);

            if((key == _T('y')) 
               || (key == _T('Y'))){
                retVal = (LONG) (setparams)(name,
                                            device,
                                            &StopBits,
                                            &Parity,
                                            &BaudRate,
                                            &WordLen
                                            );
                if(retVal != ERROR_SUCCESS){
                    temp = RetreiveMessageText(MSG_ERROR_SET);
                    if(temp){
                        temp[_tcslen(temp) - 2 ] = _T('\0');
                        _tprintf(_T("%s %d"),temp,retVal);
                        TCFree(temp);
                    }
                }
            }
            break;
        case _T('3'):
            SendParameterChange();
            break;
        case _T('4'):
            GetStatus();
            break;
        case _T('5'):
            StartTCService();
            break;
        case _T('6'):
            StopTCService();
            break;
        case _T('7'):
            AddAllComPorts();
            break;
        default:
            DisplayScreen(MSG_HELP_SCREEN);
            do{
                readRet = ReadFile(hConsoleInput,
                                   &key,
                                   sizeof(TCHAR),
                                   &len,
                                   NULL
                                   );
                if(!readRet || !len){
                    exit(1);
                }
                if(lastChar != _T('\r') || key != _T('\n')){
                    lastChar = key;
                    break;
                }
                lastChar = key;
            }while(1);

            break;
            
        }

    }
    fFreeResult = FreeLibrary(hinstLib);
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\admin\console\utils.c ===
/*
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        utils.c
 *
 * Contains all the work needed to present the console
 *
 * 
 * Sadagopan Rajaram -- Dec 20, 1999
 *
 */

#include "tcadmin.h"

BOOL AnsiStatus = (sizeof(TCHAR) == sizeof(CHAR));


BOOL
Browse(
    )
{
    int index,j;
    LONG retVal;
    DWORD len;
    TCHAR name[MAX_BUFFER_SIZE];
    LPTSTR message[NUMBER_FIELDS + 1];
    TCHAR device[MAX_BUFFER_SIZE];
    int nameLen, deviceLen;
    UINT baudRate;
    LPTSTR temp;
    UCHAR stopBits, parity, wordLen;
    BOOL cont = TRUE;
    TCHAR key;
    LPTSTR confirm;
    BOOL readRet;

    for(index = 0; index < NUMBER_FIELDS; index ++){
        message[index]  = RetreiveMessageText(MSG_NAME_PROMPT+index);
        if (!message[index]) {
            for(j=index-1; j>=0;j--){
                TCFree(message[j]);
            }
            _tprintf(_T("Cannot find Resources\n"));
            return FALSE;
        }
        temp = message[index];
        while(*temp != _T('%')){
            temp++;
        }
        *temp = (TCHAR) 0;
    }
    message[index]  = RetreiveMessageText(MSG_NAME_PROMPT+index);
    if (!message[index]) {
        for(j=index-1; j>=0;j--){
            TCFree(message[j]);
        }
        _tprintf(_T("Cannot find Resources\n"));
        index ++;
        return FALSE;
    }
    confirm = RetreiveMessageText(MSG_CONFIRM_PROMPT);
    if (!confirm) {
        for(j=index-1; j>=0;j--){
            TCFree(message[j]);
        }
        _tprintf(_T("Cannot find Resources\n"));
        index ++;
        return FALSE;
    }
    confirm[_tcslen(confirm) - 2] = _T('\0');                              
    index = 0;
    do{
        parity = NO_PARITY;
        baudRate = DEFAULT_BAUD_RATE;
        stopBits = 0;
        wordLen = 8;
        nameLen = deviceLen =MAX_BUFFER_SIZE;
        name[0] = device[0] = (TCHAR) 0;
        retVal = (LONG) (getparams)(index,
                                    name,
                                    &nameLen,
                                    device, 
                                    &deviceLen,
                                    &stopBits,
                                    &parity,
                                    &baudRate,
                                    &wordLen
                                    );
        if(retVal != ERROR_SUCCESS){
            if (retVal == ERROR_NO_MORE_ITEMS){
                index --;
                if(index < 0 ) {
                    cont=FALSE;
                    continue;
                }
                goto input;
            }
            else{
                _tprintf(_T("%d\n"),retVal);
                cont=FALSE;
            }
            continue;
        }
        DisplayParameters(message, 
                          name,
                          device,
                          baudRate,
                          wordLen,
                          parity,
                          stopBits
                          );
        _tprintf(_T("%s"),message[6]);
input:
        readRet = ReadFile(hConsoleInput,
                           &key,
                           sizeof(TCHAR),
                           &len,
                           NULL
                           );
        if(!readRet || !len){
            exit(1);
        }
        if(lastChar == _T('\r') && key == _T('\n')){
            lastChar = key;
            goto input;
        }

        lastChar = key;
        switch(key){
        case _T('p'):
        case _T('P'):
            if(index == 0){
                goto input;
            }
            index --;
            break;
        case _T('n'):
        case _T('N'):
            index ++;
            break;
        case _T('m'):
        case _T('M'):
            cont=FALSE;
            break;
        case _T('d'):
        case _T('D'):
            retVal = (LONG) (deletekey)(name);
            if(index > 0){
                index --;
            }
            break;
        case _T('e'):
        case _T('E'):
            retVal = DisplayEditMenu(name,
                                     _tcslen(name),
                                     device,
                                     _tcslen(device),
                                     &baudRate,
                                     &wordLen,
                                     &parity,
                                     &stopBits
                                     );

            if(retVal == ERROR_SUCCESS){
                DisplayParameters(message, 
                                  name,
                                  device,
                                  baudRate,
                                  wordLen,
                                  parity,
                                  stopBits
                                  );
                _tprintf(_T("%s"),confirm);
                do{
                    readRet = ReadFile(hConsoleInput,
                                       &key,
                                       sizeof(TCHAR),
                                       &len,
                                       NULL
                                   );
                    if(!readRet || !len){
                        exit(1);
                    }
                    if(lastChar != _T('\r') || key != _T('\n')){
                        lastChar = key;
                        break;
                    }
                    lastChar = key;
                }while(1);

                if((key == _T('y')) 
                   || (key == _T('Y'))){
                    retVal = (LONG) (setparams)(name,
                                                device,
                                                &stopBits,
                                                &parity,
                                                &baudRate,
                                                &wordLen
                                                );
                    if(retVal != ERROR_SUCCESS){
                        temp = RetreiveMessageText(MSG_ERROR_SET);
                        temp[_tcslen(temp) - 2 ] = _T('\0');
                        if(temp){
                            _tprintf(_T("%s %d"),temp,retVal);
                        }
                        TCFree(temp);
                    }
                }
            }
            break;
        default:
            goto input;
        }

    }while(cont);

    for(index = 0; index <= NUMBER_FIELDS; index ++){
        TCFree(message[index]);
    }

    return TRUE;
}

VOID DisplayScreen(
    UINT MessageID
    )
{
    LPTSTR Message;
    DWORD len;

    Message = RetreiveMessageText(MessageID);
    if (!Message) {
        _tprintf(_T("Cannot retreive message\n"));
        return;
    }
    _tprintf(_T("%s"),Message);
    TCFree(Message);
    return;
}

int 
DisplayEditMenu(
    TCHAR *name,
    int nameLen,
    TCHAR *device,
    int deviceLen,
    UINT *BaudRate,
    UCHAR *WordLen,
    UCHAR *Parity,
    UCHAR *StopBits
    )
{


    LPTSTR message,temp,curr;
    int i;
    DWORD len;
    BOOL ret;
    TCHAR buffer[MAX_BUFFER_SIZE];
    int dat;

    message = RetreiveMessageText(MSG_NAME_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    while(!GetLine(name, nameLen, MAX_BUFFER_SIZE));
    message = RetreiveMessageText(MSG_DEVICE_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    while(!GetLine(device, deviceLen, MAX_BUFFER_SIZE));
    message = RetreiveMessageText(MSG_BAUD_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*BaudRate);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),BaudRate); 
    message = RetreiveMessageText(MSG_WORD_PROMPT);
    if(! message){
        return -1;
    }
    temp = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),message);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*WordLen);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),&dat); 
    *WordLen = (UCHAR) dat;
    message = RetreiveMessageText(MSG_PARITY_PROMPT2);
    if(! message){
        return -1;
    }
    temp = curr = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,NO_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,ODD_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,EVEN_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,MARK_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,SPACE_PARITY);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),curr);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*Parity);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),&dat); 
    *Parity = (UCHAR) dat;
    message = RetreiveMessageText(MSG_STOP_PROMPT2);
    if(! message){
        return -1;
    }
    temp = curr = message;
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,STOP_BIT_1);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,STOP_BITS_1_5);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s%d"),curr,STOP_BITS_2);
    curr = &(temp[1]);
    while(*temp != _T('%')){
        temp ++;
    }
    *temp = (TCHAR) 0;
    _tprintf(_T("%s"),curr);
    TCFree(message);
    _stprintf(buffer,_T("%d"),*StopBits);
    while(!GetLine(buffer,_tcslen(buffer) , MAX_BUFFER_SIZE));
    _stscanf(buffer,_T("%d"),&dat); 
    *StopBits = (UCHAR) dat;

    return ERROR_SUCCESS;

}

LPTSTR
RetreiveMessageText(
    IN     ULONG  MessageId
    )
{
    ULONG LenBytes;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    BOOLEAN IsUnicode;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    LPTSTR MessageText;

    Status = RtlFindMessage(
                ResourceImageBase,
                (ULONG)(ULONG_PTR)RT_MESSAGETABLE,
                0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        _tprintf(_T("TCADMIN: Can't find message 0x%lx\n"),MessageId);
        return(NULL);
    }

    IsUnicode = (BOOLEAN)((MessageEntry->Flags & 
                           MESSAGE_RESOURCE_UNICODE) != 0);

    //
    // Get the size in bytes of a buffer large enough to hold the
    // message and its terminating nul wchar.  If the message is
    // unicode, then this value is equal to the size of the message.
    // If the message is not unicode, then we have to calculate this value.
    //
    if(IsUnicode) {
        #ifdef UNICODE
        LenBytes = (wcslen((PWSTR)MessageEntry->Text) 
                    + 1)*sizeof(WCHAR);
        #else
        LenBytes = wcstombs(NULL,(PWSTR)MessageEntry->Text, 0);
        #endif
    } else {

        //
        // RtlAnsiStringToUnicodeSize includes an implied wide-nul terminator
        // in the count it returns.
        //
        #ifdef UNICODE
        AnsiString.Buffer = MessageEntry->Text;
        AnsiString.Length = (USHORT)strlen(MessageEntry->Text);
        AnsiString.MaximumLength = AnsiString.Length;

        LenBytes = RtlAnsiStringToUnicodeSize(&AnsiString);
        #else
        LenBytes = strlen((PCHAR) MessageEntry->Text);
        #endif
    }

    LenBytes += sizeof(TCHAR);
    //
    // allocate a buffer.
    //
    MessageText = (LPTSTR) TCAlloc(LenBytes);
    if(MessageText == NULL) {
        return(NULL);
    }
    memset(MessageText,0,LenBytes);
    if(IsUnicode) {

        //
        // Message is already unicode; just copy it into the buffer.
        //
        #ifdef UNICODE
        wcscpy(MessageText,(PWSTR)MessageEntry->Text);
        #else
        LenBytes = wcstombs((PCHAR) MessageText, 
                            (PWCHAR) MessageEntry->Text, 
                            LenBytes);
        #endif

    } else {

        //
        // Message is not unicode; convert in into the buffer.
        //
        #ifdef UNICODE
        UnicodeString.Buffer = MessageText;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = (USHORT)LenBytes;

        RtlAnsiStringToUnicodeString(&UnicodeString,
                                     &AnsiString,
                                     FALSE
                                     );
        #else
        strcpy((PCHAR) MessageText, (PCHAR) MessageEntry->Text);
        #endif
    }

    return(MessageText);
}

LONG
GetLine(
    LPTSTR str,
    int index,
    int MaxLength
    )
{
    DWORD len;
    DWORD size;
    TCHAR buffer[3];
    BOOL ret;

    str[index] = (TCHAR) 0;
    FlushConsoleInputBuffer(hConsoleInput);
    _tprintf(_T("%s"),str);
    buffer[0] = buffer[2] = (TCHAR) 0x8;
    buffer[1] = (TCHAR) 0;
    do{
        if (index == MaxLength) {
            index--;
        }

        //
        // Read a (possibly) partial command line.
        //
        do{
            ret = ReadFile(hConsoleInput,
                           &(str[index]),
                           sizeof(TCHAR),
                           &len,
                           NULL
                           );
            if(!ret || !len){
                exit(1);
            }
            if(lastChar != _T('\r') || str[index] != _T('\n')){
                //ignore \r\n combinations
                lastChar = str[index];
                break;
            }
            lastChar = str[index];
        }while(1);
        
        lastChar = str[index];
        if ((str[index] == (TCHAR) 0x8) ||   // backspace (^h)
            (str[index] == (TCHAR) 0x7F)) {  // delete
            if (index > 0) {
                WriteConsole(hConsoleOutput,
                             buffer,
                             3,
                             &len,
                             NULL
                             );
                index--;
            }
        } else {
            WriteConsole(hConsoleOutput,
                         &(str[index]),
                         1,
                         &len,
                         NULL
                         );
            index++;
        }
    } while ((index == 0) || ((str[index - 1] != _T('\n')) &&(str[index-1] != _T('\r'))));

    if(str[index-1] == _T('\r')){
        buffer[0] = '\n';
        str[index - 1] = '\0';
    }
    else{
        buffer[0] = _T('\r');
        str[index-1] ='\0';
    }

    WriteConsole(hConsoleOutput,
                 buffer,
                 1,
                 &len,
                 NULL
                 );
    FlushConsoleInputBuffer(hConsoleInput);
    return index;
}

VOID
DisplayParameters(
    LPCTSTR *message,
    LPCTSTR name,
    LPCTSTR device,
    UINT baudRate,
    UCHAR wordLen,
    UCHAR parity,
    UCHAR stopBits
    )
{
    _tprintf(_T("%s "),message[0]);
    _tprintf(_T("%s\n"),name);
    _tprintf(_T("%s "),message[1]);
    _tprintf(_T("%s\n"),device);
    _tprintf(_T("%s "),message[2]);
    _tprintf(_T("%d\n"),baudRate);
    _tprintf(_T("%s "),message[3]);
    _tprintf(_T("%d\n"),wordLen);
    _tprintf(_T("%s "),message[4]);
    switch(parity){
    case NO_PARITY:
        _tprintf(_T("NONE\n"));
        break;
    case ODD_PARITY:
        _tprintf(_T("ODD\n"));
        break;
    case EVEN_PARITY:
        _tprintf(_T("EVEN\n"));
        break;
    case MARK_PARITY:
        _tprintf(_T("MARK\n"));
        break;
    case SPACE_PARITY:
        _tprintf(_T("SPACE\n"));
        break;
    default:
        _tprintf(_T("NONE\n"));
        break;
    }
    _tprintf(_T("%s "),message[5]);
    switch(stopBits){
    case STOP_BIT_1:
        _tprintf(_T("1\n"));
        break;
    case STOP_BITS_1_5:
        _tprintf(_T("1.5\n"));
        break;
    case STOP_BITS_2:
        _tprintf(_T("2\n"));
        break;
    default:
        _tprintf(_T("1\n"));
        break;
    }

}

VOID SendParameterChange(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS status;

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = ControlService(tc_handle,
                         SERVICE_CONTROL_PARAMCHANGE,
                         &status
                         );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_SEND_PARAMETER_CHANGE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(SUCCESSFULLY_SENT_PARAMETER_CHANGE);
    if(temp){
        _tprintf(_T("%s"), temp);
        TCFree(temp);
    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;

}

VOID
GetStatus(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    DWORD len;
    int i;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS_PROCESS status;
    DWORD val[] = {
        SERVICE_STOPPED,
        SERVICE_START_PENDING,
        SERVICE_STOP_PENDING,
        SERVICE_RUNNING,
        SERVICE_CONTINUE_PENDING,
        SERVICE_PAUSE_PENDING,
        SERVICE_PAUSED
        };

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = QueryServiceStatusEx(tc_handle,
                               SC_STATUS_PROCESS_INFO,
                               (LPBYTE) &status,
                               sizeof(status),
                               &len
                               );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_QUERY_STATUS);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(QUERY_STATUS_SUCCESS);
    if(temp){
        temp[_tcslen(temp) -2 ] = (TCHAR) 0;
        _tprintf(_T("%s"), temp);
        TCFree(temp);
        for(i = 0 ; i<NUMBER_OF_STATES; i++){
            if(val[i] == status.dwCurrentState) break;
        }
        temp = RetreiveMessageText(SERVICE_STOPPED_MESSAGE + i);
        if(temp){
            _tprintf(_T("%s"),temp);
            TCFree(temp);
        }

    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;
    
}

VOID StopTCService(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS status;

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = ControlService(tc_handle,
                         SERVICE_CONTROL_STOP,
                         &status
                         );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_SEND_STOP);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(SUCCESSFULLY_SENT_STOP);
    if(temp){
        _tprintf(_T("%s"), temp);
        TCFree(temp);
    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;

}

VOID StartTCService(
    )
{
    SC_HANDLE sc_handle;
    SC_HANDLE tc_handle;
    LPTSTR temp;
    BOOL ret;
    SERVICE_STATUS status;

    sc_handle = OpenSCManager(NULL,
                             NULL,
                             GENERIC_READ
                             );
    if (sc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE_MANAGER);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s"), temp);
            return;
        }
    }
    tc_handle = OpenService(sc_handle,
                            TCSERV_NAME,
                            SERVICE_ALL_ACCESS
                            );

    if (tc_handle == NULL){
        temp = RetreiveMessageText(CANNOT_OPEN_SERVICE);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp,GetLastError());
            TCFree(temp);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    ret = StartService(tc_handle,
                       0,
                       NULL
                       );
    if(ret == FALSE){
        temp = RetreiveMessageText(CANNOT_SEND_START);
        if(temp){
            temp[_tcslen(temp) - 2] = (TCHAR) 0;
            _tprintf(_T("%s %d"), temp, GetLastError());
            TCFree(temp);
            CloseServiceHandle(tc_handle);
            CloseServiceHandle(sc_handle);
            return;
        }
    }
    temp = RetreiveMessageText(SUCCESSFULLY_SENT_START);
    if(temp){
        _tprintf(_T("%s"), temp);
        TCFree(temp);
    }
    CloseServiceHandle(tc_handle);
    CloseServiceHandle(sc_handle);
    return;

}

VOID
AddAllComPorts(
    )
/* 
 * Adds all the Com ports in the system as parameters to bridge
 * Reads key HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM
 * Each value name is a com device name. The friendly name is the 
 * value data
 * 
 */
{
    DWORD index;
    HKEY m_hkey;
    ULONG retVal;
    LPTSTR temp;
    TCHAR device[MAX_BUFFER_SIZE*2];
    TCHAR name[MAX_BUFFER_SIZE];
    UINT baudRate;
    DWORD type;
    DWORD deviceLen,nameLen;
    UCHAR stopBits, parity, wordLen;
    
    index = 0;

    retVal = RegOpenKey(HKEY_LOCAL_MACHINE,
                        SERIAL_DEVICE_KEY,
                        &m_hkey
                        );
    if(retVal != ERROR_SUCCESS){
        _tprintf(_T("%d\n"),retVal);
        return;
    }

    index = 0;
    while(1){
        deviceLen = nameLen = MAX_BUFFER_SIZE;
        retVal = RegEnumValue(m_hkey,
                              index,
                              device,
                              &deviceLen,
                              NULL,
                              &type,
                              name,
                              &nameLen
                              );
        if(retVal != ERROR_SUCCESS){
            if(retVal != ERROR_NO_MORE_ITEMS){
                _tprintf(_T("%d\n"),retVal);
            }
            break;
        }
        stopBits = STOP_BIT_1;
        parity = NO_PARITY;
        baudRate = DEFAULT_BAUD_RATE;
        wordLen = SERIAL_DATABITS_8;
        _stprintf(device, "\\??\\%s",name);
        retVal = (ULONG) (setparams)(name,
                                     device,
                                     &stopBits,
                                     &parity,
                                     &baudRate,
                                     &wordLen
                                     );
        if(retVal != ERROR_SUCCESS){
            temp = RetreiveMessageText(MSG_ERROR_SET);
            temp[_tcslen(temp) - 2 ] = _T('\0');
            if(temp){
                _tprintf(_T("%s %d"),temp,retVal);
            }
            TCFree(temp);
            break;
        }
        index ++;

    }
    retVal = RegCloseKey(m_hkey);




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\admin\data\dll.c ===
#include "tcdata.h"
#include "tcsrvc.h"

// The key to the registry where the paramters are present.

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    HKEY lock,l_hkey;
    LONG retVal;
    DWORD disposition;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(Reason);
    return TRUE;

}

LONG 
TCLock(
    PHANDLE lock
    )
{
    LONG RetVal; 

    (*lock) = CreateMutex(NULL,
                          FALSE,
                          TCSERV_MUTEX_NAME
                          );
    if ((*lock)) {
       RetVal = WaitForSingleObject(*lock,INFINITE);
       if (RetVal == WAIT_FAILED) {
           return GetLastError();
       }
       else{
           return ERROR_SUCCESS;
       }
    }
    else{
        return GetLastError();
    }
}

VOID
TCUnlock(
    HANDLE lock
    )
{
    if (lock) {
        ReleaseMutex(lock);
        CloseHandle(lock);
    }
    return;
}

LONG GetParametersByName(
    TCHAR *name,
    int *nameLen,
    TCHAR *device,
    int *deviceLen,
    PUCHAR stopBits,
    PUCHAR parity,
    PUINT baudRate,
    PUCHAR wordLen
    )
{
    LONG RetVal;
    HKEY m_child;
    DWORD lpcdata, lpType,dat;
    HANDLE lock;
    HKEY m_hkey;



    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &m_hkey
                              );
    if(RetVal != ERROR_SUCCESS){
        TCUnlock(lock);
        return RetVal;
    }
    RetVal= RegOpenKeyEx(m_hkey,
                         name,  // subkey name
                         0,   // reserved
                         KEY_ALL_ACCESS, // security access mask
                         &m_child
                         );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Device"),
                             NULL,  
                             &lpType,
                             (LPBYTE)device,
                             deviceLen
                             );
    (*deviceLen) = (*deviceLen) - 1;
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_child);
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    lpcdata = sizeof(UINT);
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Baud Rate"),
                             NULL,  
                             &lpType,
                             (LPBYTE)baudRate,
                             &lpcdata
                             );
    lpcdata = sizeof(DWORD);
    dat = (DWORD) *stopBits;
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Stop Bits"),
                             NULL,  
                             &lpType,
                             (LPBYTE)&dat,
                             &lpcdata
                             );
    *stopBits = (UCHAR) dat;
    dat = (DWORD) *wordLen;
    lpcdata = sizeof(DWORD);
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Word Length"),
                             NULL,  
                             &lpType,
                             (LPBYTE)&dat,
                             &lpcdata
                             );
    *wordLen = (UCHAR) dat;
    lpcdata = sizeof(DWORD);
    dat = (DWORD) *parity;
    RetVal = RegQueryValueEx(m_child,
                             _TEXT("Parity"),
                             NULL,  
                             &lpType,
                             (LPBYTE)&dat,
                             &lpcdata
                             );
    *parity = (UCHAR) dat;
    RegCloseKey(m_child);
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return ERROR_SUCCESS;
}


LONG
GetParametersAtIndex(
    int index,
    TCHAR *name,
    int *nameLen,
    TCHAR *device,
    int *deviceLen,
    PUCHAR stopBits,
    PUCHAR parity,
    PUINT baudRate,
    PUCHAR wordLen
    )
{
    LONG RetVal;
    FILETIME lpftLastWriteTime;
    HANDLE lock;
    HKEY m_hkey;

    if ((name == NULL) || (device == NULL)) {
        return -1;
    }
    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &m_hkey
                          );
    if(RetVal != ERROR_SUCCESS){
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegEnumKeyEx(m_hkey,
                          index,
                          name,
                          nameLen,
                          NULL,
                          NULL,
                          NULL,
                          &lpftLastWriteTime
                          ); 
    if(RetVal != ERROR_SUCCESS){ 
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return (GetParametersByName(name,
                                nameLen,
                                device,
                                deviceLen,
                                stopBits,
                                parity,
                                baudRate,
                                wordLen));
}


LONG
SetParameters(
    TCHAR *name,
    TCHAR *device,
    PUCHAR stopBits,
    PUCHAR parity,
    PUINT baudRate,
    PUCHAR wordLen
    )
{
    LONG RetVal;
    HKEY m_child, m_hkey;
    int lpcdata;
    DWORD dat;
    HANDLE lock;

    if ((name == NULL) || (device == NULL)) {
        return -1;
    }
    if(_tcslen(name) == 0 || _tcslen(device) == 0){
        return -1;
    }
    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        TCUnlock(lock);
        return RetVal;
    }
    RetVal = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            HKEY_TCSERV_PARAMETER_KEY,
                            0,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &m_hkey,
                            NULL
                            );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RetVal= RegCreateKeyEx(m_hkey,
                           name,  // subkey name
                           0,   // reserved
                           NULL,
                           0,
                           KEY_ALL_ACCESS, // security access mask
                           NULL,
                           &m_child,
                           NULL
                           );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    lpcdata = _tcslen(device)*sizeof(TCHAR);
    RetVal = RegSetValueEx(m_child,
                           _TEXT("Device"),
                           0,  
                           REG_SZ,
                           (LPBYTE)device,
                           lpcdata
                           );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_child);
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    if(baudRate){
        lpcdata = sizeof(UINT);
        RetVal = RegSetValueEx(m_child,
                               _TEXT("Baud Rate"),
                               0,  
                               REG_DWORD,
                               (LPBYTE)baudRate,
                               lpcdata
                               );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }

    }
    if(stopBits){
        dat =(DWORD)  *stopBits;
        lpcdata = sizeof(DWORD);
        RetVal = RegSetValueEx(m_child,
                               _TEXT("Stop Bits"),
                               0,  
                               REG_DWORD,
                               (LPBYTE)&dat,
                               lpcdata
                               );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }
    }
    if(wordLen){
        lpcdata = sizeof(DWORD);
        dat = (DWORD) *wordLen;
        RetVal = RegSetValueEx(m_child,
                               _TEXT("Word Length"),
                               0,  
                               REG_DWORD,
                               (LPBYTE)&dat,
                               lpcdata
                               );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }
    }
    if(parity){
        lpcdata = sizeof(DWORD);
        dat = (DWORD) *parity;
        RetVal = RegSetValueEx(m_child,
                             _TEXT("Parity"),
                             0,  
                             REG_DWORD,
                             (LPBYTE)&dat,
                             lpcdata
                             );
        if(RetVal != ERROR_SUCCESS){
            RegCloseKey(m_child);
            RegCloseKey(m_hkey);
            TCUnlock(lock);
            return RetVal;
        }
    }
    RegCloseKey(m_child);
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return ERROR_SUCCESS;

}

LONG
DeleteKey(
    LPCTSTR name
    )
{
    LONG RetVal;
    HANDLE lock;
    HKEY m_hkey;

    RetVal = TCLock(&lock);
    if (RetVal != ERROR_SUCCESS) {
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &m_hkey
                              );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        TCUnlock(lock);
        return RetVal;
    }
    RetVal =  RegDeleteKey(m_hkey,
                           name
                           );
    RegCloseKey(m_hkey);
    TCUnlock(lock);
    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\ems\sac\sacrunner\sacrunner.cpp ===
// SacRunner.cpp : Defines the entry point for the console application.
//

#include "inclfile.h"

#include "..\SacCommunicator\SacCommunicator.h"

#include "ntlog.hxx"

#define BUFFER_SIZE 1024

LPCTSTR g_vConnectionParams[]= {"COM1", "9600", "8", "0", "1"};

BOOL    g_bVerbose       = FALSE;

LPCTSTR g_szInputFileName= NULL;
LPCTSTR g_szRespDir      = NULL;

LPCTSTR g_szLogFileName  = NULL;
LPCTSTR g_szNtLogFile    = NULL;
LPCTSTR g_szBvtLogFile    = NULL;

CNtLog  g_ntlogLogger;

UINT g_nPassTotal= 0, g_nFailTotal= 0;

BOOL WriteBvtLog(LPCTSTR szBvtLogFile, double ratioPassLimit, UINT nPassTotal, UINT nFailTotal, time_t tmStart, time_t tmFinish)
{
	fstream f(szBvtLogFile, std::ios::out);

	if (!f.is_open())
		return FALSE;

	LPCTSTR vTestResults[]= {_T("NOCONFIG"), _T("PASS"), _T("FAIL")};
	int nTestResult= !(nPassTotal||nFailTotal) ? 0 : (nPassTotal/(nPassTotal+nFailTotal)<ratioPassLimit)+1;

	f<<"[TESTRESULT]\n";
	f<<"\tTEST:        Basic Sac Stress\n";
	f<<"\tRESULT:      "<<vTestResults[nTestResult]<<'\n';
	f<<"\tCONTACT:     ahmedt\n";
	f<<"\tPM CONTACT:  pasquale\n";
	f<<"\tDEV PRIME:   adamba\n";
	f<<"\tDEV ALT:     adamba\n";
	f<<"\tTEST PRIME:  ahmedt\n";
	f<<"\tTEST ALT:    rgeorge\n";

	struct tm *ptminfoStart, *ptminfoFinish, tminfoStart, tminfoFinish;
	ptminfoStart= localtime(&tmStart);
	tminfoStart= *ptminfoStart;

	ptminfoFinish= localtime(&tmFinish);
	tminfoFinish= *ptminfoFinish;

	f<<"\tSTART TIME:\t\t"<<tminfoStart.tm_mon<<'/'<<tminfoStart.tm_mday<<'/'<<tminfoStart.tm_year<<' '<<tminfoStart.tm_hour<<':'<<tminfoStart.tm_min<<':'<<tminfoStart.tm_sec<<'\n';
	f<<"\tEND TIME:\t\t"<<tminfoFinish.tm_mon<<'/'<<tminfoFinish.tm_mday<<'/'<<tminfoFinish.tm_year<<' '<<tminfoFinish.tm_hour<<':'<<tminfoFinish.tm_min<<':'<<tminfoFinish.tm_sec<<'\n';


	f<<"\n\t[Detailed Results]\n";
	f<<"\t\tPass Count:"<< g_nPassTotal<<'\n';
	f<<"\t\tFail Count:"<< g_nFailTotal<<'\n';
	f<<"\t\t\tFor more info check the command log-file: "<< g_szLogFileName<<'\n';
	f<<"\t[/Detailed Results]\n\n";


	f<<"[/TESTRESULT]\n";

	f.close();

	return TRUE;

}

BOOL RunSac(LPCTSTR szFileName, int nCommPortId, DCB dcb, BOOL b2Screen, LPCTSTR szLogfileName= NULL, LPCSTR szResponseDir= NULL, LPCTSTR szNtLogFile= NULL)
{
	fstream f(szFileName, std::ios::in); // opening file
	if (!f.is_open()) // checking if open
		return FALSE; // cannot open input file then we have nothing to do

	fstream log_f; // log file
	BOOL bLog; // whether to log or not
	if (szLogfileName&&*szLogfileName) // if name supplied
		log_f.open(szLogfileName, std::ios::out); // open file

	bLog= log_f.is_open(); // only can log if log file is open

	CSacCommunicator SacCl(nCommPortId, dcb); // creating a sac client

	if (!SacCl.Connect()) // connecting to sac
	{
		log_f.close();
		f.close();
		return FALSE; // cannot init connection
	}
	// file is open if we r here and connected to port

	BOOL bNtLog; // whether or not having an nt log

	if (bNtLog= szNtLogFile!=NULL) // in order for that a file name has to be supplied
	{
		bNtLog= g_ntlogLogger.Init(szNtLogFile); // and intialization has to succeed so as to be able to log

		if (bNtLog)
			g_ntlogLogger.AttachThread();
	}


	// poke sac
	if (!SacCl.SacCommand( SAC_STR("\r") ))
		return FALSE;

	int nLineNo= 0;
	while (!f.eof())
	{
		++nLineNo; // another line

		if (b2Screen)
			std::cout<<"Line: "<<nLineNo<<'\n'; // echo line #


		TCHAR szStaticBuffer[BUFFER_SIZE]; // reading buffer
		LPTSTR szBuffer;

		szBuffer= szStaticBuffer;
		f.getline(szBuffer, BUFFER_SIZE-1); // reading line taking into consideration the \r appended later


		while (*szBuffer==' '||*szBuffer=='\t')
			szBuffer++; // eat white

		if (!*szBuffer||*szBuffer=='#'||*szBuffer=='\r'||*szBuffer=='\n') // skip empty lines
		{
			if (b2Screen)
				std::cout<<"\tline skipped!!"<<std::endl;
						
			continue; // a comment or an empty line
		}

		int i= 0;
		while (szBuffer[i]!='\0'&&szBuffer[i]!=':')
		{
			if (!_tcsncmp(szBuffer+i, _T("\\\\"), 2))
				break; // rest of line comment

			i++;
		}

		int nCount= 1; // default count is 1
		if (szBuffer[i]==':') // if count present
		{
			int j= 1;
			while (szBuffer[i+j]!='\0')
			{
				if (!_tcsncmp(szBuffer+i+j, _T("//"), 2))
					break;
				j++;
			}

			szBuffer[i+j]= '\0';

			nCount= _ttoi(szBuffer+i+1); // get count
			szBuffer[i]='\0'; // remove it from string
		}

		for (i= _tcslen(szBuffer); i>0&&(szBuffer[i-1]==' '||szBuffer[i-1]=='\t'); i--)
			;

		szBuffer[i]='\0';

		_tcscat(szBuffer, _T("\r")); // append CR

		for (i= 0; i<nCount; i++)
		{
			BOOL bSuccess;
			SacString strResponse;

			if (!_tcscmp(szBuffer, "Paging Off\r")) // look for special command
				bSuccess= SacCl.PagingOff(strResponse);
			else
				bSuccess= SacCl.SacCommand(szBuffer, strResponse, FALSE, 5000);

			g_nPassTotal+= bSuccess;
			g_nFailTotal+= !bSuccess;


			if (szResponseDir) // if output dir specified
			{
				TCHAR szResponseFileBuf[BUFFER_SIZE];

				_tcscpy(szResponseFileBuf, szResponseDir);
				sprintf(szResponseFileBuf+_tcslen(szResponseFileBuf), "\\L%d_C%d.out", nLineNo, i);

				fstream out_f(szResponseFileBuf, std::ios::out);
				if (out_f.is_open())
					out_f<<strResponse.data(); // log out

				out_f.close(); // close out file
			}


			LPCTSTR vstrStatus[]= { _T("FAILURE"), _T("SUCCESS") }; // status string vector

			if (b2Screen)
				std::cout<<"\tCount: "<<i+1<< " -> "<< vstrStatus[bSuccess]<< std::endl; // report 2 screen

			if (bLog)
			{
				log_f<< "Line["<< nLineNo<< "]\\ Count[" <<i+1<<"]-> Command: ";
				log_f<< szBuffer<< "\tStatus: "<< vstrStatus[bSuccess]<< std::endl; // report to log file
			}

			if (bNtLog)
				if (bSuccess)
					if (strResponse.length())
						g_ntlogLogger.Pass("Sac Responded -> L[%d], C[%d]: %s", nLineNo, i, szBuffer);
					else
						g_ntlogLogger.Warn("Sac NIL Response -> L[%d], C[%d]: %s", nLineNo, i, szBuffer);
				else
					g_ntlogLogger.Fail("Sac Communication Failed -> L[%d], C[%d]: %s", nLineNo, i, szBuffer);

		}
	}

	// finally
	goto Terminate;
	Terminate:
	SacCl.Disconnect(); // close connection
	log_f.close(); // close general log
	f.close(); // close input file

	if (bNtLog)
	{
		g_ntlogLogger.DetachThread();
		g_ntlogLogger.Close();
	}


	return TRUE; // that's it
}

BOOL GetArgs(int argc, LPTSTR argv[], LPCTSTR szErrBuffer= NULL)
{

	if (*argv[1]!='-'&&*argv[1]!='/')
		g_szInputFileName= argv[1];

	for (int i= 1; i<argc; i++)
	{
		if (*argv[i]=='-'||*argv[i]=='/')
			switch (*(argv[i]+1))
			{
				case 'I':
					if (*(argv[i]+2))
						g_szInputFileName= argv[i]+2;
					else
						g_szInputFileName= argv[++i];
					break;
				case 'V':
					if (!*(argv[i]+2))
						g_bVerbose= TRUE;
					else
						return FALSE;
					
					break;
				case 'L':
					if (*(argv[i]+2))
						g_szLogFileName= argv[i]+2;
					else
						g_szLogFileName= argv[++i];
					break;
				case 'N':
					if (!_tcsncmp(argv[i]+2, _T("TL"), 2))
						if (*(argv[i]+4))
							g_szNtLogFile= argv[i]+4;
						else
							g_szNtLogFile= argv[++i];
					break;
				case 'B':
					if (!_tcsncmp(argv[i]+2, _T("VTL"), 2))
						if (*(argv[i]+5))
							g_szBvtLogFile= argv[i]+4;
						else
							g_szBvtLogFile= argv[++i];
					break;
				case 'D':
					if (*(argv[i]+2))
						g_szRespDir= argv[i]+2;
					else
						g_szRespDir= argv[++i];
					break;
				case 'C': // -C 9600, 8,N, 1
//					TCHAR* pCurr= *(argv[i]+2)? (argv[i]+2) : argv[++i];
					TCHAR* pCurr= argv[i]+2;

					for (int j= 0; j<4; j++)
					{
						int k;

						if (!*pCurr)
							pCurr= argv[++i];

						for (k= 0; pCurr[k]&&pCurr[k]!=','; )
							k++;

						pCurr[k]= '\0';

						g_vConnectionParams[j]= pCurr;

						pCurr+= k+1;
					}
					break;
			}
	}

	return TRUE;
}

int __cdecl main(int argc, char* argv[])
{
	DCB dcb;

	GetArgs(argc, argv);

	if (!g_szInputFileName)
	{
		std::cout<< "Erorr: no input file name supplied"<< std::endl;
		return !0;
	}

	std::cout<< "attempting to run w/ following options:"<< std::endl;

	if (g_szLogFileName)
		std::cout<< "logging to: "<< g_szLogFileName<< '\n';
	else
		std::cout<< "no log filename supplied, logging truned off\n";

	if (g_szNtLogFile)
		std::cout<< "nt log will be written to: "<< g_szLogFileName<< ".*\n";
	else
		std::cout<< "no nt-log filename supplied, nt-logging truned off\n";

	if (g_szRespDir)
		std::cout<< "sac output files will be located in: "<< g_szRespDir<< "\\\n";
	else
		std::cout<< "no directory specified for sac output files, using current\n";

	if (g_bVerbose)
		std::cout<< "running verbose...\n";
	else
		std::cout<< "running non-verbose...\n";

	std::cout<<std::endl;

	for (int i= 0; CSacCommunicator::s_vctrCommPorts[i]; i++)
		if (!_tcscmp(CSacCommunicator::s_vctrCommPorts[i], g_vConnectionParams[0]))
			break;

	int nCommPort= i;

	BuildCommDCB( CSacCommunicator::s_vctrCommPorts[nCommPort], &dcb);
	dcb.BaudRate = _ttoi(g_vConnectionParams[1]);   // set the baud rate
	dcb.ByteSize = (BYTE) _ttoi(g_vConnectionParams[2]);   // data size, xmit, and rcv
	dcb.Parity   = (BYTE) _ttoi(g_vConnectionParams[3]);   // parity bit
	dcb.StopBits = (BYTE) _ttoi(g_vConnectionParams[4]);   // one stop bit

	time_t tmStart, tmFinish;
	BOOL bTestResult;
	time(&tmStart);
	bTestResult= RunSac(g_szInputFileName, nCommPort, dcb, g_bVerbose, g_szLogFileName, g_szRespDir, g_szNtLogFile);
	time(&tmFinish);

	if (bTestResult)
	{
		WriteBvtLog(g_szBvtLogFile, 0.5, g_nPassTotal, g_nFailTotal, tmStart, tmFinish);
		std::cout<< "\nTEST RESULT: SUCCEEDED!!!\n";
	}
	else
	{
		WriteBvtLog(g_szBvtLogFile, 0.5, 0, 0, tmStart, tmFinish);
		std::cout<< "\nTEST RESULT: NOCONFIG | FAILED!!!\n";
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\admin\data\tcdata.h ===
/* 
 * tcdata.h
 * 
 * Contains header information for the data part of the 
 * tcadmin utility.
 * 
 * Sadagopan Rajaram - Dec 27th, 1999.
 *
 */

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library
//

#include <process.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>

extern HKEY m_hkey;
extern HKEY m_lock;
extern int m_pid;

#define HKEY_PARAMETERS_LOCK _T("System\\CurrentControlSet\\Services\\TCSERV\\Lock")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\client\keymap.h ===
/*
 *
 *
 * Keycode definitions for special keys
 *
 * On systems that have any of these keys, the routine 'inchar' in the
 * machine-dependent code should return one of the codes here.
 */

#define ZERO            ((TCHAR) 0x00)
#define ESCP            ((TCHAR) 0x1B)
#define K_HOME          ((TCHAR) 0x80)
#define K_END           ((TCHAR) 0x81)
#define K_INSERT        ((TCHAR) 0x82)
#define K_DELETE        ((TCHAR) 0x83)
#define K_UARROW        ((TCHAR) 0x84)
#define K_DARROW        ((TCHAR) 0x85)
#define K_LARROW        ((TCHAR) 0x86)
#define K_RARROW        ((TCHAR) 0x87)
#define K_CGRAVE        ((TCHAR) 0x88)    /* control grave accent */
#define K_PAGEUP        ((TCHAR) 0x89)
#define K_PAGEDOWN      ((TCHAR) 0x8A)

#define K_F1            ((TCHAR) 0x8B)    /* function keys */
#define K_F2            ((TCHAR) 0x8C)
#define K_F3            ((TCHAR) 0x8D)
#define K_F4            ((TCHAR) 0x8E)
#define K_F5            ((TCHAR) 0x8F)
#define K_F6            ((TCHAR) 0x90)
#define K_F7            ((TCHAR) 0x91)
#define K_F8            ((TCHAR) 0x92)
#define K_F9            ((TCHAR) 0x93)
#define K_F10           ((TCHAR) 0x94)
#define K_F11           ((TCHAR) 0x95)
#define K_F12           ((TCHAR) 0x96)

#define K_SF1           ((TCHAR) 0x97)    /* shifted function keys */
#define K_SF2           ((TCHAR) 0x98)
#define K_SF3           ((TCHAR) 0x99)
#define K_SF4           ((TCHAR) 0x9A)
#define K_SF5           ((TCHAR) 0x9B)
#define K_SF6           ((TCHAR) 0x9C)
#define K_SF7           ((TCHAR) 0x9D)
#define K_SF8           ((TCHAR) 0x9E)
#define K_SF9           ((TCHAR) 0x9F)
#define K_SF10          ((TCHAR) 0xA0)
#define K_SF11          ((TCHAR) 0xA1)
#define K_SF12          ((TCHAR) 0xA2)

#define CTLA            ((TCHAR) 0x01)
#define CTLB            ((TCHAR) 0x02)
#define CTLC            ((TCHAR) 0x03)
#define CTLD            ((TCHAR) 0x04)
#define CTLE            ((TCHAR) 0x05)
#define CTLF            ((TCHAR) 0x06)
#define CTLG            ((TCHAR) 0x07)
#define CTLH            ((TCHAR) 0x08)
#define CTLI            ((TCHAR) 0x09)
#define CTLJ            ((TCHAR) 0x0A)
#define CTLK            ((TCHAR) 0x0B)
#define CTLL            ((TCHAR) 0x0C)
#define CTLM            ((TCHAR) 0x0D)
#define CTLN            ((TCHAR) 0x0E)
#define CTLO            ((TCHAR) 0x0F)
#define CTLP            ((TCHAR) 0x10)
#define CTLQ            ((TCHAR) 0x11)
#define CTLR            ((TCHAR) 0x12)
#define CTLS            ((TCHAR) 0x13)
#define CTLT            ((TCHAR) 0x14)
#define CTLU            ((TCHAR) 0x15)
#define CTLV            ((TCHAR) 0x16)
#define CTLW            ((TCHAR) 0x17)
#define CTLX            ((TCHAR) 0x18)
#define CTLY            ((TCHAR) 0x19)
#define CTLZ            ((TCHAR) 0x1A)
#define CTL1            ((TCHAR) 0x1B)
#define CTL2            ((TCHAR) 0x1C)
#define CTL3            ((TCHAR) 0x1D)
#define CTL4            ((TCHAR) 0x1E)
#define CTL5            ((TCHAR) 0x1F)

/*
    for keyboard translation tables
*/

#define K_EN            K_END
#define K_HO            K_HOME
#define K_LE            K_LARROW
#define K_RI            K_RARROW
#define K_UP            K_UARROW
#define K_DO            K_DARROW
#define K_IN            K_INSERT
#define K_DE            K_DELETE
#define K_CG            K_CGRAVE
#define K_PU            K_PAGEUP
#define K_PD            K_PAGEDOWN

#define K_FA            K_F10
#define K_FB            K_F11
#define K_FC            K_F12

#define K_S1            K_SF1
#define K_S2            K_SF2
#define K_S3            K_SF3
#define K_S4            K_SF4
#define K_S5            K_SF5
#define K_S6            K_SF6
#define K_S7            K_SF7
#define K_S8            K_SF8
#define K_S9            K_SF9
#define K_SA            K_SF10
#define K_SB            K_SF11
#define K_SC            K_SF12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\inc\tcsrvc.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *       tcsrvc.h
 *
 * Contains the structure definition for exchanging information between 
 * the client and the server.
 *
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

#define TCSERV_MUTEX_NAME _T("Microsoft-TCSERV-Mutex")

#ifndef MAX_BUFFER_SIZE
#define MAX_BUFFER_SIZE 256
#endif


typedef struct _CLIENT_INFO{
    int len;
    TCHAR device[MAX_BUFFER_SIZE];
} CLIENT_INFO, *PCLIENT_INFO;

#define SERVICE_PORT 3876

#define HKEY_TCSERV_PARAMETER_KEY _T("System\\CurrentControlSet\\Services\\TCSERV\\Parameters")

#define TCSERV_NAME _T("TCSERV")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\client\console.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        console.c
 *
 * Hacks to read characters from the NT console 
 * Taken from nt\sdktools\vi\nt.c 
 * 
 * 
 * Sadagopan Rajaram -- Nov 5, 1999
 *
 */

#include "tcclnt.h"
#include "keymap.h"

#define     MAX_VK   0x7f

TCHAR RegularTable[] =  {ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 08 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 10 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 18 */  ZERO, ZERO, ZERO, ESCP, ZERO, ZERO, ZERO, ZERO,
              /* 20 */  ZERO, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, ZERO, ZERO, ZERO, ZERO, K_IN, K_DE, ZERO,
              /* 30 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 38 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 40 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 48 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 50 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 58 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 60 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 68 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 70 */  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8,
              /* 78 */  K_F9, K_FA, K_FB, K_FC, ZERO, ZERO, ZERO, ZERO};

TCHAR ShiftedTable[] = { ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 08 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 10 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 18 */  ZERO, ZERO, ZERO, ESCP, ZERO, ZERO, ZERO, ZERO,
              /* 20 */  ZERO, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, ZERO, ZERO, ZERO, ZERO, K_IN, K_DE, ZERO,
              /* 30 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 38 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 40 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 48 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 50 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 58 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 60 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 68 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 70 */  K_S1, K_S2, K_S3, K_S4, K_S5, K_S6, K_S7, K_S8,
              /* 78 */  K_S9, K_SA, K_SB, K_SC, ZERO, ZERO, ZERO, ZERO};

TCHAR ControlTable[] = { ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 08 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 10 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 18 */  ZERO, ZERO, ZERO, ESCP, ZERO, ZERO, K_CG, ZERO,
              /* 20 */  ZERO, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, ZERO, ZERO, ZERO, ZERO, K_IN, K_DE, ZERO,
              /* 30 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 38 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 40 */  ZERO, CTLA, CTLB, CTLC, CTLD, CTLE, CTLF, CTLG,
              /* 48 */  CTLH, CTLI, CTLJ, CTLK, CTLL, CTLM, CTLN, CTLO,
              /* 50 */  CTLP, CTLQ, CTLR, CTLS, CTLT, CTLU, CTLV, CTLW,
              /* 58 */  CTLX, CTLY, CTLZ, CTL1, CTL2, CTL3, CTL4, CTL5,
              /* 60 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 68 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 70 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,
              /* 78 */  ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO};

#define ALT_PRESSED (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)
#define CTL_PRESSED (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)
#define CONTROL_ALT (ALT_PRESSED | CTL_PRESSED)

/*
 * inTCHAR() - get a TCHARacter from the keyboard
 * Reads only ascii TCHARacters from the keyboard.
 */
void
inchar(CHAR *buff)
{
    INPUT_RECORD    InputRec;
    DWORD           NumRead;
    int len;

    while(1) {    /* loop until we get a valid console event */
        ReadConsoleInput(InputHandle,&InputRec,1,&NumRead);
        if((InputRec.EventType == KEY_EVENT)
           && (InputRec.Event.KeyEvent.bKeyDown)){
            KEY_EVENT_RECORD *KE = &InputRec.Event.KeyEvent;
            TCHAR *Table;


            if(KE->dwControlKeyState & ALT_PRESSED) {
                if ((KE->uChar.AsciiChar == 'x')||(KE->uChar.AsciiChar == 'X')) {
                    exit(0);
                }
                continue;       // no ALT keys allowed.
            } else{
                if(KE->dwControlKeyState & CTL_PRESSED) {
                    Table = ControlTable;
                } else {
                   // We might have a character in Unicode
                    #ifdef UNICODE
                    if(KE->uChar.UnicodeChar) {    // no control, no alt
                        // convert to dbcs character and return
                        len= wctomb(buff,KE->uChar.UnicodeChar);
                        if(len == -1){
                            continue;
                        }
                        buff[len] = (CHAR) 0;
                        return;
                    #else
                    if(KE->uChar.AsciiChar){
                        buff[0] = KE->uChar.AsciiChar;
                        buff[1] = (CHAR) 0;
                        return;
                    #endif

                    } else {
                        if(KE->dwControlKeyState & SHIFT_PRESSED) {
                            Table = ShiftedTable;
                        } else {
                            Table = RegularTable;
                        }
                    }
                }
            }

            if((KE->wVirtualKeyCode > MAX_VK) || !Table[KE->wVirtualKeyCode]) {
                continue;
            }
            #ifdef UNICODE
            // convert to dbcs character and return
            len= wctomb(buff,Table[KE->wVirtualKeyCode]);
            if(len == -1){
                continue;
            }
            buff[len] = (CHAR) 0;
            #else 
            buff[0] = Table[KE->wVirtualKeyCode];
            buff[1] = (CHAR) 0;
            #endif
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\client\main.c ===
/*
 * Copyright (c) Microsoft Corporation
 *
 * Module Name :
 *        main.c
 *
 * This is the main file containing the client code.
 *
 *
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */

// Can kill this program on a normal NT console using the
// Alt - X Key combination. Just a shortcut, that is all.
// Serves no useful purpose.

#include "tcclnt.h"
#include "tcsrvc.h"

WSABUF ReceiveBuffer;
CHAR RecvBuf[MAX_BUFFER_SIZE];
IO_STATUS_BLOCK IoStatus;
HANDLE InputHandle;
DWORD bytesRecvd;
WSAOVERLAPPED junk;
SOCKET cli_sock;
DWORD flags;

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
inputUpdate(
    PVOID dummy
    )
{
    // Runs in a single thread getting all the inputs
    // from the keyboard.

    ULONG result;
    // gets a multibyte string for every character
    // pressed on the keyboard.
    CHAR r[MB_CUR_MAX + 1];

    while(1){
         r[0] = _T('\0');
         inchar(r);
         // BUGBUG - Performance issues in sending a single character
         // at a time across the n/w
        if(strlen(r)){
            // may send a single byte or two bytes.
            send(cli_sock,r,strlen(r),0);
        }
    }
    return 1;

}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

VOID sendUpdate(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverLapped,
    IN DWORD dwFlags
    )
{
    int error,i;
    // Receives a packet and sends it through the stream parser
    // BUGBUG - For effeciency it can be made inline.
    // I am not sure of the performance increase, but it should
    // be substantial as we will be sending a lot of data.

    if(dwError != 0){
        exit(1);
    }
    for(i=0;i < (int)cbTransferred;i++){
        PrintChar(ReceiveBuffer.buf[i]);
    }
    // Repost the receive on the socket.

    error = WSARecv(cli_sock,
                    &ReceiveBuffer,
                    1,
                    &bytesRecvd,
                    &flags,
                    &junk,
                    sendUpdate
                    );
    if((error == SOCKET_ERROR)
       &&(WSAGetLastError()!=WSA_IO_PENDING)){
        // Implies something wrong with the socket.
        exit(1);
    }
    return;

}

int __cdecl
main(
    IN int argc,
    char *argv[]
    )
/*++
   Opens a single port, binds to the tcserver and passes information back and forth.
--*/
{
    struct sockaddr_in srv_addr,cli_addr;
    LPHOSTENT host_info;
    CLIENT_INFO SendInfo;
    int status;
    WSADATA data;
    #ifdef UNICODE
    // BUGBUG - Trying to write a code that works for
    // both Unicode and ASCII. Gets multi byte sequences
    // Confusion when the tcclnt and tcclnt are in different
    // modes.
    ANSI_STRING Src;
    UNICODE_STRING Dest;
    #endif
    NTSTATUS Status;
    HANDLE Thread;
    DWORD ThreadId;
    COORD coord;
    SMALL_RECT rect;
    int RetVal;
    struct hostent *ht;
    ULONG r;
    TCHAR Buffer[80];



    if((argc<2) || (argc >4)){
        // Error in running the program
        printf("Usage - tcclnt COMPORTNAME [ipaddress]\n");
        exit(0);
    }

    ThreadId = GetEnvironmentVariable(_T("TERM"),Buffer , 80);
    // We need to know if we have a vt100 screen or an ANSI screen.
    AttributeFunction = ProcessTextAttributes;
    if(ThreadId >0){
        // Terminal type exists in the environment.
        // Use it
        if((_tcsncmp(Buffer, _T("VT100"), 5) == 0)||
            _tcsncmp(Buffer, _T("vt100"),5) ==0 )
            AttributeFunction = vt100Attributes;
    }

    hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    coord.X = MAX_TERMINAL_WIDTH;
    coord.Y = MAX_TERMINAL_HEIGHT;
    rect.Left = rect.Top = 0;
    rect.Right = MAX_TERMINAL_WIDTH -1;
    rect.Bottom = MAX_TERMINAL_HEIGHT -1;

    if(hConsoleOutput == NULL){
        printf("Could not get current console handle %d\n", GetLastError());
        return 1;
    }

    RetVal = SetConsoleScreenBufferSize(hConsoleOutput,
                                        coord
                                        );

    RetVal = SetConsoleWindowInfo(hConsoleOutput,
                                  TRUE,
                                  &rect
                                  );
    if (RetVal == FALSE) {
        printf("Could not set window size %d\n", GetLastError());
        return 1;
    }
    RetVal = SetConsoleMode(hConsoleOutput,ENABLE_PROCESSED_OUTPUT);
    if(RetVal == FALSE){
        printf("Could not console mode %d\n", GetLastError());
        return 1;
    }

    /* Set up client socket */
    InputHandle = GetStdHandle(STD_INPUT_HANDLE);
    if(InputHandle == NULL) return 1;
    SetConsoleMode(InputHandle, 0);
    status=WSAStartup(514,&data);

    if(status){
        printf("Cannot start up %d\n",status);
        return(1);
    }

    cli_sock=WSASocket(PF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED);

    if (cli_sock==INVALID_SOCKET){
        printf("Windows Sockets error %d: Couldn't create socket.",
                WSAGetLastError());
        return(1);
    }

    cli_addr.sin_family=AF_INET;
    cli_addr.sin_addr.s_addr=INADDR_ANY;
    cli_addr.sin_port=0;                /* no specific port req'd */

    /* Bind client socket to any local interface and port */

    if (bind(cli_sock,(LPSOCKADDR)&cli_addr,sizeof(cli_addr))==SOCKET_ERROR){
        printf("Windows Sockets error %d: Couldn't bind socket.",
                WSAGetLastError());
        return(1);
    }

    srv_addr.sin_family = AF_INET;
    if(argc == 3){
        srv_addr.sin_addr.s_addr = inet_addr(argv[2]);
        if (srv_addr.sin_addr.s_addr == INADDR_NONE) {
            ht = gethostbyname(argv[2]);
            if(!ht || !ht->h_addr){ // cannot resolve the name
                printf("Cannot resolve %s", argv[2]);
                exit(1);
            }
            memcpy((&(srv_addr.sin_addr.s_addr)),ht->h_addr, ht->h_length);
        }
    }
    else{
        srv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    }
    srv_addr.sin_port=htons(SERVICE_PORT);

    /* Connect to FTP server at address SERVER */

    if (connect(cli_sock,(LPSOCKADDR)&srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
        printf("Windows Sockets error %d: Couldn't connect socket.\n",
               WSAGetLastError());
        return(1);
    }

    SendInfo.len = sizeof(CLIENT_INFO);

    #ifdef UNICODE
    Src.Buffer = argv[1];
    Src.Length = (USHORT)strlen(argv[1]);
    Dest.Buffer = SendInfo.device;
    Dest.MaximumLength = MAX_BUFFER_SIZE;
    Status = RtlAnsiStringToUnicodeString(&Dest, &Src, FALSE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed, ec = 0x%08x\n",Status);
        exit(1);
    }
    send(cli_sock, (PCHAR) &SendInfo, sizeof(CLIENT_INFO), 0);
    #else
    // We are sending to an ANSI String
    strcpy(SendInfo.device, argv[1]);
    send(cli_sock, (PCHAR) &SendInfo, sizeof(CLIENT_INFO), 0);
    #endif
    ReceiveBuffer.len = MAX_BUFFER_SIZE;
    ReceiveBuffer.buf = RecvBuf;
    status=WSARecv(cli_sock,
            &ReceiveBuffer,
            1,
            &bytesRecvd,
            &flags,
            &junk,
            sendUpdate
            );
    if((status == SOCKET_ERROR)
       &&(WSAGetLastError() != WSA_IO_PENDING)){
        printf("Error in recv %d\n",WSAGetLastError());
        exit(1);
    }
    // Create a thread that gets input from the console
    // to send to the bridge.
    Thread = CreateThread(NULL,
                          0,
                          inputUpdate,
                          NULL,
                          0,
                          &ThreadId
                          );
    if (Thread== NULL) {
        exit(1);
    }
    CloseHandle(Thread);

    while(1){
        // Put this thread in an alertable
        // state so that the receive calls can
        // asynchronously terminate within the
        // context of this thread.
        status=SleepEx(INFINITE,TRUE);
    }
    // We never return here.
    closesocket(cli_sock);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\client\tcclnt.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcclnt.h
 *
 * Contains the include files used by the client
 *
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

//
//  NT public header files
//
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//
// netlib header.
//

#include <lmcons.h>
#include <secobj.h>
#include <conio.h>

#define MAX_TERMINAL_WIDTH 80
#define MAX_TERMINAL_HEIGHT 24

extern HANDLE hConsoleOutput;
extern HANDLE InputHandle;
extern VOID (*AttributeFunction)(PCHAR,int); 
// BUGBUG - dont know where this constant is really defined
#undef MB_CUR_MAX
#define MB_CUR_MAX 2

VOID 
ProcessEscapeSequence(
    PCHAR Buffer,
    int length
    );

BOOLEAN 
FinalCharacter(
    CHAR c
    );

VOID 
PrintChar(
    CHAR c
    );

VOID
ProcessTextAttributes(
    PCHAR Buffer,
    int length
    );

VOID inchar(
    CHAR *buff
    );

VOID
vt100Attributes(
    PCHAR Buffer,
    int length
    );

VOID
OutputConsole(
    CHAR byte
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\bridge.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        bridge.c
 *
 * This contains the main worker thread that passes information between the clients 
 * the Com port.
 * 
 * Sadagopan Rajaram -- Oct 15, 1999
 *
 */

#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

 
DWORD 
bridge(
    PCOM_PORT_INFO pComPortInfo
    )
{
    NTSTATUS Status;
    PCONNECTION_INFO pTemp;
    DWORD waitStatus; 
    int SocketStatus;


    Status = ReadFile(pComPortInfo->ComPortHandle, 
                      pComPortInfo->Buffer,
                      MAX_QUEUE_SIZE,
                      &(pComPortInfo->BytesRead),
                      &(pComPortInfo->Overlapped)
                      );
    if (!NT_SUCCESS(Status)) {
        TCDebugPrint(("Could not read from Com Port %x\n",GetLastError()));
        goto end;
    }

    while(1){
        MutexLock(pComPortInfo);
        // Get the new sockets that have been added to the port since
        // you were asleep. Send them the requested information and add 
        // them to the connections list so that they are primed to receive 
        // information.
        while(pComPortInfo->Sockets != NULL){
            pTemp = pComPortInfo->Sockets;
            SocketStatus = 1;
            if(pTemp->Flags){
                SocketStatus=GetBufferInfo(pTemp, pComPortInfo);
                pTemp->Flags = 0;
            }
            TCDebugPrint(("Got conn\n"));
            pComPortInfo->Sockets = pTemp->Next;
            pTemp->Next = pComPortInfo->Connections;
            pComPortInfo->Connections = pTemp;
            if (SocketStatus == SOCKET_ERROR) {
                TCDebugPrint(("something wrong with socket %d\n",
                              WSAGetLastError()));
                CleanupSocket(pTemp);
                continue;
            }
            SocketStatus = WSARecv(pTemp->Socket, 
                             &(pTemp->Buffer),
                             1 ,
                             &(pTemp->BytesRecvd),
                             &(pTemp->Flags),
                             &(pTemp->Overlapped),
                             updateComPort
                             );
            if (SocketStatus == SOCKET_ERROR ) {
                SocketStatus = WSAGetLastError();
                if (SocketStatus != WSA_IO_PENDING) {
                    TCDebugPrint(("something wrong with socket %d\n",
                              SocketStatus));
                    CleanupSocket(pTemp);
                }
            }
        }
        MutexRelease(pComPortInfo);
wait:
        waitStatus=NtWaitForMultipleObjects(4, 
                                            pComPortInfo->Events, 
                                            WaitAny, 
                                            TRUE,
                                            NULL
                                            );
        if(waitStatus == WAIT_FAILED){
            TCDebugPrint(("Fatal Error %x", waitStatus));
            closesocket(MainSocket);
            goto end;
        }
        else{
            if(waitStatus == WAIT_IO_COMPLETION){
                goto wait;
            }
            waitStatus = waitStatus - WAIT_OBJECT_0;
            switch(waitStatus){
            case 0:
                Status = STATUS_SUCCESS;
                goto end;
                break;
            case 1:
                ResetEvent(pComPortInfo->Events[1]);
                break;
            case 2:
                ResetEvent(pComPortInfo->Events[2]);
                updateClients(pComPortInfo);
                goto wait;
                break;
            case 3:
                Status = STATUS_SUCCESS;
                ResetEvent(pComPortInfo->Events[3]);
                goto end;
                break;
            default:
                goto wait;
                break;
            }

        }
    }
end:

    // Cancel the pending IRPs and close all the sockets.
    TCDebugPrint(("Cancelling all irps and shutting down the thread\n"));
    MutexLock(pComPortInfo);
    CancelIo(pComPortInfo->ComPortHandle);
    NtClose(pComPortInfo->ComPortHandle);
    while(pComPortInfo->Sockets != NULL){
        pTemp = pComPortInfo->Sockets;
        closesocket(pTemp->Socket);
        pComPortInfo->Sockets = pTemp->Next;
        pTemp->Next = NULL;
        TCFree(pTemp);
    }
    pTemp = pComPortInfo->Connections;
    while(pTemp != NULL){
        closesocket(pTemp->Socket);
        pTemp = pTemp->Next;
    }
    pComPortInfo->ShuttingDown = TRUE;
    if(pComPortInfo->Connections == NULL) SetEvent(pComPortInfo->TerminateEvent);
    MutexRelease(pComPortInfo);
wait2:
    waitStatus=NtWaitForSingleObject(pComPortInfo->TerminateEvent,TRUE,NULL);
    if(waitStatus == WAIT_IO_COMPLETION){
        goto wait2;
    }
    TCDebugPrint(("End of COM port\n"));
    return Status;
}

VOID 
CALLBACK
updateComPort(
    IN DWORD dwError, 
    IN DWORD cbTransferred, 
    IN LPWSAOVERLAPPED lpOverlapped, 
    IN DWORD dwFlags
    )

/*++ 
    Writes the data that it has gotten from the socket to all the connection
    that it currently has and to the com port.
--*/
{


    PCONNECTION_INFO pTemp = (PCONNECTION_INFO) lpOverlapped->hEvent;
    PCONNECTION_INFO pConn;
    PCOM_PORT_INFO pComPort;
    int Status;

    pComPort = pTemp->pComPortInfo;
    MutexLock(pComPort);
    if((cbTransferred == 0) && (dwError == 0)) {
        // For byte stream socket, this indicates graceful closure
        CleanupSocket(pTemp);
        MutexRelease(pComPort);
        return;
    }
    // If socket closed, remove it from the connection list. 
    if(pComPort->ShuttingDown){
        CleanupSocket(pTemp);
        if(pComPort->Connections == NULL){
            SetEvent(pComPort->TerminateEvent);
            MutexRelease(pComPort);
            return;
        }
        MutexRelease(pComPort);
        return;
    }
    if (dwError != 0) {
        // Something wrong with the connection. Close the socket and
        // delete it from the listeners list.
        CleanupSocket(pTemp);
        MutexRelease(pComPort);
        return;
    }

    Status =WriteFile(pComPort->ComPortHandle,
              (pTemp->Buffer).buf,
              cbTransferred,
              &(pTemp->BytesRecvd),
              &(pComPort->WriteOverlapped)
              );
    if(!Status){
        if(GetLastError() != ERROR_IO_PENDING)
            TCDebugPrint(("Error writing to comport %d",GetLastError()));
    }
    Status = WSARecv(pTemp->Socket, 
                     &(pTemp->Buffer),
                     1 ,
                     &(pTemp->BytesRecvd),
                     &(pTemp->Flags),
                     &(pTemp->Overlapped),
                     updateComPort
                     );
    if (Status == SOCKET_ERROR ) {
        Status = WSAGetLastError();
        if (Status != WSA_IO_PENDING) {
            TCDebugPrint(("something wrong with socket %d\n",
                          Status));
            CleanupSocket(pTemp);
        }
    }
    MutexRelease(pComPort);
    return;
}

VOID
updateClients(
    PCOM_PORT_INFO pComPortInfo

    )
/*++
    Writes the data that it has gotten from the com port to all the connection
    that it currently has
--*/
{
    PCONNECTION_INFO pConn;
    BOOL Status;
    DWORD Error;
    NTSTATUS stat;


  
    if((pComPortInfo->Overlapped.InternalHigh == 0)||
        (!NT_SUCCESS(pComPortInfo->Overlapped.Internal))){
        TCDebugPrint(("Problem with Com Port %x\n", pComPortInfo->Overlapped.Internal));
        MutexLock(pComPortInfo);
        if(pComPortInfo->ShuttingDown){
            // will never occur because this is a procedure called from
            // the thread
            MutexRelease(pComPortInfo);
            return;
        }
        if (pComPortInfo->Overlapped.Internal == STATUS_CANCELLED){
            // something wrong, try reinitializing the com port
            // this thing happens every time the m/c on the other end 
            // reboots. Pretty painful.Probably can improve this later.
            // Why should the reboot cause this com port 
            // to go awry ?? 
            stat = NtClose(pComPortInfo->ComPortHandle);
            if(!NT_SUCCESS(stat)){
                TCDebugPrint(("Cannot close handle\n"));
            }
            stat = InitializeComPort(pComPortInfo);
            if(!NT_SUCCESS(stat)){
                TCDebugPrint(("Cannot reinitialize com port\n"));
                MutexRelease(pComPortInfo);
                return;
            }
        }
        Status = ReadFile(pComPortInfo->ComPortHandle, 
                          pComPortInfo->Buffer,
                          MAX_QUEUE_SIZE,
                          &(pComPortInfo->BytesRead),
                          &(pComPortInfo->Overlapped)
                          );
        if(Status == 0){
            if ((Error = GetLastError()) != ERROR_IO_PENDING) {
                TCDebugPrint(("Error = %d\n", Error));
            }
        }
        MutexRelease(pComPortInfo);

        return;
    }
    MutexLock(pComPortInfo);
    Enqueue(pComPortInfo);
    pConn = pComPortInfo->Connections;
    while(pConn!=NULL){
        send(pConn->Socket, 
             pComPortInfo->Buffer, 
             (int)pComPortInfo->Overlapped.InternalHigh,
             0
             );
        pConn = pConn->Next;
    } 
    Status = ReadFile(pComPortInfo->ComPortHandle, 
                      pComPortInfo->Buffer,
                      MAX_QUEUE_SIZE,
                      &(pComPortInfo->BytesRead),
                      &(pComPortInfo->Overlapped)
                      );
    if (Status == 0) {
        if((Error=GetLastError())!= ERROR_IO_PENDING){
            TCDebugPrint(("Problem with Com Port %x\n", Error));
        }
    }
    MutexRelease(pComPortInfo);
    return;
}

VOID CleanupSocket(
    PCONNECTION_INFO pConn
    )
{
    PCOM_PORT_INFO pTemp;
    PCONNECTION_INFO pPrevConn;

    // Assume that the structure is locked earlier. 
    // the socket connection is closed when this occurs.
    // We free the socket either if the TCP port on the 
    // client end has died or we are deleting this com port.
    pTemp = pConn->pComPortInfo;
    if(pConn == pTemp->Connections) {
        pTemp->Connections = pConn->Next;
    }
    else{
        pPrevConn = pTemp->Connections;
        while((pPrevConn !=NULL) &&(pPrevConn->Next != pConn)){
            pPrevConn=pPrevConn->Next;
        }
        if(pPrevConn == NULL) return;
        pPrevConn->Next = pConn->Next;
     }
    pConn->Next = NULL;
    TCFree(pConn); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\debug.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the binl server.

Author:

    Colin Watson (colinw)  14-Apr-1997

Environment:

    User Mode - Win32

Revision History:


--*/


#if DBG==1
// Leak detection
//


#define INITIALIZE_TRACE_MEMORY     InitializeCriticalSection( &g_TraceMemoryCS );\
                                    g_TraceMemoryTable = NULL;
#define UNINITIALIZE_TRACE_MEMORY   DebugMemoryCheck( );\
                                    DeleteCriticalSection( &g_TraceMemoryCS );

extern CRITICAL_SECTION g_TraceMemoryCS;

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCSTR pszComment;
    struct _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

extern LPMEMORYBLOCK g_TraceMemoryTable;

HGLOBAL
DebugAlloc(
    UINT    uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment );

void
DebugMemoryDelete(
    HGLOBAL hglobal );

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    DWORD   dwBytes,
    LPCSTR pszComment );

HGLOBAL
DebugFree(
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

HGLOBAL
TCReAlloc(
    HGLOBAL mem,
    DWORD size,
    LPCSTR comment
    );


#define TCAllocate(x,s) DebugAlloc(GMEM_ZEROINIT, x, s)
#define TCFree(x)     DebugFree(x)
        
#define TCDebugPrint(x) DbgPrint x

#else   // not DBG

#define INITIALIZE_TRACE_MEMORY
#define UNINITIALIZE_TRACE_MEMORY

#define TCDebugPrint(x) 
#define TCAllocate(x,s) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, x)
#define TCFree(x)     HeapFree(GetProcessHeap(),0,x)
#define TCReAlloc(x, y , z) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x,y)


#endif // not DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\client\parser.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        parser.c
 *
 * This is the file containing the client code for parsing vt100 escape sequences 
 * into console mode output. 
 * 
 * 
 * Sadagopan Rajaram -- Nov 3, 1999
 *
 */

#include "tcclnt.h"

 
CHAR FinalCharacters[] = "mHJKr";
HANDLE hConsoleOutput;
BOOLEAN InEscape=FALSE; 
BOOLEAN lastCharM = FALSE;
CHAR EscapeBuffer[MAX_TERMINAL_WIDTH];
int index=0;
SHORT ScrollTop = 0;
SHORT ScrollBottom = MAX_TERMINAL_HEIGHT -1; 
#ifdef UNICODE
int DBCSIndex = 0;
CHAR DBCSArray[MB_CUR_MAX+1];
#endif

VOID (*AttributeFunction)(PCHAR, int);

VOID 
PrintChar(
    CHAR c
    )
{
    // A boolean variable to check if we are processing an escape sequence

    if(c == '\033'){
        InEscape = TRUE;
        EscapeBuffer[0] = c;
        index = 1;
        return;
    }
    if(InEscape == TRUE){
        if(index == MAX_TERMINAL_WIDTH){
            // vague escape sequence,give up processing
            InEscape = FALSE;
            index=0;
            return;
        }
        EscapeBuffer[index]=c;
        index++;
        if(FinalCharacter(c)){
            if(c=='m'){
                // maybe getting \017
                lastCharM = TRUE;
            }
            ProcessEscapeSequence(EscapeBuffer, index);
            InEscape = FALSE;
            index=0;
        }
        return;
    }
    if(lastCharM && c == '\017'){
        lastCharM = FALSE;
        return;
    }
    OutputConsole(c);
    return;
}

BOOLEAN 
FinalCharacter(
    CHAR c
    )
{

    if(strchr(FinalCharacters,c)){
        return TRUE;
    }
    return FALSE;

}

VOID 
ProcessEscapeSequence(
    PCHAR Buffer,
    int length
    )
{


    // BUGBUG - Function too big, can optimize code size by having 
    // an action variable which is initialized when the strings are 
    // compared, so that cut and paste code can be eliminated.

    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    ULONG charsToWrite;
    ULONG charsWritten;
    PCHAR pTemp;
    int RetVal;



    if (length == 3) {
        // One of the home cursor or clear to end of display
        if (strncmp(Buffer,"\033[H",length)==0) {
            // Home the cursor
            csbInfo.dwCursorPosition.X = 0;
            csbInfo.dwCursorPosition.Y = 0;
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if(strncmp(Buffer,"\033[J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            SetConsoleMode(hConsoleOutput,
                           ENABLE_WRAP_AT_EOL_OUTPUT|ENABLE_PROCESSED_OUTPUT
                           );

            charsToWrite = (MAX_TERMINAL_HEIGHT - 
                            csbInfo.dwCursorPosition.Y)*MAX_TERMINAL_WIDTH - 
                csbInfo.dwCursorPosition.X;
            
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );


            SetConsoleMode(hConsoleOutput,
                           ENABLE_PROCESSED_OUTPUT
                           );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if(strncmp(Buffer,"\033[K", length) == 0){
            // clear to end of line assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            charsToWrite = (MAX_TERMINAL_WIDTH - csbInfo.dwCursorPosition.X);
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if (strncmp(Buffer,"\033[r", length) == 0) {
            ScrollTop = 0;
            ScrollBottom = MAX_TERMINAL_HEIGHT -1;
        }
    }

    if (length == 4) {
        // One of the home cursor or clear to end of display
        if (strncmp(Buffer,"\033[0H",length)==0) {
            // Home the cursor
            csbInfo.dwCursorPosition.X = 0;
            csbInfo.dwCursorPosition.Y = 0;
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if(strncmp(Buffer,"\033[2J",length) == 0){
            // Home the cursor
            csbInfo.dwCursorPosition.X = 0;
            csbInfo.dwCursorPosition.Y = 0;
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            sprintf(Buffer, "\033[0J");
        }

        if(strncmp(Buffer,"\033[0J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            SetConsoleMode(hConsoleOutput,
                           ENABLE_WRAP_AT_EOL_OUTPUT|ENABLE_PROCESSED_OUTPUT
                           );

            charsToWrite = (MAX_TERMINAL_HEIGHT - 
                            csbInfo.dwCursorPosition.Y)*MAX_TERMINAL_WIDTH - 
                csbInfo.dwCursorPosition.X;
            
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );


            SetConsoleMode(hConsoleOutput,
                           ENABLE_PROCESSED_OUTPUT
                           );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if((strncmp(Buffer,"\033[0K", length) == 0) || 
           (strncmp(Buffer,"\033[2K",length) == 0)){
            // clear to end of line assuming 80 X 24 size
            RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                                &csbInfo
                                                );
            if (RetVal == FALSE) {
                return;
            }
            charsToWrite = (MAX_TERMINAL_WIDTH - csbInfo.dwCursorPosition.X);
            RetVal = FillConsoleOutputAttribute(hConsoleOutput,
                                                csbInfo.wAttributes,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                0,
                                                charsToWrite,
                                                csbInfo.dwCursorPosition,
                                                &charsWritten
                                                );
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
            return;
        }
        if((strncmp(Buffer,"\033[0m", length) == 0)||
           (strncmp(Buffer,"\033[m\017", length) == 0)){
            // clear all attributes and set Text attributes to black on white
            SetConsoleTextAttribute(hConsoleOutput, 
                             FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN
                             );

            return;
        }
    }

    if(Buffer[length-1] == 'm'){
        //set the text attributes
        // clear all attributes and set Text attributes to white on black
        SetConsoleTextAttribute(hConsoleOutput, 
                         FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN
                         );
        AttributeFunction(Buffer, length);
        return;
    }


    if(Buffer[length -1] == 'H'){
        // Set cursor position
        if (sscanf(Buffer,"\033[%d;%d", &charsToWrite, &charsWritten) == 2) {
            csbInfo.dwCursorPosition.Y = (SHORT)(charsToWrite -1);
            csbInfo.dwCursorPosition.X = (SHORT)(charsWritten -1);
            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
        }
        return;

    }
    if(Buffer[length -1] == 'r'){
        // Set scroll region
        sscanf(Buffer,"\033[%d;%d", &charsToWrite,&charsWritten);
        if ((charsToWrite < 1) 
            || (charsToWrite > MAX_TERMINAL_HEIGHT)
            || (charsWritten < charsToWrite)) { 
            return;
        }
        ScrollTop    = (SHORT)(charsToWrite -1);
        ScrollBottom = (SHORT)(charsWritten -1);
    }
    return;
}

VOID
ProcessTextAttributes(
    PCHAR Buffer,
    int length
    )
{
    PCHAR CurrLoc = Buffer;
    ULONG Attribute;
    WORD TextAttribute = 0;
    BOOLEAN Reverse = FALSE;
    PCHAR pTemp;
    
    while(*CurrLoc != 'm'){
        if((*CurrLoc < '0') || (*CurrLoc >'9' )){
            CurrLoc ++;
        }else{
            if (sscanf(CurrLoc,"%d", &Attribute) != 1) {
                return;
            }
            switch(Attribute){
            case 1:
                TextAttribute = TextAttribute | FOREGROUND_INTENSITY;
                break;
            case 37:
                TextAttribute = TextAttribute|FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN;
                break;
            case 47:
                TextAttribute = TextAttribute|BACKGROUND_RED |BACKGROUND_BLUE |BACKGROUND_GREEN;
                break;
            case 34:
                TextAttribute = TextAttribute|FOREGROUND_BLUE;
                break;
            case 44:
                TextAttribute = TextAttribute|BACKGROUND_BLUE;
                break;
            case 31: 
                TextAttribute = TextAttribute|FOREGROUND_RED;
                break;
            case 41:
                TextAttribute = TextAttribute|BACKGROUND_RED;
                break;
            case 33: 
                TextAttribute = TextAttribute|FOREGROUND_GREEN|FOREGROUND_BLUE;
                break;
            case 43:
                TextAttribute = TextAttribute|BACKGROUND_GREEN|BACKGROUND_BLUE;
                break;
            case 7:
                // Reverse the background and foreground colors
                Reverse=TRUE;
            default:
                break;
            }
            pTemp = strchr(CurrLoc, ';');
            if(pTemp == NULL){
                pTemp = strchr(CurrLoc, 'm');
            }
            if(pTemp == NULL) {
                break;
            }
            CurrLoc = pTemp;

        }
    }
    if (Reverse) {
        if ((!TextAttribute) || 
            (TextAttribute == FOREGROUND_INTENSITY)) {
            // Reverse vt100 escape sequence.
            TextAttribute = TextAttribute | 
                BACKGROUND_RED |BACKGROUND_BLUE |BACKGROUND_GREEN;
        }
    }
    if(TextAttribute){
        SetConsoleTextAttribute(hConsoleOutput,
                         TextAttribute
                         );
    }
    return;

}


VOID
vt100Attributes(
    PCHAR Buffer,
    int length
    )
{
    PCHAR CurrLoc = Buffer;
    ULONG Attribute;
    WORD TextAttribute = 0;
    PCHAR pTemp;

    while(*CurrLoc != 'm'){
        if((*CurrLoc < '0') || (*CurrLoc >'9' )){
            CurrLoc ++;
        }else{
            if (sscanf(CurrLoc,"%d", &Attribute) != 1) {
                return;
            }

            switch(Attribute){
            case 1:
                TextAttribute = TextAttribute | FOREGROUND_INTENSITY;
                break;
            case 5:
                TextAttribute = TextAttribute | BACKGROUND_INTENSITY;
                break;
            case 7:
                TextAttribute = TextAttribute | 
                BACKGROUND_RED |BACKGROUND_BLUE |BACKGROUND_GREEN;
                break;
            default:
                break;
            }
            pTemp = strchr(CurrLoc, ';');
            if(pTemp == NULL){
                pTemp = strchr(CurrLoc, 'm');
            }
            if(pTemp == NULL) {
                break;
            }
            CurrLoc = pTemp;

        }
    }
    if(TextAttribute){
        SetConsoleTextAttribute(hConsoleOutput,
                                TextAttribute
                                );
    }
    return;
}

VOID
OutputConsole(
    CHAR byte
    )
{

    CONSOLE_SCREEN_BUFFER_INFO csbInfo;
    COORD dwBufferCoord;
    SMALL_RECT sRect;
    BOOL RetVal;
    TCHAR Char;
    SHORT ypos;
    CHAR_INFO Fill;
    DWORD charsWritten;


    if (byte == '\n'){
        RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                            &csbInfo
                                            );
        if (RetVal == FALSE) {
            return;
        }
        ypos = csbInfo.dwCursorPosition.Y;
        if ((ypos == ScrollBottom ) || (ypos == MAX_TERMINAL_HEIGHT -1 )) {
            // Do the scrolling
            dwBufferCoord.X = 0;
            dwBufferCoord.Y = ScrollBottom;
            Fill.Char.UnicodeChar = (WCHAR) 0;
            Fill.Attributes = FOREGROUND_RED |FOREGROUND_BLUE |FOREGROUND_GREEN;
            if ((ypos == ScrollBottom) 
                && (ScrollTop != ScrollBottom)) {
                sRect.Left   = 0;
                sRect.Top    = ScrollTop + 1;
                sRect.Right  = MAX_TERMINAL_WIDTH-1;
                sRect.Bottom = ScrollBottom;
                dwBufferCoord.Y = ScrollTop;
                dwBufferCoord.X = 0;
                RetVal =  ScrollConsoleScreenBuffer(hConsoleOutput,
                                                    &sRect,
                                                    NULL,
                                                    dwBufferCoord,
                                                    &Fill
                                                    );
                dwBufferCoord.Y = ScrollBottom;

            } else {
                if (ypos == MAX_TERMINAL_HEIGHT -1){
                    sRect.Left   = 0;
                    sRect.Top    = 1;
                    sRect.Right  = MAX_TERMINAL_WIDTH-1;
                    sRect.Bottom = MAX_TERMINAL_HEIGHT - 1;
                    dwBufferCoord.Y = 0;
                    dwBufferCoord.X = 0;
                    RetVal =  ScrollConsoleScreenBuffer(hConsoleOutput,
                                                        &sRect,
                                                        NULL,
                                                        dwBufferCoord,
                                                        &Fill
                                                        );
                    dwBufferCoord.Y = MAX_TERMINAL_HEIGHT -1;
                }
            }
            RetVal = FillConsoleOutputCharacter(hConsoleOutput,
                                                (TCHAR) 0,
                                                MAX_TERMINAL_WIDTH,
                                                dwBufferCoord,
                                                &charsWritten
                                                );
            return;

        } else {

            csbInfo.dwCursorPosition.Y = ypos + 1;

            SetConsoleCursorPosition(hConsoleOutput,
                                     csbInfo.dwCursorPosition
                                     );
        }
        return;
    }
    if (byte == '\r'){
        RetVal = GetConsoleScreenBufferInfo(hConsoleOutput,
                                            &csbInfo
                                            );
        if (RetVal == FALSE) {
            return;
        }
        csbInfo.dwCursorPosition.X = 0;

        SetConsoleCursorPosition(hConsoleOutput,
                                 csbInfo.dwCursorPosition
                                 );
        return;
    }

     
    Char = (TCHAR) byte;

    #ifdef UNICODE
    DBCSArray[DBCSIndex] = byte;
    if(DBCSIndex ==0){
        if(isleadbyte(byte)){
            DBCSIndex ++;
            return;
        }
    }
    else{
      mbtowc(&Char, DBCSArray, 2);
      DBCSIndex  = 0;
    }
    #endif
    _tprintf(_T("%c"),Char);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the Terminal Concentrator server.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Modifications - Sadagopan Rajaram 11th Nov 99

Environment:

    User Mode - Win32

Revision History:


--*/


//
// Adds a MEMORYBLOCK to the memory tracking list.
//

#include <tcsrv.h>

#if DBG==1

LPMEMORYBLOCK g_TraceMemoryTable;
CRITICAL_SECTION g_TraceMemoryCS;

HGLOBAL
TCReAlloc(
    HGLOBAL mem,
    DWORD size,
    LPCSTR comment
    )
{
    HGLOBAL temp;
    LPMEMORYBLOCK pmbHead;
    DWORD nBytes=0;


    temp = DebugAlloc(GMEM_ZEROINIT, size, comment);
    if(temp != NULL){
        EnterCriticalSection( &g_TraceMemoryCS );
        pmbHead = g_TraceMemoryTable;

        while ( pmbHead && pmbHead->hglobal != mem )
        {
            pmbHead = pmbHead->pNext;
        }
        if(pmbHead){   
            nBytes = pmbHead->dwBytes;
        }
        LeaveCriticalSection(&g_TraceMemoryCS);
        if(nBytes){
            memcpy(temp, mem, nBytes);
            DebugFree(mem);
        }
    }
    return temp;
}

HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    DWORD   dwBytes,
    LPCSTR pszComment 
    )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->pszComment = pszComment;

        EnterCriticalSection( &g_TraceMemoryCS );

        pmb->pNext         = g_TraceMemoryTable;
        g_TraceMemoryTable = pmb;

        TCDebugPrint(("DebugAlloc: 0x%08x alloced %d (%s) with 0x%08x\n", hglobal, dwBytes, 
                      pmb->pszComment, pmb ));

        LeaveCriticalSection( &g_TraceMemoryCS );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead;
        LPMEMORYBLOCK pmbLast = NULL;

        EnterCriticalSection( &g_TraceMemoryCS );
        pmbHead = g_TraceMemoryTable;

        while ( (pmbHead) && (pmbHead->hglobal != hglobal ))
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }
        if ( pmbHead )
        {
            HGLOBAL *p;
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                g_TraceMemoryTable = pmbHead->pNext;
            }

            TCDebugPrint(("DebugFree: 0x%08x freed %d (%s)\n",pmbHead->hglobal,pmbHead->dwBytes,
                pmbHead->pszComment ));

            p = (HGLOBAL)((LPBYTE)hglobal + pmbHead->dwBytes);
            if ( *p != hglobal )
            {
                TCDebugPrint(("DebugFree: Heap check FAILED for 0x%08x %u bytes (%s).\n",
                    hglobal, pmbHead->dwBytes, pmbHead->pszComment));
            }

            memset( hglobal, 0xFE, pmbHead->dwBytes + sizeof(HGLOBAL));
            memset( pmbHead, 0xFD, sizeof(MEMORYBLOCK) );
            pmbHead->pNext = NULL;
            GlobalFree( pmbHead );

        }
        else
        {
            HGLOBAL *p;

            TCDebugPrint(("DebugFree: 0x%08x not found in memory table\n", hglobal ));
            memset( hglobal, 0xFE, (int)GlobalSize( hglobal ));
        }

        LeaveCriticalSection( &g_TraceMemoryCS );

    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    UINT uFlags,
    DWORD   dwBytes,
    LPCSTR pszComment )
{
    HGLOBAL hglobal;

    HGLOBAL *p;
    hglobal = GlobalAlloc( uFlags, dwBytes + sizeof(HGLOBAL));
    if (hglobal == NULL) {
        TCDebugPrint(("No memory %s %d\n", pszComment, GetLastError()));
        return NULL;
    }
    p = (HGLOBAL)((LPBYTE)hglobal + dwBytes);
    *p = hglobal;

    return DebugMemoryAdd( hglobal,dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb;

    EnterCriticalSection( &g_TraceMemoryCS );

    pmb = g_TraceMemoryTable;
    while ( pmb )
    {
        LPMEMORYBLOCK pTemp;
        
        if ( fFoundLeak == FALSE )
        {
            TCDebugPrint(("\n***************************** Memory leak detected *****************************\n\n"));
            TCDebugPrint(("Memory leak at %x, %s", pmb->hglobal, pmb->pszComment));
            fFoundLeak = TRUE;
        }
        pTemp = pmb;
        pmb = pmb->pNext;
        memset( pTemp, 0xFD, sizeof(MEMORYBLOCK) );
        GlobalFree( pTemp );
    }

    if ( fFoundLeak == TRUE )
    {
        TCDebugPrint(("\n***************************** Memory leak detected *****************************\n\n"));
    }

    LeaveCriticalSection( &g_TraceMemoryCS );

    //BinlAssert( !fFoundLeak );
}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\handler.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        handler.c
 *
 * Service Handler functions
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 25, 1999
 *
 */
#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

VOID
ServiceControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Terminal Concentrator

Arguments:

    Opcode - Supplies a value which specifies the action for the
        service to perform.

Return Value:

    None.

--*/
{
    DWORD Error;

    switch (Opcode) {
    case SERVICE_CONTROL_STOP:                                                
    case SERVICE_CONTROL_SHUTDOWN:                                             
        EnterCriticalSection(&GlobalMutex);
        // We set the global state to a stop pending while the 
        // com ports destroy themselves. 
        // This is triggered by destroying the main socket.
        TCGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
        closesocket(MainSocket);
        LeaveCriticalSection(&GlobalMutex);
        break;
    case SERVICE_CONTROL_PARAMCHANGE:

        EnterCriticalSection(&GlobalMutex);
        // If we are not currently running, but have been sent too many 
        // control parameter change requests, we say return.
        if(TCGlobalServiceStatus.dwCurrentState != SERVICE_RUNNING){
            LeaveCriticalSection(&GlobalMutex);
            return;
        }
        TCGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
        LeaveCriticalSection(&GlobalMutex);
        // Does the actual work of munging through the registry and 
        // finding out changes.
        UpdateChanges();
        break;
    }

    return;
}


VOID UpdateChanges(
    )
/*++ 
    Reads the parameters from the registry and then tries to add or delete com 
    ports as necessary
--*/
{

    PCOM_PORT_INFO pTempInfo;
    PCOM_PORT_INFO pTemp;
    PCOM_PORT_INFO addedPorts;
    LPTSTR device;
    LPTSTR name;
    BOOLEAN addPort;
    HKEY hKey, hParameter;
    NTSTATUS Status;
    int index;
    LONG RetVal;
    HANDLE lock;
    
    addedPorts = NULL;
    hKey = NULL;

    EnterCriticalSection(&GlobalMutex);
    pTempInfo = ComPortInfo;
    while(pTempInfo != NULL){
        // Sets the flag of Deleted to TRUE 
        // for all COM ports. If they are found
        // unchanged in the registry, we can leave
        // them. Changing session names are ok. 
        pTempInfo->Deleted = TRUE;
        pTempInfo= pTempInfo->Next;
    }
    LeaveCriticalSection(&GlobalMutex);
    RetVal = TCLock(&lock);
    if(RetVal != ERROR_SUCCESS){
        TCDebugPrint(("Cannot Lock Registry %d\n", RetVal));
        goto end;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey
                          );
    if(RetVal != ERROR_SUCCESS){  
        TCUnlock(lock);
        TCDebugPrint(("Cannot open Registry Key %d\n", RetVal));
        goto end;
    }
    
    // Read the correct parameters from the registry until you get no more.

    index= 0;
    while(1) {
        RetVal = GetNextParameter(hKey,
                                  index,
                                  &hParameter,
                                  &name
                                  );
        if (RetVal == ERROR_NO_MORE_ITEMS) {
            TCUnlock(lock);
            TCDebugPrint(("Done with registry %d\n",index));
            break;
        }
        if(RetVal != ERROR_SUCCESS){
            TCUnlock(lock);
            TCDebugPrint(("Error reading registry %d\n",RetVal));
            goto end;
        }
        RetVal = GetNameOfDeviceFromRegistry(hParameter,
                                             &device
                                             );
        if(RetVal != ERROR_SUCCESS){
            TCFree(name);
            continue;
        }
        
        pTempInfo = GetComPortParameters(hParameter);
        RegCloseKey(hParameter);
        if(pTempInfo == NULL){   
            TCFree(name);
            TCFree(device);
            RegCloseKey(hKey);
            TCUnlock(lock);
            goto end;
        }
        pTempInfo->Device.Buffer = device;
        pTempInfo->Name.Buffer = name;
        pTempInfo->Name.Length = _tcslen(pTempInfo->Name.Buffer)*sizeof(TCHAR);
        pTempInfo->Device.Length = _tcslen(pTempInfo->Device.Buffer) * sizeof(TCHAR);

        EnterCriticalSection(&GlobalMutex);
        if(TCGlobalServiceStatus.dwCurrentState != SERVICE_PAUSED){
            // Somehow, the service has been shut down.
            RegCloseKey(hKey);
            FreeComPortInfo(pTempInfo);
            LeaveCriticalSection(&GlobalMutex);
            TCUnlock(lock);
            goto end;
        }
        pTemp = ComPortInfo;
        addPort = TRUE;
        while(pTemp){
            RetVal = ComPortInfoCompare(pTemp, pTempInfo);
            if(RetVal == SAME_ALL){
                pTemp->Deleted = FALSE;
                addPort = FALSE;
                break;
            }
            if (RetVal == SAME_DEVICE) {
                // User has changed configuration 
                // settings
                addPort  = TRUE;
                break;
            }
            if (RetVal == DIFFERENT_SESSION) {
                // Only session name has changed. So, we do not
                // need to delete the device. 
                pTemp->Deleted = FALSE;
                addPort = FALSE;
                TCFree(pTemp->Name.Buffer);
                pTemp->Name.Buffer = pTempInfo->Name.Buffer;
                pTempInfo->Name.Buffer = NULL;
                break;
            }
            // Different devices, so continue searching
            pTemp=pTemp->Next;
        }
        LeaveCriticalSection(&GlobalMutex);
        if (addPort == FALSE) {
            FreeComPortInfo(pTempInfo);
        }
        else{
            pTempInfo->Next = addedPorts;
            addedPorts= pTempInfo;
        }
        index++;
    }

    while(1){
        EnterCriticalSection(&GlobalMutex);
        if(TCGlobalServiceStatus.dwCurrentState != SERVICE_PAUSED){
            LeaveCriticalSection(&GlobalMutex);
            goto end;
        }
        pTempInfo = ComPortInfo;
        device = NULL;
        while(pTempInfo){
            if(pTempInfo->Deleted){
                // This is true if the configuration settings are 
                // changed or if the device has been really deleted. 
                device = pTempInfo->Device.Buffer;
                break;
            }
            pTempInfo = pTempInfo->Next;
        }
        LeaveCriticalSection(&GlobalMutex);
        if(device){
            Status = DeleteComPort(device);
        }
        else{
            break;
        }
    }

    while(addedPorts){
        pTempInfo = addedPorts;
        addedPorts = addedPorts->Next;
        Status = AddComPort(pTempInfo);
        if(Status != STATUS_SUCCESS){
            FreeComPortInfo(pTempInfo);
            TCDebugPrint(("Could not Initialize Com Port %x\n",Status));
        }
    }
end:
    while (addedPorts) {
        // We may have come here after an error condition.
        pTempInfo = addedPorts;
        addedPorts = pTempInfo->Next;
        pTempInfo->Next = NULL;
        FreeComPortInfo(pTempInfo);

    }
    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState != SERVICE_PAUSED){
        LeaveCriticalSection(&GlobalMutex);
        return ;
    }
    TCGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
    LeaveCriticalSection(&GlobalMutex);
    return;

}


int 
ComPortInfoCompare(
    PCOM_PORT_INFO com1,
    PCOM_PORT_INFO com2
    )
{
    int ret;

    if (_tcscmp(com1->Device.Buffer, com2->Device.Buffer)) {
        // Different Devices
        return DIFFERENT_DEVICES;
    }
    // Same device
    ret = SAME_DEVICE;
    if ((com1->Parity != com2->Parity) ||
        (com1->StopBits != com2->StopBits) ||
        (com1->WordLength != com2->WordLength)||
        (com1->BaudRate != com2->BaudRate)){
        return ret;
    }
    if (_tcscmp(com1->Name.Buffer, com2->Name.Buffer)) {
        // Different Devices
        return DIFFERENT_SESSION;
    }
    return SAME_ALL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\tcsrvt.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcsrvt.c
 *
 * This is the main file containing the service setup routines
 * 
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */
 

#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

int __cdecl
main (
    INT argc,
    CHAR **argv
    )
{
    int i;

    SERVICE_TABLE_ENTRY   DispatchTable[] = { 
        { _T("TCSERV"), ServiceEntry      }, 
        { NULL,              NULL          } 
    }; 
 
    if (!StartServiceCtrlDispatcher( DispatchTable)) 
    { 
        OutputDebugStringA(" [TCSERV] StartServiceCtrlDispatcher error"); 
    } 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\tcsrv.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        tcsrv.h
 *
 * Contains the structure definitions and global variables used by the service
 *
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <winsock2.h>
#include <align.h>
#include <smbgtpt.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <dsrole.h>
#include <rpc.h>
#include <ntdsapi.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmsname.h>
#include <rpc.h>
#include <security.h>   // General definition of a Security Support Provider
#include <ntlmsp.h>
#include <spseal.h>
#include <userenv.h>
#include <setupapi.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//
// netlib header.
//

#include <lmcons.h>
#include <secobj.h>

//
// tcp services control hander file
//
#include <tchar.h>
#include "debug.h"

#define MAX_TERMINAL_WIDTH 80
#define MAX_BUFFER_SIZE 256
#define MAX_REGISTRY_NAME_SIZE 256
#define MAX_QUEUE_SIZE 1024
#define SAME_ALL 0
#define SAME_DEVICE 1
#define DIFFERENT_DEVICES 2
#define DIFFERENT_SESSION 4
#define DEFAULT_BAUD_RATE 9600

struct _COM_PORT_INFO;
#ifdef UNICODE
#define TSTRING UNICODE_STRING
#else
#define TSTRING ANSI_STRING
#endif
typedef struct _CONNECTION_INFO{
     SOCKET Socket;
     WSABUF Buffer;
     CHAR buffer[MAX_BUFFER_SIZE];
     DWORD BytesRecvd;
     DWORD Flags;
     IO_STATUS_BLOCK IoStatus;
     WSAOVERLAPPED Overlapped;
     struct _COM_PORT_INFO *pComPortInfo;
     struct _CONNECTION_INFO *Next;
} CONNECTION_INFO, *PCONNECTION_INFO;
 
typedef struct _COM_PORT_INFO{
    CRITICAL_SECTION Mutex;
    HANDLE Events[4];
    HANDLE ComPortHandle;
    HANDLE TerminateEvent;
    BOOLEAN ShuttingDown;
    BOOLEAN Deleted;
    TSTRING Device;
    TSTRING Name;
    ULONG BaudRate;
    UCHAR Parity;
    UCHAR StopBits;
    UCHAR WordLength;
    int Head;
    int Tail;
    int Number;
    CHAR Queue[MAX_QUEUE_SIZE];
    DWORD BytesRead;
    OVERLAPPED Overlapped;
    OVERLAPPED WriteOverlapped;
    IO_STATUS_BLOCK IoStatus;
    CHAR Buffer[MAX_BUFFER_SIZE];
    PCONNECTION_INFO Sockets;
    PCONNECTION_INFO Connections;
    struct _COM_PORT_INFO *Next;
}COM_PORT_INFO, *PCOM_PORT_INFO;

extern PCOM_PORT_INFO ComPortInfo;

extern int ComPorts;

extern PHANDLE Threads;

extern SOCKET MainSocket;

extern WSAEVENT TerminateService;

extern CRITICAL_SECTION GlobalMutex;

extern SERVICE_STATUS_HANDLE TCGlobalServiceStatusHandle;

extern SERVICE_STATUS TCGlobalServiceStatus;

#define MutexLock(x) EnterCriticalSection(&(x->Mutex))
#define MutexRelease(x) LeaveCriticalSection(&(x->Mutex))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\proto.h ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *       proto.h
 *
 * Contains the prototypes of all the functions used by the service.
 *
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */

 
VOID 
ServiceEntry(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    );

DWORD
ProcessRequests(
    SOCKET socket
    );

DWORD
InitializeComPortConnection(
    SOCKET cli_sock
    );

NTSTATUS Initialize(
    );

NTSTATUS 
InitializeComPort(
    PCOM_PORT_INFO pComPortInfo
    );

SOCKET
ServerSocket(
    );

VOID 
Shutdown(
    NTSTATUS Status
    );

DWORD 
bridge(
    PCOM_PORT_INFO pComPortInfo
    );

VOID 
CALLBACK
updateComPort(
    IN DWORD dwError, 
    IN DWORD cbTransferred, 
    IN LPWSAOVERLAPPED lpOverlapped, 
    IN DWORD dwFlags
    );

VOID
updateClients(
    PCOM_PORT_INFO pComPortInfo
    );


VOID CleanupSocket(
    PCONNECTION_INFO pConn
    );


PCOM_PORT_INFO 
FindDevice(
    LPTSTR device,
    int   *pIndex
    );

NTSTATUS
AddComPort(
    PCOM_PORT_INFO pComPortInfo
    );

NTSTATUS
DeleteComPort(
    LPTSTR device
    );

LONG
GetNextParameter(
    HKEY hKey,
    DWORD dwIndex,
    PHKEY pChild,
    LPTSTR *Name
    );

LONG
GetNameOfDeviceFromRegistry(
    HKEY hKey,
    LPTSTR *device
    );

PCOM_PORT_INFO
GetComPortParameters(
    HKEY hKey
    );

VOID
FreeComPortInfo(
    PCOM_PORT_INFO pTemp
    );

VOID UpdateChanges(
    );

VOID
ServiceControlHandler(
    IN DWORD Opcode
    );

NTSTATUS
InitializeThread(
    PCOM_PORT_INFO pComPortInfo
    );

int GetBufferInfo(
    PCONNECTION_INFO pConnection,
    PCOM_PORT_INFO pComPortInfo
    );

VOID Enqueue(
    PCOM_PORT_INFO pComPortInfo
    );

int 
ComPortInfoCompare(
    PCOM_PORT_INFO com1,
    PCOM_PORT_INFO com2
    );

LONG 
TCLock(
    PHANDLE lock
    );

VOID
TCUnlock(
    HANDLE lock
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\main.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        main.c
 *
 * This is the main file containing the service entry and shutdown routines. 
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */
 
 
#include "tcsrv.h"
#include "tcsrvc.h"
#include "proto.h"

SERVICE_STATUS_HANDLE TCGlobalServiceStatusHandle;
SERVICE_STATUS TCGlobalServiceStatus;

VOID 
ServiceEntry(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )
/*++

Routine Description
    This is the main routine for the terminal concentrator service. After 
    initialization, the service processes requests on the main socket until 
    a terminate service has been signalled.

Arguments:
    NumArgs     - Number of strings in the ArgsArray
    ArgsArray   - String arguments
    pGlobalData - Contains the necessary global information needed to start 
                  the service

Return Value:
    None   

++*/
{
    // Initialize Status fields

    NTSTATUS status;
 
    TCGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    TCGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    TCGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN
        |SERVICE_ACCEPT_STOP
        |SERVICE_ACCEPT_PARAMCHANGE  ;
    TCGlobalServiceStatus.dwCheckPoint = 1;
    TCGlobalServiceStatus.dwWaitHint = 60000; // 60 secs.
    TCGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    TCGlobalServiceStatus.dwServiceSpecificExitCode = 0;

  
    TCGlobalServiceStatusHandle= RegisterServiceCtrlHandler(TCSERV_NAME, 
                                                            ServiceControlHandler  
                                                            );
    if(TCGlobalServiceStatusHandle == INVALID_HANDLE_VALUE){
        return;
    }
    if(!SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus)){
        return;
    }

    // Open a well known socket for the client to connect.

    INITIALIZE_TRACE_MEMORY
    MainSocket = ServerSocket();
    if(MainSocket == INVALID_SOCKET){
        // gone case . Terminate Service
        TCDebugPrint(("Cannot open Socket\n"));
        return;
    }
    
    
    // Initialize by getting control of the COM ports and starting threads 
    // for each of them.
    status = Initialize();

    if(status != STATUS_SUCCESS){
        TCDebugPrint(("Cannot Initialize\n"));
        Shutdown(status);
        return;
    }

    // Blindly loops around waiting for a request from the control socket and 
    // processes their requests.

    status = ProcessRequests(MainSocket);

    if (status != STATUS_SUCCESS){
        TCDebugPrint(("Ended with Error"));
    }

    Shutdown(status);

    return;

}


DWORD
ProcessRequests(
    SOCKET socket
    )
/*++ 
    Here we sit around waiting for connections. 
    Once we get a connection, we start a thread to get the required parameters
    and send the information to the thread processing that COM port.
--*/ 
{

    int status;
    SOCKET cli_sock;
    CLIENT_INFO ClientInfo;
    struct sockaddr_in cli_addr;
    int addr_len;
    ULONG argp;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    PHANDLE NewThreads;
    ULONG ThreadID;

    status = listen(socket, SOMAXCONN);

    if (status == SOCKET_ERROR) {
        TCDebugPrint(("Cannot listen to socket %x\n",WSAGetLastError()));
        closesocket(socket);
        return (WSAGetLastError());
    }
    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState != SERVICE_START_PENDING){
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_SUCCESS;
    }
    TCGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);
    LeaveCriticalSection(&GlobalMutex);

    while(1){
        cli_sock = accept(socket,NULL,NULL);
        if (cli_sock == INVALID_SOCKET){
            // got to shutdown - no Error here
            TCDebugPrint(("Main Socket No more %d\n",GetLastError()));
            return(STATUS_SUCCESS);
        }
        // receive the com port that the client wants to connect to.

        ThreadHandle=CreateThread(NULL,
                                  THREAD_ALL_ACCESS,
                                  (LPTHREAD_START_ROUTINE) InitializeComPortConnection,
                                  (LPVOID) cli_sock,
                                  0,
                                  &ThreadID
                                  );
        if(ThreadHandle == NULL){
            closesocket(cli_sock);
            TCDebugPrint(("Create connection Thread Failure %lx\n",GetLastError()));
        }
        else{
            NtClose(ThreadHandle);
        }
    }
    return(0);
}

DWORD
InitializeComPortConnection(
    SOCKET cli_sock
    )
{
    PCOM_PORT_INFO pTempInfo;
    PCONNECTION_INFO pConn;
    int i;
    BOOL ret;
    ULONG par;
    DWORD status;
    CLIENT_INFO ClientInfo;
    
    status = recv(cli_sock,
                  (PCHAR) &ClientInfo,
                  sizeof(CLIENT_INFO),
                  0
                  );
    if((status == SOCKET_ERROR) ||( status == 0)){
        //something wrong
        TCDebugPrint(("Receive Problem %x\n",WSAGetLastError()));
        closesocket(cli_sock);
        return 0;
    }
    ClientInfo.device[MAX_BUFFER_SIZE -1] = 0;
    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState == SERVICE_STOP_PENDING){
        // Entire Service is shutting down.
        closesocket(cli_sock);
        LeaveCriticalSection(&GlobalMutex);
        return 1;
    }
    pTempInfo = FindDevice(ClientInfo.device, &i);
    if(!pTempInfo){
        closesocket(cli_sock);
        TCDebugPrint(("No Such Device\n"));
        LeaveCriticalSection(&GlobalMutex);
        return -1;
    }

    MutexLock(pTempInfo);
    if(pTempInfo->ShuttingDown){
        // The Com Port alone is shutting down, so 
        // make sure the socket goes away.
        closesocket(cli_sock);
        MutexRelease(pTempInfo);
        LeaveCriticalSection(&GlobalMutex);
        return -1;
    }
    pConn = TCAllocate(sizeof(CONNECTION_INFO),"New Connection");
    if(pConn == NULL){
        closesocket(cli_sock);
        MutexRelease(pTempInfo);
        LeaveCriticalSection(&GlobalMutex);
        return -1;
    }
    pConn->Socket = cli_sock;
    // Make the socket non-blocking so that receive
    // does not wait. 
    i = ioctlsocket(cli_sock,
                    FIONBIO,
                    &par
                    );
    if(i == SOCKET_ERROR){
        TCDebugPrint(("Error in setting socket parameters %d\n",GetLastError()));
    }
    pConn->pComPortInfo = pTempInfo;
    pConn->Next = pTempInfo->Sockets;
    pTempInfo->Sockets=pConn;
    pConn->Flags = ClientInfo.len;
    (pConn->Buffer).buf = pConn->buffer;
    (pConn->Buffer).len = MAX_BUFFER_SIZE;
    (pConn->Overlapped).hEvent = (WSAEVENT) pConn;
    ret = SetEvent(pTempInfo->Events[1]);
    if(ret == FALSE){
        TCDebugPrint(("Cannot signal object %d\n",GetLastError()));
    }
    MutexRelease(pTempInfo);
    LeaveCriticalSection(&GlobalMutex);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\init.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        init.c
 *
 * Initilization functions
 * Where possible, code has been obtained from BINL server.
 * 
 * Sadagopan Rajaram -- Oct 14, 1999
 *
 */
#include "tcsrv.h"
#include <ntddser.h>
#include "tcsrvc.h"
#include "proto.h"

PHANDLE Threads;
PCOM_PORT_INFO ComPortInfo;
int ComPorts;
SOCKET MainSocket;
HANDLE TerminateService;
CRITICAL_SECTION GlobalMutex;

NTSTATUS Initialize(
    )
/*++ 
    This function performs the initialization routine by opening the COM ports, 
    allocating circular buffers for each of the COM ports. All these values are 
    in the registry. 
    
    Threads are started for reading from each of the COM ports. These buffers 
    are protected by mutual exclusion variables.
    
    Caveat for me - Remember all the allocation done here. you need to free them 
    when you leave the system.
    
    Return Value : 
        Success if successful in doing everything, else an error code.
    
--*/  
    
{
    int number=1; 
    int i;
    HKEY hKey, hParameter;
    PCOM_PORT_INFO pTempInfo;
    NTSTATUS Status;
    LPTSTR name,device;
    int index;
    LONG RetVal;
    HANDLE lock;


    // Global variable carrying information about the COM ports.
    ComPortInfo = NULL;
    ComPorts = 0;

    RetVal = TCLock(&lock);
    if(RetVal != ERROR_SUCCESS){
        TCDebugPrint(("Cannot Lock Registry %d\n", RetVal));
        return RetVal;
    }
    RetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          HKEY_TCSERV_PARAMETER_KEY,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey
                          );
    if(RetVal != ERROR_SUCCESS){
        TCDebugPrint(("Cannot open Registry Key %d\n", RetVal));
        return RetVal;
    }

    // Read the correct parameters from the registry until you get no more.

    index= 0;
    while(1) {
        RetVal = GetNextParameter(hKey,
                                  index,
                                  &hParameter,
                                  &name
                                  );
        if (RetVal == ERROR_NO_MORE_ITEMS) {
            TCUnlock(lock);
            TCDebugPrint(("Done with registry\n"));
            break;
        }
        if(RetVal != ERROR_SUCCESS){
            TCUnlock(lock);
            TCDebugPrint(("Problem with registry, %d\n", RetVal));
            return RetVal;
        }
        RetVal = GetNameOfDeviceFromRegistry(hParameter,
                                             &device
                                             );
        if(RetVal != ERROR_SUCCESS){
            TCFree(name);
            continue;
        }
        
        pTempInfo = GetComPortParameters(hParameter);
        RegCloseKey(hParameter);

        if(pTempInfo == NULL){
            TCFree(name);
            TCFree(device);
            RegCloseKey(hKey);
            TCUnlock(lock);
            return RetVal;
        }

        pTempInfo->Device.Buffer = device;
        pTempInfo->Name.Buffer = name;
        pTempInfo->Name.Length = (_tcslen(pTempInfo->Name.Buffer))*sizeof(TCHAR);
        pTempInfo->Device.Length = (_tcslen(pTempInfo->Device.Buffer)) * sizeof(TCHAR);
        Status = AddComPort(pTempInfo);
    
        // Open the Com port and start the worker thread.

        if(Status != STATUS_SUCCESS){
            FreeComPortInfo(pTempInfo);
            TCDebugPrint(("Could not initialize com port\n"));
        }
        index++;
    }
    return (STATUS_SUCCESS);
}

NTSTATUS
AddComPort(
    PCOM_PORT_INFO pComPortInfo
    )
/*++
    Adds a Com port to the global list and reallocates the threads and 
    allows dynamic changes to the com ports being serviced.
--*/
{
    // Lock down the global data so that it is consistent.
    NTSTATUS Status;

    pComPortInfo->Events[0] = TerminateService;
    pComPortInfo->Events[1] = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (pComPortInfo->Events[1]==NULL) {
        TCDebugPrint(("Event creation failed\n"));
        return(STATUS_NO_MEMORY);

    }
    pComPortInfo->Events[2] = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (pComPortInfo->Events[2]==NULL) {
        TCDebugPrint(("Event creation failed\n"));
        return(STATUS_NO_MEMORY);

    }
    pComPortInfo->Overlapped.hEvent = pComPortInfo->Events[2];
    pComPortInfo->WriteOverlapped.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (pComPortInfo->WriteOverlapped.hEvent==NULL) {
        TCDebugPrint(("Write Event creation failed\n"));
        return(STATUS_NO_MEMORY);

    }
    InitializeCriticalSection(&(pComPortInfo->Mutex));
    pComPortInfo->TerminateEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(pComPortInfo->TerminateEvent== NULL){
        TCDebugPrint(("Terminate Event Creation Failed\n"));
        return(STATUS_NO_MEMORY);
    }
    pComPortInfo->Events[3] = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(pComPortInfo->Events[3]== NULL){
        TCDebugPrint(("Terminate Event Creation Failed\n"));
        return(STATUS_NO_MEMORY);
    }
    pComPortInfo->ShuttingDown = FALSE;
    pComPortInfo->Deleted = FALSE;
    pComPortInfo->Sockets = NULL;
    pComPortInfo->Connections = NULL;
    pComPortInfo->Head=pComPortInfo->Tail =0;
    pComPortInfo->Number = 0;
    Status = InitializeComPort(pComPortInfo);
    if (Status == STATUS_SUCCESS) {
        return InitializeThread(pComPortInfo);
    }
    return Status;
}

NTSTATUS 
InitializeComPort(
    PCOM_PORT_INFO pComPortInfo
    )
/*++ 
    Start a thread to do stuff. But before that, it must initialize the Com Port
    and fill out the rest of the data structure.
--*/

{
    HANDLE temp;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    SERIAL_BAUD_RATE BaudRate;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_TIMEOUTS NewTimeouts;
    ULONG ModemStatus;
    int i;
    
    #ifdef UNICODE

    InitializeObjectAttributes(&Obja,
                               &(pComPortInfo->Device), 
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    #else
    UNICODE_STRING str;
    int len;
    // Here is where uniformity breaks down :-)
    len = (_tcslen(pComPortInfo->Device.Buffer)+1)*sizeof(WCHAR);
    str.Buffer = (PWCHAR) TCAllocate(len,"Unicode");
    str.MaximumLength = len*sizeof(WCHAR);
    str.Length = 0;
    if(str.Buffer == NULL){
        return STATUS_NO_MEMORY;
    }
    len = mbstowcs(str.Buffer,
                   pComPortInfo->Device.Buffer,
                   _tcslen(pComPortInfo->Device.Buffer)+1
                   );
    str.Buffer[len] = (TCHAR) 0;
    str.Length = wcslen(str.Buffer) * sizeof(WCHAR);
    InitializeObjectAttributes(&Obja,
                               &str, 
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    #endif

    Status = NtCreateFile(&(pComPortInfo->ComPortHandle),
                          GENERIC_READ | GENERIC_WRITE |SYNCHRONIZE,
                          &Obja,
                          &(pComPortInfo->IoStatus),
                          0,
                          0,
                          FILE_SHARE_READ|FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE,
                          0,
                          0
                          );
    #ifdef UNICODE
    #else
    TCFree(str.Buffer);
    #endif

    if (!NT_SUCCESS(Status)) {
        TCDebugPrint(("Opening Com Device Failure %x\n",Status));
        return Status;
    }

    // Set Com Port Parameters
    // Set the baud rate
    //
    BaudRate.BaudRate = pComPortInfo->BaudRate;
    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_SET_BAUD_RATE,
                                   &BaudRate,
                                   sizeof(SERIAL_BAUD_RATE),
                                   NULL,
                                   0
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't set Baud rate %ld\n", Status));
        return Status;
    }
    
    //
    // Set 8-N-1 data
    //
    LineControl.WordLength = pComPortInfo->WordLength;
    LineControl.Parity = pComPortInfo->Parity;
    LineControl.StopBits = pComPortInfo->StopBits;
    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_SET_LINE_CONTROL,
                                   &LineControl,
                                   sizeof(SERIAL_LINE_CONTROL),
                                   NULL,
                                   0
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't set line control %lx\n",Status));
        return Status;
    }
    
    //
    // Check if we have a carrier
    //

    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_GET_MODEMSTATUS,
                                   NULL,
                                   0,
                                   &ModemStatus,
                                   sizeof(ULONG)
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't call the detect routine %lx\n",Status));
        return Status;
    }
    // BUGBUG - We do not bother about the presence of a carrier as the 
    // machine to which this bridge is connected may be down. 

    /*if ((ModemStatus & 0xB0) != 0xB0) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't detect carrier %lx\n",ModemStatus));
        return STATUS_SERIAL_NO_DEVICE_INITED;
    }*/
    
    //
    // Set timeout values for reading
    // We should have a time out that reads from the read buffer 
    // as many characters as there are asked for or waits for the 
    // first available character
    //
    NewTimeouts.ReadIntervalTimeout = MAXULONG;
    NewTimeouts.ReadTotalTimeoutMultiplier = MAXULONG;
    NewTimeouts.ReadTotalTimeoutConstant = MAXULONG-1;
    NewTimeouts.WriteTotalTimeoutMultiplier = MAXULONG;
    NewTimeouts.WriteTotalTimeoutConstant = MAXULONG;
    Status = NtDeviceIoControlFile(pComPortInfo->ComPortHandle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &(pComPortInfo->IoStatus),
                                   IOCTL_SERIAL_SET_TIMEOUTS,
                                   &NewTimeouts,
                                   sizeof(SERIAL_TIMEOUTS),
                                   NULL,
                                   0
                                  );

    if (!NT_SUCCESS(Status)) {
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Can't set time out values %lx\n",Status));
        return Status;
    }
    return STATUS_SUCCESS;

}

NTSTATUS
InitializeThread(
    PCOM_PORT_INFO pComPortInfo
    )
{
    NTSTATUS Status;
    HANDLE ThreadHandle;
    PHANDLE NewThreads;
    ULONG ThreadID;

    ThreadHandle=CreateThread(NULL,
                              THREAD_ALL_ACCESS,
                              bridge,
                              pComPortInfo,
                              0,
                              &ThreadID
                              );
    if(ThreadHandle == NULL){
        NtClose(pComPortInfo->ComPortHandle);
        TCDebugPrint(("Create Com Thread Failure %lx\n",GetLastError()));
        return GetLastError();
    } 
    EnterCriticalSection(&GlobalMutex);
    if(ComPorts == 0){
        NewThreads = (PHANDLE) TCAllocate(sizeof(HANDLE), "Thread");
    }
    else{
        NewThreads = (PHANDLE) TCReAlloc(Threads,
                                         (ComPorts+1)*sizeof(HANDLE),"Reallocation");
    }
    if(NewThreads == NULL){
        SetEvent(pComPortInfo->Events[3]);
        NtClose(pComPortInfo->ComPortHandle);
        NtClose(ThreadHandle);
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_NO_MEMORY;
    }
    Threads = NewThreads;
    Threads[ComPorts] = ThreadHandle;
    pComPortInfo->Next = ComPortInfo;
    ComPortInfo = pComPortInfo;
    ComPorts++;
    LeaveCriticalSection(&GlobalMutex);
    return STATUS_SUCCESS;
}


SOCKET
ServerSocket(
    )
/*++
    Standard server binding code
--*/ 
{
    struct sockaddr_in srv_addr;
    int status; 
    WSADATA data;


    // Set the socket version to 2.2
    status=WSAStartup(514,&data);
    if(status){
        TCDebugPrint(("Cannot start up %d\n",status));
        return(INVALID_SOCKET);
    }
    TerminateService = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(TerminateService == NULL){
        TCDebugPrint(("Cannot open Terminate Event %lx\n",GetLastError()));
        return INVALID_SOCKET;
    }
    MainSocket=WSASocket(AF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED);
    if (MainSocket==INVALID_SOCKET){
        TCDebugPrint(("Could not open server socket %lx\n", WSAGetLastError()));
        return(MainSocket);
    }
    srv_addr.sin_family=AF_INET;
    srv_addr.sin_addr.s_addr=INADDR_ANY;
    // convert to network byte order. 
    // yechh!! bind does not automatically do it and
    // I got hurts in testing. (was so used to 
    // Unix big endian ordering == network byte ordering.
    srv_addr.sin_port=htons(SERVICE_PORT);        /* specific port for server to listen on */

    /* Bind socket to the appropriate port and interface (INADDR_ANY) */

    if (bind(MainSocket,(LPSOCKADDR)&srv_addr,sizeof(srv_addr))==SOCKET_ERROR){
        TCDebugPrint(("Windows Sockets error %d: Couldn't bind socket.",
                WSAGetLastError()));
        return(INVALID_SOCKET);
    }

    // Initialize the Global Mutex variable
    InitializeCriticalSection(&GlobalMutex);

    return(MainSocket);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\test\cpuhog\cpuhog.c ===
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>


#define TOTAL_COUNT (100000000)


//
// DON'T UNCOMMENT THIS LINE UNTIL YOU'RE READY
// TO RUN THE WHOLE TEST.  YOU WON'T BE ABLE TO
// BREAK IN UNTIL THE TEST ENDS!!!
//
#define GO_FOREVER (1)

#define MAX_MEMORY  (256)


DWORD
MyWorkerThread(
    PVOID   ThreadParameter
    )
/*++

    Pretend to be busy.

--*/
{
ULONG   i;
PVOID   TmpPtr = NULL;
ULONG   MemorySize;


#ifdef GO_FOREVER
    while( 1 ) {
#else
    for( i = 0; i < TOTAL_COUNT; i++ ) {
#endif

        MemorySize = rand() % MAX_MEMORY;
    }
    
    return 0;
}


int
__cdecl
main( int   argc, char *argv[])
{
ULONG   i;
DWORD   ThreadId;
SYSTEM_INFO SystemInfo;
HANDLE  MyHandle;
HANDLE  *HandlePtr = NULL;


    printf( "This program is for testing purposes only.\n" );
    printf( "It is designed to consume all available CPU cycles.\n" );
    printf( "\n" );
    printf( "IT WILL RENDER YOUR SYSTEM UNRESPONSIVE!\n" );
    printf( "\n" );
    printf( "Press the '+' key to continue, or any other key to exit.\n" );
    if( _getch() != '+' ) {
        printf( "Exiting...\n" );
        return;
    }
    

    printf( "working..." );


    //
    // Figure out how many CPUs we have.  We'll want to create a thread
    // for each one so that there is no available resources.
    //
    GetSystemInfo( &SystemInfo );

    //
    // Allocate an array of handles for each one of the processors.
    //
    HandlePtr = (HANDLE *)malloc( sizeof(HANDLE) * SystemInfo.dwNumberOfProcessors );
    if( HandlePtr == NULL ) {
        printf( "We failed to allocate any memory.\n" );
        return;
    }


    //
    // Let this guy get lots of CPU time.
    //
    if (!SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS)) {
        printf("Failed to raise to realtime priority\n");
    }



    //
    // Now go create a bunch of threads so that we tie up all available time
    // on all CPUs.
    //
    for( i = 0; i < SystemInfo.dwNumberOfProcessors; i++ ) {
        HandlePtr[i] = CreateThread( NULL,
                                     0,
                                     MyWorkerThread,
                                     UIntToPtr( i ),
                                     CREATE_SUSPENDED,
                                     &ThreadId );

        if( HandlePtr[i] != NULL ) {
             SetThreadPriority( HandlePtr[i],
                                THREAD_PRIORITY_TIME_CRITICAL );
            ResumeThread( HandlePtr[i] );
        }
    }


    //
    // Now wait for them to finish.
    //
    WaitForMultipleObjects( SystemInfo.dwNumberOfProcessors,
                            HandlePtr,
                            TRUE,
                            INFINITE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\utils.c ===
/* 
 * Copyright (c) Microsoft Corporation
 * 
 * Module Name : 
 *        utils.c
 *
 * Some utility functions used by the service. 
 * 
 * Sadagopan Rajaram -- Oct 18, 1999
 *
 */
 
 
#include "tcsrv.h"
#include <ntddser.h>
#include "tcsrvc.h"
#include "proto.h"

PCOM_PORT_INFO 
FindDevice(
    LPTSTR device,
    int *pIndex
    )
/*++
    Searches through the global list and returns the COM port with the 
    correct name
    Remember that the shared global variables are not locked during this 
    function call
--*/
{

    PCOM_PORT_INFO pTemp;

    int i=ComPorts-1;

    pTemp = ComPortInfo;
    while(pTemp){
        if(!((_tcscmp(pTemp->Device.Buffer,device)) && 
             (_tcscmp(pTemp->Name.Buffer, device))))
            break;
        pTemp = pTemp->Next;
        i--;
    }
    *pIndex = i;
    return pTemp;
}


LONG
GetNextParameter(
    HKEY hKey,
    DWORD dwIndex,
    PHKEY pChild,
    LPTSTR *Name
    )
/*++
    Gets the name of the Com Port. It is a user defined name and has nothing 
    to do with the device name in NT.   
    Return -
         A filled in Com port info, else NULL if end of Parameters is reached.
--*/ 
{

    LONG RetVal;
    // Registry names cannot be longer than 256 characters.
    TCHAR lpName[MAX_REGISTRY_NAME_SIZE];
    DWORD lpcName;
    FILETIME lpftLastWriteTime;

    lpcName = MAX_REGISTRY_NAME_SIZE;

    RetVal = RegEnumKeyEx(hKey,     
                          dwIndex,  
                          lpName,   
                          &lpcName, 
                          NULL,     
                          NULL,     
                          NULL,     
                          &lpftLastWriteTime
                          );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(hKey);
        return RetVal;
    }

    *Name = (LPTSTR) TCAllocate(sizeof(TCHAR)*(lpcName+1),"Registry key");
    if((*Name) == NULL){
        RegCloseKey(hKey);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    _tcscpy((*Name),lpName);
    RetVal= RegOpenKeyEx(hKey,
                         lpName,  // subkey name
                         0,   // reserved
                         KEY_ALL_ACCESS, // security access mask
                         pChild
                         );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(hKey);
    }
    return RetVal;
}

LONG
GetNameOfDeviceFromRegistry(
    HKEY hKey,
    LPTSTR *device
    )
/*++
    Gets the NT device Name. If there is no device name, it is an error.
    
    Return-
           Device Name like L"\\device\\serial0"   
--*/
{
    LONG RetVal;
    DWORD lpType=0;
    LPTSTR lpData = NULL;
    DWORD lpcbData=0;

    RetVal = RegQueryValueEx(hKey,
                             _T("Device"),
                             NULL,  
                             &lpType,
                             (LPBYTE)lpData,
                             &lpcbData
                             );
    if((RetVal != ERROR_SUCCESS)
        &&(RetVal != ERROR_MORE_DATA)){
        RegCloseKey(hKey);
        return RetVal;
    }
    lpData = (LPTSTR) TCAllocate(lpcbData, "Device Name");
    if(lpData == NULL){
        RegCloseKey(hKey);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RetVal = RegQueryValueEx(hKey,
                             _T("Device"),
                             NULL,  
                             &lpType,
                             (LPBYTE)lpData,
                             &lpcbData
                             );
    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(hKey);
        TCFree(lpData);
        return RetVal;
    }
    *device = lpData;
    return ERROR_SUCCESS;

}

PCOM_PORT_INFO
GetComPortParameters(
    HKEY hKey
    )
{
    PCOM_PORT_INFO pComPortInfo;
    DWORD dwordsize;
    ULONG RetVal;
    DWORD data;
    
    dwordsize = sizeof(DWORD);

    pComPortInfo = (PCOM_PORT_INFO)TCAllocate(sizeof(COM_PORT_INFO),"Com Port Data");
    if(pComPortInfo== NULL){
        RegCloseKey(hKey);
        return NULL;
    }
    data = DEFAULT_BAUD_RATE;
    RetVal = RegQueryValueEx(hKey,
                             _T("Baud Rate"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->BaudRate = (ULONG) data;
    data = STOP_BIT_1;
    RetVal = RegQueryValueEx(hKey,
                             _T("Stop Bits"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->StopBits = (UCHAR) data;

    data = NO_PARITY;
    RetVal = RegQueryValueEx(hKey,
                             _T("Stop Bits"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->Parity = (UCHAR) data;

    data = SERIAL_DATABITS_8;
    RetVal = RegQueryValueEx(hKey,
                             _T("Word Length"),
                             NULL,
                             NULL,
                             (LPBYTE) &data,
                             &(dwordsize)
                             );
    pComPortInfo->WordLength = (UCHAR) data;

    return pComPortInfo;
}


VOID
FreeComPortInfo(
    PCOM_PORT_INFO pTemp
    )
{

   if(pTemp == NULL) return;
   if (pTemp->Device.Buffer) {
       TCFree(pTemp->Device.Buffer);
   }
   if(pTemp->Name.Buffer){
       TCFree(pTemp->Name.Buffer);
   }
   NtClose(pTemp->Events[1]);
   NtClose(pTemp->Events[2]);
   NtClose(pTemp->Events[3]);
   NtClose(pTemp->TerminateEvent);
   NtClose(pTemp->WriteOverlapped.hEvent);
   DeleteCriticalSection(&(pTemp->Mutex));
   TCFree(pTemp);
   return;
}

VOID Enqueue(
    PCOM_PORT_INFO pComPortInfo
    )
{
    int i,size,j,k;
    
    size = (int) pComPortInfo->Overlapped.InternalHigh;
    j = pComPortInfo->Tail;
    k = pComPortInfo->Head;
    for(i=0;i<size;i++){
        (pComPortInfo->Queue)[j] = (pComPortInfo->Buffer)[i];
        j = (j+1)% MAX_QUEUE_SIZE;
        if(k==j){
            k = (k+1)%MAX_QUEUE_SIZE;
        }
    }
    pComPortInfo->Head = k;
    pComPortInfo->Tail =j;

    return;
}

int GetBufferInfo(
    PCONNECTION_INFO pConnection,
    PCOM_PORT_INFO pComPortInfo
    )
{
    int i,size;
    int Status;
    
    size = 0;

    for(i=pComPortInfo->Head; (i != pComPortInfo->Tail ); i=(i+1)%(MAX_QUEUE_SIZE)){
        (pConnection->buffer)[size] = (pComPortInfo->Queue)[i];
        size++;
        if(size == MAX_BUFFER_SIZE){
            Status=send(pConnection->Socket, pConnection->buffer, size, 0);
            if(Status == SOCKET_ERROR){
                return Status;   
            }
            size = 0;
        }
    }
    if(size){
        Status = send(pConnection->Socket, pConnection->buffer, size, 0);
        if(Status == SOCKET_ERROR){
            return Status;
        }
    }

    return 0;
}

LONG 
TCLock(
    PHANDLE lock
    )
{
    LONG RetVal; 

    (*lock) = CreateMutex(NULL,
                          FALSE,
                          TCSERV_MUTEX_NAME
                          );
    if ((*lock)) {
       RetVal = WaitForSingleObject(*lock,INFINITE);
       if (RetVal == WAIT_FAILED) {
           return GetLastError();
       }
       else{
           return ERROR_SUCCESS;
       }
    }
    else{
        return GetLastError();
    }
}

VOID
TCUnlock(
    HANDLE lock
    )
{
    if (lock) {
        ReleaseMutex(lock);
        CloseHandle(lock);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\tcsrv\server\unlo.c ===
/* 
 * Copyright (c) Microsoft Corporation
 *         
 * Module Name : 
 *             unlo.c
 *         
 * Shut down and delete functions
 * Where possible, code has been obtained from BINL server.
 *         
 * Sadagopan Rajaram -- Oct 14, 1999
 *         
 */        
 
#include "tcsrv.h"
#include <ntddser.h>
#include "tcsrvc.h"
#include "proto.h"

NTSTATUS
DeleteComPort(
    LPTSTR device
    )
/*++ 
    Deletes a Com port from the list 
--*/
{

    BOOL ret;
    NTSTATUS Status;
    PCOM_PORT_INFO pPrev,pComPortInfo;
    HANDLE Thread;
    int index,i;

    EnterCriticalSection(&GlobalMutex);
    if(TCGlobalServiceStatus.dwCurrentState == SERVICE_STOP_PENDING){
        // Entire Service is shutting down.
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_SUCCESS;
    }   // find the device needed to be deleted.
    pComPortInfo = FindDevice(device,&index); 
    if(!pComPortInfo){
        // Bah ! give me an existing device.
        LeaveCriticalSection(&GlobalMutex);
        return (STATUS_OBJECT_NAME_NOT_FOUND);
    }
    // Set the terminate event on the com port.
    ret = SetEvent(pComPortInfo->Events[3]);
    Thread = Threads[index];
    LeaveCriticalSection(&GlobalMutex);
    // wait for the com port thread to finish.
    Status = NtWaitForSingleObject(Thread, FALSE, NULL);
    if (Status == WAIT_FAILED) {
        // catastrophe
        return Status;
    }
    EnterCriticalSection(&GlobalMutex);
    // do this again as another delete or insert may have 
    // changed the index, though how is beyond me :-) 
    // if we are already shutting down the service.
    if(TCGlobalServiceStatus.dwCurrentState == SERVICE_STOP_PENDING){
        // Entire Service is shutting down.
        LeaveCriticalSection(&GlobalMutex);
        return STATUS_SUCCESS;
    }
    pComPortInfo = FindDevice(device,&index);
    if(!pComPortInfo){
        LeaveCriticalSection(&GlobalMutex);
        return (STATUS_OBJECT_NAME_NOT_FOUND);
    }
    if(pComPortInfo == ComPortInfo){
        ComPortInfo = pComPortInfo->Next;
    }
    else{
        pPrev = ComPortInfo;
        while(pPrev->Next != pComPortInfo){// Can never fail
            pPrev = pPrev->Next;
        }
        pPrev->Next = pComPortInfo->Next;
    }
    pComPortInfo->Next = NULL;
    FreeComPortInfo(pComPortInfo);
    NtClose(Threads[index]);
    for(i=index;i<ComPorts-1;i++){
        // move the threads array to the proper place
        Threads[i]=Threads[i+1];
    }
    ComPorts --;
    if(ComPorts == 0){
        TCFree(Threads);
        Threads=NULL;
    }
    LeaveCriticalSection(&GlobalMutex);
    return(STATUS_SUCCESS);

}

VOID 
Shutdown(
    NTSTATUS Status
    )
/*++
    Cleanly shut down the service. delete all threads, cancel all outstanding IRPs.
    Close all open sockets. 
--*/ 
{
    PCOM_PORT_INFO pTemp;
    int i;

    SetEvent(TerminateService); // all threads down
    // Can do this another way,
    // We can take each comport device and
    // delete it using the DeleteComPort 
    // function. But, this allows for maximum 
    // parallelism even in shutting down :-)

    if(Threads){
        WaitForMultipleObjects(ComPorts,Threads, TRUE, INFINITE); 
        // BUGBUG - what if thread is a rougue thread and
        // never comes back. Must use some reasonable
        // time out. 
        // Theory says INFINITE is the safest :-)
    }
    
    //All threads terminated.
    // Now start freeing all global memory
    // just using the locks as a safety measure.
    EnterCriticalSection(&GlobalMutex);
    while(ComPortInfo){
        pTemp = ComPortInfo;
        ComPortInfo=pTemp->Next;
        pTemp->Next = NULL;
        FreeComPortInfo(pTemp);

    }
    TCFree(Threads);         
    NtClose(TerminateService);
    LeaveCriticalSection(&GlobalMutex);

    UNINITIALIZE_TRACE_MEMORY
    //All done, now print status and exit.
    TCGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(TCGlobalServiceStatusHandle, &TCGlobalServiceStatus);

    TCDebugPrint(("Shutdown Status = %lx\n",Status));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__952CE458_7A87_478A_B722_0240CA1D831E__INCLUDED_)
#define AFX_CHILDFRM_H__952CE458_7A87_478A_B722_0240CA1D831E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__952CE458_7A87_478A_B722_0240CA1D831E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "watcher.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CMDIFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//
#include "StdAfx.h"
#include "watcher.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__38761070_0598_4D11_9F1E_BD4D0572E5BD__INCLUDED_)
#define AFX_MAINFRM_H__38761070_0598_4D11_9F1E_BD4D0572E5BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__38761070_0598_4D11_9F1E_BD4D0572E5BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\managedialog.h ===
#if !defined(AFX_MANAGEDIALOG_H__AEF13AD1_98C6_4DDF_80F8_F74873918D25__INCLUDED_)
#define AFX_MANAGEDIALOG_H__AEF13AD1_98C6_4DDF_80F8_F74873918D25__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ManageDialog.h : header file
//
#include "watcher.h"
#include "ParameterDialog.h"
/////////////////////////////////////////////////////////////////////////////
// ManageDialog dialog

class ManageDialog : public CDialog
{
// Construction
public:
        void SetApplicationPtr(CWatcherApp *watcher);
        ManageDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(ManageDialog)
        enum { IDD = Manage };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(ManageDialog)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        CWatcherApp *m_watcher;
        int m_Index;
        UINT Port;
        int lang;
        int tc;
        int hist;
        CString Session;
        CString LoginPasswd;
        CString LoginName;
        CString language;
        CString tcclnt;
        CString Command;
        CString Machine;
        CString history;

        void GetSetParameters(ParameterDialog &pd);
        int SetParameters(CString &mac, 
                          CString &com, 
                          CString &lgnName, 
                          CString &lgnPasswd, 
                          UINT port, 
                          int lang, 
                          int tc,
                          int hist,
                          HKEY &child
                          );
        // Generated message map functions
        //{{AFX_MSG(ManageDialog)
        afx_msg void OnEditButton();
        afx_msg void OnDeleteButton();
        afx_msg void OnNewButton();
        afx_msg void OnNextButton();
        afx_msg void OnPrevButton();
        virtual void OnOK();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MANAGEDIALOG_H__AEF13AD1_98C6_4DDF_80F8_F74873918D25__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\parameterdialog.cpp ===
// ParameterDialog.cpp : implementation file
//

#include "stdafx.h"
#include "watcher.h"
#include "ParameterDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ParameterDialog dialog


ParameterDialog::ParameterDialog(CWnd* pParent /*=NULL*/)
    : CDialog(ParameterDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(ParameterDialog)
        // NOTE: the ClassWizard will add member initialization here
    Machine = "";
    Command="";
    Port = TELNET_PORT;
    tcclnt = 0;
    language = 0;
	DeleteValue = FALSE;
    history = 0;
    //}}AFX_DATA_INIT
}


void ParameterDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ParameterDialog)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Text(pDX, IDC_MACHINE, Machine);
    DDV_MaxChars(pDX, Machine, 256);
    DDX_Text(pDX, IDC_COMMAND, Command);    
    DDV_MaxChars(pDX, Command, 256);
    DDX_Text(pDX, IDC_LOGIN, LoginName);    
    DDV_MaxChars(pDX, Command, 256);
    DDX_Text(pDX, IDC_PASSWD, LoginPasswd);    
    DDV_MaxChars(pDX, Command, 256);
    DDX_Text(pDX, IDC_SESSION, Session);    
    DDV_MaxChars(pDX, Session, 256);
	DDV_MinChars(pDX,Session);
    DDX_Text(pDX,IDC_PORT, Port);
    DDX_CBIndex(pDX,IDC_HISTORY,history);
    DDX_CBIndex(pDX,IDC_TELNET,tcclnt);
    DDX_CBIndex(pDX,IDC_LANGUAGE,language);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ParameterDialog, CDialog)
    //{{AFX_MSG_MAP(ParameterDialog)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ParameterDialog message handlers



void ParameterDialog::DDV_MinChars(CDataExchange *pDX, CString &str)
{
	if(pDX->m_bSaveAndValidate == FALSE){
		return;
	}

	if(str == TEXT("")){
		pDX->Fail();
		return;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\parameterdialog.h ===
#if !defined(AFX_PARAMETERDIALOG_H__E8ECC68E_A168_499A_8458_63293E3DD498__INCLUDED_)
#define AFX_PARAMETERDIALOG_H__E8ECC68E_A168_499A_8458_63293E3DD498__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ParameterDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
//  dialog

class ParameterDialog : public CDialog
{
// Construction
public:
        CString Session;
        CString LoginPasswd;
        CString LoginName;
        BOOL DeleteValue;
        int language;
        int tcclnt;
        int history;
        CString Command;
        CString Machine;
        UINT Port;
        ParameterDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(ParameterDialog)
        enum { IDD = Parameters };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(ParameterDialog)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        void DDV_MinChars(CDataExchange *pDX,CString &str);

        // Generated message map functions
        //{{AFX_MSG(ParameterDialog)
                // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PARAMETERDIALOG_H__E8ECC68E_A168_499A_8458_63293E3DD498__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\managedialog.cpp ===
// ManageDialog.cpp : implementation file
//

#include "stdafx.h"
#include "ManageDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ManageDialog dialog


ManageDialog::ManageDialog(CWnd* pParent /*=NULL*/)
:CDialog(ManageDialog::IDD, pParent),
 m_watcher(NULL),
 m_Index(0),
 Port(23),
 lang(0),
 tc(0),
 hist(0)
{
    //{{AFX_DATA_INIT(ManageDialog)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void ManageDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    CEdit *ctrl;
    BOOL ret;
    
    //{{AFX_DATA_MAP(ManageDialog)
    ctrl = (CEdit *)GetDlgItem(IDC_MACHINE_NAME_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_MACHINE_NAME_MANAGE, Machine);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_COMMAND_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_COMMAND_MANAGE, Command);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_LOGIN_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_LOGIN_MANAGE, LoginName);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_PASSWD_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_PASSWD_MANAGE, LoginPasswd);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_SESSION_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX, IDC_SESSION_MANAGE, Session);    
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_PORT_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_PORT_MANAGE, Port);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_CLIENT_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_CLIENT_MANAGE,tcclnt);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_LANGUAGE_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_LANGUAGE_MANAGE,language);
    ret = ctrl->SetReadOnly(TRUE);
    ctrl = (CEdit *)GetDlgItem(IDC_HISTORY_MANAGE);
    ret = ctrl->SetReadOnly(FALSE);
    DDX_Text(pDX,IDC_HISTORY_MANAGE,history);
    ret = ctrl->SetReadOnly(TRUE);
    // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ManageDialog, CDialog)
    //{{AFX_MSG_MAP(ManageDialog)
    ON_BN_CLICKED(EDIT_BUTTON, OnEditButton)
    ON_BN_CLICKED(DELETE_BUTTON, OnDeleteButton)
    ON_BN_CLICKED(NEW_BUTTON, OnNewButton)
    ON_BN_CLICKED(NEXT_BUTTON, OnNextButton)
    ON_BN_CLICKED(PREV_BUTTON, OnPrevButton)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// ManageDialog message handlers

void ManageDialog::OnEditButton() 
{
    // TODO: Add your control notification handler code here
    ParameterDialog pd;

    pd.Session = (LPCTSTR) Session;
    pd.Machine = (LPCTSTR) Machine;
    pd.Command = (LPCTSTR) Command;
    CString temp;
    pd.language = lang;
    pd.tcclnt = tc;
    pd.history = hist;
    pd.LoginName = (LPCTSTR) LoginName;
    pd.LoginPasswd = (LPCTSTR) LoginPasswd;
    pd.Port = Port;
    GetSetParameters(pd);
    if(m_watcher){
        int ret = m_watcher->GetParametersByIndex(m_Index,
                                                  Session,
                                                  Machine,
                                                  Command,
                                                  Port,
                                                  lang,
                                                  tc,
                                                  hist,
                                                  LoginName,
                                                  LoginPasswd
                                                  );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        }
    }
    UpdateData(FALSE);
}

void ManageDialog::OnDeleteButton() 
{
    // TODO: Add your control notification handler code here
    HKEY &m_hkey = m_watcher->GetKey();

    if(!m_hkey){
        return;
    }
    int RetVal = RegDeleteKey(m_hkey,
                              (LPCTSTR) Session
                              );
    if (RetVal == ERROR_SUCCESS){
        m_Index = m_Index ? m_Index -1 : 0;
        if(m_watcher){
            ParameterDialog pd;
            pd.Session = Session;
            m_watcher->Refresh(pd,TRUE);
            RetVal = m_watcher->GetParametersByIndex(m_Index,
                                                     Session,
                                                     Machine,
                                                     Command,
                                                     Port,
                                                     lang,
                                                     tc,
                                                     hist,
                                                     LoginName,
                                                     LoginPasswd
                                                     );
            if(RetVal == ERROR_SUCCESS){
                language.LoadString(IDS_ENGLISH + lang);
                tcclnt.LoadString(IDS_TELNET + tc);
                history.LoadString(IDS_NO + hist);
            }
        }
    }
    UpdateData(FALSE);

}

void ManageDialog::OnNewButton() 
{
    // TODO: Add your control notification handler code here
    ParameterDialog pd;
    GetSetParameters(pd);

}

void ManageDialog::OnNextButton() 
{
    // TODO: Add your control notification handler code here
    int ret = 0;

    m_Index ++;
    if(m_watcher){
        ret = m_watcher->GetParametersByIndex(m_Index,
                                              Session,
                                              Machine,
                                              Command,
                                              Port,
                                              lang,
                                              tc,
                                              hist,
                                              LoginName,
                                              LoginPasswd
                                              );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        }
    }
    if (ret != 0){
        m_Index --;
        if(m_watcher){
            ret = m_watcher->GetParametersByIndex(m_Index,
                                                  Session,
                                                  Machine,
                                                  Command,
                                                  Port,
                                                  lang,
                                                  tc,
                                                  hist,
                                                  LoginName,
                                                  LoginPasswd
                                                  ); 
            if(ret == ERROR_SUCCESS){
                language.LoadString(IDS_ENGLISH + lang);
                tcclnt.LoadString(IDS_TELNET + tc);
                history.LoadString(IDS_NO + hist);
            }
        }
    }
    UpdateData(FALSE);
    return;

}

void ManageDialog::OnPrevButton() 
{
    // TODO: Add your control notification handler code here
    int ret = 0;

    m_Index = m_Index ? m_Index -1 : 0;
    if(m_watcher){
        ret = m_watcher->GetParametersByIndex(m_Index,
                                              Session,
                                              Machine,
                                              Command,
                                              Port,
                                              lang,
                                              tc,
                                              hist,
                                              LoginName,
                                              LoginPasswd
                                              );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        } 
    }
    if (ret != 0){
        m_Index =0;
        if(m_watcher){
            ret = m_watcher->GetParametersByIndex(m_Index,
                                                  Session,
                                                  Machine,
                                                  Command,
                                                  Port,
                                                  lang,
                                                  tc,
                                                  hist,
                                                  LoginName,
                                                  LoginPasswd
                                                  );
            if(ret == ERROR_SUCCESS){
                language.LoadString(IDS_ENGLISH + lang);
                tcclnt.LoadString(IDS_TELNET + tc);
                history.LoadString(IDS_NO + hist);
            }
        }
    }
    UpdateData(FALSE);
    return;
}

void ManageDialog::OnOK() 
{
    // TODO: Add extra validation here

    CDialog::OnOK();
}

void ManageDialog::SetApplicationPtr(CWatcherApp *watcher)
{

    int ret = 0;

    m_watcher = watcher;
    if(m_watcher){
        ret = m_watcher->GetParametersByIndex(m_Index,
                                              Session,
                                              Machine,
                                              Command,
                                              Port,
                                              lang,
                                              tc,
                                              hist,
                                              LoginName,
                                              LoginPasswd
                                              );
        if(ret == ERROR_SUCCESS){
            language.LoadString(IDS_ENGLISH + lang);
            tcclnt.LoadString(IDS_TELNET + tc);
            history.LoadString(IDS_NO + hist);
        }
    }
}

void ManageDialog::GetSetParameters(ParameterDialog &pd)
{
    HKEY m_child;

    INT_PTR ret = pd.DoModal();
    if (ret == IDOK){
        // Add it to the registry
        if(m_watcher){
            HKEY & m_hkey = m_watcher->GetKey();
            ret = RegCreateKeyEx(m_hkey,
                                 (LPCTSTR) pd.Session,   // subkey name
                                 0,                      // reserved
                                 NULL,                   // class string
                                 0,                      // special options
                                 KEY_ALL_ACCESS,         // desired security access
                                 NULL,                   // inheritance
                                 &m_child,               // key handle
                                 NULL                    // disposition value buffer
                                 );
            if (ret == ERROR_SUCCESS){
                ret = SetParameters(pd.Machine, pd.Command,
                                    pd.LoginName, pd.LoginPasswd,
                                    pd.Port, pd.language,
                                    pd.tcclnt,pd.history,
                                    m_child
                                    );
                if(ret == ERROR_SUCCESS){
                    m_watcher->Refresh(pd,FALSE);
                }
            }  
        }else{
            return;
        }
    }
}

int ManageDialog::SetParameters(CString &mac, 
                                CString &com, 
                                CString &lgnName, 
                                CString &lgnPasswd, 
                                UINT port, 
                                int lang, 
                                int tc, 
                                int hist,
                                HKEY &child
                                )
{
    DWORD lpcName;
    const TCHAR *lpName;
    int RetVal;
    int charSize = sizeof(TCHAR);

    lpcName = MAX_BUFFER_SIZE;
    lpName = (LPCTSTR) mac;
    lpcName = (mac.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("Machine"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE) lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpName = (LPCTSTR) com;
    lpcName = (com.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("Command"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE)lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpName = (LPCTSTR) lgnName;
    lpcName = (lgnName.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("User Name"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE)lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpName = (LPCTSTR) lgnPasswd;
    lpcName = (lgnPasswd.GetLength())*charSize;
    RetVal = RegSetValueEx(child,
                           _TEXT("Password"),
                           NULL,  
                           REG_SZ,
                           (LPBYTE)lpName,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }

    lpcName = sizeof(UINT);
    RetVal = RegSetValueEx(child,
                           _TEXT("Port"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&port,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(DWORD);
    RetVal = RegSetValueEx(child,
                           _TEXT("Client Type"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&tc,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(DWORD);
    RetVal = RegSetValueEx(child,
                           _TEXT("Language"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&lang,
                           lpcName
                           );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(DWORD);
    RetVal = RegSetValueEx(child,
                           _TEXT("History"),
                           NULL,  
                           REG_DWORD,
                           (LPBYTE)&hist,
                           lpcName
                           );  
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    // Now you can refresh the application.

    return RetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	watcher.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "StdAfx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by watcher.rc
//
#define IDD_ABOUTBOX                    100
#define IDP_SOCKETS_INIT_FAILED         104
#define IDR_MAINFRAME                   128
#define IDR_WATCHETYPE                  129
#define Parameters                      130
#define Manage                          133
#define IDC_MACHINE_STATIC              1000
#define IDC_PORT_STATIC                 1001
#define IDC_COMMAND_CAPTION             1002
#define IDC_MACHINE                     1003
#define IDC_PORT                        1004
#define IDC_COMMAND                     1005
#define IDC_CLIENT_MANAGE               1006
#define IDC_TELNET                      1008
#define IDC_COMBO_STATIC                1009
#define IDC_LANGUAGE_STATIC             1010
#define IDC_LANGUAGE                    1011
#define IDC_LOGIN                       1012
#define IDC_STATIC_LOGIN                1013
#define IDC_PASSWD                      1014
#define NEW_BUTTON                      1014
#define IDC_STATIC_PASSWD               1015
#define DELETE_BUTTON                   1015
#define IDC_SESSION                     1016
#define EDIT_BUTTON                     1016
#define IDC_STATIC_SESSION              1017
#define NEXT_BUTTON                     1017
#define PREV_BUTTON                     1018
#define IDC_HISTORY                     1018
#define IDC_PASSWD_MANAGE               1019
#define IDC_STATIC_HISTORY              1019
#define IDC_STATIC_PASSWD_MANAGE        1020
#define IDC_SESSION_MANAGE              1021
#define IDC_STATIC_SESSION_MANAGE       1022
#define IDC_MACHINE_STATIC_MANAGE       1023
#define IDC_PORT_STATIC_MANAGE          1024
#define IDC_COMMAND_CAPTION_MANAGE      1025
#define IDC_COMBO_STATIC_MANAGE         1026
#define IDC_LANGUAGE_STATIC_MANAGE      1027
#define IDC_STATIC_LOGIN_MANAGE         1028
#define IDC_LOGIN_MANAGE                1029
#define IDC_LANGUAGE_MANAGE             1030
#define IDC_COMMAND_MANAGE              1031
#define IDC_PORT_MANAGE                 1032
#define IDC_MACHINE_NAME_MANAGE         1033
#define IDC_HISTORY_MANAGE              1034
#define IDC_STATIC_HISTORY_MANAGE       1035
#define ID_APP_PARAMETERS_SAVE          32774
#define ID_FILE_MANAGE                  32775
#define AFX_IDS_APP_PROFILE             57346
#define AFX_IDS_COMPANY                 57347
#define IDS_TELNET                      61446
#define IDS_TC                          61447
#define IDS_NO                          61448
#define IDS_YES                         61449
#define IDS_ENGLISH                     61450
#define IDS_JAPANESE                    61451
#define IDS_EUROPEAN                    61452
#define CREATE_WMI_OBJECT_FAILURE       61453
#define CREATE_TEXT_SRC_FAILURE         61454
#define CREATE_TC_SOCKET_FAILURE        61455
#define CREATE_TELNET_SOCKET_FAILURE    61456
#define CDC_TEXT_FAILURE                61457
#define SOCKET_CONNECTION_FAILED        61458
#define SOCKET_CREATION_FAILED          61459

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__D2DE24F7_ACC0_4A4A_B473_23DF6153FBE4__INCLUDED_)
#define AFX_STDAFX_H__D2DE24F7_ACC0_4A4A_B473_23DF6153FBE4__INCLUDED_
#if dbg ==1 && !defined (_DEBUG)
#define _DEBUG
#endif
#if _MSC_VER > 1000
#pragma once

#include <afxwin.h>         // MFC core and standard components
#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxsock.h>        // MFC socket extensions
#include <afxmt.h>          // MFC Multi threading support
//#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls

#endif // _MSC_VER > 1000
//COLOR DEFINITIONS

#define WHITE RGB(128,128,128)
#define BLACK RGB(0,0,0)
#define BLUE RGB(0,0,128)
#define YELLOW RGB(0,128,128)
#define RED RGB(128,0,0)

// Code Page definitions
#define ENGLISH 437
#define JAPANESE 932
#define EUROPEAN 1250
#define MAX_LANGUAGES 3
#define MAX_BUFFER_SIZE 256
#define TELNET_PORT 23
#define MAX_TERMINAL_HEIGHT 24
#define MAX_TERMINAL_WIDTH 80

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line 
#endif //!defined(AFX_STDAFX_H__D2DE24F7_ACC0_4A4A_B473_23DF6153FBE4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watcher.cpp ===
// watcher.cpp : Defines the class behaviors for the application.
//
#include "StdAfx.h"
#include "watcher.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "watcherDoc.h"
#include "watcherView.h"
#include "ManageDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp

BEGIN_MESSAGE_MAP(CWatcherApp, CWinApp)
    //{{AFX_MSG_MAP(CWatcherApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_APP_EXIT, OnAppExit)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_MANAGE,OnFileManage)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelp)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp construction

CWatcherApp::CWatcherApp()
:m_hkey(NULL),
 m_pDocTemplate(NULL),
 m_pManageDialog(NULL)
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWatcherApp object

CWatcherApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp initialization

BOOL CWatcherApp::InitInstance()
{
    if (!AfxSocketInit()){
        AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
        return FALSE;
    }

    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    #ifdef _AFXDLL
    Enable3dControls();                     // Call this when using MFC in a shared DLL
    #else
    Enable3dControlsStatic();       // Call this when linking to MFC statically
    #endif

    // Change the registry key under which our settings are stored.
    // TODO: You should modify this string to be something appropriate
    // such as the name of your company or organization.
    // will do this in the ProcessShellCommand part.....

    //      SetRegistryKey(AFX_IDS_COMPANY);

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocTemplate = new CMultiDocTemplate(IDR_WATCHETYPE,
                                           RUNTIME_CLASS(CWatcherDoc),
                                           RUNTIME_CLASS(CChildFrame),
                                           // custom MDI child frame
                                           RUNTIME_CLASS(CWatcherView));
    if(!m_pDocTemplate){
        // Will almost never occur , but ...
        // Oops !!
        return FALSE;
    }
    AddDocTemplate(m_pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if(!pMainFrame){
        // Will almost never occur , but ...
        // Oops !!
        return FALSE;
    }

    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();
    // Dispatch commands specified on the command line
    m_hkey = GetAppRegistryKey();

    if(m_hkey == NULL){
        return FALSE;
    }
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;
    // Get the value of the key in the registry where all the parameters are stored.

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    // Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
    // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWatcherApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp message handlers


void CWatcherApp::OnFileManage(){
    // Here we bring up the manage window.

    if (m_pManageDialog){
        m_pManageDialog->ShowWindow(SW_SHOWNORMAL);
        return;
    }
    // Actually construct the dialog box here
    m_pManageDialog = new ManageDialog();
    if( !m_pManageDialog){
        // Oops!! Memory problem
        return;
    }
    ((ManageDialog *) m_pManageDialog)->SetApplicationPtr(this);
    m_pManageDialog->Create(Manage);
    m_pManageDialog->ShowWindow(SW_SHOWNORMAL);
    return;
}


void CWatcherApp::OnHelp()
{
    // Need to expand on this a little bit.
    CWinApp::WinHelp(0,HELP_CONTENTS);
}

void CWatcherApp::ParseCommandLine(CCommandLineInfo& rCmdInfo)
{
    BOOL setReg = FALSE;
    for (int i = 1; i < __argc; i++){
        LPCTSTR pszParam = __targv[i];
        BOOL bFlag = FALSE;
        BOOL bLast = ((i + 1) == __argc);
        if (pszParam[0] == '-' || pszParam[0] == '/'){
            // remove flag specifier
            bFlag = TRUE;
            ++pszParam;
            if (_tcscmp(pszParam, TEXT("r")) == 0){
                // we are being given a new registry profile string
                // Can only change this from watcher.
                // HKEY_CURRENT_USER\\SOFTWARE\\%KEY%\\WATCHER
                if(!bLast) {
                    // the next argument is the string
                    SetRegistryKey(__targv[i+1]);
                    i++;
                    setReg = TRUE;
                    if(i==__argc){
                        if (rCmdInfo.m_nShellCommand == CCommandLineInfo::FileNew && !rCmdInfo.m_strFileName.IsEmpty())
                            rCmdInfo.m_nShellCommand = CCommandLineInfo::FileOpen;
                        rCmdInfo.m_bShowSplash = !rCmdInfo.m_bRunEmbedded && !rCmdInfo.m_bRunAutomated;
                    }
                    continue;
                }

            }
        }
        rCmdInfo.ParseParam(pszParam, bFlag, bLast);
    }
    if(!setReg){
        SetRegistryKey(AFX_IDS_COMPANY);
    }
}

BOOL CWatcherApp::ProcessShellCommand(CCommandLineInfo& rCmdInfo)
{
    BOOL bResult = TRUE;
    switch (rCmdInfo.m_nShellCommand)
        {
    case CCommandLineInfo::FileNew:
        // Load parameters from the registry
        bResult = LoadRegistryParameters();
    break;

    // If we've been asked to open a file, call OpenDocumentFile()

    case CCommandLineInfo::FileOpen:
        // cannot happen ...... maybe later allow the user to read
        // parameters from a file.
        break;

    // If the user wanted to print, hide our main window and
    // fire a message to ourselves to start the printing

    case CCommandLineInfo::FilePrintTo:
    case CCommandLineInfo::FilePrint:
        m_nCmdShow = SW_HIDE;
    ASSERT(m_pCmdInfo == NULL);
    OpenDocumentFile(rCmdInfo.m_strFileName);
    m_pCmdInfo = &rCmdInfo;
    m_pMainWnd->SendMessage(WM_COMMAND, ID_FILE_PRINT_DIRECT);
    m_pCmdInfo = NULL;
    bResult = FALSE;
    break;

    // If we're doing DDE, hide ourselves

    case CCommandLineInfo::FileDDE:
//        m_pCmdInfo = (CCommandLineInfo*)m_nCmdShow;
    m_nCmdShow = SW_HIDE;
    break;

    // If we've been asked to unregister, unregister and then terminate
    case CCommandLineInfo::AppUnregister:
        {
        UnregisterShellFileTypes();
        BOOL bUnregistered = Unregister();

        // if you specify /EMBEDDED, we won't make an success/failure box
        // this use of /EMBEDDED is not related to OLE

        if (!rCmdInfo.m_bRunEmbedded)
            {
            if (bUnregistered)
                AfxMessageBox(AFX_IDP_UNREG_DONE);
            else
                AfxMessageBox(AFX_IDP_UNREG_FAILURE);
        }
        bResult = FALSE;    // that's all we do

        // If nobody is using it already, we can use it.
        // We'll flag that we're unregistering and not save our state
        // on the way out. This new object gets deleted by the
        // app object destructor.

        if (m_pCmdInfo == NULL)
            {
            m_pCmdInfo = new CCommandLineInfo;
            m_pCmdInfo->m_nShellCommand = CCommandLineInfo::AppUnregister;
        }
    }
    break;
    }
    return bResult;
}

BOOL CWatcherApp::LoadRegistryParameters()
{

    DWORD dwIndex=0;
    CString sess,lgnName, lgnPasswd;
    CString mac, com;
    UINT port;
    LONG RetVal;
    int tc, lang,hist;


    //Get each session parameters from here
    // There are NO optional values.

    while(1){
        RetVal = GetParametersByIndex(dwIndex,
                                      sess,
                                      mac,
                                      com,
                                      port,
                                      lang,
                                      tc,
                                      hist,
                                      lgnName,
                                      lgnPasswd
                                      );
        if(RetVal == ERROR_NO_MORE_ITEMS){
            return TRUE;
        }
        if (RetVal != ERROR_SUCCESS) {
            return FALSE;
        }
        // Make sure that the string buffers are NOT shared by locking
        // them.
        mac.LockBuffer();
        com.LockBuffer();
        lgnName.LockBuffer();
        lgnPasswd.LockBuffer();
        sess.LockBuffer();        // Passing references is really cool.
        CreateNewSession(mac, com, port,lang, tc, hist,lgnName, lgnPasswd,sess);
        dwIndex ++;
    }
    return TRUE;
}

int CWatcherApp::GetParametersByIndex(int dwIndex,
                                      CString &sess,
                                      CString &mac,
                                      CString &com,
                                      UINT &port,
                                      int &lang,
                                      int &tc,
                                      int &hist,
                                      CString &lgnName,
                                      CString &lgnPasswd
                                      )
{
    LONG RetVal;
    TCHAR lpName[MAX_BUFFER_SIZE];
    DWORD lpcName;
    FILETIME lpftLastWriteTime;
    HKEY child;
    DWORD lpType = 0;


    if (m_hkey == NULL) return -1;
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegEnumKeyEx(m_hkey,
                      dwIndex,
                      lpName,
                      &lpcName,
                      NULL,
                      NULL,
                      NULL,
                      &lpftLastWriteTime
                          );
    if(RetVal == ERROR_NO_MORE_ITEMS){
        return RetVal;
    }

    if(RetVal != ERROR_SUCCESS){
        RegCloseKey(m_hkey);
        m_hkey = NULL;
        return FALSE;
    }

    sess = lpName;
    RetVal= RegOpenKeyEx(m_hkey,
                         lpName,  // subkey name
                         0,   // reserved
                         KEY_ALL_ACCESS, // security access mask
                         &child
                         );
    if(RetVal != ERROR_SUCCESS){
        // Hmm problem with main key itself
        RegCloseKey(m_hkey);
        m_hkey = NULL;
        return RetVal;
    }
    // We open the key corresponding to the session and then try to
    // obtain the parameters. Now, we need a lock possibly to achieve
    // synchronization.That would be a complete solution.
    // Use some kind of readers-writers solution.
    // Fault tolerant ???
    // Get the remaining parameters.
    RetVal = GetParameters(mac,
                           com,
                           lgnName,
                           lgnPasswd,
                           port,
                           lang,
                           tc,
                           hist,
                           child
                           );
    RegCloseKey(child);
    return RetVal;
}

void CWatcherApp::CreateNewSession(CString &mac,
                                   CString &com,
                                   UINT port,
                                   int lang,
                                   int tc,
                                   int hist,
                                   CString &lgnName,
                                   CString &lgnPasswd,
                                   CString &sess
                                   )
{
    CCreateContext con;
    CChildFrame *cmdiFrame;

    con.m_pNewViewClass = RUNTIME_CLASS(CWatcherView);
    con.m_pCurrentFrame = NULL;
    con.m_pNewDocTemplate = m_pDocTemplate;

    // A new document is created using these parameters.
    // BUGBUG - Memory inefficiency :-(
    // This function must be shared between the ManageDialog and
    // the Watcher Application.
    // Will probably declare them as friends of each other.
    // For the moment , let use have two copies of the function.
    con.m_pCurrentDoc = new CWatcherDoc(mac,
                                        com,
                                        port,
                                        tc,
                                        lang,
                                        hist,
                                        lgnName,
                                        lgnPasswd,
                                        sess
                                        );
    // Add the document to the template.
    // this is how the document is available to the document
    // manager.
    if(!con.m_pCurrentDoc){
        // Can occur if you keep on opening newer sessions.
        // Oops !!
        return;
    }
    m_pDocTemplate->AddDocument(con.m_pCurrentDoc);
    cmdiFrame = new CChildFrame();
    if(!cmdiFrame){
        // Oops !!
        return;
    }
    BOOL ret = cmdiFrame->LoadFrame(IDR_WATCHETYPE,
                               WS_OVERLAPPEDWINDOW|FWS_ADDTOTITLE,
                               NULL,
                               &con);
    ret = con.m_pCurrentDoc->OnNewDocument();
    cmdiFrame->InitialUpdateFrame(con.m_pCurrentDoc,TRUE);
    return;
}

int CWatcherApp::GetParameters(CString &mac,
                               CString &com,
                               CString &lgnName,
                               CString &lgnPasswd,
                               UINT &port,
                               int &lang,
                               int &tc,
                               int &hist,
                               HKEY &child
                               )
{

    DWORD lpcName, lpType;
    TCHAR lpName[MAX_BUFFER_SIZE];
    int RetVal;


    // I see this kind of function in all the programs that use the
    // registry. Should try to simplify this.
    // BUGBUG - Memory inefficiency :-(
    // This function must be shared between the ManageDialog and
    // the Watcher Application.
    // Will probably declare them as friends of each other.
    // For the moment , let use have two copies of the function.
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegQueryValueEx(child,
                             _TEXT("Machine"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    mac = lpName;
    lpName[0] = 0;
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegQueryValueEx(child,
                             _TEXT("Command"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    com = lpName;
    lpcName = MAX_BUFFER_SIZE;
    lpName[0] = 0;
    RetVal = RegQueryValueEx(child,
                             _TEXT("Password"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lgnPasswd = lpName;
    lpName[0] = 0;
    lpcName = MAX_BUFFER_SIZE;
    RetVal = RegQueryValueEx(child,
                             _TEXT("User Name"),
                             NULL,
                             &lpType,
                             (LPBYTE)lpName,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lgnName = lpName;
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("Port"),
                             NULL,
                             &lpType,
                             (LPBYTE)&port,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("Client Type"),
                             NULL,
                             &lpType,
                             (LPBYTE)&tc,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("Language"),
                             NULL,
                             &lpType,
                             (LPBYTE)&lang,
                             &lpcName
                             );
    if(RetVal != ERROR_SUCCESS){
        return RetVal;
    }
    lpcName = sizeof(int);
    RetVal = RegQueryValueEx(child,
                             _TEXT("History"),
                             NULL,
                             &lpType,
                             (LPBYTE)&hist,
                             &lpcName
                             );
    return RetVal;
}

void CWatcherApp::OnAppExit()
{
    // TODO: Add your command handler code here
    if (m_pManageDialog){
        delete m_pManageDialog;
    }
    if(m_hkey){
        RegCloseKey(m_hkey);
        m_hkey = NULL;
    }
    CWinApp::OnAppExit();
}

HKEY & CWatcherApp::GetKey()
{
    return m_hkey;
}

void CWatcherApp::Refresh(ParameterDialog &pd, BOOLEAN del){
    POSITION index;

    if(m_pDocTemplate == NULL){
        return;
    }
    CDocument *doc;
    CWatcherDoc *wdoc;
    index = m_pDocTemplate->GetFirstDocPosition();
    while(index != NULL){
        doc = m_pDocTemplate->GetNextDoc(index);
        if(doc->GetTitle() == pd.Session){
            // May be conflict
            if(doc->IsKindOf(RUNTIME_CLASS(CWatcherDoc))){
                wdoc = (CWatcherDoc *) doc;
                ParameterDialog & dpd = wdoc->GetParameters();
                if(EqualParameters(pd, dpd)==FALSE){
                    DeleteSession(doc);
                    if(!del){
                        CreateNewSession(pd.Machine, pd.Command, pd.Port,
                                         pd.language, pd.tcclnt, pd.history,
                                         pd.LoginName, pd.LoginPasswd,
                                         pd.Session
                                         );
                    }
                    return;
                }

            }else{
                // Doc Template returning junk values.
                return;
            }


        }
    }
    if(!del){
        CreateNewSession(pd.Machine, pd.Command, pd.Port,
                         pd.language, pd.tcclnt, pd.history,
                         pd.LoginName, pd.LoginPasswd,
                         pd.Session
                         );
    }

}

void CWatcherApp::DeleteSession(CDocument *wdoc)
{
    POSITION pos;
    pos = wdoc->GetFirstViewPosition();
    while (pos != NULL){
        CView* pView = wdoc->GetNextView(pos);
        CWnd *pParent = pView->GetParent();
        if(pParent){
            pParent->PostMessage(WM_CLOSE,0,0);
            return;
        }
    }


}

BOOLEAN CWatcherApp::EqualParameters(ParameterDialog & pd1, ParameterDialog & pd2)
{
     if((pd1.Session != pd2.Session)||
       (pd1.Machine != pd2.Machine)||
       (pd1.Command != pd2.Command)||
       (pd1.history != pd2.history)||
       (pd1.language != pd2.language)||
       (pd1.tcclnt != pd2.tcclnt)||
       (pd1.Port != pd2.Port)){
        return FALSE;
    }
    if((pd1.LoginPasswd != pd2.LoginPasswd)||
       (pd1.LoginName != pd2.LoginName)){
        return FALSE;
       }
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watchersocket.cpp ===
// WatcherSocket.cpp : implementation file
//

#include "stdafx.h"
#include "watcher.h"
#include "WatcherSocket.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// WatcherSocket

WatcherSocket::WatcherSocket()
{
	DocView = NULL;
	Command = NULL;
}

WatcherSocket::~WatcherSocket()
{

	CSocket::~CSocket();
}


// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(WatcherSocket, CSocket)
	//{{AFX_MSG_MAP(WatcherSocket)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif	// 0

/////////////////////////////////////////////////////////////////////////////
// WatcherSocket member functions

void WatcherSocket::SetParentView(CView *view)
{
    if (DocView) return;
    DocView = view;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watcher.h ===
// watcher.h : main header file for the WATCHER application
//

#if !defined(AFX_WATCHER_H__691AA721_59DC_4A70_AB0E_224249D74256__INCLUDED_)
#define AFX_WATCHER_H__691AA721_59DC_4A70_AB0E_224249D74256__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "ParameterDialog.h"

/////////////////////////////////////////////////////////////////////////////
// CWatcherApp:
// See watcher.cpp for the implementation of this class
//

class CWatcherApp : public CWinApp
{
public:
    //void AddParameter();
    CWatcherApp();

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWatcherApp)
public:
    // Making this public so that the Manage Dialog 
    // can access this function.
    int GetParametersByIndex(int dwIndex,
                             CString &sess,
                             CString &mac,
                             CString &com,
                             UINT &port,
                             int &lang,
                             int &tc,
                             int &hist,
                             CString &lgnName,
                             CString &lgnPasswd
                             );
    void Refresh(ParameterDialog &pd, BOOLEAN del);
    HKEY & GetKey();
    virtual BOOL InitInstance();
    virtual void ParseCommandLine(CCommandLineInfo& rCmdInfo);
    virtual BOOL ProcessShellCommand(CCommandLineInfo &rCmdInfo);
    //}}AFX_VIRTUAL

    // Implementation
    //{{AFX_MSG(CWatcherApp)
    afx_msg void OnAppAbout();
    afx_msg void OnAppExit();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
protected:
    // Reads in the parameters from the registry 
    // corresponding to the session.
    void DeleteSession(CDocument *wdoc);
    BOOLEAN EqualParameters(ParameterDialog & pd1, ParameterDialog & pd2);
    int GetParameters(CString &mac,
                      CString &com, 
                      CString &lgnName, 
                      CString &lgnPasswd, 
                      UINT &port,
                      int &lang,
                      int &tc, 
                      int & hist,
                      HKEY &child
                      );
    // does everything the document manager does when asked to 
    // create a new document. 
    void CreateNewSession(CString &mac, 
                          CString &com, 
                          UINT port, 
                          int lang, 
                          int tc, 
                          int hist,
                          CString &lgnName, 
                          CString &lgnPasswd, 
                          CString &sess
                          );
    BOOL LoadRegistryParameters();
    afx_msg void OnHelp();
    afx_msg void OnFileManage();
    HKEY m_hkey;
    CMultiDocTemplate * m_pDocTemplate;
    CDialog *m_pManageDialog;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHER_H__691AA721_59DC_4A70_AB0E_224249D74256__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watcherdoc.h ===
// watcherDoc.h : interface of the CWatcherDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WATCHERDOC_H__C1609D45_5255_456D_97BD_BF6372AFCBB1__INCLUDED_)
#define AFX_WATCHERDOC_H__C1609D45_5255_456D_97BD_BF6372AFCBB1__INCLUDED_

#include "ParameterDialog.h"    // Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CWatcherDoc : public CDocument
{
protected: // create from serialization only
        CWatcherDoc();
        DECLARE_DYNCREATE(CWatcherDoc)

// Attributes
public:
        CWatcherDoc(CString &machine, CString &command, UINT port, 
                int tc, int lang, int hist, CString &lgnName, CString &lgnPasswd, CString &sess);

// Operations
public:

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CWatcherDoc)
        public:
        virtual BOOL OnNewDocument();
        virtual void Serialize(CArchive& ar);
        virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
        //}}AFX_VIRTUAL

// Implementation
public:
        ParameterDialog & GetParameters();
        void ScrollData(BYTE byte, COLORREF foreground,COLORREF background,
                        int ScrollTop, int ScrollBottom);
        BOOL Unlock();
        BOOL Lock();
        TCHAR * GetDataLine(int line);
        void SetData(int x, int y, BYTE byte, int n, COLORREF foreground, COLORREF background);
        void SetData(int x, int y, TCHAR byte, COLORREF foreground, COLORREF background);
        TCHAR * GetData(void);
        COLORREF * GetForeground(void);
        COLORREF * GetBackground(void);
        virtual ~CWatcherDoc();
#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
        ParameterDialog Params;
        COLORREF Background[MAX_TERMINAL_HEIGHT*MAX_TERMINAL_WIDTH];
        COLORREF Foreground[MAX_TERMINAL_HEIGHT*MAX_TERMINAL_WIDTH];
        TCHAR Data[MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT];
        CCriticalSection mutex;
        //{{AFX_MSG(CWatcherDoc)
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERDOC_H__C1609D45_5255_456D_97BD_BF6372AFCBB1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watchersocket.h ===
#if !defined(AFX_WATCHERSOCKET_H__52E4ADBF_C131_4999_9B73_88136FFBC4DD__INCLUDED_)
#define AFX_WATCHERSOCKET_H__52E4ADBF_C131_4999_9B73_88136FFBC4DD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WatcherSocket.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// WatcherSocket command target

class WatcherSocket : public CSocket
{
// Attributes
public:
// Operations
public:
	WatcherSocket();
	virtual ~WatcherSocket();

// Overrides
public:
	void SetParentView(CView *view);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(WatcherSocket)
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(WatcherSocket)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

// Implementation
protected:
	LPBYTE Command;
	CView * DocView;
	int lenCommand;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERSOCKET_H__52E4ADBF_C131_4999_9B73_88136FFBC4DD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watchertcclient.cpp ===
// WatcherTCClient.cpp : implementation file
//

#include "stdafx.h"
#include "WATCHER.h"
#include "WatcherTCClient.h"
#include "WATCHERView.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// WatcherTCClient

WatcherTCClient::WatcherTCClient(LPBYTE cmd, int cmdLen)
{
    DocView = NULL;
        lenCommand = cmdLen;
        Command = cmd;
}

WatcherTCClient::~WatcherTCClient()
{
        if(Command){
                delete [] Command;
                Command = NULL;
        }
        WatcherSocket::~WatcherSocket();
}


// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(WatcherTCClient, WatcherSocket)
        //{{AFX_MSG_MAP(WatcherTCClient)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif  // 0

/////////////////////////////////////////////////////////////////////////////
// WatcherTCClient member functions

void WatcherTCClient::OnClose(int nErrorCode)
{
    BOOL ret = (DocView->GetParent())->PostMessage(WM_CLOSE,0,0);
    WatcherSocket::OnClose(nErrorCode);
    return;
}

void WatcherTCClient::OnReceive(int nErrorCode)
{
    BYTE Buffer[MAX_BUFFER_SIZE];
    int i,nRet;

    if (nErrorCode != 0) {
        (DocView->GetParent())->PostMessage(WM_CLOSE, 0,0);
        return;
    }
    nRet = Receive(Buffer, MAX_BUFFER_SIZE, 0);
    if(nRet <= 0) return;
    for(i=0;i<nRet;i++){
       ((CWatcherView *)DocView)->ProcessByte(Buffer[i]);
    }
        WatcherSocket::OnReceive(nErrorCode);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watchertelnetclient.cpp ===
// WatcherTelnetClient.cpp : implementation file
//

#include "stdafx.h"
#include "WATCHER.h"
#include "WatcherTelnetClient.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "WATCHERView.h"
/////////////////////////////////////////////////////////////////////////////
// WatcherTelnetClient

WatcherTelnetClient::WatcherTelnetClient(LPBYTE cmd, int cmdLen, 
                                         LPBYTE lgn, int lgnLen)
:CommandSequence(NO_COMMAND),
 lenLogin(lgnLen),
 Login(lgn),
 OptionIndex(0),
 PacketNumber(3),
 SentTermType(FALSE)
{
    Command = cmd;
    DocView = NULL;
    lenCommand = cmdLen;
}

WatcherTelnetClient::~WatcherTelnetClient()
{
    if (Login){
        delete [] Login;
        Login = NULL;
    }
    if (Command){
        delete [] Command;
        Command = NULL;
    }
    WatcherSocket::~WatcherSocket();

}


// Do not edit the following lines, which are needed by ClassWizard.
#if 0
BEGIN_MESSAGE_MAP(WatcherTelnetClient, WatcherSocket)
    //{{AFX_MSG_MAP(WatcherTelnetClient)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif  // 0

/////////////////////////////////////////////////////////////////////////////
// WatcherTelnetClient member functions
void WatcherTelnetClient::OnReceive(int nErrorCode)
{
    BYTE Buffer[MAX_BUFFER_SIZE];
    int i,nRet,ret;

    
    if (nErrorCode != 0) {
        DocView->GetParent()->PostMessage(WM_CLOSE, 0,0);
        return;
    }
    nRet = Receive(Buffer, MAX_BUFFER_SIZE, 0);
    if(nRet <= 0) return;
    for(i=0;i<nRet;i++){
        ret = ProcessByte(Buffer[i]);
    }
    if (PacketNumber == 0){
        WatcherSocket::OnReceive(nErrorCode);
        return;
    }
    if(PacketNumber == 3){
        if(Login){
            Send(Login, lenLogin, 0);
        }
        PacketNumber --;
        WatcherSocket::OnReceive(nErrorCode);
        return;
    }
    if (SentTermType){
        if(PacketNumber == 1){
            if(Command){
                int ret = Send(Command, lenCommand, 0);
            }
        }
        PacketNumber --;
    }
    WatcherSocket::OnReceive(nErrorCode);
    return;
}


int WatcherTelnetClient::ProcessByte(BYTE byte)
{
    // Watch in general for Telnet Sequences and 
    // generate appropriate responses. 
    // Otherwise pass on the character to the View 
    // which will be configured for a particular console.

    if ((byte == 255)&&(CommandSequence == NO_COMMAND)){
        CommandSequence = IAC;
        return 0;
    }
    switch (CommandSequence){
    case NO_COMMAND:
        // Send the character to the document view
        ((CWatcherView *)DocView)->ProcessByte(byte);
        break;
    case IAC:
        // A Command Sequence is beginning
        CommandSequence = byte;
        break;
    case DO:
        // Options are here
        // Only one byte options allowed
        // So fall through
    case DONT:
        // Same as above;
    case WILL:
        // same
    case WONT:
        Options[OptionIndex] = byte;
        ProcessCommand(CommandSequence);
        CommandSequence=NO_COMMAND;
        OptionIndex = 0;
        break;
    case SB:
        // Might be a long list, so just go on
        // until a SE is encountered
       Options[OptionIndex]=byte;
        if (byte == SE){
            ProcessSBCommand(CommandSequence);
            OptionIndex = 0;
            CommandSequence = NO_COMMAND;
        }
        else{
            OptionIndex++;
            if (OptionIndex == MAX_BUFFER_SIZE){
                // Cant have such a long command, can we??
                OptionIndex = 0;
                CommandSequence = NO_COMMAND;
            }
        }
        break;
    default:
        // Cant recognize the command
        OptionIndex = 0;
        CommandSequence = NO_COMMAND;
        break;         
    }
    return 0;

}

void WatcherTelnetClient::ProcessCommand(BYTE cmd)
{
    BYTE sbuf[MAX_BUFFER_SIZE];

    switch(cmd){
    case DO:
        sbuf[0] = IAC;
        sbuf[1] = WONT;
        switch(Options[0]){
        case TO_NAWS:
            // terminal size is sent here.
            sbuf[1] = WILL;
            sbuf[2] = TO_NAWS;
            sbuf[3] = IAC;
            sbuf[4] = SB;
            sbuf[5] = TO_NAWS;
            sbuf[6] = 0;
            sbuf[7] = MAX_TERMINAL_WIDTH;
            sbuf[8] = 0;
            sbuf[9] = MAX_TERMINAL_HEIGHT;
            sbuf[10] = IAC;
            sbuf[11] = SE;
            Send(sbuf, 12, 0);
            break;
        case TO_TERM_TYPE:
            // will then subnegotiate the parameters. 
            sbuf[1]=WILL;
        default:
            // just negate everything you dont understand :-)
            sbuf[2] = Options[0];
            Send(sbuf,3,0);
            break;
        }
    default:
        break;
    }

}

void WatcherTelnetClient::ProcessSBCommand(BYTE cmd)
{
    BYTE sbuf[MAX_BUFFER_SIZE];
    switch(Options[0]){
    case TO_TERM_TYPE:
        sbuf[0] = IAC;
        sbuf[1] = SB;
        sbuf[2] = TO_TERM_TYPE;
        sbuf[3] = TT_IS;
        sbuf[4] = 'A';
        sbuf[5] = 'N';
        sbuf[6] = 'S';
        sbuf[7] = 'I';
        sbuf[8] = IAC;
        sbuf[9] = SE;
        Send(sbuf,10,0);
        // May have to renegotiate the terminal type. 
        // If we connect to a real Terminal concentrator
        // do we have to do all this ?? 
        SentTermType = TRUE;
        break;
    default:
        break;
    }
    return;
}

void WatcherTelnetClient::OnClose(int nErrorCode)
{
    // this was just for debug purposes. 
    // If the error code is not zero, ie we
    // had fatal errors on send and receive. 
    BOOL ret = (DocView->GetParent())->PostMessage(WM_CLOSE,0,0);
    WatcherSocket::OnClose(nErrorCode);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watchertcclient.h ===
#if !defined(AFX_WATCHERTCCLIENT_H__BD819878_DCEC_4CB6_B994_5E1B95003E1B__INCLUDED_)
#define AFX_WATCHERTCCLIENT_H__BD819878_DCEC_4CB6_B994_5E1B95003E1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WatcherTCClient.h : header file
//

#include "WatcherSocket.h"


/////////////////////////////////////////////////////////////////////////////
// WatcherTCClient command target

class WatcherTCClient : public WatcherSocket
{
// Attributes
public:

// Operations
public:
	WatcherTCClient(LPBYTE cmd=NULL, int cmdLen=0);
	virtual ~WatcherTCClient();

// Overrides
public:

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(WatcherTCClient)
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(WatcherTCClient)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
protected:
	void OnReceive(int nErrorCode);
	void OnClose(int nErrorCode);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERTCCLIENT_H__BD819878_DCEC_4CB6_B994_5E1B95003E1B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watcherdoc.cpp ===
// watcherDoc.cpp : implementation of the CWatcherDoc class
//

#include "stdafx.h"
#include "watcher.h"

#include "watcherDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc

IMPLEMENT_DYNCREATE(CWatcherDoc, CDocument)

BEGIN_MESSAGE_MAP(CWatcherDoc, CDocument)
        //{{AFX_MSG_MAP(CWatcherDoc)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc construction/destruction

CWatcherDoc::CWatcherDoc()
{
        // TODO: add one-time construction code here
    COLORREF white = WHITE;
    COLORREF black = BLACK;
    int i,j,size;
    size = MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT;
    INT_PTR nRet;
    nRet = Params.DoModal();
    if(nRet != IDOK){
        // kill document
        Params.DeleteValue = TRUE;
        return;
    }
    // TODO: add one-time construction code here
    memset(Data,0,MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT*sizeof(TCHAR));
    for(i=0;i<size;i+=MAX_TERMINAL_WIDTH){
        for(j=0;j<MAX_TERMINAL_WIDTH;j++){
            Background[i+j] = black;
            Foreground[i+j] = white;
        }
    }
    return;
}
CWatcherDoc::CWatcherDoc(CString &machine, CString &command, UINT port, 
                int tc, int lang,int hist, CString &lgnName, CString &lgnPasswd, CString &sess)
{
        COLORREF white = WHITE;
    COLORREF black = BLACK;
    int i,j,size;
    size = MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT;
        // TODO: add one-time construction code here
        Params.Machine = machine;
        Params.Command = command;
        Params.Port = port;
        Params.tcclnt = tc;
        Params.language = lang;
        Params.LoginName = lgnName;
        Params.LoginPasswd = lgnPasswd;
        Params.Session = sess;
    Params.history = hist;
    memset(Data,0,MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT*sizeof(TCHAR));
    for(i=0;i<size;i+=MAX_TERMINAL_WIDTH){
        for(j=0;j<MAX_TERMINAL_WIDTH;j++){
            Background[i+j] = black;
            Foreground[i+j] = white;
        }
    }
    return;
}

CWatcherDoc::~CWatcherDoc()
{
}

BOOL CWatcherDoc::OnNewDocument()
{
        if (!CDocument::OnNewDocument())
                return FALSE;

        // TODO: add reinitialization code here
        // (SDI documents will reuse this document)

        return TRUE;
}

BOOL CWatcherDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
        return CDocument::OnOpenDocument(lpszPathName);
}


/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc serialization

void CWatcherDoc::Serialize(CArchive& ar)
{
        if (ar.IsStoring())
        {
                // TODO: add storing code here
        }
        else
        {
                // TODO: add loading code here
        }
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc diagnostics

#ifdef _DEBUG
void CWatcherDoc::AssertValid() const
{
        CDocument::AssertValid();
}

void CWatcherDoc::Dump(CDumpContext& dc) const
{
        CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWatcherDoc commands

COLORREF * CWatcherDoc::GetBackground()
{
   return (Background);
}

COLORREF * CWatcherDoc::GetForeground()
{
    return (Foreground);
}


TCHAR * CWatcherDoc::GetData()
{
    return (Data);

}

void CWatcherDoc::SetData(int x, int y, TCHAR byte, 
                          COLORREF foreground, COLORREF background)
{
        if (x >= MAX_TERMINAL_WIDTH){
                return;
        }
        if (y>= MAX_TERMINAL_HEIGHT){
                return;
        }

    Data[x+y*MAX_TERMINAL_WIDTH] = byte;
    Foreground[x+y*MAX_TERMINAL_WIDTH] = foreground;
    Background[x+y*MAX_TERMINAL_WIDTH] = background;
    return;

}

void CWatcherDoc::SetData(int x, int y, BYTE byte, int n, 
                          COLORREF foreground, COLORREF background)
{

    int i,j;
    
    i=MAX_TERMINAL_WIDTH*y + x;
        if (i+n > MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT) {
                return;
        }
    memset(&(Data[i]),byte, n*sizeof(TCHAR));
    for(j=0;j<n;j++){
        Foreground[i+j] = foreground;
        Background[i+j] = background;
    }
    return;

}

TCHAR * CWatcherDoc::GetDataLine(int line)
{
  return (&(Data[line*MAX_TERMINAL_WIDTH]));
}

BOOL CWatcherDoc::Lock()
{
    return mutex.Lock(INFINITE);
}

BOOL CWatcherDoc::Unlock()
{
    return mutex.Unlock();
}

void CWatcherDoc::ScrollData(BYTE byte, COLORREF foreground, COLORREF background,
                             int ScrollTop, int ScrollBottom)
{
    if ((ScrollTop < 1)||(ScrollBottom > MAX_TERMINAL_HEIGHT) || (ScrollTop > ScrollBottom)) {
        // error
        return;
    }
    int number = MAX_TERMINAL_WIDTH*(ScrollBottom - ScrollTop);
    int index1 = (ScrollTop-1)*MAX_TERMINAL_WIDTH;
    int index2 = index1 + MAX_TERMINAL_WIDTH;
    if (ScrollTop < ScrollBottom) {
        memmove(&(Data[index1]),&(Data[index2]), number*sizeof(TCHAR));
        memmove(&(Foreground[index1]),&(Foreground[index2]), number*sizeof(TCHAR));
        memmove(&(Background[index1]),&(Background[index2]), number*sizeof(TCHAR));
    }
   // number -= MAX_TERMINAL_WIDTH;
    index1 = MAX_TERMINAL_WIDTH*(ScrollBottom - 1);
    memset(&(Data[index1]), byte, MAX_TERMINAL_WIDTH*sizeof(TCHAR));
    for(int j=0;j<MAX_TERMINAL_WIDTH;j++){
        Foreground[index1+j] = foreground;
        Background[index1+j] = background;
    }
    return;

}

ParameterDialog & CWatcherDoc::GetParameters()
{
 return Params;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watcherview.h ===
// watcherView.h : interface of the CWatcherView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WATCHERVIEW_H__3A351A40_9441_4451_AA2B_C5D4C392CB1B__INCLUDED_)
#define AFX_WATCHERVIEW_H__3A351A40_9441_4451_AA2B_C5D4C392CB1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "ParameterDialog.h"
#include "watcherDoc.h"
#ifndef _WATCHER_SOCKET
#define _WATCHER_SOCKET
#include "WatcherSocket.h"
#endif

#define MAX_BELL_SIZE MAX_BUFFER_SIZE*8

class CWatcherView : public CView
{
protected: // create from serialization only
    CWatcherView();
    DECLARE_DYNCREATE(CWatcherView)

// Attributes
public:
    CWatcherDoc* GetDocument();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWatcherView)
    virtual void OnInitialUpdate();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
protected:
    //}}AFX_VIRTUAL

// Implementation
public:
    void ProcessByte(BYTE byte);
    virtual ~CWatcherView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    void ProcessBellSequence(CHAR *Buffer, int len);
    LCID Locale;
    int xpos;
    int ypos;
    int CharsInLine;
    int height;
    int width;
    int position;
    int index;
    #ifdef _UNICODE
    int dbcsIndex;
    #endif
    BOOL InEscape;
    WatcherSocket *Socket;
    CClientDC *cdc;
    COLORREF background;
    COLORREF foreground;
    UINT CodePage;
    int indexBell;
    BOOL BellStarted;
    BOOL InBell;
    int ScrollTop;
    int ScrollBottom;
    BOOL seenM;
    #ifdef _UNICODE
    BYTE DBCSArray[2];
    #endif
    BYTE BellBuffer[MAX_BELL_SIZE];
    BYTE EscapeBuffer[MAX_BUFFER_SIZE];
    CRITICAL_SECTION mutex;
    int GetTextWidth(TCHAR *Data, int number);
    BOOL IsPrintable(TCHAR Char);
    BOOL FinalCharacter(CHAR c);
    BOOL IsLeadByte(BYTE byte);
    void ProcessTextAttributes(PCHAR Buffer,int length);
    void ProcessEscapeSequence(PCHAR Buffer, int length);
    void PrintCharacter(BYTE byte);
    //{{AFX_MSG(CWatcherView)
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnDestroy();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in watcherView.cpp
inline CWatcherDoc* CWatcherView::GetDocument()
   { return (CWatcherDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WATCHERVIEW_H__3A351A40_9441_4451_AA2B_C5D4C392CB1B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watcherview.cpp ===
// watcherView.cpp : implementation of the View class
//

#include "stdafx.h"
#include "watcher.h"
#include "watcherDoc.h"
#include "watcherView.h"
#include "WatcherTelnetClient.h"
#include "WatcherTCClient.h"
#include "tcsrvc.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include <wbemidl.h>
#include "wbemDCpl.h"

#define CHECKERROR(HRES) if(FAILED(hres)) {_stprintf(buffer,_T("0x%x"),hres);\
            AfxFormatString1(rString, CREATE_WMI_OBJECT_FAILURE, buffer);\
            MessageBox(NULL,(LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONEXCLAMATION);\
            delete [] messageBuffer;\
            return -1;\
            }

UINT
GenerateWMIEvent(LPTSTR messageBuffer
                )
{

    TCHAR buffer[MAX_BUFFER_SIZE];
    CString rString;
    HRESULT hres;

    hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    CHECKERROR(hres);

    // Load provision code

    IWbemDecoupledEventSink* pConnection = NULL;
    hres = CoCreateInstance(CLSID_PseudoSink, NULL, CLSCTX_SERVER, 
                            IID_IWbemDecoupledEventSink, (void**)&pConnection);
    CHECKERROR(hres);

    // Connect and announce provider name (as in MOF)

    IWbemObjectSink* pSink = NULL;
    IWbemServices* pNamespace = NULL;
    hres = pConnection->Connect(L"root\\default", L"WatcherEventProv", 
                                0, &pSink, &pNamespace);
    CHECKERROR(hres);

    BSTR XMLData = SysAllocString(messageBuffer);
    IWbemObjectTextSrc *pSrc;
    IWbemClassObject *pInstance;


    if( SUCCEEDED( hres = CoCreateInstance ( CLSID_WbemObjectTextSrc, NULL, 
                                             CLSCTX_INPROC_SERVER,                        
                                             IID_IWbemObjectTextSrc, 
                                             (void**) &pSrc ) ) ) {
        if( SUCCEEDED( hres = pSrc->CreateFromText( 0, XMLData, WMI_OBJ_TEXT_WMI_DTD_2_0, 
                                                    NULL, &pInstance) ) ) {
            pSink->Indicate(1,&pInstance);
            pInstance->Release();
        }
        else{
            _stprintf(buffer,_T("0x%x"),hres);
            AfxFormatString1(rString, CREATE_WMI_OBJECT_FAILURE, buffer);
            MessageBox(NULL,(LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONEXCLAMATION);
            pSrc->Release();
        }
    }
    else{
        _stprintf(buffer,_T("0x%x"),hres);
        AfxFormatString1(rString, CREATE_TEXT_SRC_FAILURE, buffer);
        MessageBox(NULL,(LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONEXCLAMATION);
    }
    SysFreeString(XMLData);

    // Init data

    pConnection->Disconnect();
    pSink->Release();
    pConnection->Release();
    MessageBox(NULL,messageBuffer,L"",MB_OK|MB_ICONEXCLAMATION);
    delete [] messageBuffer;
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView

IMPLEMENT_DYNCREATE(CWatcherView, CView)

BEGIN_MESSAGE_MAP(CWatcherView, CView)
    //{{AFX_MSG_MAP(CWatcherView)
    ON_WM_CHAR()
    ON_WM_DESTROY()
        ON_WM_KEYDOWN()
        //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWatcherView construction/destruction

CWatcherView::CWatcherView()
:xpos(0),
 ypos(0),
 CharsInLine(0),
 height(0),
 width(0),
 position(0),
 index(0),
#ifdef _UNICODE
 dbcsIndex(0),
#endif
 InEscape(FALSE),
 Socket(NULL),
 cdc(NULL),
 background(BLACK),
 foreground(WHITE),
 indexBell(0),
 BellStarted(FALSE),
 InBell(FALSE),
 ScrollTop(1),
 ScrollBottom(MAX_TERMINAL_HEIGHT),
 seenM(FALSE)
{
    // TODO: add construction code here
    InitializeCriticalSection(&mutex);
    return;
}

CWatcherView::~CWatcherView()
{
    DeleteCriticalSection(&mutex);
}

BOOL CWatcherView::PreCreateWindow(CREATESTRUCT& cs)
{
        // TODO: Modify the Window class or styles here by modifying
        //  the CREATESTRUCT cs

        return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView drawing

void CWatcherView::OnDraw(CDC* pDC)
{   
    TCHAR *Data,Char;
    int i,j, Height;
    int CharWidth, Position;
    int size;
    BOOL ret;
    COLORREF *Foreground;
    COLORREF *Background;

    CWatcherDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
    ret = pDoc->Lock();
    if (ret == FALSE) return;
    Data = pDoc->GetData();
    size = MAX_TERMINAL_WIDTH*MAX_TERMINAL_HEIGHT;
    Background = pDoc->GetBackground();
    Foreground = pDoc->GetForeground();
    Height = 0;
 
    for(i=0;i<size;i+=MAX_TERMINAL_WIDTH){
        Position = 0;
        for(j=0;j<MAX_TERMINAL_WIDTH;j++){
            Char = Data[i + j]; 
            cdc->SetTextColor(Foreground[i+j]);
            cdc->SetBkColor(Background[i+j]);

            if (!cdc->GetOutputCharWidth(Char, Char, &CharWidth)) {
                return;
            }

            if(Char == 0xFFFF){
                continue;
            }               
            if(IsPrintable(Char)){
                cdc->FillSolidRect(Position,Height,CharWidth,
                                   height,Background[i+j]);
                cdc->TextOut(Position, Height,&Char, 1);
                Position = Position + CharWidth;
            }
            else{
                cdc->FillSolidRect(Position,Height,width,
                                   height,Background[i+j]);
                Position = Position + width;
            }
        }
        cdc->FillSolidRect(Position,Height, MAX_TERMINAL_WIDTH*width-Position,
                           height,Background[i+j-1]);
        Height = Height + height;
    }
    ret = pDoc->Unlock();
    return;
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView initial update of the document.
void CWatcherView::OnInitialUpdate()
{
    BOOL ret;
    TCHAR Buffer[256];
    CLIENT_INFO SendInfo;
    CFont font;
    UCHAR Charset;
    LPBYTE SocketBuffer;
    CString rString;

    ParameterDialog &Params=((CWatcherDoc *)GetDocument())->GetParameters();

    if(Params.DeleteValue == TRUE){
        ret = GetParent()->PostMessage(WM_CLOSE,0,0);
        return;
    }

    CString FaceName;
    switch(Params.language + IDS_ENGLISH){
    case IDS_ENGLISH:   
        CodePage = ENGLISH;
        Charset = ANSI_CHARSET;
        FaceName = TEXT("Courier New");
        break;
    case IDS_JAPANESE:
        CodePage = JAPANESE;
        Charset = SHIFTJIS_CHARSET;
//        Locale = MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL),
//                          SORT_JAPANESE_UNICODE);
//        SetThreadLocale(Locale);
        FaceName = TEXT("MS Mincho");
        break;
    case IDS_EUROPEAN:
        CodePage = EUROPEAN;
        Charset = EASTEUROPE_CHARSET;
        FaceName = TEXT("Courier New");
        break;
    default:
        CodePage = ENGLISH;
        Charset = ANSI_CHARSET;
        FaceName = TEXT("Courier New");
        break;
    }
    
    VERIFY(font.CreateFont(16,                        // nHeight
                           0,                         // nWidth
                           0,                         // nEscapement
                           0,                         // nOrientation
                           FW_MEDIUM,                 // nWeight
                           FALSE,                     // bItalic
                           FALSE,                     // bUnderline
                           0,                         // cStrikeOut
                           Charset,                       // nCharSet
                           OUT_DEFAULT_PRECIS,        // nOutPrecision
                           CLIP_DEFAULT_PRECIS,       // nClipPrecision
                           DEFAULT_QUALITY,           // nQuality
                           FIXED_PITCH | FF_MODERN,  // nPitchAndFamily
                           FaceName));                 // lpszFacename
    cdc = new CClientDC(this);
    if(!cdc){
        ret = GetParent()->PostMessage(WM_CLOSE,0,0);
        return;
    }
    cdc->SelectObject(&font);
    CDocument *pDoc = GetDocument();
    if(pDoc){
        pDoc->SetTitle(Params.Session);
        pDoc->UpdateAllViews(NULL,0,NULL);
    }
    // Now create the socket and start the worker thread
    if(Params.tcclnt){
        // Assuming Unicode always....... (Can remove a lot of other junk)
        _tcscpy(SendInfo.device, (LPCTSTR) Params.Command);
        SendInfo.len = Params.history;
        int strsize = sizeof(CLIENT_INFO);
        SocketBuffer = new BYTE[strsize];
        SocketBuffer = (LPBYTE) ::memcpy(SocketBuffer,&SendInfo, strsize);
        Socket = new WatcherTCClient(SocketBuffer,strsize);
        if(!SocketBuffer || !Socket){
            AfxFormatString1(rString, CREATE_TC_SOCKET_FAILURE, L"");
            MessageBox((LPCTSTR) rString, L"Watcher", MB_OK|MB_ICONSTOP);
            ret = GetParent()->PostMessage(WM_CLOSE,0,0);
            return;
        }
    }
    else{
        LPBYTE LoginBuffer;
        int strsize,cmdsize; 
        CString login;
        CString comm;
        login = Params.LoginName + _TEXT("\r\n") + Params.LoginPasswd + _TEXT("\r\n");
        strsize = ::_tcslen((LPCTSTR) login);
        LoginBuffer = new BYTE [strsize*sizeof(TCHAR) + 2];
        strsize = WideCharToMultiByte(CodePage,0,(LPCTSTR)login,strsize,
                                      (LPSTR) LoginBuffer,strsize*sizeof(TCHAR),NULL,NULL);
        comm = Params.Command + _TEXT("\r\n");
        cmdsize = ::_tcslen((LPCTSTR) comm);
        SocketBuffer = new BYTE [cmdsize*sizeof(TCHAR) + 2];
        cmdsize = WideCharToMultiByte(CodePage,0,(LPCTSTR) comm,cmdsize,
                                      (LPSTR) SocketBuffer,cmdsize*sizeof(TCHAR),NULL,NULL);
        Socket = new WatcherTelnetClient(SocketBuffer,cmdsize,LoginBuffer,strsize);
        if(!Socket || !LoginBuffer || !SocketBuffer
           || !cmdsize || !strsize){
            AfxFormatString1(rString, CREATE_TELNET_SOCKET_FAILURE, L"");
            MessageBox((LPCTSTR) rString, L"Watcher",MB_OK|MB_ICONSTOP);
            ret = GetParent()->PostMessage(WM_CLOSE,0,0);
            return;
        }
    }
    ASSERT ( Socket != NULL );
    Socket->SetParentView(this);
    TEXTMETRIC TextProps;
    ret = cdc->GetOutputTextMetrics(&TextProps);    
    if(!ret){
        _stprintf(Buffer, _T("%d"),GetLastError());
        AfxFormatString1(rString, CDC_TEXT_FAILURE, Buffer);
        MessageBox((LPCTSTR) rString,L"Watcher", MB_OK|MB_ICONSTOP);
        ret = GetParent()->PostMessage(WM_CLOSE,0,0);
        return;
    }
    height = TextProps.tmHeight + 1;
    width = (TextProps.tmAveCharWidth);
    CWnd *parent = GetParent();
    if(!parent){
        // this is an  orphan child window
        return;
    }
    CRect wrect, crect;
    parent->GetClientRect(&crect);
    parent->GetWindowRect(&wrect);
    wrect.SetRect(0,
                  0,
                  wrect.Width() - crect.Width() + width*MAX_TERMINAL_WIDTH,
                  wrect.Height() - crect.Height() + height*MAX_TERMINAL_HEIGHT
                  );
    parent->MoveWindow(&wrect,TRUE);
    parent->GetClientRect(&crect);
  
    ret =Socket->Create(0,SOCK_STREAM,NULL);
    if(!ret){
        _stprintf(Buffer,_T("%d"),GetLastError());
        AfxFormatString1(rString, SOCKET_CREATION_FAILED, Buffer);
        MessageBox((LPCTSTR) rString, L"Watcher", MB_OK|MB_ICONSTOP);
        ret = parent->PostMessage(WM_CLOSE,0,0);
        return;
    }
    position = 0;
  

    ret = Socket->Connect((LPCTSTR) Params.Machine,Params.Port);
    if (!ret){
        _stprintf(Buffer,_T("%d"),GetLastError());
        AfxFormatString1(rString, SOCKET_CONNECTION_FAILED, (LPCTSTR) Buffer);
        MessageBox((LPCTSTR) rString, L"Watcher", MB_OK|MB_ICONSTOP);
        ret = parent->PostMessage(WM_CLOSE,0,0);
       return;
    }
    if(Params.tcclnt){
        ret = Socket->Send(SocketBuffer,sizeof(CLIENT_INFO),0);
    }
    CView::OnInitialUpdate();
        
    if(cdc){
        OnDraw(cdc);
    }
    return;
}

/////////////////////////////////////////////////////////////////////////////
// CWatcherView diagnostics

#ifdef _DEBUG
void CWatcherView::AssertValid() const
{
    CView::AssertValid();
}

void CWatcherView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CWatcherDoc* CWatcherView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWatcherDoc)));
    return (CWatcherDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWatcherView message handlers

void CWatcherView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
        // TODO: Add your message handler code here and/or call default
        // We will send the character across the network and that is all we do.
    int nRet;

    nRet=Socket->Send(&nChar, 1, 0);
        //CView::OnChar(nChar, nRepCnt, nFlags);
}




// REMARK - should we make this also a virtual function so that 
// if bell sequences are to be trapped, you just need to 
// extend this class ??
void CWatcherView::ProcessByte(BYTE byte)
{
    //Currently, just do a textout on the device
    // Store the character in the screen buffer
    // A boolean variable to check if we are processing an escape sequence

    EnterCriticalSection(&mutex);
  
    if(byte == 27){
        InEscape = TRUE;
        EscapeBuffer[0] = byte;
        index = 1;
        LeaveCriticalSection(&mutex);
        return;
    }
    // Escape characters are not found in the characters sent across the 
    // wire. Similarly, when we enter the Bell protocol, no bells can 
    // be found. 
    if(InEscape == TRUE){
        if(index == MAX_TERMINAL_WIDTH){
            // vague escape sequence,give up processing
            InEscape = FALSE;
            index=0;
            LeaveCriticalSection(&mutex);
            return;
        }
        EscapeBuffer[index]=byte;
        index++;
        if(FinalCharacter((CHAR) byte)){
            ProcessEscapeSequence((PCHAR)EscapeBuffer, index);
            InEscape = FALSE;
            index=0;
        }
        LeaveCriticalSection(&mutex);
        return;
    }
    if(InBell == TRUE){
        if(indexBell > MAX_BELL_SIZE){
            // What a bell sequence, I give up....
            InBell = FALSE;
            // Print all that stuff onto the screen
            for(int i = 0; i<indexBell; i++){
                PrintCharacter(BellBuffer[i]);
            }
            LeaveCriticalSection(&mutex);
            return;
        }
        // We are processing a bell seequnce.
        if(indexBell < 10){ 
            BellBuffer[indexBell] = byte;
            indexBell ++;
            if(strncmp((const char *)BellBuffer,"\007\007\007<?xml>\007",indexBell) == 0){
                if(indexBell == 9){
                    BellStarted = TRUE;
                }
            }else{
                InBell = FALSE;
                for(int i = 0; i<indexBell; i++){
                   PrintCharacter(BellBuffer[i]);
                }
            }
        }else{
            BellBuffer[indexBell] = byte;
            indexBell++;
            if(BellBuffer[indexBell-1] == 0x07){
                // ok, end reached, go on.
                InBell = FALSE;
                BellStarted = FALSE;
                ProcessBellSequence((char * )BellBuffer, indexBell);
                indexBell = 0;
            }
        }
        LeaveCriticalSection(&mutex);
        return;
    }
    if(byte == 0x07){
        // We got a bell
        // start looking for the bell protocol
        InEscape = FALSE;
        BellStarted = FALSE;
        InBell = TRUE;
        BellBuffer[0] = byte;
        indexBell = 1;
        LeaveCriticalSection(&mutex);
        return;
    }

    if (byte == '\017' && seenM) {
        seenM=FALSE;
        LeaveCriticalSection(&mutex);
        return;
    }
    seenM=FALSE;
    PrintCharacter(byte);
    LeaveCriticalSection(&mutex);
    return;
}

void CWatcherView::PrintCharacter(BYTE byte)
{

    TCHAR Char;
    int CharWidth;
    CWatcherDoc *pDoc;
    BOOL ret;
    LPTSTR DataLine;
    
    pDoc = (CWatcherDoc *)GetDocument(); 
    if(!pDoc){
        // something really fatal.
        return;
    }
    if(byte == 10){
        ypos++;
        if((ypos == MAX_TERMINAL_HEIGHT) || (ypos == ScrollBottom)){
            ret = pDoc->Lock();
            if (ypos == ScrollBottom) {
                pDoc->ScrollData(0,foreground,background,ScrollTop,ScrollBottom);
            }
            else{
                pDoc->ScrollData(0,foreground,background,1,MAX_TERMINAL_HEIGHT);
            }
            ypos = ypos -1;
            ret = pDoc->Unlock();
            OnDraw(cdc);
        }
        return;
    }

    if(byte == 13){
        xpos = 0;
        position = 0;
        return;
    }

    if (byte == 0x8) {
        // backspace character.
        ret = pDoc->Lock();
        if(xpos>0){
            xpos--;
            pDoc->SetData(xpos, ypos, 0, 
                          foreground, background);
            DataLine = pDoc->GetDataLine(ypos);
            position = 0;
            if (xpos > 0){
                position = GetTextWidth(DataLine, xpos);
            }
        }
        ret = pDoc->Unlock();
        OnDraw(cdc);
        return;
    }

    Char = byte;
#ifdef _UNICODE
    DBCSArray[dbcsIndex] = byte;
    if(dbcsIndex ==0){
        if(IsDBCSLeadByteEx(CodePage, byte)){
            dbcsIndex ++;
            return;
        }
    }
    else{
      MultiByteToWideChar(CodePage,0,(const char *)DBCSArray,2,&Char,1); 
          dbcsIndex  = 0;
    }
#endif
 

    if(xpos >= MAX_TERMINAL_WIDTH){
        //Before moving over to the next line clear to end of display 
        // using the current background
        if(cdc){
            cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width-position,
                               height,background);
        }
        xpos = 0;
        position = 0;
        ypos++;
        if((ypos == MAX_TERMINAL_HEIGHT) || (ypos == ScrollBottom)){
            ret = pDoc->Lock();
            if (ypos == ScrollBottom) {
                pDoc->ScrollData(0,foreground,background,ScrollTop,ScrollBottom);
            }
            else{
                pDoc->ScrollData(0,foreground,background,1,MAX_TERMINAL_HEIGHT);
            }
            ypos = ypos -1;
            ret = pDoc->Unlock();
            OnDraw(cdc);
        }
    }

    ret =cdc->GetOutputCharWidth(Char, Char, &CharWidth);

    if(IsPrintable(Char)){
        cdc->FillSolidRect(position,ypos*height,CharWidth,
                           height,background);
        cdc->TextOut(position,ypos*height,&Char, 1); 
        position = position + CharWidth;
        if (CharWidth >= 2*width){
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0xFFFF, foreground, background);
            xpos++;
            ret = pDoc->Unlock();
        }
    }
    else{
        cdc->FillSolidRect(position,ypos*height,width,
                           height,background);
        position = position + width;
    }
    ret = pDoc->Lock();
    pDoc->SetData(xpos, ypos, Char, 
                  foreground, background);
    xpos++;
    ret = pDoc->Unlock();

}


void CWatcherView::ProcessEscapeSequence(PCHAR Buffer, int length)
{

    ULONG charsToWrite;
    ULONG charsWritten;
    TCHAR *DataLine;
    CWatcherDoc *pDoc;
    BOOL ret;

    pDoc = (CWatcherDoc *) GetDocument();
    if(!pDoc){
        // something really wrong, queitly ignore this 
        // escape sequence
        return;
    }

    if (length == 3) {
        // One of the home cursor or clear to end of display
        if(strncmp(Buffer,"\033[r",length)==0){
            ScrollTop = 1;
            ScrollBottom = MAX_TERMINAL_HEIGHT;
            return;
        }
        if (strncmp(Buffer,"\033[H",length)==0) {
            // Home the cursor
            xpos = 0;
            ypos = 0;
            position = 0;
            return;
        }
        if(strncmp(Buffer,"\033[J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            ret = pDoc->Lock();
            if(cdc){
                cdc->FillSolidRect(0,(ypos+1)*height,MAX_TERMINAL_WIDTH*width,
                                   (MAX_TERMINAL_HEIGHT-ypos)*height,background);
                cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width - position,
                                   height,background);
            }
            pDoc->SetData(xpos, ypos, 0,
                          (MAX_TERMINAL_HEIGHT - ypos)*MAX_TERMINAL_WIDTH -xpos,
                          foreground, background);
            ret = pDoc->Unlock();
        }
        if(strncmp(Buffer,"\033[K", length) == 0){
            // clear to end of line assuming 80 X 24 size
            if(cdc){
                cdc->FillSolidRect(position,ypos*height,MAX_TERMINAL_WIDTH*width - position,
                                   height,background);
            }
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0,
                          MAX_TERMINAL_WIDTH -xpos, foreground, background);
            ret = pDoc->Unlock();
            return;
        }
        if(strncmp(Buffer,"\033[m", length) == 0){
            // clear all attributes and set Text attributes to black on white
            background = BLACK;
            foreground = WHITE;
            seenM = TRUE;
            if(cdc){
                cdc->SetBkColor(background);
                cdc->SetTextColor(foreground);
            }
            return;
        }
    }
    if (length == 4) {
        // One of the home cursor or clear to end of display
        if (strncmp(Buffer,"\033[0H",length)==0) {
            // Home the cursor
            xpos = 0;
            ypos = 0;
            position = 0;
            return;
        }

        if(strncmp(Buffer,"\033[2J",length) == 0){
            xpos = 0; 
            ypos = 0; 
            position =0;
            sprintf(Buffer,"\033[0J");
        }

        if(strncmp(Buffer,"\033[0J", length) == 0){
            // clear to end of display assuming 80 X 24 size
            if (IsWindowEnabled()){
                cdc->FillSolidRect(0,(ypos+1)*height,MAX_TERMINAL_WIDTH*width,
                                   (MAX_TERMINAL_HEIGHT-ypos)*height,background);
                cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width - position,
                                   height,background);
            }
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0,
                (MAX_TERMINAL_HEIGHT - ypos)*MAX_TERMINAL_WIDTH -xpos,
                foreground, background);
            ret = pDoc->Unlock();
        }
        if((strncmp(Buffer,"\033[0K", length) == 0) || 
           (strncmp(Buffer,"\033[2K",length) == 0)){
            // clear to end of line assuming 80 X 24 size
            if(cdc){
                cdc->FillSolidRect(position,ypos*height, MAX_TERMINAL_WIDTH*width-position,
                                   height,background);
            }
            ret = pDoc->Lock();
            pDoc->SetData(xpos, ypos, 0,
                MAX_TERMINAL_WIDTH -xpos, foreground, background);
            ret = pDoc->Unlock();
            return;
        }
        if((strncmp(Buffer,"\033[0m", length) == 0)||
           (strncmp(Buffer,"\033[m\017", length) == 0)){
            // clear all attributes and set Text attributes to black on white
            background = BLACK;
            foreground = WHITE;
            if(cdc){
                cdc->SetBkColor(background);
                cdc->SetTextColor(foreground);
            }
            return;
        }
    }
    if(Buffer[length-1] == 'm'){
        //set the text attributes
        // clear all attributes and set Text attributes to black on white
        ProcessTextAttributes((PCHAR) Buffer, length);
        return;
    }

    if(Buffer[length -1] == 'r'){
        if (sscanf(Buffer,"\033[%d;%dr", &charsToWrite, &charsWritten) == 2) {
            ScrollTop = (SHORT)charsToWrite;
            ScrollBottom = (SHORT)charsWritten;
        }
        return;
    }

    if(Buffer[length -1] == 'H'){
        if (sscanf(Buffer,"\033[%d;%dH", &charsToWrite, &charsWritten) == 2) {
            ypos = (SHORT)(charsToWrite -1);
            xpos = (SHORT)(charsWritten -1);
            ret = pDoc->Lock();
            DataLine = pDoc->GetDataLine(ypos);
            if (xpos >0){
                position = GetTextWidth(DataLine, xpos);
            }
            else{
                position = 0;
            }
            pDoc->Unlock();
        }
    }
    return;
}

void CWatcherView::ProcessTextAttributes(PCHAR Buffer, int length)
{

    PCHAR CurrLoc = Buffer;
    ULONG Attribute;
    PCHAR pTemp;
    COLORREF temp;
 
    while(*CurrLoc != 'm'){
        if((*CurrLoc < '0') || (*CurrLoc >'9' )){
            CurrLoc ++;
        }else{
            if (sscanf(CurrLoc,"%d", &Attribute) != 1) {
                return;
            }
            switch(Attribute){
            case 7:
                // switch the colors. This will make this code 
                // work for applications (written in an Unix world
                // for real VT100. )
                temp = foreground;
                foreground = background;
                background = temp;
                break;
            case 37:
                foreground  = WHITE;
                break;
            case 47:
                background = WHITE;
                break;
            case 34:
                foreground  = BLUE;
                break;
            case 44:
                background  = BLUE; 
                break;
            case 30:
                foreground = BLACK;
                break;
            case 40:
                background = BLACK;
            case 33:
                foreground = YELLOW;
                break;
            case 43:
                background = YELLOW;
            case 31:
                foreground = RED;
                break;
            case 41:
                background = RED;
            default:
                break;
            }
            pTemp = strchr(CurrLoc, ';');
            if(pTemp == NULL){
                pTemp = strchr(CurrLoc, 'm');
            }
            if(pTemp == NULL) {
                break;
            }
            CurrLoc = pTemp;

        }
    }
    cdc->SetBkColor(background);
    cdc->SetTextColor(foreground);
    return;
}

BOOL CWatcherView::FinalCharacter(CHAR c)
{

    CHAR FinalCharacters[]="mHJKr";

    if(strchr(FinalCharacters,c)){
        return TRUE;
    }
    return FALSE;

}

BOOL CWatcherView::IsPrintable(TCHAR Char)
{
        if (Char > 32) return TRUE;
        return FALSE;
}

void CWatcherView::OnDestroy() 
{
        if(Socket){
            delete Socket;
        }
        if(cdc){
            delete cdc;
        }
        CView::OnDestroy();

        // TODO: Add your message handler code here
        
}

int CWatcherView::GetTextWidth(TCHAR *Data, int number)
{
    int textWidth=0;
    int CharWidth;

    for(int i=0;i<number;i++){
        // For variable width characters like Japanese, we need to 
        // blank out the next character. 
        if(Data[i] == 0xFFFF){
            continue;
        }
        if(IsPrintable(Data[i])){
            if (cdc->GetOutputCharWidth(Data[i], Data[i], &CharWidth)) {
                textWidth += CharWidth;
            }
        }
        else{
            textWidth += width;
        }
    }
    return textWidth;               

}
// REMARK - Make this a virtual function so that 
// later writers can just extend this class and work 
// with the same framework. Now, the bell sequence 
// processing consists of nothing, but later can be 
// expanded to include WMI kind of processing.
void CWatcherView::ProcessBellSequence(CHAR *Buffer, int len)
{
    // Set this as the active window.
    // We will probably bring up a dialog box with
    // the bell parameters.

    WCHAR *messageBuffer;
    CHAR tempBuffer[MAX_BELL_SIZE + 1];
    int index =0;

    memset(tempBuffer,0, MAX_BELL_SIZE + 1);
    memcpy(tempBuffer, Buffer+16, len-24);
    tempBuffer[len-24] = (CHAR) 0;

    CWnd *parent = GetParent();
    CWnd *prev = parent->GetParent();
    if (prev && prev->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd))){
        ((CMDIFrameWnd *) prev)->MDIActivate(parent);
        ((CMDIFrameWnd *) prev)->MDIRestore(parent);
    }
    else{
        ((CMDIChildWnd *)parent)->MDIActivate();
        ((CMDIChildWnd *)parent)->MDIRestore();
    }
    int convlen;
    messageBuffer = new WCHAR [MAX_BELL_SIZE + 1];
    messageBuffer[0] = 0;
    convlen = MultiByteToWideChar(CP_ACP,
                                  0,
                                  tempBuffer,
                                  -1,
                                  messageBuffer,
                                  MAX_BELL_SIZE);
    messageBuffer[convlen] = (WCHAR) 0;
    CWinThread *th = ::AfxBeginThread(AFX_THREADPROC (GenerateWMIEvent),
                                      messageBuffer
                                      );
    return;
}

void CWatcherView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
        // TODO: Add your message handler code here and/or call default
    switch(nChar) { 
    case VK_LEFT: 
        Socket->Send("\033OC",sizeof("\033OC"),0);
        break;
    case VK_RIGHT: 
        Socket->Send("\033OD",sizeof("\033OD"),0);
        break;
    case VK_UP: 
        Socket->Send("\033OA",sizeof("\033OA"),0);
        break;
    case VK_DOWN: 
        Socket->Send("\033OB",sizeof("\033OB"),0);
        break;
    case VK_F1: 
        Socket->Send("\033""1",sizeof("\033""1"),0);
        break;
    case VK_F2: 
        Socket->Send("\033""2",sizeof("\033""2"),0);
        break;
    case VK_F3: 
        Socket->Send("\033""3",sizeof("\033""3"),0);
        break;
    case VK_F4: 
        Socket->Send("\033""4",sizeof("\033""4"),0);
        break;      
    case VK_F12: 
        Socket->Send("\033@",sizeof("\033@"),0);
        break;      
    default: 
        break; 
    } 
    CView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\inc\cardbus.h ===
/*++

Module Name:

    cardbus.h

Abstract:

    This header contains generic cardbus definitions.

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _CARDBUS_
#define _CARDBUS_

//
// Cardbus register definitions
//

typedef struct _CARDBUS_SOCKET_REGS {
    ULONG Event;
    ULONG Mask;
    ULONG PresentState;
    ULONG ForceEvent;
    ULONG Control;
} CARDBUS_SOCKET_REGS, *PCARDBUS_SOCKET_REGS;    

//
// Socket Event Register bits
//

#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK               (SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//
// Socket Mask Register bits
//

#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//
// Socket Present State Register bits
//

#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK          0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK              0x00000030L
#define CARDTYPE(dw)       ((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK    (SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
                SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK     (SKTSTATE_5VSOCKET | \
                SKTSTATE_3VSOCKET | \
                SKTSTATE_XVSOCKET | \
                SKTSTATE_YVSOCKET)

//
//Socket Froce Register bits
//

#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET               0x10000000L
#define SKTFORCE_3VSOCKET               0x20000000L
#define SKTFORCE_XVSOCKET               0x40000000L
#define SKTFORCE_YVSOCKET               0x80000000L

//
// Power Control Register bits
//

#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//
// Misc. CardBus Constants
//

#define EXCAREG_OFFSET                  0x0800

//
// PCI config space constants
//
#define CARDBUS_LEGACY_MODE_BASE_ADDR   0x44

#define CARDBUS_BRIDGE_CONTROL_RESET    0x40

#endif  // _CARDBUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\headless\watcher\watchertelnetclient.h ===
#if !defined(AFX_WATCHERTELNETCLIEN_H__5CB77E83_A530_4398_B134_353F5F0C84E5__INCLUDED_)
#define AFX_WatcherTelnetClient_H__5CB77E83_A530_4398_B134_353F5F0C84E5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WatcherTelnetClient.h : header file
//
#include "WatcherSocket.h"

/////////////////////////////////////////////////////////////////////////////
// WatcherTelnetClient command target

/*
 * Definitions for the TELNET protocol.
 */
#define NO_COMMAND 0               /* No command processing */
#define IAC        255             /* interpret as command: */
#define DONT       254             /* you are not to use option */
#define DO         253             /* please, you use option */
#define WONT       252             /* I won't use option */
#define WILL       251             /* I will use option */
#define SB         250             /* interpret as subnegotiation */
#define GA         249             /* you may reverse the line */
#define EL         248             /* erase the current line */
#define EC         247             /* erase the current character */
#define AYT        246             /* are you there */
#define AO         245             /* abort output--but let prog finish */
#define IP         244             /* interrupt process--permanently */
#define BREAK      243             /* break */
#define DM         242             /* data mark--for connect. cleaning */
#define NOP        241             /* nop */
#define SE         240             /* end sub negotiation */

#define SYNCH   242             /* for telfunc calls */
/* Telnet options - Names have been truncated to be unique in 7 chars */


#define TO_BINARY       0       /* 8-bit data path */
#define TO_ECHO         1       /* echo */
#define TO_RCP          2       /* prepare to reconnect */
#define TO_SGA          3       /* suppress go ahead */
#define TO_NAMS         4       /* approximate message size */
#define TO_STATUS       5       /* give status */
#define TO_TM           6       /* timing mark */
#define TO_RCTE         7       /* remote controlled transmission and echo */
#define TO_NL           8       /* negotiate about output line width */
#define TO_NP           9       /* negotiate about output page size */
#define TO_NCRD         10      /* negotiate about CR disposition */
#define TO_NHTS         11      /* negotiate about horizontal tabstops */
#define TO_NHTD         12      /* negotiate about horizontal tab disposition */
#define TO_NFFD         13      /* negotiate about formfeed disposition */
#define TO_NVTS         14      /* negotiate about vertical tab stops */
#define TO_NVTD         15      /* negotiate about vertical tab disposition */
#define TO_NLFD         16      /* negotiate about output LF disposition */
#define TO_XASCII       17      /* extended ascic character set */
#define TO_LOGOUT       18      /* force logout */
#define TO_BM           19      /* byte macro */
#define TO_DET          20      /* data entry terminal */
#define TO_SUPDUP       21      /* supdup protocol */
#define TO_TERM_TYPE    24      /* terminal type */
#define TO_NAWS         31      // Negotiate About Window Size
#define TO_TOGGLE_FLOW_CONTROL 33  /* Enable & disable Flow control */
#define TO_ENVIRON      36      /* Environment Option */
#define TO_NEW_ENVIRON  39      /* New Environment Option */
#define TO_EXOPL        255     /* extended-options-list */

#define TO_AUTH         37      
#define TT_SEND         1
#define TT_IS           0

class WatcherTelnetClient : public WatcherSocket
{
// Attributes
public:

public:
    WatcherTelnetClient(LPBYTE cmd = NULL, int cmdLen=0, LPBYTE lgn = NULL, int lngLen=0 );
    virtual ~WatcherTelnetClient();

// Overrides
public:
	
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(WatcherTelnetClient)
    //}}AFX_VIRTUAL
    void OnReceive(int nErrorCode);
	void OnClose(int nErrorCode);
    // Generated message map functions
    //{{AFX_MSG(WatcherTelnetClient)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

// Implementation
protected:
	BYTE CommandSequence;
	int lenLogin;
	LPBYTE Login;
	int OptionIndex;
	int PacketNumber;
	BOOL SentTermType;
	BYTE Options[MAX_BUFFER_SIZE];

	void ProcessSBCommand(BYTE cmd);
	int ProcessByte(BYTE Char);
    void ProcessCommand(BYTE cmd);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WatcherTelnetClient_H__5CB77E83_A530_4398_B134_353F5F0C84E5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\inc\kdcom.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.h

Abstract:

    This module contains the header file for a very simple com port package.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 19-Jul-1991
        Moved into HAL
--*/

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8
#define COM3_PORT   0x03e8
#define COM4_PORT   0x02e8

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_56000    56000
#define BD_57600    57600
#define BD_115200   115200

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

#define MSG_DEBUG_9600          "Switching debugger to 9600 baud\n"

//
// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
//
#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//
#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//
#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//
#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//
#define SERIAL_MSR_DCD      0x80

#define SERIAL_LSR_NOT_PRESENT  0xff

typedef struct _CPPORT {
    PUCHAR  Address;
    ULONG  Baud;
    USHORT  Flags;
    TIME_FIELDS     CarrierLostTime;
//    ULONG   LockVar;
//    KSPIN_LOCK Lock;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls
#define PORT_SAVED          0x0004      // port is in saved state
#define PORT_NOCDLTIME      0x0010      // 'Carrier detect lost' time not set
#define PORT_DISBAUD        0x0020      // Display baud rate abbrv
#define PORT_SENDINGSTRING  0x0040      // Sending modem string (don't recurse)
#define PORT_MDM_CD         0x0080      // CD while in modem control mode

VOID
CpInitialize (
    PCPPORT  Port,
    PUCHAR  Address,
    ULONG Rate
    );

VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG  Rate
    );

USHORT
CpQueryBaud (
    PCPPORT  Port
    );

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    );

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR  Byte,
    BOOLEAN WaitForData
    );

VOID
CpLockPort (
    PCPPORT Port
    );

VOID
CpUnlockPort (
    PCPPORT Port
    );

VOID
CpStallExecution (
    VOID
    );

BOOLEAN
CpDoesPortExist(
    IN PUCHAR Address
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\inc\ntdlltrc.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    NtdllTracer.h

Abstract:

	This file contains structures and functions definitions used in Ntdll 
	events tracing


--*/

#ifndef _NTDLL_WMI_TRACE_
#define _NTDLL_WMI_TRACE_

#define MEMORY_FROM_LOOKASIDE					1		//Activity from LookAside
#define MEMORY_FROM_LOWFRAG						2		//Activity from Low Frag Heap
#define MEMORY_FROM_MAINPATH					3		//Activity from Main Code Path
#define MEMORY_FROM_SLOWPATH                    4       //Activity from Slow Code Path

#define LOG_LOOKASIDE                           0x00000001       //Bit for LookAside trace

#define FAILED_TLSINDEX			-1
#define MAX_PID                 10

#ifndef UserSharedData
#define UserSharedData USER_SHARED_DATA
#endif

#define IsCritSecLogging(CriticalSection) ((USER_SHARED_DATA->TraceLogging & ENABLECRITSECTRACE) \
                         && CriticalSection != &UMLogCritSect \
                         && CriticalSection != &PMCritSect \
                         && CriticalSection != &NtdllTraceHandles->CriticalSection)


extern 
ULONG GlobalCounter;

#define IsHeapLogging(HeapHandle) (USER_SHARED_DATA->TraceLogging & ENABLEHEAPTRACE && \
                                  (WmipProcessHeap || !GlobalCounter ) &&  \
                                   WmipProcessHeap != HeapHandle)

typedef struct _THREAD_LOCAL_DATA THREAD_LOCAL_DATA, *PTHREAD_LOCAL_DATA, **PPTHREAD_LOCAL_DATA;

typedef struct _THREAD_LOCAL_DATA {

	PTHREAD_LOCAL_DATA  FLink;					//Forward Link
	PTHREAD_LOCAL_DATA  BLink;					//Backward Link
	PWMI_BUFFER_HEADER  pBuffer;				//Pointer to thread buffer info.
    LONG                ReferenceCount;

} THREAD_LOCAL_DATA, *PTHREAD_LOCAL_DATA, **PPTHREAD_LOCAL_DATA;

extern 
PVOID WmipProcessHeap;

__int64
WmipGetCycleCount();

void 
ReleaseBufferLocation(PTHREAD_LOCAL_DATA pThreadLocalData);

NTSTATUS 
AcquireBufferLocation(PVOID *pEvent, PPTHREAD_LOCAL_DATA pThreadLocalData, PUSHORT ReqSize);

typedef struct _NTDLL_EVENT_COMMON {

  PVOID Handle;		        //Handle of Heap

}NTDLL_EVENT_COMMON, *PNTDLL_EVENT_COMMON;


typedef struct _NTDLL_EVENT_HANDLES {

	RTL_CRITICAL_SECTION	CriticalSection;			//Critical section
	ULONG					dwTlsIndex;					//TLS Index
	TRACEHANDLE				hRegistrationHandle;		//Registration Handle used for Unregistration.
	TRACEHANDLE				hLoggerHandle;				//Handle to Trace Logger
	PTHREAD_LOCAL_DATA		pThreadListHead;	        //Link List that contains all threads info invovled in tracing.

}NTDLL_EVENT_HANDLES, *PNTDLL_EVENT_HANDLES, **PPNTDLL_EVENT_HANDLES;

extern LONG TraceLevel;
extern PNTDLL_EVENT_HANDLES NtdllTraceHandles;
extern RTL_CRITICAL_SECTION UMLogCritSect;
extern RTL_CRITICAL_SECTION PMCritSect;
extern RTL_CRITICAL_SECTION LoaderLock;

#endif //_NTDLL_WMI_TRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\inc\kdlog.h ===
/*++

Module Name:

    kdlog.h

Abstract:

    This header contains definitions for components which help diagnose
    problems in the kd client debugger code.

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _KDLOG_
#define _KDLOG_


typedef struct _KD_DBG_LOG_CONTEXT {
    USHORT Type;
    USHORT Version;
    ULONG EntryLength;
    BOOLEAN Enabled;
    ULONG Index;
    ULONG LastIndex;
    ULONG Count;
    ULONG TotalLogged;
    PVOID LogData;
} KD_DBG_LOG_CONTEXT, *PKD_DBG_LOG_CONTEXT;   


#endif  // _KDLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\inc\svcsp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    svcsp.h

Abstract:

    This file contains definitions used by service dlls that
    run inside of services.exe.

Author:

    Jonathan Schwartz (jschwart)  20-Sep-2000

--*/

#ifndef _SVCSP_
#define _SVCSP_

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>                    // RPC_IF_HANDLE

//
// Service DLLs loaded into services.exe all export the same main
// entry point.  SVCS_ENTRY_POINT defines that name.
//
// Note that SVCS_ENTRY_POINT_STRING is always ANSI, because that's
// what GetProcAddress takes.
//

#define SVCS_ENTRY_POINT        ServiceEntry
#define SVCS_ENTRY_POINT_STRING "ServiceEntry"

//
// Name for the common RPC pipe shared by all the RPC servers in services.exe.
// Note:  Because version 1.0 of WinNt had seperate names for each server's
// pipe, the client side names have remained the same.  Mapping to the new
// name is handled by the named pipe file system.
//

#define SVCS_RPC_PIPE           L"ntsvcs"

//
// Name for the common LRPC protocol and port available in services.exe.
//

#define SVCS_LRPC_PROTOCOL      L"ncalrpc"
#define SVCS_LRPC_PORT          L"ntsvcs"


//
// Start and stop RPC server entry point prototype.
//

typedef
NTSTATUS
(*PSVCS_START_RPC_SERVER) (
    IN LPTSTR InterfaceName,
    IN RPC_IF_HANDLE InterfaceSpecification
    );

typedef
NTSTATUS
(*PSVCS_STOP_RPC_SERVER) (
    IN RPC_IF_HANDLE InterfaceSpecification
    );



//
// Structure containing "global" data for the various DLLs.
//

typedef struct _SVCS_GLOBAL_DATA
{
    //
    // NT well-known SIDs
    //

    PSID NullSid;                   // No members SID
    PSID WorldSid;                  // All users SID
    PSID LocalSid;                  // NT local users SID
    PSID NetworkSid;                // NT remote users SID
    PSID LocalSystemSid;            // NT system processes SID
    PSID LocalServiceSid;           // NT LocalService SID
    PSID NetworkServiceSid;         // NT NetworkService SID
    PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
    PSID AuthenticatedUserSid;      // NT authenticated users SID

    //
    // Well Known Aliases.
    //
    // These are aliases that are relative to the built-in domain.
    //

    PSID AliasAdminsSid;            // Administrator Sid
    PSID AliasUsersSid;             // User Sid
    PSID AliasGuestsSid;            // Guest Sid
    PSID AliasPowerUsersSid;        // Power User Sid
    PSID AliasAccountOpsSid;        // Account Operator Sid
    PSID AliasSystemOpsSid;         // System Operator Sid
    PSID AliasPrintOpsSid;          // Print Operator Sid
    PSID AliasBackupOpsSid;         // Backup Operator Sid

    //
    // Entry points provided by services.exe
    //

    PSVCS_START_RPC_SERVER  StartRpcServer;
    PSVCS_STOP_RPC_SERVER   StopRpcServer;
    LPWSTR                  SvcsRpcPipeName;

    //
    // Miscellaneous useful data
    //
    BOOL  fSetupInProgress;         // TRUE if setup is in progress, FALSE otherwise
}
SVCS_GLOBAL_DATA, *PSVCS_GLOBAL_DATA;


//
// Service DLL entrypoint prototype
//

typedef
VOID
(*PSVCS_SERVICE_DLL_ENTRY) (
    IN DWORD argc,
    IN LPTSTR argv[],
    IN PSVCS_GLOBAL_DATA pGlobalData,
    IN HANDLE SvcReferenceHandle
    );

#endif  // ndef _SVCSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

/*                                                                         */
/* This copy of md5.h modified and adapted for my purposes, tommcg 6/28/96 */
/*                                                                         */

#pragma warning( disable: 4201 4204 )


#ifndef VOID
    typedef void VOID;
#endif
#ifndef UCHAR
    typedef unsigned char UCHAR;
#endif
#ifndef ULONG
    typedef unsigned long ULONG;
#endif
#ifndef ULONGLONG
    typedef unsigned __int64 ULONGLONG;
#endif
#ifndef PCVOID
    typedef const void * PCVOID;
#endif
#ifndef IN
    #define IN
#endif
#ifndef OUT
    #define OUT
#endif


typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        UCHAR Byte  [ 16 ];
        };
    };

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }

VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    );

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // pointer to 64 bytes of data
    );

VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    );

VOID
ComputeCompleteMD5(                     // complete MD5 in one call
    IN  PCVOID    DataBuffer,           // buffer to compute MD5 over
    IN  ULONGLONG DataLength,           // bytes of data in buffer
    OUT PMD5_HASH HashValue             // return finalized MD5 value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\misc.h ===
//
//  misc.h
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCH_MISC_H_
#define _PATCH_MISC_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma intrinsic( memcpy, memset, memcmp, strcpy, strcmp, strlen, strcat, abs, _rotl )

#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#endif

#ifndef MIN
#define MIN( a, b ) (((a)<(b))?(a):(b))
#endif

#ifndef bool
typedef int bool;
#endif

#ifndef byte
typedef unsigned char byte;
#endif

#define SUBALLOCATOR_ALIGNMENT 8

#define MINIMUM_VM_ALLOCATION 0x10000


#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

#include <stdlib.h>
#include <stdio.h>

#endif


#ifndef ASSERT

BOOL
Assert(
    LPCSTR szText,
    LPCSTR szFile,
    DWORD  dwLine
    );

#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
#define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))
#else
#define ASSERT( a )
#endif
#endif // ASSERT


VOID
InitializeCrc32Table(
    VOID
    );

ULONG
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    );

BOOL
SafeCompleteCrc32(
    IN  PVOID  Buffer,
    IN  ULONG  ByteCount,
    OUT PULONG CrcValue
    );

BOOL
SafeCompleteMD5(
    IN  PVOID     Buffer,
    IN  ULONG     ByteCount,
    OUT PMD5_HASH MD5Value
    );

BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT ULONG  *FileSize,
    OUT PVOID  *MapBase
    );

BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT ULONG  *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

BOOL
MyCreateMappedFileA(
    IN  LPCSTR  FileName,
    IN  ULONG   InitialSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

BOOL
MyCreateMappedFileByHandle(
    IN  HANDLE FileHandle,
    IN  ULONG  InitialSize,
    OUT PVOID *MapBase
    );

VOID
MyUnmapCreatedMappedFile(
    IN HANDLE    FileHandle,
    IN PVOID     MapBase,
    IN ULONG     FileSize,
    IN PFILETIME FileTime OPTIONAL
    );

PVOID
__fastcall
MyVirtualAlloc(
    ULONG Size
    );

VOID
__fastcall
MyVirtualFree(
    PVOID Allocation
    );

HANDLE
CreateSubAllocator(
    IN ULONG InitialCommitSize,
    IN ULONG GrowthCommitSize
    );

PVOID
__fastcall
SubAllocate(
    IN HANDLE hAllocator,
    IN ULONG  Size
    );

VOID
DestroySubAllocator(
    IN HANDLE hAllocator
    );

LPSTR
__fastcall
MySubAllocStrDup(
    IN HANDLE SubAllocator,
    IN LPCSTR String
    );

LPSTR
MySubAllocStrDupAndCat(
    IN HANDLE SubAllocator,
    IN LPCSTR String1,
    IN LPCSTR String2,
    IN CHAR   Separator
    );

PVOID
MyHeapAllocZero(
    IN ULONG Size
    );

VOID
MyHeapFree(
    IN PVOID Allocation
    );

ULONG
HashName(
    IN LPCSTR Name
    );

ULONG
HashNameCaseInsensitive(
    IN LPCSTR Name
    );

VOID
MyLowercase(
    IN OUT LPSTR String
    );

VOID
DwordToHexString(
    IN  DWORD Value,
    OUT LPSTR Buffer    // writes exactly 9 bytes including terminator
    );

BOOL
HashToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer        // must be at least 33 bytes
    );

//
//  FILETIME units are 100ns intervals from 01/01/1601.
//
//  ULONG units are seconds from 01/01/1970.
//
//  There are 10,000,000 FILETIME units in one second.
//
//  There are 11,644,473,600 seconds from 01/01/1601 to 01/01/1970.
//

#define FILETIME_UNITS_PER_SECOND      10000000
#define FILETIME_TO_ULONG_OFFSET    11644473600

VOID
__inline
UlongTimeToFileTime(
    IN  ULONG     UlongTime,
    OUT PFILETIME FileTime
    )
    {
    *(UNALIGNED DWORDLONG *)FileTime = ( UlongTime + FILETIME_TO_ULONG_OFFSET ) * FILETIME_UNITS_PER_SECOND;
    }

ULONG
__inline
FileTimeToUlongTime(
    IN PFILETIME FileTime
    )
    {
    return (ULONG)(( *(UNALIGNED DWORDLONG *)FileTime / FILETIME_UNITS_PER_SECOND ) - FILETIME_TO_ULONG_OFFSET );
    }


#ifdef __cplusplus
}
#endif

#endif // _PATCH_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\misc.c ===
#include <precomp.h>

//
//  misc.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 12/97
//
//  Copyright (C) Microsoft, 1997-1998.
//
//  MICROSOFT CONFIDENTIAL
//

typedef struct _SUBALLOCATOR SUBALLOCATOR, *PSUBALLOCATOR;

struct _SUBALLOCATOR {
    PVOID  VirtualListTerminator;
    PVOID *VirtualList;
    PCHAR  NextAvailable;
    PCHAR  LastAvailable;
    ULONG  GrowSize;
    };


const ULONG gCrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

BOOL
Assert(
    LPCSTR szText,
    LPCSTR szFile,
    DWORD  dwLine
    )
    {
    CHAR Buffer[ 512 ];
    wsprintf( Buffer, "ASSERT( %s ) FAILED, %s (%d)\n", szText, szFile, dwLine );
    OutputDebugString( Buffer );
    DebugBreak();
    return FALSE;
    }

#endif


#ifdef DONTCOMPILE  // Not currently being used

VOID
InitializeCrc32Table(
    VOID
    )
    {
    ULONG i, j, Value;

    for ( i = 0; i < 256; i++ ) {
        for ( Value = i, j = 8; j > 0; j-- ) {
            if ( Value & 1 ) {
                Value = ( Value >> 1 ) ^ 0xEDB88320;
                }
            else {
                Value >>= 1;
                }
            }
        gCrcTable32[ i ] = Value;
        }
    }

#endif // DONTCOMPILE


#ifdef _M_IX86
#pragma warning( disable: 4035 )    // no return value
#endif

ULONG
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    )
    {

#ifdef DONTCOMPILE  // Not currently being used

    //
    //  First determine if the CRC table has been initialized by checking
    //  that the last value in it is nonzero.  Believe it or not, this is
    //  thread safe because two threads could initialize the table at the
    //  same time with no harm, and the last value to be initialized in the
    //  table is used to determine if the table has been initialized.  On
    //  all hardware platforms (including Alpha) it is safe to assume that
    //  an aligned DWORD written to memory by one processor will be seen by
    //  the other processor(s) as either containing the value previously
    //  contained in that memory location, or the new written value, but not
    //  some weird unpredictable value.
    //

    if ( gCrcTable32[ 255 ] == 0 ) {
        InitializeCrc32Table();
        }

#endif // DONTCOMPILE

#ifdef _M_IX86

    __asm {

            mov     ecx, ByteCount          ; number of bytes in buffer
            xor     ebx, ebx                ; ebx (bl) will be our table index
            mov     esi, Buffer             ; buffer pointer
            test    ecx, ecx                ; test for zero length buffer
            mov     eax, InitialCrc         ; CRC-32 value

            jnz     short loopentry         ; if non-zero buffer, start loop
            jmp     short exitfunc          ; else exit (crc already in eax)

looptop:    shr     eax, 8                  ; (crc>>8)                      (U1)
            mov     edx, gCrcTable32[ebx*4] ; fetch Table[ index ]          (V1)

            xor     eax, edx                ; crc=(crc>>8)^Table[index]     (U1)
loopentry:  mov     bl, [esi]               ; fetch next *buffer            (V1)

            inc     esi                     ; buffer++                      (U1)
            xor     bl, al                  ; index=(byte)crc^*buffer       (V1)

            dec     ecx                     ; adjust counter                (U1)
            jnz     short looptop           ; loop while nBytes             (V1)

            shr     eax, 8                  ; remaining math on last byte
            xor     eax, gCrcTable32[ebx*4] ; eax returns new crc value

exitfunc:

        }

#else // ! _M_IX86

    {
    ULONG  Value = InitialCrc;
    ULONG  Count = ByteCount;
    PUCHAR p     = Buffer;

    while ( Count-- ) {
        Value = ( Value >> 8 ) ^ gCrcTable32[ (UCHAR)( *p++ ^ Value ) ];
        }

    return Value;
    }

#endif // ! _M_IX86
    }

#ifdef _M_IX86
#pragma warning( default: 4035 )    // no return value
#endif


BOOL
SafeCompleteCrc32(
    IN  PVOID  Buffer,
    IN  ULONG  ByteCount,
    OUT PULONG CrcValue
    )
    {
    BOOL Success = TRUE;

    __try {
        *CrcValue = Crc32( 0xFFFFFFFF, Buffer, ByteCount ) ^ 0xFFFFFFFF;
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
SafeCompleteMD5(
    IN  PVOID     Buffer,
    IN  ULONG     ByteCount,
    OUT PMD5_HASH MD5Value
    )
    {
    BOOL Success = TRUE;

    __try {
        ComputeCompleteMD5( Buffer, ByteCount, MD5Value );
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT ULONG  *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyMapViewOfFileByHandle(
                      InternalFileHandle,
                      FileSize,
                      MapBase
                      );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT ULONG  *FileSize,
    OUT PVOID  *MapBase
    )
    {
    ULONG  InternalFileSize;
    ULONG  InternalFileSizeHigh;
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalFileSize = GetFileSize( FileHandle, &InternalFileSizeHigh );

    if ( InternalFileSizeHigh != 0 ) {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
        }

    if ( InternalFileSize == 0 ) {
        *MapBase  = NULL;
        *FileSize = 0;
        return TRUE;
        }

    if ( InternalFileSize != 0xFFFFFFFF ) {

        InternalMapHandle = CreateFileMapping(
                                FileHandle,
                                NULL,
                                PAGE_WRITECOPY,
                                0,
                                0,
                                NULL
                                );

        if ( InternalMapHandle != NULL ) {

            InternalMapBase = MapViewOfFile(
                                  InternalMapHandle,
                                  FILE_MAP_COPY,
                                  0,
                                  0,
                                  0
                                  );

            CloseHandle( InternalMapHandle );

            if ( InternalMapBase != NULL ) {

                *MapBase  = InternalMapBase;
                *FileSize = InternalFileSize;

                return TRUE;
                }
            }
        }

    return FALSE;
    }


BOOL
MyCreateMappedFileA(
    IN  LPCSTR  FileName,
    IN  ULONG   InitialSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyCreateMappedFileByHandle(
                       InternalFileHandle,
                       InitialSize,
                       MapBase
                       );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


BOOL
MyCreateMappedFileByHandle(
    IN  HANDLE FileHandle,
    IN  ULONG  InitialSize,
    OUT PVOID *MapBase
    )
    {
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalMapHandle = CreateFileMapping(
                            FileHandle,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            InitialSize,
                            NULL
                            );

    if ( InternalMapHandle != NULL ) {

        InternalMapBase = MapViewOfFile(
                              InternalMapHandle,
                              FILE_MAP_WRITE,
                              0,
                              0,
                              0
                              );

        CloseHandle( InternalMapHandle );

        if ( InternalMapBase != NULL ) {

            *MapBase = InternalMapBase;

            return TRUE;
            }
        }

    return FALSE;
    }


VOID
MyUnmapCreatedMappedFile(
    IN HANDLE    FileHandle,
    IN PVOID     MapBase,
    IN ULONG     FileSize,
    IN PFILETIME FileTime OPTIONAL
    )
    {
    FlushViewOfFile( MapBase, 0 );
    UnmapViewOfFile( MapBase );
    SetFilePointer( FileHandle, (LONG) FileSize, NULL, FILE_BEGIN );
    SetEndOfFile( FileHandle );
    SetFileTime( FileHandle, NULL, NULL, FileTime );
    }


PVOID
__fastcall
MyVirtualAlloc(
    ULONG Size
    )
    {
    return VirtualAlloc( NULL, Size, MEM_COMMIT, PAGE_READWRITE );
    }


VOID
__fastcall
MyVirtualFree(
    PVOID Allocation
    )
    {
    VirtualFree( Allocation, 0, MEM_RELEASE );
    }


HANDLE
CreateSubAllocator(
    IN ULONG InitialCommitSize,
    IN ULONG GrowthCommitSize
    )
    {
    PSUBALLOCATOR SubAllocator;
    ULONG InitialSize;
    ULONG GrowthSize;

    InitialSize = ROUNDUP2( InitialCommitSize, MINIMUM_VM_ALLOCATION );
    GrowthSize  = ROUNDUP2( GrowthCommitSize,  MINIMUM_VM_ALLOCATION );

    SubAllocator = MyVirtualAlloc( InitialSize );

    //
    //  If can't allocate entire initial size, back off to minimum size.
    //  Very large initial requests sometimes cannot be allocated simply
    //  because there is not enough contiguous address space.
    //

    if (( SubAllocator == NULL ) && ( InitialSize > GrowthSize )) {
        InitialSize  = GrowthSize;
        SubAllocator = MyVirtualAlloc( InitialSize );
        }

    if (( SubAllocator == NULL ) && ( InitialSize > MINIMUM_VM_ALLOCATION )) {
        InitialSize  = MINIMUM_VM_ALLOCATION;
        SubAllocator = MyVirtualAlloc( InitialSize );
        }

    if ( SubAllocator != NULL ) {
        SubAllocator->NextAvailable = (PCHAR)SubAllocator + ROUNDUP2( sizeof( SUBALLOCATOR ), SUBALLOCATOR_ALIGNMENT );
        SubAllocator->LastAvailable = (PCHAR)SubAllocator + InitialSize;
        SubAllocator->VirtualList   = (PVOID*)SubAllocator;
        SubAllocator->GrowSize      = GrowthSize;
        }

    return (HANDLE) SubAllocator;
    }


PVOID
__fastcall
SubAllocate(
    IN HANDLE hAllocator,
    IN ULONG  Size
    )
    {
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PCHAR NewVirtual;
    PCHAR Allocation;
    ULONG AllocSize;
    ULONG Available;
    ULONG GrowSize;

    ASSERT( Size < (ULONG)( ~(( SUBALLOCATOR_ALIGNMENT * 2 ) - 1 )));

    AllocSize = ROUNDUP2( Size, SUBALLOCATOR_ALIGNMENT );

    Available = (ULONG)( SubAllocator->LastAvailable - SubAllocator->NextAvailable );

    if ( AllocSize <= Available ) {

        Allocation = SubAllocator->NextAvailable;

        SubAllocator->NextAvailable = Allocation + AllocSize;

        return Allocation;
        }

    //
    //  Insufficient VM, so grow it.  Make sure we grow it enough to satisfy
    //  the allocation request in case the request is larger than the grow
    //  size specified in CreateSubAllocator.
    //

#ifdef TESTCODE

    printf( "\nGrowing VM suballocater\n" );

#endif

    GrowSize = SubAllocator->GrowSize;

    if ( GrowSize < ( AllocSize + SUBALLOCATOR_ALIGNMENT )) {
        GrowSize = ROUNDUP2(( AllocSize + SUBALLOCATOR_ALIGNMENT ), MINIMUM_VM_ALLOCATION );
        }

    NewVirtual = MyVirtualAlloc( GrowSize );

    //
    //  If failed to alloc GrowSize VM, and the allocation could be satisfied
    //  with a minimum VM allocation, try allocating minimum VM to satisfy
    //  this request.
    //

    if (( NewVirtual == NULL ) && ( AllocSize <= ( MINIMUM_VM_ALLOCATION - SUBALLOCATOR_ALIGNMENT ))) {
        GrowSize = MINIMUM_VM_ALLOCATION;
        NewVirtual = MyVirtualAlloc( GrowSize );
        }

    if ( NewVirtual != NULL ) {

        //
        //  Set LastAvailable to end of new VM block.
        //

        SubAllocator->LastAvailable = NewVirtual + GrowSize;

        //
        //  Link new VM into list of VM allocations.
        //

        *(PVOID*)NewVirtual = SubAllocator->VirtualList;
        SubAllocator->VirtualList = (PVOID*)NewVirtual;

        //
        //  Requested allocation comes next.
        //

        Allocation = NewVirtual + SUBALLOCATOR_ALIGNMENT;

        //
        //  Then set the NextAvailable for what's remaining.
        //

        SubAllocator->NextAvailable = Allocation + AllocSize;

        //
        //  And return the allocation.
        //

        return Allocation;
        }

    //
    //  Could not allocate enough VM to satisfy request.
    //

    return NULL;
    }


VOID
DestroySubAllocator(
    IN HANDLE hAllocator
    )
    {
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PVOID VirtualBlock = SubAllocator->VirtualList;
    PVOID NextVirtualBlock;

    do  {
        NextVirtualBlock = *(PVOID*)VirtualBlock;
        MyVirtualFree( VirtualBlock );
        VirtualBlock = NextVirtualBlock;
        }
    while ( VirtualBlock != NULL );
    }


LPSTR
__fastcall
MySubAllocStrDup(
    IN HANDLE SubAllocator,
    IN LPCSTR String
    )
    {
    ULONG Length = (ULONG)strlen( String );
    LPSTR Buffer = SubAllocate( SubAllocator, Length + 1 );

    if ( Buffer ) {
        memcpy( Buffer, String, Length );   // no need to copy NULL terminator
        }

    return Buffer;
    }


LPSTR
MySubAllocStrDupAndCat(
    IN HANDLE SubAllocator,
    IN LPCSTR String1,
    IN LPCSTR String2,
    IN CHAR   Separator
    )
    {
    ULONG Length1 = (ULONG)strlen( String1 );
    ULONG Length2 = (ULONG)strlen( String2 );
    LPSTR Buffer = SubAllocate( SubAllocator, Length1 + Length2 + 2 );

    if ( Buffer ) {

        memcpy( Buffer, String1, Length1 );

        if (( Separator != 0 ) && ( Length1 > 0 ) && ( Buffer[ Length1 - 1 ] != Separator )) {
            Buffer[ Length1++ ] = Separator;
            }

        memcpy( Buffer + Length1, String2, Length2 );   // no need to terminate
        }

    return Buffer;
    }


VOID
MyLowercase(
    IN OUT LPSTR String
    )
    {
    LPSTR p;

    for ( p = String; *p; p++ ) {
        if (( *p >= 'A' ) && ( *p <= 'Z' )) {
            *p |= 0x20;
            }
        }
    }



#ifdef DONTCOMPILE  // not used currently

DWORD MyProcessHeap;

PVOID
MyHeapAllocZero(
    IN ULONG Size
    )
    {
    PVOID Allocation;

    if ( MyProcessHeap == NULL ) {
        MyProcessHeap = GetProcessHeap();
        }

    Allocation = HeapAlloc( MyProcessHeap, HEAP_ZERO_MEMORY, Size );

    if ( Allocation == NULL ) {
        SetLastError( ERROR_OUTOFMEMORY );
        }

    return Allocation;
    }


VOID
MyHeapFree(
    IN PVOID Allocation
    )
    {
    HeapFree( MyProcessHeap, 0, Allocation );
    }

#endif // DONTCOMPILE


ULONG
HashName(
    IN LPCSTR Name
    )
    {
    ULONG Length = (ULONG)strlen( Name );
    ULONG Hash   = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


ULONG
HashNameCaseInsensitive(
    IN LPCSTR Name
    )
    {
    ULONG Length = (ULONG)strlen( Name );
    ULONG Hash   = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ ( *Name++ & 0xDF );   // mask case bit
        }

    return Hash;
    }


UCHAR
__inline
LowNibbleToHexChar(
    ULONG Value
    )
    {
    return "0123456789abcdef"[ Value & 0x0000000F ];
    }


VOID
DwordToHexString(
    IN  DWORD Value,
    OUT LPSTR Buffer    // writes exactly 9 bytes including terminator
    )
    {
    ULONG i;

    Buffer[ 8 ] = 0;

    i = 8;

    do  {
        Buffer[ --i ] = LowNibbleToHexChar( Value );
        Value >>= 4;
        }
    while ( i != 0 );
    }


BOOL
HashToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer                // must be at least 33 bytes
    )
    {
    ULONG i;

    for ( i = 0; i < sizeof( MD5_HASH ); i++ ) {

        *Buffer++ = LowNibbleToHexChar( HashValue->Byte[ i ] >> 4 );
        *Buffer++ = LowNibbleToHexChar( HashValue->Byte[ i ] );
        }

    *Buffer = 0;

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996-1999, Microsoft Corporation.
//


#include "md5.h"

#ifndef PCUCHAR
    typedef const unsigned char * PCUCHAR;
#endif
#ifndef PCULONG
    typedef const unsigned long * PCULONG;
#endif

#include <stdlib.h>     /* _rotl */
#include <memory.h>     /* memcpy, memset */

#pragma intrinsic(memcpy, memset)

/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* ROTATE_LEFT rotates x left n bits. */

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

//
//  Intel and PowerPC both have a hardware rotate instruction with intrinsic
//  (inline) function for them.  Rough measurements show a 25% speed increase
//  for Intel and 10% speed increase for PowerPC when using the instrinsic
//  rotate versus the above defined shift/shift/or implemenation.
//

#if defined(_M_IX86) || defined(_M_PPC)
    #undef  ROTATE_LEFT
    #define ROTATE_LEFT(x, n) _rotl(x, n)
    #pragma intrinsic(_rotl)
#endif


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // ULONG-aligned pointer to 64-byte message chunk
    )
    {
    PCULONG MessageWord32 = DataChunk;
    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    )
    {
    union {
        ULONGLONG Qword[  8 ];
        UCHAR     Byte [ 64 ];
        } LocalBuffer;

    //
    //  Always append a pad byte of 0x80 to the message.
    //
    //  If RemainingBytes is less than (but not equal to) 56 bytes, then
    //  the final bits hashed count will be stored in the last 8 bytes of
    //  this 64 byte hash chunk.
    //
    //  If RemainingBytes is exactly 56 bytes, the appended 0x80 pad byte
    //  will force an extra chunk.
    //
    //  If RemainingBytes is greater than or equal to 56 bytes, then the
    //  final bits hashed count will be stored in the last 8 bytes of the
    //  NEXT 64 byte chunk that is otherwise zeroed, so THIS chunk needs to
    //  be zero-padded beyond the first pad byte and then hashed, then zero
    //  the first 56 bytes of the LocalBuffer for the NEXT chunk hash.
    //

    RemainingBytes &= 63;           // only care about partial frames

    //
    //  Zero init local buffer.
    //

    memset( &LocalBuffer, 0, 64 );

    //
    //  Append 0x80 pad byte to message.
    //

    LocalBuffer.Byte[ RemainingBytes ] = 0x80;

    if ( RemainingBytes > 0 ) {

        //
        //  Copy remaining data bytes (0 < RemainingBytes < 64) to LocalBuffer
        //  (remainder of LocalBuffer already zeroed except for pad byte).
        //

        memcpy( &LocalBuffer, RemainingData, RemainingBytes );

        if ( RemainingBytes >= 56 ) {

            UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

            memset( &LocalBuffer, 0, 56 );

            }
        }

    //
    //  Number of BITS hashed goes into last 8 bytes of last chunk.  This
    //  is a 64-bit value.  Note that if the number of BITS exceeds 2^64
    //  then this number is the low order 64 bits of the result.
    ///

    LocalBuffer.Qword[ 7 ] = ( TotalBytesHashed * 8 );      // number of BITS

    UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

    }


VOID
ComputeCompleteMD5(
    IN  PCVOID    DataBuffer,
    IN  ULONGLONG DataLength,
    OUT PMD5_HASH HashValue
    )
    {
    PCUCHAR   DataPointer = DataBuffer;
    ULONGLONG ChunkCount  = DataLength / 64;
    ULONG     OddBytes    = (ULONG)DataLength & 63;

    InitMD5( HashValue );

    while ( ChunkCount-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataPointer );
        DataPointer += 64;
        }

    FinalizeMD5( HashValue, DataPointer, OddBytes, DataLength );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\patchapi.c ===
#include <precomp.h>

//
//  patchapi.c
//
//  Implementation of PatchAPI for creating and applying patches to files.
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-1999.
//
//  MICROSOFT CONFIDENTIAL
//

typedef struct _PATCH_DATA {
    PVOID PatchData;
    ULONG PatchSize;
    } PATCH_DATA, *PPATCH_DATA;

//
//  If we're building a DLL, and it's not the applyer-only DLL, we need to
//  hook DLL_PROCESS_DETACH so we can unload imagehlp.dll if we dynamically
//  load it.  We only need imagehlp.dll if we're creating patches.
//

#ifdef BUILDING_PATCHAPI_DLL
#ifndef PATCH_APPLY_CODE_ONLY

BOOL
WINAPI
DllEntryPoint(
    HANDLE hDll,
    DWORD  Reason,
    PVOID  Reserved     // NULL for dynamic unload, non-NULL for terminating
    )
    {
    if ( Reason == DLL_PROCESS_ATTACH ) {
        DisableThreadLibraryCalls( hDll );
        InitImagehlpCritSect();
        }
    else if (( Reason == DLL_PROCESS_DETACH ) && ( ! Reserved )) {
        UnloadImagehlp();
        }

    return TRUE;
    }

#endif // ! PATCH_APPLY_CODE_ONLY
#endif // BUILDING_PATCHAPI_DLL


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    )
    {
    BOOL Success = TRUE;

    if ( ProgressCallback != NULL ) {

        __try {

            Success = ProgressCallback(
                          CallbackContext,
                          CurrentPosition,
                          MaximumPosition
                          );

            if (( ! Success ) && ( GetLastError() == ERROR_SUCCESS )) {
                SetLastError( ERROR_CANCELLED );
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( ERROR_CANCELLED );
            Success = FALSE;
            }
        }

    return Success;
    }


BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    PUCHAR MappedFile;
    BOOL   Modified;
    BOOL   Success;
    ULONG  i;

    MappedFile = FileMappedImage;
    Modified   = FALSE;
    Success    = TRUE;

    __try {

        NtHeader = GetNtHeader( MappedFile, FileSize );

        if ( NtHeader ) {

            //
            //  This is a coff image.
            //

            Modified = NormalizeCoffImage(
                           NtHeader,
                           MappedFile,
                           FileSize,
                           OptionFlags,
                           OptionData,
                           NewFileCoffBase,
                           NewFileCoffTime
                           );

            }

        else {

            //
            //  Other file type normalizations could be performed here.
            //

            }

#ifdef TESTCODE

        //
        //  The following test-only code creates a file containing
        //  the modified coff image to verify that the coff image
        //  is really a valid coff image.  This is for debugging
        //  only.
        //

        if ( Modified ) {

            HANDLE hFile = CreateFile(
                               "Normalized.out",
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                DWORD Actual;

                WriteFile( hFile, MappedFile, FileSize, &Actual, NULL );

                CloseHandle( hFile );

                }
            }

#endif // TESTCODE

        for ( i = 0; i < IgnoreRangeCount; i++ ) {
            if (( IgnoreRangeArray[ i ].OffsetInOldFile + IgnoreRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                ZeroMemory( MappedFile + IgnoreRangeArray[ i ].OffsetInOldFile, IgnoreRangeArray[ i ].LengthInBytes );
                }
            }

        for ( i = 0; i < RetainRangeCount; i++ ) {
            if (( RetainRangeArray[ i ].OffsetInOldFile + RetainRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                ZeroMemory( MappedFile + RetainRangeArray[ i ].OffsetInOldFile, RetainRangeArray[ i ].LengthInBytes );
                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    )
    {
    BOOL   Success = FALSE;
    HANDLE FileHandle;

    FileHandle = CreateFileA(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {

        Success = GetFilePatchSignatureByHandle(
                      FileHandle,
                      OptionFlags,
                      OptionData,
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray,
                      SignatureBufferSize,
                      SignatureBuffer
                      );

        CloseHandle( FileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    )
    {
    CHAR   AnsiSignatureBuffer[ 40 ];   // big enough for hex MD5 (33 bytes)
    HANDLE FileHandle;
    INT    Converted;
    BOOL   Success = FALSE;

    FileHandle = CreateFileW(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {

        Success = GetFilePatchSignatureByHandle(
                      FileHandle,
                      OptionFlags,
                      OptionData,
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray,
                      sizeof( AnsiSignatureBuffer ),
                      AnsiSignatureBuffer
                      );

        if ( Success ) {

            //
            //  Worst case growth from ANSI to UNICODE is 2X.
            //

            if (( SignatureBufferSizeInBytes / 2 ) < ( strlen( AnsiSignatureBuffer ) + 1 )) {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                Success = FALSE;
                }

            else {

                Converted = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                AnsiSignatureBuffer,
                                -1,
                                SignatureBuffer,
                                SignatureBufferSizeInBytes / 2
                                );

                Success = Converted ? TRUE : FALSE;
                }
            }

        CloseHandle( FileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    )
    {
    PVOID FileMapped;
    ULONG FileSize;
    ULONG FileCrc;
    MD5_HASH FileMD5;
    BOOL  Success;

    Success = MyMapViewOfFileByHandle(
                  FileHandle,
                  &FileSize,
                  &FileMapped
                  );

    if ( Success ) {

        //
        //  Note that we must normalize to a fixed known rebase address,
        //  so the CRC from this might be different than the OldFileCrc
        //  in a patch header that is specific to a new file's rebase
        //  address.  Note that if PATCH_OPTION_NO_REBASE is specified
        //  then the rebase address is ignored.
        //

        Success = NormalizeOldFileImageForPatching(
                      FileMapped,
                      FileSize,
                      OptionFlags,
                      OptionData,
                      0x10000000,           // non-zero fixed coff base
                      0x10000000,           // non-zero fixed coff time
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray
                      );

        if ( Success ) {

            if ( OptionFlags & PATCH_OPTION_SIGNATURE_MD5 ) {

                Success = SafeCompleteMD5(
                            FileMapped,
                            FileSize,
                            &FileMD5
                            );

                if ( Success ) {

                    if ( SignatureBufferSize < 33 ) {
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        Success = FALSE;
                        }

                    else {
                        HashToHexString( &FileMD5, ((LPSTR) SignatureBuffer ));
                        }
                    }
                }

            else {    // signature type is CRC-32

                Success = SafeCompleteCrc32(
                            FileMapped,
                            FileSize,
                            &FileCrc
                            );

                if ( Success ) {

                    if ( SignatureBufferSize < 9 ) {
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        Success = FALSE;
                        }

                    else {
                        DwordToHexString( FileCrc, (LPSTR) SignatureBuffer );
                        }
                    }
                }
            }

        UnmapViewOfFile( FileMapped );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


#ifndef PATCH_APPLY_CODE_ONLY

VOID
ReduceRiftTable(
    IN PRIFT_TABLE RiftTable
    )
    {
    PRIFT_ENTRY RiftEntryArray = RiftTable->RiftEntryArray;
    PUCHAR      RiftUsageArray = RiftTable->RiftUsageArray;
    ULONG       RiftEntryCount = RiftTable->RiftEntryCount;
    LONG        CurrentDisplacement;
    LONG        ThisDisplacement;
    ULONG       i;

    //
    //  Essentially we want to remove the usage count from any entry where
    //  the preceding USED entry would produce the same rift displacement.
    //
    //  The first used entry should contain a non-zero displacement (any
    //  USED entries before that should be marked UNUSED because they will
    //  coast from zero).
    //

    CurrentDisplacement = 0;

    for ( i = 0; i < RiftEntryCount; i++ ) {

        if ( RiftUsageArray[ i ] != 0 ) {

            ThisDisplacement = RiftEntryArray[ i ].NewFileRva - RiftEntryArray[ i ].OldFileRva;

            if ( ThisDisplacement == CurrentDisplacement ) {
                RiftUsageArray[ i ] = 0;    // not needed
                }
            else {
                CurrentDisplacement = ThisDisplacement;
                }
            }
        }
    }

#endif // PATCH_APPLY_CODE_ONLY


BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN ULONG TransformOptions,
    IN PVOID OldFileMapped,
    IN ULONG OldFileSize,
    IN ULONG NewFileResTime,
    IN PRIFT_TABLE RiftTable,
    ...
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    BOOL Success = TRUE;

    __try {

        NtHeader = GetNtHeader( OldFileMapped, OldFileSize );

        if ( NtHeader ) {

            Success = TransformCoffImage(
                          TransformOptions,
                          NtHeader,
                          OldFileMapped,
                          OldFileSize,
                          NewFileResTime,
                          RiftTable,
                          NULL
                          );
            }

        else {

            //
            //  Other file type transformations could be performed here.
            //

            }

#ifndef PATCH_APPLY_CODE_ONLY

        if ( RiftTable->RiftUsageArray != NULL ) {
            ReduceRiftTable( RiftTable );
            }

#endif // PATCH_APPLY_CODE_ONLY

        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

#ifdef TESTCODE

    //
    //  The following test-only code creates a file containing
    //  the modified coff image to verify that the coff image
    //  is really a valid coff image.  This is for debugging
    //  only.
    //

    if ( Success ) {

        HANDLE hFile = CreateFile(
                           "Transformed.out",
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           );

        if ( hFile != INVALID_HANDLE_VALUE ) {

            DWORD Actual;

            WriteFile( hFile, OldFileMapped, OldFileSize, &Actual, NULL );

            CloseHandle( hFile );

            }
        }

#endif // TESTCODE

    return Success;
    }


PUCHAR
__fastcall
VariableLengthUnsignedDecode(
    IN  PUCHAR Buffer,
    OUT PULONG ReturnValue
    )
    {
    PUCHAR p = Buffer;
    ULONG Value = 0;
    ULONG Shift = 0;

    do  {
        Value |= (( *p & 0x7F ) << Shift );
        Shift += 7;
        }
    while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));

    *ReturnValue = Value;

    return p;
    }


PUCHAR
__fastcall
VariableLengthSignedDecode(
    IN  PUCHAR Buffer,
    OUT PLONG  ReturnValue
    )
    {
    PUCHAR p = Buffer;
    ULONG Shift;
    LONG  Value;

    Value = *p & 0x3F;
    Shift = 6;

    if ( ! ( *p++ & 0x80 )) {
        do  {
            Value |= (( *p & 0x7F ) << Shift );
            Shift += 7;
            }
        while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));
        }

    if ( *Buffer & 0x40 ) {
        Value = -Value;
        }

    *ReturnValue = Value;

    return p;
    }


UCHAR
PatchVersion(
    IN ULONG PatchSignature
    )
    {
    union {
        ULONG Signature;
        UCHAR Byte[ 4 ];
        } u;

    u.Signature = PatchSignature;

    if (( u.Byte[ 0 ] == 'P' ) && ( u.Byte[ 1 ] == 'A' ) &&
        ( u.Byte[ 2 ] >= '0' ) && ( u.Byte[ 2 ] <= '9' ) &&
        ( u.Byte[ 3 ] >= '0' ) && ( u.Byte[ 3 ] <= '9' )) {

        return (UCHAR)(( u.Byte[ 2 ] - '0' ) * 10 + ( u.Byte[ 3 ] - '0' ));
        }

    return 0;
    }


BOOL
DecodePatchHeader(
    IN  PVOID               PatchHeader,
    IN  ULONG               PatchHeaderMaxSize,
    IN  HANDLE              SubAllocator,
    OUT PULONG              PatchHeaderActualSize,
    OUT PPATCH_HEADER_INFO *HeaderInfo
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    PPATCH_HEADER_INFO Header;
    ULONG  i, j;
    LONG   Delta;
    LONG   DeltaNew;
    ULONG  DeltaPos;
    ULONG  Length;
    ULONG  PreviousOffset;
    ULONG  PreviousOldRva;
    ULONG  PreviousNewRva;
    BOOL   Success;
    PUCHAR p;

    //
    //  A couple of implementation notes here.  The PatchHeaderMaxSize
    //  value does NOT guarantee that we won't try to read beyond that
    //  memory address in this routine.  This routine should be called
    //  under try/except to trap the case where we walk off the end of
    //  a corrupt patch header.  The PatchHeaderMaxSize is just a helper
    //  value that lets us know if we did have a corrupt header in the
    //  case where we walked too far but not off the end of the page.
    //

    Success = FALSE;

    p = PatchHeader;

    Header = SubAllocate( SubAllocator, sizeof( PATCH_HEADER_INFO ));

    //
    //  SubAllocate provides zeroed memory.
    //

    if ( Header != NULL ) {

        __try {

            Header->Signature = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            if ( Header->Signature != PATCH_SIGNATURE ) {
                if ( PatchVersion( Header->Signature ) > PatchVersion( PATCH_SIGNATURE )) {
                    SetLastError( ERROR_PATCH_NEWER_FORMAT );
                    }
                else {
                    SetLastError( ERROR_PATCH_CORRUPT );
                    }
                __leave;
                }

            Header->OptionFlags = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            //
            //  The PATCH_OPTION_NO_TIMESTAMP flag is stored inverse for
            //  backward compatibility, so flip it back here.
            //

            Header->OptionFlags ^= PATCH_OPTION_NO_TIMESTAMP;

            //
            //  Now check for invalid flags.
            //

            if ( Header->OptionFlags & ~PATCH_OPTION_VALID_FLAGS ) {
                SetLastError( ERROR_PATCH_CORRUPT );
                __leave;
                }

            //
            //  If the PATCH_OPTION_EXTENDED_OPTIONS flag is set, the next
            //  4 bytes is the ExtendedOptionFlags value.
            //

            if ( Header->OptionFlags & PATCH_OPTION_EXTENDED_OPTIONS ) {

                Header->ExtendedOptionFlags = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );
                }

            //
            //  No stored OptionData defined for now.
            //

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

                Header->NewFileTime = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_REBASE )) {

                Header->NewFileCoffBase = ((ULONG)*(UNALIGNED USHORT *)( p )) << 16;
                p += sizeof( USHORT );

                ASSERT( Header->NewFileCoffBase != 0 );

                //
                //  If NewFileTime is nonzero, CoffTime is stored as a signed
                //  delta from NewFileTime since they are usually very close.
                //  If NewFileTime is zero, CoffTime is encoded as a ULONG.
                //

                if ( Header->NewFileTime != 0 ) {

                    p = VariableLengthSignedDecode( p, &Delta );
                    Header->NewFileCoffTime = Header->NewFileTime - Delta;
                    }

                else {

                    Header->NewFileCoffTime = *(UNALIGNED ULONG *)( p );
                    p += sizeof( ULONG );
                    }
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

                //
                //  If NewFileCoffTime is nonzero, ResTime is stored as a
                //  signed delta from NewFileCoffTime since they are usually
                //  very close.  If NewFileCoffTime is zero, ResTime is
                //  encoded as a ULONG.
                //

                if ( Header->NewFileCoffTime != 0 ) {

                    p = VariableLengthSignedDecode( p, &Delta );
                    Header->NewFileResTime = Header->NewFileCoffTime - Delta;
                    }

                else {

                    Header->NewFileResTime = *(UNALIGNED ULONG *)( p );
                    p += sizeof( ULONG );
                    }
                }

            p = VariableLengthUnsignedDecode( p, &Header->NewFileSize );

            Header->NewFileCrc = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            Header->OldFileCount = *p++;

            Header->OldFileInfoArray = SubAllocate( SubAllocator, Header->OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));

            if ( Header->OldFileInfoArray == NULL ) {
                __leave;
                }

            for ( i = 0; i < Header->OldFileCount; i++ ) {

                OldFileInfo = &Header->OldFileInfoArray[ i ];

                p = VariableLengthSignedDecode( p, &Delta );

                if ((LONG)( Header->NewFileSize + Delta ) < 0 ) {
                    SetLastError( ERROR_PATCH_CORRUPT );
                    __leave;
                    }

                OldFileInfo->OldFileSize = Header->NewFileSize + Delta;

                OldFileInfo->OldFileCrc = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );

                OldFileInfo->IgnoreRangeCount = *p++;

                if ( OldFileInfo->IgnoreRangeCount != 0 ) {

                    OldFileInfo->IgnoreRangeArray = SubAllocate( SubAllocator, OldFileInfo->IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ));

                    if ( OldFileInfo->IgnoreRangeArray == NULL ) {
                        __leave;
                        }

                    PreviousOffset = 0;

                    for ( j = 0; j < OldFileInfo->IgnoreRangeCount; j++ ) {

                        p = VariableLengthSignedDecode( p, &Delta );
                        p = VariableLengthUnsignedDecode( p, &Length );

                        OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile = PreviousOffset + Delta;
                        OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes = Length;

                        PreviousOffset = PreviousOffset + Delta + Length;

                        if ( PreviousOffset > OldFileInfo->OldFileSize ) {
                            SetLastError( ERROR_PATCH_CORRUPT );
                            __leave;
                            }
                        }
                    }

                OldFileInfo->RetainRangeCount = *p++;

                if ( OldFileInfo->RetainRangeCount != 0 ) {

                    OldFileInfo->RetainRangeArray = SubAllocate( SubAllocator, OldFileInfo->RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ));

                    if ( OldFileInfo->RetainRangeArray == NULL ) {
                        __leave;
                        }

                    PreviousOffset = 0;

                    for ( j = 0; j < OldFileInfo->RetainRangeCount; j++ ) {

                        p = VariableLengthSignedDecode( p, &Delta );
                        p = VariableLengthSignedDecode( p, &DeltaNew );
                        p = VariableLengthUnsignedDecode( p, &Length );

                        OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile = PreviousOffset + Delta;
                        OldFileInfo->RetainRangeArray[ j ].OffsetInNewFile = PreviousOffset + Delta + DeltaNew;
                        OldFileInfo->RetainRangeArray[ j ].LengthInBytes   = Length;

                        PreviousOffset = PreviousOffset + Delta + Length;

                        if (( PreviousOffset > OldFileInfo->OldFileSize ) ||
                            (( PreviousOffset + DeltaNew ) > Header->NewFileSize )) {
                            SetLastError( ERROR_PATCH_CORRUPT );
                            __leave;
                            }
                        }
                    }

                p = VariableLengthUnsignedDecode( p, &OldFileInfo->RiftTable.RiftEntryCount );

                if ( OldFileInfo->RiftTable.RiftEntryCount != 0 ) {

                    OldFileInfo->RiftTable.RiftEntryArray = SubAllocate( SubAllocator, OldFileInfo->RiftTable.RiftEntryCount * sizeof( RIFT_ENTRY ));

                    if ( OldFileInfo->RiftTable.RiftEntryArray == NULL ) {
                        __leave;
                        }

                    OldFileInfo->RiftTable.RiftUsageArray = NULL;

                    PreviousOldRva = 0;
                    PreviousNewRva = 0;

                    for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {

                        p = VariableLengthUnsignedDecode( p, &DeltaPos );
                        p = VariableLengthSignedDecode( p, &DeltaNew );

                        OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva = PreviousOldRva + DeltaPos;
                        OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva = PreviousNewRva + DeltaNew;

                        PreviousOldRva += DeltaPos;
                        PreviousNewRva += DeltaNew;
                        }
                    }

                p = VariableLengthUnsignedDecode( p, &OldFileInfo->PatchDataSize );
                }

            if ( p > ((PUCHAR)PatchHeader + PatchHeaderMaxSize )) {
                SetLastError( ERROR_PATCH_CORRUPT );
                __leave;
                }

            Success = TRUE;
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( ERROR_PATCH_CORRUPT );
            Success = FALSE;
            }
        }

    if ( Success ) {

        if ( PatchHeaderActualSize ) {
            *PatchHeaderActualSize = (ULONG)( p - (PUCHAR)PatchHeader );
            }

        if ( HeaderInfo ) {
            *HeaderInfo = Header;
            }
        }

    return Success;
    }


//
//  Following group of functions and exported apis are exclusively for
//  creating patches.  If we're only compiling the apply code, ignore
//  this group of functions.
//

#ifndef PATCH_APPLY_CODE_ONLY

PUCHAR
__fastcall
VariableLengthUnsignedEncode(
    OUT PUCHAR Buffer,
    IN  ULONG  Value
    )
    {
    UCHAR Byte = (UCHAR)( Value & 0x7F );       // low order 7 bits

    Value >>= 7;

    while ( Value ) {

        *Buffer++ = Byte;

        Byte = (UCHAR)( Value & 0x7F );         // next 7 higher order bits

        Value >>= 7;

        }

    *Buffer++ = (UCHAR)( Byte | 0x80 );

    return Buffer;
    }


PUCHAR
__fastcall
VariableLengthSignedEncode(
    OUT PUCHAR Buffer,
    IN  LONG   Value
    )
    {
    UCHAR Byte;

    if ( Value < 0 ) {
        Value = -Value;
        Byte = (UCHAR)(( Value & 0x3F ) | 0x40 );
        }
    else {
        Byte = (UCHAR)( Value & 0x3F );
        }

    Value >>= 6;

    while ( Value ) {

        *Buffer++ = Byte;

        Byte = (UCHAR)( Value & 0x7F );         // next 7 higher order bits

        Value >>= 7;

        }

    *Buffer++ = (UCHAR)( Byte | 0x80 );

    return Buffer;
    }


ULONG
EncodePatchHeader(
    IN  PPATCH_HEADER_INFO HeaderInfo,
    OUT PVOID              PatchHeaderBuffer
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    ULONG  i, j;
    LONG   Delta;
    ULONG  PreviousOffset;
    ULONG  PreviousOldRva;
    ULONG  PreviousNewRva;
    ULONG  ActiveRiftCount;

    PUCHAR p = PatchHeaderBuffer;

#ifdef TESTCODE
    PUCHAR q;
#endif // TESTCODE

    ASSERT( HeaderInfo->Signature == PATCH_SIGNATURE );
    ASSERT((( HeaderInfo->OptionFlags & ~PATCH_OPTION_VALID_FLAGS      ) == 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_EXTENDED_OPTIONS ) != 0 ) == ( HeaderInfo->ExtendedOptionFlags != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_TIMESTAMP     ) == 0 ) == ( HeaderInfo->NewFileTime         != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_REBASE        ) == 0 ) == ( HeaderInfo->NewFileCoffBase     != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_REBASE        ) == 0 ) == ( HeaderInfo->NewFileCoffTime     != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_RESTIMEFIX    ) == 0 ) == ( HeaderInfo->NewFileResTime      != 0 ));

    *(UNALIGNED ULONG *)( p ) = HeaderInfo->Signature;
    p += sizeof( ULONG );

    //
    //  The PATCH_OPTION_NO_TIMESTAMP flag is stored inverse for
    //  backward compatibility, so flip it when storing it here.
    //

    *(UNALIGNED ULONG *)( p ) = ( HeaderInfo->OptionFlags ^ PATCH_OPTION_NO_TIMESTAMP );
    p += sizeof( ULONG );

    //
    //  If the PATCH_OPTION_EXTENDED_OPTIONS flag is set, the next
    //  4 bytes is the ExtendedOptionFlags value.
    //

    if ( HeaderInfo->OptionFlags & PATCH_OPTION_EXTENDED_OPTIONS ) {

        *(UNALIGNED ULONG *)( p ) = HeaderInfo->ExtendedOptionFlags;
        p += sizeof( ULONG );
        }

    //
    //  No stored OptionData defined for now.
    //

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

        *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileTime;
        p += sizeof( ULONG );
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_REBASE )) {

        ASSERT(( HeaderInfo->NewFileCoffBase >> 16 ) != 0 );

        *(UNALIGNED USHORT *)( p ) = (USHORT)( HeaderInfo->NewFileCoffBase >> 16 );
        p += sizeof( USHORT );

        //
        //  If NewFileTime is nonzero, CoffTime is stored as a signed
        //  delta from NewFileTime since they are usually very close.
        //  If NewFileTime is zero, CoffTime is encoded as a ULONG.
        //

        if ( HeaderInfo->NewFileTime != 0 ) {

            Delta = HeaderInfo->NewFileTime - HeaderInfo->NewFileCoffTime;
            p = VariableLengthSignedEncode( p, Delta );
            }

        else {

            *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileCoffTime;
            p += sizeof( ULONG );
            }
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

        //
        //  If NewFileCoffTime is nonzero, ResTime is stored as a
        //  signed delta from NewFileCoffTime since they are usually
        //  very close.  If NewFileCoffTime is zero, ResTime is
        //  encoded as a ULONG.
        //

        if ( HeaderInfo->NewFileCoffTime != 0 ) {

            Delta = HeaderInfo->NewFileCoffTime - HeaderInfo->NewFileResTime;
            p = VariableLengthSignedEncode( p, Delta );
            }

        else {

            *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileResTime;
            p += sizeof( ULONG );
            }
        }

    p = VariableLengthUnsignedEncode( p, HeaderInfo->NewFileSize );

    *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileCrc;
    p += sizeof( ULONG );

    ASSERT( HeaderInfo->OldFileCount < 256 );

    *p++ = (UCHAR)( HeaderInfo->OldFileCount );

    for ( i = 0; i < HeaderInfo->OldFileCount; i++ ) {

        OldFileInfo = &HeaderInfo->OldFileInfoArray[ i ];

        Delta = OldFileInfo->OldFileSize - HeaderInfo->NewFileSize;
        p = VariableLengthSignedEncode( p, Delta );

        *(UNALIGNED ULONG *)( p ) = OldFileInfo->OldFileCrc;
        p += sizeof( ULONG );

        ASSERT( OldFileInfo->IgnoreRangeCount < 256 );

        *p++ = (UCHAR)( OldFileInfo->IgnoreRangeCount );

        PreviousOffset = 0;

        for ( j = 0; j < OldFileInfo->IgnoreRangeCount; j++ ) {

            Delta = OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile - PreviousOffset;

            PreviousOffset = OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile +
                             OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes;

            ASSERT( PreviousOffset <= OldFileInfo->OldFileSize );

            p = VariableLengthSignedEncode( p, Delta );

            p = VariableLengthUnsignedEncode( p, OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes );
            }

        ASSERT( OldFileInfo->RetainRangeCount < 256 );

        *p++ = (UCHAR)( OldFileInfo->RetainRangeCount );

        PreviousOffset = 0;

        for ( j = 0; j < OldFileInfo->RetainRangeCount; j++ ) {

            Delta = OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile - PreviousOffset;

            PreviousOffset = OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile +
                             OldFileInfo->RetainRangeArray[ j ].LengthInBytes;

            ASSERT( PreviousOffset <= OldFileInfo->OldFileSize );

            p = VariableLengthSignedEncode( p, Delta );

            Delta = OldFileInfo->RetainRangeArray[ j ].OffsetInNewFile -
                    OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile;

            p = VariableLengthSignedEncode( p, Delta );

            p = VariableLengthUnsignedEncode( p, OldFileInfo->RetainRangeArray[ j ].LengthInBytes );
            }

        ActiveRiftCount = 0;

        ASSERT(( OldFileInfo->RiftTable.RiftEntryCount == 0 ) || ( OldFileInfo->RiftTable.RiftUsageArray != NULL ));

        for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {
            if ( OldFileInfo->RiftTable.RiftUsageArray[ j ] ) {
                ++ActiveRiftCount;
                }
            }

#ifdef TESTCODE2

        fprintf( stderr, "\n\n" );

#endif // TESTCODE2

#ifdef TESTCODE

        q = p;

#endif // TESTCODE

        if (( OldFileInfo->RiftTable.RiftEntryCount ) && ( ActiveRiftCount == 0 )) {

            //
            //  This is a special case.  We have a rift table but didn't use
            //  any entries during transformation.  This can happen if all the
            //  rifts coast to zero for extremely similar files.  If we encode
            //  the rift count as zero, no transformations will be performed
            //  during patch apply.  To prevent that, we'll encode one rift of
            //  0,0 which is usually just the implied initial rift.
            //

            ActiveRiftCount = 1;

            p = VariableLengthUnsignedEncode( p, ActiveRiftCount );
            p = VariableLengthUnsignedEncode( p, 0 );
            p = VariableLengthSignedEncode(   p, 0 );

            }

        else {

            p = VariableLengthUnsignedEncode( p, ActiveRiftCount );

            PreviousOldRva = 0;
            PreviousNewRva = 0;

            for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {

                if ( OldFileInfo->RiftTable.RiftUsageArray[ j ] ) {

#ifdef TESTCODE2
                    fprintf( stderr, "%9X ", OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva );
                    fprintf( stderr, "%9X ", OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva );
#endif // TESTCODE2

                    Delta = OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva - PreviousOldRva;

                    ASSERT( Delta > 0 );    // sorted by OldFileRva

#ifdef TESTCODE2
                    fprintf( stderr, "%9d ", Delta );

#endif // TESTCODE2

                    PreviousOldRva = OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva;

                    p = VariableLengthUnsignedEncode( p, Delta );

                    Delta = OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva - PreviousNewRva;

#ifdef TESTCODE2
                    fprintf( stderr, "%9d\n", Delta );
#endif // TESTCODE2

                    PreviousNewRva = OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva;

                    p = VariableLengthSignedEncode( p, Delta );
                    }
                }
            }

#ifdef TESTCODE

        if ( ActiveRiftCount > 0 ) {
            printf( "\r%9d rifts encoded in %d bytes (%.1f bytes per rift)\n", ActiveRiftCount, p - q, ((double)( p - q ) / ActiveRiftCount ));
            }

#endif // TESTCODE

        p = VariableLengthUnsignedEncode( p, OldFileInfo->PatchDataSize );
        }

    return (ULONG)( p - (PUCHAR) PatchHeaderBuffer );
    }


BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_A OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_A ),
                              OldFileName,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileExA(
               1,
               &OldFileInfo,
               NewFileName,
               PatchFileName,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_W OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_W ),
                              OldFileName,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileExW(
               1,
               &OldFileInfo,
               NewFileName,
               PatchFileName,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_H OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_H ),
                              OldFileHandle,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileByHandlesEx(
               1,
               &OldFileInfo,
               NewFileHandle,
               PatchFileHandle,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_OLD_FILE_INFO_H OldFileInfoByHandle;
    HANDLE PatchFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success;
    ULONG  i;

    OldFileInfoByHandle =   _alloca( OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));
    ZeroMemory( OldFileInfoByHandle, OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));

    if ( OldFileCount == 0 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    Success = TRUE;

    for ( i = 0; i < OldFileCount; i++ ) {

        OldFileInfoByHandle[ i ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_H );
        OldFileInfoByHandle[ i ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
        OldFileInfoByHandle[ i ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
        OldFileInfoByHandle[ i ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
        OldFileInfoByHandle[ i ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

        OldFileInfoByHandle[ i ].OldFileHandle = CreateFileA(
                                                     OldFileInfoArray[ i ].OldFileName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                     NULL,
                                                     OPEN_EXISTING,
                                                     FILE_FLAG_SEQUENTIAL_SCAN,
                                                     NULL
                                                     );

        if ( OldFileInfoByHandle[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
            Success = FALSE;
            break;
            }
        }

    if ( Success ) {

        Success = FALSE;

        NewFileHandle = CreateFileA(
                            NewFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            PatchFileHandle = CreateFileA(
                                  PatchFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                  );

            if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

                Success = CreatePatchFileByHandlesEx(
                              OldFileCount,
                              OldFileInfoByHandle,
                              NewFileHandle,
                              PatchFileHandle,
                              OptionFlags,
                              OptionData,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( PatchFileHandle );

                if ( ! Success ) {
                    DeleteFileA( PatchFileName );
                    }
                }

            CloseHandle( NewFileHandle );
            }
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if (( OldFileInfoByHandle[ i ].OldFileHandle != NULL ) &&
            ( OldFileInfoByHandle[ i ].OldFileHandle != INVALID_HANDLE_VALUE )) {

            CloseHandle( OldFileInfoByHandle[ i ].OldFileHandle );
            }
        }

    return Success;
    }


BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_OLD_FILE_INFO_H OldFileInfoByHandle;
    HANDLE PatchFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success;
    ULONG  i;

    OldFileInfoByHandle =   _alloca( OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));
    ZeroMemory( OldFileInfoByHandle, OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));

    if ( OldFileCount == 0 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    Success = TRUE;

    for ( i = 0; i < OldFileCount; i++ ) {

        OldFileInfoByHandle[ i ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_H );
        OldFileInfoByHandle[ i ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
        OldFileInfoByHandle[ i ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
        OldFileInfoByHandle[ i ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
        OldFileInfoByHandle[ i ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

        OldFileInfoByHandle[ i ].OldFileHandle = CreateFileW(
                                                     OldFileInfoArray[ i ].OldFileName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                     NULL,
                                                     OPEN_EXISTING,
                                                     FILE_FLAG_SEQUENTIAL_SCAN,
                                                     NULL
                                                     );

        if ( OldFileInfoByHandle[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
            Success = FALSE;
            break;
            }
        }

    if ( Success ) {

        Success = FALSE;

        NewFileHandle = CreateFileW(
                            NewFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            PatchFileHandle = CreateFileW(
                                  PatchFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                  );

            if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

                Success = CreatePatchFileByHandlesEx(
                              OldFileCount,
                              OldFileInfoByHandle,
                              NewFileHandle,
                              PatchFileHandle,
                              OptionFlags,
                              OptionData,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( PatchFileHandle );

                if ( ! Success ) {
                    DeleteFileW( PatchFileName );
                    }
                }

            CloseHandle( NewFileHandle );
            }
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if (( OldFileInfoByHandle[ i ].OldFileHandle != NULL ) &&
            ( OldFileInfoByHandle[ i ].OldFileHandle != INVALID_HANDLE_VALUE )) {

            CloseHandle( OldFileInfoByHandle[ i ].OldFileHandle );
            }
        }

    return Success;
    }


BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PATCH_HEADER_INFO HeaderInfo;
    UP_IMAGE_NT_HEADERS32 NtHeader;
    UP_IMAGE_NT_HEADERS32 OldFileNtHeader;
    PPATCH_DATA PatchArray;
    PFILETIME PatchFileTime;
    FILETIME NewFileTime;
    PUCHAR   NewFileMapped;
    ULONG    NewFileSize;
    ULONG    NewFileCrc;
    ULONG    NewFileCoffBase;
    ULONG    NewFileCoffTime;
    ULONG    NewFileResTime;
    ULONG    NewFileCompressedSize;
    PUCHAR   OldFileMapped;
    ULONG    OldFileSize;
    ULONG    OldFileCrc;
    PUCHAR   PatchFileMapped;
    PUCHAR   PatchBuffer;
    ULONG    PatchBufferSize;
    PUCHAR   PatchAltBuffer;
    ULONG    PatchAltSize;
    ULONG    PatchDataSize;
    ULONG    PatchFileCrc;
    ULONG    HeaderSize;
    ULONG    HeaderOldFileCount;
    ULONG    ProgressPosition;
    ULONG    ProgressMaximum;
    ULONG    ErrorCode;
    BOOL     TryLzxBoth;
    BOOL     Success;
    BOOL     Transform;
    HANDLE   SubAllocatorHandle;
    ULONG    EstimatedLzxMemory;
    ULONG    ExtendedOptionFlags;
    ULONG    AltExtendedOptionFlags;
    ULONG    OldFileOriginalChecksum;
    ULONG    OldFileOriginalTimeDate;
    ULONG    i, j;
    PUCHAR   p;
    ULONG    LargestOldFileSize = 0;

    HeaderInfo.OldFileInfoArray = _alloca( OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));
    PatchArray                  = _alloca( OldFileCount * sizeof( PATCH_DATA ));

    ZeroMemory( HeaderInfo.OldFileInfoArray, OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));
    ZeroMemory( PatchArray, OldFileCount * sizeof( PATCH_DATA ));

    if (( OldFileCount == 0 ) || ( OldFileCount > 127 )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    if ( OptionFlags & PATCH_OPTION_SIGNATURE_MD5 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    if (( OptionFlags & 0x0000FFFF ) == PATCH_OPTION_USE_BEST ) {
        OptionFlags |= PATCH_OPTION_USE_LZX_BEST;
        }

    for ( i = 1; i < OldFileCount; i++ ) {
        if ( OldFileInfoArray[ i ].RetainRangeCount != OldFileInfoArray[ 0 ].RetainRangeCount ) {
            SetLastError( ERROR_PATCH_RETAIN_RANGES_DIFFER );
            return FALSE;
            }

        for ( j = 0; j < OldFileInfoArray[ 0 ].RetainRangeCount; j++ ) {
            if (( OldFileInfoArray[ i ].RetainRangeArray[ j ].OffsetInNewFile !=
                  OldFileInfoArray[ 0 ].RetainRangeArray[ j ].OffsetInNewFile ) ||
                ( OldFileInfoArray[ i ].RetainRangeArray[ j ].LengthInBytes !=
                  OldFileInfoArray[ 0 ].RetainRangeArray[ j ].LengthInBytes )) {

                SetLastError( ERROR_PATCH_RETAIN_RANGES_DIFFER );
                return FALSE;
                }
            }
        }

    ExtendedOptionFlags = 0;

    if (( OptionData ) && ( OptionData->SizeOfThisStruct >= sizeof( PATCH_OPTION_DATA ))) {
        ExtendedOptionFlags = OptionData->ExtendedOptionFlags;
        }

    Success = MyMapViewOfFileByHandle(
                  NewFileHandle,
                  &NewFileSize,
                  &NewFileMapped
                  );

    if ( ! Success ) {

        if ( GetLastError() == ERROR_SUCCESS ) {

            SetLastError( ERROR_EXTENDED_ERROR );
            }

        return FALSE;
        }

    GetFileTime( NewFileHandle, NULL, NULL, &NewFileTime );
    PatchFileTime = &NewFileTime;

    NewFileCoffBase    = 0;
    NewFileCoffTime    = 0;
    NewFileResTime     = 0;
    HeaderOldFileCount = 0;
    HeaderSize         = 0;
    NewFileCrc         = 0;     // prevent compiler warning

    ProgressPosition   = 0;
    ProgressMaximum    = 0;     // prevent compiler warning

    __try {

        NtHeader = GetNtHeader( NewFileMapped, NewFileSize );

        if ( ! ( OptionFlags & PATCH_OPTION_NO_REBASE )) {
            if ( NtHeader ) {
                NewFileCoffTime = NtHeader->FileHeader.TimeDateStamp;
                NewFileCoffBase = NtHeader->OptionalHeader.ImageBase;
                }
            else {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            }

        if (( NtHeader ) && ( NtHeader->OptionalHeader.CheckSum == 0 )) {
            OptionFlags |= PATCH_OPTION_NO_CHECKSUM;
            }

        if ( ! ( OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

            if ( NtHeader ) {

                UP_IMAGE_RESOURCE_DIRECTORY ResDir;

                ResDir = ImageDirectoryMappedAddress(
                             NtHeader,
                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                             NULL,
                             NewFileMapped,
                             NewFileSize
                             );

                if ( ResDir ) {
                    NewFileResTime = ResDir->TimeDateStamp;
                    }
                }

            if ( NewFileResTime == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            }

        TryLzxBoth = FALSE;

        if (( OptionFlags & PATCH_OPTION_USE_LZX_BEST ) == PATCH_OPTION_USE_LZX_BEST ) {

            OptionFlags &= ~PATCH_OPTION_USE_LZX_B;     //  No E8 translation on first try.

            if ((( ! NtHeader ) && ( *(UNALIGNED USHORT *)NewFileMapped == 0x5A4D )) ||             // MZ, not PE
                (( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ))) {    // PE, i386

                TryLzxBoth = TRUE;  //  Will force E8 translation on second try.
                }
            }

        else if (( OptionFlags & PATCH_OPTION_USE_LZX_BEST ) == PATCH_OPTION_USE_LZX_B ) {

            //
            //  Caller is requesting forced E8 translation, so disable E8
            //  transformation.
            //

            if (( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) {    // PE, i386
                ExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;
                }
            }

        ProgressMaximum = NewFileSize * OldFileCount;

        for ( i = 0; i < OldFileCount; i++ ) {
            OldFileSize = GetFileSize( OldFileInfoArray[ i ].OldFileHandle, NULL );

            if ( LargestOldFileSize < OldFileSize ) {
                LargestOldFileSize = OldFileSize;
                }

            ProgressMaximum += LzxInsertSize( OldFileSize, OptionFlags );
            }

        if ( TryLzxBoth ) {
            ProgressMaximum *= 2;
            }

        if ( OptionFlags & PATCH_OPTION_FAIL_IF_BIGGER ) {
            ProgressMaximum += NewFileSize;
            }

        Success = ProgressCallbackWrapper(
                      ProgressCallback,
                      CallbackContext,
                      0,
                      ProgressMaximum
                      );

        if ( ! Success ) {
            __leave;
            }

        for ( j = 0; j < OldFileInfoArray[ 0 ].RetainRangeCount; j++ ) {
            ZeroMemory(
                OldFileInfoArray[ 0 ].RetainRangeArray[ j ].OffsetInNewFile + NewFileMapped,
                OldFileInfoArray[ 0 ].RetainRangeArray[ j ].LengthInBytes
                );
            }

        NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, NewFileSize ) ^ 0xFFFFFFFF;

        PatchBufferSize = ROUNDUP2( NewFileSize + ( NewFileSize / 256 ), 0x10000 );

        Success = FALSE;

        for ( i = 0; i < OldFileCount; i++ ) {

            Success = MyMapViewOfFileByHandle(
                          OldFileInfoArray[ i ].OldFileHandle,
                          &OldFileSize,
                          &OldFileMapped
                          );

            if ( ! Success ) {
                break;
                }

            OldFileOriginalChecksum = 0;
            OldFileOriginalTimeDate = 0;
            OldFileNtHeader = NULL;

            __try {

                OldFileNtHeader = GetNtHeader( OldFileMapped, OldFileSize );

                if ( OldFileNtHeader ) {

                    OldFileOriginalChecksum = OldFileNtHeader->OptionalHeader.CheckSum;
                    OldFileOriginalTimeDate = OldFileNtHeader->FileHeader.TimeDateStamp;
                    }
                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }

            Success = NormalizeOldFileImageForPatching(
                          OldFileMapped,
                          OldFileSize,
                          OptionFlags,
                          OptionData,
                          NewFileCoffBase,
                          NewFileCoffTime,
                          OldFileInfoArray[ i ].IgnoreRangeCount,
                          OldFileInfoArray[ i ].IgnoreRangeArray,
                          OldFileInfoArray[ i ].RetainRangeCount,
                          OldFileInfoArray[ i ].RetainRangeArray
                          );

            if ( Success ) {

                Success = SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc );

                if ( Success ) {

                    //
                    //  First determine if this old file is the same as any already
                    //  processed old files.
                    //

                    Success = FALSE;

                    for ( j = 0; j < HeaderOldFileCount; j++ ) {

                        if (( HeaderInfo.OldFileInfoArray[ j ].OldFileCrc  == OldFileCrc  ) &&
                            ( HeaderInfo.OldFileInfoArray[ j ].OldFileSize == OldFileSize )) {

                            //
                            //  We have to remap the other old file here to make the
                            //  comparison.
                            //

                            PUCHAR CompareFileMapped;
                            ULONG  CompareFileSize;

                            Success = MyMapViewOfFileByHandle(
                                          HeaderInfo.OldFileInfoArray[ j ].OldFileHandle,
                                          &CompareFileSize,
                                          &CompareFileMapped
                                          );

                            if ( Success ) {

                                ASSERT( CompareFileSize == HeaderInfo.OldFileInfoArray[ j ].OldFileSize );

                                NormalizeOldFileImageForPatching(
                                    CompareFileMapped,
                                    CompareFileSize,
                                    OptionFlags,
                                    OptionData,
                                    NewFileCoffBase,
                                    NewFileCoffTime,
                                    HeaderInfo.OldFileInfoArray[ j ].IgnoreRangeCount,
                                    HeaderInfo.OldFileInfoArray[ j ].IgnoreRangeArray,
                                    HeaderInfo.OldFileInfoArray[ j ].RetainRangeCount,
                                    HeaderInfo.OldFileInfoArray[ j ].RetainRangeArray
                                    );

                                __try {
                                    Success = ( memcmp( CompareFileMapped, OldFileMapped, OldFileSize ) == 0 );
                                    }
                                __except( EXCEPTION_EXECUTE_HANDLER ) {
                                    SetLastError( GetExceptionCode() );
                                    Success = FALSE;
                                    }

                                UnmapViewOfFile( CompareFileMapped );

                                if ( Success ) {
                                    break;
                                    }
                                }
                            }
                        }

                    if ( ! Success ) {

                        //
                        //  Now see if old file is same as new file.
                        //

                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = 0;
                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = 0;
                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = NULL;
                        HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = NULL;

                        PatchBuffer = NULL;
                        PatchDataSize = 0;

                        if (( NewFileCrc == OldFileCrc  ) && ( NewFileSize == OldFileSize )) {

                            __try {
                                Success = ( memcmp( NewFileMapped, OldFileMapped, NewFileSize ) == 0 );
                                }
                            __except( EXCEPTION_EXECUTE_HANDLER ) {
                                SetLastError( GetExceptionCode() );
                                Success = FALSE;
                                }
                            }

                        if ( ! Success ) {

                            //
                            //  It's a unique file, so create the patch for it.
                            //
                            //  First we need to apply the transforms.
                            //

                            Transform = TRUE;

                            //
                            //  NOTE: This test for NtHeader is a perf tweak
                            //        for non-coff files.  If we ever have any
                            //        transformations for non-coff files, this
                            //        test should be removed.
                            //

                            if (( NtHeader ) && ( OldFileNtHeader )) {

                                //
                                //  See if rift table already provided by
                                //  caller so we don't need to generate it.
                                //

                                if (( OptionData ) &&
                                    ( OptionData->SizeOfThisStruct >= sizeof( PATCH_OPTION_DATA )) &&
                                    ( OptionData->SymbolOptionFlags & PATCH_SYMBOL_EXTERNAL_RIFT ) &&
                                    ( OptionData->OldFileSymbolPathArray ) &&
                                    ( OptionData->OldFileSymbolPathArray[ i ] )) {

                                    //
                                    //  This hidden private flag that tells us the rift information
                                    //  is already specified for us.  The LPCSTR pointer at
                                    //  OptionData->OldFileSymbolPathArray[ i ] is really a
                                    //  PRIFT_TABLE pointer.  Note that no validation of external
                                    //  rift data is performed (must be in ascending order with
                                    //  no OldRva duplicates).
                                    //
                                    //  We need to be careful to treat this external rift table
                                    //  differently in that we don't want to free the arrays
                                    //  like we do for our internally allocated rift tables.
                                    //  So, mark the RiftEntryAlloc field as zero to indicate
                                    //  that the rift arrays were not internally allocated.
                                    //

                                    PRIFT_TABLE ExternalRiftTable = (PVOID) OptionData->OldFileSymbolPathArray[ i ];

                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = 0;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = ExternalRiftTable->RiftEntryCount;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = ExternalRiftTable->RiftEntryArray;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = ExternalRiftTable->RiftUsageArray;
                                    }

                                else {

                                    //
                                    //  Need to allocate rift arrays and generate rift data.
                                    //  This (NewSize+OldSize)/sizeof(RIFT) allocation will
                                    //  provide enough space for one rift entry for every
                                    //  four bytes in the files.
                                    //

                                    ULONG AllocCount = ( NewFileSize + OldFileSize ) / sizeof( RIFT_ENTRY );

                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount = 0;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc = AllocCount;
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray = MyVirtualAlloc( AllocCount * sizeof( RIFT_ENTRY ));
                                    HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray = MyVirtualAlloc( AllocCount * sizeof( UCHAR ));

                                    if (( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryArray == NULL ) ||
                                        ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftUsageArray == NULL )) {

                                        Transform = FALSE;
                                        }

                                    else {

                                        Transform = GenerateRiftTable(
                                                        OldFileInfoArray[ i ].OldFileHandle,
                                                        OldFileMapped,
                                                        OldFileSize,
                                                        OldFileOriginalChecksum,
                                                        OldFileOriginalTimeDate,
                                                        NewFileHandle,
                                                        NewFileMapped,
                                                        NewFileSize,
                                                        OptionFlags,
                                                        OptionData,
                                                        i,
                                                        &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                        );

                                        ASSERT( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount <= HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryAlloc );

#ifdef TESTCODE
                                        printf( "\r%9d unique rift entries generated\n", HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount );
#endif
                                        }
                                    }

                                if ( Transform ) {

                                    if ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount != 0 ) {

                                        Transform = TransformOldFileImageForPatching(
                                                        ExtendedOptionFlags,
                                                        OldFileMapped,
                                                        OldFileSize,
                                                        NewFileResTime,
                                                        &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                        );
                                        }
                                    }
                                }

                            if ( Transform ) {

                                PatchBuffer = MyVirtualAlloc( PatchBufferSize );

                                if ( PatchBuffer != NULL ) {

                                    EstimatedLzxMemory = EstimateLzxCompressionMemoryRequirement(
                                                             OldFileSize,
                                                             NewFileSize,
                                                             OptionFlags
                                                             );

                                    SubAllocatorHandle = CreateSubAllocator(
                                                             EstimatedLzxMemory,
                                                             MINIMUM_VM_ALLOCATION
                                                             );

                                    if ( SubAllocatorHandle != NULL ) {

                                        __try {
                                            ErrorCode = CreateRawLzxPatchDataFromBuffers(
                                                            OldFileMapped,
                                                            OldFileSize,
                                                            NewFileMapped,
                                                            NewFileSize,
                                                            PatchBufferSize,
                                                            PatchBuffer,
                                                            &PatchDataSize,
                                                            OptionFlags,
                                                            OptionData,
                                                            SubAllocate,
                                                            SubAllocatorHandle,
                                                            ProgressCallback,
                                                            CallbackContext,
                                                            ProgressPosition,
                                                            ProgressMaximum
                                                            );
                                            }
                                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                                            ErrorCode = GetExceptionCode();
                                            }

                                        DestroySubAllocator( SubAllocatorHandle );

                                        if ( ErrorCode == NO_ERROR ) {

                                            Success = TRUE;

                                            if ( TryLzxBoth ) {

                                                AltExtendedOptionFlags = ExtendedOptionFlags;

                                                if (( NtHeader ) && ( ! ( AltExtendedOptionFlags | PATCH_TRANSFORM_NO_RELCALLS ))) {

                                                    //
                                                    //  Need to map, normalize, and transform
                                                    //  old file again without E8 transform.
                                                    //

                                                    AltExtendedOptionFlags |= PATCH_TRANSFORM_NO_RELCALLS;

                                                    UnmapViewOfFile( OldFileMapped );
                                                    OldFileMapped = NULL;

                                                    Success = MyMapViewOfFileByHandle(
                                                                  OldFileInfoArray[ i ].OldFileHandle,
                                                                  &OldFileSize,
                                                                  &OldFileMapped
                                                                  );

                                                    if ( Success ) {

                                                        Success = NormalizeOldFileImageForPatching(
                                                                      OldFileMapped,
                                                                      OldFileSize,
                                                                      OptionFlags,
                                                                      OptionData,
                                                                      NewFileCoffBase,
                                                                      NewFileCoffTime,
                                                                      OldFileInfoArray[ i ].IgnoreRangeCount,
                                                                      OldFileInfoArray[ i ].IgnoreRangeArray,
                                                                      OldFileInfoArray[ i ].RetainRangeCount,
                                                                      OldFileInfoArray[ i ].RetainRangeArray
                                                                      );

                                                        if ( Success ) {

                                                            if ( HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount != 0 ) {

                                                                Success = TransformOldFileImageForPatching(
                                                                              AltExtendedOptionFlags,
                                                                              OldFileMapped,
                                                                              OldFileSize,
                                                                              NewFileResTime,
                                                                              &HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable
                                                                              );
                                                                }
                                                            }
                                                        }
                                                    }

                                                if ( Success ) {

                                                    PatchAltBuffer = MyVirtualAlloc( PatchBufferSize );

                                                    if ( PatchAltBuffer != NULL ) {

                                                        SubAllocatorHandle = CreateSubAllocator(
                                                                                 EstimatedLzxMemory,
                                                                                 MINIMUM_VM_ALLOCATION
                                                                                 );

                                                        if ( SubAllocatorHandle != NULL ) {

                                                            PatchAltSize = 0;   // prevent compiler warning

                                                            __try {
                                                                ErrorCode = CreateRawLzxPatchDataFromBuffers(
                                                                                OldFileMapped,
                                                                                OldFileSize,
                                                                                NewFileMapped,
                                                                                NewFileSize,
                                                                                PatchBufferSize,
                                                                                PatchAltBuffer,
                                                                                &PatchAltSize,
                                                                                OptionFlags | PATCH_OPTION_USE_LZX_B,
                                                                                OptionData,
                                                                                SubAllocate,
                                                                                SubAllocatorHandle,
                                                                                ProgressCallback,
                                                                                CallbackContext,
                                                                                ProgressPosition + NewFileSize + LzxInsertSize( OldFileSize, OptionFlags ),
                                                                                ProgressMaximum
                                                                                );
                                                                }
                                                            __except( EXCEPTION_EXECUTE_HANDLER ) {
                                                                ErrorCode = GetExceptionCode();
                                                                }

                                                            DestroySubAllocator( SubAllocatorHandle );

                                                            if (( ErrorCode == NO_ERROR ) && ( PatchAltSize <= PatchDataSize )) {
                                                                MyVirtualFree( PatchBuffer );
                                                                PatchBuffer   = PatchAltBuffer;
                                                                PatchDataSize = PatchAltSize;
                                                                ExtendedOptionFlags = AltExtendedOptionFlags;
                                                                }
                                                            else {
                                                                MyVirtualFree( PatchAltBuffer );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                        else {
                                            SetLastError( ErrorCode );
                                            }
                                        }
                                    }
                                }
                            }

                        if ( Success ) {

                            PatchArray[ HeaderOldFileCount ].PatchData = PatchBuffer;
                            PatchArray[ HeaderOldFileCount ].PatchSize = PatchDataSize;

                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileHandle    = OldFileInfoArray[ i ].OldFileHandle;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileSize      = OldFileSize;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].OldFileCrc       = OldFileCrc;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].PatchDataSize    = PatchDataSize;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
                            HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

                            //
                            //  We overestimate (worst case) the possible
                            //  header size here.  Note that typical rift
                            //  encoding size is around 5 bytes per entry,
                            //  but we expect that to decrease when we switch
                            //  to Huffman encoding for the rift table.
                            //

                            HeaderSize += 32;
                            HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE );
                            HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE );
                            HeaderSize += HeaderInfo.OldFileInfoArray[ HeaderOldFileCount ].RiftTable.RiftEntryCount * sizeof( RIFT_ENTRY );

                            ++HeaderOldFileCount;
                            }
                        }
                    }
                }

            if ( OldFileMapped != NULL ) {
                UnmapViewOfFile( OldFileMapped );
                OldFileMapped = NULL;
                }

            if ( Success ) {

                ProgressPosition += ( LzxInsertSize( OldFileSize, OptionFlags ) + NewFileSize ) * ( TryLzxBoth ? 2 : 1 );

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximum
                              );
                }

            if ( ! Success ) {
                break;
                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    if ( Success ) {

        if (( OptionFlags & PATCH_OPTION_FAIL_IF_SAME_FILE ) &&
            ( HeaderOldFileCount == 1 ) &&
            ( PatchArray[ 0 ].PatchSize == 0 )) {

            SetLastError( ERROR_PATCH_SAME_FILE );
            Success = FALSE;
            }
        }

    PatchBuffer   = NULL;
    PatchDataSize = 0;

    if ( Success ) {

        //
        //  Create header
        //

        Success = FALSE;

        HeaderSize = ROUNDUP2( HeaderSize, 0x10000 );

        PatchBuffer = MyVirtualAlloc( HeaderSize );

        if ( PatchBuffer != NULL ) {

            Success = TRUE;

            //
            //  Compute size of PatchData without the header.
            //

            PatchDataSize = 0;

            for ( i = 0; i < HeaderOldFileCount; i++ ) {
                PatchDataSize += PatchArray[ i ].PatchSize;
                }

            //
            //  Don't need to encode NewFileResTime if the patch is simply
            //  a header with no patch data (new file is same as old file).
            //  We do still need the NewFileCoffTime and NewFileCoffBase
            //  though because we still need to normalize the old file.
            //

            if ( PatchDataSize == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                NewFileResTime = 0;
                }

            if ( ExtendedOptionFlags ) {
                OptionFlags |=  PATCH_OPTION_EXTENDED_OPTIONS;
                }
            else {
                OptionFlags &= ~PATCH_OPTION_EXTENDED_OPTIONS;
                }

            //
            //  Don't need to set PATCH_OPTION_LZX_LARGE unless an LZX window larger
            //  than 8Mb was used.  This allows backwards compatibility by default for
            //  files smaller than 8Mb.
            //

            if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {

                if ( LzxWindowSize( LargestOldFileSize, NewFileSize, OptionFlags ) <= LZX_MAXWINDOW_8 ) {

                        OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
                    }
                }


            HeaderInfo.Signature           = PATCH_SIGNATURE;
            HeaderInfo.OptionFlags         = OptionFlags;
            HeaderInfo.ExtendedOptionFlags = ExtendedOptionFlags;
            HeaderInfo.OptionData          = OptionData;
            HeaderInfo.NewFileCoffBase     = NewFileCoffBase;
            HeaderInfo.NewFileCoffTime     = NewFileCoffTime;
            HeaderInfo.NewFileResTime      = NewFileResTime;
            HeaderInfo.NewFileSize         = NewFileSize;
            HeaderInfo.NewFileCrc          = NewFileCrc;
            HeaderInfo.OldFileCount        = HeaderOldFileCount;
            HeaderInfo.NewFileTime         = 0;

            if ( ! ( OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

                HeaderInfo.NewFileTime = FileTimeToUlongTime( &NewFileTime );
                PatchFileTime = NULL;
                }

            HeaderSize = EncodePatchHeader( &HeaderInfo, PatchBuffer );

            PatchDataSize += HeaderSize + sizeof( ULONG );

            //
            //  Now we know the size of the patch file, so if we want to
            //  make sure it's not bigger than just compressing the new
            //  file, we need to compress the new file to see (the output
            //  of the compression is discarded -- we just want to know
            //  how big it would be.  Obviously if the patch file is bigger
            //  than the raw new file, no need to compress the new file to
            //  see if that is smaller!
            //

            if ( OptionFlags & PATCH_OPTION_FAIL_IF_BIGGER ) {

                if ( PatchDataSize > NewFileSize ) {
                    SetLastError( ERROR_PATCH_BIGGER_THAN_COMPRESSED );
                    Success = FALSE;
                    }

                else {

                    EstimatedLzxMemory = EstimateLzxCompressionMemoryRequirement(
                                             0,
                                             NewFileSize,
                                             0      // CAB has only 2Mb window size
                                             );

                    SubAllocatorHandle = CreateSubAllocator(
                                             EstimatedLzxMemory,
                                             MINIMUM_VM_ALLOCATION
                                             );

                    if ( SubAllocatorHandle != NULL ) {

                        NewFileCompressedSize = 0;  // prevent compiler warning

                        __try {
                            ErrorCode = RawLzxCompressBuffer(
                                            NewFileMapped,
                                            NewFileSize,
                                            0,
                                            NULL,
                                            &NewFileCompressedSize,
                                            SubAllocate,
                                            SubAllocatorHandle,
                                            ProgressCallback,
                                            CallbackContext,
                                            ProgressPosition,
                                            ProgressMaximum
                                            );
                            }
                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            ErrorCode = GetExceptionCode();
                            }

                        DestroySubAllocator( SubAllocatorHandle );

                        if ( ErrorCode == NO_ERROR ) {
                            if ( PatchDataSize > NewFileCompressedSize ) {
                                SetLastError( ERROR_PATCH_BIGGER_THAN_COMPRESSED );
                                Success = FALSE;
                                }
                            }
                        }
                    }

                if ( Success ) {

                    ProgressPosition += NewFileSize;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximum
                                  );
                    }
                }
            }
        }

    UnmapViewOfFile( NewFileMapped );

    if ( Success ) {

        Success = MyCreateMappedFileByHandle(
                      PatchFileHandle,
                      PatchDataSize,
                      &PatchFileMapped
                      );

        if ( Success ) {

            __try {

                p = PatchFileMapped;
                CopyMemory( p, PatchBuffer, HeaderSize );
                p += HeaderSize;

                for ( i = 0; i < HeaderOldFileCount; i++ ) {
                    if ( PatchArray[ i ].PatchSize != 0 ) {
                        CopyMemory( p, PatchArray[ i ].PatchData, PatchArray[ i ].PatchSize );
                        p += PatchArray[ i ].PatchSize;
                        }
                    }

                PatchFileCrc = Crc32( 0xFFFFFFFF, PatchFileMapped, PatchDataSize - sizeof( ULONG ));

                *(UNALIGNED ULONG *)( PatchFileMapped + PatchDataSize - sizeof( ULONG )) = PatchFileCrc;

                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                SetLastError( GetExceptionCode() );
                PatchDataSize = 0;
                Success = FALSE;
                }

            MyUnmapCreatedMappedFile(
                PatchFileHandle,
                PatchFileMapped,
                PatchDataSize,
                PatchFileTime
                );
            }
        }

    //
    //  Cleanup
    //

    if ( PatchBuffer ) {
        MyVirtualFree( PatchBuffer );
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if ( PatchArray[ i ].PatchData ) {
            MyVirtualFree( PatchArray[ i ].PatchData );
            }
        if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryAlloc ) {
            if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryArray ) {
                MyVirtualFree( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftEntryArray );
                }
            if ( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftUsageArray ) {
                MyVirtualFree( HeaderInfo.OldFileInfoArray[ i ].RiftTable.RiftUsageArray );
                }
            }
        }

    if ( Success ) {
        ASSERT( ProgressPosition == ProgressMaximum );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    )
    {
    HANDLE PatchFileHandle;
    HANDLE HeaderFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileA(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_RANDOM_ACCESS,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        HeaderFileHandle = CreateFileA(
                               PatchHeaderFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );


        if ( HeaderFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ExtractPatchHeaderToFileByHandles(
                          PatchFileHandle,
                          HeaderFileHandle
                          );

            CloseHandle( HeaderFileHandle );

            if ( ! Success ) {
                DeleteFileA( PatchHeaderFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    )
    {
    HANDLE PatchFileHandle;
    HANDLE HeaderFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileW(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_RANDOM_ACCESS,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        HeaderFileHandle = CreateFileW(
                               PatchHeaderFileName,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );


        if ( HeaderFileHandle != INVALID_HANDLE_VALUE ) {

            Success = ExtractPatchHeaderToFileByHandles(
                          PatchFileHandle,
                          HeaderFileHandle
                          );

            CloseHandle( HeaderFileHandle );

            if ( ! Success ) {
                DeleteFileW( PatchHeaderFileName );
                }
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    )
    {
    PPATCH_HEADER_INFO HeaderInfo;
    HANDLE   SubAllocator;
    PUCHAR   PatchFileMapped;
    FILETIME PatchFileTime;
    ULONG    PatchFileSize;
    ULONG    PatchFileCrc;
    ULONG    PatchHeaderSize;
    ULONG    ActualSize;
    ULONG    i;
    BOOL     Success;
    BOOL     Mapped;

    Success = FALSE;

    Mapped = MyMapViewOfFileByHandle(
                 PatchFileHandle,
                 &PatchFileSize,
                 &PatchFileMapped
                 );

    if ( Mapped ) {

        GetFileTime( PatchFileHandle, NULL, NULL, &PatchFileTime );

        PatchFileCrc = 0;

        SafeCompleteCrc32( PatchFileMapped, PatchFileSize, &PatchFileCrc );

        if ( PatchFileCrc == 0xFFFFFFFF ) {

            SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

            if ( SubAllocator ) {

                Success = DecodePatchHeader(
                              PatchFileMapped,
                              PatchFileSize,
                              SubAllocator,
                              &PatchHeaderSize,
                              &HeaderInfo
                              );

                if ( Success ) {

                    //
                    //  Header extraction is provided so that a header without
                    //  the bulk of the patch data can be used to determine if
                    //  an old file is correct for this patch header (can be
                    //  patched).
                    //
                    //  Since the extracted header will not be used to actually
                    //  apply, we don't need any of the header data that is
                    //  used only for transformation (RiftTable and NewResTime).
                    //  Since NewResTime is typically encoded as one byte (as
                    //  delta from NewCoffTime), we won't bother throwing it
                    //  away, but we will throw away the RiftTable.
                    //
                    //  Zero out the rift entry counts, then re-create the
                    //  patch header with the zeroed rift counts (create over
                    //  the write-copy mapped patch file buffer, then write
                    //  that buffer to disk).
                    //

                    for ( i = 0; i < HeaderInfo->OldFileCount; i++ ) {
                        HeaderInfo->OldFileInfoArray[ i ].RiftTable.RiftEntryCount = 0;
                        }

                    __try {

                        PatchHeaderSize = EncodePatchHeader( HeaderInfo, PatchFileMapped );

                        PatchFileCrc = Crc32( 0xFFFFFFFF, PatchFileMapped, PatchHeaderSize );

                        *(UNALIGNED ULONG *)( PatchFileMapped + PatchHeaderSize ) = PatchFileCrc;

                        Success = WriteFile(
                                      PatchHeaderFileHandle,
                                      PatchFileMapped,
                                      PatchHeaderSize + sizeof( ULONG ),
                                      &ActualSize,
                                      NULL
                                      );
                        }

                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        SetLastError( GetExceptionCode() );
                        Success = FALSE;
                        }

                    if ( Success ) {
                        SetFileTime( PatchHeaderFileHandle, NULL, NULL, &PatchFileTime );
                        }
                    }

                DestroySubAllocator( SubAllocator );
                }
            }

        else {
            SetLastError( ERROR_PATCH_CORRUPT );
            }

        UnmapViewOfFile( PatchFileMapped );
        }

    return Success;
    }


#endif // ! PATCH_APPLY_CODE_ONLY


//
//  Following group of functions and exported apis are exclusively for
//  applying patches.  If we're only compiling the create code, ignore
//  this group of functions.
//

#ifndef PATCH_CREATE_CODE_ONLY

PVOID
SaveRetainRanges(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN ULONG  RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    IN BOOL   SaveFromNewFile
    )
    {
    PUCHAR Buffer, p;
    ULONG  Offset;
    ULONG  TotalSize = 0;
    ULONG  i;

    for ( i = 0; i < RetainRangeCount; i++ ) {
        TotalSize += RetainRangeArray[ i ].LengthInBytes;
        }

    Buffer = MyVirtualAlloc( TotalSize );

    if ( Buffer ) {

        __try {

            p = Buffer;

            for ( i = 0; i < RetainRangeCount; i++ ) {

                Offset = SaveFromNewFile ?
                             RetainRangeArray[ i ].OffsetInNewFile :
                             RetainRangeArray[ i ].OffsetInOldFile;

                if (( Offset + RetainRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                    CopyMemory( p, MappedFile + Offset, RetainRangeArray[ i ].LengthInBytes );
                    }

                p += RetainRangeArray[ i ].LengthInBytes;
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode() );
            MyVirtualFree( Buffer );
            Buffer = NULL;
            }
        }

    return Buffer;
    }


BOOL
CreateNewFileFromOldFileMapped(
    IN  PUCHAR                   OldFileMapped,
    IN  ULONG                    OldFileSize,
    OUT HANDLE                   NewFileHandle,
    IN  PFILETIME                NewFileTime,
    IN  ULONG                    NewFileExpectedCrc,
    IN  ULONG                    RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE      RetainRangeArray,
    IN  PUCHAR                   RetainBuffer,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PUCHAR NewFileMapped;
    ULONG  NewFileCrc;
    BOOL   Success;
    ULONG  i;

    Success = MyCreateMappedFileByHandle(
                  NewFileHandle,
                  OldFileSize,
                  &NewFileMapped
                  );

    if ( Success ) {

        __try {

            CopyMemory( NewFileMapped, OldFileMapped, OldFileSize );

            NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, OldFileSize ) ^ 0xFFFFFFFF;

            if ( NewFileCrc == NewFileExpectedCrc ) {

                for ( i = 0; i < RetainRangeCount; i++ ) {
                    if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                        CopyMemory(
                            RetainRangeArray[ i ].OffsetInNewFile + NewFileMapped,
                            RetainBuffer,
                            RetainRangeArray[ i ].LengthInBytes
                            );
                        }
                    RetainBuffer += RetainRangeArray[ i ].LengthInBytes;
                    }

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              OldFileSize,
                              OldFileSize
                              );
                }

            else {
                SetLastError( ERROR_PATCH_WRONG_FILE );
                OldFileSize = 0;
                Success = FALSE;
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( GetExceptionCode());
            OldFileSize = 0;
            Success = FALSE;
            }

        MyUnmapCreatedMappedFile(
            NewFileHandle,
            NewFileMapped,
            OldFileSize,
            NewFileTime
            );
        }

    return Success;
    }


BOOL
CreateNewFileFromPatchData(
    IN  PUCHAR                   OldFileMapped,
    IN  ULONG                    OldFileSize,
    IN  PUCHAR                   PatchData,
    IN  ULONG                    PatchDataSize,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    NewFileSize,
    IN  PFILETIME                NewFileTime,
    IN  ULONG                    NewFileExpectedCrc,
    IN  ULONG                    RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE      RetainRangeArray,
    IN  PUCHAR                   RetainBuffer,
    IN  ULONG                    OptionFlags,
    IN  PVOID                    OptionData,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE SubAllocatorHandle;
    ULONG  EstimatedLzxMemory;
    PUCHAR NewFileMapped;
    ULONG  NewFileCrc;
    ULONG  ErrorCode;
    BOOL   Success;
    ULONG  i;

    UNREFERENCED_PARAMETER( OptionData );

    Success = MyCreateMappedFileByHandle(
                  NewFileHandle,
                  NewFileSize,
                  &NewFileMapped
                  );

    if ( Success ) {

        ErrorCode = NO_ERROR;

        EstimatedLzxMemory = EstimateLzxDecompressionMemoryRequirement(
                                 OldFileSize,
                                 NewFileSize,
                                 OptionFlags
                                 );

        SubAllocatorHandle = CreateSubAllocator(
                                 EstimatedLzxMemory,
                                 MINIMUM_VM_ALLOCATION
                                 );

        if ( SubAllocatorHandle != NULL ) {

            __try {

                ErrorCode = ApplyRawLzxPatchToBuffer(
                                OldFileMapped,
                                OldFileSize,
                                PatchData,
                                PatchDataSize,
                                NewFileMapped,
                                NewFileSize,
                                OptionFlags,
                                OptionData,
                                SubAllocate,
                                SubAllocatorHandle,
                                ProgressCallback,
                                CallbackContext,
                                0,
                                NewFileSize
                                );

                if ( ErrorCode == NO_ERROR ) {

                    NewFileCrc = Crc32( 0xFFFFFFFF, NewFileMapped, NewFileSize ) ^ 0xFFFFFFFF;

                    if ( NewFileCrc == NewFileExpectedCrc ) {

                        for ( i = 0; i < RetainRangeCount; i++ ) {
                            if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                                CopyMemory(
                                    RetainRangeArray[ i ].OffsetInNewFile + NewFileMapped,
                                    RetainBuffer,
                                    RetainRangeArray[ i ].LengthInBytes
                                    );
                                }
                            RetainBuffer += RetainRangeArray[ i ].LengthInBytes;
                            }
                        }

                    else {

                        ErrorCode = ERROR_PATCH_WRONG_FILE;

                        }
                    }

#ifdef TESTCODE

                if ( ErrorCode != NO_ERROR ) {

                    HANDLE hFile = CreateFile(
                                       "Wrong.out",
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                       );

                    if ( hFile != INVALID_HANDLE_VALUE ) {

                        DWORD Actual;

                        WriteFile( hFile, NewFileMapped, NewFileSize, &Actual, NULL );

                        CloseHandle( hFile );

                        }
                    }

#endif // TESTCODE

                }

            __except( EXCEPTION_EXECUTE_HANDLER ) {
                ErrorCode = GetExceptionCode();
                }

            DestroySubAllocator( SubAllocatorHandle );
            }

        MyUnmapCreatedMappedFile(
            NewFileHandle,
            NewFileMapped,
            ( ErrorCode == NO_ERROR ) ? NewFileSize : 0,
            NewFileTime
            );

        if ( ErrorCode == NO_ERROR ) {
            Success = TRUE;
            }
        else {
            SetLastError( ErrorCode );
            Success = FALSE;
            }
        }

    return Success;
    }


BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    PPATCH_HEADER_INFO HeaderInfo;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    ULONG    RetainRangeCount;
    PUCHAR   RetainBuffer;
    HANDLE   SubAllocator;
    ULONG    PatchHeaderSize;
    FILETIME NewFileTime;
    PUCHAR   PatchFileMapped;
    ULONG    PatchFileSize;
    ULONG    PatchFileCrc;
    PUCHAR   PatchData;
    PUCHAR   OldFileMapped;
    ULONG    OldFileSize;
    ULONG    OldFileCrc;
    BOOL     Mapped;
    BOOL     Success;
    BOOL     Finished;
    ULONG    i;

    Success = FALSE;

    Mapped = MyMapViewOfFileByHandle(
                 PatchFileHandle,
                 &PatchFileSize,
                 &PatchFileMapped
                 );

    if ( Mapped ) {

        GetFileTime( PatchFileHandle, NULL, NULL, &NewFileTime );

        PatchFileCrc = 0;

        SafeCompleteCrc32( PatchFileMapped, PatchFileSize, &PatchFileCrc );

        if ( PatchFileCrc == 0xFFFFFFFF ) {

            SubAllocator = CreateSubAllocator( 0x10000, 0x10000 );

            if ( SubAllocator ) {

                Success = DecodePatchHeader(
                              PatchFileMapped,
                              PatchFileSize,
                              SubAllocator,
                              &PatchHeaderSize,
                              &HeaderInfo
                              );

                if ( Success ) {

                    //
                    //  Patch is valid.
                    //

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  0,
                                  HeaderInfo->NewFileSize
                                  );

                    if ( Success ) {

                        Finished = FALSE;
                        Success  = FALSE;

                        if (( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) &&
                            ( HeaderInfo->NewFileTime != 0 )) {

                            UlongTimeToFileTime( HeaderInfo->NewFileTime, &NewFileTime );
                            }

                        OldFileSize = GetFileSize( OldFileHandle, NULL );

                        //
                        //  First see if the old file is really the new file.
                        //

                        if ( OldFileSize == HeaderInfo->NewFileSize ) {

                            Mapped = MyMapViewOfFileByHandle(
                                         OldFileHandle,
                                         &OldFileSize,
                                         &OldFileMapped
                                         );

                            if ( ! Mapped ) {
                                Success  = FALSE;
                                Finished = TRUE;
                                }

                            else {

                                RetainBuffer     = NULL;
                                OldFileCrc       = 0;
                                OldFileInfo      = &HeaderInfo->OldFileInfoArray[ 0 ];
                                RetainRangeCount = OldFileInfo->RetainRangeCount;
                                RetainRangeArray = OldFileInfo->RetainRangeArray;

                                if (( RetainRangeCount != 0 ) &&
                                    ( ! ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ))) {

                                    RetainBuffer = SaveRetainRanges(
                                                       OldFileMapped,
                                                       OldFileSize,
                                                       RetainRangeCount,
                                                       RetainRangeArray,
                                                       TRUE
                                                       );

                                    if ( RetainBuffer == NULL ) {
                                        Finished = TRUE;
                                        }
                                    }

                                if ( ! Finished ) {

                                    __try {

                                        //
                                        //  First see if they match exact, without
                                        //  normalizing.
                                        //

                                        for ( i = 0; i < RetainRangeCount; i++ ) {
                                            if (( RetainRangeArray[ i ].OffsetInNewFile + RetainRangeArray[ i ].LengthInBytes ) <= OldFileSize ) {
                                                ZeroMemory( OldFileMapped + RetainRangeArray[ i ].OffsetInNewFile, RetainRangeArray[ i ].LengthInBytes );
                                                }
                                            }

                                        OldFileCrc = Crc32( 0xFFFFFFFF, OldFileMapped, OldFileSize ) ^ 0xFFFFFFFF;

                                        if ( OldFileCrc != HeaderInfo->NewFileCrc ) {

                                            //
                                            //  Don't match exact, so try with
                                            //  normalizing.
                                            //
                                            //  NOTE: We're assuming here that the
                                            //  zeroed retain ranges don't overlap
                                            //  with the binding info that we're
                                            //  correcting.
                                            //

                                            NormalizeOldFileImageForPatching(
                                                OldFileMapped,
                                                OldFileSize,
                                                HeaderInfo->OptionFlags,
                                                HeaderInfo->OptionData,
                                                HeaderInfo->NewFileCoffBase,
                                                HeaderInfo->NewFileCoffTime,
                                                0,
                                                NULL,
                                                0,
                                                NULL
                                                );

                                            OldFileCrc = Crc32( 0xFFFFFFFF, OldFileMapped, OldFileSize ) ^ 0xFFFFFFFF;
                                            }
                                        }

                                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                                        SetLastError( GetExceptionCode() );
                                        Finished = TRUE;
                                        }

                                    if (( ! Finished ) &&
                                        ( OldFileCrc  == HeaderInfo->NewFileCrc  ) &&
                                        ( OldFileSize == HeaderInfo->NewFileSize )) {

                                        Finished = TRUE;

                                        if ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_EXACT ) {
                                            SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                            Success = FALSE;
                                            }
                                        else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                            Success = TRUE;
                                            }
                                        else {
                                            Success = CreateNewFileFromOldFileMapped(
                                                          OldFileMapped,
                                                          OldFileSize,
                                                          NewFileHandle,
                                                          &NewFileTime,
                                                          HeaderInfo->NewFileCrc,
                                                          RetainRangeCount,
                                                          RetainRangeArray,
                                                          RetainBuffer,
                                                          ProgressCallback,
                                                          CallbackContext
                                                          );
                                            }
                                        }

                                    if ( RetainBuffer != NULL ) {
                                        MyVirtualFree( RetainBuffer );
                                        }
                                    }

                                UnmapViewOfFile( OldFileMapped );
                                }
                            }

                        if ( ! Finished ) {

                            //
                            //  Now see if the old file matches one of the old
                            //  files we have in our patch file.  For each set
                            //  of old file info in our patch file, we have to
                            //  remap the old file to check it since each old
                            //  file might have different ignore range parameters
                            //  (we modify the buffer for the ignore ranges).
                            //

                            PatchData = PatchFileMapped + PatchHeaderSize;
                            Success   = FALSE;

                            for ( i = 0; ( i < HeaderInfo->OldFileCount ) && ( ! Finished ) && ( ! Success ); i++ ) {

                                OldFileInfo = &HeaderInfo->OldFileInfoArray[ i ];

                                if ( OldFileInfo->OldFileSize == OldFileSize ) {

                                    Mapped = MyMapViewOfFileByHandle(
                                                 OldFileHandle,
                                                 &OldFileSize,
                                                 &OldFileMapped
                                                 );

                                    if ( ! Mapped ) {
                                        Finished = TRUE;
                                        }

                                    else {

                                        RetainBuffer = NULL;

                                        if (( OldFileInfo->RetainRangeCount != 0 ) &&
                                            ( ! ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ))) {

                                            RetainBuffer = SaveRetainRanges(
                                                               OldFileMapped,
                                                               OldFileSize,
                                                               OldFileInfo->RetainRangeCount,
                                                               OldFileInfo->RetainRangeArray,
                                                               FALSE
                                                               );

                                            if ( RetainBuffer == NULL ) {
                                                Finished = TRUE;
                                                }
                                            }

                                        if ( ! Finished ) {

                                            NormalizeOldFileImageForPatching(
                                                OldFileMapped,
                                                OldFileSize,
                                                HeaderInfo->OptionFlags,
                                                HeaderInfo->OptionData,
                                                HeaderInfo->NewFileCoffBase,
                                                HeaderInfo->NewFileCoffTime,
                                                OldFileInfo->IgnoreRangeCount,
                                                OldFileInfo->IgnoreRangeArray,
                                                OldFileInfo->RetainRangeCount,
                                                OldFileInfo->RetainRangeArray
                                                );

                                            OldFileCrc = 0;

                                            if (( SafeCompleteCrc32( OldFileMapped, OldFileSize, &OldFileCrc )) &&
                                                ( OldFileCrc  == OldFileInfo->OldFileCrc  ) &&
                                                ( OldFileSize == OldFileInfo->OldFileSize )) {

                                                //
                                                //  CRC's match
                                                //

                                                if ( OldFileInfo->PatchDataSize == 0 ) {
                                                    if ( ApplyOptionFlags & APPLY_OPTION_FAIL_IF_CLOSE ) {
                                                        SetLastError( ERROR_PATCH_NOT_NECESSARY );
                                                        Finished = TRUE;
                                                        }
                                                    else if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else {
                                                        Success = CreateNewFileFromOldFileMapped(
                                                                      OldFileMapped,
                                                                      OldFileSize,
                                                                      NewFileHandle,
                                                                      &NewFileTime,
                                                                      HeaderInfo->NewFileCrc,
                                                                      OldFileInfo->RetainRangeCount,
                                                                      OldFileInfo->RetainRangeArray,
                                                                      RetainBuffer,
                                                                      ProgressCallback,
                                                                      CallbackContext
                                                                      );
                                                        if ( ! Success ) {
                                                            Finished = TRUE;
                                                            }
                                                        }
                                                    }

                                                else {

                                                    if ( ApplyOptionFlags & APPLY_OPTION_TEST_ONLY ) {
                                                        Success = TRUE;
                                                        }
                                                    else if (( PatchData + OldFileInfo->PatchDataSize ) > ( PatchFileMapped + PatchFileSize )) {
                                                        SetLastError( ERROR_PATCH_NOT_AVAILABLE );
                                                        Finished = TRUE;
                                                        }
                                                    else {

                                                        Success = TRUE;

                                                        if ( OldFileInfo->RiftTable.RiftEntryCount != 0 ) {

                                                            Success = TransformOldFileImageForPatching(
                                                                          HeaderInfo->ExtendedOptionFlags,
                                                                          OldFileMapped,
                                                                          OldFileSize,
                                                                          HeaderInfo->NewFileResTime,
                                                                          &OldFileInfo->RiftTable
                                                                          );
                                                            }

                                                        if ( Success ) {

                                                            Success = CreateNewFileFromPatchData(
                                                                           OldFileMapped,
                                                                           OldFileSize,
                                                                           PatchData,
                                                                           OldFileInfo->PatchDataSize,
                                                                           NewFileHandle,
                                                                           HeaderInfo->NewFileSize,
                                                                           &NewFileTime,
                                                                           HeaderInfo->NewFileCrc,
                                                                           OldFileInfo->RetainRangeCount,
                                                                           OldFileInfo->RetainRangeArray,
                                                                           RetainBuffer,
                                                                           HeaderInfo->OptionFlags,
                                                                           HeaderInfo->OptionData,
                                                                           ProgressCallback,
                                                                           CallbackContext
                                                                           );
                                                            }

                                                        if ( ! Success ) {
                                                            Finished = TRUE;
                                                            }
                                                        }
                                                    }
                                                }

                                            if ( RetainBuffer != NULL ) {
                                                MyVirtualFree( RetainBuffer );
                                                }
                                            }

                                        UnmapViewOfFile( OldFileMapped );
                                        }
                                    }

                                PatchData += OldFileInfo->PatchDataSize;
                                }

                            if (( ! Finished ) && ( ! Success )) {
                                SetLastError( ERROR_PATCH_WRONG_FILE );
                                }
                            }
                        }
                    }

                DestroySubAllocator( SubAllocator );
                }
            }

        else {
            SetLastError( ERROR_PATCH_CORRUPT );
            }

        UnmapViewOfFile( PatchFileMapped );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileByHandles(
               PatchFileHandle,
               OldFileHandle,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileByHandlesEx(
               PatchFileHandle,
               OldFileHandle,
               NewFileHandle,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileA(
               PatchFileName,
               OldFileName,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    )
    {
    return ApplyPatchToFileExA(
               PatchFileName,
               OldFileName,
               NewFileName,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE PatchFileHandle;
    HANDLE OldFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileA(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        OldFileHandle = CreateFileA(
                            OldFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( OldFileHandle != INVALID_HANDLE_VALUE ) {

            NewFileHandle = CreateFileA(
                                NewFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

            if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

                Success = ApplyPatchToFileByHandlesEx(
                              PatchFileHandle,
                              OldFileHandle,
                              NewFileHandle,
                              ApplyOptionFlags,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( NewFileHandle );

                if ( ! Success ) {
                    DeleteFileA( NewFileName );
                    }
                }

            CloseHandle( OldFileHandle );
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    )
    {
    return ApplyPatchToFileW(
               PatchFileName,
               OldFileName,
               INVALID_HANDLE_VALUE,
               ApplyOptionFlags | APPLY_OPTION_TEST_ONLY
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    )
    {
    return ApplyPatchToFileExW(
               PatchFileName,
               OldFileName,
               NewFileName,
               ApplyOptionFlags,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    HANDLE PatchFileHandle;
    HANDLE OldFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success = FALSE;

    PatchFileHandle = CreateFileW(
                          PatchFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

        OldFileHandle = CreateFileW(
                            OldFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( OldFileHandle != INVALID_HANDLE_VALUE ) {

            NewFileHandle = CreateFileW(
                                NewFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

            if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

                Success = ApplyPatchToFileByHandlesEx(
                              PatchFileHandle,
                              OldFileHandle,
                              NewFileHandle,
                              ApplyOptionFlags,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( NewFileHandle );

                if ( ! Success ) {
                    DeleteFileW( NewFileName );
                    }
                }

            CloseHandle( OldFileHandle );
            }

        CloseHandle( PatchFileHandle );
        }

    return Success;
    }

#endif // ! PATCH_CREATE_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\patchlzx.h ===
#ifndef _PATCH_LZX_H_
#define _PATCH_LZX_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The patch code is using the LZX_MAXWINDOW value to compute
//  progress ranges.  We need a better way to compute progress
//  ranges that doesn't need to know the details of the underlying
//  compression engine.
//

#define LZX_MAXWINDOW_8   (8*1024*1024)  // 8MB
#define LZX_MAXWINDOW_32 (32*1024*1024)  // 32MB

#ifndef PFNALLOC
typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );
#endif

//
//  The PFNALLOC function must return zeroed memory its caller, or NULL to
//  indicate insufficient memory.
//
//  Note that no PFNFREE corresponding to PFNALLOC is specified.  Functions
//  that take a PFNALLOC parameter use that routine for multiple allocations,
//  but it is the responsibility of the caller to free any allocations made
//  through the PFNALLOC allocator after the function has returned.  This
//  scheme is used to facilitate multiple allocations that can be freed with
//  a single call such as a HeapCreate/HeapAlloc[...]/HeapDestroy sequence.
//

ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    );

ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    );

ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags
    );

ULONG
__fastcall
LzxInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags
    );

#ifdef __cplusplus
}
#endif

#endif // _PATCH_LZX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2000.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for files >8MB

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0x80FF0007

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\patchlzx.c ===
#include <precomp.h>

//
//  patchlzx.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-1998.
//
//  MICROSOFT CONFIDENTIAL
//


#define LZX_BLOCKSIZE  0x8000   // 32K
#define LZX_MINWINDOW  0x20000  // 128K


typedef struct _LZX_OUTPUT_CONTEXT {
    PUCHAR                   PatchBufferPointer;
    ULONG                    PatchBufferSize;
    ULONG                    PatchSize;
    BOOL                     DiscardOutput;
    } LZX_OUTPUT_CONTEXT, *PLZX_OUTPUT_CONTEXT;


ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags
    )
    {
    ULONG WindowSize;
    ULONG DataSize;

    DataSize = ROUNDUP2( OldDataSize, LZX_BLOCKSIZE ) + NewDataSize;

    if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {
        if ( DataSize > LZX_MAXWINDOW_32 ) {
             DataSize = LZX_MAXWINDOW_32;
             }
        }
    else {
        if ( DataSize > LZX_MAXWINDOW_8 ) {
             DataSize = LZX_MAXWINDOW_8;
             }
        }

    for ( WindowSize = LZX_MINWINDOW;
          WindowSize < DataSize;
          WindowSize <<= 1
        );

    return WindowSize;
    }


ULONG
__fastcall
LzxInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags
    )
    {

    if ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) {
        if ( OldDataSize > LZX_MAXWINDOW_32 ) {
             OldDataSize = LZX_MAXWINDOW_32;
             }
        }
    else {
        if ( OldDataSize > LZX_MAXWINDOW_8 ) {
             OldDataSize = LZX_MAXWINDOW_8;
             }
        }

    return OldDataSize;
    }


//
//  Following group of functions and exported apis are exclusively for
//  creating patches.  If we're only compiling the apply code, ignore
//  this group of functions.
//

#ifndef PATCH_APPLY_CODE_ONLY


ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    )
    {
    ULONG WindowSize = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

    //
    //  Currently the LZX engine requires 9 times the size of the window
    //  plus a fixed overhead of just under 0x1A0000 bytes (1.7MB).
    //

    return (( WindowSize * 9 ) + 0x1A0000 );
    }


int
__stdcall
MyLzxOutputCallback(
    PVOID  CallerContext,
    PUCHAR CompressedData,
    LONG   CompressedSize,
    LONG   UncompressedSize
    )
    {
    PLZX_OUTPUT_CONTEXT OutputContext = CallerContext;

    UNREFERENCED_PARAMETER( UncompressedSize );

    OutputContext->PatchSize += CompressedSize + sizeof( USHORT );

    if ( ! OutputContext->DiscardOutput ) {
        if ( OutputContext->PatchSize <= OutputContext->PatchBufferSize ) {
            *(UNALIGNED USHORT *)( OutputContext->PatchBufferPointer ) = (USHORT) CompressedSize;
            memcpy( OutputContext->PatchBufferPointer + sizeof( USHORT ), CompressedData, CompressedSize );
            OutputContext->PatchBufferPointer += CompressedSize + sizeof( USHORT );
            }
        }

    return TRUE;
    }


ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    LZX_OUTPUT_CONTEXT OutputContext;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    ULONG  LzxOptE8;
    LONG   LzxStatus;
    PUCHAR BlockPointer;
    ULONG  BytesRemaining;
    ULONG  OddBytes;
    LONG   Estimate;
    BOOL   Success;
    ULONG  ErrorCode;

    UNREFERENCED_PARAMETER( OptionData );

    ErrorCode = ERROR_INVALID_PARAMETER;

    if ( OptionFlags & ( PATCH_OPTION_USE_LZX_A | PATCH_OPTION_USE_LZX_B )) {

        ErrorCode = ERROR_OUTOFMEMORY;

        OutputContext.DiscardOutput = TRUE;

        LzxWindow = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

        Success = LZX_EncodeInit(
                      &LzxContext,
                      LzxWindow,
                      LZX_BLOCKSIZE,
                      pfnAlloc,
                      AllocHandle,
                      MyLzxOutputCallback,
                      &OutputContext
                      );

        if ( Success ) {

            ULONG ProgressPosition = ProgressInitialValue;

            ErrorCode        = ERROR_PATCH_ENCODE_FAILURE;
            BlockPointer     = OldDataBuffer;
            BytesRemaining   = LzxInsertSize( OldDataSize, OptionFlags );
            OddBytes         = BytesRemaining % LZX_BLOCKSIZE;

#ifdef TRACING
            EncTracingDefineOffsets(
                LzxWindow,
                OddBytes ? (LZX_BLOCKSIZE - OddBytes) : 0,
                OddBytes ? (BytesRemaining + LZX_BLOCKSIZE - OddBytes) : BytesRemaining
                );
#endif

            if ( OddBytes ) {

                PUCHAR PadBuffer = pfnAlloc( AllocHandle, LZX_BLOCKSIZE );

                if ( PadBuffer == NULL ) {
                    ErrorCode = ERROR_OUTOFMEMORY;
                    Success   = FALSE;
                    }
                else {

                    memcpy(
                        PadBuffer + LZX_BLOCKSIZE - OddBytes,
                        BlockPointer,
                        OddBytes
                        );

                    Success = LZX_EncodeInsertDictionary(
                                  LzxContext,
                                  PadBuffer,
                                  LZX_BLOCKSIZE
                                  );

                    if ( Success ) {

                        ProgressPosition += OddBytes;

                        Success = ProgressCallbackWrapper(
                                      ProgressCallback,
                                      CallbackContext,
                                      ProgressPosition,
                                      ProgressMaximumValue
                                      );

                        if ( ! Success ) {
                            ErrorCode = GetLastError();
                            }
                        }

                    BlockPointer   += OddBytes;
                    BytesRemaining -= OddBytes;
                    }
                }

            while (( BytesRemaining ) && ( Success )) {

                ASSERT(( BytesRemaining % LZX_BLOCKSIZE ) == 0 );

                Success = LZX_EncodeInsertDictionary(
                              LzxContext,
                              BlockPointer,
                              LZX_BLOCKSIZE
                              );

                if ( Success ) {

                    ProgressPosition += LZX_BLOCKSIZE;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximumValue
                                  );

                    if ( ! Success ) {
                        ErrorCode = GetLastError();
                        }
                    }

                BlockPointer   += LZX_BLOCKSIZE;
                BytesRemaining -= LZX_BLOCKSIZE;
                }

            if ( Success ) {

                LZX_EncodeResetState( LzxContext );

                LzxOptE8 = 0;

                NtHeader = GetNtHeader( NewDataBuffer, NewDataSize );

                //
                //  If file has MZ signature AND it's NOT a PE image,
                //  OR it's a PE image AND it's an i386 image, turn on
                //  the i386-specific E8 call translation optimization.
                //

                if (( OptionFlags & PATCH_OPTION_USE_LZX_B ) &&
                    ((( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) ||
                     (( ! NtHeader ) && ( *(UNALIGNED USHORT *)NewDataBuffer == 0x5A4D )))) {

                    LzxOptE8 = NewDataSize;
                    }

                OutputContext.PatchBufferSize    = PatchBufferSize;
                OutputContext.PatchBufferPointer = PatchBuffer;
                OutputContext.PatchSize          = 0;
                OutputContext.DiscardOutput      = FALSE;

                BlockPointer   = NewDataBuffer;
                BytesRemaining = NewDataSize;
                LzxStatus      = ENCODER_SUCCESS;
                Success        = TRUE;

                while (( BytesRemaining >= LZX_BLOCKSIZE ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

                    LzxStatus = LZX_Encode(
                                    LzxContext,
                                    BlockPointer,
                                    LZX_BLOCKSIZE,
                                    &Estimate,
                                    LzxOptE8
                                    );

                    if ( LzxStatus == ENCODER_SUCCESS ) {

                        ProgressPosition += LZX_BLOCKSIZE;

                        Success = ProgressCallbackWrapper(
                                      ProgressCallback,
                                      CallbackContext,
                                      ProgressPosition,
                                      ProgressMaximumValue
                                      );

                        if ( ! Success ) {
                            ErrorCode = GetLastError();
                            }
                        }

                    BlockPointer   += LZX_BLOCKSIZE;
                    BytesRemaining -= LZX_BLOCKSIZE;
                    }

                if (( BytesRemaining ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

                    LzxStatus = LZX_Encode(
                                    LzxContext,
                                    BlockPointer,
                                    BytesRemaining,
                                    &Estimate,
                                    LzxOptE8
                                    );

                    if ( LzxStatus == ENCODER_SUCCESS ) {

                        ProgressPosition += BytesRemaining;

                        Success = ProgressCallbackWrapper(
                                      ProgressCallback,
                                      CallbackContext,
                                      ProgressPosition,
                                      ProgressMaximumValue
                                      );

                        if ( ! Success ) {
                            ErrorCode = GetLastError();
                            }
                        }
                    }

                if (( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

                    Success = LZX_EncodeFlush( LzxContext );

                    if ( Success ) {

                        ErrorCode  = ERROR_INSUFFICIENT_BUFFER;
                        *PatchSize = OutputContext.PatchSize;

                        if ( OutputContext.PatchSize <= OutputContext.PatchBufferSize ) {

                            ErrorCode = NO_ERROR;

                            }
                        }
                    }
                }
            }
        }

    return ErrorCode;
    }


ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    UP_IMAGE_NT_HEADERS32 NtHeader;
    LZX_OUTPUT_CONTEXT OutputContext;
    ULONG  ProgressPosition;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    ULONG  LzxOptE8;
    LONG   LzxStatus;
    PUCHAR BlockPointer;
    ULONG  BytesRemaining;
    LONG   Estimate;
    BOOL   Success;
    ULONG  ErrorCode;

    if ( OutDataBufferSize == 0 ) {
         OutDataBuffer = NULL;
         }
    else if ( OutDataBuffer == NULL ) {
         OutDataBufferSize = 0;
         }

    ErrorCode = ERROR_OUTOFMEMORY;

    OutputContext.DiscardOutput      = OutDataBuffer ? FALSE : TRUE;
    OutputContext.PatchBufferSize    = OutDataBufferSize;
    OutputContext.PatchBufferPointer = OutDataBuffer;
    OutputContext.PatchSize          = 0;

    LzxWindow = LzxWindowSize( 0, InDataSize, 0 );

    Success = LZX_EncodeInit(
                  &LzxContext,
                  LzxWindow,
                  LZX_BLOCKSIZE,
                  pfnAlloc,
                  AllocHandle,
                  MyLzxOutputCallback,
                  &OutputContext
                  );

    if ( Success ) {

        LzxOptE8 = 0;
        NtHeader = GetNtHeader( InDataBuffer, InDataSize );

        //
        //  If file has MZ signature AND it's NOT a PE image,
        //  OR it's a PE image AND it's an i386 image, turn on
        //  the i386-specific E8 call translation optimization.
        //

        if ((( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) ||
            (( ! NtHeader ) && ( *(UNALIGNED USHORT *)InDataBuffer == 0x5A4D ))) {

            LzxOptE8 = InDataSize;
            }

        ProgressPosition = ProgressInitialValue;
        ErrorCode        = ERROR_PATCH_ENCODE_FAILURE;
        BlockPointer     = InDataBuffer;
        BytesRemaining   = InDataSize;
        LzxStatus        = ENCODER_SUCCESS;
        Success          = TRUE;

        while (( BytesRemaining >= LZX_BLOCKSIZE ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            LzxStatus = LZX_Encode(
                            LzxContext,
                            BlockPointer,
                            LZX_BLOCKSIZE,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus == ENCODER_SUCCESS ) {

                ProgressPosition += LZX_BLOCKSIZE;

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximumValue
                              );

                if ( ! Success ) {
                    ErrorCode = GetLastError();
                    }
                }

            BlockPointer   += LZX_BLOCKSIZE;
            BytesRemaining -= LZX_BLOCKSIZE;
            }

        if (( BytesRemaining ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            LzxStatus = LZX_Encode(
                            LzxContext,
                            BlockPointer,
                            BytesRemaining,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus == ENCODER_SUCCESS ) {

                ProgressPosition += BytesRemaining;

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximumValue
                              );

                if ( ! Success ) {
                    ErrorCode = GetLastError();
                    }
                }
            }

        if (( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            Success = LZX_EncodeFlush( LzxContext );

            if ( Success ) {

                if ( OutDataSize ) {
                    *OutDataSize = OutputContext.PatchSize;
                    }

                if (( OutDataBufferSize ) && ( OutputContext.PatchSize > OutDataBufferSize )) {
                    ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                    }
                else {
                    ErrorCode = NO_ERROR;
                    }
                }
            }
        }

    return ErrorCode;
    }

#endif // ! PATCH_APPLY_CODE_ONLY


//
//  Following group of functions and exported apis are exclusively for
//  applying patches.  If we're only compiling the create code, ignore
//  this group of functions.
//

#ifndef PATCH_CREATE_CODE_ONLY


ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags
    )
    {
    ULONG WindowSize = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

    //
    //  Currently the LZX decompression engine requires the size of the
    //  window plus some slop and the size of the context.  We'll add 64K
    //  to cover the context size and slop.
    //

    return ( WindowSize + 0x10000 );
    }


ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  PVOID    OptionData,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    PVOID LzxContext;
    ULONG LzxWindow;
    BOOL  Success;
    ULONG ErrorCode;

    UNREFERENCED_PARAMETER( OptionData );

    ErrorCode = ERROR_INVALID_PARAMETER;

    if ( OptionFlags & ( PATCH_OPTION_USE_LZX_A | PATCH_OPTION_USE_LZX_B )) {

        ErrorCode = ERROR_OUTOFMEMORY;

        LzxWindow = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags );

        Success = LZX_DecodeInit(
                      &LzxContext,
                      LzxWindow,
                      pfnAlloc,
                      AllocHandle
                      );

        if ( Success ) {

            ErrorCode = ERROR_PATCH_DECODE_FAILURE;

            Success = LZX_DecodeInsertDictionary(
                          LzxContext,
                          OldDataBuffer,
                          LzxInsertSize( OldDataSize, OptionFlags )
                          );

            if ( Success ) {

                PUCHAR CompressedInputPointer     = PatchDataBuffer;
                PUCHAR CompressedInputExtent      = CompressedInputPointer + PatchDataSize;
                PUCHAR UncompressedOutputPointer  = NewDataBuffer;
                ULONG  UncompressedBytesRemaining = NewDataSize;
                ULONG  ProgressPosition           = ProgressInitialValue;
                LONG   LzxStatus                  = 0;
                LONG   ActualSize;
                ULONG  UncompressedBlockSize;
                ULONG  CompressedBlockSize;

                while (( UncompressedBytesRemaining ) && ( LzxStatus == 0 )) {

                    UncompressedBlockSize = ( UncompressedBytesRemaining > LZX_BLOCKSIZE ) ? LZX_BLOCKSIZE : UncompressedBytesRemaining;

                    CompressedBlockSize = *(UNALIGNED USHORT *)( CompressedInputPointer );

                    CompressedInputPointer += sizeof( USHORT );

                    if (( CompressedInputPointer + CompressedBlockSize ) > CompressedInputExtent ) {
                        LzxStatus = 1;
                        break;
                        }

                    LzxStatus = LZX_Decode(
                                    LzxContext,
                                    UncompressedBlockSize,
                                    CompressedInputPointer,
                                    CompressedBlockSize,
                                    UncompressedOutputPointer,
                                    UncompressedBlockSize,
                                    &ActualSize
                                    );

                    CompressedInputPointer     += CompressedBlockSize;
                    UncompressedOutputPointer  += ActualSize;
                    UncompressedBytesRemaining -= ActualSize;
                    ProgressPosition           += ActualSize;

                    Success = ProgressCallbackWrapper(
                                  ProgressCallback,
                                  CallbackContext,
                                  ProgressPosition,
                                  ProgressMaximumValue
                                  );

                    if ( ! Success ) {
                        ErrorCode = GetLastError();
                        LzxStatus = 1;
                        }
                    }

                if ( LzxStatus == 0 ) {
                    ErrorCode = NO_ERROR;
                    }
                }
            }
        }

    return ErrorCode;
    }

#endif // ! PATCH_CREATE_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\patchprv.h ===
//
//  patchprv.h
//
//  Private interface options for creating patch files.
//
//  Author: Tom McGuire (tommcg) 2/98
//
//  Copyright (C) Microsoft, 1997-1998.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCHPRV_H_
#define _PATCHPRV_H_

#ifdef __cplusplus
extern "C" {
#endif

#define PATCH_SIGNATURE     '91AP'          // PA19 patch signature

typedef struct _RIFT_ENTRY {
    ULONG OldFileRva;
    ULONG NewFileRva;
    } RIFT_ENTRY, *PRIFT_ENTRY;

typedef struct _RIFT_TABLE {
    ULONG       RiftEntryCount;
    ULONG       RiftEntryAlloc;
    PRIFT_ENTRY RiftEntryArray;
    PUCHAR      RiftUsageArray;
    } RIFT_TABLE, *PRIFT_TABLE;

typedef struct _PATCH_HEADER_OLD_FILE_INFO {
    HANDLE              OldFileHandle;
    ULONG               OldFileSize;
    ULONG               OldFileCrc;
    ULONG               PatchDataSize;
    ULONG               IgnoreRangeCount;
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    RIFT_TABLE          RiftTable;
    } HEADER_OLD_FILE_INFO, *PHEADER_OLD_FILE_INFO;

typedef struct _PATCH_HEADER_INFO {
    ULONG Signature;
    ULONG OptionFlags;
    ULONG ExtendedOptionFlags;
    PVOID OptionData;
    ULONG NewFileCoffBase;
    ULONG NewFileCoffTime;
    ULONG NewFileResTime;
    ULONG NewFileTime;
    ULONG NewFileSize;
    ULONG NewFileCrc;
    ULONG OldFileCount;
    PHEADER_OLD_FILE_INFO OldFileInfoArray;
    } PATCH_HEADER_INFO, *PPATCH_HEADER_INFO;


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    );

BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    );

BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN ULONG TransformOptions,
    IN PVOID OldFileMapped,
    IN ULONG OldFileSize,
    IN ULONG NewFileResTime,
    IN PRIFT_TABLE RiftTable,
    ...
    );


//
//  The following is a private flag to indicate external rift data is being
//  specified in the OptionData->OldFileSymbolPathArray[ OldFileIndex ] field
//  (really a PRIFT_TABLE pointer).
//

#define PATCH_SYMBOL_EXTERNAL_RIFT      PATCH_SYMBOL_RESERVED1

//
//  The following is an internal flag stored in the patch header to indicate
//  the ExtendedOptionFlags field is present (non-zero) in the header.  It is
//  never necessary to specify this flag when creating a patch.
//

#define PATCH_OPTION_EXTENDED_OPTIONS   PATCH_OPTION_RESERVED1

//
//  Following are flags in the ExtendedOptionFlags field.
//

#define PATCH_TRANSFORM_NO_RELOCS       0x00000001  // don't xform relocs
#define PATCH_TRANSFORM_NO_IMPORTS      0x00000002  // don't xform imports
#define PATCH_TRANSFORM_NO_EXPORTS      0x00000004  // don't xform exports
#define PATCH_TRANSFORM_NO_RELJMPS      0x00000008  // don't xform E9 or 0F 8x instructions
#define PATCH_TRANSFORM_NO_RELCALLS     0x00000010  // don't xform E8 instructions
#define PATCH_TRANSFORM_NO_RESOURCE     0x00000020  // don't xform resources



VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCHPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\pestuff.h ===
#ifndef _PATCH_PESTUFF_H_
#define _PATCH_PESTUFF_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef IMAGE_DOS_HEADER                UNALIGNED* UP_IMAGE_DOS_HEADER;
typedef IMAGE_NT_HEADERS32              UNALIGNED* UP_IMAGE_NT_HEADERS32;
typedef IMAGE_SECTION_HEADER            UNALIGNED* UP_IMAGE_SECTION_HEADER;
typedef IMAGE_EXPORT_DIRECTORY          UNALIGNED* UP_IMAGE_EXPORT_DIRECTORY;
typedef IMAGE_IMPORT_DESCRIPTOR         UNALIGNED* UP_IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_BY_NAME            UNALIGNED* UP_IMAGE_IMPORT_BY_NAME;
typedef IMAGE_THUNK_DATA32              UNALIGNED* UP_IMAGE_THUNK_DATA32;
typedef IMAGE_RESOURCE_DIRECTORY        UNALIGNED* UP_IMAGE_RESOURCE_DIRECTORY;
typedef IMAGE_RESOURCE_DIRECTORY_ENTRY  UNALIGNED* UP_IMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef IMAGE_RESOURCE_DATA_ENTRY       UNALIGNED* UP_IMAGE_RESOURCE_DATA_ENTRY;
typedef IMAGE_RESOURCE_DIR_STRING_U     UNALIGNED* UP_IMAGE_RESOURCE_DIR_STRING_U;
typedef IMAGE_LOAD_CONFIG_DIRECTORY32   UNALIGNED* UP_IMAGE_LOAD_CONFIG_DIRECTORY32;
typedef IMAGE_BASE_RELOCATION           UNALIGNED* UP_IMAGE_BASE_RELOCATION;


UP_IMAGE_NT_HEADERS32
__fastcall
GetNtHeader(
    IN PVOID MappedFile,
    IN ULONG MappedFileSize
    );

BOOL
NormalizeCoffImage(
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR MappedFile,
    IN     ULONG  FileSize,
    IN     ULONG  OptionFlags,
    IN     PVOID  OptionData,
    IN     ULONG  NewFileCoffBase,
    IN     ULONG  NewFileCoffTime
    );

BOOL
TransformCoffImage(
    IN     ULONG  TransformOptions,
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR OldFileMapped,
    IN     ULONG  OldFileSize,
    IN     ULONG  NewFileResTime,
    IN OUT PRIFT_TABLE RiftTable,
    IN OUT PUCHAR HintMap,
    ...
    );

BOOL
GenerateRiftTable(
    IN HANDLE OldFileHandle,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  OldFileOriginalChecksum,
    IN ULONG  OldFileOriginalTimeDate,
    IN HANDLE NewFileHandle,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN PVOID  OptionData,
    IN ULONG  OldFileIndex,
    IN PVOID  RiftTable
    );

VOID
InitImagehlpCritSect(
    VOID
    );

VOID
UnloadImagehlp(
    VOID
    );

#define X86_OPCODE_NOP  0x90
#define X86_OPCODE_LOCK 0xF0

BOOL
SmashLockPrefixesInMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN UCHAR  NewOpCode      // X86_OPCODE_NOP or X86_OPCODE_LOCK
    );

USHORT
ChkSum(
    IN USHORT  Initial,
    IN PUSHORT Buffer,
    IN ULONG   Bytes
    );

PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize,
    IN  PUCHAR MappedBase,
    IN  ULONG  MappedSize
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCH_PESTUFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\precomp.h ===
#define BUILDING_PATCHAPI 1

#pragma warning( disable: 4001 )    // single line comments
#pragma warning( disable: 4115 )    // type definition in parentheses
#pragma warning( disable: 4200 )    // zero-sized array in struct/union
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4204 )    // non-constant initializer
#pragma warning( disable: 4206 )    // empty file after preprocessing
#pragma warning( disable: 4209 )    // benign redefinition
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bit field other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

#include <windows.h>
#include <wincrypt.h>
#pragma warning( disable: 4201 )
#include <imagehlp.h>
#include <stdlib.h>

//
//  For some reason, windows.h screws up the disabled warnings, so we have
//  to disable them again after including it.
//

#pragma warning( disable: 4001 )    // single line comments
#pragma warning( disable: 4115 )    // type definition in parentheses
#pragma warning( disable: 4200 )    // zero-sized array in struct/union
#pragma warning( disable: 4201 )    // nameless struct/union
#pragma warning( disable: 4204 )    // non-constant initializer
#pragma warning( disable: 4206 )    // empty file after preprocessing
#pragma warning( disable: 4209 )    // benign redefinition
#pragma warning( disable: 4213 )    // cast on l-value
#pragma warning( disable: 4214 )    // bit field other than int
#pragma warning( disable: 4514 )    // unreferenced inline function

#include "md5.h"
#include "misc.h"
#include "redblack.h"
#include "patchapi.h"
#include "patchprv.h"
#include "patchlzx.h"
#include "pestuff.h"

typedef void t_encoder_context;
typedef void t_decoder_context;

#include <encapi.h>
#include <decapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\pestuff.c ===
#include <precomp.h>

//
//  pestuff.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 3/98
//
//  Copyright (C) Microsoft, 1997-1999.
//
//  MICROSOFT CONFIDENTIAL
//


#define MAX_SYMBOL_NAME_LENGTH  2048


typedef struct _SYMBOL_CONTEXT SYMBOL_CONTEXT, *PSYMBOL_CONTEXT;

struct _SYMBOL_CONTEXT {
    SYMBOL_TREE NewDecoratedSymbolTree;
    SYMBOL_TREE NewUndecoratedSymbolTree;
    SYMBOL_TREE OldUndecoratedSymbolTree;
    ULONG_PTR   NewImageBase;
    ULONG_PTR   OldImageBase;
    ULONG       SymbolOptionFlags;
    PRIFT_TABLE RiftTable;
#ifdef TESTCODE
    HANDLE      OutFile;
#endif
    };


typedef struct _RELOC_ARRAY_ENTRY RELOC_ARRAY_ENTRY, *PRELOC_ARRAY_ENTRY;

struct _RELOC_ARRAY_ENTRY {
    ULONG  RelocRva;
    UCHAR  RelocType;
    USHORT HighAdjValue;
    };


#ifndef PATCH_APPLY_CODE_ONLY

#ifdef TESTCODE
ULONG CountDecoratedMatches;
ULONG CountUndecoratedMatches;
#endif

LPCSTR ImagehlpImportNames[] = {
           "SymInitialize",
           "SymGetOptions",
           "SymSetOptions",
           "SymLoadModule",
           "SymGetModuleInfo",
           "SymEnumerateSymbols",
           "UnDecorateSymbolName",
           "SymUnloadModule",
           "SymCleanup"
           };

#define COUNT_IMAGEHLP_IMPORTS ( sizeof( ImagehlpImportNames ) / sizeof( ImagehlpImportNames[ 0 ] ))

//
//  NOTE:  Above names must be in SAME ORDER as the prototypes below.
//

union {

    VOID ( __stdcall * Imports[ COUNT_IMAGEHLP_IMPORTS ] )();

    struct {
        BOOL  ( __stdcall * SymInitialize        )( HANDLE, LPCSTR, BOOL );
        DWORD ( __stdcall * SymGetOptions        )( VOID );
        DWORD ( __stdcall * SymSetOptions        )( DWORD );
        DWORD ( __stdcall * SymLoadModule        )( HANDLE, HANDLE, LPCSTR, LPCSTR, DWORD_PTR, DWORD );
        BOOL  ( __stdcall * SymGetModuleInfo     )( HANLDE, DWORD, PIMAGEHLP_MODULE );
        BOOL  ( __stdcall * SymEnumerateSymbols  )( HANDLE, DWORD_PTR, PSYM_ENUMSYMBOLS_CALLBACK, PVOID );
        BOOL  ( __stdcall * UnDecorateSymbolName )( LPCSTR, LPSTR, DWORD, DWORD );
        BOOL  ( __stdcall * SymUnloadModule      )( HANDLE, DWORD_PTR );
        BOOL  ( __stdcall * SymCleanup           )( HANDLE );
        };
    } Imagehlp;


BOOL ImagehlpCritSectInitialized;
CRITICAL_SECTION ImagehlpCritSect;
HANDLE hLibImagehlp;
HANDLE hProc;
IMAGEHLP_MODULE ImagehlpModuleInfo;

VOID
InitImagehlpCritSect(
    VOID
    )
    {
    if ( ! ImagehlpCritSectInitialized ) {
        InitializeCriticalSection( &ImagehlpCritSect );
        ImagehlpCritSectInitialized = TRUE;
        hProc = GetCurrentProcess();
        }
    }


BOOL
LoadImagehlp(
    VOID
    )
    {
    HANDLE hLib;
    ULONG i;

    if ( Imagehlp.Imports[ COUNT_IMAGEHLP_IMPORTS - 1 ] == NULL ) {

        hLib = LoadLibrary( "imagehlp.dll" );

        if ( hLib == NULL ) {
            return FALSE;
            }

        for ( i = 0; i < COUNT_IMAGEHLP_IMPORTS; i++ ) {

            Imagehlp.Imports[ i ] = GetProcAddress( hLib, ImagehlpImportNames[ i ] );

            if ( Imagehlp.Imports[ i ] == NULL ) {

                FreeLibrary( hLib );
                return FALSE;
                }
            }

        hLibImagehlp = hLib;
        }

    return TRUE;
    }


#ifdef BUILDING_PATCHAPI_DLL

VOID
UnloadImagehlp(
    VOID
    )
    {
    if ( hLibImagehlp ) {
        FreeLibrary( hLibImagehlp );
        hLibImagehlp = NULL;
        Imagehlp.Imports[ COUNT_IMAGEHLP_IMPORTS - 1 ] = NULL;
        DeleteCriticalSection( &ImagehlpCritSect );
        ImagehlpCritSectInitialized = FALSE;
        }
    }

#endif // BUILDING_PATCHAPI_DLL

#endif // ! PATCH_APPLY_CODE_ONLY


UP_IMAGE_NT_HEADERS32
__fastcall
GetNtHeader(
    IN PVOID MappedFile,
    IN ULONG MappedFileSize
    )
    {
    UP_IMAGE_DOS_HEADER   DosHeader;
    UP_IMAGE_NT_HEADERS32 RetHeader;
    UP_IMAGE_NT_HEADERS32 NtHeader;

    RetHeader = NULL;

    __try {

        if ( MappedFileSize >= 0x200 ) {

            DosHeader = (UP_IMAGE_DOS_HEADER) MappedFile;

            if ( DosHeader->e_magic == IMAGE_DOS_SIGNATURE ) {

                NtHeader = (UP_IMAGE_NT_HEADERS32)((PUCHAR) MappedFile + DosHeader->e_lfanew );

                if (((PUCHAR) NtHeader + sizeof( IMAGE_NT_HEADERS32 )) <= ((PUCHAR) MappedFile + MappedFileSize )) {

                    if ( NtHeader->Signature == IMAGE_NT_SIGNATURE ) {

                        if (NtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {

                            RetHeader = NtHeader;

                            }
                        }
                    }
                }
            }
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    return RetHeader;
    }


BOOL
__fastcall
IsImageRvaInExecutableSection(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Rva
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].Misc.VirtualSize )) {

            return (( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) ? TRUE : FALSE );
            }
        }

    return FALSE;
    }


ULONG
__fastcall
ImageRvaToFileOffset(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Rva
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    if ( Rva < NtHeader->OptionalHeader.SizeOfHeaders ) {
        return Rva;
        }

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( Rva >= SectionHeader[ i ].VirtualAddress ) &&
            ( Rva <  SectionHeader[ i ].VirtualAddress + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].PointerToRawData + ( Rva - SectionHeader[ i ].VirtualAddress ));
            }
        }

    return 0;
    }


PVOID
__fastcall
ImageRvaToMappedAddress(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Rva,
    IN PVOID MappedBase,
    IN ULONG MappedSize
    )
    {
    ULONG MappedOffset = ImageRvaToFileOffset( NtHeader, Rva );

    if (( MappedOffset ) && ( MappedOffset < MappedSize )) {
        return ((PUCHAR)MappedBase + MappedOffset );
        }

    return NULL;
    }

ULONG
__fastcall
ImageVaToFileOffset(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Va
    )
    {
    return ImageRvaToFileOffset( NtHeader, Va - NtHeader->OptionalHeader.ImageBase );
    }


PVOID
__fastcall
ImageVaToMappedAddress(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG Va,
    IN PVOID MappedBase,
    IN ULONG MappedSize
    )
    {
    return ImageRvaToMappedAddress( NtHeader, Va - NtHeader->OptionalHeader.ImageBase, MappedBase, MappedSize );
    }


ULONG
__fastcall
ImageDirectoryRvaAndSize(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize
    )
    {
    if ( DirectoryIndex < NtHeader->OptionalHeader.NumberOfRvaAndSizes ) {

        if ( DirectorySize ) {
            *DirectorySize = NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].Size;
            }

        return NtHeader->OptionalHeader.DataDirectory[ DirectoryIndex ].VirtualAddress;
        }

    return 0;
    }


ULONG
__fastcall
ImageDirectoryOffsetAndSize(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize
    )
    {
    ULONG Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, DirectorySize );

    if ( Rva ) {
        return ImageRvaToFileOffset( NtHeader, Rva );
        }

    return 0;
    }


PVOID
__fastcall
ImageDirectoryMappedAddress(
    IN  UP_IMAGE_NT_HEADERS32 NtHeader,
    IN  ULONG  DirectoryIndex,
    OUT PULONG DirectorySize,
    IN  PUCHAR MappedBase,
    IN  ULONG  MappedSize
    )
    {
    PUCHAR Directory;
    ULONG  LocalSize;
    ULONG  Rva;

    Rva = ImageDirectoryRvaAndSize( NtHeader, DirectoryIndex, &LocalSize );

    Directory = ImageRvaToMappedAddress( NtHeader, Rva, MappedBase, MappedSize );

    if (( Directory ) && (( Directory + LocalSize ) <= ( MappedBase + MappedSize ))) {

        if ( DirectorySize ) {
            *DirectorySize = LocalSize;
            }

        return Directory;
        }

    return NULL;
    }


ULONG
__fastcall
FileOffsetToImageRva(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG FileOffset
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG i;

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if (( FileOffset >= SectionHeader[ i ].PointerToRawData ) &&
            ( FileOffset <  SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData )) {

            return ( SectionHeader[ i ].VirtualAddress + ( FileOffset - SectionHeader[ i ].PointerToRawData ));
            }
        }

    return 0;
    }


ULONG
MappedAddressToImageRva(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID MappedAddress,
    IN PVOID MappedFile
    )
    {
    LONG FileOffset = (LONG)((PUCHAR)MappedAddress - (PUCHAR)MappedFile);

    if ( FileOffset > 0 ) {
        return FileOffsetToImageRva( NtHeader, FileOffset );
        }

    return 0;
    }


BOOL
RebaseMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN ULONG  NewBase
    )
    {
    UP_IMAGE_BASE_RELOCATION RelocBlock;
    LONG                   RelocAmount;
    LONG                   RelocDirRemaining;
    ULONG                  RelocDirSize;
    PUCHAR                 RelocBlockMa;
    PUCHAR                 RelocFixupMa;
    ULONG                  RelocCount;
    USHORT UNALIGNED*      RelocEntry;
    PUCHAR                 MappedFileEnd;
    BOOL                   Modified;

    //
    //  Carefully rebase the image, ignoring invalid info as much as possible
    //  without taking an access violation.  We don't want to use try/except
    //  here because this code needs to be workable without any imports from
    //  kernel32.dll.  This code is not intended to catch errors in invalid
    //  rebase info -- it is intended to silently do the best it can at
    //  rebasing the image in memory.  If the rebase info is valid, it will
    //  correctly rebase the image.  If the rebase info is not valid, it will
    //  attempt to avoid causing an access violation.
    //

    ASSERT( NtHeader->OptionalHeader.ImageBase != NewBase );
    ASSERT(( NewBase & 0x0000FFFF ) == 0 );
    ASSERT(( NewBase & 0xFFFF0000 ) != 0 );

    Modified      = FALSE;
    MappedFileEnd = MappedFile + FileSize;
    RelocAmount   = NewBase - NtHeader->OptionalHeader.ImageBase;

    RelocBlock = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize, MappedFile, FileSize );

    if ( RelocBlock ) {

        NtHeader->OptionalHeader.ImageBase = NewBase;
        Modified = TRUE;

        RelocDirRemaining = (LONG)RelocDirSize;

        while ( RelocDirRemaining > 0 ) {

            if (( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION ))) {

                //
                //  ImageRvaToMappedAddress returns NULL if the Rva is zero,
                //  but that is a valid base address of a reloc block.  Use
                //  ImageRvaToFileOffset instead.
                //

                RelocBlockMa = MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress );

                if ( RelocBlockMa ) {

                    RelocEntry = (PUSHORT)((PUCHAR)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                    RelocCount = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                    while ( RelocCount-- ) {

                        RelocFixupMa = RelocBlockMa + ( *RelocEntry & 0x0FFF );

                        if ( RelocFixupMa < MappedFileEnd ) {

                            switch ( *RelocEntry >> 12 ) {

                                case IMAGE_REL_BASED_HIGHLOW:

                                    *(UNALIGNED LONG *)RelocFixupMa += RelocAmount;
                                    break;

                                case IMAGE_REL_BASED_LOW:

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)( *(UNALIGNED SHORT *)RelocFixupMa + RelocAmount );
                                    break;

                                case IMAGE_REL_BASED_HIGH:

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)((( *(UNALIGNED USHORT *)RelocFixupMa << 16 ) + RelocAmount ) >> 16 );
                                    break;

                                case IMAGE_REL_BASED_HIGHADJ:

                                    ++RelocEntry;
                                    --RelocCount;

                                    *(UNALIGNED USHORT *)RelocFixupMa = (USHORT)((( *(UNALIGNED USHORT *)RelocFixupMa << 16 ) + *(UNALIGNED SHORT *)RelocEntry + RelocAmount + 0x8000 ) >> 16 );
                                    break;

                                //
                                //  Just skip and continue if we don't
                                //  recognize the reloc type.
                                //

                                }
                            }

                        ++RelocEntry;

                        }
                    }
                }

            RelocDirRemaining -= RelocBlock->SizeOfBlock;
            RelocBlock = (UP_IMAGE_BASE_RELOCATION)((PUCHAR)RelocBlock + RelocBlock->SizeOfBlock );

            }
        }

    return Modified;
    }


BOOL
UnBindMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader
    )
    {
    UP_IMAGE_SECTION_HEADER  SectionHeader;
    UP_IMAGE_IMPORT_DESCRIPTOR ImportDesc;
    ULONG                    SectionCount;
    DWORDLONG                SectionName;
    PVOID                    BoundImportDir;
    ULONG                    BoundImportSize;
    ULONG UNALIGNED*         OriginalIat;
    ULONG UNALIGNED*         BoundIat;
    PUCHAR                   MappedFileEnd;
    BOOL                     Modified;
    ULONG                    i;

    Modified       = FALSE;
    MappedFileEnd  = MappedFile + FileSize;
    BoundImportDir = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT, &BoundImportSize, MappedFile, FileSize );

    if ( BoundImportDir ) {

        //
        //  Zero the bound import directory and pointers to bound
        //  import directory.
        //

        ZeroMemory( BoundImportDir, BoundImportSize );

        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress = 0;
        NtHeader->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size           = 0;

        Modified = TRUE;
        }

    //
    //  Now walk imports and zero the TimeDate and
    //  ForwarderChain fields.
    //

    ImportDesc = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, NULL, MappedFile, FileSize );

    if ( ImportDesc ) {

        while (((ULONG_PTR)ImportDesc < ((ULONG_PTR)MappedFileEnd - sizeof( IMAGE_IMPORT_DESCRIPTOR ))) &&
               ( ImportDesc->Characteristics )) {

            if ( ImportDesc->TimeDateStamp ) {

                //
                //  This is a bound import.  Copy the unbound
                //  IAT over the bound IAT to restore.
                //

                ImportDesc->TimeDateStamp = 0;
                Modified = TRUE;

                OriginalIat = ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->OriginalFirstThunk, MappedFile, FileSize );
                BoundIat    = ImageRvaToMappedAddress( NtHeader, (ULONG)ImportDesc->FirstThunk,         MappedFile, FileSize );

                if (( OriginalIat ) && ( BoundIat )) {

                    while (((PUCHAR)OriginalIat < MappedFileEnd ) &&
                           ((PUCHAR)BoundIat    < MappedFileEnd ) &&
                           ( *OriginalIat )) {

                        *BoundIat++ = *OriginalIat++;
                        }
                    }
                }

            if ( ImportDesc->ForwarderChain ) {
                 ImportDesc->ForwarderChain = 0;
                 Modified = TRUE;
                 }

            ++ImportDesc;
            }
        }

    //
    //  The bind utility marks the .idata section as read-only so we want to
    //  change it back to read-write.
    //

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        SectionName = *(UNALIGNED DWORDLONG*)( &SectionHeader[ i ].Name );
        SectionName |= 0x2020202020202020;  // fast lower case

        if ( SectionName == 0x202061746164692E ) {      // ".idata  "

            if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_WRITE )) {

                SectionHeader[ i ].Characteristics |= ( IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE );
                Modified = TRUE;
                }

            break;
            }
        }

    return Modified;
    }


BOOL
SmashLockPrefixesInMappedImage(
    IN PUCHAR MappedFile,
    IN ULONG  FileSize,
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN UCHAR  NewOpCode      // X86_OPCODE_NOP or X86_OPCODE_LOCK
    )
    {
    UP_IMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig;
    ULONG UNALIGNED* LockPrefixEntry;
    PUCHAR LockPrefixInstruction;
    BOOL   Modified;

    Modified   = FALSE;
    LoadConfig = ImageDirectoryMappedAddress( NtHeader, IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, NULL, MappedFile, FileSize );

    if ( LoadConfig ) {

        if ( LoadConfig->LockPrefixTable ) {

            //
            //  The LoadConfig->LockPrefixTable field and
            //  the lock prefix addresses are stored in the
            //  image as image VA, not RVA values.
            //

            LockPrefixEntry = ImageVaToMappedAddress( NtHeader, LoadConfig->LockPrefixTable, MappedFile, FileSize );

            if ( LockPrefixEntry ) {

                while ( *LockPrefixEntry ) {

                    LockPrefixInstruction = ImageVaToMappedAddress( NtHeader, *LockPrefixEntry, MappedFile, FileSize );

                    if ( LockPrefixInstruction ) {

                        if ( *LockPrefixInstruction != NewOpCode ) {

                            //
                            //  Lock prefix instruction is not what we want,
                            //  so modify it.
                            //

                            *LockPrefixInstruction = NewOpCode;
                            Modified = TRUE;
                            }
                        }

                    ++LockPrefixEntry;

                    }
                }
            }
        }

    return Modified;
    }


USHORT
ChkSum(
    IN USHORT  Initial,
    IN PUSHORT Buffer,
    IN ULONG   Bytes
    )
    {
    USHORT UNALIGNED* p = Buffer;
    ULONG WordsRemaining = Bytes / 2;
    ULONG WordsInChunk;
    ULONG SumChunk;
    ULONG SumTotal;

    SumTotal = Initial;

    while ( WordsRemaining ) {

        WordsInChunk = WordsRemaining;

        if ( WordsInChunk > 0x10000 ) {
             WordsInChunk = 0x10000;
             }

        WordsRemaining -= WordsInChunk;

        SumChunk = 0;

        do  {
            SumChunk += *p++;
            }
        while ( --WordsInChunk != 0 );

        SumTotal += ( SumChunk >> 16 ) + ( SumChunk & 0xFFFF );
        }

    if ( Bytes % 2 ) {

        SumTotal += *((PBYTE) p);
        }

    return (USHORT)(( SumTotal >> 16 ) + ( SumTotal & 0xFFFF ));
    }


BOOL
NormalizeCoffImage(
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR MappedFile,
    IN     ULONG  FileSize,
    IN     ULONG  OptionFlags,
    IN     PVOID  OptionData,
    IN     ULONG  NewFileCoffBase,
    IN     ULONG  NewFileCoffTime
    )
    {
    BOOL Modified = FALSE;

    UNREFERENCED_PARAMETER( OptionData );

    if ( ! ( OptionFlags & PATCH_OPTION_NO_REBASE )) {

        if (( NewFileCoffTime != 0 ) && ( NtHeader->FileHeader.TimeDateStamp != NewFileCoffTime )) {
             NtHeader->FileHeader.TimeDateStamp = NewFileCoffTime;
             Modified = TRUE;
             }

        if (( NewFileCoffBase != 0 ) && ( NtHeader->OptionalHeader.ImageBase != NewFileCoffBase )) {
            Modified |= RebaseMappedImage( MappedFile, FileSize, NtHeader, NewFileCoffBase );
            }
        }

    if ( ! ( OptionFlags & PATCH_OPTION_NO_BINDFIX )) {
        Modified |= UnBindMappedImage( MappedFile, FileSize, NtHeader );
        }

    if ( ! ( OptionFlags & PATCH_OPTION_NO_LOCKFIX )) {
        Modified |= SmashLockPrefixesInMappedImage( MappedFile, FileSize, NtHeader, X86_OPCODE_LOCK );
        }

    //
    //  If the target file has zero checksum (PATCH_OPTION_NO_CHECKSUM),
    //  set the checksum in this image to zero.
    //
    //  Otherwise, if we either modified the image or if the image has
    //  a zero checksum, recompute the correct checksum.
    //

    if ( OptionFlags & PATCH_OPTION_NO_CHECKSUM ) {

        if ( NtHeader->OptionalHeader.CheckSum != 0 ) {
             NtHeader->OptionalHeader.CheckSum = 0;
             Modified = TRUE;
             }
        }

    else {

        if ( Modified ) {
             (ULONG)( NtHeader->OptionalHeader.CheckSum ) = 0;
             NtHeader->OptionalHeader.CheckSum = ChkSum( 0, (PVOID)MappedFile, FileSize ) + FileSize;
             }
        }

    return Modified;
    }


//
//  For some odd reason, the VC4 compiler says there is unreachable code
//  in the GetNewRvaFromRiftTable and FindRiftTableEntryForOldRva functions,
//  but I can't find it by inspection, and the VC5 and VC6 compilers don't
//  complain about it, so it's probably just a VC4 issue.  So, if the compiler
//  version is previous to VC5, disable this particular warning.
//

#if ( _MSC_VER < 1100 )
#pragma warning( disable: 4702 )    // unreachable code
#endif

ULONG
__fastcall
GetNewRvaFromRiftTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG OldRva
    )
    {
    PRIFT_ENTRY RiftEntryArray;
    ULONG NewRva;
    ULONG Index;
    ULONG MinIndexInclusive;
    ULONG MaxIndexExclusive;
    LONG  Displacement;
    BOOL  Found;

    //
    //  Rift table is in sorted order by OldRva, so do a binary search for
    //  matching or nearest preceding OldRva value.
    //

    RiftEntryArray    = RiftTable->RiftEntryArray;
    MaxIndexExclusive = RiftTable->RiftEntryCount;
    MinIndexInclusive = 0;
    Index             = 0;
    Found             = FALSE;

    while (( ! Found ) && ( MinIndexInclusive < MaxIndexExclusive )) {

        Index = ( MinIndexInclusive + MaxIndexExclusive ) / 2;    // won't overflow

        if ( RiftEntryArray[ Index ].OldFileRva < OldRva ) {
            MinIndexInclusive = Index + 1;
            }
        else if ( RiftEntryArray[ Index ].OldFileRva > OldRva ) {
            MaxIndexExclusive = Index;
            }
        else {
            Found = TRUE;
            break;
            }
        }

    if ( ! Found ) {

        //
        //  MinIndex is pointing to next highest entry, which could also be
        //  the zeroth entry if the search value was lower than anything in
        //  the table.
        //

        if ( MinIndexInclusive == 0 ) {
            return OldRva;  // zero displacement
            }

        Index = MinIndexInclusive - 1;
        }

    Displacement = (LONG)( RiftEntryArray[ Index ].NewFileRva - RiftEntryArray[ Index ].OldFileRva );

#ifndef PATCH_APPLY_CODE_ONLY

    //
    //  If we're updating the RiftUsageArray during compression, we want to
    //  mark the contributing entry as being used.
    //

    if ( RiftTable->RiftUsageArray != NULL ) {
         RiftTable->RiftUsageArray[ Index ] = 1;
         }

#endif

    NewRva = OldRva + Displacement;

    return NewRva;
    }


ULONG
__fastcall
FindRiftTableEntryForOldRva(
    IN PRIFT_TABLE RiftTable,
    IN ULONG OldRva
    )
    {
    PRIFT_ENTRY RiftEntryArray;
    ULONG MinIndexInclusive;
    ULONG MaxIndexExclusive;
    ULONG Index;
    BOOL  Found;

    //
    //  Rift table is in sorted order by OldRva, so do a binary search for
    //  matching or nearest preceding OldRva value.
    //

    RiftEntryArray    = RiftTable->RiftEntryArray;
    MaxIndexExclusive = RiftTable->RiftEntryCount;
    MinIndexInclusive = 0;
    Index             = 0;
    Found             = FALSE;

    while (( ! Found ) && ( MinIndexInclusive < MaxIndexExclusive )) {

        Index = ( MinIndexInclusive + MaxIndexExclusive ) / 2;    // won't overflow

        if ( RiftEntryArray[ Index ].OldFileRva < OldRva ) {
            MinIndexInclusive = Index + 1;
            }
        else if ( RiftEntryArray[ Index ].OldFileRva > OldRva ) {
            MaxIndexExclusive = Index;
            }
        else {
            Found = TRUE;
            break;
            }
        }

    if ( ! Found ) {

        //
        //  MinIndex is pointing to next highest entry, which could also be
        //  the zeroth entry if the search value was lower than anything in
        //  the table.
        //

        if ( MinIndexInclusive == 0 ) {
            return 0;
            }

        Index = MinIndexInclusive - 1;
        }

    return Index;
    }


#if ( _MSC_VER < 1100 )
#pragma warning( default: 4702 )    // unreachable code
#endif


VOID
__inline
ChangeOldRvaToNewRva(
    IN PRIFT_TABLE RiftTable,
    IN OUT PVOID AddressOfRvaToChange
    )
    {
    //
    //  Assuming all addresses of RVAs in a PE image are aligned.
    //

    ULONG UNALIGNED* RvaToChange = AddressOfRvaToChange;

    *RvaToChange = GetNewRvaFromRiftTable(
                       RiftTable,
                       *RvaToChange
                       );
    }


VOID
__inline
SwapRelocs(
    PRELOC_ARRAY_ENTRY One,
    PRELOC_ARRAY_ENTRY Two
    )
    {
    RELOC_ARRAY_ENTRY Tmp;

    Tmp  = *One;
    *One = *Two;
    *Two =  Tmp;
    }


VOID
__fastcall
RelocQsort(
    PRELOC_ARRAY_ENTRY LowerBound,
    PRELOC_ARRAY_ENTRY UpperBound
    )
    {
    PRELOC_ARRAY_ENTRY Lower = LowerBound;
    PRELOC_ARRAY_ENTRY Upper = UpperBound;
    PRELOC_ARRAY_ENTRY Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG PivotRva = Pivot->RelocRva;

    do  {

        while (( Lower <= Upper ) && ( Lower->RelocRva <= PivotRva )) {
            ++Lower;
            }

        while (( Upper >= Lower ) && ( Upper->RelocRva >= PivotRva )) {
            --Upper;
            }

        if ( Lower < Upper ) {
            SwapRelocs( Lower++, Upper-- );
            }
        }

    while ( Lower <= Upper );

    if ( Lower < Pivot ) {
        SwapRelocs( Lower, Pivot );
        Pivot = Lower;
        }
    else if ( Upper > Pivot ) {
        SwapRelocs( Upper, Pivot );
        Pivot = Upper;
        }

    if ( LowerBound < ( Pivot - 1 )) {
        RelocQsort( LowerBound, Pivot - 1 );
        }

    if (( Pivot + 1 ) < UpperBound ) {
        RelocQsort( Pivot + 1, UpperBound );
        }
    }


VOID
TransformOldFile_PE_Relocations(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID       FileMappedImage,
    IN ULONG       FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR      HintMap
    )
    {
    PUCHAR  MappedFile;
    PUCHAR  MappedFileEnd;
    ULONG   ImageBaseVa;
    ULONG   ImageLastVa;
    PUCHAR  ImageFirstSectionMa;     // Mapped address
    ULONG   ImageFirstSectionVa;     // Virtual address
    ULONG   RelocDirOff;
    ULONG   RelocDirSize;
    LONG    RelocDirRemaining;
    UP_IMAGE_BASE_RELOCATION RelocBlock;
    UP_IMAGE_BASE_RELOCATION RelocBlockBaseMa;        // Mapped address
    ULONG   RelocBlockBaseVa;        // Virtual address
    ULONG   RelocCount;
    USHORT UNALIGNED* RelocEntry;
    USHORT UNALIGNED* RelocFirst;
    UCHAR   RelocType;
    PUCHAR  RelocFixupMa;            // Mapped address
    ULONG   RelocFixupVa;            // Virtual address
    ULONG   RelocFixupRva;
    ULONG   RelocTargetVa;           // Virtual address
    ULONG   RelocTargetRva;
    ULONG   NewRva;
    ULONG   NewVa;
    PRELOC_ARRAY_ENTRY RelocArray;
    ULONG   RelocArrayCount;
    ULONG   RelocArrayIndex;
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG     SectionCount;
    DWORDLONG SectionName;
    PUCHAR  p;
    ULONG   i;

#ifdef TESTCODE

    ULONG CountRelocChanges = 0;

#endif // TESTCODE

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;
    ImageBaseVa   = NtHeader->OptionalHeader.ImageBase;
    RelocDirOff   = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_BASERELOC, &RelocDirSize );

    if (( RelocDirOff ) && (( RelocDirOff + RelocDirSize ) <= FileSize )) {

        memset( HintMap + RelocDirOff, 0x01, RelocDirSize );  // may need to be OR'd if other bits are used

        //  allocate an array for the new reloc entries, approximating the needed size

        RelocArray = MyVirtualAlloc( sizeof( *RelocArray ) * ( RelocDirSize / sizeof(USHORT)));

        if ( RelocArray != NULL ) {

            RelocArrayCount = 0;

            RelocBlock = (UP_IMAGE_BASE_RELOCATION)( MappedFile + RelocDirOff );

            RelocDirRemaining = (LONG)RelocDirSize;

            while ( RelocDirRemaining > 0 ) {

                if (( RelocBlock->SizeOfBlock <= (ULONG)RelocDirRemaining ) &&
                    ( RelocBlock->SizeOfBlock > sizeof( IMAGE_BASE_RELOCATION ))) {

                    //
                    //  ImageRvaToMappedAddress returns NULL if the Rva is zero,
                    //  but that is a valid base address of a reloc block.  Use
                    //  ImageRvaToFileOffset instead.
                    //

                    RelocBlockBaseMa = (UP_IMAGE_BASE_RELOCATION)( MappedFile + ImageRvaToFileOffset( NtHeader, RelocBlock->VirtualAddress ));

                    if ( RelocBlockBaseMa ) {

                        RelocBlockBaseVa = RelocBlock->VirtualAddress + ImageBaseVa;
                        RelocEntry       = (PUSHORT)((PUCHAR)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                        RelocCount       = ( RelocBlock->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION )) / sizeof( USHORT );

                        while ( RelocCount-- ) {

                            RelocType = (UCHAR)( *RelocEntry >> 12 );

                            if ( RelocType != IMAGE_REL_BASED_ABSOLUTE ) {

                                RelocFixupMa  = (PUCHAR)RelocBlockBaseMa + ( *RelocEntry & 0x0FFF );
                                RelocFixupVa  = RelocBlockBaseVa + ( *RelocEntry & 0x0FFF );
                                RelocFixupRva = RelocFixupVa - ImageBaseVa;

                                RelocArray[ RelocArrayCount ].RelocRva  = GetNewRvaFromRiftTable(
                                                                              RiftTable,
                                                                              RelocFixupRva
                                                                              );

                                RelocArray[ RelocArrayCount ].RelocType = RelocType;

                                switch ( RelocType ) {

                                    case IMAGE_REL_BASED_HIGHLOW:

                                        if ( RelocFixupMa < MappedFileEnd ) {

                                            *(UNALIGNED ULONG *)( HintMap + ( RelocFixupMa - MappedFile )) |= 0x01010101;

                                            //
                                            //  Target is a 32-bit VA that we want to
                                            //  change to the corresponding VA in the
                                            //  new file.
                                            //

                                            RelocTargetVa  = *(UNALIGNED ULONG *) RelocFixupMa;
                                            RelocTargetRva = RelocTargetVa - ImageBaseVa;

                                            NewRva = GetNewRvaFromRiftTable(
                                                         RiftTable,
                                                         RelocTargetRva
                                                         );

                                            if ( NewRva != RelocTargetRva ) {

                                                NewVa = NewRva + ImageBaseVa;
                                                *(UNALIGNED ULONG *) RelocFixupMa = NewVa;
#ifdef TESTCODE
                                                ++CountRelocChanges;
#endif // TESTCODE
                                                }

                                            }

                                        break;

                                    case IMAGE_REL_BASED_LOW:
                                    case IMAGE_REL_BASED_HIGH:

                                        if ( RelocFixupMa < MappedFileEnd ) {
                                            *(UNALIGNED USHORT *)( HintMap + ( RelocFixupMa - MappedFile )) |= 0x0101;
                                            }

                                        break;

                                    case IMAGE_REL_BASED_HIGHADJ:

                                        if ( RelocFixupMa < MappedFileEnd ) {
                                            *(UNALIGNED USHORT *)( HintMap + ( RelocFixupMa - MappedFile )) |= 0x0101;
                                            }

                                        ++RelocEntry;
                                        --RelocCount;

                                        RelocArray[ RelocArrayCount ].HighAdjValue = *RelocEntry;

                                        break;
                                    }

                                ++RelocArrayCount;
                                }

                            ++RelocEntry;
                            }
                        }
                    }

                RelocDirRemaining -= RelocBlock->SizeOfBlock;
                RelocBlock = (UP_IMAGE_BASE_RELOCATION)((PUCHAR)RelocBlock + RelocBlock->SizeOfBlock );
                }

#ifdef TESTCODE

            printf( "\r%9d modified reloc targets\n", CountRelocChanges );

#endif TESTCODE

            //
            //  Now we want to reconstruct the .reloc table based on the new values
            //  hoping that it will more closely match the .reloc table in the new
            //  file.
            //
            //  First we want to sort our RelocArray by Rva.
            //

            if ( RelocArrayCount > 1 ) {
                RelocQsort( &RelocArray[ 0 ], &RelocArray[ RelocArrayCount - 1 ] );

#ifdef TESTCODE

                for ( i = 0; i < RelocArrayCount - 1; i++ ) {
                    if ( RelocArray[ i ].RelocRva > RelocArray[ i + 1 ].RelocRva ) {

                        printf( "\nReloc sort failed at index %d of %d\n", i, RelocArrayCount );

                        for ( i = 0; i < RelocArrayCount; i++ ) {
                            printf( "%08X\n", RelocArray[ i ].RelocRva );
                            }

                        exit( 1 );
                        break;
                        }
                    }

#endif // TESTCODE

                }

            RelocDirRemaining = (LONG)RelocDirSize;

            //
            //  Look for .reloc section to determine max size we can use for new
            //  .reloc data (may be bigger than old RelocDirSize).
            //

            SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
            SectionCount  = NtHeader->FileHeader.NumberOfSections;

            for ( i = 0; i < SectionCount; i++ ) {

                SectionName = *(UNALIGNED DWORDLONG*)( &SectionHeader[ i ].Name );
                SectionName |= 0x2020202020202020;  // fast lower case

                if ( SectionName == 0x2020636F6C65722E ) {      // ".reloc  "

                    if (( RelocDirOff >= SectionHeader[ i ].PointerToRawData ) &&
                        ( RelocDirOff <  SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData )) {

                        RelocDirRemaining = ( SectionHeader[ i ].PointerToRawData + SectionHeader[ i ].SizeOfRawData ) - RelocDirOff;
                        }
                    }
                }

            RelocDirRemaining &= ~1;    // force to even value
            RelocBlock = (UP_IMAGE_BASE_RELOCATION)( MappedFile + RelocDirOff );
            RelocArrayIndex = 0;

            while (( RelocDirRemaining > sizeof( IMAGE_BASE_RELOCATION )) &&
                   ( RelocArrayIndex < RelocArrayCount )) {

                RelocBlock->VirtualAddress = ( RelocArray[ RelocArrayIndex ].RelocRva & 0xFFFFF000 );
                RelocFirst = RelocEntry    = (PUSHORT)((PUCHAR)RelocBlock + sizeof( IMAGE_BASE_RELOCATION ));
                RelocDirRemaining         -= sizeof( IMAGE_BASE_RELOCATION );

                while (( RelocDirRemaining > 0 ) &&
                       ( RelocArrayIndex < RelocArrayCount ) &&
                       (( RelocArray[ RelocArrayIndex ].RelocRva & 0xFFFFF000 ) == RelocBlock->VirtualAddress )) {

                    *RelocEntry++ = (USHORT)(( RelocArray[ RelocArrayIndex ].RelocType << 12 ) | ( RelocArray[ RelocArrayIndex ].RelocRva & 0x00000FFF ));
                    RelocDirRemaining -= sizeof( USHORT );

                    if ((( RelocArray[ RelocArrayIndex ].RelocType << 12 ) == IMAGE_REL_BASED_HIGHADJ ) &&
                        ( RelocDirRemaining > 0 )) {

                        *RelocEntry++ = RelocArray[ RelocArrayIndex ].HighAdjValue;
                        RelocDirRemaining -= sizeof( USHORT );
                        }

                    ++RelocArrayIndex;
                    }

                if (( RelocDirRemaining > 0 ) && ((ULONG_PTR)RelocEntry & 2 )) {
                    *RelocEntry++ = 0;
                    RelocDirRemaining -= sizeof( USHORT );
                    }

                RelocBlock->SizeOfBlock = (ULONG)((PUCHAR)RelocEntry - (PUCHAR)RelocFirst ) + sizeof( IMAGE_BASE_RELOCATION );
                RelocBlock = (UP_IMAGE_BASE_RELOCATION)((PUCHAR)RelocBlock + RelocBlock->SizeOfBlock );
                }

            MyVirtualFree( RelocArray );
            }
        }

    else {

        //
        //  No relocation table exists for this binary.  We can still perform
        //  this transformation for x86 images by inferring some of the
        //  relocation targets in the mapped image by scanning the image for
        //  4-byte values that are virtual addresses that fall within the
        //  mapped image range.  We start with the address of the first
        //  section, assuming no relocs occur in the image header.
        //

        if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

            SectionHeader       = IMAGE_FIRST_SECTION( NtHeader );
            ImageFirstSectionMa = MappedFile  + SectionHeader->PointerToRawData;
            ImageFirstSectionVa = ImageBaseVa + SectionHeader->VirtualAddress;
            ImageLastVa         = ImageBaseVa + NtHeader->OptionalHeader.SizeOfImage;

            for ( p = ImageFirstSectionMa; p < ( MappedFileEnd - 4 ); p++ ) {

                RelocTargetVa = *(UNALIGNED ULONG *) p;

                if (( RelocTargetVa >= ImageFirstSectionVa ) && ( RelocTargetVa < ImageLastVa )) {

                    //
                    //  This looks like a 32-bit VA that points within the image,
                    //  so we'll transform it to the corresponding new address.
                    //

                    *(UNALIGNED ULONG *)( HintMap + ( p - MappedFile )) |= 0x01010101;

                    RelocTargetRva = RelocTargetVa - ImageBaseVa;

                    NewRva = GetNewRvaFromRiftTable( RiftTable, RelocTargetRva );

                    if ( NewRva != RelocTargetRva ) {
                        NewVa = NewRva + ImageBaseVa;
                        *(UNALIGNED ULONG *) p = NewVa;

#ifdef TESTCODE
                        ++CountRelocChanges;
#endif // TESTCODE

                        }

                    p += 3;
                    }
                }

#ifdef TESTCODE

            printf( "\r%9d modified inferred reloc targets\n", CountRelocChanges );

#endif // TESTCODE

            }
        }
    }


VOID
TransformOldFile_PE_Exports(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_EXPORT_DIRECTORY ExportBlock;
    ULONG UNALIGNED* Entry;
    PUCHAR MappedFile;
    PUCHAR MappedFileEnd;
    ULONG  FileOffset;
    ULONG  ExportDirOff;
    ULONG  ExportDirSize;
    ULONG  EntryCount;

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;

    ExportDirOff = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_EXPORT, &ExportDirSize );

    if (( ExportDirOff ) && (( ExportDirOff + ExportDirSize ) <= FileSize )) {

        memset( HintMap + ExportDirOff, 0x01, ExportDirSize );  // may need to be OR'd if other bits are used

        ExportBlock = (UP_IMAGE_EXPORT_DIRECTORY)( MappedFile + ExportDirOff );

        EntryCount = ExportBlock->NumberOfFunctions;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfFunctions );

        memset( HintMap + FileOffset, 0x01, EntryCount * sizeof( ULONG )); // may need to be OR'd if other bits are used

        Entry = (PULONG)( MappedFile + FileOffset );

        while ( EntryCount-- ) {
            ChangeOldRvaToNewRva( RiftTable, Entry++ );
            }

        EntryCount = ExportBlock->NumberOfNames;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfNames );

        memset( HintMap + FileOffset, 0x01, EntryCount * sizeof( ULONG )); // may need to be OR'd if other bits are used

        Entry = (PULONG)( MappedFile + FileOffset );

        while ( EntryCount-- ) {
            ChangeOldRvaToNewRva( RiftTable, Entry++ );
            }

        EntryCount = ExportBlock->NumberOfNames;
        FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ExportBlock->AddressOfNameOrdinals );

        memset( HintMap + FileOffset, 0x01, EntryCount * sizeof( USHORT )); // may need to be OR'd if other bits are used

        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->Name );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfFunctions );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfNames );
        ChangeOldRvaToNewRva( RiftTable, &ExportBlock->AddressOfNameOrdinals );
        }

    return;
    }


VOID
TransformOldFile_PE_Imports(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_IMPORT_BY_NAME    ImportByNameData;
    UP_IMAGE_IMPORT_DESCRIPTOR ImportBlock;
    UP_IMAGE_THUNK_DATA32      ThunkDataStart;
    UP_IMAGE_THUNK_DATA32      ThunkData;
    PUCHAR MappedFile;
    PUCHAR MappedFileEnd;
    ULONG  FileOffset;
    ULONG  ImportDirOff;
    ULONG  ImportDirSize;
    ULONG  ImportByNameDataOffset;

    MappedFile    = FileMappedImage;
    MappedFileEnd = MappedFile + FileSize;

    ImportDirOff = ImageDirectoryOffsetAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDirSize );

    if (( ImportDirOff ) && (( ImportDirOff + ImportDirSize ) <= FileSize )) {

        memset( HintMap + ImportDirOff, 0x01, ImportDirSize );  // may need to be OR'd if other bits are used

        ImportBlock = (UP_IMAGE_IMPORT_DESCRIPTOR)( MappedFile + ImportDirOff );

        while ( ImportBlock->OriginalFirstThunk ) {

            if ( ! ImportBlock->TimeDateStamp ) {

                FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ImportBlock->OriginalFirstThunk );

                ThunkData = ThunkDataStart = (UP_IMAGE_THUNK_DATA32)( MappedFile + FileOffset );

                while ( ThunkData->u1.Ordinal != 0 ) {

                    if ( ! IMAGE_SNAP_BY_ORDINAL32( ThunkData->u1.Ordinal )) {

                        ImportByNameDataOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ThunkData->u1.AddressOfData );

                        ImportByNameData = (UP_IMAGE_IMPORT_BY_NAME)( MappedFile + ImportByNameDataOffset );

                        memset( HintMap + ImportByNameDataOffset, 0x01, strlen( (LPSTR)ImportByNameData->Name ) + 3 ); // may need to be OR'd if other bits are used

                        ChangeOldRvaToNewRva( RiftTable, &ThunkData->u1.AddressOfData );
                        }

                    ThunkData++;
                    }

                memset( HintMap + FileOffset, 0x01, ((PUCHAR)ThunkData - (PUCHAR)ThunkDataStart )); // may need to be OR'd if other bits are used

                FileOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ImportBlock->FirstThunk );

                ThunkData = ThunkDataStart = (UP_IMAGE_THUNK_DATA32)( MappedFile + FileOffset );

                while ( ThunkData->u1.Ordinal != 0 ) {

                    if ( ! IMAGE_SNAP_BY_ORDINAL32( ThunkData->u1.Ordinal )) {

                        ImportByNameDataOffset = ImageRvaToFileOffset( NtHeader, (ULONG) ThunkData->u1.AddressOfData );

                        ImportByNameData = (UP_IMAGE_IMPORT_BY_NAME)( MappedFile + ImportByNameDataOffset );

                        memset( HintMap + ImportByNameDataOffset, 0x01, strlen( (LPSTR)ImportByNameData->Name ) + 3 ); // may need to be OR'd if other bits are used

                        ChangeOldRvaToNewRva( RiftTable, &ThunkData->u1.AddressOfData );
                        }

                    ThunkData++;
                    }

                memset( HintMap + FileOffset, 0x01, ((PUCHAR)ThunkData - (PUCHAR)ThunkDataStart )); // may need to be OR'd if other bits are used
                }

            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->Name );
            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->OriginalFirstThunk );
            ChangeOldRvaToNewRva( RiftTable, &ImportBlock->FirstThunk );

            ImportBlock++;
            }
        }

    //
    //  Another other big thing that will prevent long matches through
    //  the IMAGE_IMPORT_BY_NAME entries is the Hint values which
    //  may change (from implib for dll being imported).  The Hint
    //  values are stored between each of the names.  Maybe a separate
    //  "hint rift table" to fix those, or zero out all the hints in
    //  both the old and new files, then after the new file is built,
    //  go fill-in the hint values.
    //
    //  Currently we have no infrastructure for pre-modification of
    //  the new file before compression and post-modification after
    //  decompression.
    //

    return;
    }


#ifdef DONTCOMPILE  // jmps2 and jmps3 are experimental


VOID
TransformOldFile_PE_RelativeJmps2(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN PUCHAR NewFileMapped,         // OPTIONAL
    IN ULONG  NewFileSize,           // OPTIONAL
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_NT_HEADERS32   NewNtHeader;
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SectionExtent;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  SectionLastRva;
    ULONG  ImageLastRva;
    LONG   Displacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  i;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;
    ULONG CountRiftModifications = 0;
    ULONG CountRiftDeletions = 0;

    ULONG CountUnmatchedBranches = 0;

    ULONG CountUnmatchedE8 = 0;
    ULONG CountUnmatchedE9 = 0;
    ULONG CountUnmatched0F = 0;

    ULONG CountUnmatchedE8Targets = 0;
    ULONG CountUnmatchedE9Targets = 0;
    ULONG CountUnmatched0FTargets = 0;

    ULONG CountUnmatchedE8Followers = 0;
    ULONG CountUnmatchedE9Followers = 0;
    ULONG CountUnmatched0FFollowers = 0;

    ULONG CountUnmatchedE8Instructions = 0;
    ULONG CountUnmatchedE9Instructions = 0;
    ULONG CountUnmatched0FInstructions = 0;

    ULONG CountBranchInversions = 0;

#endif // TESTCODE

    NewNtHeader   = NewFileMapped ? GetNtHeader( NewFileMapped, NewFileSize ) : NULL;
    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = OldFileMapped + SectionOffset;
            SectionLastRva = SectionBaseRva + SectionLength;

            if (( SectionOffset < OldFileSize ) &&
                (( SectionOffset + SectionLength ) <= OldFileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if (( *p == 0xE8 ) ||       // call relative
                            ( *p == 0xE9 ) ||       // jmp relative
                            (( *p == 0x0F ) &&      // jcc relative (0F 8x)
                             (( *( p + 1 ) & 0xF0 ) == 0x80 ) &&
                             ( ++p < SearchExtent ))) {

                            //
                            //  Relative displacement is stored as
                            //  32-bit signed value following these
                            //  opcodes.  The displacement is relative
                            //  to the NEXT instruction, which is at
                            //  (p + 5).
                            //

                            Displacement = *(UNALIGNED LONG*)( p + 1 );

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8>, <E9>, and <0F><8x> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //
                            //  Also, for jmp and jcc instructions, verify that
                            //  the displacement is larger than +/- 127 because
                            //  if it wasn't, the instruction should have been
                            //  encoded as an 8-bit near branch, not a 32-bit
                            //  branch.  This prevents us from falsely matching
                            //  data that looks like:
                            //
                            //      xxE9xxxx 00000000
                            //

                            if (( *p == 0xE8 ) ||
                                ( Displacement >  127 ) ||
                                ( Displacement < -128 )) {

                                OffsetInSection = ( p + 5 ) - SectionStart;
                                OriginRva       = SectionBaseRva + OffsetInSection;
                                TargetRva       = OriginRva + Displacement;

                                if ((( TargetRva >= SectionBaseRva ) &&
                                     ( TargetRva <  SectionLastRva )) ||
                                    (( TargetRva <  ImageLastRva ) &&
                                     ( IsImageRvaInExecutableSection( NtHeader, TargetRva )))) {

                                    //
                                    //  Looks like a valid TargetRva.
                                    //

#ifndef PATCH_APPLY_CODE_ONLY

                                    //
                                    //  If we're creating the patch, then we need
                                    //  to validate the corresponding branch in the
                                    //  new file (might want to modify a rift entry).
                                    //

                                    if ( NewFileMapped != NULL ) {     // we're compressing

                                        BOOL OriginNext  = FALSE;
                                        BOOL OriginFound = FALSE;
                                        BOOL TargetNext  = FALSE;
                                        BOOL TargetFound = FALSE;

                                        ULONG  RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OriginRva );
                                        ULONG  NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                        PUCHAR NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                        ULONG NewOriginRva1 = NewOriginRva;
                                        ULONG NewOriginMo1  = NewOriginMa - NewFileMapped;
                                        ULONG NewOriginVa1  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;

                                        ULONG NewOriginRva2 = 0;
                                        ULONG NewOriginMo2  = 0;
                                        ULONG NewOriginVa2  = 0;

                                        UCHAR OldInstruction = *p;
                                        UCHAR NewInstruction = *( NewOriginMa - 5 );
                                        BOOL  InstructionsMatch = ( *p == *( NewOriginMa - 5 ));
                                        BOOL  FollowersMatch    = ( *( p + 5 ) == *NewOriginMa );
#endif // TESTCODE

                                        if (( *p == *( NewOriginMa - 5 )) &&    // instructions match, and
                                            (( *p == 0xE9 ) ||                  //   jmp instruction, or
                                             ( *( p + 5 ) == *NewOriginMa ))) { //   followers match

                                            OriginFound = TRUE;
                                            }

                                        else {

                                            if (( RiftIndexOrigin + 1 ) < RiftTable->RiftEntryCount ) {

                                                NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );
                                                NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                                NewOriginRva2 = NewOriginRva;
                                                NewOriginMo2  = NewOriginMa - NewFileMapped;
                                                NewOriginVa2  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;
#endif // TESTCODE

                                                if (( *p == *( NewOriginMa - 5 )) &&    // instructions match, and
                                                    (( *p == 0xE9 ) ||                  //   jmp instruction, or
                                                     ( *( p + 5 ) == *NewOriginMa ))) { //   followers match

                                                    OriginFound = TRUE;
                                                    OriginNext  = TRUE;
                                                    }
                                                }
                                            }

                                        if ( OriginFound ) {

                                            ULONG  RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, TargetRva );
                                            ULONG  NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );
                                            PUCHAR NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );
                                            PUCHAR TargetMa = OldFileMapped + ImageRvaToFileOffset( NtHeader, TargetRva );

                                            if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                                TargetFound = TRUE;
                                                }

                                            else {

                                                if (( RiftIndexTarget + 1 ) < RiftTable->RiftEntryCount ) {

                                                    NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );
                                                    NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );

                                                    if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                                        TargetFound = TRUE;
                                                        TargetNext  = TRUE;
                                                        }
                                                    }
                                                }

                                            if ( TargetFound ) {    // target and origin found

                                                if ( OriginNext ) {

                                                    //
                                                    //  Coast the rift entry at [RiftIndexOrigin+1]
                                                    //  backwards to the Rva of the instruction.
                                                    //

                                                    LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva - OriginRva );

                                                    RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva -= Delta;
                                                    RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                                    ++CountRiftModifications;
#endif // TESTCODE
                                                    ASSERT( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );

                                                    if ( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva ) {
                                                         RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
#ifdef TESTCODE
                                                         ++CountRiftDeletions;
#endif // TESTCODE
                                                         }
                                                    }

                                                if ( TargetNext ) {

                                                    //
                                                    //  Coast the rift entry at [RiftIndexTarget+1]
                                                    //  backwards to the Rva of the target.
                                                    //

                                                    LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva - TargetRva );

                                                    RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva -= Delta;
                                                    RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                                    ++CountRiftModifications;
#endif // TESTCODE
                                                    ASSERT( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );

                                                    if ( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva ) {
                                                         RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva;
#ifdef TESTCODE
                                                         ++CountRiftDeletions;
#endif // TESTCODE
                                                         }
                                                    }
                                                }
                                            }
#ifdef TESTCODE
                                        if ( ! (( OriginFound ) && ( TargetFound ))) {

                                            ++CountUnmatchedBranches;

                                            switch ( *p ) {

                                                case 0xE8:

                                                    ++CountUnmatchedE8;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatchedE8Targets;
                                                        }
                                                    else if ( InstructionsMatch ) {
                                                        ASSERT( ! FollowersMatch );
                                                        ++CountUnmatchedE8Followers;
                                                        }
                                                    else {
                                                        ++CountUnmatchedE8Instructions;

                                                        printf( "\rUnmatched E8 at old RVA %08X (VA %08X, FO %08X)\n"
                                                                  "    with either new RVA %08X (VA %08X, FO %08X)\n"
                                                                  "     or backcoasted RVA %08X (VA %08X, FO %08X)\n\n",
                                                                OriginRva - 5,
                                                                ( OriginRva - 5 ) + NtHeader->OptionalHeader.ImageBase,
                                                                p - OldFileMapped,
                                                                NewOriginRva1,
                                                                NewOriginVa1,
                                                                NewOriginMo1,
                                                                NewOriginRva2,
                                                                NewOriginVa2,
                                                                NewOriginMo2
                                                              );
                                                        }


                                                    break;

                                                case 0xE9:

                                                    ++CountUnmatchedE9;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatchedE9Targets;
                                                        }
                                                    else {
                                                        ++CountUnmatchedE9Instructions;
                                                        }

                                                    break;

                                                default:

                                                    ++CountUnmatched0F;

                                                    if ( OriginFound ) {
                                                        ++CountUnmatched0FTargets;
                                                        }
                                                    else if ( InstructionsMatch ) {
                                                        ASSERT( ! FollowersMatch );
                                                        ++CountUnmatched0FFollowers;
                                                        }
                                                    else {
                                                        ++CountUnmatched0FInstructions;
                                                        }

                                                    if ( ! InstructionsMatch ) {
                                                        if (( OldInstruction & ~1 ) == ( NewInstruction & ~1 )) {
                                                            ++CountBranchInversions;
                                                            }
                                                        }

                                                    break;

                                                }
                                            }
#endif // TESTCODE
                                        }

#endif // PATCH_APPLY_CODE_ONLY

                                    NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                    NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                    NewDisplacement = NewTargetRva - NewOriginRva;

                                    if ( NewDisplacement != Displacement ) {
                                        *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                        ++CountRelativeBranchChanges;
#endif // TESTCODE
                                        }

                                    p += 4;
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%d modified relative branches\n", CountRelativeBranchChanges );
    printf( "%d rift back-coasting modifications due to branch inspection\n", CountRiftModifications );
    printf( "%d rift deletions due to branch inspection back-coasting\n", CountRiftDeletions );
    printf( "%d total unmatched relative branches, composed of:\n", CountUnmatchedBranches );

    printf( "\t%d unmatched E8 (call)\n", CountUnmatchedE8 );
    printf( "\t\t%d unmatched E8 (call) instructions\n", CountUnmatchedE8Instructions );
    printf( "\t\t%d unmatched E8 (call) followers\n", CountUnmatchedE8Followers );
    printf( "\t\t%d unmatched E8 (call) targets\n", CountUnmatchedE8Targets );

    printf( "\t%d unmatched E9 (jmp)\n",    CountUnmatchedE9 );
    printf( "\t\t%d unmatched E9 (jmp) instructions\n", CountUnmatchedE9Instructions );
    printf( "\t\t%d unmatched E9 (jmp) targets\n", CountUnmatchedE9Targets );

    printf( "\t%d unmatched 0F 8x (jcc)\n", CountUnmatched0F );
    printf( "\t\t%d unmatched 0F 8x (jcc) instructions\n", CountUnmatched0FInstructions );
    printf( "\t\t\t%d unmatched 0F 8x (jcc) instruction inversions\n", CountBranchInversions );
    printf( "\t\t%d unmatched 0F 8x (jcc) followers\n", CountUnmatched0FFollowers );
    printf( "\t\t%d unmatched 0F 8x (jcc) targets\n", CountUnmatched0FTargets );

#endif // TESTCODE

    }


#ifdef _M_IX86

__inline char * mymemchr( char *buf, int c, unsigned count ) {

    __asm {
            mov     edi, buf
            mov     ecx, count
            mov     eax, c
            repne   scasb
            lea     eax, [edi-1]
            jz      RETURNIT
            xor     eax, eax
RETURNIT:
        }
    }

#else // ! _M_IX86

#define mymemchr memchr

#endif // ! _M_IX86



VOID
TransformOldFile_PE_RelativeJmps3(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN PUCHAR NewFileMapped,         // OPTIONAL
    IN ULONG  NewFileSize,           // OPTIONAL
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_NT_HEADERS32   NewNtHeader;
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SectionExtent;
    ULONG  SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  SectionLastRva;
    ULONG  ImageLastRva;
    LONG   DisplacementValue;
    LONG   NewDisplacement;
    LONG   OffsetToRvaAdjust;
    ULONG  FileOffset;
    ULONG  TargetOffset;
    UCHAR  Instruction;
    ULONG  InstructionLength;
    ULONG  DisplacementOrigin;
    ULONG  DisplacementOffset;
    BOOL   Skip;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;
    ULONG CountRiftModifications = 0;
    ULONG CountRiftDeletions = 0;

    ULONG CountUnmatchedBranches = 0;

    ULONG CountUnmatchedE8 = 0;
    ULONG CountUnmatchedE9 = 0;
    ULONG CountUnmatched0F = 0;

    ULONG CountUnmatchedE8Targets = 0;
    ULONG CountUnmatchedE9Targets = 0;
    ULONG CountUnmatched0FTargets = 0;

    ULONG CountUnmatchedE8Followers = 0;
    ULONG CountUnmatchedE9Followers = 0;
    ULONG CountUnmatched0FFollowers = 0;

    ULONG CountUnmatchedE8Instructions = 0;
    ULONG CountUnmatchedE9Instructions = 0;
    ULONG CountUnmatched0FInstructions = 0;

    ULONG CountBranchInversions = 0;

#endif // TESTCODE

    NewNtHeader   = NewFileMapped ? GetNtHeader( NewFileMapped, NewFileSize ) : NULL;
    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage - 1;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = OldFileMapped + SectionOffset;
            SectionLastRva = SectionBaseRva + SectionLength;
            OffsetToRvaAdjust = SectionHeader[ i ].VirtualAddress - SectionHeader[ i ].PointerToRawData;

            if (( SectionOffset < OldFileSize ) &&
                (( SectionOffset + SectionLength ) <= OldFileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionOffset + SectionLength - 6;

                    for ( FileOffset = SectionOffset; FileOffset < SearchExtent; FileOffset++ ) {

                        Instruction = OldFileMapped[ FileOffset ];

                        switch ( Instruction ) {

                            case 0xE8:

                                InstructionLength  = 6;     // E8 xx xx xx xx yy
                                DisplacementOrigin = FileOffset + 5;
                                DisplacementOffset = 1;
                                break;

                            case 0xE9:

continue;

                                InstructionLength  = 5;     // E9 xx xx xx xx
                                DisplacementOrigin = FileOffset + 5;
                                DisplacementOffset = 1;
                                break;

                            case 0x0F:

continue;

                                if (( OldFileMapped[ FileOffset + 1 ] & 0xF0 ) != 0x80 ) {
                                    continue;
                                    }

                                InstructionLength  = 7;     // 0F 8x yy yy yy yy zz
                                DisplacementOrigin = FileOffset + 6;
                                DisplacementOffset = 2;
                                break;

                            default:

                                continue;

                            }

                        Skip = FALSE;

                        for ( j = 0; j < InstructionLength; j++ ) {
                            if ( HintMap[ FileOffset + j ] & 0x01 ) {
                                Skip = TRUE;
                                break;
                                }
                            }

                        if ( Skip ) {
                            continue;
                            }

                        DisplacementValue = *(UNALIGNED LONG*)( OldFileMapped + FileOffset + DisplacementOffset );

                        if (( Instruction != 0xE8 ) &&
                            (( DisplacementValue > 127 ) || ( DisplacementValue < -128 ))) {

                            continue;
                            }

                        OriginRva = DisplacementOrigin + OffsetToRvaAdjust;
                        TargetRva = OriginRva + DisplacementValue;

                        if ( TargetRva > ImageLastRva ) {
                            continue;
                            }

                        TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                        if ( HintMap[ TargetOffset ] & 0x01 ) {
                            continue;
                            }

#ifndef PATCH_APPLY_CODE_ONLY

                        //
                        //  If we're creating the patch, then we want
                        //  to validate the corresponding branch in the
                        //  new file (might want to modify a rift entry).
                        //

                        if ( NewFileMapped != NULL ) {     // we're compressing

                            BOOL OriginNext  = FALSE;
                            BOOL OriginFound = FALSE;
                            BOOL TargetNext  = FALSE;
                            BOOL TargetFound = FALSE;

                            ULONG  RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OriginRva );
                            ULONG  NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                            PUCHAR NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                            ULONG NewOriginRva1 = NewOriginRva;
                            ULONG NewOriginMo1  = NewOriginMa - NewFileMapped;
                            ULONG NewOriginVa1  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;

                            ULONG NewOriginRva2 = 0;
                            ULONG NewOriginMo2  = 0;
                            ULONG NewOriginVa2  = 0;

                            BOOL InstructionsMatch;
                            BOOL FollowersMatch;
                            BOOL BranchInversion;

                            BranchInversion = FALSE;

                            if ( Instruction == 0x0F ) {
                                InstructionsMatch = ( *( NewOriginMa - 6 ) == Instruction ) && ( *( NewOriginMa - 5 ) == OldFileMapped[ FileOffset + 1 ] );

                                if ( ! InstructionsMatch ) {
                                    BranchInversion = ( *( NewOriginMa - 6 ) == Instruction ) && (( *( NewOriginMa - 5 ) & ~1 ) == ( OldFileMapped[ FileOffset + 1 ] & ~1 ));
                                    }
                                }
                            else {
                                InstructionsMatch = ( *( NewOriginMa - 5 ) == Instruction );
                                }

                            FollowersMatch = ( *NewOriginMa == OldFileMapped[ DisplacementOrigin ] );

#endif // TESTCODE

                            if (( InstructionsMatch ) &&
                                (( FollowersMatch ) || ( Instruction == 0xE9 ))) {

                                OriginFound = TRUE;
                                }

                            else {

                                if (( RiftIndexOrigin + 1 ) < RiftTable->RiftEntryCount ) {

                                    NewOriginRva = OriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );
                                    NewOriginMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewOriginRva );
#ifdef TESTCODE
                                    NewOriginRva2 = NewOriginRva;
                                    NewOriginMo2  = NewOriginMa - NewFileMapped;
                                    NewOriginVa2  = NewOriginRva + NewNtHeader->OptionalHeader.ImageBase;
#endif // TESTCODE

                                    if ( Instruction == 0x0F ) {
                                        InstructionsMatch = ( *( NewOriginMa - 6 ) == Instruction ) && ( *( NewOriginMa - 5 ) == OldFileMapped[ FileOffset + 1 ] );
                                        }
                                    else {
                                        InstructionsMatch = ( *( NewOriginMa - 5 ) == Instruction );
                                        }

                                    FollowersMatch = ( *NewOriginMa == OldFileMapped[ DisplacementOrigin ] );

                                    if (( InstructionsMatch ) &&
                                        (( FollowersMatch ) || ( Instruction == 0xE9 ))) {

                                        OriginFound = TRUE;
                                        OriginNext  = TRUE;
                                        }
                                    }
                                }

                            if ( OriginFound ) {

                                ULONG  RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, TargetRva );
                                ULONG  NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );
                                PUCHAR NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );
                                PUCHAR TargetMa = OldFileMapped + ImageRvaToFileOffset( NtHeader, TargetRva );

                                if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                    TargetFound = TRUE;
                                    }

                                else {

                                    if (( RiftIndexTarget + 1 ) < RiftTable->RiftEntryCount ) {

                                        NewTargetRva = TargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );
                                        NewTargetMa  = NewFileMapped + ImageRvaToFileOffset( NewNtHeader, NewTargetRva );

                                        if ( *NewTargetMa == *TargetMa ) {  // target instructions match
                                            TargetFound = TRUE;
                                            TargetNext  = TRUE;
                                            }
                                        }
                                    }

                                if ( TargetFound ) {    // target and origin found

                                    if ( OriginNext ) {

                                        //
                                        //  Coast the rift entry at [RiftIndexOrigin+1]
                                        //  backwards to the Rva of the instruction.
                                        //

                                        LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva - OriginRva );

                                        RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva -= Delta;
                                        RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                        ++CountRiftModifications;
#endif // TESTCODE
                                        ASSERT( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva );

                                        if ( RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].OldFileRva ) {
                                             RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
#ifdef TESTCODE
                                             ++CountRiftDeletions;
#endif // TESTCODE
                                             }
                                        }

                                    if ( TargetNext ) {

                                        //
                                        //  Coast the rift entry at [RiftIndexTarget+1]
                                        //  backwards to the Rva of the target.
                                        //

                                        LONG Delta = (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva - TargetRva );

                                        RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva -= Delta;
                                        RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva -= Delta;
#ifdef TESTCODE
                                        ++CountRiftModifications;
#endif // TESTCODE
                                        ASSERT( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva <= RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva );

                                        if ( RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva == RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].OldFileRva ) {
                                             RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva =  RiftTable->RiftEntryArray[ RiftIndexTarget + 1 ].NewFileRva;
#ifdef TESTCODE
                                             ++CountRiftDeletions;
#endif // TESTCODE
                                             }
                                        }
                                    }
                                }
#ifdef TESTCODE
                            if ( ! (( OriginFound ) && ( TargetFound ))) {

                                ++CountUnmatchedBranches;

                                switch ( Instruction ) {

                                    case 0xE8:

                                        ++CountUnmatchedE8;

                                        if ( OriginFound ) {
                                            ++CountUnmatchedE8Targets;
                                            }
                                        else if ( InstructionsMatch ) {
                                            ASSERT( ! FollowersMatch );
                                            ++CountUnmatchedE8Followers;
                                            }
                                        else {
                                            ++CountUnmatchedE8Instructions;

                                            printf( "\rUnmatched E8 at old RVA %08X (VA %08X, FO %08X)\n"
                                                      "    with either new RVA %08X (VA %08X, FO %08X)\n"
                                                      "     or backcoasted RVA %08X (VA %08X, FO %08X)\n\n",
                                                    OriginRva - 5,
                                                    ( OriginRva - 5 ) + NtHeader->OptionalHeader.ImageBase,
                                                    FileOffset,
                                                    NewOriginRva1,
                                                    NewOriginVa1,
                                                    NewOriginMo1,
                                                    NewOriginRva2,
                                                    NewOriginVa2,
                                                    NewOriginMo2
                                                  );
                                            }


                                        break;

                                    case 0xE9:

                                        ++CountUnmatchedE9;

                                        if ( OriginFound ) {
                                            ++CountUnmatchedE9Targets;
                                            }
                                        else {
                                            ++CountUnmatchedE9Instructions;
                                            }

                                        break;

                                    default:

                                        ++CountUnmatched0F;

                                        if ( OriginFound ) {
                                            ++CountUnmatched0FTargets;
                                            }
                                        else if ( InstructionsMatch ) {
                                            ASSERT( ! FollowersMatch );
                                            ++CountUnmatched0FFollowers;
                                            }
                                        else {
                                            ++CountUnmatched0FInstructions;
                                            }

                                        if ( BranchInversion ) {
                                            ++CountBranchInversions;
                                            }

                                        break;

                                    }
                                }
#endif // TESTCODE
                            }

#endif // PATCH_APPLY_CODE_ONLY

                        NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                        NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                        NewDisplacement = NewTargetRva - NewOriginRva;

                        if ( NewDisplacement != DisplacementValue ) {
                            *(UNALIGNED LONG*)( OldFileMapped + FileOffset + DisplacementOffset ) = NewDisplacement;
#ifdef TESTCODE
                            ++CountRelativeBranchChanges;
#endif // TESTCODE
                            }

                        FileOffset = DisplacementOrigin - 1;
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%d modified relative branches\n", CountRelativeBranchChanges );
    printf( "%d rift back-coasting modifications due to branch inspection\n", CountRiftModifications );
    printf( "%d rift deletions due to branch inspection back-coasting\n", CountRiftDeletions );
    printf( "%d total unmatched relative branches, composed of:\n", CountUnmatchedBranches );

    printf( "\t%d unmatched E8 (call)\n", CountUnmatchedE8 );
    printf( "\t\t%d unmatched E8 (call) instructions\n", CountUnmatchedE8Instructions );
    printf( "\t\t%d unmatched E8 (call) followers\n", CountUnmatchedE8Followers );
    printf( "\t\t%d unmatched E8 (call) targets\n", CountUnmatchedE8Targets );

    printf( "\t%d unmatched E9 (jmp)\n",    CountUnmatchedE9 );
    printf( "\t\t%d unmatched E9 (jmp) instructions\n", CountUnmatchedE9Instructions );
    printf( "\t\t%d unmatched E9 (jmp) targets\n", CountUnmatchedE9Targets );

    printf( "\t%d unmatched 0F 8x (jcc)\n", CountUnmatched0F );
    printf( "\t\t%d unmatched 0F 8x (jcc) instructions\n", CountUnmatched0FInstructions );
    printf( "\t\t\t%d unmatched 0F 8x (jcc) instruction inversions\n", CountBranchInversions );
    printf( "\t\t%d unmatched 0F 8x (jcc) followers\n", CountUnmatched0FFollowers );
    printf( "\t\t%d unmatched 0F 8x (jcc) targets\n", CountUnmatched0FTargets );

#endif // TESTCODE

    }


#endif // DONTCOMPILE

VOID
TransformOldFile_PE_RelativeJmps(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  ImageLastRva;
    LONG   Displacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  TargetOffset;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative branch instructions (different opcodes for different
    //  machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeBranchChanges = 0;

#endif // TESTCODE

    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = (PUCHAR)FileMappedImage + SectionOffset;

            if (( SectionOffset < FileSize ) &&
                (( SectionOffset + SectionLength ) <= FileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if (( *p == 0xE9 ) ||       // jmp relative32 (E9)
                            (( *p == 0x0F ) &&      // jcc relative32 (0F 8x)
                             (( *( p + 1 ) & 0xF0 ) == 0x80 ) &&
                             ( ++p < SearchExtent ))) {

                            //
                            //  Validate that instruction and target are NOT
                            //  something we've already identified as something
                            //  else (reloc target, etc).
                            //

                            Skip = FALSE;

                            if (( *p & 0xF0 ) == 0x80 ) {
                                if ( HintMap[ SectionOffset + ( p - SectionStart ) - 1 ] & 0x01 ) {
                                    Skip = TRUE;
                                    }
                                }

                            if ( ! Skip ) {
                                for ( j = 0; j < 5; j++ ) {
                                    if ( HintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                        Skip = TRUE;
                                        break;
                                        }
                                    }
                                }

                            if ( ! Skip ) {

                                //
                                //  Relative displacement is stored as 32-bit
                                //  signed value following these opcodes.  The
                                //  displacement is relative to the NEXT
                                //  instruction, which is at (p + 5).
                                //
                                //  Also, for jmp and jcc instructions, verify that
                                //  the displacement is larger than +/- 127 because
                                //  if it wasn't, the instruction should have been
                                //  encoded as an 8-bit near branch, not a 32-bit
                                //  branch.  This prevents us from falsely matching
                                //  data that looks like:
                                //
                                //      xxE9xxxx 00000000
                                //

                                Displacement = *(UNALIGNED LONG*)( p + 1 );

                                if (( Displacement >  127 ) ||
                                    ( Displacement < -128 )) {

                                    OffsetInSection = (ULONG)(( p + 5 ) - SectionStart );
                                    OriginRva       = SectionBaseRva + OffsetInSection;
                                    TargetRva       = OriginRva + Displacement;

                                    //
                                    //  We expect a lot of false positives here because
                                    //  occurences of <E9>, and <0F><8x> will
                                    //  likely occur in other parts of the instruction
                                    //  stream so now we validate that the TargetRva
                                    //  falls within the image and within an executable
                                    //  section.
                                    //

                                    if ( TargetRva < ImageLastRva ) {

                                        TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                                        if ( ! ( HintMap[ TargetOffset ] & 0x01 )) {

                                            //
                                            //  Looks like a valid TargetRva, so lookup its
                                            //  corresponding "new" RVA in the rift table.
                                            //

                                            NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                            NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                            NewDisplacement = NewTargetRva - NewOriginRva;

                                            if (( NewDisplacement >  127 ) ||
                                                ( NewDisplacement < -128 )) {

                                                if ( NewDisplacement != Displacement ) {

                                                    *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                                    ++CountRelativeBranchChanges;
#endif // TESTCODE
                                                    }
                                                }

                                            else {

                                                //
                                                //  If new displacement is 8 bits, it would be
                                                //  encoded as an 8-bit relative instruction.
                                                //  For E9, instructions, that is EB.  For
                                                //  0F 8x instructions, that is 7x.  In both
                                                //  cases, we're shrinking the instruction stream.
                                                //  We'll leave the extra bytes alone.
                                                //

                                                if ( *p == 0xE9 ) {

                                                    *p = 0xEB;
                                                    *( p + 1 ) = (CHAR) NewDisplacement;
                                                    }

                                                else {

                                                    *( p - 1 ) = (UCHAR)(( *p & 0x0F ) | ( 0x70 ));
                                                    *p = (CHAR) NewDisplacement;
                                                    }

#ifdef TESTCODE
                                                ++CountRelativeBranchChanges;
#endif // TESTCODE

                                                }

                                            p += 4;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%9d modified relative branches\n", CountRelativeBranchChanges );

#endif // TESTCODE

    }


VOID
TransformOldFile_PE_RelativeCalls(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN PRIFT_TABLE RiftTable,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  ImageLastRva;
    LONG   Displacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OriginRva;
    ULONG  TargetRva;
    ULONG  NewOriginRva;
    ULONG  NewTargetRva;
    ULONG  TargetOffset;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

    //
    //  For each executable section, scan for opcodes that indicate
    //  relative call or branch instructions (different opcodes for
    //  different machine types).
    //

#ifdef TESTCODE

    ULONG CountRelativeCallChanges = 0;

#endif // TESTCODE

    ImageLastRva  = NtHeader->OptionalHeader.SizeOfImage;
    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {

        if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

            SectionBaseRva = SectionHeader[ i ].VirtualAddress;
            SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
            SectionOffset  = SectionHeader[ i ].PointerToRawData;
            SectionStart   = (PUCHAR)FileMappedImage + SectionOffset;

            if (( SectionOffset < FileSize ) &&
                (( SectionOffset + SectionLength ) <= FileSize )) {

                if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction and target are NOT
                            //  something we've already identified as something
                            //  else (reloc target, etc).
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( HintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( ! Skip ) {

                                //
                                //  Relative displacement is stored as 32-bit
                                //  signed value following these opcodes.  The
                                //  displacement is relative to the NEXT
                                //  instruction, which is at (p + 5).
                                //

                                Displacement    = *(UNALIGNED LONG*)( p + 1 );
                                OffsetInSection = (ULONG)(( p + 5 ) - SectionStart );
                                OriginRva       = SectionBaseRva + OffsetInSection;
                                TargetRva       = OriginRva + Displacement;

                                //
                                //  We expect a lot of false positives here because
                                //  occurences of <E8> will
                                //  likely occur in other parts of the instruction
                                //  stream so now we validate that the TargetRva
                                //  falls within the image and within an executable
                                //  section.
                                //

                                if ( TargetRva < ImageLastRva ) {

                                    TargetOffset = ImageRvaToFileOffset( NtHeader, TargetRva );

                                    if ( ! ( HintMap[ TargetOffset ] & 0x01 )) {

                                        //
                                        //  Looks like a valid TargetRva, so lookup its
                                        //  corresponding "new" RVA in the rift table.
                                        //

                                        NewTargetRva = GetNewRvaFromRiftTable( RiftTable, TargetRva );
                                        NewOriginRva = GetNewRvaFromRiftTable( RiftTable, OriginRva );

                                        NewDisplacement = NewTargetRva - NewOriginRva;

                                        if ( NewDisplacement != Displacement ) {

                                            *(UNALIGNED LONG*)( p + 1 ) = NewDisplacement;
#ifdef TESTCODE
                                            ++CountRelativeCallChanges;
#endif // TESTCODE
                                            }

                                        p += 4;
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Need to implement the scan for Alpha platform
                    //  relative call/jmp/jcc opcodes.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE

    printf( "\r%9d modified relative calls\n", CountRelativeCallChanges );

#endif // TESTCODE

    }


VOID
TransformOldFile_PE_MarkNonExe(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN PUCHAR HintMap
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionCount;
    ULONG Offset;
    ULONG Size;
    ULONG Rva;
    ULONG i;

    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );

    //
    //  Need to mark all non-exectuble bytes in hint map:
    //
    //      Image header
    //      All PE image directories (import, export, etc)
    //      All non-executable sections
    //      All relocation targets
    //         (a reloc target can be in the middle of an instruction, but
    //          never the first byte of an instruction)
    //
    //  If we use other bits in hint map, may need to change these
    //  memsets to bitwise OR.
    //

    memset( HintMap + 0, 0x01, NtHeader->OptionalHeader.SizeOfHeaders );

    for ( i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++ ) {

        Rva  = NtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress;
        Size = NtHeader->OptionalHeader.DataDirectory[ i ].Size;

        if (( Rva != 0 ) && ( Size != 0 )) {
            Offset = ImageRvaToFileOffset( NtHeader, Rva );
            memset( HintMap + Offset, 0x01, Size );
            }
        }

    SectionHeader = IMAGE_FIRST_SECTION( NtHeader );
    SectionCount  = NtHeader->FileHeader.NumberOfSections;

    for ( i = 0; i < SectionCount; i++ ) {
        if ( ! ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE )) {
            memset( HintMap + SectionHeader[ i ].PointerToRawData, 0x01, SectionHeader[ i ].SizeOfRawData );
            }
        }
    }


typedef struct _RES_RECURSION_CONTEXT {
    PRIFT_TABLE RiftTable;
    PUCHAR      ResBase;
    PUCHAR      ResEnd;
    ULONG       ResSize;
    ULONG       ResDone;
    ULONG       ResTime;
    ULONG       OldResRva;
    ULONG       NewResRva;
    } RES_RECURSION_CONTEXT, *PRES_RECURSION_CONTEXT;


VOID
TransformResourceRecursive(
    IN PRES_RECURSION_CONTEXT ResContext,
    IN UP_IMAGE_RESOURCE_DIRECTORY ResDir
    )
    {
    UP_IMAGE_RESOURCE_DIRECTORY_ENTRY ResEntry;
    UP_IMAGE_RESOURCE_DATA_ENTRY ResData;
    ULONG ResEntryCount;
    ULONG NewOffset;
    ULONG NewRva;

    if (((PUCHAR)ResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < ResContext->ResEnd ) {

        ResContext->ResDone += sizeof( *ResDir );

        if ( ResContext->ResDone > ResContext->ResSize ) {
            return;
            }

        if ( ResDir->TimeDateStamp != ResContext->ResTime ) {
             ResDir->TimeDateStamp  = ResContext->ResTime;
             }

        ResEntryCount = ResDir->NumberOfNamedEntries + ResDir->NumberOfIdEntries;
        ResEntry = (UP_IMAGE_RESOURCE_DIRECTORY_ENTRY)( ResDir + 1 );

        while (( ResEntryCount > 0 ) && ((PUCHAR)ResEntry < ( ResContext->ResEnd - sizeof( *ResEntry )))) {

            if ( ResEntry->DataIsDirectory ) {

                TransformResourceRecursive(
                    ResContext,
                    (UP_IMAGE_RESOURCE_DIRECTORY)( ResContext->ResBase + ResEntry->OffsetToDirectory )
                    );
                }

            else {

                ResData = (UP_IMAGE_RESOURCE_DATA_ENTRY)( ResContext->ResBase + ResEntry->OffsetToData );

                if (((PUCHAR)ResData > ( ResContext->ResBase )) &&
                    ((PUCHAR)ResData < ( ResContext->ResEnd - sizeof( *ResData )))) {

                    ResContext->ResDone += ResData->Size;

                    if ( ResContext->ResDone > ResContext->ResSize ) {
                        return;
                        }

                    NewRva = GetNewRvaFromRiftTable( ResContext->RiftTable, ResData->OffsetToData );

                    if ( ResData->OffsetToData != NewRva ) {
                         ResData->OffsetToData  = NewRva;
                         }
                    }
                }

            NewOffset = GetNewRvaFromRiftTable( ResContext->RiftTable, ResContext->OldResRva + ResEntry->OffsetToDirectory ) - ResContext->NewResRva;

            if ( ResEntry->OffsetToDirectory != NewOffset ) {
                 ResEntry->OffsetToDirectory  = NewOffset;
                 }

            if ( ResEntry->NameIsString ) {

                NewOffset = GetNewRvaFromRiftTable( ResContext->RiftTable, ResContext->OldResRva + ResEntry->NameOffset ) - ResContext->NewResRva;

                if ( ResEntry->NameOffset != NewOffset ) {
                     ResEntry->NameOffset  = NewOffset;
                     }
                }

            ResContext->ResDone += sizeof( *ResEntry );

            if ( ResContext->ResDone > ResContext->ResSize ) {
                return;
                }

            ++ResEntry;
            --ResEntryCount;
            }
        }
    }


VOID
TransformOldFile_PE_Resources(
    IN UP_IMAGE_NT_HEADERS32 NtHeader,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  NewFileResTime,
    IN PRIFT_TABLE RiftTable
    )
    {
    RES_RECURSION_CONTEXT ResContext;

    ResContext.ResBase = ImageDirectoryMappedAddress(
                             NtHeader,
                             IMAGE_DIRECTORY_ENTRY_RESOURCE,
                             &ResContext.ResSize,
                             OldFileMapped,
                             OldFileSize
                             );

    if ( ResContext.ResBase ) {

        ResContext.ResEnd    = ResContext.ResBase + ResContext.ResSize;
        ResContext.ResDone   = 0;
        ResContext.OldResRva = ImageDirectoryRvaAndSize( NtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );
        ResContext.NewResRva = GetNewRvaFromRiftTable( RiftTable, ResContext.OldResRva );
        ResContext.ResTime   = NewFileResTime;
        ResContext.RiftTable = RiftTable;

        TransformResourceRecursive(
            &ResContext,
            (UP_IMAGE_RESOURCE_DIRECTORY) ResContext.ResBase
            );
        }
    }


BOOL
TransformCoffImage(
    IN     ULONG  TransformOptions,
    IN OUT UP_IMAGE_NT_HEADERS32 NtHeader,
    IN OUT PUCHAR OldFileMapped,
    IN     ULONG  OldFileSize,
    IN     ULONG  NewFileResTime,
    IN OUT PRIFT_TABLE RiftTable,
    IN OUT PUCHAR HintMap,
    ...
    )
    {
    PUCHAR InternalHintMap = NULL;

    //
    //  First, zero out the rift usage array
    //

    if ( RiftTable->RiftUsageArray != NULL ) {
        ZeroMemory( RiftTable->RiftUsageArray, RiftTable->RiftEntryAlloc * sizeof( RiftTable->RiftUsageArray[ 0 ] ));
        }

    //
    //  Allocated parallel "hint" mapping the same size as the old
    //  file.  Each one of the 8 bits corresponding to each byte in
    //  the old file can be used to track information about that
    //  byte during the transformations.
    //

    if ( HintMap == NULL ) {
        InternalHintMap = MyVirtualAlloc( OldFileSize );
        HintMap = InternalHintMap;
        }

    if ( HintMap != NULL ) {

        //
        //  Apply PE image transforms (each inside try/except)
        //

        __try {
            TransformOldFile_PE_MarkNonExe( NtHeader, OldFileMapped, OldFileSize, HintMap );
            }
        __except( EXCEPTION_EXECUTE_HANDLER ) {
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RELOCS )) {
            __try {
                TransformOldFile_PE_Relocations( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_IMPORTS )) {
            __try {
                TransformOldFile_PE_Imports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_EXPORTS )) {
            __try {
                TransformOldFile_PE_Exports( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RELJMPS )) {
            __try {
                TransformOldFile_PE_RelativeJmps( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RELCALLS )) {
            __try {
                TransformOldFile_PE_RelativeCalls( NtHeader, OldFileMapped, OldFileSize, RiftTable, HintMap );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( ! ( TransformOptions & PATCH_TRANSFORM_NO_RESOURCE )) {
            __try {
                TransformOldFile_PE_Resources( NtHeader, OldFileMapped, OldFileSize, NewFileResTime, RiftTable );
                }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                }
            }

        if ( InternalHintMap != NULL ) {
            MyVirtualFree( InternalHintMap );
            }
        }

    return TRUE;
    }


#ifndef PATCH_APPLY_CODE_ONLY


BOOL
AddRiftEntryToTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    )
    {
    ULONG RiftIndex;

    if (( OldRva != 0 ) && ( NewRva != 0 )) {

        RiftIndex = RiftTable->RiftEntryCount;

        if (( RiftIndex + 1 ) < RiftTable->RiftEntryAlloc ) {
            RiftTable->RiftEntryCount = RiftIndex + 1;
            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva = OldRva;
            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva = NewRva;
            return TRUE;
            }
        }

    return FALSE;
    }


BOOL
InsertRiftEntryInSortedTable(
    IN PRIFT_TABLE RiftTable,
    IN ULONG       RiftIndex,
    IN ULONG       OldRva,
    IN ULONG       NewRva
    )
    {
    if (( OldRva != 0 ) && ( NewRva != 0 )) {

        //
        //  First scoot to the correct index in case RiftIndex is off by a few.
        //

        while (( RiftIndex > 0 ) && ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva > OldRva )) {
            --RiftIndex;
            }

        while (( RiftIndex < RiftTable->RiftEntryCount ) && ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva < OldRva )) {
            ++RiftIndex;
            }

        if ( RiftIndex < RiftTable->RiftEntryCount ) {

            if ( RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva == OldRva ) {

                //
                //  Don't insert duplicates.  If it matches an existing OldRva,
                //  just warn if the NewRva doesn't match the rift.
                //

#ifdef TESTCODE

                if ( RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva != NewRva ) {

                    printf( "\rAttempt to insert different rift at same OldRva\n"
                            "    OldRva:%08X NewRva:%08X (discarded)\n"
                            "    OldRva:%08X NewRva:%08X (kept)\n\n",
                            OldRva,
                            NewRva,
                            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva,
                            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva
                          );

                    return FALSE;
                    }

#endif /* TESTCODE */

                return TRUE;
                }
            }

        //
        //  Verify we have enough allocation to insert a new entry.
        //

        if (( RiftTable->RiftEntryCount + 1 ) < RiftTable->RiftEntryAlloc ) {

            //
            //  Slide everything from RiftIndex to make room for new
            //  entry at RiftIndex.
            //

            LONG CountToMove = RiftTable->RiftEntryCount - RiftIndex;

            if ( CountToMove > 0 ) {

                MoveMemory(
                    &RiftTable->RiftEntryArray[ RiftIndex + 1 ],
                    &RiftTable->RiftEntryArray[ RiftIndex ],
                    CountToMove * sizeof( RiftTable->RiftEntryArray[ 0 ] )
                    );

#ifdef DONTCOMPILE  // we don't use the RiftUsageArray when we're inserting

                if ( RiftTable->RiftUsageArray ) {

                    MoveMemory(
                        &RiftTable->RiftUsageArray[ RiftIndex + 1 ],
                        &RiftTable->RiftUsageArray[ RiftIndex ],
                        CountToMove * sizeof( RiftTable->RiftUsageArray[ 0 ] )
                        );
                    }

#endif // DONTCOMPILE

                }

#ifdef DONTCOMPILE  // we don't use the RiftUsageArray when we're inserting

            RiftTable->RiftUsageArray[ RiftIndex ] = 0;

#endif // DONTCOMPILE

            RiftTable->RiftEntryArray[ RiftIndex ].OldFileRva = OldRva;
            RiftTable->RiftEntryArray[ RiftIndex ].NewFileRva = NewRva;
            RiftTable->RiftEntryCount++;

            return TRUE;
            }
        }

    return FALSE;
    }


VOID
__inline
SwapRifts(
    PRIFT_ENTRY One,
    PRIFT_ENTRY Two
    )
    {
    RIFT_ENTRY Tmp;

    Tmp  = *One;
    *One = *Two;
    *Two =  Tmp;
    }


VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    )
    {
    PRIFT_ENTRY Lower = LowerBound;
    PRIFT_ENTRY Upper = UpperBound;
    PRIFT_ENTRY Pivot = Lower + (( Upper - Lower ) / 2 );
    ULONG PivotRva = Pivot->OldFileRva;

    do  {

        while (( Lower <= Upper ) && ( Lower->OldFileRva <= PivotRva )) {
            ++Lower;
            }

        while (( Upper >= Lower ) && ( Upper->OldFileRva >= PivotRva )) {
            --Upper;
            }

        if ( Lower < Upper ) {
            SwapRifts( Lower++, Upper-- );
            }
        }

    while ( Lower <= Upper );

    if ( Lower < Pivot ) {
        SwapRifts( Lower, Pivot );
        Pivot = Lower;
        }
    else if ( Upper > Pivot ) {
        SwapRifts( Upper, Pivot );
        Pivot = Upper;
        }

    if ( LowerBound < ( Pivot - 1 )) {
        RiftQsort( LowerBound, Pivot - 1 );
        }

    if (( Pivot + 1 ) < UpperBound ) {
        RiftQsort( Pivot + 1, UpperBound );
        }
    }


VOID
RiftSortAndRemoveDuplicates(
    IN PUCHAR                OldFileMapped,
    IN ULONG                 OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR                NewFileMapped,
    IN ULONG                 NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN OUT PRIFT_TABLE       RiftTable
    )
    {
    ULONG i, n;

    if ( RiftTable->RiftEntryCount > 1 ) {

        n = RiftTable->RiftEntryCount - 1;

        RiftQsort( &RiftTable->RiftEntryArray[ 0 ], &RiftTable->RiftEntryArray[ n ] );

        for ( i = 0; i < n; i++ ) {

            while (( i < n ) &&
                   ( RiftTable->RiftEntryArray[ i     ].OldFileRva ==
                     RiftTable->RiftEntryArray[ i + 1 ].OldFileRva )) {

                if ( RiftTable->RiftEntryArray[ i     ].NewFileRva !=
                     RiftTable->RiftEntryArray[ i + 1 ].NewFileRva ) {

                    //
                    //  This is an ambiguous entry since the OldRva values
                    //  match but the NewRva values do not.  Inspect the
                    //  bytes in the old and new files and choose the one
                    //  that is correct.  If both are correct, or neither is
                    //  correct, choose the lower of the two NewRva values.
                    //

                    ULONG  ChosenNewRva;
                    PUCHAR OldFileRiftMa;
                    PUCHAR NewFileRiftMa1;
                    PUCHAR NewFileRiftMa2;

#ifdef TESTCODE
                    LPSTR Method = "lower";
#endif

                    ChosenNewRva = MIN( RiftTable->RiftEntryArray[ i     ].NewFileRva,
                                        RiftTable->RiftEntryArray[ i + 1 ].NewFileRva );

                    OldFileRiftMa = ImageRvaToMappedAddress(
                                        OldFileNtHeader,
                                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                                        OldFileMapped,
                                        OldFileSize
                                        );

                    NewFileRiftMa1 = ImageRvaToMappedAddress(
                                         NewFileNtHeader,
                                         RiftTable->RiftEntryArray[ i ].NewFileRva,
                                         NewFileMapped,
                                         NewFileSize
                                         );

                    NewFileRiftMa2 = ImageRvaToMappedAddress(
                                         NewFileNtHeader,
                                         RiftTable->RiftEntryArray[ i + 1 ].NewFileRva,
                                         NewFileMapped,
                                         NewFileSize
                                         );

                    //
                    //  Use try/except to touch the mapped files.
                    //

                    __try {

                        if ( OldFileRiftMa != NULL ) {

                            if ((  NewFileRiftMa1 != NULL ) &&
                                ( *NewFileRiftMa1 == *OldFileRiftMa ) &&
                                ((  NewFileRiftMa2 == NULL ) ||
                                 ( *NewFileRiftMa2 != *OldFileRiftMa ))) {

                                ChosenNewRva = RiftTable->RiftEntryArray[ i ].NewFileRva;
#ifdef TESTCODE
                                Method = "match inspection";
#endif
                                }

                            else if ((  NewFileRiftMa2 != NULL ) &&
                                     ( *NewFileRiftMa2 == *OldFileRiftMa ) &&
                                     ((  NewFileRiftMa1 == NULL ) ||
                                      ( *NewFileRiftMa1 != *OldFileRiftMa ))) {

                                ChosenNewRva = RiftTable->RiftEntryArray[ i + 1 ].NewFileRva;
#ifdef TESTCODE
                                Method = "match inspection";
#endif
                                }
                            }
                        }

                    __except( EXCEPTION_EXECUTE_HANDLER ) {
                        }

#ifdef TESTCODE
                    printf(
                        "RiftInfo contains ambiguous entries:\n"
                        "    OldRva:%08X NewRva:%08X (discarded)\n"
                        "    OldRva:%08X NewRva:%08X (kept %s)\n\n",
                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                        ( RiftTable->RiftEntryArray[ i ].NewFileRva == ChosenNewRva ) ?
                          RiftTable->RiftEntryArray[ i + 1 ].NewFileRva :
                          RiftTable->RiftEntryArray[ i ].NewFileRva,
                        RiftTable->RiftEntryArray[ i ].OldFileRva,
                        ChosenNewRva,
                        Method
                        );
#endif
                    RiftTable->RiftEntryArray[ i + 1 ].NewFileRva = ChosenNewRva;
                    }

                MoveMemory(
                    &RiftTable->RiftEntryArray[ i ],
                    &RiftTable->RiftEntryArray[ i + 1 ],
                    ( n - i ) * sizeof( RIFT_ENTRY )
                    );

                --n;

                }
            }

        RiftTable->RiftEntryCount = n + 1;
        }
    }


#ifdef _M_IX86

//
//  The x86 compiler might not optimize (a=x/y;b=x%y) into a single
//  divide instruction that provides both the quotient and the remainder.
//

#pragma warning( disable: 4035 )    // no return value

__inline
DWORDLONG
QuotientAndRemainder(
    IN ULONG Dividend,
    IN ULONG Divisor
    )
    {
    __asm {
        mov     eax, Dividend
        xor     edx, edx
        div     Divisor         ; eax <- quotient, edx <- remainder
        }
    }

#pragma warning( default: 4035 )    // no return value

#else // ! _M_IX86

__inline
DWORDLONG
QuotientAndRemainder(
    IN ULONG Dividend,
    IN ULONG Divisor
    )
    {
    ULONG Quotient  = ( Dividend / Divisor );
    ULONG Remainder = ( Dividend % Divisor );

    return (((DWORDLONG)Remainder << 32 ) | Quotient );
    }

#endif // ! _M_IX86


BOOL
IsMatchingResourceString(
    IN UP_IMAGE_RESOURCE_DIR_STRING_U OldString,
    IN UP_IMAGE_RESOURCE_DIR_STRING_U NewString
    )
    {
    USHORT Length;

    if ( OldString->Length != NewString->Length ) {
        return FALSE;
        }

    Length = OldString->Length;

    while ( Length-- ) {
        if ( OldString->NameString[ Length ] != NewString->NameString[ Length ] ) {
            return FALSE;
            }
        }

    return TRUE;
    }


VOID
GetResourceRiftInfoRecursive(
    IN UP_IMAGE_RESOURCE_DIRECTORY OldResDir,
    IN PUCHAR OldResBase,
    IN PUCHAR OldResEnd,
    IN ULONG  OldResRva,
    IN UP_IMAGE_RESOURCE_DIRECTORY NewResDir,
    IN PUCHAR NewResBase,
    IN PUCHAR NewResEnd,
    IN ULONG  NewResRva,
    IN PRIFT_TABLE RiftTable
    )
    {
    UP_IMAGE_RESOURCE_DIRECTORY_ENTRY OldResEntry;
    UP_IMAGE_RESOURCE_DIRECTORY_ENTRY NewResEntry;
    UP_IMAGE_RESOURCE_DATA_ENTRY OldResData;
    UP_IMAGE_RESOURCE_DATA_ENTRY NewResData;
    ULONG OldResEntryCount;
    ULONG NewResEntryCount;

    if ((( (PUCHAR) OldResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < OldResEnd ) &&
        (( (PUCHAR) NewResDir + sizeof( IMAGE_RESOURCE_DIRECTORY )) < NewResEnd )) {

        OldResEntryCount = OldResDir->NumberOfNamedEntries + OldResDir->NumberOfIdEntries;
        OldResEntry = (UP_IMAGE_RESOURCE_DIRECTORY_ENTRY) ( OldResDir + 1 );

        while (( OldResEntryCount > 0 ) && ((PUCHAR)OldResEntry < OldResEnd )) {

            NewResEntryCount = NewResDir->NumberOfNamedEntries + NewResDir->NumberOfIdEntries;
            NewResEntry = (UP_IMAGE_RESOURCE_DIRECTORY_ENTRY)( NewResDir + 1 );

            while ( NewResEntryCount > 0 ) {

                if ( (PUCHAR) NewResEntry > NewResEnd ) {
                    NewResEntryCount = 0;
                    break;
                    }

                if ( !OldResEntry->NameIsString && !NewResEntry->NameIsString &&
                     ( OldResEntry->Id == NewResEntry->Id )) {
                    break;
                    }
                else if (( OldResEntry->NameIsString && NewResEntry->NameIsString ) &&
                        IsMatchingResourceString(
                            (UP_IMAGE_RESOURCE_DIR_STRING_U)( OldResBase + OldResEntry->NameOffset ),
                            (UP_IMAGE_RESOURCE_DIR_STRING_U)( NewResBase + NewResEntry->NameOffset ))) {
                    break;
                    }

                ++NewResEntry;
                --NewResEntryCount;
                }

            if ( NewResEntryCount > 0 ) {

                if ( OldResEntry->NameIsString ) {

                    AddRiftEntryToTable(
                        RiftTable,
                        OldResRva + OldResEntry->NameOffset,
                        NewResRva + NewResEntry->NameOffset
                        );
                    }

                AddRiftEntryToTable(
                    RiftTable,
                    OldResRva + OldResEntry->OffsetToDirectory,
                    NewResRva + NewResEntry->OffsetToDirectory
                    );

                if ( OldResEntry->DataIsDirectory ) {

                    GetResourceRiftInfoRecursive(
                        (UP_IMAGE_RESOURCE_DIRECTORY)( OldResBase + OldResEntry->OffsetToDirectory ),
                        OldResBase,
                        OldResEnd,
                        OldResRva,
                        (UP_IMAGE_RESOURCE_DIRECTORY)( NewResBase + NewResEntry->OffsetToDirectory ),
                        NewResBase,
                        NewResEnd,
                        NewResRva,
                        RiftTable
                        );
                    }
                else {

                    OldResData = (UP_IMAGE_RESOURCE_DATA_ENTRY)( OldResBase + OldResEntry->OffsetToData );
                    NewResData = (UP_IMAGE_RESOURCE_DATA_ENTRY)( NewResBase + NewResEntry->OffsetToData );

                    AddRiftEntryToTable(
                        RiftTable,
                        OldResData->OffsetToData,
                        NewResData->OffsetToData
                        );
                    }
                }

            ++OldResEntry;
            --OldResEntryCount;
            }
        }
    }


BOOL
GetImageNonSymbolRiftInfo(
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN HANDLE SubAllocator,
    IN PRIFT_TABLE RiftTable
    )
    {

    //
    //  Create rifts for sections by section names.
    //

    {
    UP_IMAGE_SECTION_HEADER OldSectionHeader;
    UP_IMAGE_SECTION_HEADER NewSectionHeader;
    ULONG OldSectionCount;
    ULONG NewSectionCount;
    ULONG i, j;

    OldSectionHeader = IMAGE_FIRST_SECTION( OldFileNtHeader );
    OldSectionCount  = OldFileNtHeader->FileHeader.NumberOfSections;

    NewSectionHeader = IMAGE_FIRST_SECTION( NewFileNtHeader );
    NewSectionCount  = NewFileNtHeader->FileHeader.NumberOfSections;

    ASSERT( sizeof( OldSectionHeader->Name ) == sizeof( DWORDLONG ));

    for ( i = 0; i < OldSectionCount; i++ ) {

        for ( j = 0; j < NewSectionCount; j++ ) {

            if ( *(UNALIGNED DWORDLONG *)OldSectionHeader[ i ].Name ==
                 *(UNALIGNED DWORDLONG *)NewSectionHeader[ j ].Name ) {

                //
                //  Add a rift entry for this section name match.
                //
                //  Note that we create rift values here that are minus
                //  one from the actual section boundary because if a
                //  symbol exists at the start of the section, its rift
                //  entry would conflict with this section entry.
                //

                AddRiftEntryToTable(
                    RiftTable,
                    OldSectionHeader[ i ].VirtualAddress - 1,
                    NewSectionHeader[ i ].VirtualAddress - 1
                    );

                break;
                }
            }
        }
    }


    //
    //  Create rifts for image directories.
    //

    {
    ULONG i, n;

    n = MIN( OldFileNtHeader->OptionalHeader.NumberOfRvaAndSizes,
             NewFileNtHeader->OptionalHeader.NumberOfRvaAndSizes );

    for ( i = 0; i < n; i++ ) {

        if (( OldFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress ) &&
            ( OldFileNtHeader->OptionalHeader.DataDirectory[ i ].Size           ) &&
            ( NewFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress ) &&
            ( NewFileNtHeader->OptionalHeader.DataDirectory[ i ].Size           )) {

            AddRiftEntryToTable(
                RiftTable,
                OldFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress,
                NewFileNtHeader->OptionalHeader.DataDirectory[ i ].VirtualAddress
                );
            }
        }
    }

    //
    //  Create rifts for image export directory
    //

    {
    UP_IMAGE_EXPORT_DIRECTORY OldExportDir;
    UP_IMAGE_EXPORT_DIRECTORY NewExportDir;
    ULONG   OldExportIndex;
    ULONG   NewExportIndex;
    ULONG   OldExportNameCount;
    ULONG   NewExportNameCount;
    ULONG   OldExportFunctionCount;
    ULONG   NewExportFunctionCount;
    ULONG   UNALIGNED* OldExportFunctionArray;
    ULONG   UNALIGNED* NewExportFunctionArray;
    USHORT  UNALIGNED* OldExportNameToOrdinal;
    USHORT  UNALIGNED* NewExportNameToOrdinal;
    ULONG   UNALIGNED* OldExportNameArray;
    ULONG   UNALIGNED* NewExportNameArray;
    LPSTR   OldExportName;
    LPSTR   NewExportName;
    ULONG   OldOrdinal;
    ULONG   NewOrdinal;
    LONG    OrdinalBaseNewToOld;
    PBYTE   NewExportOrdinalNameExists;
    PSYMBOL_NODE NewExportSymbolNode;
    SYMBOL_TREE  NewExportNameTree;

    OldExportDir = ImageDirectoryMappedAddress(
                       OldFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       NULL,
                       OldFileMapped,
                       OldFileSize
                       );

    NewExportDir = ImageDirectoryMappedAddress(
                       NewFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                       NULL,
                       NewFileMapped,
                       NewFileSize
                       );

    if (( OldExportDir ) && ( NewExportDir )) {

        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->Name ),                  (ULONG)( NewExportDir->Name ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfFunctions ),    (ULONG)( NewExportDir->AddressOfFunctions ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfNames ),        (ULONG)( NewExportDir->AddressOfNames ));
        AddRiftEntryToTable( RiftTable, (ULONG)( OldExportDir->AddressOfNameOrdinals ), (ULONG)( NewExportDir->AddressOfNameOrdinals ));

        //
        //  Now build a tree of new export names, then walk old export names
        //  looking for matches in tree of new export names.
        //

        SymRBInitTree(
            &NewExportNameTree,
            SubAllocator
            );

        //
        //  First insert new export names.
        //

        NewExportNameCount     = NewExportDir->NumberOfNames;
        NewExportFunctionCount = NewExportDir->NumberOfFunctions;
        NewExportFunctionArray = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfFunctions,    NewFileMapped, NewFileSize );
        NewExportNameToOrdinal = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfNameOrdinals, NewFileMapped, NewFileSize );
        NewExportNameArray     = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG) NewExportDir->AddressOfNames,        NewFileMapped, NewFileSize );

        if ( NewExportNameArray ) {

            for ( NewExportIndex = 0; NewExportIndex < NewExportNameCount; NewExportIndex++ ) {

                if ( NewExportNameArray[ NewExportIndex ] ) {

                    NewExportName = ImageRvaToMappedAddress( NewFileNtHeader, NewExportNameArray[ NewExportIndex ], NewFileMapped, NewFileSize );

                    if ( NewExportName ) {

                        SymRBInsert( &NewExportNameTree, NewExportName, NewExportIndex );

                        }
                    }
                }
            }

        //
        //  Walk old export names and match them up.
        //

        OldExportNameCount     = OldExportDir->NumberOfNames;
        OldExportFunctionCount = OldExportDir->NumberOfFunctions;
        OldExportFunctionArray = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfFunctions,    OldFileMapped, OldFileSize );
        OldExportNameToOrdinal = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfNameOrdinals, OldFileMapped, OldFileSize );
        OldExportNameArray     = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG) OldExportDir->AddressOfNames,        OldFileMapped, OldFileSize );

        if ( OldExportNameArray ) {

            for ( OldExportIndex = 0; OldExportIndex < OldExportNameCount; OldExportIndex++ ) {

                if ( OldExportNameArray[ OldExportIndex ] ) {

                    OldExportName = ImageRvaToMappedAddress( OldFileNtHeader, OldExportNameArray[ OldExportIndex ], OldFileMapped, OldFileSize );

                    if ( OldExportName ) {

                        NewExportSymbolNode = SymRBFind( &NewExportNameTree, OldExportName );

                        if ( NewExportSymbolNode ) {

                            //
                            //  Found a name match.  The Rva field in the
                            //  symbol node contains the index into the
                            //  NewExportNameArray.
                            //
                            //  This match gives us two rift entries: one
                            //  for the locations of the names themselves,
                            //  and another for the locations of the
                            //  functions corresponding to those names.
                            //

                            NewExportIndex = NewExportSymbolNode->Rva;

                            AddRiftEntryToTable(
                                RiftTable,
                                OldExportNameArray[ OldExportIndex ],
                                NewExportNameArray[ NewExportIndex ]
                                );

                            if ( OldExportNameToOrdinal && NewExportNameToOrdinal ) {

                                OldOrdinal = OldExportNameToOrdinal[ OldExportIndex ];
                                NewOrdinal = NewExportNameToOrdinal[ NewExportIndex ];

                                if (( OldOrdinal < OldExportFunctionCount ) &&
                                    ( NewOrdinal < NewExportFunctionCount )) {

                                    AddRiftEntryToTable(
                                        RiftTable,
                                        OldExportFunctionArray[ OldOrdinal ],
                                        NewExportFunctionArray[ NewOrdinal ]
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

        //
        //  Now use ordinals to match any exports that don't have names.
        //  We use the NameToOrdinal table to determine if a name exists.
        //  For all ordinals that don't have a NameToOrdinal entry, we
        //  create a match.
        //

        if (( NewExportFunctionArray ) && ( NewExportNameToOrdinal )) {

            NewExportOrdinalNameExists = SubAllocate( SubAllocator, NewExportFunctionCount );

            if ( NewExportOrdinalNameExists != NULL ) {

                for ( NewExportIndex = 0; NewExportIndex < NewExportNameCount; NewExportIndex++ ) {

                    NewOrdinal = NewExportNameToOrdinal[ NewExportIndex ];

                    if ( NewOrdinal < NewExportFunctionCount ) {

                        NewExportOrdinalNameExists[ NewOrdinal ] = TRUE;

                        }
                    }

                OrdinalBaseNewToOld = (LONG)NewExportDir->Base - (LONG)OldExportDir->Base;

                for ( NewOrdinal = 0; NewOrdinal < NewExportFunctionCount; NewOrdinal++ ) {

                    if ( ! NewExportOrdinalNameExists[ NewOrdinal ] ) {

                        OldOrdinal = NewOrdinal + OrdinalBaseNewToOld;

                        if ( OldOrdinal < OldExportFunctionCount ) {

                            AddRiftEntryToTable(
                                RiftTable,
                                OldExportFunctionArray[ OldOrdinal ],
                                NewExportFunctionArray[ NewOrdinal ]
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    //
    //  Create rifts for image import directory
    //

    {
    UP_IMAGE_IMPORT_DESCRIPTOR OldImportDir;
    UP_IMAGE_IMPORT_DESCRIPTOR NewImportDir;

    ULONG OldImportDirRva;
    ULONG NewImportDirRva;

    ULONG OldImportDirIndex;
    ULONG NewImportDirIndex;

    LPSTR OldImportDllName;
    LPSTR NewImportDllName;

    LPSTR OldImportDllNameLowercase;
    LPSTR NewImportDllNameLowercase;

    UP_IMAGE_THUNK_DATA32 OldImportThunk;
    UP_IMAGE_THUNK_DATA32 NewImportThunk;

    UP_IMAGE_THUNK_DATA32 OldImportOriginalThunk;
    UP_IMAGE_THUNK_DATA32 NewImportOriginalThunk;

    ULONG OldImportThunkIndex;
    ULONG NewImportThunkIndex;

    UP_IMAGE_IMPORT_BY_NAME OldImportByName;
    UP_IMAGE_IMPORT_BY_NAME NewImportByName;

    LPSTR OldImportName;
    LPSTR NewImportName;

    SYMBOL_TREE NewImportDllNameTree;
    SYMBOL_TREE NewImportFunctionNameTree;

    PSYMBOL_NODE NewImportDllSymbolNode;
    PSYMBOL_NODE NewImportFunctionSymbolNode;

    OldImportDirRva = ImageDirectoryRvaAndSize(
                          OldFileNtHeader,
                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                          NULL
                          );

    NewImportDirRva = ImageDirectoryRvaAndSize(
                          NewFileNtHeader,
                          IMAGE_DIRECTORY_ENTRY_IMPORT,
                          NULL
                          );

    OldImportDir = ImageDirectoryMappedAddress(
                       OldFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_IMPORT,
                       NULL,
                       OldFileMapped,
                       OldFileSize
                       );

    NewImportDir = ImageDirectoryMappedAddress(
                       NewFileNtHeader,
                       IMAGE_DIRECTORY_ENTRY_IMPORT,
                       NULL,
                       NewFileMapped,
                       NewFileSize
                       );

    if (( OldImportDir ) && ( NewImportDir )) {

        //
        //  Now build a tree of new import names, then walk old export names
        //  looking for matches in tree of new import names.
        //

        SymRBInitTree(
            &NewImportDllNameTree,
            SubAllocator
            );

        SymRBInitTree(
            &NewImportFunctionNameTree,
            SubAllocator
            );

        for ( NewImportDirIndex = 0; NewImportDir[ NewImportDirIndex ].Characteristics; NewImportDirIndex++ ) {

            if ( NewImportDir[ NewImportDirIndex ].Name ) {

                NewImportDllName = ImageRvaToMappedAddress( NewFileNtHeader, NewImportDir[ NewImportDirIndex ].Name, NewFileMapped, NewFileSize );

                if ( NewImportDllName ) {

                    NewImportDllNameLowercase = MySubAllocStrDup( SubAllocator, NewImportDllName );

                    if ( NewImportDllNameLowercase ) {

                        MyLowercase( NewImportDllNameLowercase );

                        SymRBInsert( &NewImportDllNameTree, NewImportDllNameLowercase, NewImportDirIndex );

                        NewImportThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk, NewFileMapped, NewFileSize );

                        if ( NewImportThunk ) {

                            for ( NewImportThunkIndex = 0; NewImportThunk[ NewImportThunkIndex ].u1.Ordinal; NewImportThunkIndex++ ) {

                                if ( ! IMAGE_SNAP_BY_ORDINAL32( NewImportThunk[ NewImportThunkIndex ].u1.Ordinal )) {

                                    NewImportByName = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportThunk[ NewImportThunkIndex ].u1.AddressOfData, NewFileMapped, NewFileSize );

                                    if ( NewImportByName ) {

                                        NewImportName = MySubAllocStrDupAndCat(
                                                            SubAllocator,
                                                            NewImportDllNameLowercase,
                                                            (LPSTR)NewImportByName->Name,
                                                            '!'
                                                            );

                                        if ( NewImportName ) {

                                            SymRBInsert( &NewImportFunctionNameTree, NewImportName, NewImportThunkIndex );

                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        for ( OldImportDirIndex = 0; OldImportDir[ OldImportDirIndex ].Characteristics; OldImportDirIndex++ ) {

            if ( OldImportDir[ OldImportDirIndex ].Name ) {

                OldImportDllName = ImageRvaToMappedAddress( OldFileNtHeader, OldImportDir[ OldImportDirIndex ].Name, OldFileMapped, OldFileSize );

                if ( OldImportDllName ) {

                    OldImportDllNameLowercase = MySubAllocStrDup( SubAllocator, OldImportDllName );

                    if ( OldImportDllNameLowercase ) {

                        MyLowercase( OldImportDllNameLowercase );

                        NewImportDllSymbolNode = SymRBFind( &NewImportDllNameTree, OldImportDllNameLowercase );

                        if ( NewImportDllSymbolNode ) {

                            //
                            //  Found a matching dll import descriptor.
                            //  This will give us four rifts: one for the
                            //  descriptor itself, another for the
                            //  dll name referenced by the descriptor, and
                            //  the FirstThunk and OriginalFirstThunk
                            //  arrays.
                            //
                            //  The index of the new import descriptor is
                            //  stored in the Rva field of the node.
                            //

                            NewImportDirIndex = NewImportDllSymbolNode->Rva;

                            AddRiftEntryToTable(
                                RiftTable,
                                OldImportDirRva + ( OldImportDirIndex * sizeof( IMAGE_IMPORT_DESCRIPTOR )),
                                NewImportDirRva + ( NewImportDirIndex * sizeof( IMAGE_IMPORT_DESCRIPTOR ))
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].Name,
                                (ULONG)NewImportDir[ NewImportDirIndex ].Name
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].OriginalFirstThunk,
                                (ULONG)NewImportDir[ NewImportDirIndex ].OriginalFirstThunk
                                );

                            AddRiftEntryToTable(
                                RiftTable,
                                (ULONG)OldImportDir[ OldImportDirIndex ].FirstThunk,
                                (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk
                                );

                            OldImportThunk = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportDir[ OldImportDirIndex ].FirstThunk, OldFileMapped, OldFileSize );

                            if ( OldImportThunk ) {

                                for ( OldImportThunkIndex = 0; OldImportThunk[ OldImportThunkIndex ].u1.Ordinal; OldImportThunkIndex++ ) {

                                    if ( ! IMAGE_SNAP_BY_ORDINAL32( OldImportThunk[ OldImportThunkIndex ].u1.Ordinal )) {

                                        OldImportByName = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportThunk[ OldImportThunkIndex ].u1.AddressOfData, OldFileMapped, OldFileSize );

                                        if ( OldImportByName ) {

                                            OldImportName = MySubAllocStrDupAndCat(
                                                                SubAllocator,
                                                                OldImportDllNameLowercase,
                                                                (LPSTR)OldImportByName->Name,
                                                                '!'
                                                                );

                                            if ( OldImportName ) {

                                                NewImportFunctionSymbolNode = SymRBFind( &NewImportFunctionNameTree, OldImportName );

                                                if ( NewImportFunctionSymbolNode ) {

                                                    //
                                                    //  Found a matching import function name.
                                                    //  This will give us two rifts: one for the
                                                    //  FirstThunk arrays and another for the
                                                    //  OriginalFirstThunk arrays.
                                                    //
                                                    //  The index of the new import thunk is
                                                    //  stored in the Rva field of the node.
                                                    //

                                                    NewImportThunkIndex = NewImportFunctionSymbolNode->Rva;

                                                    NewImportThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].FirstThunk, NewFileMapped, NewFileSize );

                                                    if ( NewImportThunk ) {

                                                        AddRiftEntryToTable(
                                                            RiftTable,
                                                            (ULONG)OldImportThunk[ OldImportThunkIndex ].u1.AddressOfData,
                                                            (ULONG)NewImportThunk[ NewImportThunkIndex ].u1.AddressOfData
                                                            );
                                                        }

                                                    OldImportOriginalThunk = ImageRvaToMappedAddress( OldFileNtHeader, (ULONG)OldImportDir[ OldImportDirIndex ].OriginalFirstThunk, OldFileMapped, OldFileSize );
                                                    NewImportOriginalThunk = ImageRvaToMappedAddress( NewFileNtHeader, (ULONG)NewImportDir[ NewImportDirIndex ].OriginalFirstThunk, NewFileMapped, NewFileSize );

                                                    if ( OldImportOriginalThunk && NewImportOriginalThunk ) {

                                                        AddRiftEntryToTable(
                                                            RiftTable,
                                                            (ULONG)OldImportOriginalThunk[ OldImportThunkIndex ].u1.AddressOfData,
                                                            (ULONG)NewImportOriginalThunk[ NewImportThunkIndex ].u1.AddressOfData
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //
    //  Create rift entries for resources
    //

    {
    PUCHAR OldResBase, NewResBase;
    ULONG  OldResSize, NewResSize;
    ULONG  OldResRva,  NewResRva;

    OldResBase = ImageDirectoryMappedAddress(
                OldFileNtHeader,
                IMAGE_DIRECTORY_ENTRY_RESOURCE,
                &OldResSize,
                OldFileMapped,
                OldFileSize
                );

    NewResBase = ImageDirectoryMappedAddress(
                NewFileNtHeader,
                IMAGE_DIRECTORY_ENTRY_RESOURCE,
                &NewResSize,
                NewFileMapped,
                NewFileSize
                );

    if ( OldResBase && NewResBase ) {

        OldResRva = ImageDirectoryRvaAndSize( OldFileNtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );
        NewResRva = ImageDirectoryRvaAndSize( NewFileNtHeader, IMAGE_DIRECTORY_ENTRY_RESOURCE, NULL );

        GetResourceRiftInfoRecursive(
            (UP_IMAGE_RESOURCE_DIRECTORY) OldResBase,
            OldResBase,
            OldResBase + OldResSize,
            OldResRva,
            (UP_IMAGE_RESOURCE_DIRECTORY) NewResBase,
            NewResBase,
            NewResBase + NewResSize,
            NewResRva,
            RiftTable
            );
        }
    }

    //
    //  Gen rift info for other non-symbol stuff here.
    //

#ifdef TESTCODE
    printf( "\r%9d non-symbol rift entries\n", RiftTable->RiftEntryCount );
#endif

    return TRUE;
    }


VOID
MyUndecorateSymbol(
    IN  LPCSTR DecoratedSymbol,
    OUT LPSTR  UndecoratedSymbol,
    IN  DWORD  BufferSize
    )
    {
    LPCSTR d;
    LPCSTR e;
    ULONG  Len;
    ULONG  Ext;

    d = DecoratedSymbol;

    if (( d[ 0 ] == '.' ) &&
        ( d[ 1 ] == '.' ) &&
        ( d[ 2 ] == '?' )) {

        d += 2;
        }

    if ( *d == '?' ) {

        *UndecoratedSymbol = 0;   // in case UnDecorateSymbolName fails

        Imagehlp.UnDecorateSymbolName( d, UndecoratedSymbol, BufferSize, UNDNAME_NAME_ONLY );

        //
        //  UnDecorateSymbolName will strip any trailing '_nnn' (from BBT omap
        //  info), but we want to preserved it.  Check for that pattern in the
        //  original, and if found, append it to the new string.
        //

        d += strlen( d + 1 );   // point d to last character in string

        if (( *d >= '0' ) && ( *d <= '9' )) {

            do  {
                --d;
                }
            while (( *d >= '0' ) && ( *d <= '9' ));

            if ( *d == '_' ) {

                //
                //  Matches the '_nnn' pattern, append to new string.
                //

                if (( strlen( UndecoratedSymbol ) + strlen( d )) < ( BufferSize - 1 )) {
                    strcat( UndecoratedSymbol, d );
                    }
                }
            }
        }

    else {

        //
        //  Strip any preceding '_' or '@'.
        //

        if (( *d == '_' ) || ( *d == '@' )) {
            ++d;
            }

        //
        //  Find end of name as either terminator or '@nn'.
        //

        for ( e = d; ( *e ) && ( *e != '@' ); ) {
            ++e;
            }

        //
        //  Copy as much of name as will fit in the buffer.
        //

        Len = (ULONG)( e - d );

        if ( Len > ( BufferSize - 1 )) {
             Len = ( BufferSize - 1 );
             }

        memcpy( UndecoratedSymbol, d, Len );

        if ( *e == '@' ) {

            //
            //  Skip '@nn' to append remainder of symbol
            //

            do  {
                ++e;
                }
            while (( *e >= '0' ) && ( *e <= '9' ));

            d = e;

            while ( *e ) {
                ++e;
                }

            //
            //  Now 'd' points to first character after '@nn' and 'e' points
            //  to end of the string.  If the extension will fit in the buffer,
            //  append it.
            //

            Ext = (ULONG)( e - d );

            if (( Len + Ext ) < ( BufferSize - 1 )) {
                memcpy( UndecoratedSymbol + Len, d, Ext );
                }

            Len += Ext;
            }

        //
        //  Terminate the string.
        //

        UndecoratedSymbol[ Len ] = 0;
        }
    }


BOOL
UndecorateSymbolAndAddToTree(
    IN LPCSTR       SymbolName,
    IN ULONG        Rva,
    IN PSYMBOL_TREE SymbolTree
    )
    {
    ULONG SymbolNameSize  = (ULONG) strlen( SymbolName ) + 1;
    LPSTR UndecoratedName = _alloca( SymbolNameSize );
    PSYMBOL_NODE SymbolNode;

    MyUndecorateSymbol(
        SymbolName,
        UndecoratedName,
        SymbolNameSize
        );

    SymbolNode = SymRBInsert(
                     SymbolTree,
                     UndecoratedName,
                     Rva
                     );

    return ( SymbolNode != NULL );
    }


BOOL
CALLBACK
NewFileEnumSymbolsCallback(
    LPSTR     SymbolName,
    ULONG_PTR SymbolAddr,
    ULONG     SymbolSize,
    PVOID     Context
    )
    {
    PSYMBOL_CONTEXT SymbolContext = Context;
    PSYMBOL_NODE SymbolNode;
    ULONG NewRva;

    UNREFERENCED_PARAMETER( SymbolSize );

#ifdef TESTCODE

    if ( SymbolContext->OutFile != INVALID_HANDLE_VALUE ) {

        CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
        CHAR  Discarded;
        DWORD Actual;

        Discarded = 'X';
        NewRva = SymbolAddr;

        if ( NewRva > SymbolContext->NewImageBase ) {
            NewRva -= SymbolContext->NewImageBase;
            Discarded = ' ';
            }

        sprintf( TextBuffer, "%08X %c %s\r\n", NewRva, Discarded, SymbolName );
        WriteFile( SymbolContext->OutFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }

#endif // TESTCODE

    if ( SymbolAddr > SymbolContext->NewImageBase ) {

        NewRva = (ULONG)( SymbolAddr - SymbolContext->NewImageBase );

        SymbolNode = SymRBInsert(
                         &SymbolContext->NewDecoratedSymbolTree,
                         SymbolName,
                         NewRva
                         );

        return ( SymbolNode != NULL );
        }

    return TRUE;
    }


BOOL
CALLBACK
OldFileEnumSymbolsCallback(
    LPSTR     SymbolName,
    ULONG_PTR SymbolAddr,
    ULONG     SymbolSize,
    PVOID     Context
    )
    {
    PSYMBOL_CONTEXT SymbolContext = Context;
    PSYMBOL_NODE SymbolNode;
    ULONG OldRva;

    UNREFERENCED_PARAMETER( SymbolSize );

#ifdef TESTCODE

    if ( SymbolContext->OutFile != INVALID_HANDLE_VALUE ) {

        CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
        CHAR  Discarded;
        DWORD Actual;

        Discarded = 'X';
        OldRva = SymbolAddr;

        if ( OldRva > SymbolContext->OldImageBase ) {
            OldRva -= SymbolContext->OldImageBase;
            Discarded = ' ';
            }

        sprintf( TextBuffer, "%08X %c %s\r\n", OldRva, Discarded, SymbolName );
        WriteFile( SymbolContext->OutFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }

#endif // TESTCODE

    if ( SymbolAddr > SymbolContext->OldImageBase ) {

        OldRva = (ULONG)( SymbolAddr - SymbolContext->OldImageBase );

        SymbolNode = SymRBFind(
                         &SymbolContext->NewDecoratedSymbolTree,
                         SymbolName
                         );

        if ( SymbolNode ) {

            AddRiftEntryToTable( SymbolContext->RiftTable, OldRva, SymbolNode->Rva );

            SymbolNode->Hit = 1;

#ifdef TESTCODE

            CountDecoratedMatches++;

#endif // TESTCODE

            }

        else {

            //
            //  Didn't find matching new symbol.  Build a tree of unmatched
            //  old symbols with UNdecorated names.  Later we'll match up
            //  remaining unmatched new symbols to these unmatched old symbols
            //  by their undecorated names.
            //

            if ( SymbolContext->SymbolOptionFlags & PATCH_SYMBOL_UNDECORATED_TOO ) {

                return UndecorateSymbolAndAddToTree(
                           SymbolName,
                           OldRva,
                           &SymbolContext->OldUndecoratedSymbolTree
                           );
                }
            }
        }

    return TRUE;
    }


BOOL
MatchRemainingSymbolsThisNode(
    IN PSYMBOL_NODE NewDecoratedSymbolNode,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    if ( ! NewDecoratedSymbolNode->Hit ) {

        ULONG SymbolNameSize     = (ULONG) strlen( NewDecoratedSymbolNode->SymbolName ) + 1;
        LPSTR NewUndecoratedName = _alloca( SymbolNameSize );
        PSYMBOL_NODE NewUndecoratedSymbolNode;
        PSYMBOL_NODE OldUndecoratedSymbolNode;

        MyUndecorateSymbol(
            NewDecoratedSymbolNode->SymbolName,
            NewUndecoratedName,
            SymbolNameSize
            );

        OldUndecoratedSymbolNode = SymRBFind(
                                       OldUndecoratedSymbolTree,
                                       NewUndecoratedName
                                       );

        if ( OldUndecoratedSymbolNode ) {

            AddRiftEntryToTable(
                RiftTable,
                OldUndecoratedSymbolNode->Rva,
                NewDecoratedSymbolNode->Rva
                );

            OldUndecoratedSymbolNode->Hit = 1;

#ifdef TESTCODE

            CountUndecoratedMatches++;

#endif // TESTCODE

            }

        else {

            //
            //  This new symbol has no match in the old symbol tree.  Build a
            //  tree of unmatched new undecorated symbols.
            //

            NewUndecoratedSymbolNode = SymRBInsert(
                                           NewUndecoratedSymbolTree,
                                           NewUndecoratedName,
                                           NewDecoratedSymbolNode->Rva
                                           );

            return ( NewUndecoratedSymbolNode != NULL );
            }
        }

    return TRUE;
    }


BOOL
MatchRemainingSymbolsRecursive(
    IN PSYMBOL_NODE NewDecoratedSymbolNode,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    if ( NewDecoratedSymbolNode == RBNIL ) {
        return TRUE;
        }

    return ( MatchRemainingSymbolsRecursive( NewDecoratedSymbolNode->Left,  NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ) &&
             MatchRemainingSymbolsRecursive( NewDecoratedSymbolNode->Right, NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ) &&
             MatchRemainingSymbolsThisNode(  NewDecoratedSymbolNode,        NewUndecoratedSymbolTree, OldUndecoratedSymbolTree, RiftTable ));
    }


#ifdef TESTCODE

VOID
DumpUnHitSymbolNode(
    IN PSYMBOL_NODE SymbolNode,
    IN HANDLE hFile
    )
    {
    CHAR  TextBuffer[ 16 + MAX_SYMBOL_NAME_LENGTH ];
    DWORD Actual;

    if ( ! SymbolNode->Hit ) {
        sprintf( TextBuffer, "%08X   %s\r\n", SymbolNode->Rva, SymbolNode->SymbolName );
        WriteFile( hFile, TextBuffer, strlen( TextBuffer ), &Actual, NULL );
        }
    }

VOID
DumpUnHitSymbolNodesRecursive(
    IN PSYMBOL_NODE SymbolNode,
    IN HANDLE hFile
    )
    {
    if ( SymbolNode == RBNIL ) {
        return;
        }

    //
    //  The tree is in hash order, not Rva order, so the output will appear
    //  to be in random order (easily solved with sort.exe utility).
    //

    DumpUnHitSymbolNode( SymbolNode, hFile );
    DumpUnHitSymbolNodesRecursive( SymbolNode->Left,  hFile );
    DumpUnHitSymbolNodesRecursive( SymbolNode->Right, hFile );
    }


VOID
DumpUnHitSymbolNodes(
    IN PSYMBOL_TREE SymbolTree,
    IN LPCSTR DumpFileName
    )
    {
    HANDLE hFile;

    hFile = CreateFile(
                DumpFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        DumpUnHitSymbolNodesRecursive( SymbolTree->Root, hFile );

        CloseHandle( hFile );
        }
    }

#endif // TESTCODE


BOOL
MatchRemainingSymbols(
    IN PSYMBOL_TREE NewDecoratedSymbolTree,
    IN PSYMBOL_TREE NewUndecoratedSymbolTree,
    IN PSYMBOL_TREE OldUndecoratedSymbolTree,
    IN PRIFT_TABLE  RiftTable
    )
    {
    BOOL Success;

    //
    //  Walk old tree, for each unmatched symbol, undecorate it and try to
    //  find match in the undecorated new symbol tree.  If it fails to match,
    //  add it to the old undecorated tree.
    //

    Success = MatchRemainingSymbolsRecursive(
                  NewDecoratedSymbolTree->Root,
                  NewUndecoratedSymbolTree,
                  OldUndecoratedSymbolTree,
                  RiftTable
                  );

    if ( Success ) {

        //
        //  Now we have remaining unmatched undecorated symbols in the
        //  OldUndecoratedSymbolTree and NewUndecoratedSymbolTree.
        //
        //  Here is an opportunity to do soft name matching, like for
        //  BBT omap generated symbol names (have trailing '_nnn').
        //  Unfortunately, current versions of imagehlp append an '_nnn'
        //  value that is useless becaue it is not the offset from the
        //  start of the function.
        //

#ifdef TESTCODE

        DumpUnHitSymbolNodes( OldUndecoratedSymbolTree, "UnmatchedOldSymbols.out" );
        DumpUnHitSymbolNodes( NewUndecoratedSymbolTree, "UnmatchedNewSymbols.out" );

#endif // TESTCODE

        }

    return Success;
    }


BOOL
GetImageSymbolRiftInfo(
    IN HANDLE                  OldFileHandle,
    IN PUCHAR                  OldFileMapped,
    IN ULONG                   OldFileSize,
    IN UP_IMAGE_NT_HEADERS32   OldFileNtHeader,
    IN LPCSTR                  OldFileSymPath,
    IN ULONG                   OldFileOriginalChecksum,
    IN ULONG                   OldFileOriginalTimeDate,
    IN ULONG                   OldFileIndex,
    IN HANDLE                  NewFileHandle,
    IN PUCHAR                  NewFileMapped,
    IN ULONG                   NewFileSize,
    IN UP_IMAGE_NT_HEADERS32   NewFileNtHeader,
    IN LPCSTR                  NewFileSymPath,
    IN ULONG                   SymbolOptionFlags,
    IN HANDLE                  SubAllocator,
    IN PRIFT_TABLE             RiftTable,
    IN PPATCH_SYMLOAD_CALLBACK SymLoadCallback,
    IN PVOID                   SymLoadContext
    )
    {
    SYMBOL_CONTEXT SymbolContext;
    DWORD SymOptions;
    ULONG_PTR OldBase;
    ULONG_PTR NewBase;
    BOOL  Success;

#ifdef TESTCODE
    ULONG InitialRiftEntries = RiftTable->RiftEntryCount;
#endif

    UNREFERENCED_PARAMETER( OldFileNtHeader );
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );

    InitImagehlpCritSect();

    EnterCriticalSection( &ImagehlpCritSect );

    Success = LoadImagehlp();

    if ( Success ) {

        __try {

            SymOptions = Imagehlp.SymGetOptions();

            SymOptions &= ~SYMOPT_CASE_INSENSITIVE;
            SymOptions &= ~SYMOPT_UNDNAME;
            SymOptions &= ~SYMOPT_DEFERRED_LOADS;

            Imagehlp.SymSetOptions( SymOptions );

            Success = Imagehlp.SymInitialize( hProc, NewFileSymPath, FALSE );

            if ( Success ) {

                __try {

                    SymRBInitTree(
                        &SymbolContext.NewDecoratedSymbolTree,
                        SubAllocator
                        );

                    SymRBInitTree(
                        &SymbolContext.NewUndecoratedSymbolTree,
                        SubAllocator
                        );

                    SymRBInitTree(
                        &SymbolContext.OldUndecoratedSymbolTree,
                        SubAllocator
                        );

                    NewBase = Imagehlp.SymLoadModule( hProc, NewFileHandle, NULL, "New", (ULONG_PTR)NewFileMapped, NewFileSize );

                    Success = ( NewBase != 0 );

                    if ( Success ) {

                        __try {

                            if ( SymLoadCallback ) {

                                ZeroMemory( &ImagehlpModuleInfo, sizeof( ImagehlpModuleInfo ));
                                ImagehlpModuleInfo.SizeOfStruct = sizeof( ImagehlpModuleInfo );

                                Success = Imagehlp.SymGetModuleInfo(
                                              hProc,
                                              NewBase,
                                              &ImagehlpModuleInfo
                                              );

                                if ( Success ) {

                                    Success = SymLoadCallback(
                                                  0,
                                                  ImagehlpModuleInfo.LoadedImageName,
                                                  ImagehlpModuleInfo.SymType,
                                                  ImagehlpModuleInfo.CheckSum,
                                                  ImagehlpModuleInfo.TimeDateStamp,
                                                  NewFileNtHeader->OptionalHeader.CheckSum,
                                                  NewFileNtHeader->FileHeader.TimeDateStamp,
                                                  SymLoadContext
                                                  );
                                    }
                                }

                            if ( Success ) {

                                SymbolContext.NewImageBase      = NewBase;
                                SymbolContext.SymbolOptionFlags = SymbolOptionFlags;
                                SymbolContext.RiftTable         = RiftTable;
#ifdef TESTCODE
                                CountDecoratedMatches   = 0;
                                CountUndecoratedMatches = 0;

                                SymbolContext.OutFile = CreateFile(
                                                            "NewSymbols.out",
                                                            GENERIC_WRITE,
                                                            FILE_SHARE_READ,
                                                            NULL,
                                                            CREATE_ALWAYS,
                                                            FILE_ATTRIBUTE_NORMAL,
                                                            NULL
                                                            );
#endif // TESTCODE

                                Success = Imagehlp.SymEnumerateSymbols( hProc, NewBase, NewFileEnumSymbolsCallback, &SymbolContext );

#ifdef TESTCODE
                                if ( SymbolContext.OutFile != INVALID_HANDLE_VALUE ) {
                                    CloseHandle( SymbolContext.OutFile );
                                    }
#endif // TESTCODE
                                }
                        }

                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            Success = FALSE;
                            }

                        Imagehlp.SymUnloadModule( hProc, NewBase );
                        }
                    }

                __except( EXCEPTION_EXECUTE_HANDLER ) {
                    Success = FALSE;
                    }

                //
                //  Must do cleanup and reinitialize Imagehlp for this
                //  process identifier.  Otherwise it thinks the old
                //  module is still hanging around.
                //

                Imagehlp.SymCleanup( hProc );

                if ( Success ) {

                    Success = Imagehlp.SymInitialize( hProc, OldFileSymPath, FALSE );

                    if ( Success ) {

                        __try {

                            OldBase = Imagehlp.SymLoadModule( hProc, OldFileHandle, NULL, "Old", (ULONG_PTR)OldFileMapped, OldFileSize );

                            Success = ( OldBase != 0 );

                            if ( Success ) {

                                __try {

                                    if ( SymLoadCallback ) {

                                        ZeroMemory( &ImagehlpModuleInfo, sizeof( ImagehlpModuleInfo ));
                                        ImagehlpModuleInfo.SizeOfStruct = sizeof( ImagehlpModuleInfo );

                                        Success = Imagehlp.SymGetModuleInfo(
                                                      hProc,
                                                      OldBase,
                                                      &ImagehlpModuleInfo
                                                      );

                                        if ( Success ) {

                                            Success = SymLoadCallback(
                                                          OldFileIndex + 1,
                                                          ImagehlpModuleInfo.LoadedImageName,
                                                          ImagehlpModuleInfo.SymType,
                                                          ImagehlpModuleInfo.CheckSum,
                                                          ImagehlpModuleInfo.TimeDateStamp,
                                                          OldFileOriginalChecksum,
                                                          OldFileOriginalTimeDate,
                                                          SymLoadContext
                                                          );
                                            }
                                        }

                                    if ( Success ) {

                                        SymbolContext.OldImageBase = OldBase;
#ifdef TESTCODE
                                        SymbolContext.OutFile = CreateFile(
                                                                    "OldSymbols.out",
                                                                    GENERIC_WRITE,
                                                                    FILE_SHARE_READ,
                                                                    NULL,
                                                                    CREATE_ALWAYS,
                                                                    FILE_ATTRIBUTE_NORMAL,
                                                                    NULL
                                                                    );
#endif // TESTCODE

                                        Success = Imagehlp.SymEnumerateSymbols( hProc, OldBase, OldFileEnumSymbolsCallback, &SymbolContext );

#ifdef TESTCODE
                                        if ( SymbolContext.OutFile != INVALID_HANDLE_VALUE ) {
                                            CloseHandle( SymbolContext.OutFile );
                                            }
#endif // TESTCODE
                                        }

                                    if ( Success ) {

                                        //
                                        //  Need to match remaining decorated new symbols in tree
                                        //  with unmatched now-undecorated old symbols in other tree.
                                        //

                                        if ( SymbolOptionFlags & PATCH_SYMBOL_UNDECORATED_TOO ) {

                                            Success = MatchRemainingSymbols(
                                                          &SymbolContext.NewDecoratedSymbolTree,
                                                          &SymbolContext.NewUndecoratedSymbolTree,
                                                          &SymbolContext.OldUndecoratedSymbolTree,
                                                          RiftTable
                                                          );
                                            }
                                        }
                                    }

                                __except( EXCEPTION_EXECUTE_HANDLER ) {
                                    Success = FALSE;
                                    }

                                Imagehlp.SymUnloadModule( hProc, OldBase );
                                }
                            }

                        __except( EXCEPTION_EXECUTE_HANDLER ) {
                            Success = FALSE;
                            }

                        Imagehlp.SymCleanup( hProc );
                        }
                    }
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            Success = FALSE;
            }
        }

    LeaveCriticalSection( &ImagehlpCritSect );

    if ( ! Success ) {
        SetLastError( ERROR_PATCH_IMAGEHLP_FAILURE );
        }

#ifdef TESTCODE
    printf( "\r%9d decorated symbol matches\n", CountDecoratedMatches );
    printf( "\r%9d undecorated symbol matches\n", CountUndecoratedMatches );
    printf( "\r%9d rift entries from symbols\n", RiftTable->RiftEntryCount - InitialRiftEntries );
#endif

    return Success;
    }


BOOL
OptimizeImageRiftInfo(
    IN PUCHAR                OldFileMapped,
    IN ULONG                 OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR                NewFileMapped,
    IN ULONG                 NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN HANDLE                SubAllocator,
    IN PRIFT_TABLE           RiftTable
    )
    {
    UNREFERENCED_PARAMETER( OldFileMapped );
    UNREFERENCED_PARAMETER( OldFileSize );
    UNREFERENCED_PARAMETER( OldFileNtHeader );
    UNREFERENCED_PARAMETER( NewFileMapped );
    UNREFERENCED_PARAMETER( NewFileSize );
    UNREFERENCED_PARAMETER( NewFileNtHeader );
    UNREFERENCED_PARAMETER( SubAllocator );
    UNREFERENCED_PARAMETER( RiftTable );

    return TRUE;
    }

#if 0   // This is test code

BOOL
OptimizeImageRiftInfo(
    IN PUCHAR                OldFileMapped,
    IN ULONG                 OldFileSize,
    IN UP_IMAGE_NT_HEADERS32 OldFileNtHeader,
    IN PUCHAR                NewFileMapped,
    IN ULONG                 NewFileSize,
    IN UP_IMAGE_NT_HEADERS32 NewFileNtHeader,
    IN HANDLE                SubAllocator,
    IN PRIFT_TABLE           RiftTable
    )
    {
    UP_IMAGE_SECTION_HEADER SectionHeader;
    ULONG  SectionCount;
    PUCHAR SectionStart;
    PUCHAR SearchExtent;
    ULONG  SectionLength;
    ULONG  SectionOffset;
    ULONG  SectionBaseRva;
    ULONG  OldFileLastRva;
    ULONG  NewFileLastRva;
    LONG   OldDisplacement;
    LONG   NewDisplacement;
    ULONG  OffsetInSection;
    ULONG  OldOriginRva;
    ULONG  OldTargetRva;
    ULONG  TargetOffset;
    PUCHAR OldFileHintMap;
    PUCHAR NewFileHintMap;
    PUCHAR OldFileCopy;
    PUCHAR NewFileCopy;
    PVOID  OldFileCopyNtHeader;
    PVOID  NewFileCopyNtHeader;
    BOOL   Success;
    BOOL   Skip;
    ULONG  i;
    ULONG  j;
    PUCHAR p;

#ifdef TESTCODE
    ULONG CountVerifiedE8Rifts = 0;
    ULONG CountDiscoveredE8Rifts = 0;
#endif // TESTCODE

    //
    //  Stage1:
    //
    //      Trusting existing rift info, search for E8/E9/Jcc instructions in
    //      the Old file, get the corresponding rift, inspect the corresponding
    //      instruction in the New file.  If they match, great.  If they don't
    //      match, search for a correponding instruction in the new file by
    //      looking forward up to the next rift.  If find a suitable match,
    //      create a new rift entry to support it.
    //
    //      We don't have the benefit of non-exe marked bytes here.
    //

    if ( OldFileNtHeader->FileHeader.Machine != NewFileNtHeader->FileHeader.Machine ) {
        return TRUE;    // not much we can do here!
        }

    //
    //  We need the HintMap to determine which bytes in the files are not
    //  executable.  The Transform function currently provides this, but
    //  we don't want to modify our mapped file views here.  So, allocate
    //  a range of VM and make a copy of the file to Transform, perform
    //  the transformations on that copy just to produce a hint map, then
    //  free the transformed copy (do this for both old and new files).
    //

    Success = FALSE;

    OldFileHintMap = MyVirtualAlloc( OldFileSize );
    NewFileHintMap = MyVirtualAlloc( NewFileSize );

    if ( OldFileHintMap && NewFileHintMap ) {

        OldFileCopy = MyVirtualAlloc( OldFileSize );

        if ( OldFileCopy ) {

            CopyMemory( OldFileCopy, OldFileMapped, OldFileSize );

            OldFileCopyNtHeader = GetNtHeader( OldFileCopy, OldFileSize );

            Success = TransformCoffImage(
                          ( PATCH_TRANSFORM_NO_RELJMPS | PATCH_TRANSFORM_NO_RELCALLS | PATCH_TRANSFORM_NO_RESOURCE ),
                          OldFileCopyNtHeader,
                          OldFileCopy,
                          OldFileSize,
                          0,
                          RiftTable,
                          OldFileHintMap
                          );

            MyVirtualFree( OldFileCopy );
            }

        if ( Success ) {

            Success = FALSE;

            NewFileCopy = MyVirtualAlloc( NewFileSize );

            if ( NewFileCopy ) {

                CopyMemory( NewFileCopy, NewFileMapped, NewFileSize );

                NewFileCopyNtHeader = GetNtHeader( NewFileCopy, NewFileSize );

                Success = TransformCoffImage(
                              ( PATCH_TRANSFORM_NO_RELJMPS | PATCH_TRANSFORM_NO_RELCALLS | PATCH_TRANSFORM_NO_RESOURCE ),
                              NewFileCopyNtHeader,
                              NewFileCopy,
                              NewFileSize,
                              0,
                              RiftTable,
                              NewFileHintMap
                              );

                MyVirtualFree( NewFileCopy );
                }
            }
        }

    if ( Success ) {

        //
        //  We now have valid OldFileHintMap and NewFileHintMap.
        //

        OldFileLastRva = OldFileNtHeader->OptionalHeader.SizeOfImage;
        NewFileLastRva = NewFileNtHeader->OptionalHeader.SizeOfImage;

        InsertRiftEntryInSortedTable( RiftTable, RiftTable->RiftEntryCount, OldFileLastRva, NewFileLastRva );

        SectionHeader  = IMAGE_FIRST_SECTION( OldFileNtHeader );
        SectionCount   = OldFileNtHeader->FileHeader.NumberOfSections;

        for ( i = 0; i < SectionCount; i++ ) {

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

                SectionBaseRva = SectionHeader[ i ].VirtualAddress;
                SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
                SectionOffset  = SectionHeader[ i ].PointerToRawData;
                SectionStart   = OldFileMapped + SectionOffset;

                if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction is not something that
                            //  the HintMap indicates is not an executable
                            //  instruction.  We're looking for a relative
                            //  call instruction here, so it would not be a
                            //  reloc target.
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( OldFileHintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( Skip ) {
                                continue;
                                }

                            //
                            //  Relative displacement is stored as 32-bit
                            //  signed value following these opcodes.  The
                            //  displacement is relative to the NEXT
                            //  instruction, which is at (p + 5).
                            //

                            OldDisplacement = *(UNALIGNED LONG*)( p + 1 );
                            OffsetInSection = ( p + 5 ) - SectionStart;
                            OldOriginRva     = SectionBaseRva + OffsetInSection;
                            OldTargetRva     = OldOriginRva + OldDisplacement;

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //

                            if ( OldTargetRva < OldFileLastRva ) {

                                TargetOffset = ImageRvaToFileOffset( OldFileNtHeader, OldTargetRva );

                                if ( ! ( OldFileHintMap[ TargetOffset ] & 0x01 )) {

                                    //
                                    //  Looks like a valid TargetRva, so lookup the
                                    //  corresponding "new" RVAs in the rift table.
                                    //

                                    ULONG RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OldOriginRva );
                                    ULONG RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, OldTargetRva );

                                    ULONG NewOriginRva = OldOriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                    ULONG NewTargetRva = OldTargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );

                                    PUCHAR NewOriginMa = ImageRvaToMappedAddress( NewFileNtHeader, NewOriginRva, NewFileMapped, NewFileSize );
                                    PUCHAR NewTargetMa = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                    PUCHAR OldTargetMa = ImageRvaToMappedAddress( OldFileNtHeader, OldTargetRva, OldFileMapped, OldFileSize );
                                    PUCHAR OldOriginMa = p + 5;

                                    if (( NewOriginMa ) && ( NewTargetMa ) && ( OldTargetMa )) {

                                        PUCHAR OldInstruct = p;
                                        PUCHAR NewInstruct = NewOriginMa - 5;

                                        //
                                        //  A verified call instruction should match the
                                        //  instruction byte, the byte following the
                                        //  instruction, and the target byte, because
                                        //  they should all be executable code that is
                                        //  not modified by relocs.
                                        //
                                        //  Also verify the NewFileHintMap.
                                        //

                                        if (( *OldInstruct == *NewInstruct ) &&
                                            ( *OldOriginMa == *NewOriginMa ) &&
                                            ( *OldTargetMa == *NewTargetMa )) {

                                            ULONG NewInstructOffset = NewInstruct - NewFileMapped;
                                            ULONG NewTargetOffset   = NewTargetMa - NewFileMapped;
                                            BOOL  Skip = FALSE;

                                            for ( j = 0; j < 5; j++ ) {
                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                    Skip = TRUE;
                                                    break;
                                                    }
                                                }

                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                Skip = TRUE;
                                                }

                                            if ( ! Skip ) {

                                                //
                                                //  This is a bonafide good match.  Add a rift entry
                                                //  for both the instruction and the target.  We do
                                                //  this so that subsequent rift insertions don't get
                                                //  between the rift that coasted to these and these.
                                                //

                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
#ifdef TESTCODE
                                                CountVerifiedE8Rifts++;
#endif // TESTCODE

                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Implement Alpha platform stuff here.
                    //

                    }
                }
            }

        for ( i = 0; i < SectionCount; i++ ) {

            if ( SectionHeader[ i ].Characteristics & IMAGE_SCN_MEM_EXECUTE ) {

                SectionBaseRva = SectionHeader[ i ].VirtualAddress;
                SectionLength  = MIN( SectionHeader[ i ].Misc.VirtualSize, SectionHeader[ i ].SizeOfRawData );
                SectionOffset  = SectionHeader[ i ].PointerToRawData;
                SectionStart   = OldFileMapped + SectionOffset;

                if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 ) {

                    SearchExtent = SectionStart + SectionLength - 5;

                    for ( p = SectionStart; p < SearchExtent; p++ ) {

                        if ( *p == 0xE8 ) {         // call relative32

                            //
                            //  Validate that instruction is not something that
                            //  the HintMap indicates is not an executable
                            //  instruction.  We're looking for a relative
                            //  call instruction here, so it would not be a
                            //  reloc target.
                            //

                            Skip = FALSE;

                            for ( j = 0; j < 5; j++ ) {
                                if ( OldFileHintMap[ SectionOffset + ( p - SectionStart ) + j ] & 0x01 ) {
                                    Skip = TRUE;
                                    break;
                                    }
                                }

                            if ( Skip ) {
                                continue;
                                }

                            //
                            //  Relative displacement is stored as 32-bit
                            //  signed value following these opcodes.  The
                            //  displacement is relative to the NEXT
                            //  instruction, which is at (p + 5).
                            //

                            OldDisplacement = *(UNALIGNED LONG*)( p + 1 );
                            OffsetInSection = ( p + 5 ) - SectionStart;
                            OldOriginRva     = SectionBaseRva + OffsetInSection;
                            OldTargetRva     = OldOriginRva + OldDisplacement;

                            //
                            //  We expect a lot of false positives here because
                            //  occurences of <E8> will
                            //  likely occur in other parts of the instruction
                            //  stream so now we validate that the TargetRva
                            //  falls within the image and within an executable
                            //  section.
                            //

                            if ( OldTargetRva < OldFileLastRva ) {

                                TargetOffset = ImageRvaToFileOffset( OldFileNtHeader, OldTargetRva );

                                if ( ! ( OldFileHintMap[ TargetOffset ] & 0x01 )) {

                                    //
                                    //  Looks like a valid TargetRva, so lookup the
                                    //  corresponding "new" RVAs in the rift table.
                                    //

                                    ULONG RiftIndexOrigin = FindRiftTableEntryForOldRva( RiftTable, OldOriginRva );
                                    ULONG RiftIndexTarget = FindRiftTableEntryForOldRva( RiftTable, OldTargetRva );

                                    ULONG NewOriginRva = OldOriginRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexOrigin ].OldFileRva );
                                    ULONG NewTargetRva = OldTargetRva + (LONG)( RiftTable->RiftEntryArray[ RiftIndexTarget ].NewFileRva - RiftTable->RiftEntryArray[ RiftIndexTarget ].OldFileRva );

                                    PUCHAR NewOriginMa = ImageRvaToMappedAddress( NewFileNtHeader, NewOriginRva, NewFileMapped, NewFileSize );
                                    PUCHAR NewTargetMa = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                    PUCHAR OldTargetMa = ImageRvaToMappedAddress( OldFileNtHeader, OldTargetRva, OldFileMapped, OldFileSize );
                                    PUCHAR OldOriginMa = p + 5;

                                    if (( NewOriginMa ) && ( NewTargetMa ) && ( OldTargetMa )) {

                                        PUCHAR OldInstruct = p;
                                        PUCHAR NewInstruct = NewOriginMa - 5;

                                        //
                                        //  A verified call instruction should match the
                                        //  instruction byte, the byte following the
                                        //  instruction, and the target byte, because
                                        //  they should all be executable code that is
                                        //  not modified by relocs.
                                        //
                                        //  Check NewHintMap too.
                                        //

                                        if (( *OldInstruct == *NewInstruct ) &&
                                            ( *OldOriginMa == *NewOriginMa ) &&
                                            ( *OldTargetMa == *NewTargetMa )) {

                                            ULONG NewInstructOffset = NewInstruct - NewFileMapped;
                                            ULONG NewTargetOffset   = NewTargetMa - NewFileMapped;
                                            BOOL  Skip = FALSE;

                                            for ( j = 0; j < 5; j++ ) {
                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                    Skip = TRUE;
                                                    break;
                                                    }
                                                }

                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                Skip = TRUE;
                                                }

                                            if ( ! Skip ) {

                                                //
                                                //  This is a bonafide good match.
                                                //

                                                continue;
                                                }
                                            }

                                        {

                                            //
                                            //  Instructions don't match.  Scan to find
                                            //  matching instruction in new file.  Scan
                                            //  the extent of this rift entry.
                                            //

                                            PUCHAR ScanInstruct;
                                            PUCHAR LowestMaToScan;
                                            PUCHAR HighestMaToScan;
                                            ULONG  LowestRvaToScan  = RiftTable->RiftEntryArray[ RiftIndexOrigin ].NewFileRva;
                                            ULONG  HighestRvaToScan = RiftTable->RiftEntryArray[ RiftIndexOrigin + 1 ].NewFileRva;
                                            ULONG  ExpectedTargetRva = NewTargetRva;
                                            BOOL   Found = FALSE;

                                            LowestMaToScan  = ImageRvaToMappedAddress( NewFileNtHeader, LowestRvaToScan,  NewFileMapped, NewFileSize );
                                            HighestMaToScan = ImageRvaToMappedAddress( NewFileNtHeader, HighestRvaToScan, NewFileMapped, NewFileSize );

                                            HighestMaToScan -= 5;   // size of instruction

                                            for ( ScanInstruct = NewInstruct + 1; ScanInstruct <= HighestMaToScan; ScanInstruct++ ) {

                                                if ( *ScanInstruct == 0xE8 ) {

                                                    //
                                                    //  check NewHintMap
                                                    //

                                                    NewOriginMa     = ScanInstruct + 5;
                                                    NewOriginRva    = MappedAddressToImageRva( NewFileNtHeader, NewOriginMa, NewFileMapped );
                                                    NewDisplacement = *(UNALIGNED LONG*)( ScanInstruct + 1 );
                                                    NewTargetRva    = NewOriginRva + NewDisplacement;
                                                    NewTargetMa     = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                                    if (( NewOriginRva ) && ( NewTargetMa )) {

                                                        //
                                                        //  We already know *OldInstruct == *ScanInstruct
                                                        //

                                                        if (( *OldOriginMa == *NewOriginMa ) &&
                                                            ( *OldTargetMa == *NewTargetMa ) &&
                                                            ( NewTargetRva == ExpectedTargetRva )) {

                                                            ULONG NewInstructOffset = ScanInstruct - NewFileMapped;
                                                            ULONG NewTargetOffset   = NewTargetMa  - NewFileMapped;
                                                            BOOL  Skip = FALSE;

                                                            for ( j = 0; j < 5; j++ ) {
                                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                                    Skip = TRUE;
                                                                    break;
                                                                    }
                                                                }

                                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                                Skip = TRUE;
                                                                }

                                                            if ( ! Skip ) {

                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
                                                                Found = TRUE;
#ifdef TESTCODE
                                                                CountDiscoveredE8Rifts++;
#endif // TESTCODE
                                                                break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                            if ( Found ) {
                                                continue;
                                                }

                                            for ( ScanInstruct = NewInstruct - 1; ScanInstruct >= LowestMaToScan; ScanInstruct-- ) {

                                                if ( *ScanInstruct == 0xE8 ) {

                                                    //
                                                    //  check NewHintMap
                                                    //

                                                    NewOriginMa     = ScanInstruct + 5;
                                                    NewOriginRva    = MappedAddressToImageRva( NewFileNtHeader, NewOriginMa, NewFileMapped );
                                                    NewDisplacement = *(UNALIGNED LONG*)( ScanInstruct + 1 );
                                                    NewTargetRva    = NewOriginRva + NewDisplacement;
                                                    NewTargetMa     = ImageRvaToMappedAddress( NewFileNtHeader, NewTargetRva, NewFileMapped, NewFileSize );

                                                    if (( NewOriginRva ) && ( NewTargetMa )) {

                                                        //
                                                        //  We already know *OldInstruct == *ScanInstruct
                                                        //

                                                        if (( *OldOriginMa == *NewOriginMa ) &&
                                                            ( *OldTargetMa == *NewTargetMa ) &&
                                                            ( NewTargetRva == ExpectedTargetRva )) {

                                                            ULONG NewInstructOffset = ScanInstruct - NewFileMapped;
                                                            ULONG NewTargetOffset   = NewTargetMa  - NewFileMapped;
                                                            BOOL  Skip = FALSE;

                                                            for ( j = 0; j < 5; j++ ) {
                                                                if ( NewFileHintMap[ NewInstructOffset + j ] & 0x01 ) {
                                                                    Skip = TRUE;
                                                                    break;
                                                                    }
                                                                }

                                                            if ( NewFileHintMap[ NewTargetOffset + j ] & 0x01 ) {
                                                                Skip = TRUE;
                                                                }

                                                            if ( ! Skip ) {

                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexOrigin, OldOriginRva - 5, NewOriginRva - 5 );
                                                                InsertRiftEntryInSortedTable( RiftTable, RiftIndexTarget, OldTargetRva, NewTargetRva );
                                                                Found = TRUE;
#ifdef TESTCODE
                                                                CountDiscoveredE8Rifts++;
#endif // TESTCODE
                                                                break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                else if ( OldFileNtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA ) {

                    //
                    //  Implement Alpha platform stuff here.
                    //

                    }
                }
            }
        }

#ifdef TESTCODE
    printf( "\r%9d verified E8 rifts\n", CountVerifiedE8Rifts );
    printf( "\r%9d discovered E8 rifts\n", CountDiscoveredE8Rifts );
#endif // TESTCODE

    if ( OldFileHintMap ) {
        MyVirtualFree( OldFileHintMap );
        }

    if ( NewFileHintMap ) {
        MyVirtualFree( NewFileHintMap );
        }

    return Success;
    }


#endif // 0 (test code)


BOOL
GenerateRiftTable(
    IN HANDLE OldFileHandle,
    IN PUCHAR OldFileMapped,
    IN ULONG  OldFileSize,
    IN ULONG  OldFileOriginalChecksum,
    IN ULONG  OldFileOriginalTimeDate,
    IN HANDLE NewFileHandle,
    IN PUCHAR NewFileMapped,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN PPATCH_OPTION_DATA OptionData,
    IN ULONG  OldFileIndex,
    IN PRIFT_TABLE RiftTable
    )
    {
    UP_IMAGE_NT_HEADERS32 OldFileNtHeader;
    UP_IMAGE_NT_HEADERS32 NewFileNtHeader;
    LPCSTR OldFileSymPath;
    LPCSTR NewFileSymPath;
    HANDLE SubAllocator;
    ULONG SymbolOptionFlags;
    BOOL Success = FALSE;

    UNREFERENCED_PARAMETER( OptionFlags );

    SymbolOptionFlags = 0;
    SubAllocator = NULL;

    __try {

        //
        //  See if both files are PE images.
        //

        OldFileNtHeader = GetNtHeader( OldFileMapped, OldFileSize );

        if ( OldFileNtHeader ) {

            NewFileNtHeader = GetNtHeader( NewFileMapped, NewFileSize );

            if ( NewFileNtHeader ) {

                //
                //  Both files are PE images.
                //

                SubAllocator = CreateSubAllocator( 0x100000, 0x100000 );

                if ( ! SubAllocator ) {
                    Success = FALSE;
                    __leave;
                    }

                //
                //  Before we bother with debug info, we can create initial
                //  rift data from the section headers to compensate for any
                //  section base RVA differences.  This will work even if we
                //  don't have debug symbols.
                //

                Success = GetImageNonSymbolRiftInfo(
                              OldFileMapped,
                              OldFileSize,
                              OldFileNtHeader,
                              NewFileMapped,
                              NewFileSize,
                              NewFileNtHeader,
                              SubAllocator,
                              RiftTable
                              );

                //
                //  Now get rift info from symbols
                //

                if ( Success ) {

                    if (( OptionData ) && ( OptionData->SizeOfThisStruct >= sizeof( PATCH_OPTION_DATA ))) {

                        SymbolOptionFlags = OptionData->SymbolOptionFlags;

                        if ( ! ( SymbolOptionFlags & PATCH_SYMBOL_NO_IMAGEHLP )) {

                            if ( OptionData->OldFileSymbolPathArray ) {

                                OldFileSymPath = OptionData->OldFileSymbolPathArray[ OldFileIndex ];
                                NewFileSymPath = OptionData->NewFileSymbolPath;

                                if (( OldFileSymPath ) && ( NewFileSymPath )) {

                                    Success = GetImageSymbolRiftInfo(
                                                  OldFileHandle,
                                                  OldFileMapped,
                                                  OldFileSize,
                                                  OldFileNtHeader,
                                                  OldFileSymPath,
                                                  OldFileOriginalChecksum,
                                                  OldFileOriginalTimeDate,
                                                  OldFileIndex,
                                                  NewFileHandle,
                                                  NewFileMapped,
                                                  NewFileSize,
                                                  NewFileNtHeader,
                                                  NewFileSymPath,
                                                  SymbolOptionFlags,
                                                  SubAllocator,
                                                  RiftTable,
                                                  OptionData->SymLoadCallback,
                                                  OptionData->SymLoadContext
                                                  );

                                    if ( SymbolOptionFlags & PATCH_SYMBOL_NO_FAILURES ) {
#ifdef TESTCODE
                                        if (( ! Success ) && ( GetLastError() == ERROR_PATCH_IMAGEHLP_FAILURE )) {
                                            printf( "\rWARNING: Imagehlp.Dll failure\n" );
                                            }
#endif
                                        Success = TRUE;
                                        }
                                    }
                                }
                            }
                        }
                    }

                if ( Success ) {

                    RiftSortAndRemoveDuplicates(
                        OldFileMapped,
                        OldFileSize,
                        OldFileNtHeader,
                        NewFileMapped,
                        NewFileSize,
                        NewFileNtHeader,
                        RiftTable
                        );

                    //
                    //  Now we can optimize the rift info by peeking into
                    //  the mapped files.
                    //

                    Success = OptimizeImageRiftInfo(
                                  OldFileMapped,
                                  OldFileSize,
                                  OldFileNtHeader,
                                  NewFileMapped,
                                  NewFileSize,
                                  NewFileNtHeader,
                                  SubAllocator,
                                  RiftTable
                                  );
                    }

#ifdef TESTCODE

                if ( Success ) {

                    HANDLE hFile = CreateFile(
                                       "RiftInfo.out",
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL
                                       );

                    if ( hFile != INVALID_HANDLE_VALUE ) {

                        CHAR  TextBuffer[ 24 ];
                        DWORD Actual;
                        ULONG i;

                        for ( i = 0; i < RiftTable->RiftEntryCount; i++ ) {
                            sprintf( TextBuffer, "%08X %08X\r\n", RiftTable->RiftEntryArray[ i ].OldFileRva, RiftTable->RiftEntryArray[ i ].NewFileRva );
                            WriteFile( hFile, TextBuffer, 19, &Actual, NULL );
                            }

                        CloseHandle( hFile );
                        }
                    }

#endif // TESTCODE

                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    if ( SubAllocator ) {
        DestroySubAllocator( SubAllocator );
        }

    return Success;
    }


#endif // PATCH_APPLY_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\src_dll.inc ===
#
#  Must set TARGETNAME and DLLBASE before including this file
#

TARGETTYPE=DYNLINK

UMTYPE=windows

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           ..\..\lzx\encoder\$(O)\lzxpc.lib \
           ..\..\lzx\decoder\$(O)\lzxpd.lib

C_DEFINES=$(C_DEFINES) -DBUILDING_PATCHAPI_DLL=1

SOURCES=$(SOURCES) $(TARGETNAME).rc


i386_SOURCES=..\i386\exsup.asm  \
             ..\i386\exsup3.asm

!if "$(TARGET_DIRECTORY)" != "i386"
!undef NO_NTDLL
USE_NTDLL=1
!endif

NTTARGETFILES=DELEXPFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\redblack.h ===
/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.h for debug symbol lookups.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

typedef struct _SYMBOL_NODE SYMBOL_NODE, *PSYMBOL_NODE;
typedef struct _SYMBOL_TREE SYMBOL_TREE, *PSYMBOL_TREE;

struct _SYMBOL_NODE {
    PSYMBOL_NODE Left;
    PSYMBOL_NODE Right;
    ULONG        Hash;
    union {
      ULONG      RvaWithStatusBits;
      struct {
        ULONG    Rva:30;
        ULONG    Hit:1;
        ULONG    Red:1;
        };
      };
    CHAR         SymbolName[ 0 ];
    };

struct _SYMBOL_TREE {
    PSYMBOL_NODE Root;
    HANDLE SubAllocator;
#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    ULONG CountNodes;
    BOOL DeletedAny;
#endif
    };


#define RBNIL ((PSYMBOL_NODE)&SymRBEmptyNode)

extern const SYMBOL_NODE SymRBEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  128 million, so the max depth is 54 (2*Lg(2^27)).  Note that no runtime
//  checks are made to ensure we don't exceed this number, but since our
//  minimum node allocation size is 32 bytes, that would be a maximum of
//  100 million nodes in a 3GB address space.
//

#define MAX_DEPTH 54


//
//  The following prototypes are the red-black tree interface.
//

VOID
SymRBInitTree(
    IN OUT PSYMBOL_TREE Tree,
    IN HANDLE SubAllocator
    );

PSYMBOL_NODE
SymRBInsert(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName,
    IN     ULONG Rva
    );

PSYMBOL_NODE
SymRBFind(
    IN PSYMBOL_TREE Tree,
    IN LPSTR SymbolName
    );

PSYMBOL_NODE
SymRBFindAndDelete(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName
    );


#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\redblack.c ===
#include <precomp.h>

/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    Copyright (C) Microsoft, 1998.

    2/98, modified this version of redblack.c for debug symbol lookups.

*/

#ifndef PATCH_APPLY_CODE_ONLY

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const SYMBOL_NODE SymRBEmptyNode = { RBNIL, RBNIL };


VOID
SymRBInitTree(
    IN OUT PSYMBOL_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    Tree->CountNodes = 0;
    Tree->DeletedAny = FALSE;
#endif
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PSYMBOL_NODE
SymRBFind(
    IN PSYMBOL_TREE Tree,
    IN LPSTR SymbolName
    )
    {
    PSYMBOL_NODE Node = Tree->Root;
    ULONG        Hash;
    int          Compare;

    Hash = HashName( SymbolName );

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node =  Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node =  Node->Right;
            }
        else {

            Compare = strcmp( SymbolName, Node->SymbolName );

            if ( Compare == 0 ) {
                return Node;
                }
            else if ( Compare < 0 ) {
                Node =  Node->Left;
                }
            else {
                Node =  Node->Right;
                }
            }
        }

    return NULL;
    }


PSYMBOL_NODE
SymRBInsert(
    IN OUT PSYMBOL_TREE Tree,
    IN     LPSTR SymbolName,
    IN     ULONG Rva
    )
    {
    PSYMBOL_NODE * Stack[ MAX_DEPTH ];
    PSYMBOL_NODE **StackPointer = Stack;
    PSYMBOL_NODE * Link;
    PSYMBOL_NODE   Node;
    PSYMBOL_NODE   Sibling;
    PSYMBOL_NODE   Parent;
    PSYMBOL_NODE   Child;
    PSYMBOL_NODE   NewNode;
    ULONG          NameLength;
    ULONG          Hash;
    int            Compare;

    ASSERT( ! Tree->DeletedAny );

    Hash = HashName( SymbolName );

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {

            Compare = strcmp( SymbolName, Node->SymbolName );

            if ( Compare == 0 ) {

                //
                //  Found a matching symbol.
                //

                return Node;
                }

            else if ( Compare < 0 ) {
                *StackPointer++ = &Node->Left;
                Node = Node->Left;
                }
            else {
                *StackPointer++ = &Node->Right;
                Node = Node->Right;
                }
            }
        }

    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.
    //

    NameLength = (ULONG) strlen( SymbolName ) + 1;

    NewNode = SubAllocate( Tree->SubAllocator, ( sizeof( SYMBOL_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
    Tree->CountNodes++;
#endif

    NewNode->Left   = RBNIL;
    NewNode->Right  = RBNIL;
    NewNode->Hash   = Hash;
    NewNode->RvaWithStatusBits = Rva | 0x80000000;  // make new node RED, not hit
    memcpy( NewNode->SymbolName, SymbolName, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
    }

#endif // ! PATCH_APPLY_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\i386\exsup.asm ===
;***
;exsup.asm
;
;       Copyright (c) 1993-1997, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Exception handling for i386.  This file contains those routines
;       common to both C8.0 and C9.0.
;
;Notes:
;
;Revision History:
;       04-13-93  JWM   setjmp(), longjmp() & raisex() moved to setjmp.asm;
;                       common data definitions moved to exsup.inc.
;       10-18-93  GJF   Ensure direction flag is clear in _except_handler2
;       12-16-93  PML   Accept <0,0,>0 from except filter, not just -1,0,+1
;       01-10-94  PML   Moved C8-specific __except_handler2 to exsup2.inc.
;                       Only C8/C9 common routines left here.
;       01-20-94  GJF   Gave _EXCEPTION_REGISTRATION a _COMMON suffix (fix
;                       from SteveWo).
;       02-10-94  GJF   -1 is the end-of-exception-handler chain marker, not 0.
;       01-11-95  SKS   Remove MASM 5.X support
;       04-18-95  JWM   Added NLG support
;       04-21-95  JWM   NLG routines moved from setjmp.asm, NLG data from
;                       frame.cpp.
;       04-25-95  JWM   Added __NLG_Return2 label.
;       06-07-95  JWM   NLG now multithread safe.
;       06-20-95  JWM   dwCode passed on stack (11803).
;       07-11-95  JWM   unwanted prologue removed from NLG_Notify (11803).
;       07-21-95  JWM   Added new entry point, _NLG_Notify1 (16585).
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =       1
?NODATA =       1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?
ifndef _BUILD_DLL_LIB_
extrn _RtlUnwind@16:near
endif           ; _BUILD_DLL_LIB_

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
_EXCEPTION_REGISTRATION_COMMON struc    ; C8.0/C9.0 common only
                        dd      ?       ; prev (OS-req, def'd in exsup.inc)
                        dd      ?       ; handler (ditto)
;private:
    scopetable          dd      ?       ; C8/C9 common
    trylevel            dd      ?       ; C8/C9 common
_EXCEPTION_REGISTRATION_COMMON ends

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

assumes DS,DATA
assumes FS,DATA

public __except_list
__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

;BeginDATA
;
;__NLG_Destination _NLG_INFO <>
;PUBLIC __NLG_Destination
;
;EndDATA

BeginCODE

ifndef _BUILD_DLL_LIB_

;NB: call to RtlUnwind appears to trash ebx! and possibly others so just
; to be save, we save all callee save regs.
cProc _global_unwind2,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  stop
cBegin
        push    0                       ; ReturnValue
        push    0                       ; ExceptionRecord
        push    offset flat:_gu_return  ; TargetIp
        push    stop                    ; TargetFrame

        call    _RtlUnwind@16
_gu_return:
cEnd

endif           ; _BUILD_DLL_LIB_

;_unwind_handler(
;  PEXCEPTION_RECORD xr,
;  PREGISTRATION_RECORD establisher,
;  PCONTEXT context,
;  PREGISTRATION_RECORD dispatcher);
;
;this is a special purpose handler used to guard our local unwinder.
; its job is to catch collided unwinds.
;
;NB: this code is basically stolen from the NT routine xcptmisc.asm
; and is basically the same method used by the system unwinder (RtlUnwind).
;
cProc _unwind_handler,<C>
cBegin
        mov     ecx, dword ptr [esp+4]
        test    dword ptr [ecx.exception_flags], EXCEPTION_UNWIND_CONTEXT
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jz      short _uh_return

    ; We collide in a _local_unwind.  We set the dispatched to the
    ; establisher just before the local handler so we can unwind
    ; any future local handlers.

        mov     eax, [esp+8]            ; Our establisher is the one
                                        ; in front of the local one

        mov     edx, [esp+16]
        mov     [edx], eax              ; set dispatcher to local_unwind2

        mov     eax, DISPOSITION_COLLIDED_UNWIND
_uh_return:
cEnd

;/* _LOCAL_UNWIND2 - run all termination handlers listed in the scope table
; * associated with the given registration record, from the current lexical
; * level through enclosing levels up to, but not including the given 'stop'
; * level.
; */
;void _local_unwind2(PEXCEPTION_REGISTRATION xr, int stop)
;{
;    int ix;
;
;    for(ix=xr->trylevel; ix!=-1 && ix!=stop; ix=xr->xscope[i].enclosing_level){
;       /* NULL indicates that this entry is for a termination handler */
;       if(xr->xscope[i].filter==NULL){
;           /* NB: call to the termination handler may trash callee save regs */
;           (*xr->xscope[i].specific_handler)();
;       }
;    }
;    xr->trylevel=stop;
;}
;/* NOTE: frame (ebp) is setup by caller of __local_unwind2 */

;PUBLIC  __NLG_Return2

cProc _local_unwind2,<C,PUBLIC>
cBegin
        push    ebx
        push    esi
        push    edi     ;call to the handler may trash, so we must save it

        mov     eax, [esp+16]           ; (eax) = PEXCEPTION_REGISTRATION

        ;link in a handler to guard our unwind
        push    eax
        push    TRYLEVEL_INVALID
        push    OFFSET FLAT:__unwind_handler
        push    fs:__except_list
        mov     fs:__except_list, esp

_lu_top:
        mov     eax, [esp+32]           ; (eax) = PEXCEPTION_REGISTRATION
        mov     ebx, [eax.scopetable]
        mov     esi, [eax.trylevel]

        cmp     esi, -1                 ; REVIEW: do we need this extra check?
        je      short _lu_done
        cmp     esi, [esp+36]
        je      short _lu_done

        lea     esi, [esi+esi*2]        ; esi*= 3

        mov     ecx, [(ebx+esi*4).enclosing_level]
        mov     [esp+8], ecx            ; save enclosing level
        mov     [eax.trylevel], ecx

        cmp     dword ptr [(ebx+esi*4).filter], 0
        jnz     short _lu_continue

;        push    0101h
;        mov     eax, [(ebx+esi*4).specific_handler]
;        call    _NLG_Notify

        call    [(ebx+esi*4).specific_handler]

;__NLG_Return2::
_lu_continue:
        jmp     short _lu_top
_lu_done:
        pop     fs:__except_list
        add     esp, 4*3                ; cleanup stack

        pop     edi                     ; restore c-runtime registers
        pop     esi
        pop     ebx
cEnd

;/* _ABNORMAL_TERMINATION - return TRUE if __finally clause entered via
; * _local_unwind2.
; */
;BOOLEAN _abnormal_termination(void);
;cProc _abnormal_termination,<C,PUBLIC>
;cBegin
;        xor     eax, eax                ; assume FALSE
;
;        mov     ecx, fs:__except_list
;        cmp     [ecx.handler], offset FLAT:__unwind_handler
;        jne     short _at_done          ; UnwindHandler first?
;
;        mov     edx, [ecx+12]           ; establisher of local_unwind2
;        mov     edx, [edx.trylevel]     ; is trylevel the same as the
;        cmp     [ecx+8], edx            ; local_unwind level?
;        jne     short _at_done          ; no - then FALSE
;
;        mov     eax, 1                  ; currently in _abnormal_termination
;_at_done:
;cEnd

;
; NLG entrypoints, for debugger support
; On entry: address of non-local goto in eax
;

;public __NLG_Dispatch

;OPTION PROLOGUE:NONE
;OPTION EPILOGUE:NONE

;_NLG_Notify1 PROC C PUBLIC
;        push ebx
;        push ecx
;        mov  ebx, OFFSET __NLG_Destination
;        jmp  __NLG_go           ; ecx is already set
;_NLG_Notify1 ENDP
;
;_NLG_Notify PROC C PUBLIC, dwInCode:DWORD
;        push ebx
;        push ecx
;        mov  ebx, OFFSET __NLG_Destination
;        mov  ecx, dwInCode
;__NLG_Go:
;        mov  [ebx.dwCode], ecx
;        mov  [ebx.uoffDestination], eax
;        mov  [ebx.uoffFramePointer], ebp
;__NLG_Dispatch::
;        pop  ecx
;        pop  ebx
;        ret  4
;_NLG_Notify ENDP
;
;OPTION PROLOGUE:PROLOGUEDEF
;OPTION EPILOGUE:EPILOGUEDEF

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\sources.inc ===
# TARGETPATH=..\..\bin
TARGETPATH=obj
# TARGETPATHLIB=$(BASEDIR)\public\sdk\lib

SOURCES=..\patchapi.c \
        ..\patchlzx.c \
        ..\pestuff.c  \
        ..\redblack.c \
        ..\misc.c     \
        ..\md5.c

INCLUDES=..;..\..\lzx\encoder;..\..\lzx\decoder

#
#  Turn off precompiled headers for now since VC6 causes a "PchSym"
#  object to wind up in the binary's .data section.  Well we don't otherwise
#  have a .data section, so this "PchSym" essentially costs a whole
#  page of address space.  If VC6 is fixed, or if using another
#  compiler, can turn precompiled headers back on.
#

# PRECOMPILED_INCLUDE=..\precomp.h
# PRECOMPILED_PCH=precomp.pch
# PRECOMPILED_OBJ=precomp.obj

#
#  Even though we're building DLLs here, we don't want to use MSVCRT.DLL
#  because that file doesn't exist on standard Win95 systems.  Instead we'll
#  use LIBCMT.LIB to drag in the few things we need from the CRT such as
#  memmove and alloca support.
#

USE_LIBCMT=1

#
#  But, if we're building test or debug versions, which need printf support,
#  we'll use MSVCRT.DLL instead.
#

!IFDEF TESTCODE
C_DEFINES=$(C_DEFINES) -DTESTCODE=$(TESTCODE)
USE_LIBCMT=
USE_CRTDLL=1
!ENDIF

!IFDEF DEBUG
C_DEFINES=$(C_DEFINES) -DDEBUG=$(DEBUG)
USE_LIBCMT=
USE_CRTDLL=1
!ENDIF

NO_NTDLL=1

MSC_WARNING_LEVEL=/W4

# MSC_OPTIMIZATION=/Od
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\i386\exsup.inc ===
;***
;exsup.inc
;
;       Copyright (C) 1993-1997, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Common data structures & definitions for exsup.asm and other
;       Structured Exception Handling support modules.
;
;Revision History:
;       04-13-93  JWM   Initial version
;       12-05-93  PML   Update for C9.0
;       01-12-94  PML   Move jmp_buf struct here, add new fields
;       01-13-95  JWM   Added _NLG_INFO struct.
;       06-05-95  JWM   Added uoffFramePointer to _NLG_INFO struct.
;
;******************************************************************************


;handler dispositions
DISPOSITION_DISMISS             equ     0
DISPOSITION_CONTINUE_SEARCH     equ     1
DISPOSITION_NESTED_EXCEPTION    equ     2
DISPOSITION_COLLIDED_UNWIND     equ     3

;filter return codes
FILTER_ACCEPT           equ     1
FILTER_DISMISS          equ     -1
FILTER_CONTINUE_SEARCH  equ     0

;handler flags settings..
EXCEPTION_UNWINDING     equ     2
EXCEPTION_EXIT_UNWIND   equ     4
EXCEPTION_UNWIND_CONTEXT equ    EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

TRYLEVEL_NONE           equ     -1
TRYLEVEL_INVALID        equ     -2

;callback interface codes (mimimal required set)
CB_GET_MAX_CODE         equ     0
CB_DO_LOCAL_UNWIND      equ     1
CB_GET_FRAME_EBP        equ     2
CB_GET_SCOPE_INDEX      equ     3
CB_GET_SCOPE_DATA       equ     4
MAX_CALLBACK_CODE       equ     4

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_EXCEPTION_REGISTRATION struc
    prev                dd      ?
    handler             dd      ?
_EXCEPTION_REGISTRATION ends

;setjmp/longjmp buffer
_JMP_BUF struc
    saved_ebp           dd      ?
    saved_ebx           dd      ?
    saved_edi           dd      ?
    saved_esi           dd      ?
    saved_esp           dd      ?
    saved_return        dd      ?
    saved_xregistration dd      ?
    saved_trylevel      dd      ?
    ; following only found in C9.0 or later jmp_buf
    version_cookie      dd      ?
    unwind_func         dd      ?
    unwind_data         dd      6 dup(?)
_JMP_BUF ends

; Cookie placed in the jmp_buf to identify the new, longer form
JMPBUF_COOKIE   equ     'VC20'

; Offset of TryLevel in a C8.0 SEH registration node
C8_TRYLEVEL     equ     12

; NLG struct (debugging info)
;
; struct {
;    unsigned long   dwSig;
;    unsigned long   uoffDestination;
;    unsigned long   dwCode;
;    unsigned long   uoffFramePointer;
; } _NLG_Destination = {EH_MAGIC_NUMBER1,0,0,0};

;MAGIC_NUMBER1           equ     019930520h
;
;_NLG_INFO struc
;    dwSig                       dd      MAGIC_NUMBER1
;    uoffDestination     dd      0
;    dwCode                      dd      0
;    uoffFramePointer    dd      0
;_NLG_INFO ends

; This constant is also defined in mtdll.h!
;_NLG_LOCK               equ     01ah
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\i386\cmacros.inc ===
comment $

	SCCSID = "@(#)cmacros.mas:1.12"

cmacros - assembly macros for interfacing to hhls

(C)Copyright Microsoft Corp. 1984-1997

$

;; Revision History
;;
;;	1.00	05/03/84	Initial Release
;;
;;	1.01	05/06/84	Greg Whitten
;;				Added defgrp and changed cMerge to Microsoft C
;;				Added copyright message and changed to 1.01
;;				Changes should have no affect on working programs
;;
;;	1.02	07/10/84	Steve Wood
;;				Added labelx macros
;;
;;	1.03	07/14/84	Greg Whitten
;;				Added defines for ?pu, ?adj, ?lblpu
;;				  (removes undefined errors)
;;				Changes should have no affect on working programs
;;
;;	1.04	07/18/84	Greg Whitten
;;				Added local control from PL/M or C conventions
;;				  except for cCall macro
;;
;;	1.05	08/06/84	Steve Wood
;;				Made ?PLM and ?WIN be the defaults
;;
;;	1.06	01/02/85	Steve Wood
;;				Changed createSeg and defgrp to automatically
;;				  define the ln_assumes macro and the lnoffset
;;				  and lnbase equates for each logical segment
;;				  name.
;;
;;	1.07	02/19/85	Walt Moore
;;				Added farptr macro for defining a far pointer
;;				to be used in a cCall.	Folded regptr into
;;				farptr.  Space compaction in macros.  Changed
;;				?pp to be smaller.  Moved ?ia out of ?al1 into
;;				?aloc.	Merged cProc and ?pd into one macro.
;;				Changed some %outs to use the error macro so
;;				an error would be generated.  Added makeframe
;;				and parmR to cProc.  Changed error to also put
;;                              the error message in the listing.
;;				Deleted the smashes macro.
;;
;;	1.08	03/18/85	Steve Wood
;;				Added NODATA support.
;;
;;	1.09	03/27/85	Steve Wood
;;				Added ?definitions
;;
;;	2.00	04/01/85	Steve Wood
;;				April fools
;;
;;	2.01	06/17/85	Steve Wood
;;				Changed NODATA to always generate POP DS
;;				  for return address patching
;;
;;	2.02	02/11/86	Steve Wood
;;				Added ATOMIC keyword to cProc macro
;;				Changed far epilog to use LEA SP,BP-2
;;				Changed error macro to ??error to avoid
;;				  conflict
;;
;;	2.03	03/06/86	Steve Wood
;;				Fixed bug with ATOMIC and locals in far proc
;;				Added DOS5 switch to disable INC/DEC BP
;;				  instructions in special far prologs/epilogs
;;
;;	2.04	08/07/86	Scott Randell
;;				Fixed bug with ATOMIC and ?TF
;;				  (was doing unnecessary MOV SP,BP)
;;				Added pcode profile ?PROFILE
;;
;;	2.05	08/12/86	Walt Moore
;;				Changed _TEXT alignment to word.
;;				Added/corrected some comments.
;;				Removed redundant init of ?pc in cProc
;;				Made ATOMIC require NODATA
;;				Moved definition of non-underscored 'C' label
;;				  from the cProc to the cBegin macro
;;				Minor clean-up of code
;;
;;	2.06	09/11/86	Walt Moore
;;				Added private stack checking
;;				Put local control for PL/M or C into cCall
;;
;;
;;	2.07	09/19/86	Steve Wood
;;				Added ?SMALL, ?MEDIUM, etc.  symbols
;;				Added forceframe keyword to cProc macro.
;;				Interpret ?TF for all epilogs.
;;
;;	3.xx.a	02/26/87	Walt Moore
;;				Massive rework.  Documentation coming.
;;
;;	3.xx.b	04/08/87	NeilK
;;				Added parmH, which is like parmW except
;;				that it reserves 4 bytes on frame.
;;
;;	3.xx.c	05/11/87	Walt Moore
;;				Added <> to ?ap so that arg <DataOFFSET foo>
;;				can be used.
;;
;;	3.01	07/03/87	Walt Moore
;;				parm_bytes_&procname is now generated for
;;				all cProcs, and is the number of bytes of
;;				parameters to the cProc.
;;
;;				NO_BP added as a keyword to cProc which
;;				causes all equates to be generated without
;;				reference to BP for the procedure.  All type
;;				info is still generated, but the user must
;;				supply any segment and base register.
;;				?NO_BP, if defined, makes this the default.
;;
;;				USE_BP can be specified on the cProc line
;;				to force the generation of BP in equates.
;;
;;				Moved definition of xxxxBASE.  The equ was to
;;				a forward reference.
;;
;;				Don't generate a warning for a nogen if only
;;				parameters are present.
;;
;;				Keywords for cProc, cBegin, cEnd, and registers
;;				are now allowed to be either all upper case or
;;				all lower case.
;;
;;				Only generate warnings on pass 2.
;;
;;	3.02	07/06/87	Walt Moore
;;				Boy did I screw up <nogen>  If the text is
;;				recognized as nogen, then process it as such,
;;				else ignore it and generate frame as needed.
;;
;;	3.03	07/14/87	Walt Moore
;;				Added <partial> keyword to the cBegin macro
;;				to only allocate locals and save registers.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;				Added cleanframe macro which will take the
;;				frame down, but not generate the RET statement.
;;				Used in conjunction with dispatching in the
;;				Winthorn engine and drivers.
;;
;;	3.04	07/16/87	Walt Moore
;;				globalD was generating off and seg name
;;				without word ptr override, giving them a
;;				dword attribute
;;
;;	3.05	07/17/87	Walt Moore
;;				.xcref cleanframe
;;
;;	3.06    07/24/87	Hans Spiller
;;				32 bit small model (?SMALL32):
;;				  new entry exit sequences using pseudoregs
;;				  mach independant register names (IAX, etc)
;;				  parmI/localI (int size variables)
;;				  mpush/mpop uses mach independant names
;;				  IPUSHF, IPOPF, IPUSHA,IPOPA,IIRET
;;				  
;;				case sensitivity bugfix. the compiler
;;				  generates "CODE", not "Code"
;;
;;				32 bit issues as yet undone:  allocation
;;			        macros for dealing with 32 bit mode far
;;				pointers, globalI, staticI, parmR, saving
;;				si,di vs. esi,edi,ebx
;;
;;	3.06a   09/29/87	Mark Roberts
;;				32 bit small model (?SMALL32):
;;				  fix a few bugs and add staticI
;;
;;	3.06b	07/20/87	Scott Randell
;;				Fix up for ?COW compatibility, added ?NOATOMIC
;;				to 3.xx version.
;;
;;	3.06c	04/29/88	Jim Schaad
;;				Put in ?DFDATA to force data segments even if
;;				?NODATA is set.
;;
;;	3.06d	05/02/88	Andy Padawer
;;				Bug fixes for 3.06b (cEnd), 3.06c (general).
;;
;;	3.06e	08/31/88	Andy Padawer
;;				use "if memS32" not "ifdef ?SMALL32".
;;
;;	3.06f   05/12/89	Mark Roberts
;;			  	fix staticI, globalDP and add globalI
;;
;;	3.06g   12/07/89	Mark Roberts
;;			  	add externI
;;
;;	3.06h	01/25/90	Jan de Rie
;;				add ?DFCODE to allow suppressing code segments
;;
;; Assembly macros for interfacing to C
;;
;;      User settable conditional assembly flags used within the cmacros
;;
;;	Memory model flags.  Set only one of the following.  memS is the
;;	default.  The symbols with ? are for defining from the command line
;;      and the memx symbols are numeric symbols that can be set in your source
;;      file prior to including this file.
;;
;;	    ?SMALL   memS - small model
;;	    ?MEDIUM  memM - medium model
;;	    ?LARGE   memL - large model
;;	    ?COMPACT memC - compact model
;;	    ?HUGE    memH - huge model
;;	    ?SMALL32 memS32 - 32 bit small model
;;
;;	?DF	Define flag.  If this flag is 0, then defines default segment
;;		and group definitions based on the compiler flag.  If this
;;              flag is 1, then does not define any segments or groups.
;;
;;	?DFDATA Define Data Flag.  If this flag is 0, then defines default
;;		data segment and group definitions based on compiler flag.
;;		If this flag is 1, then does not define any data segments
;;		or groups.
;;
;;	?DFCODE Define Code Flag.  If this flag is 0, then defines default
;;		code segments based on the compiler flag.  If this flag is 1,
;;		then does not define the code segments.  Inactive if
;;		?DF is 1.
;;
;;	?TF	Tight flag.  If this flag is 0, then use longer epilog
;;		sequence that safely cleans up a stack frame.  If this flag is
;;              1, then use more efficient epilog that assumes the stack is
;;		valid (SP)
;;
;;	?WIN	Windows flag.  Enables generation of special prolog/epilog
;;		for far procedures.  Default value is 1 (Windows).
;;
;;	?COW	Character Windows flag.  To be used in conjunction with ?WIN,
;;		If defined will not save DS for ?NODATA far prolog/epilog
;;		(CW does not modify the DS on the stack).
;;
;;	DOS5	If defined, then special far prolog/epilog seqeuences will not
;;		include the INC/DEC BP instructions.
;;
;;	?PLM	Calling convention flag.  If this flag is 0, then the
;;		calling convention used is that of C.  If this flag
;;		is 1, then the PL/M calling convention is used.
;;		The default value is 1.  The PL/M calling convention
;;		is used by pascal, fortran, basic, and cobol.
;;
;;		In the C calling convention, arguments are passed
;;              in reverse order; arg0 is the last pushed, argn is the
;;              first pushed.  also, it is the callers responsibility
;;              to remove the arguments from the stack upon a return
;;              from a call.
;;
;;		In the PL/M calling comvention, arguments are passed
;;              as encountered; arg0 is the first pushed, argn is the
;;              last pushed.  also, it is the called procedure's
;;              responsibility to remove parameters from the stack
;;		before returning (using the RET n instruction)
;;
;;	?NODATA If defined, then no data segment or DGROUP is defined and
;;              the special prolog/epilog sequences will not contain the
;;		code needed to setup DS.
;;
;;	?CHKSTK If defined, then prolog sequences for cProcs with local
;;		parameters will call the CHKSTK procedure to allocate
;;              the stack space.
;;
;;	?CHKSTKPROC	If defined, then this macro will be invoked to
;;                      perform the stack checking, otherwise the
;;                      standard stack checking procedure will be
;;			performed.  ?CHKSTKPROC must be declared
;;                      before the cmacros are included in the source
;;			else the standard chkstk routine will be declared
;;                      as an external symbol.
;;
;;			On entry to the user's stack checking procedure,
;;                      the frame has been setup except for allocating
;;                      local variable space and saving autosave registers.
;;
;;			The user supplied macro is passed as an argument
;;                      the number of byte of stack space requested.
;;
;;	?PROFILE  If defined then all far cBegin entries will have StartNMeas,
;;		  and all cEnd will have StopNMeas calls, StartNMeas and
;;		  StopNMeas will be defined as externfp
;;
;;	?NOPARMR  If defined, then the "parmR"	 macro	will not be defined.
;;
;;	?NOGLOBAL If defined, then the "globalx" macros will not be defined.
;;
;;	?NOSTATIC If defined, then the "staticx" macros will not be defined.
;;
;;	?NOEXTERN If defined, then the "externx" macros will not be defined.
;;
;;	?NOLABEL  If defined, then the "labelx"  macros will not be defined.
;;
;;	?NODEF	  If defined, then the "defx"	 macros will not be defined.
;;
;;	?NOPTR	  If defined, then "farptr & regptr"	will not be defined.
;;
;;	?QUIET	  If defined, then only error messages will be issued to
;;		  the console.	If undefined, then certain cmacro text will
;;		  be generated to the console.
;;
;;	?NOATOMIC If defined, then ATOMIC will be ignored (for giving real
;;		  frames to all procedures (and profiling).
;;
;;	?NO_BP	  If defined, then equates generated for parms and locals
;;		  will not explicitly reference BP.
;;	IAX, ICX, IDX, IBX, ISP, IBP, ISI, IDI
;;		  these pseudo registers expand to either ax..., or eax...
;;		  depending upon 32bit mode being enabled.  they should be
;;		  used whenever a pointer or integer is being used in order
;;		  to make source code machine independant



.xcref					;;Get rid of a lot of symbols


;	??_out	- output given message to the console unless ?QUIET has
;	been specified.
;
;	usage:
;		??_out	<t>
;
;	where:
;		<t> is the message to output

.xcref	??_out
??_out macro t
  ifndef ?QUIET
    %out t
  endif
endm



;	outif - output msg if name is non-zero.  if name is undefined,
;	set name = 0, else set name to the default value.
;
;	usage:
;		outif	name,defval,onmsg,offmsg
;	where:
;		name	name of symbol
;		defval	default value to give symbol if not defined
;			if blank, then 0 will be used
;		onmsg	text to display if symbol is non-zero
;		offmsg	test to be displayed if symbol is zero


outif macro name,defval,onmsg,offmsg
  ifndef name
    ifb <defval>
      name=0
    else
      name=defval
    endif
  endif
  if name
    name=1
    ifnb <onmsg>
      ??_out <! onmsg>
    endif
  else
    ifnb <offmsg>
      ??_out <! offmsg>
    endif
  endif
endm



;	??error - output msg and generate an assembly time error
;		  on regardess of assembler pass
;	usage:
;		??error <t>
;	where:
;		t	is the text to be output


.xcref	??error
??error macro	msg
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
endm


;	??error2 - output msg and generate an assembly time error
;		   on pass 2 only
;	usage:
;		??error2 <t>
;	where:
;		t	is the text to be output


.xcref	??error2
??error2 macro	 msg
  if2
  %out e r r o r ----- msg		;;to console
  .err e r r o r ----- msg		;;forced error by assembler
  endif
endm


.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized,memS32,sizeI,wordI

;if1					;;Only on pass 1
  ASMpass=1
  ifdef ?SMALL				;;inform user what is going on
    memS=1
  endif
  ifdef ?MEDIUM
    memM=1
  endif
  ifdef ?COMPACT
    memC=1
  endif
  ifdef ?LARGE
    memL=1
  endif
  ifdef ?HUGE
    memH=1
  endif
  ifdef ?SMALL32
    memS32=1
  endif
  ifdef ?FLAT32
    memF32=1
  endif

  ??_out  <cMacros Version 3.06h - 01/25/90>
  ??_out  <Copyright (C) Microsoft Corp. 1984-1990.  All rights reserved.>
  outif   memS,0,<Small Model>
  outif   memM,0,<Medium model>
  outif   memL,0,<Large Model>
  outif   memC,0,<Compact Model>
  outif   memH,0,<Huge Model>
  outif	  memS32,0,<32 Bit Small Model>
  outif   memF32,0,<32 Bit Flat Model>

  memMOD= memS + memM + memL + memC + memH + memS32
  if memMOD ne 1
    if memMOD eq 0
      memS = 1				; assume small model
      outif   memS,0,<Small model>
    else
      ??error	<must have only 1 memory model selected>
    endif
  endif

  sizec=  memM + memL + memH		; large code
  sized=  memL + memC + (memH*2)	; large data (2 if huge)
  ;; note that memS32 is used generaly to indicate 32 bitness.  I
  ;; doubt very much whether anyone will ever do other models in
  ;; 32 bit code...
  if memS32
    sizeI = 4				; size of a push
    wordI equ <dword>
    asmdI equ <dd>
  else
    sizeI = 2
    wordI equ <word>
    asmdI equ <dw>
  endif

  outif ?DF,0,<No segments or groups will be defined>
  outif ?DFDATA,0,<No data segments will be defined>
  outif ?DFCODE,0,<No code segments will be defined>
  outif ?TF,0,<Epilog sequences assume valid SP>
  outif ?WIN,1,<Windows support>
  outif	?COW,0,<Characters Windows support>
  outif ?PLM,1,<PL/M calling convention>
  outif	?NOATOMIC,0,<ATOMIC disabled>
  outif ?NODATA,0,<NODATA module>

  ife ?NODATA
    ?nodata1=0
  else
    ?nodata1=1
  endif

  ifndef ?CHKSTK
    ?chkstk1=0
  else
    ?chkstk1=1
    ifdef ?CHKSTKPROC
      ??_out <! Private stack checking enabled>
    else
      ??_out <! Stack checking enabled>
    endif
  endif

  ifndef DOS5
    ?DOS5=0
  else
    ?DOS5=1
    ??_out <! DOS5 module>
  endif

  ifdef ?PROFILE
    ??_out <! Native profiling enabled>
  endif

  ifndef ?NO_BP
    ?no_bp1=0
  else
    ?no_bp1=1
    ??_out <! NO_BP is default>
  endif
;else
  ASMpass=2
;endif

;; define pseudo registers and instructions for 386/8086 independance
if memS32
  .386
  IAX equ <eax>
  ICX equ <ecx>
  IDX equ <edx>
  IBX equ <ebx>
  ISP equ <esp>
  IBP equ <ebp>
  ISI equ <esi>
  IDI equ <edi>
  IPUSHF equ pushfd
  IPOPF equ popfd
  IPUSHA equ pushad
  IPOPA equ popad
  IIRET equ iretd
else
  IAX equ <ax>
  ICX equ <cx>
  IDX equ <dx>
  IBX equ <bx>
  ISP equ <sp>
  IBP equ <bp>
  ISI equ <si>
  IDI equ <di>
  IPUSHF equ pushf
  IPOPF equ popf
;  IPUSHA equ pusha
;  IPOPA equ popa
  IIRET equ iret
endif

;;	Initialize all symbols used in the macros.  Theses symbols will not be
;;      included in any cross reference listing.

	.xcref	?n,?ax,?ah,?al,?bx,?bh
	.xcref	?bl,?cx,?ch,?cl,?dx,?dh
	.xcref	?dl,?si,?di,?es,?ds,?bp
	.xcref	?sp,?ss,?cs
	.xcref	?n,?AX,?AH,?AL,?BX,?BH
	.xcref	?BL,?CX,?CH,?CL,?DX,?DH
	.xcref	?DL,?SI,?DI,?ES,?DS,?BP
	.xcref	?SP,?SS,?CS
	.xcref  ?EAX,?EBX,?ECX,?EDX,?ESI,?EDI,?ESP,?EBP
	.xcref  ?eax,?ebx,?ecx,?edx,?esi,?edi,?esp,?ebp
	.xcref  ?IAX,?IBX,?ICX,?IDX,?ISI,?IDI,?ISP,?IBP

	.xcref	?rsl,?cpd,?argl,?argc,?ba
	.xcref	?acb,???,?po
	.xcref	?pas,?pc

	.xcref	uconcat,mpush,mpop
	.xcref	?ri,?pp,?pp1,?al1
	.xcref	?ad,?ap,?atal,?dd,?dd1,?dd2
	.xcref	?pg,?pg1,?aloc,?cs1,?cs2
	.xcref	?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
	.xcref	?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
	.xcref	?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
	.xcref	defgrp,addseg,createSeg
	.xcref	save,outif,errnz,errn$,errnz1
	.xcref	?PLMPrevParm,?gcc
	.xcref	?cCall1,?pcc,?no_bp1,?no_bp2
	.xcref	?cbe,?pcbe



;;      conditionals set by the macros
;;
;;	?pc	Procedure class.  If this is set to 1, then the procedure
;;              is a far procedure, else it is a near procedure.
;;
;;	?ia	Interface adjustment count for far procedures.	The
;;              interface adjustment defines the number of bytes of
;;		storage allocated between BP and the first frame variable
;;              allocated on the stack.
;;
;;		Normally zero, it will be adjusted for both far windows
;;              procedures and by register parameters.
;;
;;	?cpd	Current procedure defined.  This is set to a non-zero
;;		value if a procedure is being defined (i.e a cProc has
;;		been encountered, and cBegin has not).
;;
;;	?ba	Begin active.  This is set to a non-zero value if a
;;		cBegin is active (i.e. a cBegin has been encountered,
;;		and cEnd has not).
;;
;;	?wfp	Windows far procedure.	Set if a windows far procedure
;;
;;	?pcc	procedure calling conventing.  Calling convention for
;;		this procedure.  May be different than the default set
;;		via ?PLM
;;
;;
;;	Other variables that are defined once so that the .xcref command
;;      doesn't get too upset if they show up missing!

?rsl    =       0                       ;;0 = no register to save
?cpd    =       0                       ;;<> 0 if in a procedure definition
?argl   =       0                       ;;length of arguments pushed on stack
?argc   =       0                       ;;# of arguments so far
?ba     =       0                       ;;<>0 if in a procedure (xbegin)
?acb    =       0                       ;;number of arguments to a call
???     =       0                       ;;byte count of local storage
?po     =       0                       ;;byte count of parameters
?pas    =       0                       ;;autosave value for procedure
?pc     =       0                       ;;class of a procedure (near/far)
?ia     =       0                       ;;no adjustment
?pu     =       0                       ;;public flag for some macros
?adj    =       0                       ;;initial define for .xcref
?rp     =       0                       ;;count of register parameters
?uf     =       0                       ;;user's frame code specified
?nd	=	0			;;NODATA keyword specified
?nx	=	0			;;ATOMIC keyword specified
?wfp    =       0                       ;;window far procedure
?ff     =       0                       ;;forceframe keyword specified
?dd2	=	0			;;used for globalx and staticx
?cCall1 =	0			;;used for cCalls
?pcc	=	?PLM			;;procedure calling convention
?PLMPrevParm =	0			;;Used in parameter processing
?no_bp2 =	?no_bp1 		;;BP / No BP flag
?cbe	=	0			;;cbegin/cEnd keyword flag

	.xcref	?casen
if1					;;only define ?casen on pass 1
?casen	=	0			;;case sensitive assembly if <> 0
endif



?n      =       0000000000000000b       ;;register none
?ax	=	0000000000000011b	;;register ax
?ah	=	0000000000000001b	;;register ah
?al	=	0000000000000010b	;;register al
?bx	=	0000000000001100b	;;register bx
?bh	=	0000000000000100b	;;register bh
?bl	=	0000000000001000b	;;register bl
?cx	=	0000000000110000b	;;register cx
?ch	=	0000000000010000b	;;register ch
?cl	=	0000000000100000b	;;register cl
?dx	=	0000000011000000b	;;register dx
?dh	=	0000000001000000b	;;register dh
?dl	=	0000000010000000b	;;register dl
?si	=	0000000100000000b	;;register si
?di	=	0000001000000000b	;;register di
?es	=	0000010000000000b	;;register es
?ds	=	0000100000000000b	;;register ds
?bp	=	0001000000000000b	;;register bp
?sp	=	0010000000000000b	;;register sp
?ss	=	0100000000000000b	;;register ss
?cs	=	1000000000000000b	;;register cs
					;;Incase we're case sensitive
?AX	=	0000000000000011b	;;register ax
?AH	=	0000000000000001b	;;register ah
?AL	=	0000000000000010b	;;register al
?BX	=	0000000000001100b	;;register bx
?BH	=	0000000000000100b	;;register bh
?BL	=	0000000000001000b	;;register bl
?CX	=	0000000000110000b	;;register cx
?CH	=	0000000000010000b	;;register ch
?CL	=	0000000000100000b	;;register cl
?DX	=	0000000011000000b	;;register dx
?DH	=	0000000001000000b	;;register dh
?DL	=	0000000010000000b	;;register dl
?SI	=	0000000100000000b	;;register si
?DI	=	0000001000000000b	;;register di
?ES	=	0000010000000000b	;;register es
?DS	=	0000100000000000b	;;register ds
?BP	=	0001000000000000b	;;register bp
?SP	=	0010000000000000b	;;register sp
?SS	=	0100000000000000b	;;register ss
?CS	=	1000000000000000b	;;register cs

?EAX	=	0000000000000011b	;;register ax
?EBX	=	0000000000001100b	;;register bx
?ECX	=	0000000000110000b	;;register cx
?EDX	=	0000000011000000b	;;register dx
?ESI	=	0000000100000000b	;;register si
?EDI	=	0000001000000000b	;;register di
?EBP	=	0001000000000000b	;;register bp
?ESP	=	0010000000000000b	;;register sp

?eax	=	0000000000000011b	;;register ax
?ebx	=	0000000000001100b	;;register bx
?ecx	=	0000000000110000b	;;register cx
?edx	=	0000000011000000b	;;register dx
?esi	=	0000000100000000b	;;register si
?edi	=	0000001000000000b	;;register di
?ebp	=	0001000000000000b	;;register bp
?esp	=	0010000000000000b	;;register sp

?IAX	=	0000000000000011b	;;register ax
?IBX	=	0000000000001100b	;;register bx
?ICX	=	0000000000110000b	;;register cx
?IDX	=	0000000011000000b	;;register dx
?ISI	=	0000000100000000b	;;register si
?IDI	=	0000001000000000b	;;register di
?IBP	=	0001000000000000b	;;register bp
?ISP	=	0010000000000000b	;;register sp

        .cref



;;      uconcat - unconditionally generate a statement from a field
;;      of given parameters
;;
;;      usage:
;;		uconcat  a,b,c,d,e,f,g
;;
;;      where:
;;              a,b   are concatenated for field 1
;;              c,d   are concatenated for field 2
;;		e,f,g are concatenated for field 3

uconcat macro a,b,c,d,e,f,g
  a&b c&d e&f&g
endm



;;      mpush pushes multiple registers onto the stack according to
;;      a register specification.
;;
;;      format:
;;              mpush   r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpush macro r
  irp x,<IAX,IBX,ICX,IDX,ISI,IDI,es,ds,IBP,ISP,ss,cs>
    if (r and ?&&x)
      push x								      ;@
    endif
  endm
endm



;;      mpop pops multiple registers from the stack according to
;;      a register specification.
;;
;;      format:
;;              mpop    r
;;
;;      where:
;;              r       is a numeric expression returned from ?ri
;;                      or any other valid register expression

mpop macro r
  irp x,<cs,ss,ISP,IBP,ds,es,IDI,ISI,IDX,ICX,IBX,IAX>
    if (r and ?&&x)
      pop x								      ;@
    endif
  endm
endm


;;      save - flag that the indicated registers are to be saved/restored
;;
;;	A flag is created which indicates which registers are to be saved
;;	when the cCall macro is invoked, and then restored after the call.
;;
;;      usage:
;;              save    <r>
;;
;;      where  r  is the list of registers to save, which may be:
;;
;;		register     saves
;;		   AX	      AX
;;		   AH	      AX
;;		   AL	      AX
;;		   BX	      BX
;;		   BH	      BX
;;		   BL	      BX
;;		   CX	      CX
;;		   CH	      CX
;;		   CL	      CX
;;		   DX	      DX
;;		   DH	      DX
;;		   DL	      DX
;;		   SI	      SI
;;		   DI	      DI
;;		   ES	      ES
;;		   DS	      DS
;;		   BP	      BP
;;
;;		  none	    nothing
;;
;;      the macro generates a value for the variable ?rsl

save macro r
  ?rsl=0				;;initialize save list
  ?ri ?rsl,<r>				;;generate magic number
endm



;;      ?ri - or register indexes to variable
;;
;;      ?ri is a macro that examines the passed argument list and computes
;;      a register index variable.
;;
;;	The values ORed with the variable are:
;;
;;              ?n       equ     0000000000000000b;
;;		?AX	 equ	 0000000000000011b;
;;		?AH	 equ	 0000000000000001b;
;;		?AL	 equ	 0000000000000010b;
;;		?BX	 equ	 0000000000001100b;
;;		?BH	 equ	 0000000000000100b;
;;		?BL	 equ	 0000000000001000b;
;;		?CX	 equ	 0000000000110000b;
;;		?CH	 equ	 0000000000010000b;
;;		?CL	 equ	 0000000000100000b;
;;		?DX	 equ	 0000000011000000b;
;;		?DH	 equ	 0000000001000000b;
;;		?DL	 equ	 0000000010000000b;
;;		?SI	 equ	 0000000100000000b;
;;		?DI	 equ	 0000001000000000b;
;;		?ES	 equ	 0000010000000000b;
;;		?DS	 equ	 0000100000000000b;
;;		?BP	 equ	 0001000000000000b;
;;		?SP	 equ	 0010000000000000b;
;;		?SS	 equ	 0100000000000000b;
;;		?CS	 equ	 1000000000000000b;
;;      usage:
;;		?ri n,<rl>
;s mach independant names;      where:
;;              n       is the variable to contain the new index value
;;		r	is the register list

?ri macro n,r
  irp x,<r>
    ifdef ?&&x				;;if defined, then add to list
      n=n or ?&&x
    else
      ??error2 <unknown register x>
      .err
    endif
  endm
endm



;;      parmx - generate reference to parameter(s) on the stack
;;
;;	An equate is generated for addressing a paramter(s)
;;      on the stack for the current procedural frame.
;;
;;	An error message is generated if there isn't a current frame.
;;
;;      usage:
;;              parmX   n
;;      where:
;;              X       is the type of the argument(s)  B=byte, W=word, D=dword
;;			I = machine independant int size
;;              n       is the name(s) to be given the parameter(s).
;;
;;	Bytes are considered to be two bytes long for alignment.
;;
;;	The parmd form of the macro generates three equates:
;;
;;              name       -    for accessing the parameter as a double word
;;              off_name   -    for accessing the offset  (lsw) of the parameter
;;              seg_name   -    for accessing the segment (msw) of the parameter

.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP,parmH,parmI
.cref

parmB macro n
  ?pp <n>,<byte>,sizeI,1
endm

parmW macro n
  ?pp <n>,<word>,sizeI,2
endm

parmI macro n
  ?pp <n>,wordI,sizeI,sizeI
endm

parmD macro n
  ife ?pcc				;;if to assemble for C
    irp x,<n>
      ?pp <&&x>,<dword>,0,4
      ?pp <off_&&x>,<word>,2,2
      ?pp <seg_&&x>,<word>,2,2
    endm
  else					;;if to assemble for PL/M
    irp x,<n>
      ?pp <seg_&&x>,<word>,2,2
      ?pp <off_&&x>,<word>,2,2
      ?pp <&&x>,<dword>,0,4
    endm
  endif
endm

parmH macro n
  ?pp <n>,<word>,4,2
endm

parmQ macro n
  ?pp <n>,<qword>,8,8
endm

parmT macro n
  ?pp <n>,<tbyte>,10,10
endm

if sizec
  parmCP macro n
    parmD <n>
  endm
else
  parmCP macro n
    parmW <n>
  endm
endif

if sized
  parmDP macro n
    parmD <n>
  endm
else
  parmDP macro n
    parmI <n>
  endm
endif



;;      ?pp is the generalized parameter definition macro
;;
;;      usage:
;;              ?pp m,t,l,s
;;
;;      where:
;;              n       is the name(s) of the parameters
;;              t       is the type (word, dword)
;;              l       is the length to update parameter byte count by
;;              s       is the internal typing size


?pp macro n,t,l,s			;;process parameter
  if ?cpd				;;must be in a procedure definition
    .xcref
    irp x,<n>
      .xcref ?t&&x			;;don't want this in xref
      ?t&&x=s				;;save size info
      ife ?pcc				;;if C calling convention
	?pp1 x,<t>,,,%(?po+?adj)
	?po=?po+l			;;update parameter offset
      else				;;else assemble for PL/M
	?PLMPrevParm=?PLMPrevParm+1	;;Show next parameter
	?po=?po+l			;;update parameter offset
	?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
      endif
    endm
    .cref
  else
    ??error2 <parm(s) "&n" declared outside proc def>
  endif
endm



;;	?pp1 is the macro that generates the text equate for the
;;	parameter.  Two options exist, one for the C calling
;;      convention where the last parameter was the first pushed onto
;;	the stack ('C' convention), and one for the PL/M calling
;;      convention where the first parameter was the first
;;      pushed (also the same as ms-pascal).
;;
;;	The text generated will be of one of two forms:
;;
;;		name equ (type ptr [bp+(adj+offset)]) for C
;;           or
;;		name equ (type ptr [bp+adj+?po-offset]) for PL/M
;;
;;
;;	For C, since parameters are pushed first last, the offset
;;      plus the adjust will point to the correct parameter.
;;
;;	For PL/M, since parameters are pushed first first, the offset
;;	of a parameter is much more complicated.  A known portion of
;;      the offset can be computed when the text equate is generated.
;;
;;	What is known is the number of garbage bytes between BP and
;;      the nearest parameter (in this case the last parameter), and
;;      also how many bytes of parameters have preceeded this parameter.
;;
;;	What is unknown is how many total bytes of parameters there will
;;      be, which affects all the generated text equates since the offset
;;      from bp must be determined at some point.
;;
;;	Well, the offset from BP can be computed with one variable if
;;      the following is remembered:
;;
;;          the offset of any parameter from the first parameter is always
;;          the current parameter offset (?po).
;;
;;	With this in mind, you just have to figure out where the first
;;      parameter is, which is:
;;
;;              bp + garbage adjustment + distance to first parameter
;;         or
;;              bp + ?adj + ?po
;;
;;	This implies that any parameter can be defined as:
;;
;;              bp + ?adj + ?po -%?po
;;
;;	Make any sense?
;;
;;	For PL/M, a chain of self-purging macros will be generated
;;	which will pass the evaluated ?po to any previous incarnation
;;	of the macro.  This will allow the text equate to be generated
;;	with the actual offset instead of the symbolic ?po.
;;
;;
;;      usage:
;;		?pp1	n,t,o,a,b,cpc,ppc
;;
;;      where:
;;              n    is the name to be given the equate
;;              t    is the type (byte, word, dword)
;;              o    is the offset from the first parameter
;;              a    is the adjustment
;;              b    is the adjustment plus the offset from the first parameter
;;		cpc  is the number of parameters so far
;;		ppc  is cpc - 1


?pp1 macro n,t,o,a,b,cpc,ppc
  ife ?pcc				;;if to generate for C
    if ?no_bp2
      n equ (t ptr [+b])
    else
      n equ (t ptr [IBP][+b])
    endif
  else					;;else generate for PL/M
    .xcref
    .xcref ?PLMParm&cpc
    .cref
    if ?no_bp2
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    else
      ?PLMParm&cpc &macro po
	uconcat <n>,,<equ>,,<(t ptr [IBP][+>,%(a+po-o),<])>
	?PLMParm&ppc po
	purge ?PLMParm&cpc
      &endm
    endif
  endif
endm



;;	parmR - register parameter
;;
;;	parmR is the macro used for generating register parameters.
;;	The space allocated for the register parameters will be
;;      the ?ia (interface adjust) area which is between the  old
;;	BP and the first parameter.  Normally this is empty (?ia=0),
;;      or has the saved ds for a windows far procedure.
;;
;;	Byte and dword register parameters will be allowed.
;;
;;      usage:
;;		parmR	n,r,r2
;;      where:
;;              n       is the name of the parameter
;;              r       is the register it is in
;;              r2      is the offset register if a dword


ifndef ?NOPARMR
  .xcref
  .xcref ?pr,parmR
  .cref

  parmR macro n,r,r2
    ?pr n,r,r2,%?rp,%(?ia+2)
  endm

  ;;	?pr - register parameter
  ;;
  ;;	?pr is the actual macro for generating the equates for
  ;;	register parameters.
  ;;
  ;;	usage:
  ;;		parmR	n,r,r2,i,o
  ;;	where:
  ;;		n	is the name of the parameter
  ;;		r	is the register it is in
  ;;		r2	is the offset register if a dword
  ;;		i	is the index of the ?rp to generate
  ;;		o	is the offset from bp where the parm will be

  ?pr macro n,r,r2,i,o
    .xcref
    ifnb <r2>				;;if a dword parameter
      parmR seg_&n,r			;;define segment equate
      parmR off_&n,r2			;;define offset  equate
      if ?no_bp2
	n equ (dword ptr [-o-2])	;;define dword equate
      else
	n equ (dword ptr [bp][-o-2])	;;define dword equate
      endif
      .xcref ?t&n
      ?t&n=4				;;show a dword to cmacros
    else
      .xcref ?rp&i
      ?rp&i=0				;;show no register(s)
      ifdef ?&r 			;;define register if valid
	?rp&i=?&r
      endif

      if ??? or (?cpd eq 0) or (?rp&i eq 0)
	??error2 <invalid parmR encountered: &n,&r>
	exitm
      endif

      if ?no_bp2
	n equ (word ptr [-o])		;;assume a word register
      else
	n equ (word ptr [bp][-o])	;;assume a word register
      endif
      .xcref ?t&n
      ?t&n=2				;;show a word to cmacros
      irp x,<bh,ch,dh,bl,cl,dl,ah,al>
	if ?&&x eq ?&r			;;if really a byte register
	  if ?no_bp2
	    n equ (byte ptr [-o])	;;  then make it a byte
	  else
	    n equ (byte ptr [bp][-o])	;;  then make it a byte
	  endif
	  ?t&n=1			;;show a byte to cmacros
	  exitm
	endif
      endm
      ?ia=?ia+2 			;;show this guy is out there
      ?rp=?rp+1 			;;show one more register parameter
    endif
    .cref
  endm
endif



;;      localx - generate reference to a local variable on the stack
;;
;;	An equate is generated for addressing a local variable
;;      on the stack for the current procedural frame.
;;
;;      usage:
;;              localx    n
;;      where:
;;              x       is the type b=byte, w=word, d=dword, v=variable size
;;              n       is the name(s) to be given the variable(s).
;;
;;	Bytes are considered to be two bytes long for alignment reasons
;;
;;	The locald form of the macro generates three equates:
;;
;;              name       -    for accessing the variable as a double word
;;              off_name   -    for accessing the offset  (lsw) of the variable
;;              seg_name   -    for accessing the segment (msw) of the variable


.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV,localI
.cref

localB macro n
  ?aloc <n>,<byte ptr>,1,1,0		;; no alignment
endm

localW macro n
  ?aloc <n>,<word ptr>,2,2,1		;; word aligned
endm

localI macro n
  ?aloc <n>,&wordI&< ptr>,sizeI,sizeI,1	;; dword aligned
endm

localD macro n
  irp x,<n>
    ?aloc <seg_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <off_&&x>,<word ptr>,2,2,1	;; word aligned
    ?aloc <&&x>,<dword ptr>,0,4,1	;; word aligned
  endm
endm

localQ macro n
  ?aloc <n>,<qword ptr>,8,8,1		;; word aligned
endm

localT macro n
  ?aloc <n>,<tbyte ptr>,10,10,1 	;; word aligned
endm

if sizec
  localCP macro n
    localD <n>
  endm
else
  localCP macro n
    localW <n>
  endm
endif

if sized
  localDP macro n
    localD <n>
  endm
else
  localDP macro n
    localI <n>
  endm
endif

localV macro n,a
  ?aloc <n>,,%(a),0,1			;; word aligned
endm


;;      ?aloc is the macro that actually allocates local storage.
;;      it is only invoked by the localx macros.
;;
;;      usage:
;;              ?aloc  n,t,l,s,a
;;      where:
;;              n      is a list of names of local variable of the
;;                      given type.
;;              t       is the text string for the given variable
;;                      and is one of:
;;                          word  ptr
;;                          dword ptr
;;                          byte  ptr
;;                      or alternatively left blank for variable size
;;                      allocations (no implicit type).
;;              l       is the size of the variable in bytes
;;              s       is the internal type flag (size), and is one of:
;;                              word     - 2
;;                              dword    - 4
;;                              byte     - 1
;;                              variable - 0
;;              a       is a flag indicating that word alignment is to be
;;                      forced for this type of item.
;;
;;	NOTE:	It is assumed that the stack is already aligned on a word
;;		boundary when the cProc is invoked.  The macros will guarantee
;;		to allocate an even number of bytes on the stack to maintain
;;              word alignment.


?aloc macro n,t,l,s,a
  if ?cpd				;;must be in a proc def
    .xcref
    irp x,<n>				;;generate symbol equates
      ???=???+l 			;;update length of locals
      if a				;;if align, then force word alignment
	if memS32 and l GT 2
	  ???=((??? + 3) and 0fffffffch) ;; dword alignment
	else
	  ???=((??? + 1) and 0fffeh)
	endif
      endif
      ?al1 x,<t>,%(???+?ia)		;;?ia will always be valid (0 or 2)
      .xcref ?t&&x
      ?t&&x=s				;;save size info
    endm
    .cref
  else
    ??error2 <locals "&n" declared outside procedure def>
  endif
endm



;;      ?al1 - allocate local, continued.
;;
;;      ?al1 actually generates the text equate for the local variable.
;;	The form of the text equate generated is more or less:
;;
;;		name equ (type ptr [bp-?ia-nn])
;;          or
;;		name equ ([bp-?ia-nn])
;;
;;      where:
;;              ?ia   is defined to be either zero, or is defined to be
;;		      the number of bytes between the saved BP and the first
;;		      local.  ?ia is only applicable if the current cProc is
;;		      a windows far procedure or if parmRs have been
;;		      encountered.  If not, the ?ia will be zero.  since ?ia
;;		      is determinable prior to invoking this macro, it will be
;;		      added into the  offset ("nn") passed to this macro
;;
;;      usage:
;;              ?al1 n,t,o
;;      where:
;;              n    is the name for the text equate
;;              t    is the type of the equate
;;              o    is the offset of the equate


?al1 macro n,t,o
  if ?no_bp2
    n equ (t [-o])
  else
    n equ (t [IBP][-o])
  endif
endm


;;	?gcc - get calling convention
;;
;;	?gcv sets the given symbol to the calling convention
;;	to be used.
;;
;;	usage:
;;		?gcc s,i,cc
;;
;;	where:
;;		s  is the symbol to return the convention in
;;		   s = 0 if 'C' calling convention
;;		   s = 1 if PL/M (PASCAL) calling convention
;;		i  is the initial value for s
;;		cc is the calling convention override, and may be one of
;;		   C	  use 'C' convention
;;		   PLM	  use PL/M calling convention
;;		   PASCAL use PL/M calling convention

?gcc macro s,i,cc
  s = i 				;;Set default calling convention
  ifnb <cc>
    ifidn <cc>,<C>			;;If overriding default
      s=0				;;  'C' calling convention
    endif
    ifidn <cc>,<PLM>
      s=1				;;  PL/M calling convention
    endif
    ifidn <cc>,<PASCAL>
      s=1				;;  PL/M calling convention
    endif
  endif
endm



ifndef ?NOGLOBAL
  .xcref
  .xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP,globalI
  .cref

  ;;	globalx - define global data of type x
  ;;
  ;;	usage:
  ;;		globalx n,i,s,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;		c	is the convention, C for C, PLM or PASCAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;
  ;;	The D form will generate two extra equates of the form off_n and seg_n.

  globalB macro n,i,s,c
    ?ad <n>,1
    ?dd n,1,<byte>,<db>,<i>,<s>,<c>
  endm

  globalW macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,<word>,<dw>,<i>,<s>,<c>
  endm

  globalI macro n,i,s,c
    ?ad <n>,2
    ?dd n,1,wordI,%asmdI,<i>,<s>,<c>
  endm

  globalD macro n,i,s,c
    ?ad <n>,4
    ?dd n,1,<dword>,<dd>,<i>,<s>,<c>
    off_&n equ word ptr n[0]
    seg_&n equ word ptr n[2]
  endm

  globalQ macro n,i,s,c
    ?ad <n>,8
    ?dd n,1,<qword>,<dq>,<i>,<s>,<c>
  endm

  globalT macro n,i,s,c
    ?ad <n>,10
    ?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
  endm

  if sizec
    globalCP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalCP macro n,i,s,c
      globalW n,<i>,<s>,<c>
    endm
  endif

  if sized
    globalDP macro n,i,s,c
      globalD n,<i>,<s>,<c>
    endm
  else
    globalDP macro n,i,s,c
      globalI n,<i>,<s>,<c>
    endm
  endif

endif


ifndef ?NOSTATIC
  .xcref
  .xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP,staticI
  .cref

  ;;	staticx - define static data of type x
  ;;
  ;;	usage:
  ;;		staticx n,i,s
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is the name to be given the variable.
  ;;		i	is the initial value of the variable.
  ;;		s	is the duplication factor
  ;;
  ;;	statics do not generate an underscored version of the symbol
  ;;	since they are intended to be internal symbols.  If they are
  ;;	required to be public, use globlax.


  staticB macro n,i,s
    ?ad <n>,1
    ?dd n,0,<byte>,<db>,<i>,<s>,<PLM>	;;PLM to keep from generating _
  endm

  staticW macro n,i,s
    ?ad <n>,2
    ?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
  endm

  staticD macro n,i,s
    ?ad <n>,4
    ?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
  endm

  staticI macro n,i,s
    ?ad <n>,sizeI
    ?dd n,0,wordI,%asmdI,<i>,<s>,<PLM>
  endm

  staticQ macro n,i,s
    ?ad <n>,8
    ?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
  endm

  staticT macro n,i,s
    ?ad <n>,10
    ?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
  endm

  if sizec
    staticCP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticCP macro n,i,s
      staticW n,<i>,<s>
    endm
  endif

  if sized
    staticDP macro n,i,s
      staticD n,<i>,<s>
    endm
  else
    staticDP macro   n,i,s
      staticI n,<i>,<s>
    endm
  endif
endif



;;      ?dd is the generalized data definition macro.
;;
;;      format:
;;		?dd n,p,t,d,i,s,c
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              t       is the assembler type (byte, word, dword)
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


?dd macro n,p,t,d,i,s,c
  ?gcc ?dd2,%?PLM,<c>			;;Set calling convention
  ife ?dd2				;;If 'C'
    n label t
    ?dd1 _&n,p,<d>,<i>,<s>		;;Microsoft C uses leading underscores
  else
    ?dd1 n,p,<d>,<i>,<s>		;;If PL/M
  endif
endm



;;      ?dd1 is the generalized data definition macro.
;;
;;      format:
;;              ?dd1 n,p,d,i,s
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              d       is the assembler directive (db,dw or dd)
;;              i       is the initial value
;;              s       is a duplication factor


?dd1 macro n,p,d,i,s
  if p
    public n
  endif
  ifb <s>
    n d i
  else
    ifb <i>
      n d s dup (?)
    else
      n d s dup (i)
    endif
  endif
endm



ifndef ?NOEXTERN
  .xcref
  .xcref ?ex1,?ex2,externB,externW,externD,externQ,externT,externI
  .xcref externNP,externFP,externP,externCP,externDP,externA
  .cref
  ?ex2 = 0

  ;;	externx - define external data of type x
  ;;
  ;;	usage:
  ;;		externx n,c
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer
  ;;			dp=data pointer,  a=absolute
  ;;		n	is a list of names to define
  ;;		c	is the convention, C for C, PLM or PSACAL forPL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  externA macro n,c			;;40h is reserved for whatever will
    ?ex1 <n>,40h,<abs>,<c>,<>		;;  be done in the future for ASB
  endm					;;  externals

  externB macro n,c
    ?ex1 <n>,1,<byte>,<c>,<>
  endm

  externW macro n,c
    ?ex1 <n>,2,<word>,<c>,<>
  endm

  externD macro n,c
    ?ex1 <n>,4,<dword>,<c>,<>
  endm

  externI macro n,c
    ?ex1 <n>,sizeI,%wordI,<c>,<>
  endm

  externQ macro n,c
    ?ex1 <n>,8,<qword>,<c>,<>
  endm

  externT macro n,c
    ?ex1 <n>,10,<tbyte>,<c>,<>
  endm

  externNP macro n,c
    ?ex1 <n>,2,<near>,<c>,<cc>
  endm

  externFP macro n,c
    ?ex1 <n>,4,<far>,<c>,<cc>
  endm

  if sizec
    externP macro n,c
      ?ex1 <n>,4,<far>,<c>,<cc>
    endm
  else
    externP macro n,c
      ?ex1 <n>,2,<near>,<c>,<cc>
    endm
  endif

  if sizec
    externCP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externCP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif

  if sized
    externDP macro n,c
      ?ex1 <n>,4,<dword>,<c>,<>
    endm
  else
    externDP macro n,c
      ?ex1 <n>,2,<word>,<c>,<>
    endm
  endif



  ;;	?ex1 is the generalized external definition macro
  ;;
  ;;	format:
  ;;		?ex1 n,s,d,c,scv
  ;;	where:
  ;;		n	is are the names of the externals
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.
  ;;		scv	save calling convention.  If this field is "cc", then
  ;;			the calling convention will be saved in a ?CCn equ.

  ?ex1 macro n,s,d,c,scv
    ?gcc ?ex2,%?PLM,<c>
    irp x,<n>
      .xcref
      .xcref ?t&&x
      .cref
      ?t&&x=s				;;save size info
      ife ?ex2
	extrn _&&x:&d
	x equ _&&x
      else
	extrn x:&d
      endif
      ifidn <scv>,<cc>			;;save calling convention (C or PL/M)
	.xcref				;;  if NP, FP, or P
	.xcref ?CC&&x
	.cref
	?CC&&x=?ex2
      endif
    endm
  endm
endif



ifndef ?NOLABEL
  .xcref
  .xcref ?lb1,?lblpu,?lb2
  .xcref labelB,labelW,labelD,labelQ,labelT
  .xcref labelNP,labelFP,labelP,labelCP,labelDP
  .cref
  ?lblpu = 0
  ?lb2 = 0

  ;;	  labelx - define label of data type x
  ;;
  ;;	  usage:
  ;;		  labelx n,c
  ;;	  where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;			q=quad word, t=tenbytes, cp=code pointer, dp=data pointer
  ;;		n	is a list of names to define, the first of which can
  ;;			be the keyword public
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  labelB macro n,c
    ?lb1 <n>,1,<byte>,<c>
  endm

  labelW macro n,c
    ?lb1 <n>,2,<word>,<c>
  endm

  labelD macro n,c
    ?lb1 <n>,4,<dword>,<c>
  endm

  labelQ macro n,c
    ?lb1 <n>,8,<qword>,<c>
  endm

  labelT macro n,c
    ?lb1 <n>,10,<tbyte>,<c>
  endm

  labelNP macro n,c
    ?lb1 <n>,2,<near>,<c>
  endm

  labelFP macro n,c
    ?lb1 <n>,4,<far>,<c>
  endm

  if sizec
    labelP macro n,c
      ?lb1 <n>,4,<far>,<c>
    endm
  else
    labelP macro n,c
      ?lb1 <n>,2,<near>,<c>
    endm
  endif

  if sizec
    labelCP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelCP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif

  if sized
    labelDP macro n,c
      ?lb1 <n>,4,<dword>,<c>
    endm
  else
    labelDP macro n,c
      ?lb1 <n>,2,<word>,<c>
    endm
  endif


  ;;	?lb1 is the generalized label definition macro
  ;;
  ;;	format:
  ;;		?lb1 n,s,d
  ;;	where:
  ;;		n	are the names of the labels
  ;;		s	is the size in bytes (used for typing)
  ;;		d	is the type
  ;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
  ;;			The default (?PLM flag) will be used if not specified.

  ?lb1 macro n,s,d,c
   ?gcc ?lb2,%?PLM,<c>
    ?lblpu=0
    irp x,<n>
      ifidn <x>,<PUBLIC>
	?lblpu=1
      else
	.xcref
	.xcref ?t&&x
	.cref
	?t&&x=s 			;;save size info
	ife ?lb2			;;If C
	  if ?lblpu
	     public _&&x
	  endif
	  _&&x label &d
	  x equ _&&x
	else				;;If PL/M
	  if ?lblpu
	     public x
	  endif
	  x label &d
	endif
      endif
    endm
  endm
endif



ifndef ?NODEF

  ;;	defx - inform macros that name is of type x
  ;;
  ;;	The given name(s) is flaged to be of the given type.  This macro
  ;;	is intended for giving types to variables that were not generated
  ;;	by the macros (i.e., static storage).  There must be a type definition
  ;;	for all parameters in a call list.
  ;;
  ;;	usage:
  ;;		defx	n
  ;;	where:
  ;;		x	is the type of the variable  b=byte, w=word, d=dword
  ;;		n      is the name(s) to be given the variable(s).
  ;;
  ;;	Bytes are considered to be two bytes long for alignment reasons

  .xcref
  .xcref defB,defW,defD,defQ,defT,defCP,defDP
  .cref

  defB macro n
    ?ad <n>,1
  endm

  defW macro n
    ?ad <n>,2
  endm

  defD macro n
    ?ad <n>,4
  endm

  defQ macro n
    ?ad <n>,8
  endm

  defT macro n
    ?ad <n>,10
  endm

  if sizec
    defCP macro n
      defD <n>
    endm
  else
    defCP macro n
      defW <n>
    endm
  endif

  if sized
    defDP macro n
      defD <n>
    endm
  else
    defDP macro n
      defW <n>
    endm
  endif
endif



;	?ad is the macro which creates a definition for the given
;	symbol
;
;	usage:
;		?ad <n>,s
;	where:
;		n is a list of names to define
;		s is the size info (1,2,4,8,10)


?ad macro n,s
  irp x,<n>
    .xcref
    .xcref ?t&&x
    .cref
    ?t&&x=s				;;save size info
  endm
endm



ifndef ?NOPTR
  .xcref
  .xcref regPtr,farPtr
  .cref

  ;;	regPtr generates information allowing a 32-bit pointer currently
  ;;	in a register to be pushed as a parameter to a subroutine using
  ;;	the cCall macro.
  ;;
  ;;	usage:
  ;;		regptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the register containing the segment portion
  ;;			of the pointer
  ;;		o	is the register containing the offset portion
  ;;			of the pointer
  ;;
  ;;	2/14/85 - made obsolete with farptr

  regPtr macro n,s,o
    farPtr n,s,o
  endm



  ;;	farPtr generates information allowing a 32-bit pointer to be
  ;;	pushed as a parameter to a subroutine using the cCall macro.
  ;;
  ;;	usage:
  ;;		farptr	n,s,o
  ;;	where:
  ;;		n	is the name the argument will be known as
  ;;		s	is the segment portion of the pointer
  ;;		o	is the offset portion of the pointer
  ;;
  ;;	Note that any cast must have been made in the argument itself
  ;;	(i.e. regptr ptr1,ds,<word ptr 3[si]>)


  farPtr macro n,s,o
    .xcref
    .xcref ?t&n
    .cref
    n &macro
      push s								      ;@
      push o								      ;@
    &endm
    ?t&n=80h
  endm
endif



;;      arg - declare argument
;;
;;	The given argument(s) is added to the argument list structure
;;
;;      format:
;;              arg     a
;;
;;      where:
;;              a       is any valid argument to push.
;;
;;	If any element in arglist has not been defined or isn't a 16-bit
;;      register, then a complete specification must have been given in a
;;      text equate and a defx also given (if not, you'll pay the penalty!)


arg macro a
  irp x,<a>
    ?argc=?argc+1			;;increment the arg count
    ?atal <x>,%?argc			;;generate argument
  endm
endm



;;      ?atal (add to argument list) generates a macro that will cause
;;	the given argument to be processed when invoked.  It is used by
;;      the arg macro only.


?atal macro n,i
  .xcref
  .xcref ?ali&i
  .cref
  ?ali&i &macro
    ?ap <n>
  &endm
endm



;;      ?ap - process arguments and place onto stack
;;
;;	The given argument is processed (type checking) and place on
;;	the stack for a pending call.  There must be a type definition
;;	for all arguments (except words).  This can be done by using
;;      text equates and the defx macro.
;;
;;      format:
;;              ?ap n
;;      where:
;;              n       is the name of the argument to be pushed
;;
;;	The variable  ?argl  is updated by the length of the arguments
;;      pushed so that the stack can be cleaned up after the call.


?ap macro n
  ?argl=?argl+2 			;;assume one word is pushed
  ifdef ?t&n
    ife ?t&n-1				;;byte type
      push word ptr (n) 						      ;@
      exitm
    endif

    ife ?t&n-2				;;word type
      push n								      ;@
      exitm
    endif

    ife ?t&n-4				;;dword type
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n-8				;;qword type
      push word ptr (n)[6]						      ;@
      push word ptr (n)[4]						      ;@
      push word ptr (n)[2]						      ;@
      push word ptr (n) 						      ;@
      ?argl=?argl+6
      exitm
    endif

    if ?t&n and 80h			;;far pointer type
      n
      ?argl=?argl+2
      exitm
    endif

    ife ?t&n				;;variable storage
      push word ptr (n) 						      ;@
      exitm
    endif
  endif

  push n				;;unknown or register or immediate    ;@
endm



;;	cCall - call a 'c' language procedure
;;
;;	The given procedure is called with the given parameters.
;;	If the calling convention is C, the arguments are pushed
;;      in reverse order, and removed after the called procedure
;;	returns.  If the calling conventing is PL/M, the arguments
;;      are pushed as they were encountered, and the called procedure
;;      is assumed to have removed them from the stack.
;;
;;	The calling convention priority will be:
;;	   1)	that specified on the cCall if present
;;	   2)	that defined by the target
;;	   3)	the default (?PLM flag)
;;
;;      format:
;;		ccall n,<a>,c
;;
;;      where:
;;              n       is the name of the procedure to call
;;              a       are arguments to be pushed (optional, may be
;;                      specified with the "arg" macro.
;;		c	is the convention, C for C, PLM or PSACAL for PL/M.
;;			The default (?PLM flag) will be used if not specified.


cCall macro n,a,c
  ifnb <a>				;;add any arguments to list
    arg <a>
  endif
  mpush %?rsl				;;save registers (if any)

  ifdef ?CC&n				;;if calling convention has been
    ?cCall1=?CC&n			;;   defined for target, use it
  else					;;else use the default
    ?cCall1=?PLM
  endif

  ifnb <c>				;;If possible override, check it out
    ?gcc ?cCall1,%?cCall1,<c>
  endif

  ?argl=0				;;init argument length
  ife ?cCall1				;;if C calling convention
    ?acb=?argc				;;initialize for looping
  else
    ?acb=1				;;initialize for looping
  endif

  rept ?argc				;;push arguments and purge macros
    uconcat <?ali>,%?acb
    uconcat <purge>,,<?ali>,%?acb
    ife ?cCall1 			;;if C calling convention
      ?acb=?acb-1
    else
      ?acb=?acb+1
    endif
  endm
  call n				;;call the procedure		      ;@
  if ((?cCall1 eq 0) and (?argl ne 0))	;;If C calling convention and arguments
    add sp,?argl			;;  then remove them		      ;@
  endif
  mpop %?rsl				;;pop all specified regs
  ?rsl=0				;;invalidate save list
  ?argc= 0				;;    "      arguments
  ?argl= 0
endm




;;	cProc - define a 'c' procedure
;;
;;	cProc is the procedure definition for procedures.
;;
;;      format:
;;		cProc n,cf,a
;;      where:
;;              n       is the name of the procedure
;;
;;		cf	controls certain definitions, and may be:
;;			    NEAR       proc is to be a near label
;;			    FAR        proc is to be a far  label
;;			    PUBLIC     proc is to be defined as public
;;			    SMALL      call makeframe procedure
;;			    NODATA     dont create prolog code to setup DS
;;			    ATOMIC     don't link stack if not needed
;;				       NODATA must be specified for ATOMIC
;;			    FORCEFRAME Force generation of a frame
;;			    C	       proc is to be a C    procedure
;;			    PLM        proc is to be a PL/M procedure
;;			    PASCAL     proc is to be a PL/M procedure
;;			    WIN        proc is to be a windows procedure
;;			    NONWIN     proc isn't to be a windows procedure
;;			    NO_BP      don't generate BP in text equates
;;			    BP	       generate BP in text equates
;;
;;              a       is a list of registers that are to be saved whenever
;;                      the procedure is invoked.
;;
;;			makeframe procedure:   If small is specified, then
;;                      the "makeframe procedure" is invoked instead of
;;                      generating normal prologues/epilogues
;;
;;			A call is performed to the makeframe procedure.  The
;;                      call is followed by two bytes.  the first byte is the
;;                      number of locals to allocate for the frame, the second
;;			is the number of bytes of parameters.  The makeframe
;;			procedure will in turn call the cProc routine at the
;;			address following the data bytes.  When the cProc is
;;                      finished, it will do a near return to the makeframe
;;                      procedure to clean up the frame and exit.
;;
;;			Note that register parameters and makeframe are
;;                      incompatible and cannot be used together.
;;
;;			The makeframe procedure will save SI, DI, and also
;;			DS if a far procedure.	These registers will be
;;                      removed from the autosave list if specified.


cProc macro n,cf,a
  if ?cpd
    ?utpe				;;generate unterminated proc error
  endif

  ?cpd=1				;;a procdef is active now
  ???=0 				;;no locals are defined yet
  ?argc=0				;;no arguments are defined
  ?ba=0 				;;not in a procedure
  ?po=0 				;;initial parameter offset
  ?pu=0 				;;initial public setting
  ?ia=0 				;;no special prolog/epilog
  ?adj=2*sizeI				;;parameter adjustment (near ret+bp)
  ?rp=0 				;;no register parameters
  ?uf=0 				;;don't use makeframe
  ?wfp=?WIN				;;default far procedure (win or not)
  ?ff=0 				;;don't force frame setup
  ?pas=0				;;process register save list
  ?pcc=?PLM				;;calling convention (C or PL/M)
  ?no_bp2=?no_bp1			;;Default base register generation

  ifnb <a>				;;register save list
    ?ri ?pas,<a>
  endif

  ?pc=sizec				;;default size
  ?nd=?nodata1				;;default NODATA flag
  ?nx=0 				;;default is not ATOMIC

  irp x,<cf>
    ifdef ??_cproc_&&x
      ??_cproc_&&x
    else
      ??error2 <e r r o r - unknown keyword x>
      .err
    endif

  endm

  if ?pcc				;;If PLM
    ?PLMPrevParm=0			;;  show no previous parameter
    .xcref
    .xcref ?PLMParm0
    .cref
    ?PLMParm0 &macro			;;Null macro to terminate
    purge ?PLMParm0
    &endm
  endif

  .xcref
  .xcref ?CC&n
  .cref
  ?CC&n=?pcc				;;Save procedure type

  if (?nx eq 1) and (?nd eq 0)		;;ATOMIC requires NODATA
    ?nx = 0				;;clear the ATOMIC keyword
    ??error2 <ATOMIC specified without NODATA - ATOMIC ignored>
  endif

  if ?pc				;;if a far procedure
    if ?wfp				;;if windows
      ife ?nx				;;if not ATOMIC
        ife ?COW			;; COW dos not save DS
	  ?ia=2				;;  adjust locals for saved ds
	  ?pas = ?pas and (not ?ds)	;;no need for extra save
	endif
      endif
    endif
    ?adj=?adj+sizeI 			;;far, make parameter adjustment
  else
    ?wfp=0				;;not a far windows procedure
  endif

  ?pas = ?pas and (not (?sp+?cs+?ss))	;;make no sense to save these

  if ?uf				;;don't save these if user frame
    ?pas = ?pas and (not (?bp+?si+?di))
  endif

  ife ?pcc
    ?pg  <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  else
    ?pg  <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
  endif
endm




;;      ?pg - generate begin and nested macros for current procedure
;;
;;      format:
;;		?pg n,p,c,a,w,nnu,cc
;;      where:
;;              n       is the name of the procedure
;;              p       is the public flag
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              w       true if a far windows procedure
;;		nnu	procedure name without any underscore
;;		cc	calling convention (C or PL/M)
;;
;;
;;      local stack allocation will be forced to an even byte count to
;;      maintain stack word alignment.


?pg macro n,p,c,a,w,nnu,cc
  .xcref
  if ?uf				;;if user frame
    if ?nd
      ??error2 <NODATA encountered in &n - user frame ignored>
      ?uf=0
    endif
  endif

  .xcref cBegin
  cBegin &macro g			;;generate cBegin macro
    .xcref
    if cc				;;Finish definition of parameters
      uconcat <?PLMParm>,%?PLMPrevParm,%?po
    endif

    if ?uf				;;if user frame
      if ?rp				;;If register parameters
	??error2 <parmR encountered in &n - user frame ignored>
	?uf=0
      endif
    endif
    ?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc,<nnu>,%??? ;;generate cEnd macro
    ?cpd=0				;;terminate current proc def
    ?argc=0				;;no arguments are defined yet
    ?ba=1				;;have reached a begin
    ???=(???+1) and 0fffeh		;;word align local storage

    if p				;;If to be public
      public n
    endif

    ife c				;;declare procedure type
      n proc near
    else
      n proc far
    endif

    ife cc				;;if 'C' calling convention
      nnu equ n 			;;  generate label without underscore
    endif

    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cBegin>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have locals
      if ???+a+?rp			;;  saved regs, or parmRs
	if2
	  ??_out <cBegin - possibly invalid use of nogen>
	endif
      endif
    else				;;else must generate a frame
      if ?uf				;;if user frame code specified
	 ?mf c,%???,%?po		;;  call user's makeframe
	 mpush a			;;  save specified registers
      else
	ife ?cbe			;;If full frame to be set up
	  if w				;;if a far windows procedure
	    ife ?nd			;;if not NODATA,
	      mov IAX,ds 		;;   then set AX = current ds, and    ;@
	      nop			;;   leave room for  MOV AX,1234h     ;@
	    endif
	    ife ?nx			;;if not ATOMIC, far frame must be set
	      ife ?DOS5 		;;if not DOS5, then set far frame flag
		inc IBP			;;  by incrementing the old bp	      ;@
	      endif
	      push IBP							      ;@
	      mov IBP,ISP 						      ;@
	      ife ?COW			;; save DS not needed for CW
	  	push ds							      ;@
	      endif
	    else			;;ATOMIC procedure
	      if ?ff+???+?po+?rp	;;if any locals or parameters
		push IBP 		;;  then must set frame pointer       ;@
		mov IBP,ISP		;;  to be able to access them	      ;@
	      endif
	    endif
	    ife ?nd			;;if not NODATA, then AX should
	      mov ds,IAX 		;;  have the ds to use		      ;@
	    endif
	  else				;;not windows.	use standard prolog
	    if ?ff+???+?po+?rp		;;if any locals or parameters
	      push IBP			;;  then must set frame pointer       ;@
	      mov IBP,ISP 		;;  to be able to access them	      ;@
	    endif
	  endif
	  if ?rp			;;if parmR's, push them before
	    ?uf=0			;;  allocating locals and saving
	    rept ?rp			;;  the autosave registers
	      uconcat mpush,,?rp,%?uf
	      ?uf=?uf+1
	    endm
	  endif
	  if ???			;;if locals to allocate
	    if ?chkstk1 		;;if stack checking enabled
	      ifdef ?CHKSTKPROC 	;;if user supplied stack checking
		?CHKSTKPROC %???	;;  invoke it with bytes requested
	      else
		mov IAX,???		;;invoke default stack checking       ;@
		ife cc
		  call _chkstk						      ;@
		else
		  call chkstk						      ;@
		endif
	      endif
	    else			;;no stack checking
	      sub   ISP,???		;; allocate any local storage	      ;@
	    endif
	  endif
	else				;;partial frame, only set locals
	  if ?rp			;;If parmRs, error
	    ??error2 <cBegin - parmRs encountered with partial frame>
	  else
	    if ???			;;Only realloc frame if locals
	      lea ISP,[IBP][-???-?ia]	;;?ia will adjust for saved BP	      ;@
	    endif
	  endif
	endif
	mpush a 			;;save autosave registers
      endif

      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StartNMeas		;;  invoke profile start procedure    ;@
	endif
      endif

    endif

    .cref
    purge cBegin			;;remove the macro
  &endm 				;;end of cBegin macro

  .xcref ?utpe
  ?utpe &macro
    ??error2 <unterminated procedure definition: "&n">
  &endm
  .cref
endm					;;end of ?pg macro




;;      ?pg1 - generate end macro for current procedure
;;
;;      format:
;;		?pg1 n,c,a,o,w,f,d,r,cc,nnu,lc
;;      where:
;;              n       is the name of the procedure
;;              c       is the class definition for the procedure
;;              a       is an enumerated list of registers to save
;;                      at entry and restore at exit
;;              o       is the number of bytes of paramteres to remove at exit
;;              w       true if a far windows procedure
;;              f       is 1 if to use the user's makeframe procedure
;;		d	is 1 if NODATA procedure
;;              r       number of register parameters
;;		cc	calling convention (C or PL/M)
;;		nnu	procedure name without any underscore
;;		lc	locals byte count


?pg1 macro n,c,a,o,w,f,d,r,cc,nnu,lc
  .xcref
  .xcref cEnd

  parm_bytes_&nnu = o			;;Define number of parameter bytes

  cEnd &macro g 			;;start of cEnd macro
    .xcref
    ?ba=0				;;no longer in a procedure
    ?cbe = 0				;;Assume no command on cBegin line
    ifnb <g>
      ?pcbe <g>,<nnu>,<cEnd>
    endif
    if ?cbe eq 1			;;if nogen, then cannot have parmRs
      if a+r+lc 			;;  locals, or saved registers
	if2
	  ??_out <cEnd - possibly invalid use of nogen>
	endif
      endif
    else				;;else must remove the frame
      ifdef ?PROFILE			;;if profiling enabled
	if c				;;  and a far procedure
	  call StopNMeas		;;  invoke profile stop procedure
	endif				;;  (doesn't trash DX:AX)
      endif
      mpop a				;;restore autosaved registers
      if f				;;if to use the "makeframe" procedure
	db 0c3h 			;;  near return to user's makeframe    @
      else
	if w				;;if far win proc, use special epilog
	  ife ?nx			;;if not ATOMIC, bp was pushed
	    ife ?COW			;; restore DS not needed for CW
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
		lea sp,-2[bp]		;;  or locals or parmR's, get valid SP @
	      endif
	      pop ds			;;restore saved ds and bp	       @
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov sp,bp
	      endif
	    endif
	    pop IBP			;;				       @
	    ife ?DOS5			;;if not DOS5, bp was
	      dec IBP			;;  incremented to mark far frame      @
	    endif
	  else				;;ATOMIC frame was set up
	    if memS32
	      leave
	    else
	      if (?TF eq 0) or (???+r)	;;if cannot assume valid sp
	        mov ISP,IBP 		;;  or locals or parmR's, get valid SP @
	      endif
	      if ???+?po+r
	        pop IBP						      ;@
	      endif
	    endif
	  endif
	else				;;non-windows standard epilog
	  if ?ff+???+?po+r		;;if any parameters
	    if (?TF eq 0) or (???+r)	;;if cannot assume valid SP
	      mov ISP,IBP 		;;  or locals or parmR's, get valid SP;@
	    endif
	    pop IBP							      ;@
	  endif
	endif
	if ?cbe ne 4			;;Don't generate ret if ??cleanframe??   e
	  ife cc			;;if C calling convention
	    ret 			;;  return			      ;@
	  else				;;else
	    ret o			;;  return and remove paramteres      ;@
	  endif
	endif
      endif
    endif
    if ?cbe ne 4			;;Don't delete macro if ??cleanframe??   e
      n endp				;;end of process
      .cref
      purge cEnd			;;remove the macro
    else
      .cref
    endif
  &endm
  .cref
endm


;;	cleanframe
;;
;;	cleanframe removes a cMacros generated frame, invoking cEnd
;;	with a special keyword which will keep the cEnd macro from
;;	generating a return statement and purging itself.

.xcref
.xcref cleanframe
cleanframe macro
  cEnd <??cleanframe??>
endm
.cref



;; The following macros are used to speed up the processing of the
;; command allowed on a cProc command line.  They simply set or clear
;; the correct flag as needed.

.xcref
.xcref ??_cproc_FAR,??_cproc_NEAR,??_cproc_PUBLIC,??_cproc_SMALL
.xcref ??_cproc_DATA,??_cproc_NODATA,??_cproc_ATOMIC,??_cproc_C
.xcref ??_cproc_PLM,??_cproc_PASCAL,??_cproc_WIN,??_cproc_NONWIN
.xcref ??_cproc_NO_BP,??_cproc_BP

.xcref ??_cproc_far,??_cproc_near,??_cproc_public,??_cproc_small
.xcref ??_cproc_data,??_cproc_nodata,??_cproc_atomic,??_cproc_c
.xcref ??_cproc_plm,??_cproc_pascal,??_cproc_win,??_cproc_nonwin
.xcref ??_cproc_no_bp,??_cproc_bp
.cref

??_cproc_FAR macro
 ?pc=1
endm

??_cproc_NEAR macro
  ?pc=0
endm

??_cproc_PUBLIC macro
  ?pu=1
endm

??_cproc_SMALL macro
  ?uf=1
endm

??_cproc_DATA macro
  ?nd=0
endm

??_cproc_NODATA macro
  ?nd=1
endm

??_cproc_ATOMIC macro
  ?nx=1
endm

??_cproc_C macro
  ?pcc=0
endm

??_cproc_PLM macro
  ?pcc=1
endm

??_cproc_PASCAL macro
  ?pcc=1
endm

??_cproc_WIN macro
  ?wfp=1
endm

??_cproc_NONWIN macro
  ?wfp=0
endm

??_cproc_NO_BP macro
  ?no_bp2=1
endm

??_cproc_BP macro
  ?no_bp2=0
endm

??_cproc_far macro
 ?pc=1
endm

??_cproc_near macro
  ?pc=0
endm

??_cproc_public macro
  ?pu=1
endm

??_cproc_small macro
  ?uf=1
endm

??_cproc_data macro
  ?nd=0
endm

??_cproc_nodata macro
  ?nd=1
endm

??_cproc_atomic macro
  ?nx=1
endm

??_cproc_c macro
  ?pcc=0
endm

??_cproc_plm macro
  ?pcc=1
endm

??_cproc_pascal macro
  ?pcc=1
endm

??_cproc_win macro
  ?wfp=1
endm

??_cproc_nonwin macro
  ?wfp=0
endm

??_cproc_no_bp macro
  ?no_bp2=1
endm

??_cproc_bp macro
  ?no_bp2=0
endm


;	?pcbe is the macro which processes the text on cBegin/cEnd
;	The text is allowed to be:
;
;		NOGEN	nogen
;		PARTIAL partial
;		the procedure name as given on the cProc line
;
;	usage:
;		?pcbe <g>,<nnu>,<mt>
;	where:
;		g	is the text on the cBegin/cEnd line
;		nnu	is the procedure name without any underscores
;		mt	macro type (cBegin/cEnd)
;
;	The variable ?cbe is set to the following value
;
;		0 = invalid (defualt action>
;		1 = nogen
;		2 = partial frame
;		4 = clean frame


?pcbe macro g,nnu,mt
  ifidn <g>,<NOGEN>
    ?cbe = 1
  else
    ifidn <g>,<nogen>
      ?cbe = 1
    else
      ifidn <mt>,<cBegin>
	ifidn <g>,<PARTIAL>
	  ?cbe = 2
	else
	  ifidn <g>,<partial>
	    ?cbe = 2
	  else
	    ifdif <g>,<nnu>
	      ??error2 <mt - unknown keyword g>
	    endif
	  endif
	endif
      else
	ifidn <g>,<??cleanframe??>
	  ?cbe = 4
	else
	  ifdif <g>,<nnu>
	    ??error2 <mt - unknown keyword g>
	  endif
	endif
      endif
    endif
  endif
endm



;	assumes is a macro that will set up the assumes for a segment
;	or group created with the createSeg macro.  If the assumed
;	value passed in isn't known, then a normal assume is made.
;
;       usage:
;               assumes s,g
;
;       where:
;               s       is the register to make the assumption about
;		g	is the value to assume is in it
;
; as a hack, substitute FLAT for g if memF32 is set


assumes macro   s,ln
  if  memF32
    assume s:FLAT
  endif
  ife memF32
    ifndef ln&_assumes
      assume s:ln
    else
      ln&_assumes s
    endif
  endif
endm



;	createSeg is a macro that sets up a segment definition and
;	a logical name for that segment.  The logical name can be
;       used to enter the segment, but it cannot be used for anything
;       else.
;
;       usage:
;		createSeg n,ln,a,co,cl,grp
;       where:
;               n       is the physical name of the segment
;               ln      is the name it is to be invoked by
;               a       is the alignment, and is optional
;               co      is the combine type, and is optional
;               cl      is the class, and is optional
;               grp     is the name of the group that contains this segment


createSeg macro n,ln,a,co,cl,grp
  ifnb <cl>
    n segment a co '&cl'
  else
    n segment a co
  endif
  n ends
  ifnb <grp>
    addseg grp,n
  else
    ln&OFFSET equ offset n:
    ln&BASE equ n
    ?cs3 <ln>,<n>
  endif
  ?cs1 <ln>,<n>
endm


addseg macro grp,seg
  .xcref
  .xcref grp&_def
  .cref
  ifndef  grp&_def
    grp&_def=0
  endif
  if grp&_def ne ASMpass
    .xcref
    .xcref grp&_add
    .cref
    grp&_add &macro s
      grp&_in <seg>,s
    &endm
    .xcref
    .xcref grp&_in
    .cref
    grp&_in &macro sl,s
      ifb <s>
	grp group sl
      else
	grp&_add &macro  ns
	grp&_in  <sl,s>,ns
	&endm
      endif
    &endm
    grp&_def=ASMpass
  else
    grp&_add seg
  endif
endm


defgrp macro grp,ln
  addseg grp
  ifnb <ln>
    irp x,<ln>
      ?cs3 <&x>,<grp>
      x&&OFFSET equ offset grp:
      x&&BASE equ grp
    endm
  endif
endm


?cs1 macro ln,n
  .xcref
  .xcref ln&_sbegin
  .cref
  ln&_sbegin &macro
    .xcref
    .xcref ?mf
    .cref
    ?mf &&macro c,l,p			;;when sBegin is invoked, generate
      if c				;;  the makeframe macro
	extrn n&_FARFRAME:near		;;  make frame for far procedures     ;@
	call n&_FARFRAME						      ;@
      else
	extrn n&_NEARFRAME:near 	;;  make frame for near procedures    ;@
	call n&_NEARFRAME						      ;@
      endif
      db l shr 1			;;define number of locals	      ;@
      db p shr 1			;;define number of parameters	      ;@
      &&endm
    ?cs2 <ln>,<n>
    n segment
  &endm
endm


?cs2 macro ln,n
  .xcref
  .xcref sEnd
  .cref
  sEnd &macro
    n ends
    purge ?mf				;;delete the makeframe macro
    purge sEnd
  &endm
endm


?cs3 macro ln,n
  .xcref
  .xcref ln&_assumes
  .cref
  ln&_assumes &macro s
    assume s:&n
  &endm
endm



;	sBegin is the macro that opens up the definition of a segment.
;	The segment must have already been defined with the createSeg
;       macro.
;
;       usage:
;		sBegin ln
;
;       where:
;               ln      is the logical name given to the segment when
;                       it was declared.

.xcref
.xcref sBegin
.cref
sBegin macro ln
  ln&_sbegin
endm

BeginDATA macro
  ife memF32
    sBegin DATA
  else
    .data
  endif
endm

BeginCODE macro
  ife memF32
    sBegin CODE
  else
    .code
  endif
endm

EndDATA macro
  ife memF32
    sEnd DATA
  endif
endm

EndCODE macro
  ife memF32
    sEnd CODE
  endif
endm

ife ?DF

  ;	Define all segments that will be used.	This will allow the
  ;	assume and groups to be set up at one given place, and also
  ;	allow quick changes to be made
  ;
  ;	createSeg name,logname,align,combine,class,group

ife ?DFCODE
  createSeg _TEXT,CODE,%wordI,public,CODE
endif
  ife ?nodata1
    createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
    defgrp DGROUP,DATA
  else
    ife ?DFDATA
      createSeg _DATA,DATA,%wordI,public,DATA,DGROUP
      defgrp DGROUP,DATA
    endif
  endif

  if ?chkstk1
    ifndef ?CHKSTKPROC
      externp <chkstk>
    endif
  endif
endif


;       errnz exp - generate error message if expression isn't zero
;
;	The errnz will generate an error message if the expression "exp"
;	does not evaluate to zero.  This macro is very useful for testing
;       relationships between items, labels, and data that was coded into
;       an application.
;
;                  errnz   <offset $ - offset label>   ;error if not at "label"
;                  errnz   <eofflag and 00000001b>     ;eofflag must be bit 0
;
;	For expressions involving more than one token, the angle brackets
;       must be used.
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errnz macro x				;;display error if expression is <>0
  if2
    if x				;;if expression is non-zero,
      errnz1  <x>,%(x)
    endif
  endif
endm

errnz1 macro x1,x2
  = *errnz* x1 = x2
  .err
endm



;       errn$ label,exp - generate error message if label (exp) <> $
;
;	The errnz will generate an error message if the label and "exp"
;       does not evaluate to the current value of the location counter.
;	This macro is very useful for testing relationships between
;       labels and the location counter that was coded into an application.
;
;       examples:  errn$   label        ;error if not at "label"
;                  errn$   label,+3     ;error if not three bytes from "label"
;                  errn$   label,-3     ;error if not three bytes past "label"
;
;	If no "exp" is given, it is the same as specifying 0
;
;	The macro is only evaluated on pass 2, so forward references may be
;       used in the expression.

errn$ macro l,x 			;;error if <$-label1 (exp2)> <>0
  errnz   <offset $ - offset l x>
endm



;;	If profile has been specified, declare the profile routines
;;	to be external and far.  It would be best if this could be done
;;	when the call is actually made, but then the fix-up would be
;;	generated as segment-relative.


ifdef ?PROFILE
  externFP  <StartNMeas,StopNMeas>
endif

if memF32
  .model small
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\i386\exsup3.asm ===
;***
;exsup3.asm
;
;       Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Exception handling for i386.  This is just the C9.0 version of
;       the language-specific exception handler.  The C8.0 version is
;       found in exsup2.asm, and the routines common to both C8 and C9
;       are found in exsup.asm.
;
;Notes:
;
;Revision History:
;       01-10-94  PML   Create VC/C++ 2.0 (C9.0) version from C8.0 original
;       01-11-95  SKS   Remove MASM 5.X support
;       04-18-95  JWM   Added NLG support
;       06-07-95  JWM   __SetNLGCode() used, for multithread safety.
;       06-20-95  JWM   __SetNLGCode() removed, code passed on stack (11803).
;
;*******************************************************************************

;hnt = -D_WIN32 -Dsmall32 -Dflat32 -Mx $this;

;Define small32 and flat32 since these are not defined in the NT build process
small32 equ 1
flat32  equ 1

.xlist
include pversion.inc
?DFDATA =       1
?NODATA =       1
include cmacros.inc
include exsup.inc
.list

;REVIEW: can we get rid of _global_unwind2, and just use
; the C runtimes version, _global_unwind?

extrn __global_unwind2:near
extrn __local_unwind2:near
;extrn __NLG_Notify:near

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;/* _esp, xpointers at negative offset */
;     int _esp;
;     PEXCEPTION_POINTERS xpointers;
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;};
;private (at negative offsets from node ptr)
    _esp                =       -8
    xpointers           =       -4
_C9_EXCEPTION_REGISTRATION struc        ; C9.0 version
;public:
                        dd      ?       ; prev (common)
                        dd      ?       ; handler (common)
;private:
    scopetable          dd      ?
    trylevel            dd      ?
_C9_EXCEPTION_REGISTRATION ends
FRAME_EBP_OFFSET equ 16

;#define EXCEPTION_MAXIMUM_PARAMETERS 4
;typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;
;typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;
;struct _EXCEPTION_RECORD{
;    NTSTATUS ExceptionCode;
;    ULONG ExceptionFlags;
;    struct _EXCEPTION_RECORD *ExceptionRecord;
;    PVOID ExceptionAddress;
;    ULONG NumberParameters;
;    ULONG ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
;};
_EXCEPTION_RECORD struc
    exception_number    dd      ?
    exception_flags     dd      ?
    exception_record    dd      ?
    exception_address   dd      ?
    number_parameters   dd      ?
    exception_information dd 4 dup(?)
_EXCEPTION_RECORD ends
SIZEOF_EXCEPTION_RECORD equ 36

;/* following is the structure returned by the _exception_info() intrinsic. */
;typedef struct _EXCEPTION_POINTERS EXCEPTION_POINTERS;
;typedef struct EXCEPTION_POINTERS *PEXCEPTION_POINTERS;
;struct _EXCEPTION_POINTERS{
;    PEXCEPTION_RECORD ExceptionRecord;
;    PCONTEXT Context;
;};
_EXCEPTION_POINTERS struc
    ep_xrecord          dd      ?
    ep_context          dd      ?
_EXCEPTION_POINTERS ends
SIZEOF_EXCEPTION_POINTERS equ 8

;extern __NLG_Destination:_NLG_INFO

assumes DS,DATA
assumes FS,DATA

__except_list equ 0

;struct _SCOPETABLE_ENTRY{
;     int enclosing_level;              /* lexical level of enclosing scope */
;     int (*filter)(PEXCEPTION_RECORD); /* NULL for a termination handler */
;     void (*specific_handler)(void);   /* xcpt or termination handler */
;};
;struct _SCOPETABLE_ENTRY Scopetable[NUMTRYS];
_SCOPETABLE_ENTRY struc
    enclosing_level     dd      ?
    filter              dd      ?
    specific_handler    dd      ?
_SCOPETABLE_ENTRY ends

BeginCODE

;EXTERN C __SetNLGCode:near

;/* _EXCEPT_HANDLER3 - Try to find an exception handler listed in the scope
; * table associated with the given registration record, that wants to accept
; * the current exception. If we find one, run it (and never return).
; * RETURNS: (*if* it returns)
; *  DISPOSITION_DISMISS - dismiss the exception.
; *  DISPOSITION_CONTINUE_SEARCH - pass the exception up to enclosing handlers
; */
;int _except_handler3(
;       PEXCEPTION_RECORD exception_record,
;       PEXCEPTION_REGISTRATION registration,
;       PCONTEXT context,
;       PEXCEPTION_REGISTRATION dispatcher)
;{
;    int ix, filter_result;
;
;    for(ix=registration->trylevel; ix!=-1; ix=registration->xscope[ix].enclosing_level){
;       /* if filter==NULL, then this is an entry for a termination handler */
;       if(registration->xscope[ix].filter){
;           /* NB: call to the filter may trash the callee save
;              registers. (this is *not* a standard cdecl function) */
;           filter_result=(*registration->xscope[ix].filter)(xinfo);
;           if(filter_result==FILTER_DISMISS)
;               return(-1); /* dismiss */
;           if(filter_result==FILTER_ACCEPT){
;               _global_unwind2(registration);
;               _local_unwind2(registration, ix);
;               (*registration->xscope[ix].specific_handler)(void);
;               assert(UNREACHED); /*should never return from handler*/
;           }
;           assert(filter_result==FILTER_CONTINUE_SEARCH);
;       }
;    }
;    return(0); /* didnt find one */
;}
        db      'VC20'  ;; VC/C++ 2.0/32-bit (C9.0) version
        db      'XC00'  ;; so debugger can recognize this proc (cuda:3936)
cProc _except_handler3,<C,PUBLIC>,<IBX,ISI,IDI,IBP>
        parmDP  xrecord
        parmDP  registration
        parmDP  context
        parmDP  dispatcher
        localV  xp,SIZEOF_EXCEPTION_POINTERS
cBegin
        ;4*4b for callee saves + 4b return address + 4b param = 24

        ;DF in indeterminate state at time of exception, so clear it
        cld

        mov     ebx, registration               ;ebx= PEXCEPTION_REGISTRATION
        mov     eax, xrecord

        test    [eax.exception_flags], EXCEPTION_UNWIND_CONTEXT
        jnz     _lh_unwinding

        ;build the EXCEPTION_POINTERS locally store its address in the
        ; registration record. this is the pointer that is returned by
        ; the _eception_info intrinsic.
        mov     xp.ep_xrecord, eax
        mov     eax, context
        mov     xp.ep_context, eax
        lea     eax, xp
        mov     [ebx.xpointers], eax

        mov     esi, [ebx.trylevel]             ;esi= try level
        mov     edi, [ebx.scopetable]           ;edi= scope table base
_lh_top:
        cmp     esi, -1
        je      short _lh_bagit
        lea     ecx, [esi+esi*2]                ;ecx= trylevel*3
        cmp     dword ptr [(edi+ecx*4).filter], 0
        je      short _lh_continue              ;term handler, so keep looking

        ;filter may trash *all* registers, so save ebp and scopetable offset
        push    esi
        push    ebp

        lea     ebp, FRAME_EBP_OFFSET[ebx]
        call    [(edi+ecx*4).filter]            ;call the filter

        pop     ebp
        pop     esi
        ;ebx may have been trashed by the filter, so we must reload
        mov     ebx, registration

        ; Accept <0, 0, >0 instead of just -1, 0, +1
        or      eax, eax
        jz      short _lh_continue
        js      short _lh_dismiss
        ;assert(eax==FILTER_ACCEPT)

        ;reload xscope base, cuz it was trashed by the filter call
        mov     edi, [ebx.scopetable]
        ;load handler address before we loose components of address mode
        push    ebx                             ;registration*
        call    __global_unwind2                ;run term handlers
        add     esp, 4

        ;setup ebp for the local unwinder and the specific handler
        lea     ebp, FRAME_EBP_OFFSET[ebx]

        ;the stop try level == accepting except level
        push    esi                             ;stop try level
        push    ebx                             ;registration*
        call    __local_unwind2
        add     esp, 8
        lea     ecx, [esi+esi*2]                ;ecx=trylevel*3

;        push    01h
;        mov     eax, [(edi+ecx*4).specific_handler]
;        call    __NLG_Notify

; set the current trylevel to our enclosing level immediately
; before giving control to the handler. it is the enclosing
; level, if any, that guards the handler.
        mov     eax, [(edi+ecx*4).enclosing_level]
        mov     [ebx.trylevel], eax
        call    [(edi+ecx*4).specific_handler]  ;call the except handler
        ;assert(0)                              ;(NB! should not return)

_lh_continue:
        ;reload the scope table base, possibly trashed by call to filter
        mov     edi, [ebx.scopetable]
        lea     ecx, [esi+esi*2]
        mov     esi, [edi+ecx*4+0]              ;load the enclosing trylevel
        jmp     short _lh_top

_lh_dismiss:
        mov     eax, DISPOSITION_DISMISS        ;dismiss the exception
        jmp     short _lh_return

_lh_bagit:
        mov     eax, DISPOSITION_CONTINUE_SEARCH
        jmp     short _lh_return

_lh_unwinding:
        push    ebp
        lea     ebp, FRAME_EBP_OFFSET[ebx]
        push    -1
        push    ebx
        call    __local_unwind2
        add     esp, 8
        pop     ebp
        ;the return value is not really relevent in an unwind context
        mov     eax, DISPOSITION_CONTINUE_SEARCH

_lh_return:
cEnd

;public __seh_longjmp_unwind@4
;__seh_longjmp_unwind@4 proc near
;        push    ebp
;        mov     ecx, 8[esp]
;        mov     ebp, [ecx.saved_ebp]
;        mov     eax, [ecx.saved_trylevel]
;        push    eax
;        mov     eax, [ecx.saved_xregistration]
;        push    eax
;        call    __local_unwind2
;        add     esp, 8
;        pop     ebp
;        ret     4
;__seh_longjmp_unwind@4 endp

EndCODE
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\i386\pversion.inc ===
;	SCCSID = "@(#)pversion.inc:1.8"
?PLM = 1
?WIN = 0
REALFAR = 0		; used for QC only
ifdef large
 ?LARGE		equ	1
endif
ifdef compact
 ?COMPACT	equ	1
endif
ifdef medium
 ?MEDIUM	equ	1
endif
ifdef small
 ?SMALL		equ	1
endif
ifdef small32
 ?SMALL32	equ	1
 memS32		=	1
else
 memS32		=	0
endif
ifdef flat32
 ?FLAT32	equ	1
 memF32		=	1
else
 memF32		=	0
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\mspatch\makefile.inc ===
DELEXPFILE:
  @if exist ..\..\bin\$(TARGET_DIRECTORY)\mspatch.exp \
       @del ..\..\bin\$(TARGET_DIRECTORY)\mspatch.exp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\mspatcha\makefile.inc ===
DELEXPFILE:
  @if exist ..\..\bin\$(TARGET_DIRECTORY)\mspatcha.exp \
       @del ..\..\bin\$(TARGET_DIRECTORY)\mspatcha.exp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\apatch\apatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>

#include "patchapi.h"
#include "patchprv.h"
#include <ntverp.h>
#include <common.ver>

void CopyRight( void ) {
    printf(
        "\n"
        "APATCH " VER_PRODUCTVERSION_STR " Patch Application Utility\n"
        VER_LEGALCOPYRIGHT_STR
        "\n\n"
        );
    }


void Usage( void ) {
    printf(
        "Usage:  APATCH PatchFile OldFile TargetNewFile\n\n"
        );
    exit( 1 );
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( CurrentPosition & 0xFF000000 ) {
        CurrentPosition >>= 8;
        MaximumPosition >>= 8;
        }

    if ( MaximumPosition != 0 ) {
        fprintf( stderr, "\r%3.1f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
        }

    return TRUE;
    }


void __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    DeleteFile( NewFileName );

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  NULL
                  );

    printf( "\n\n" );

    if ( ! Success ) {

        CHAR  ErrorText[ 16 ];
        ULONG ErrorCode = GetLastError();

        sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        printf( "Failed to create file from patch (%s)\n", ErrorText );

        exit( 1 );
        }

    printf( "OK\n" );
    exit( 0 );

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\mpatch\makefile.inc ===
EXENAME=mpatch.exe
PDBNAME=mpatch.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\apatch\tracing.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>

#include "patchapi.h"

#ifdef TRACING

#define FILESIZE (3000000)

long g_OldFilePosition;
unsigned long g_cLiterals = 0;
unsigned long g_cMatches = 0;
unsigned long g_cMatchBytes = 0;

#if 0   /* distance.xls */
unsigned long cDistances[6000000] = { 0 };
#endif

#ifdef COMPOSITION  /* composition.xls */
#define BUCKET_SIZE (4096)
#define NBUCKETS (FILESIZE / BUCKET_SIZE)
enum { LITERAL, MATCH_OLD, MATCH_NEW, BUCKET_TYPES };
unsigned long cBuckets[NBUCKETS][BUCKET_TYPES] = { { 0,0,0 } };
#endif

#if 0   /* rifts */
#define NO_DISPLACEMENT (333333333)
long iDisplacement[FILESIZE];
#endif

#if 0   /* slots */
#define MAX_SLOTS 500
unsigned long cSlotUsed[MAX_SLOTS];
#endif

typedef struct
{
    unsigned long ulRegionOffset;
    unsigned long ulRegionSize;
    unsigned long ulRegionAddress;
} FILE_REGION;

#define MAX_REGIONS 50

int cRegionsOld = 0;
FILE_REGION RegionsOld[MAX_REGIONS];
int cRegionsNew = 0;
FILE_REGION RegionsNew[MAX_REGIONS];


typedef struct
{
    unsigned long ulNewOffset;
    unsigned long ulOldOffset;
    unsigned long ulMatchLength;
} MATCH_LOG_ENTRY;

#define MAX_MATCH_LOG_ENTRIES (500000)

int cMatchLogEntries = 0;
MATCH_LOG_ENTRY MatchLog[MAX_MATCH_LOG_ENTRIES];


typedef struct _a_POINTER_REMAP
{
    struct _a_POINTER_REMAP *pNext;
    unsigned long ulNewPointer;
    unsigned long ulOldPointer;
    unsigned long ulLength;
} POINTER_REMAP;

POINTER_REMAP *pPointerRemapList;


#ifdef RIFTGEN
static char isRelocEntry[FILESIZE] = { '\0' };

#ifdef RIFTGEN2   /* references */
typedef struct _a_reference
{
    struct _a_reference *pNext;
    long iDisplacement;
} REFERENCE;

static REFERENCE *pReferences[FILESIZE] = { NULL };
#endif
#endif


static int QueryRelocsInRange(unsigned long ulAddress, unsigned long ulLength)
{
    int iRegion;
    unsigned long ulFileOffset;
    int fRelocsFound = FALSE;

    for (iRegion = 0; iRegion < cRegionsOld; iRegion++)
    {
        if ((ulAddress >= RegionsOld[iRegion].ulRegionAddress) &&
            (ulAddress < (RegionsOld[iRegion].ulRegionAddress + RegionsOld[iRegion].ulRegionSize)))
        {
            break;
        }
    }

    if (iRegion != cRegionsOld)
    {
        ulFileOffset = RegionsOld[iRegion].ulRegionOffset + (ulAddress - RegionsOld[iRegion].ulRegionAddress);

        while (ulLength--)
        {
            if (isRelocEntry[ulFileOffset])
            {
                fRelocsFound = TRUE;
                break;
            }

            ulFileOffset++;
            ulAddress++;
        }
    }

    return(fRelocsFound);
}


static void DisplayMatchLog(void)
{
    int iMatchLogEntry;
    unsigned long ulNewOffset;
    unsigned long ulOldOffset;
    int iNewFileRegion;
    int iOldFileRegion;
    unsigned long ulMatchLength;
    unsigned long ulLocalLength;
    unsigned long ulNewDisplacement;
    unsigned long ulOldDisplacement;
    POINTER_REMAP *pRemap;
    POINTER_REMAP **ppBacklink;
    unsigned long ulNewPointer;
    unsigned long ulOldPointer;
    long lLastDisplacement;

    if (cMatchLogEntries == 0)
    {
        return;
    }

    pPointerRemapList = NULL;

    for (iMatchLogEntry = 0; iMatchLogEntry < cMatchLogEntries; iMatchLogEntry++)
    {
        ulNewOffset = MatchLog[iMatchLogEntry].ulNewOffset;
        ulOldOffset = MatchLog[iMatchLogEntry].ulOldOffset;
        ulMatchLength = MatchLog[iMatchLogEntry].ulMatchLength;

        while (ulMatchLength)               /* until all is done */
        {
            ulLocalLength = ulMatchLength;  /* might get clipped */

            /* locate corresponding new file region to get it's address */

            for (iNewFileRegion = 0; iNewFileRegion < cRegionsNew; iNewFileRegion++)
            {
                if ((ulNewOffset >= RegionsNew[iNewFileRegion].ulRegionOffset) &&
                    (ulNewOffset < (RegionsNew[iNewFileRegion].ulRegionOffset + RegionsNew[iNewFileRegion].ulRegionSize)))
                {
                    break;
                }
            }

            if (iNewFileRegion == cRegionsNew)
            {
                goto dontcare;
            }

            /* clip if match spans beyond this region */

            ulNewDisplacement = ulNewOffset - RegionsNew[iNewFileRegion].ulRegionOffset;
            ulNewPointer = RegionsNew[iNewFileRegion].ulRegionAddress + ulNewDisplacement;

            if (ulLocalLength > (RegionsNew[iNewFileRegion].ulRegionSize - ulNewDisplacement))
            {
                ulLocalLength = (RegionsNew[iNewFileRegion].ulRegionSize - ulNewDisplacement);
            }

            /* locate corresponding old file region to get it's address */

            for (iOldFileRegion = 0; iOldFileRegion < cRegionsOld; iOldFileRegion++)
            {
                if ((ulOldOffset >= RegionsOld[iOldFileRegion].ulRegionOffset) &&
                    (ulOldOffset < (RegionsOld[iOldFileRegion].ulRegionOffset + RegionsOld[iOldFileRegion].ulRegionSize)))
                {
                    break;
                }
            }

            if (iOldFileRegion == cRegionsOld)
            {
                goto dontcare;
            }

            /* clip if match spans beyond this region */

            ulOldDisplacement = ulOldOffset - RegionsOld[iOldFileRegion].ulRegionOffset;
            ulOldPointer = RegionsOld[iOldFileRegion].ulRegionAddress + ulOldDisplacement;

            if (ulLocalLength > (RegionsOld[iOldFileRegion].ulRegionSize - ulOldDisplacement))
            {
                ulLocalLength = (RegionsOld[iOldFileRegion].ulRegionSize - ulOldDisplacement);
            }

            /* see if any relocs in the range */

            if (QueryRelocsInRange(ulOldPointer, ulLocalLength))
            {
                /* sorted insertion of this new remap into the list */

                ppBacklink = &pPointerRemapList;

                while (*ppBacklink != NULL)
                {
                    if ((*ppBacklink)->ulOldPointer > ulOldPointer)
                    {
                        break;
                    }

                    ppBacklink = &((*ppBacklink)->pNext);
                }

                pRemap = GlobalAlloc( GMEM_FIXED, sizeof(POINTER_REMAP) );

                pRemap->ulNewPointer = ulNewPointer;
                pRemap->ulOldPointer = ulOldPointer;
                pRemap->ulLength = ulLocalLength;

                pRemap->pNext = *ppBacklink;
                *ppBacklink = pRemap;
            }

            /* move on to next match or fragment */

            ulNewOffset   += ulLocalLength;
            ulOldOffset   += ulLocalLength;
            ulMatchLength -= ulLocalLength;
        }
dontcare:
        NULL;    // entertain compiler req: label must have a statement
    }

    printf("%08X\n", RegionsOld[ 0 ].ulRegionAddress);

    lLastDisplacement = 0;

    for (pRemap = pPointerRemapList; pRemap != NULL; pRemap = pRemap->pNext)
    {
        if (lLastDisplacement != (long) (pRemap->ulNewPointer - pRemap->ulOldPointer))
        {
            lLastDisplacement = pRemap->ulNewPointer - pRemap->ulOldPointer;

            printf("%08X %08X\n", pRemap->ulOldPointer, pRemap->ulNewPointer);
        }
    }
}

#endif


void CopyRight( void ) {
    MessageBox(
        NULL,
        "\n"
        "APATCH 0.15 Patch Application Utility\n"
        "Copyright (C) Microsoft, 1997\n"
        "\n",
        "APATCH Copyright",
        MB_OK);
    }


void Usage( void ) {
    MessageBox(NULL,
        "Usage:  APATCH PatchFile OldFile TargetNewFile\n\n",
        "APATCH Usage",
        MB_OK);
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( CurrentPosition & 0xFF000000 ) {
        CurrentPosition >>= 8;
        MaximumPosition >>= 8;
        }

    if ( MaximumPosition != 0 ) {
// guigauge: printf( "\r%3d%% complete", ( CurrentPosition * 100 ) / MaximumPosition );
        }

    return TRUE;
    }


int StrChr( char *psz, char c )
{
    while (*psz)
    {
        if (*psz++ == c)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


int __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    // CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( StrChr( arg, '?' )) {
            Usage();
            goto bail;
            }

        if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            goto bail;
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        goto bail;
        }

    DeleteFile( NewFileName );

#ifdef TRACING
#if 0   /* rifts */
    {
        long filepos;

        for (filepos = 0; filepos < FILESIZE; filepos++)
        {
            iDisplacement[filepos] = NO_DISPLACEMENT;
        }
    }
#endif
#endif

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  NULL
                  );

    if ( ! Success ) {

        CHAR  ErrorText[ 16 ];
        ULONG ErrorCode = GetLastError();
        CHAR  Message[100];

        wsprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        wsprintf( Message, "Failed to create file from patch (%s)\n", ErrorText );

        MessageBox( NULL, Message, "APATCH Failed", MB_OK );

        return( 1 );
        }

#ifdef TRACING
    {
#ifdef COMPOSITION   /* composition.xls */
        {
            int iBucket;

            for (iBucket = 0; iBucket < NBUCKETS; iBucket++)
            {
                if ((cBuckets[iBucket][LITERAL] || cBuckets[iBucket][MATCH_OLD] || cBuckets[iBucket][MATCH_NEW]))
                {
                    printf("%9lu %9lu %9lu %9lu\n",
                        iBucket * BUCKET_SIZE,
                        cBuckets[iBucket][LITERAL],
                        cBuckets[iBucket][MATCH_OLD],
                        cBuckets[iBucket][MATCH_NEW]);
                }
            }
        }
#endif

#if 0
        printf("%9lu bytes from literals\n", g_cLiterals);
        printf("%9lu bytes from %lu matches\n", g_cMatchBytes, g_cMatches);
        printf("%9lu bytes total\n", g_cLiterals + g_cMatchBytes);
#endif

#if 0   /* distance.xls */
        {
            int iDistance;

            for (iDistance = 0; iDistance < (sizeof(cDistances)/sizeof(cDistances[0])); iDistance++)
            {
                if (cDistances[iDistance] != 0)
                {
                    printf("%9ld   %9ld\n", iDistance, cDistances[iDistance]);
                }
            }
        }
#endif

#if 0   /* rifts */
        {
            long filepos;
            long iLastDisplacement = NO_DISPLACEMENT;

            for (filepos = 0; filepos < FILESIZE; filepos++)
            {
                if (iDisplacement[filepos] != NO_DISPLACEMENT)
                {
                    if (iLastDisplacement != iDisplacement[filepos])
                    {
                        iLastDisplacement = iDisplacement[filepos];

                        printf("%9lu %9ld\n", filepos, iDisplacement[filepos]);
                    }
                }
            }
        }
#endif

#if 0   /* slots */
        {  
            int slot;

            for (slot = 0; slot < MAX_SLOTS; slot++)
            {
                if (cSlotUsed[slot])
                {
                    printf("%5d  %9ld\n", slot, cSlotUsed[slot]);
                }
            }
        }
#endif

#ifdef RIFTGEN2   /* generating faked references for relrifts file */
        {   
            int index;
            REFERENCE *pReference, *pKill;
            int iLast = 0;
            int cEntries = 0;
            int cEntriesHit = 0;
            int iBest;

            for (index = 0; index < FILESIZE; index++)
            {
                pReference = pReferences[index];

                if (isRelocEntry[index])
                {
                    cEntries++;
                }

                if (pReference != NULL)
                {
                    if (isRelocEntry[index])
                    {
                        cEntriesHit++;
                    }

                    if (pReference->pNext != NULL)                  /* multiple values */
                    {
                        /* knowing the number of reloc entries interested could help here */

                        /* see if the last value is one of the choices */

                        while (pReference)
                        {
                            if (pReference->iDisplacement == iLast)
                            {
                                goto found;
                            }

                            pReference = pReference->pNext;
                        }

                        /* choose the value nearest the last value */

                        pReference = pReferences[index];
                        
                        while (pReference != NULL)
                        {
                            if (abs(pReference->iDisplacement - iLast) < abs(iBest - iLast))
                            {
                                iBest = pReference->iDisplacement;
                            }

                            pReference = pReference->pNext;
                        }

                        iLast = iBest;
                        printf("%d %d\n", index, iLast);

found:                  
                        /* now free the list */

                        pReference = pReferences[index];
                        
                        while (pReference != NULL)
                        {
                            pKill = pReference;
                            pReference = pReference->pNext;
                            GlobalFree(pKill);
                        }
                    }
                    else
                    {
                        if (iLast != pReference->iDisplacement)    /* a simple rift */
                        {
                            iLast = pReference->iDisplacement;
                            printf("%d %d\n", index, iLast);
                        }

                        GlobalFree(pReference);
                    }
                }
            }

            //fprintf(stderr, "%d hit of %d total relocation targets\n", cEntriesHit, cEntries);
        }
#endif

        DisplayMatchLog();
    }
#endif

//    MessageBox( NULL, "OK\n", "APATCH Done", MB_OK );

bail:

    return( 0 );

    }

#ifdef TRACING

void TracingSetOldFilePosition(long oldpos)
{
    g_OldFilePosition = oldpos;
}


void TracingLiteral(long bufpos, byte c)
{
#ifdef COMPOSITION   /* composition.xls */
    int iBucket = bufpos / BUCKET_SIZE;

    cBuckets[iBucket][LITERAL]++;
#endif

    g_cLiterals++;

#ifdef DECO_DETAILS   /* trace */
    printf("%08lX: %02X\n", bufpos, (byte) c);
#endif
}


void TracingMatch(long bufpos,long srcpos,long window,int length,int slot)
{
    static long iLastDisplacement = -1;

    g_cMatches++;
    g_cMatchBytes += length;

#if 0   /* slots */
    if (slot < MAX_SLOTS)
    {
        cSlotUsed[slot]++;
    }
    else
    {
        printf("Slot number out of range (%d)\n", slot);
    }
#endif

    if (srcpos < g_OldFilePosition)
    {
#ifdef COMPOSITION   /* composition.xls */
        int iBucket = bufpos / BUCKET_SIZE;
        int eBucket = (bufpos + length - 1) / BUCKET_SIZE;

        if (iBucket == eBucket)
        {
            cBuckets[iBucket][MATCH_NEW] += length;
        }
        else
        {
            long length1 = (eBucket * BUCKET_SIZE) - bufpos;
            cBuckets[iBucket][MATCH_NEW] += length1;
            cBuckets[eBucket][MATCH_NEW] += (length - length1);
        }
#endif

#ifdef DECO_DETAILS   /* trace */
        {
            int iDistance = bufpos - srcpos;

            printf("%08lX..%08lX:  %08lX..%08lX  (%d,%u)\n",  /* new file refs no [...] */
                bufpos,
                bufpos + length - 1,
                srcpos,
                srcpos + length - 1,
                -iDistance,
                length);
        }
#endif

#if 0
        if (iLastDisplacement != (srcpos - bufpos))
        {
            iLastDisplacement = (srcpos - bufpos);

            printf("%9ld %9ld %9ld\n",
                bufpos,
                srcpos,
                srcpos - bufpos);
        }
#endif
    }
    else
    {
#ifdef COMPOSITION   /* composition.xls */
        int iBucket = bufpos / BUCKET_SIZE;
        int eBucket = (bufpos + length - 1) / BUCKET_SIZE;

        if (iBucket == eBucket)
        {
            cBuckets[iBucket][MATCH_OLD] += length;
        }
        else
        {
            long length1 = (eBucket * BUCKET_SIZE) - bufpos;
            cBuckets[iBucket][MATCH_OLD] += length1;
            cBuckets[eBucket][MATCH_OLD] += (length - length1);
        }
#endif

        if ((cMatchLogEntries != 0) &&
            ((MatchLog[cMatchLogEntries - 1].ulNewOffset + MatchLog[cMatchLogEntries - 1].ulMatchLength) == (unsigned long) bufpos) &&
            ((MatchLog[cMatchLogEntries - 1].ulOldOffset + MatchLog[cMatchLogEntries - 1].ulMatchLength) == (unsigned long) (srcpos - g_OldFilePosition)))
        {
            MatchLog[cMatchLogEntries - 1].ulMatchLength += length;
        }
        else if (cMatchLogEntries < MAX_MATCH_LOG_ENTRIES)
        {
            MatchLog[cMatchLogEntries].ulNewOffset = bufpos;
            MatchLog[cMatchLogEntries].ulOldOffset = srcpos - g_OldFilePosition;
            MatchLog[cMatchLogEntries].ulMatchLength = length;
            cMatchLogEntries++;
        }

#ifdef DECO_DETAILS   /* trace */
        {
            int iDistance = bufpos - srcpos + window;

            printf("%08lX..%08lX: [%08lX..%08lX] (%d,%u)\n",  /* old file refs in [...] */
                bufpos,
                bufpos + length - 1,
                srcpos - g_OldFilePosition,
                srcpos - g_OldFilePosition + length - 1,
                -iDistance,
                length);
        }
#endif

#if 0   /* rifts */
        {
            int index;

            for (index = 0; index < length; index++)
            {
                iDisplacement[bufpos + index] = bufpos - srcpos + g_OldFilePosition;
            }
        }
#endif

#if 0
        if (iLastDisplacement != (bufpos - srcpos + g_OldFilePosition))
        {
            iLastDisplacement = (bufpos - srcpos + g_OldFilePosition);

            printf("%9ld %9ld %9ld\n",
                bufpos,
                srcpos - g_OldFilePosition,
                bufpos - srcpos + g_OldFilePosition);
        }
#endif

#ifdef RIFTGEN2   /* references */
        {
            int index;
            REFERENCE *pReference;
            long iOldFilePosition;

            for (index = 0; index < length; index++)
            {
                iOldFilePosition = srcpos - g_OldFilePosition + index;

                if (isRelocEntry[iOldFilePosition])
                {
                    pReference = GlobalAlloc(GMEM_FIXED, sizeof(REFERENCE));

                    pReference->pNext = pReferences[iOldFilePosition];
                    pReferences[iOldFilePosition] = pReference;
                    pReference->iDisplacement = bufpos - srcpos + g_OldFilePosition;
                }
            }
        }
#endif
    }

#if 0   /* distance.xls */
    {
        int iDistance = bufpos - srcpos + window;

        if ((iDistance < 1) || (iDistance >= (sizeof(cDistances)/sizeof(cDistances[0]))))
        {
            printf("That's a strange distance.\n");
        }
        else
        {
            cDistances[iDistance]++;
        }
    }
#endif
}

#ifdef RIFTGEN
void TracingSetIsRelocEntry(ULONG OldFileOffset, ULONG Va)
{
//    printf("offset 0x%08X is Va 0x%08X\n", OldFileOffset, Va);
//      ie, "offset 0x00000DF9 is Va 0x703B17F9" when base=0x703B0000

    isRelocEntry[OldFileOffset] = '\1';
}
#endif


void TracingReportAddresses(int FileNumber, ULONG FileOffset, ULONG Size, ULONG Address)
{
    if ( FileNumber )
    {
        RegionsNew[cRegionsNew].ulRegionOffset = FileOffset;
        RegionsNew[cRegionsNew].ulRegionSize = Size;
        RegionsNew[cRegionsNew].ulRegionAddress = Address;
        cRegionsNew++;
    }
    else
    {
        RegionsOld[cRegionsOld].ulRegionOffset = FileOffset;
        RegionsOld[cRegionsOld].ulRegionSize = Size;
        RegionsOld[cRegionsOld].ulRegionAddress = Address;
        cRegionsOld++;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\mspatchc\makefile.inc ===
DELEXPFILE:
  @if exist ..\..\bin\$(TARGET_DIRECTORY)\mspatchc.exp \
       @del ..\..\bin\$(TARGET_DIRECTORY)\mspatchc.exp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\mpatch\mpatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )
#include <windows.h>
#include <wincrypt.h>
#pragma warning( disable: 4201 )
#include <imagehlp.h>
#pragma warning( disable: 4001 4035 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#include "patchapi.h"
#include "patchprv.h"
#include <ntverp.h>
#include <common.ver>

void CopyRight( void ) {
    printf(
        "\n"
        "MPATCH " VER_PRODUCTVERSION_STR " Patch Creation Utility\n"
        VER_LEGALCOPYRIGHT_STR
        "\n\n"
        );
    }


void Usage( void ) {
    printf(
"Usage:  MPATCH [options] OldFile[;OldFile2[;OldFile3]] NewFile TargetPatchFile\n"
"\n"
"        Options:\n"
"\n"
"          -NOBINDFIX   Turn off automatic compensation for bound imports in\n"
"                       the the old file.  The default is to ignore binding\n"
"                       data in the old file during patch creation which will\n"
"                       cause the application of the patch to succeed whether\n"
"                       or not the old file on the target machine is bound, not\n"
"                       bound, or even bound to different import addresses.\n"
"                       If the files are not Win32 binaries, this option is\n"
"                       ignored and has no effect.\n"
"\n"
"          -NOLOCKFIX   Turn off automatic compensation for smashed lock prefix\n"
"                       instructions.  If the files are not Win32 binaries,\n"
"                       this option is ignored and has no effect.\n"
"\n"
"          -NOREBASE    Turn off automatic internal rebasing of old file to new\n"
"                       file's image base address.  If the files are not Win32\n"
"                       binaries, this option is ignored and has no effect.\n"
"\n"
"          -NORESTIME   Turn off automatic fixup of resource section timestamps\n"
"                       (ignored if not Win32 binaries).\n"
"\n"
"          -NOSTORETIME Don't store the timestamp of the new file in the patch\n"
"                       file.  Instead, set the timestamp of the patch file to\n"
"                       the timestamp of the new file.\n"
"\n"
"          -IGNORE:Offset,Length[,FileNumber]\n"
"\n"
"                       Ignore a range of bytes in the OldFile because those\n"
"                       bytes might be different in the old file being patched\n"
"                       on the target machine.\n"
"\n"
"          -RETAIN:Offset,Length[,OffsetInNewFile[,FileNumber]]\n"
"\n"
"                       When applying the patch, preserve the range of bytes in\n"
"                       the old file and copy them to the new file at the given\n"
"                       OffsetInNewFile.\n"
"\n"
#if 0
"          -RIFTINFO:FileName[,FileNumber]\n"
"\n"
"                       Use rift table information from FileName (produced from\n"
"                       riftinfo.exe).\n"
"\n"
#endif
"          -FAILBIGGER  If patch file is bigger than simple compressed file,\n"
"                       don't create the patch file (takes longer).\n"
"\n"
"          -FAILIFSAME  If old and new files are the same (ignoring binding\n"
"                       differences, etc), don't create the patch file.\n"
"\n"
"          -NOCOMPARE   Don't compare patch compression against ordinary non-\n"
"                       patch compression (saves time).\n"
"\n"
"          -NOPROGRESS  Don't display percent complete while building patch.\n"
"\n"
"          -NEWSYMPATH:PathName[;PathName]\n"
"\n"
"                       For NewFile, search for symbol file(s) in these path\n"
"                       locations (recursive search each path until found).\n"
"                       The default is to search for symbol files(s) starting\n"
"                       in the same directory as the NewFile.\n"
"\n"
"          -OLDSYMPATH:PathName[;PathName][,FileNumber]\n"
"\n"
"                       For OldFile, search for symbol file(s) in these path\n"
"                       locations (recursive search each path until found).\n"
"                       The default is to search for symbol files(s) starting\n"
"                       in the same directory as the OldFile.\n"
"\n"
"          -UNDECORATED After matching decorated symbol names, match remaining\n"
"                       symbols using undecorated names.\n"
"\n"
"          -NOSYMS      Don't use debug symbol files when creating the patch.\n"
"\n"
"          -NOSYMFAIL   Don't fail to create patch if symbols cannot be loaded.\n"
"\n"
"          -NOSYMWARN   Don't warn if symbols can't be found or don't match the\n"
"                       corresponding file (symbol checksum mismatch).\n"
"\n"
"          -USEBADSYMS  Rather than ignoring symbols if the checksums don't\n"
"                       match the corresponding files, use the bad symbols.\n"
"\n"
"          -E8          Force E8 call translation for x86 binaries.\n"
"\n"
"          -NOE8        Force no E8 call translation for x86 binaries.\n"
"\n"
"                       If neither -E8 or -NOE8 are specified, and the files\n"
"                       are x86 binaries, the patch will be built internally\n"
"                       twice and the smaller will be chosen for output.\n"
"\n"
"          -MSPATCH194COMPAT  Assure the patch file can be used with version\n"
"                       1.94 of MSPATCH*.DLL.  May increase size of patch\n"
"                       file if old or new file is larger than 4Mb.\n"
"\n"
"          MPATCH will also look for environment variables named \"MPATCH\"\n"
"          followed by an underscore and the name of the option.  Command line\n"
"          specified options override environment variable options.  Examples:\n"
"\n"
"              MPATCH_NOCOMPARE=1\n"
"              MPATCH_NEWSYMPATH=c:\\winnt\\symbols;\\\\server\\share\\symbols\n"
"\n"
        );
    exit( 1 );
    }


BOOL bNoProgress;
BOOL bNoSymWarn;
BOOL bUseBadSyms;


DWORDLONG
GetFileSizeByName(
    IN LPCSTR FileName
    )
    {
    DWORDLONG FileSizeReturn;
    ULONG     FileSizeHigh;
    ULONG     FileSizeLow;
    HANDLE    hFile;

    FileSizeReturn = 0xFFFFFFFFFFFFFFFF;

    hFile = CreateFile(
                FileName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile != INVALID_HANDLE_VALUE ) {

        FileSizeLow = GetFileSize( hFile, &FileSizeHigh );

        if (( FileSizeLow != 0xFFFFFFFF ) || ( GetLastError() == NO_ERROR )) {

            FileSizeReturn = ((DWORDLONG)FileSizeHigh << 32 ) | FileSizeLow;
            }

        CloseHandle( hFile );
        }

    return FileSizeReturn;
    }


BOOL
GetMpatchEnvironString(
    IN  LPCSTR VarName,
    OUT LPSTR  Buffer,
    IN  DWORD  BufferSize
    )
    {
    CHAR EnvironName[ 256 ];

    sprintf( EnvironName, "mpatch_%s", VarName );

    if ( GetEnvironmentVariable( EnvironName, Buffer, BufferSize )) {

        return TRUE;
        }

    return FALSE;
    }


BOOL
GetMpatchEnvironValue(
    IN  LPCSTR VarName
    )
    {
    CHAR LocalBuffer[ 256 ];

    if ( GetMpatchEnvironString( VarName, LocalBuffer, sizeof( LocalBuffer ))) {

        if (( *LocalBuffer == '0' ) && ( strtoul( LocalBuffer, NULL, 0 ) == 0 )) {
            return FALSE;
            }

        return TRUE;
        }

    return FALSE;
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    UNREFERENCED_PARAMETER( CallbackContext );

    if ( MaximumPosition != 0 ) {
        fprintf( stderr, "\r%3.1f%% complete", ( CurrentPosition * 100.0 ) / MaximumPosition );
        }

    return TRUE;
    }


BOOL
CALLBACK
MySymLoadCallback(
    IN ULONG  WhichFile,
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    )
    {
    LPCSTR *FileNameArray = CallbackContext;
    LPCSTR SymTypeText;

    if (( SymType == SymNone ) || ( SymType == SymExport )) {

        //
        //  Symbols could not be found.
        //

        if ( ! bNoSymWarn ) {

            printf(
                "\n"
                "WARNING: no debug symbols for %s\n\n",
                FileNameArray[ WhichFile ]
                );
            }

        return TRUE;
        }

    //
    //  Note that the Old file checksum is the checksum AFTER normalization,
    //  so if the original .dbg file was updated with bound checksum, the
    //  old file's checksum will not match the symbol file's checksum.  But,
    //  binding a file does not change its TimeDateStamp, so that should be
    //  a valid comparison.  But, .sym files don't have a TimeDateStamp, so
    //  the SymbolFileTimeDate may be zero.  If either the checksums match
    //  or the timedate stamps match, we'll say its valid.
    //

    if (( ImageFileCheckSum == SymbolFileCheckSum ) ||
        ( ImageFileTimeDate == SymbolFileTimeDate )) {

        return TRUE;
        }

    if ( ! bNoSymWarn ) {

        switch ( SymType ) {
            case SymNone:     SymTypeText = "No";       break;
            case SymCoff:     SymTypeText = "Coff";     break;
            case SymCv:       SymTypeText = "CodeView"; break;
            case SymPdb:      SymTypeText = "Pdb";      break;
            case SymExport:   SymTypeText = "Export";   break;
            case SymDeferred: SymTypeText = "Deferred"; break;
            case SymSym:      SymTypeText = "Sym";      break;
            default:          SymTypeText = "Unknown";  break;
            }

        printf(
            "\n"
            "WARNING: %s symbols %s don't match %s:\n"
            "    symbol file checksum (%08X) does not match image (%08X), and\n"
            "    symbol file timedate (%08X) does not match image (%08X).\n\n",
            SymTypeText,
            SymbolFileName,
            FileNameArray[ WhichFile ],
            SymbolFileCheckSum,
            ImageFileCheckSum,
            SymbolFileTimeDate,
            ImageFileTimeDate
            );
        }

    return bUseBadSyms;
    }


PRIFT_TABLE RiftTableArray[ 256 ];
PATCH_OLD_FILE_INFO_A OldFileInfo[ 256 ];
LPSTR OldFileSymPathArray[ 256 ];
LPSTR NewFileSymPath;
LPSTR FileNameArray[ 257 ];

PATCH_OPTION_DATA OptionData = { sizeof( PATCH_OPTION_DATA ) };

CHAR TextBuffer[ 65000 ];

void __cdecl main( int argc, char *argv[] ) {

    LPSTR OldFileName    = NULL;
    LPSTR NewFileName    = NULL;
    LPSTR PatchFileName  = NULL;
    ULONG OptionFlags    = PATCH_OPTION_USE_LZX_BEST | PATCH_OPTION_USE_LZX_LARGE;
    BOOL  Success;
    LPSTR arg;
    LPSTR p, q;
    LPSTR FileName;
    int   i, j, n;
    ULONG OldOffset;
    ULONG NewOffset;
    ULONG Length;
    ULONG FileNum;
    ULONG OldFileCount;
    ULONG ErrorCode;
    ULONG NewFileSize;
    ULONG PatchFileSize;
    ULONG OldFileRva;
    ULONG NewFileRva;
    BOOL  bNoCompare = FALSE;
    FILE  *RiftFile;
    LPSTR FileNamePart;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

#ifdef TESTCODE
    bNoCompare = TRUE;
#endif

    CopyRight();

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }
        }

    //
    //  First get environment arguments because command-line args will
    //  override them.
    //

    if ( GetMpatchEnvironValue( "e8" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
        }

    if ( GetMpatchEnvironValue( "noe8" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
        }

    if ( GetMpatchEnvironValue( "mspatch194compat" )) {
        OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
        }

    if ( GetMpatchEnvironValue( "nobindfix" )) {
        OptionFlags |= PATCH_OPTION_NO_BINDFIX;
        }

    if ( GetMpatchEnvironValue( "nolockfix" )) {
        OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
        }

    if ( GetMpatchEnvironValue( "norebase" )) {
        OptionFlags |= PATCH_OPTION_NO_REBASE;
        }

    if ( GetMpatchEnvironValue( "norestime" )) {
        OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
        }

    if ( GetMpatchEnvironValue( "nostoretime" )) {
        OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
        }

    if ( GetMpatchEnvironValue( "failbigger" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironValue( "failifbigger" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
        }

    if ( GetMpatchEnvironValue( "failsame" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironValue( "failifsame" )) {
        OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
        }

    if ( GetMpatchEnvironValue( "nocompare" )) {
        bNoCompare = TRUE;
        }

    if ( GetMpatchEnvironValue( "noprogress" )) {
        bNoProgress = TRUE;
        }

    if ( GetMpatchEnvironValue( "undecorated" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
        }

    if ( GetMpatchEnvironValue( "nosyms" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
        }

    if ( GetMpatchEnvironValue( "nosymfail" )) {
        OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
        }

    if ( GetMpatchEnvironValue( "nosymwarn" )) {
        bNoSymWarn = TRUE;
        }

    if ( GetMpatchEnvironValue( "usebadsyms" )) {
        bUseBadSyms = TRUE;
        }

    if ( GetMpatchEnvironString( "ignore", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q != NULL ) {

            *q = 0;

            OldOffset = strtoul( p, NULL, 0 );

            p = q + 1;
            q = strchr( p, ',' );

            if ( q ) {
                *q = 0;
                }

            Length = strtoul( p, NULL, 0 );

            FileNum = 1;

            if ( q ) {

                p = q + 1;

                FileNum = strtoul( p, NULL, 0 );

                if ( FileNum == 0 ) {
                    FileNum = 1;
                    }
                }

            if ( FileNum <= 255 ) {

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ) + sizeof( PATCH_IGNORE_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeCount++;

                }
            }
        }

    if ( GetMpatchEnvironString( "retain", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q != NULL ) {

            *q = 0;

            OldOffset = strtoul( p, NULL, 0 );

            p = q + 1;
            q = strchr( p, ',' );

            if ( q ) {
                *q = 0;
                }

            Length = strtoul( p, NULL, 0 );

            NewOffset = OldOffset;

            FileNum = 1;

            if ( q ) {

                p = q + 1;

                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                NewOffset = strtoul( p, NULL, 0 );

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }
                }

            if ( FileNum <= 255 ) {

                OldFileInfo[ FileNum - 1 ].RetainRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ) + sizeof( PATCH_RETAIN_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInNewFile = NewOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].RetainRangeCount++;
                }
            }
        }

    if ( GetMpatchEnvironString( "riftinfo", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum <= 255 ) {

            RiftTableArray[ FileNum - 1 ] = malloc( sizeof( RIFT_TABLE ));

            if ( RiftTableArray[ FileNum - 1 ] == NULL ) {
                printf( "Out of memory\n" );
                exit( 1 );
                }

            RiftTableArray[ FileNum - 1 ]->RiftEntryCount = 0;
            RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = 0;
            RiftTableArray[ FileNum - 1 ]->RiftEntryArray = NULL;
            RiftTableArray[ FileNum - 1 ]->RiftUsageArray = NULL;

            RiftFile = fopen( FileName, "rt" );

            if ( RiftFile == NULL ) {
                printf( "Could not open %s\n", FileName );
                exit( 1 );
                }

            while ( fgets( TextBuffer, sizeof( TextBuffer ), RiftFile )) {

                //
                //  Line looks like "00001456 00002345" where each number
                //  is an RVA in hexadecimal and the first column is the
                //  OldFileRva and the second column is the NewFileRva.
                //  Any text beyond column 17 is considered a comment, and
                //  any line that does not begin with a digit is ignored.
                //

                if (( isxdigit( *TextBuffer )) && ( strlen( TextBuffer ) >= 17 )) {

                    OldFileRva = strtoul( TextBuffer,     NULL, 16 );
                    NewFileRva = strtoul( TextBuffer + 9, NULL, 16 );

                    if (( OldFileRva + NewFileRva ) != 0 ) {

                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray = realloc(
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray,
                            RiftTableArray[ FileNum - 1 ]->RiftEntryCount * sizeof( RIFT_ENTRY ) + sizeof( RIFT_ENTRY )
                            );

                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].OldFileRva = OldFileRva;
                        RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].NewFileRva = NewFileRva;
                        RiftTableArray[ FileNum - 1 ]->RiftEntryCount++;

                        }
                    }
                }

            fclose( RiftFile );

            if ( RiftTableArray[ FileNum - 1 ]->RiftEntryCount ) {

                RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = RiftTableArray[ FileNum - 1 ]->RiftEntryCount;

                RiftTableArray[ FileNum - 1 ]->RiftUsageArray = malloc( RiftTableArray[ FileNum - 1 ]->RiftEntryCount );

                if ( RiftTableArray[ FileNum - 1 ]->RiftUsageArray == NULL ) {
                    printf( "Out of memory\n" );
                    exit( 1 );
                    }

                ZeroMemory( RiftTableArray[ FileNum - 1 ]->RiftUsageArray, RiftTableArray[ FileNum - 1 ]->RiftEntryCount );
                }

            OptionData.SymbolOptionFlags |= PATCH_SYMBOL_EXTERNAL_RIFT;

            }
        }

    if ( GetMpatchEnvironString( "oldsympath", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum <= 255 ) {
            OldFileSymPathArray[ FileNum - 1 ] = _strdup( FileName );
            }
        }

    if ( GetMpatchEnvironString( "newsympath", TextBuffer, sizeof( TextBuffer ))) {

        p = TextBuffer;
        q = strchr( p, ',' );

        if ( q ) {
            *q = 0;
            }

        FileName = p;

        FileNum = 1;

        if ( q ) {

            p = q + 1;

            FileNum = strtoul( p, NULL, 0 );

            if ( FileNum == 0 ) {
                FileNum = 1;
                }
            }

        if ( FileNum == 1 ) {
            NewFileSymPath = _strdup( FileName );
            }
        }

    //
    //  Now process commandline args
    //

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            }

        if (( *arg == '-' ) || ( *arg == '/' )) {

            _strlwr( ++arg );

            if ( strcmp( arg, "e8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_A;
                }
            else if ( strcmp( arg, "noe8" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_B;
                }
            else if ( strcmp( arg, "mspatch194compat" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_USE_LZX_LARGE;
                }
            else if ( strcmp( arg, "nobindfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "bindfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_BINDFIX;
                }
            else if ( strcmp( arg, "nolockfix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "lockfix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_LOCKFIX;
                }
            else if ( strcmp( arg, "norebase" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "rebase" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_REBASE;
                }
            else if ( strcmp( arg, "norestime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "norestimefix" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "restimefix" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_RESTIMEFIX;
                }
            else if ( strcmp( arg, "nostoretime" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "storetime" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_NO_TIMESTAMP;
                }
            else if ( strcmp( arg, "failbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifbigger" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "nofailifbigger" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_BIGGER;
                }
            else if ( strcmp( arg, "failifsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "failsame" ) == 0 ) {
                OptionFlags |= PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailifsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nofailsame" ) == 0 ) {
                OptionFlags &= ~PATCH_OPTION_FAIL_IF_SAME_FILE;
                }
            else if ( strcmp( arg, "nocompare" ) == 0 ) {
                bNoCompare = TRUE;
                }
            else if ( strcmp( arg, "compare" ) == 0 ) {
                bNoCompare = FALSE;
                }
            else if ( strcmp( arg, "noprogress" ) == 0 ) {
                bNoProgress = TRUE;
                }
            else if ( strcmp( arg, "progress" ) == 0 ) {
                bNoProgress = FALSE;
                }
            else if ( strcmp( arg, "decorated" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "undecorated" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_UNDECORATED_TOO;
                }
            else if ( strcmp( arg, "nosyms" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "syms" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_IMAGEHLP;
                }
            else if ( strcmp( arg, "nosymfail" ) == 0 ) {
                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "symfail" ) == 0 ) {
                OptionData.SymbolOptionFlags &= ~PATCH_SYMBOL_NO_FAILURES;
                }
            else if ( strcmp( arg, "nosymwarn" ) == 0 ) {
                bNoSymWarn = TRUE;
                }
            else if ( strcmp( arg, "symwarn" ) == 0 ) {
                bNoSymWarn = FALSE;
                }
            else if ( strcmp( arg, "usebadsyms" ) == 0 ) {
                bUseBadSyms = TRUE;
                }
            else if ( strcmp( arg, "nousebadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( strcmp( arg, "nobadsyms" ) == 0 ) {
                bUseBadSyms = FALSE;
                }
            else if ( memcmp( arg, "ignore:", 7 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q == NULL ) {
                    Usage();
                    }

                *q = 0;

                OldOffset = strtoul( p, NULL, 0 );

                p = q + 1;
                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                Length = strtoul( p, NULL, 0 );

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ) + sizeof( PATCH_IGNORE_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeArray[ OldFileInfo[ FileNum - 1 ].IgnoreRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].IgnoreRangeCount++;

                }
            else if ( memcmp( arg, "retain:", 7 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q == NULL ) {
                    Usage();
                    }

                *q = 0;

                OldOffset = strtoul( p, NULL, 0 );

                p = q + 1;
                q = strchr( p, ',' );

                if ( q ) {
                    *q = 0;
                    }

                Length = strtoul( p, NULL, 0 );

                NewOffset = OldOffset;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    q = strchr( p, ',' );

                    if ( q ) {
                        *q = 0;
                        }

                    NewOffset = strtoul( p, NULL, 0 );

                    if ( q ) {

                        p = q + 1;

                        FileNum = strtoul( p, NULL, 0 );

                        if ( FileNum == 0 ) {
                            FileNum = 1;
                            }
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileInfo[ FileNum - 1 ].RetainRangeArray = realloc(
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeArray,
                                                                  OldFileInfo[ FileNum - 1 ].RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ) + sizeof( PATCH_RETAIN_RANGE )
                                                                  );

                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInOldFile = OldOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].OffsetInNewFile = NewOffset;
                OldFileInfo[ FileNum - 1 ].RetainRangeArray[ OldFileInfo[ FileNum - 1 ].RetainRangeCount ].LengthInBytes   = Length;
                OldFileInfo[ FileNum - 1 ].RetainRangeCount++;

                }

            else if ( memcmp( arg, "riftinfo:", 9 ) == 0 ) {

                OptionData.SymbolOptionFlags |= PATCH_SYMBOL_EXTERNAL_RIFT;

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                RiftTableArray[ FileNum - 1 ] = malloc( sizeof( RIFT_TABLE ));

                if ( RiftTableArray[ FileNum - 1 ] == NULL ) {
                    printf( "Out of memory\n" );
                    exit( 1 );
                    }

                RiftTableArray[ FileNum - 1 ]->RiftEntryCount = 0;
                RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = 0;
                RiftTableArray[ FileNum - 1 ]->RiftEntryArray = NULL;
                RiftTableArray[ FileNum - 1 ]->RiftUsageArray = NULL;

                RiftFile = fopen( FileName, "rt" );

                if ( RiftFile == NULL ) {
                    printf( "Could not open %s\n", FileName );
                    exit( 1 );
                    }

                while ( fgets( TextBuffer, sizeof( TextBuffer ), RiftFile )) {

                    //
                    //  Line looks like "00001456 00002345" where each number
                    //  is an RVA in hexadecimal and the first column is the
                    //  OldFileRva and the second column is the NewFileRva.
                    //  Any text beyond column 17 is considered a comment, and
                    //  any line that does not begin with a digit is ignored.
                    //

                    if (( isxdigit( *TextBuffer )) && ( strlen( TextBuffer ) >= 17 )) {

                        OldFileRva = strtoul( TextBuffer,     NULL, 16 );
                        NewFileRva = strtoul( TextBuffer + 9, NULL, 16 );

                        if (( OldFileRva + NewFileRva ) != 0 ) {

                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray = realloc(
                                RiftTableArray[ FileNum - 1 ]->RiftEntryArray,
                                RiftTableArray[ FileNum - 1 ]->RiftEntryCount * sizeof( RIFT_ENTRY ) + sizeof( RIFT_ENTRY )
                                );

                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].OldFileRva = OldFileRva;
                            RiftTableArray[ FileNum - 1 ]->RiftEntryArray[ RiftTableArray[ FileNum - 1 ]->RiftEntryCount ].NewFileRva = NewFileRva;
                            RiftTableArray[ FileNum - 1 ]->RiftEntryCount++;

                            }
                        }
                    }

                fclose( RiftFile );

                if ( RiftTableArray[ FileNum - 1 ]->RiftEntryCount ) {

                    RiftTableArray[ FileNum - 1 ]->RiftEntryAlloc = RiftTableArray[ FileNum - 1 ]->RiftEntryCount;

                    RiftTableArray[ FileNum - 1 ]->RiftUsageArray = malloc( RiftTableArray[ FileNum - 1 ]->RiftEntryCount );

                    if ( RiftTableArray[ FileNum - 1 ]->RiftUsageArray == NULL ) {
                        printf( "Out of memory\n" );
                        exit( 1 );
                        }

                    ZeroMemory( RiftTableArray[ FileNum - 1 ]->RiftUsageArray, RiftTableArray[ FileNum - 1 ]->RiftEntryCount );
                    }
                }
            else if ( memcmp( arg, "oldsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum > 255 ) {
                    Usage();
                    }

                OldFileSymPathArray[ FileNum - 1 ] = _strdup( FileName );
                }
            else if ( memcmp( arg, "newsympath:", 11 ) == 0 ) {

                p = strchr( arg, ':' ) + 1;
                q = strchr( p,   ',' );

                if ( q ) {
                    *q = 0;
                    }

                FileName = p;

                FileNum = 1;

                if ( q ) {

                    p = q + 1;

                    FileNum = strtoul( p, NULL, 0 );

                    if ( FileNum == 0 ) {
                        FileNum = 1;
                        }
                    }

                if ( FileNum != 1 ) {
                    Usage();
                    }

                NewFileSymPath = _strdup( FileName );
                }
            else {
                Usage();
                }
            }

        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else {
            Usage();
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        }

    OldFileCount = 0;

    p = OldFileName;

    q = strchr( OldFileName, ';' );

    while ( q ) {

        *q = 0;

        if ( *p ) {
            OldFileInfo[ OldFileCount ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_A );
            OldFileInfo[ OldFileCount ].OldFileName = p;
            OldFileCount++;
            }

        p = q + 1;
        q = strchr( p, ';' );

        }

    if ( *p ) {
        OldFileInfo[ OldFileCount ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_A );
        OldFileInfo[ OldFileCount ].OldFileName = p;
        OldFileCount++;
        }

    //
    //  Make sure rift tables are ascending and don't contain duplicate
    //  OldRva values (ambiguous).
    //

    for ( i = 0; i < (int)OldFileCount; i++ ) {

        if (( RiftTableArray[ i ] ) && ( RiftTableArray[ i ]->RiftEntryCount > 1 )) {

            n = RiftTableArray[ i ]->RiftEntryCount - 1;

            RiftQsort( &RiftTableArray[ i ]->RiftEntryArray[ 0 ], &RiftTableArray[ i ]->RiftEntryArray[ n ] );

#ifdef TESTCODE

            for ( j = 0; j < n; j++ ) {
                if ( RiftTableArray[ i ]->RiftEntryArray[ j     ].OldFileRva >
                     RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva ) {

                    printf( "\nRift sort failed at index %d of %d\n", j, n + 1 );

                    for ( j = 0; j <= n; j++ ) {
                        printf( "%08X\n", RiftTableArray[ i ]->RiftEntryArray[ j ].OldFileRva );
                        }

                    exit( 1 );
                    break;
                    }
                }

#endif // TESTCODE

            for ( j = 0; j < n; j++ ) {

                while (( j < n ) &&
                       ( RiftTableArray[ i ]->RiftEntryArray[ j     ].OldFileRva ==
                         RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva )) {

                    if ( RiftTableArray[ i ]->RiftEntryArray[ j     ].NewFileRva !=
                         RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].NewFileRva ) {

                        //
                        //  This is an ambiguous entry since the OldRva values
                        //  match but the NewRva values do not.  Report and
                        //  discard the former.
                        //

                        printf(
                            "RiftInfo for %s contains ambiguous entries:\n"
                            "    OldRva:%08X NewRva:%08X (discarded)\n"
                            "    OldRva:%08X NewRva:%08X (kept)\n\n",
                            OldFileInfo[ i ].OldFileName,
                            RiftTableArray[ i ]->RiftEntryArray[ j ].OldFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j ].NewFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].OldFileRva,
                            RiftTableArray[ i ]->RiftEntryArray[ j + 1 ].NewFileRva
                            );
                        }

                    else {

                        //
                        //  This is a completely duplicate entry, so just
                        //  silently remove it.
                        //

                        }

                    MoveMemory(
                        &RiftTableArray[ i ]->RiftEntryArray[ j ],
                        &RiftTableArray[ i ]->RiftEntryArray[ j + 1 ],
                        ( n - j ) * sizeof( RIFT_ENTRY )
                        );

                    --n;

                    }
                }

            RiftTableArray[ i ]->RiftEntryCount = n + 1;

            }
        }

    for ( i = 0; i < (int)OldFileCount; i++ ) {

        if ( OldFileSymPathArray[ i ] == NULL ) {

            GetFullPathName( OldFileInfo[ i ].OldFileName, sizeof( TextBuffer ), TextBuffer, &FileNamePart );

            if (( FileNamePart > TextBuffer ) && ( *( FileNamePart - 1 ) == '\\' )) {
                *( FileNamePart - 1 ) = 0;
                }

            OldFileSymPathArray[ i ] = _strdup( TextBuffer );
            }
        }

    if ( NewFileSymPath == NULL ) {

        GetFullPathName( NewFileName, sizeof( TextBuffer ), TextBuffer, &FileNamePart );

        if (( FileNamePart > TextBuffer ) && ( *( FileNamePart - 1 ) == '\\' )) {
            *( FileNamePart - 1 ) = 0;
            }

        NewFileSymPath = _strdup( TextBuffer );
        }

    OptionData.NewFileSymbolPath      = NewFileSymPath;
    OptionData.OldFileSymbolPathArray = OldFileSymPathArray;

    if ( OptionData.SymbolOptionFlags & PATCH_SYMBOL_EXTERNAL_RIFT ) {
        OptionData.OldFileSymbolPathArray = (PVOID)RiftTableArray;
        }

    OptionData.SymLoadCallback = MySymLoadCallback;
    OptionData.SymLoadContext  = FileNameArray;

    FileNameArray[ 0 ] = (LPSTR)NewFileName;

    for ( i = 0; i < (int)OldFileCount; i++ ) {
        FileNameArray[ i + 1 ] = (LPSTR)OldFileInfo[ i ].OldFileName;
        }

    Success = CreatePatchFileEx(
                  OldFileCount,
                  OldFileInfo,
                  NewFileName,
                  PatchFileName,
                  OptionFlags,
                  &OptionData,
                  bNoProgress ? NULL : MyProgressCallback,
                  NULL
                  );

    ErrorCode = GetLastError();

    printf( "\n\n" );

    if ( ! Success ) {

        CHAR ErrorText[ 16 ];

        sprintf( ErrorText, ( ErrorCode < 0x10000000 ) ? "%d" : "%X", ErrorCode );

        printf( "Failed to create patch (%s)\n", ErrorText );

        exit( 1 );
        }

    NewFileSize   = (ULONG) GetFileSizeByName( NewFileName );
    PatchFileSize = (ULONG) GetFileSizeByName( PatchFileName );

    if (( NewFileSize != 0xFFFFFFFF ) && ( NewFileSize != 0 ) && ( PatchFileSize != 0xFFFFFFFF )) {

        printf( "%d bytes (%3.1f%% compression, %.1f:1)\n",
                PatchFileSize,
                ((((LONG)NewFileSize - (LONG)PatchFileSize ) * 100.0 ) / NewFileSize ),
                ((double)NewFileSize / PatchFileSize )
              );

        if ( ! bNoCompare ) {

            CHAR TempFile1[ MAX_PATH ];
            CHAR TempFile2[ MAX_PATH ];
            HANDLE hFile;

            GetTempPath( MAX_PATH, TempFile1 );
            GetTempPath( MAX_PATH, TempFile2 );
            strcat( TempFile1, "\\tt$$src.$$$" );
            strcat( TempFile2, "\\tt$$pat.$$$" );

            hFile = CreateFile(
                        TempFile1,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_TEMPORARY,
                        NULL
                        );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                CloseHandle( hFile );

                Success = CreatePatchFile(
                              TempFile1,
                              NewFileName,
                              TempFile2,
                              OptionFlags & ~PATCH_OPTION_FAIL_IF_BIGGER,
                              NULL
                              );

                if ( Success ) {

                    ULONG CompFileSize = (ULONG) GetFileSizeByName( TempFile2 );

                    if (( CompFileSize != 0xFFFFFFFF ) && ( CompFileSize != 0 )) {

                        if ( CompFileSize <= PatchFileSize ) {

                            printf( "\nWARNING: Simply compressing %s would be %d bytes smaller (%3.1f%%)\n",
                                    NewFileName,
                                    PatchFileSize - CompFileSize,
                                    ((((LONG)PatchFileSize - (LONG)CompFileSize ) * 100.0 ) / CompFileSize )
                                  );
                            }

                        else if ( NewFileSize != 0 ) {

                            printf( "\n%d bytes saved (%3.1f%%) over non-patching compression\n",
                                    CompFileSize - PatchFileSize,
                                    ((((LONG)CompFileSize - (LONG)PatchFileSize ) * 100.0 ) / NewFileSize )
                                  );
                            }
                        }
                    }
                }

            DeleteFile( TempFile1 );
            DeleteFile( TempFile2 );
            }
        }

    else {
        printf( "OK\n" );
        }

    exit( 0 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\apatch\makefile.inc ===
EXENAME=apatch.exe
PDBNAME=apatch.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\wpatch\makefile.inc ===
EXENAME=wpatch.exe
PDBNAME=wpatch.pdb

COPYTOBIN:
  @if exist obj\$(TARGET_DIRECTORY)\$(EXENAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(EXENAME) ..\..\..\bin\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(PDBNAME) \
      @copy obj\$(TARGET_DIRECTORY)\$(PDBNAME) ..\..\..\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\wpatch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wpatch.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\wpatch\wpatchid.h ===
#define DLG_PROGRESS    101
#define IDC_PROGRESS    102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\common\typedefs.h ===
/*
 * typedefs.h
 *
 * Type definitions for LZX
 */
#ifndef _TYPEDEFS_H

    #define _TYPEDEFS_H

/*
 * Definitions for LZX
 */
typedef unsigned char   byte;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;

typedef enum
    {
    false = 0,
    true = 1
    } bool;


/*
 * Definitions for Diamond/CAB memory allocation
 */
typedef unsigned char   BYTE;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned int    UINT;


//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef PVOID
typedef void * PVOID;
#endif

#ifndef HANDLE
typedef PVOID HANDLE;
#endif


typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );


#endif /* _TYPEDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decalign.c ===
/*
 * decalign.c
 *
 * Decoding aligned offset block
 */
#include "decoder.h"


static long special_decode_aligned_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   temp_pos;
    long    bufpos_end;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    char    dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte   *dec_mem_window;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf                = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = bufpos + amount_to_decode;

    while (bufpos < bufpos_end)
        {
        /*
         * Decode an item
         */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {
#ifdef TRACING
            TracingLiteral(bufpos, (byte) c);
#endif
            dec_mem_window[bufpos] = (byte) c;
            dec_mem_window[context->dec_window_size + bufpos] = (byte) c;
            bufpos++;
            }
        else
            {
            /*
             * Get match length slot
             */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /*
             * Get match position slot
             */
            m = c >> NL_SHIFT;

            if (m > 2)
                {
                if (dec_extra_bits[ m ] >= 3)
                    {
                    if (dec_extra_bits[m]-3)
                        {
                        /* no need to getbits17 */
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
                        }
                    else
                        {
                        temp_pos = 0;
                        }

                    match_pos = MP_POS_minus2[m] + (temp_pos << 3);

                    DECODE_ALIGNED_NOEOFCHECK(temp_pos);
                    match_pos += temp_pos;
                    }
                else
                    {
                    if (dec_extra_bits[m])
                        {
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

                        match_pos += MP_POS_minus2[m];
                        }
                    else
                        {
                        match_pos = 1; // MP_POS_minus2[m==3];
                        }
                    }

                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            match_length += MIN_MATCH;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  Fetch extra match length in addition to MAX_MATCH, which
                //  is encoded like this:
                //
                //      0xxxxxxxx          (8-bit value)
                //      10xxxxxxxxxx       (10-bit value plus 2^8)
                //      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
                //      111xxxxxxxxxxxxxxx (15-bit value)
                //
                //  15 bits is the largest possible because a match cannot
                //  span a 32K boundary.
                //
                //  We know we'll read at least 9 bits, so read 9 bits first
                //  and then determine how many additional to read based on
                //  the first 3 bits of that.
                //

                ULONG ExtraMatchLength;
                ULONG ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {

                            //
                            //  First 3 bits are '111', so that means remaining
                            //  6 bits are the first 6 bits of the 15 bit value
                            //  meaning we must read 9 more bits.
                            //

                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }

                        else {

                            //
                            //  First 3 bits are '110', so that means remaining
                            //  6 bits are the first 6 bits of the 12 bit value
                            //  meaning we must read 6 more bits.  Then we add
                            //  2^8 plus 2^10 to the value.
                            //

                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }

                    else {

                        //
                        //  First 2 bits are '10', so that means remaining
                        //  7 bits are the first 7 bits of the 10 bit value
                        //  meaning we must read 3 more bits.  Then we add
                        //  2^8 to the value.
                        //

                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                else {

                    //
                    //  First bit is a '0', so that means remaining 8 bits are
                    //  the 8 bit value to add to the match length.  No need to
                    //  mask off the leading '0'.
                    //

                    }

                match_length += ExtraMatchLength;

                }

#endif

#ifdef TRACING
            TracingMatch(bufpos,
                         bufpos-match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            do
                {
                dec_mem_window[bufpos] = dec_mem_window[(bufpos-match_pos) & context->dec_window_mask];

                if (bufpos < MAX_MATCH)
                    dec_mem_window[context->dec_window_size+bufpos] = dec_mem_window[bufpos];

                bufpos++;
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf               = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    return bufpos;
}


#ifndef ASM_DECODE_ALIGNED_OFFSET_BLOCK
long fast_decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
    ulong   match_pos;
    ulong   temp_pos;
    long    bufpos_end;
    long    decode_residue;
    int             match_length;
    int             c;
    ulong   dec_bitbuf;
    char    dec_bitcount;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
    byte   *dec_mem_window;
    ulong   match_ptr;
    ulong   m;

    /*
     * Store commonly used variables locally
     */
    dec_bitcount      = context->dec_bitcount;
    dec_bitbuf        = context->dec_bitbuf;
    dec_input_curpos  = context->dec_input_curpos;
    dec_end_input_pos = context->dec_end_input_pos;
    dec_mem_window    = context->dec_mem_window;

    bufpos_end = bufpos + amount_to_decode;

    while (bufpos < bufpos_end)
        {
        /*
         * Decode an item
         */
        DECODE_MAIN_TREE(c);

        if ((c -= NUM_CHARS) < 0)
            {

#ifdef TRACING
            TracingLiteral(bufpos, (byte) c);
#endif

            dec_mem_window[bufpos++] = (byte) c;
            }
        else
            {
            /*
             * Get match length slot
             */
            if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
                {
                DECODE_LEN_TREE_NOEOFCHECK(match_length);
                }

            /*
             * Get match position slot
             */
            m = c >> NL_SHIFT;

            if (m > 2)
                {
                if (dec_extra_bits[ m ] >= 3)
                    {
                    if (dec_extra_bits[m]-3)
                        {
                        /* no need to getbits17 */
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
                        }
                    else
                        {
                        temp_pos = 0;
                        }

                    match_pos = MP_POS_minus2[m] + (temp_pos << 3);

                    DECODE_ALIGNED_NOEOFCHECK(temp_pos);
                    match_pos += temp_pos;
                    }
                else
                    {
                    if (dec_extra_bits[m])
                        {
                        GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

                        match_pos += MP_POS_minus2[m];
                        }
                    else
                        {
                        match_pos = MP_POS_minus2[m];
                        }
                    }

                context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
                context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
                context->dec_last_matchpos_offset[0] = match_pos;
                }
            else
                {
                match_pos = context->dec_last_matchpos_offset[m];

                if (m)
                    {
                    context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
                    context->dec_last_matchpos_offset[0] = match_pos;
                    }
                }

            match_length += MIN_MATCH;
            match_ptr = (bufpos - match_pos) & context->dec_window_mask;

#ifdef EXTRALONGMATCHES

            if ( match_length == MAX_MATCH ) {

                //
                //  See detailed explanation above.
                //

                ULONG ExtraMatchLength, ExtraMatchLengthResidue;

                GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

                if ( ExtraMatchLength & ( 1 << 8 )) {
                    if ( ExtraMatchLength & ( 1 << 7 )) {
                        if ( ExtraMatchLength & ( 1 << 6 )) {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
                            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            }
                        else {
                            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
                            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
                            ExtraMatchLength |= ExtraMatchLengthResidue;
                            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
                            }
                        }
                    else {
                        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
                        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
                        ExtraMatchLength |= ExtraMatchLengthResidue;
                        ExtraMatchLength += ( 1 << 8 );
                        }
                    }

                match_length += ExtraMatchLength;
                }

#endif

#ifdef TRACING
            TracingMatch(bufpos,
                         bufpos - match_pos,
                         context->dec_window_size,
                         match_length,
                         m);
#endif

            do
                {
                dec_mem_window[bufpos++] = dec_mem_window[match_ptr++];
                } while (--match_length > 0);
            }
        }

    context->dec_bitcount     = dec_bitcount;
    context->dec_bitbuf       = dec_bitbuf;
    context->dec_input_curpos = dec_input_curpos;

    /* should be zero */
    decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
    context->dec_bufpos = bufpos;

    return decode_residue;
}
#endif


int decode_aligned_offset_block(
                               t_decoder_context * context,
                               long                BufPos,
                               int                 amount_to_decode
                               )
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
        {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_aligned_block(
                                                 context,
                                                 BufPos,
                                                 amount_to_slowly_decode
                                                 );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
        }

    return fast_decode_aligned_offset_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\api\samples\wpatch\wpatch.c ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#ifndef WIN32
#define WIN32 0x0400
#endif

#pragma warning( disable: 4001 4035 4100 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <windows.h>

#pragma warning( disable: 4001 4035 4100 4115 4200 4201 4204 4209 4214 4514 4699 )

#include <commctrl.h>
#include "wpatchid.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "patchapi.h"
#include "patchprv.h"

#include <ntverp.h>
#include <common.ver>

typedef struct {
    HWND hwndProgress;
    int iPercentLast;
    } CALLBACK_CONTEXT;


void Usage( void ) {
    MessageBox( NULL,
        "WPATCH " VER_PRODUCTVERSION_STR " Patch Application Utility\n"
        VER_LEGALCOPYRIGHT_STR
        "\n\n"
        "Usage:  WPATCH PatchFile OldFile TargetNewFile",
        "Patch Application Utility",
        MB_OK
        );
    }


BOOL
CALLBACK
MyProgressCallback(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    )
    {
    int iPercent;
    MSG msg;
    CALLBACK_CONTEXT *pContext = CallbackContext;

    if (pContext->hwndProgress != NULL) {

        if ( CurrentPosition & 0xFF000000 ) {
            CurrentPosition >>= 8;
            MaximumPosition >>= 8;
            }

        if ( MaximumPosition != 0 ) {

            iPercent = ( CurrentPosition * 100 ) / MaximumPosition;

            if (pContext->iPercentLast != iPercent) {

                pContext->iPercentLast = iPercent;

                SendDlgItemMessage(pContext->hwndProgress, IDC_PROGRESS, PBM_SETPOS,
                    iPercent, 0);

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        DispatchMessage(&msg);
                    }
                }
            }
        }

    return TRUE;
    }


INT_PTR CALLBACK ProgressWndProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 99));
            EnableMenuItem(GetSystemMenu(hdlg, FALSE), SC_CLOSE, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
            return TRUE;
    }

    return 0;
}


int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nShowCmd)
{
    char *pchCommand;
    char *argv[50];
    int argc;
    enum { WHITESPACE, UNQUOTED, QUOTED } eState = WHITESPACE;
    LPSTR OldFileName   = NULL;
    LPSTR PatchFileName = NULL;
    LPSTR NewFileName   = NULL;
    BOOL  Success;
    LPSTR arg;
    int   i;
    int   rc;
    CALLBACK_CONTEXT Context;
    int   fWaitOnError = TRUE;

    SetErrorMode( SEM_FAILCRITICALERRORS );

#ifndef DEBUG
    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | SEM_FAILCRITICALERRORS );
#endif

    Context.hwndProgress = NULL;
    Context.iPercentLast = -1;

    pchCommand = _strdup(lpCmdLine);    /* work on a copy */

    argv[0] = "";                       /* no EXE name supplied */
    argc = 1;                           /* that was one */

    while (*pchCommand)                 /* walk the string */
    {
        switch (eState)
        {

        case WHITESPACE:
            if (*pchCommand <= ' ')
            {
                /* ignore it */
            }
            else if (*pchCommand == '\"')
            {
                argv[argc++] = pchCommand + 1;  /* skip quote */

                eState = QUOTED;
            }
            else
            {
                argv[argc++] = pchCommand;

                eState = UNQUOTED;
            }
            break;

        case UNQUOTED:
            if (*pchCommand <= ' ')
            {
                *pchCommand = '\0';      /* nul-terminate */

                eState = WHITESPACE;
            }
            else
            {
                /* keep moving up */
            }
            break;

        case QUOTED:
            if (*pchCommand == '\"')
            {
                *pchCommand = '\0';      /* turn quote to a nul */

                eState = WHITESPACE;
            }
            else
            {
                /* keep moving up */
            }
            break;
        }

        pchCommand++;
    }

    argv[argc] = NULL;                  /* NULL-terminate the list */

    for ( i = 1; i < argc; i++ ) {

        arg = argv[ i ];

        if ( strchr( arg, '?' )) {
            Usage();
            rc = 1;
            goto bail;
            }

        if ( lstrcmpi( arg, "-QUIET" ) == 0) {
            nShowCmd = SW_HIDE;
            }
        else if ( lstrcmpi( arg, "-NOWAIT" ) == 0) {
            fWaitOnError = FALSE;
            }
        else if ( PatchFileName == NULL ) {
            PatchFileName = arg;
            }
        else if ( OldFileName == NULL ) {
            OldFileName = arg;
            }
        else if ( NewFileName == NULL ) {
            NewFileName = arg;
            }
        else {
            Usage();
            rc = 1;
            goto bail;
            }
        }

    if (( OldFileName == NULL ) || ( NewFileName == NULL ) || ( PatchFileName == NULL )) {
        Usage();
        rc = 1;
        goto bail;
        }

    if (nShowCmd != SW_HIDE) {
        InitCommonControls();

        Context.hwndProgress = CreateDialog(hInstance,
                MAKEINTRESOURCE(DLG_PROGRESS), NULL, ProgressWndProc);

        ShowWindow( Context.hwndProgress, nShowCmd );   // might be ignored per spec
        ShowWindow( Context.hwndProgress, nShowCmd );   // won't be ignored
        }

    DeleteFile( NewFileName );

    Success = ApplyPatchToFileEx(
                  PatchFileName,
                  OldFileName,
                  NewFileName,
                  0,
                  MyProgressCallback,
                  &Context
                  );

    if (Context.hwndProgress != NULL)
    {
        DestroyWindow(Context.hwndProgress);
    }

    if ( ! Success ) {

        if (fWaitOnError) {
            CHAR  ErrorText[ 100 ];
            ULONG ErrorCode = GetLastError();

            wsprintf( ErrorText, "Failed to create file from patch (%X)", ErrorCode );

            MessageBox(NULL,
                ErrorText,
                "WPATCH Failed",
                MB_ICONERROR | MB_SYSTEMMODAL);
            }

        rc = 2;
        goto bail;
        }

    rc = 0;

bail:

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\common\compdefs.h ===
/*
 * common/compdefs.h
 *
 * Definitions for both encoder and decoder
 */

/*
 * Smallest allowable match length 
 */
#define MIN_MATCH 2

/* 
 * Maximum match length 
 */
#define MAX_MATCH (MIN_MATCH+255)

/*
 * Number of uncompressed symbols 
 */
#define NUM_CHARS 256

/*
 * Number of match lengths which are correlated with match positions 
 */
#define NUM_PRIMARY_LENGTHS     7

/*
 * Primary lengths plus the extension code
 */
#define NUM_LENGTHS             (NUM_PRIMARY_LENGTHS+1)

/*
 * Equals number of different possible match lengths minus primary lengths 
 */
#define NUM_SECONDARY_LENGTHS   ((MAX_MATCH-MIN_MATCH+1)-NUM_PRIMARY_LENGTHS)

/* NL_SHIFT = log2(NUM_LENGTHS) */
#define NL_SHIFT                3

/*
 * Number of repeated offsets 
 */
#define NUM_REPEATED_OFFSETS    3

/*
 * Number of elements in the aligned offset tree
 */
#define ALIGNED_NUM_ELEMENTS 8


/*
 * Repeat codes for outputting trees
 */

/* Minimum number of repetitions of anything we're interested in */
#define TREE_ENC_REP_MIN                4

/* Maximum repetitions for "type A" repetition of zeroes */
/* (min...min+REP_ZERO_FIRST) */
#define TREE_ENC_REP_ZERO_FIRST        16

/* Maximum repetitions for "type B" repetition of zeroes */
/* (min+REP_ZERO_FIRST...min+REP_ZERO_FIRST+REP_ZERO_SECOND) */
#define TREE_ENC_REP_ZERO_SECOND       32

/* Maximum repetitions for "type C" repetition of anything */
/* (min...min_REP_SAME_FIRST) */
#define TREE_ENC_REP_SAME_FIRST         2

/* Bits required to output the above numbers */
#define TREE_ENC_REPZ_FIRST_EXTRA_BITS  4
#define TREE_ENC_REPZ_SECOND_EXTRA_BITS 5
#define TREE_ENC_REP_SAME_EXTRA_BITS    1

/* Number of cfdata frames before E8's are turned off automatically */
#define E8_CFDATA_FRAME_THRESHOLD       32768


/*
 * Block types 
 */
typedef enum
{
		BLOCKTYPE_INVALID       = 0,
		BLOCKTYPE_VERBATIM      = 1, /* normal block */
		BLOCKTYPE_ALIGNED       = 2, /* aligned offset block */
		BLOCKTYPE_UNCOMPRESSED  = 3  /* uncompressed block */
} lzx_block_type;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decapi.h ===
/*
 * decapi.h
 *
 * Decoder API definitions
 */

bool __stdcall LZX_DecodeInit(
                  t_decoder_context **dec_context,
                  long                compression_window_size,
                  PFNALLOC            pfnma,
                  HANDLE              hAllocator
                  );

void __fastcall LZX_DecodeNewGroup(t_decoder_context *context);

int __stdcall LZX_Decode(
        t_decoder_context *context,
        long    bytes_to_decode,
        byte *  compressed_input_buffer,
        long    compressed_input_size,
        byte *  uncompressed_output_buffer,
        long    uncompressed_output_size,
        long *  bytes_decoded
        );

bool __fastcall LZX_DecodeInsertDictionary(
    t_decoder_context *context,
    const byte *       data,
    unsigned long      data_size
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decdefs.h ===
/*
 * decdefs.h
 *
 * Structures and definitions used by the decoder
 */


typedef enum
{
	DEC_STATE_UNKNOWN,
	DEC_STATE_START_NEW_BLOCK,
	DEC_STATE_DECODING_DATA
} decoder_state;


/*
 * Size of uncompressed data chunks
 */
#define CHUNK_SIZE  32768


/*
 * Main tree decoding table parameters 
 */

/* # elements in main tree */
#define MAIN_TREE_ELEMENTS			(NUM_CHARS+(context->dec_num_position_slots<<NL_SHIFT))

/*
 * Decoding table size allows a direct lookup on the first 
 * MAIN_TREE_TABLE_BITS bits of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define MAIN_TREE_TABLE_BITS		10 

/*
 * Secondary length tree decoding table parameters
 * Decoding table size allows a direct lookup on the first
 * SECONDARY_LEN_TREE_TABLE_BITS of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define SECONDARY_LEN_TREE_TABLE_BITS	8 

/* 
 * Aligned offset tree decoding table parameters 
 */
#define ALIGNED_NUM_ELEMENTS	8

/*
 * Must be 7, since we do not use left/right for this tree;
 * everything is decoded in one lookup.
 */
#define ALIGNED_TABLE_BITS		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decapi.c ===
/*
 * decapi.c
 *
 * API entry points.
 */

#define ALLOC_VARS
#include "decoder.h"
#include <stdio.h>

#include <memory.h>
#pragma intrinsic(memcpy)

bool __stdcall LZX_DecodeInit(
                  t_decoder_context **dec_context,
                  long                compression_window_size,
                  PFNALLOC            pfnma,
                  HANDLE              hAllocator
                  )
{
    t_decoder_context *context= pfnma( hAllocator, sizeof( t_decoder_context ));

    if ( context == NULL ) {
        return false;
        }

    *dec_context = context;

    context->dec_malloc       = pfnma;
    context->dec_mallochandle = hAllocator;

    context->dec_window_size = compression_window_size;
    context->dec_window_mask = context->dec_window_size - 1;

    /*
     * Window size must be a power of 2
     */
    if (context->dec_window_size & context->dec_window_mask)
        return false;

    if (allocate_decompression_memory(context) == false)
        return false;

    LZX_DecodeNewGroup(context);

    return true;
}


void __fastcall LZX_DecodeNewGroup(t_decoder_context *context)
{
    reset_decoder_trees(context);
    decoder_misc_init(context);
    init_decoder_translation(context);
    context->dec_num_cfdata_frames = 0;

}


int __stdcall LZX_Decode(
              t_decoder_context *context,
              long    bytes_to_decode,
              byte *  compressed_input_buffer,
              long    compressed_input_size,
              byte *  uncompressed_output_buffer,
              long    uncompressed_output_size,
              long *  bytes_decoded
              )
{
    long    result;

    context->dec_input_curpos   = compressed_input_buffer;
    context->dec_end_input_pos  = (compressed_input_buffer + compressed_input_size + 4);

    context->dec_output_buffer  = uncompressed_output_buffer;

    init_decoder_input(context);

    result = decode_data(context, bytes_to_decode);

    context->dec_num_cfdata_frames++;

    if (result < 0)
        {
        *bytes_decoded = 0;
        return 1; /* failure */
        }
    else
        {
        *bytes_decoded = result;
        context->dec_position_at_start += result;
        return 0; /* success */
        }
}


//
// Warning, this dictionary is inserted verbatim, and is not E8
// translated.  If the encoder did E8 translation on its preloaded
// dictionary, this won't work.
//

#ifdef TRACING
ulong TracingOldDataSize;
#endif

#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))

bool __fastcall LZX_DecodeInsertDictionary(
                               t_decoder_context * context,
                               const byte *        data,
                               unsigned long       data_size
                               )
{
    if (data_size > context->dec_window_size)
        return false;

#ifdef TRACING
    TracingOldDataSize = context->dec_window_size + ROUNDUP2( data_size, CHUNK_SIZE );
#endif

    memcpy(
          &context->dec_mem_window[context->dec_window_size - data_size],
          data,
          data_size
          );

    return true;
}


#ifdef TRACING


void
__stdcall
TracingMatch(
    ulong BufPos,
    ulong MatchPos,
    ulong WindowSize,
    ulong MatchLength,
    ulong MatchPosSlot
    )
    {
    printf( "MATCH: At %08X, From %08X, Length %5d\n", BufPos + TracingOldDataSize, MatchPos + TracingOldDataSize, MatchLength );
    }


void
__stdcall
TracingLiteral(
    ulong BufPos,
    ulong ch
    )
    {
    printf( "LITER: At %08X, 0x%02X\n", BufPos + TracingOldDataSize, ch );
    }


#endif /* TRACING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decin.c ===
/*
 * decin.c
 *
 * Decoder inputting of compressed data
 */
#include "decoder.h"


/*
 * Initialises the bit buffer state
 */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context)
{
    byte *p;

    /*
     * If we're decoding an uncompressed block, don't use the
     * bit buffer; we're reading directly out of the input.
     */
    if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
        return;

    if ((context->dec_input_curpos + sizeof(ulong)) > context->dec_end_input_pos)
        return;

    p = context->dec_input_curpos;

    context->dec_bitbuf =
    ((ulong) p[2] | (((ulong) p[3]) << 8)) |
    ((((ulong) p[0] | (((ulong) p[1]) << 8))) << 16);

    context->dec_bitcount = 16;
    context->dec_input_curpos += 4;
}


/*
 * Initialise input buffer and bitwise i/o
 */
void NEAR init_decoder_input(t_decoder_context *context)
{
    initialise_decoder_bitbuf(context);
}


void NEAR fillbuf(t_decoder_context *context, int n)
{
    context->dec_bitbuf <<= n;
    context->dec_bitcount -= (char)n;

    if (context->dec_bitcount <= 0)
        {
        if (context->dec_input_curpos >= context->dec_end_input_pos)
            {
            context->dec_error_condition = true;
            return;
            }

        context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
        context->dec_input_curpos += 2;
        context->dec_bitcount += 16;

        if (context->dec_bitcount <= 0)
            {
            if (context->dec_input_curpos >= context->dec_end_input_pos)
                {
                context->dec_error_condition = true;
                return;
                }

            context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
            context->dec_input_curpos += 2;
            context->dec_bitcount += 16;
            }
        }
}


ulong NEAR getbits(t_decoder_context *context, int n)
{
    ulong value;

    value = context->dec_bitbuf >> (32-(n));
    fillbuf(context, n);

    return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decblk.c ===
/*
 * decblk.c
 *
 * main decoder module
 */
#include "decoder.h"

#include <memory.h>
#pragma intrinsic(memcpy)

/*
 * Decode a block type
 */
static int decode_block(
                       t_decoder_context *context,
                       lzx_block_type     block_type,
                       long               bufpos,
                       long               amount_to_decode
                       )
{
    int result;

    if (block_type == BLOCKTYPE_ALIGNED)
        result = decode_aligned_offset_block(context, bufpos, (int) amount_to_decode);
    else if (block_type == BLOCKTYPE_VERBATIM)
        result = decode_verbatim_block(context, bufpos, (int) amount_to_decode);
    else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        result = decode_uncompressed_block(context, bufpos, (int) amount_to_decode);
    else /* no other block types exist */
        result = -1;

    return result;
}



/*
 * Main decode entrypoint
 */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode)
{
    ulong                   amount_can_decode;
    long                    total_decoded;

    total_decoded = 0;

    while (bytes_to_decode > 0)
        {
        if (context->dec_decoder_state == DEC_STATE_START_NEW_BLOCK)
            {
            ulong   temp1;
            ulong   temp2;
            ulong   temp3;
            bool    do_translation;

            /*
             * If this is the first time this group, then get the
             * file size for translation.
             */
            if (context->dec_first_time_this_group)
                {
                context->dec_first_time_this_group = false;

                do_translation = (bool) getbits(context, 1);

                if (do_translation)
                    {
                    ulong high, low;

                    high = getbits(context, 16);
                    low  = getbits(context, 16);
                    context->dec_current_file_size = (high<<16)|low;
                    }
                else
                    {
                    context->dec_current_file_size = 0;
                    }
                }

            /*
             * If the last block we decoded was uncompressed, then
             * we need to skip the pad byte (if it exists), and
             * initialise the decoder's bit buffer
             */
            if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
                {
                /*
                 * If block size was odd, a pad byte is required
                 */
                if (context->dec_original_block_size & 1)
                    {
                    if (context->dec_input_curpos < context->dec_end_input_pos)
                        context->dec_input_curpos++;
                    }

                /* so that initialise_decoder_bitbuf() will succeed */
                context->dec_block_type = BLOCKTYPE_INVALID;

                initialise_decoder_bitbuf(context);
                }

            /* get the block type */
            context->dec_block_type = (lzx_block_type) getbits(context, 3);

            /* get size of block (in uncompressed bytes) to decode */
            temp1 = getbits(context, 8);
            temp2 = getbits(context, 8);
            temp3 = getbits(context, 8);

            /*
             * How large is the block we're going to decode?
             * It can be from 0...16777215 bytes (16MB)
             */
            context->dec_block_size =
            context->dec_original_block_size = (temp1<<16) + (temp2<<8) + (temp3);

            /* if block is an aligned type, read the aligned offset tree */
            if (context->dec_block_type == BLOCKTYPE_ALIGNED)
                read_aligned_offset_tree(context);

            /* read trees */
            if (context->dec_block_type == BLOCKTYPE_VERBATIM ||
                context->dec_block_type == BLOCKTYPE_ALIGNED)
                {
                /*      backup old trees */
                memcpy(
                      context->dec_main_tree_prev_len,
                      context->dec_main_tree_len,
                      MAIN_TREE_ELEMENTS
                      );

                memcpy(
                      context->dec_secondary_length_tree_prev_len,
                      context->dec_secondary_length_tree_len,
                      NUM_SECONDARY_LENGTHS
                      );

                read_main_and_secondary_trees(context);
                }
            else if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
                {
                if (handle_beginning_of_uncompressed_block(context) == false)
                    return -1;
                }
            else
                {
                /* no other block types are supported at this time */
                return -1;
                }

            context->dec_decoder_state = DEC_STATE_DECODING_DATA;
            }

        /*
         * Keep decoding until the whole block has been decoded
         */
        while ((context->dec_block_size > 0) && (bytes_to_decode > 0))
            {
            int decode_residue;

            amount_can_decode = min(context->dec_block_size, bytes_to_decode);

            /* shouldn't happen */
            if (amount_can_decode == 0)
                return -1;

            decode_residue = decode_block(
                                         context,
                                         context->dec_block_type,
                                         context->dec_bufpos,
                                         amount_can_decode
                                         );

            /*
             * We should have decoded exactly the amount we wanted,
             * since the encoder makes sure that no matches span 32K
             * boundaries.
             *
             * If the data was corrupted, it's possible that we decoded
             * up to MAX_MATCH bytes more than we wanted to.
             */
            if (decode_residue != 0)
                {
                /* error, we didn't decode what we wanted! */
                return -1;
                }

            context->dec_block_size -= amount_can_decode;
            bytes_to_decode -= amount_can_decode;
            total_decoded += amount_can_decode;
            }

        if (context->dec_block_size == 0)
            {
            context->dec_decoder_state = DEC_STATE_START_NEW_BLOCK;
            }

        if (bytes_to_decode == 0)
            {
            initialise_decoder_bitbuf(context);
            }
        }

#ifdef BIT16
    copy_data_to_output(
                       context,
                       total_decoded,
                       context->dec_output_buffer
                       );
#else
    copy_data_to_output(
                       context,
                       total_decoded,
                       context->dec_bufpos ?
                       &context->dec_mem_window[context->dec_bufpos - total_decoded] :
                       &context->dec_mem_window[context->dec_window_size - total_decoded]
                       );
#endif

    return total_decoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mspatch\lzx\decoder\decinit.c ===
/*
 * decinit.c
 *
 * Initialisa