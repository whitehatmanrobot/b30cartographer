e = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->OnRefresh( );
    }
}

//-----------------------------------------------------------------------------------------
void CRightList::OnRefreshServer( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

   CLicServer *pServer = NULL;

    if( pMainFrame != NULL )
    {
        CListCtrl& listctrl = GetListCtrl();
        
        CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
        
        ASSERT(pDoc);
        
        if(NULL == pDoc)
        {
            return;
        }
       
        int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);

        if( -1 != nSelected)
        {
            DWORD_PTR dCurrSel = listctrl.GetItemData( nSelected );

            if( NODE_ALL_SERVERS == pDoc->GetNodeType() )
            {  
                pServer = reinterpret_cast< CLicServer * >( dCurrSel );
            }        
            else if( pDoc->GetNodeType() == NODE_SERVER )
            {
                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack *>( dCurrSel );

                if( pKeyPack != NULL )
                {
                    pServer = pKeyPack->GetServer( );
                }
            }
            else if( pDoc->GetNodeType( ) == NODE_KEYPACK )
            {
                CLicense * pLicense = reinterpret_cast< CLicense * >( dCurrSel );

                pServer = ( pLicense->GetKeyPack() )->GetServer( );
            }
        }


        if( pServer != NULL )
        {
            pMainFrame->RefreshServer( pServer );
        }        
    }

}
    
//-----------------------------------------------------------------------------------------
void CRightList::OnDownloadKeepPack()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLKP , &bRefresh );
  
    DBGMSG( L"LICMGR : CRightList::OnDownloadKeepPack StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CRightList::OnRegisterServer()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnRegisterServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CRightList::OnRepeatLastDownload()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLASTLKP , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnRepeatLastDownload StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CRightList::OnReactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnReactivateServer StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CRightList::OnDeactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_UNREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnDeactivateServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CRightList::OnServerProperties( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_SHOWPROPERTIES , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnServerProperties StartWizard returned 0x%x\n" , dwStatus );    
    
}

//-----------------------------------------------------------------------------------------
void CRightList::OnGeneralHelp( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );
    
    if( pMainFrame != NULL )
    {
        pMainFrame->OnHelp( );
    }
}

//-----------------------------------------------------------------------------------------
void CRightList::SetActiveServer( CLicServer *pServer )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pServer != NULL )
    {
        DBGMSG( L"LICMGR : CRightList::SetActiveServer %s\n" , pServer->GetName( ) );
    }


    if( pMainFrame != NULL )
    {
        pMainFrame->SetActiveServer( pServer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by licmgr.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_SERVER_PROPERTIES           102
#define IDD_SERVER_PROPERTYPAGE         102
#define IDD_KEYPACK_PROPERTYPAGE        107
#define IDD_PROPPAGE_LARGE1             108
#define IDD_LICENSE_PROPERTYPAGE        108
#define IDR_MAINFRAME                   128
#define IDR_LICMGRTYPE                  129
#define IDI_ALL_SERVERS                 131
#define IDI_SERVER                      132
#define IDI_KEYPACK                     133
#define IDI_LICENSE                     134
#define IDD_CONNECT_DIALOG              137
#define IDD_ADD_KEYPACK                 138
#define IDR_TRACKMENU                   140
#define IDD_TEMP_LICENSES               141
#define IDD_LIC_AGREEMENT               142
#define IDD_ADD_LICENSES                144
#define IDD_REMOVE_LICENSES             146
#define IDD_DISCOVERY                   148
#define IDD_CONNECT_ERROR               149
#define IDR_MENU_LPK                    150
#define IDI_SERVERREG                   151
#define IDI_SERVERM                     152
#define IDI_SERVERX                     153
#define IDI_SERVERQ                     154
#define IDC_STATIC_NAME                 1001
#define IDC_STATIC_KEYPACK              1002
#define IDC_STATIC_KEYPACK2             1003
#define IDC_SERVER_NAME                 1005
#define IDC_SCOPE                       1006
#define IDC_HELP2                       1007
#define IDC_SERVER                      1008
#define IDC_COMPANY_NAME                1010
#define IDC_KEYPACK_ID                  1011
#define IDC_PRODUCT_NAME                1013
#define IDC_LANGUAGE                    1015
#define IDC_EDIT5                       1017
#define IDC_LICENSES                    1017
#define IDC_NUM_LICENSES                1018
#define IDC_KEYPACK_TYPE                1020
#define IDC_PRODUCT_ID                  1031
#define IDC_MAJOR_VERSION               1032
#define IDC_MINOR_VERSION               1033
#define IDC_BEGIN_SERIAL                1034
#define IDC_CHANNEL_OF_PURCHASE         1035
#define IDC_TOTAL_LICENSES              1036
#define IDC_AVAILABLE_LICENSES          1037
#define IDC_ACTIVATION_DATE             1038
#define IDC_EXPIRATION_DATE             1039
#define IDC_KEYPACK_STATUS              1040
#define IDC_MACHINE_NAME                1045
#define IDC_USER_NAME                   1046
#define IDC_ISSUE_DATE                  1047
#define IDC_EXPIRY_DATE                 1048
#define IDC_LICENSE_STATUS              1049
#define IDC_HELP1                       1051
#define IDC_TEMP_LICENSES               1052
#define IDC_LICENSE                     1053
#define IDC_AGREE                       1054
#define IDC_BUTTON1                     1056
#define IDC_HELP4                       1056
#define IDC_SPIN_LICNESES               1058
#define IDC_LICNESE_PACK                1060
#define IDC_REMOVE                      1061
#define IDC_ADD                         1062
#define IDC_HELP3                       1063
#define IDC_TLSERVER_NAME               1064
#define ID_CANCEL_DISCOVERY             1065
#define IDS_SERVER_REGISTERED           1066
#define IDS_SERVER_UNREGISTER           1067
#define IDS_SERVER_NOTREQUIRE           1068
#define ID_LARGE_ICONS                  32771
#define ID_SMALL_ICONS                  32772
#define ID_DETAILS                      32773
#define ID_LIST                         32774
#define ID_PROPERTIES                   32779
#define ID_CONNECT_SERVER               32784
#define ID_ADD_LICENSES                 32785
#define ID_EXIT                         32787
#define ID_HELP_CONTENTS                32788
#define ID_HELP_SEARCH                  32789
#define ID_HELP_HELP                    32790
#define ID_REFRESH                      32791
#define ID_LICENSE_REGISTER             32795
#define ID_REGISTRATION                 32796
#define ID_ACTION_DOWNLOADLICENSES      32797
#define ID_ACTION_ADVANCED_REPEATLASTDOWNLOAD 32799
#define ID_ACTION_ADVANCED_REREGISTERSERVER 32800
#define ID_ACTION_ADVANCED_UNREGISTERSERVER 32801
#define ID_VIEW_REFRESHALL              32802
#define ID_LPK_CONNECT                  32803
#define ID_LPK_REFRESH                  32804
#define ID_LPK_REFRESHALL               32805
#define ID_LPK_DOWNLOADLICENSES         32806
#define ID_LPK_REPEATDOWNLOAD           32807
#define ID_LPK_HELP                     32808
#define ID_LIC_CONNECT                  32809
#define ID_LIC_REFRESH                  32810
#define ID_LIC_DOWNLOADLICENSES         32811
#define ID_LIC_HELP                     32812
#define ID_LPK_PROPERTIES               32813
#define ID_LPK_ADVANCED_REPEATLASTDOWNLOAD 32814
#define ID_LPK_ADVANCED_REACTIVATESERVER 32815
#define ID_LPK_ADVANCED_DEACTIVATESERVER 32816
#define ID_SVR_ACTIVATESERVER           32817
#define ID_LICPAK_REFRESH               32819
#define ID_LICPAK_DOWNLOADLICENSES      32821
#define ID_LICPAK_REPEATDOWNLOAD        32822
#define ID_LICPAK_HELP                  32823
#define ID_ALLSVR_CONNECT               32824
#define ID_ALLSVR_REFRESHALL            32825
#define ID_ALLSVR_HELP                  32826
#define ID_KEY_HELP                     32828
#define ID_VIEW_PROPERTIES              32829
#define IDS_TREEROOT                    61204
#define IDS_SERVER_COLUMN1              61205
#define IDS_SERVER_COLUMN2              61206
#define IDS_SERVER_COLUMN3              61207
#define IDS_KEYPACK_COLUMN1             61208
#define IDS_KEYPACK_COLUMN2             61209
#define IDS_KEYPACK_COLUMN3             61210
#define IDS_KEYPACK_COLUMN4             61211
#define IDS_KEYPACK_COLUMN5             61212
#define IDS_KEYPACK_COLUMN6             61213
#define IDS_LICENSE_COLUMN1             61214
#define IDS_LICENSE_COLUMN2             61215
#define IDS_LICENSE_COLUMN3             61216
#define IDS_LICENSE_COLUMN4             61217
#define IDS_ENUM_FAILED                 61218
#define IDS_CONNECT_SERVER_FAILED       61219
#define IDS_UNKNOWN                     61220
#define IDS_INVALID_FIELDS              61221
#define IDS_ADD_SUCCESS                 61222
#define IDS_LSKEYPACKTYPE_UNKNOWN       61223
#define IDS_LSKEYPACKTYPE_RETAIL        61224
#define IDS_LSKEYPACKTYPE_SELECT        61225
#define IDS_LSKEYPACKTYPE_CONCURRENT    61226
#define IDS_LSKEYPACKTYPE_TEMPORARY     61227
#define IDS_LSKEYPACKTYPE_OPEN          61228
#define IDS_LSKEYPACKTYPE_FREE          61229
#define IDS_PURCHASE_UNKNOWN            61230
#define IDS_PURCHASE_OEM                61231
#define IDS_PURCHASE_RETAIL             61232
#define IDS_LICENSESTATUS_UNKNOWN       61233
#define IDS_LICENSESTATUS_TEMPORARY     61234
#define IDS_LICENSESTATUS_ACTIVE        61235
#define IDS_LICENSESTATUS_UPGRADED      61236
#define IDS_LICENSESTATUS_REVOKE        61237
#define IDS_LICENSE_PROPERTIES          61238
#define IDS_KEYPACK_PROPERTIES          61239
#define IDS_SERVER_PROPERTIES           61240
#define IDS_TEMPORARY                   61241
#define IDS_KEYPACKSTATUS_UNKNOWN       61242
#define IDS_KEYPACKSTATUS_ACTIVE        61243
#define IDS_KEYPACKSTATUS_PENDING       61244
#define IDS_KEYPACKSTATUS_RETURNED      61245
#define IDS_KEYPACKSTATUS_REVOKED       61246
#define IDS_KEYPACKSTATUS_TEMPORARY     61247
#define IDS_KEYPACKSTATUS_OTHERS        61248
#define IDS_APP_NAME                    61249
#define IDS_DUPLICATE_SERVER            61250
#define IDS_NO_KEYPACKS                 61251
#define IDS_NO_TEMP_LIC                 61252
#define IDS_LOCAL_NOLICENSE             61253
#define IDS_NO_MEMORY                   61254
#define IDS_DASH                        61255
#define IDS_FOR                         61256
#define IDS_PLATFORM1                   61257
#define IDS_PLATFORM2                   61258
#define IDS_PLATFORM3                   61259
#define IDS_PLATFORM4                   61260
#define IDS_PLATFORM5                   61261
#define IDS_PLATFORM6                   61262
#define IDS_TERMINAL_SERVER             61263
#define IDS_LIC_AGRMT                   61264
#define IDS_INTERNAL_ERROR              61265
#define IDS_REFRESH_SERVERS_ERROR       61266
#define IDS_UNLIMITED                   61267
#define IDS_SKU1                        61268
#define IDS_SKU2                        61269
#define IDS_SKU3                        61270
#define IDS_REMOVE_WARNING              61271
#define IDS_REMOVE_MORE                 61272
#define IDS_NO_HELP                     61273
#define IDS_CLEARING_HOUSE              61274
#define IDS_NO_ACCESS                   61275
#define IDS_REGISTER_FAILED             61276
#define IDS_TOTAL_CHANGED               61277
#define IDS_REMOVE_TOOMANY              61278
#define IDS_CONNECT_ERROR               61279
#define IDS_SERVER_BUSY                 61280
#define IDS_SERVER_OUTOFMEMORY          61281
#define IDS_SERVER_INTERNAL_ERROR       61282
#define IDS_236_SKU                     61283
#define IDS_NOSERVERINDOMAIN            61284
#define IDS_CREATETHREAD                61285
#define IDS_CANCELDISCOVERY             61286
#define IDS_TRYSERVER                   61287
#define IDS_TS4                         61446
#define IDS_SERVER_WAITFORPIN           61447

#define IDS_E_ACCESSDENIED              61451

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        155
#define _APS_NEXT_COMMAND_VALUE         32830
#define _APS_NEXT_CONTROL_VALUE         1069
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\servprop.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	ServProp.h

Abstract:
    
    This Module defines CServerProperties Dialog class
    (The Dialog used to disply server properties)


Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_SERVERPROPERTIES_H__E39780D9_8C5F_11D1_8AD4_00C04FB6CBB5__INCLUDED_)
#define AFX_SERVERPROPERTIES_H__E39780D9_8C5F_11D1_8AD4_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CServerProperties dialog

class CServerProperties : public CPropertyPage
{
    DECLARE_DYNCREATE(CServerProperties)

// Construction
public:
    CServerProperties();
    ~CServerProperties();

// Dialog Data
    //{{AFX_DATA(CServerProperties)
    enum { IDD = IDD_SERVER_PROPERTIES };
    CString    m_ServerName;
    CString    m_Scope;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CServerProperties)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CServerProperties)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVERPROPERTIES_H__E39780D9_8C5F_11D1_8AD4_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\rtlist.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LtView.h 

Abstract:
    
    This Module defines the CRightList class (The View class  used for the
    right pane in the splitter window)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_RIGHTLIST_H__72451C7E_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_RIGHTLIST_H__72451C7E_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#include "lrwizapi.h"

enum ITEM_TYPE { LICENSE , LICENSE_PACK };

// CRightList view

class CRightList : public CListView
{
protected:
    CRightList();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(CRightList)

// Attributes
public:

// Operations
public:
    HRESULT SetLicenseColumns();
    HRESULT SetKeyPackColumns();
    HRESULT SetServerColumns();
    HRESULT AddKeyPackstoList(CLicServer * pServer, BOOL bRefresh = FALSE);
    void AddKeyPack(CListCtrl& ListCtrl, int index, CKeyPack * pKeyPack);
    HRESULT AddServerstoList();

    void UI_initmenu(
        CMenu *pMenu,
        NODETYPE nt
    );

    DWORD WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh );

    void OnServerConnect( );
    void OnRefreshAllServers( );
    void OnRefreshServer( );

    void OnDownloadKeepPack();
    void OnRegisterServer();
    void OnRepeatLastDownload();
    void OnReactivateServer( );
    void OnDeactivateServer( );

    void OnServerProperties( );
    void OnGeneralHelp( );
    void SetActiveServer( CLicServer *pServer );

    //static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, 
    //LPARAM lParamSort);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRightList)
    public:
    virtual void OnInitialUpdate();
    protected:
    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CRightList();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
protected:
    CImageList m_ImageListLarge;
    CImageList m_ImageListSmall;
    //{{AFX_MSG(CRightList)
    afx_msg LRESULT OnSelChange(WPARAM wParam, LPARAM lParam);
    afx_msg void OnLargeIcons();
    afx_msg void OnSmallIcons();
    afx_msg void OnList();
    afx_msg void OnDetails();
    afx_msg void OnProperties();
    afx_msg LRESULT OnAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDeleteServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnUpdateServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddKeyPack(WPARAM wParam, LPARAM lParam);
    afx_msg void OnAddNewKeyPack();
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLeftClick( NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt );
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RIGHTLIST_H__72451C7E_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\templic.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// TempLic.cpp : implementation file
//

#include "stdafx.h"
#include "licmgr.h"
#include "defines.h"
#include "LSServer.h"
#include "TempLic.h"
#include  "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTempLicenses dialog


CTempLicenses::CTempLicenses(CWnd* pParent /*=NULL*/)
	: CDialog(CTempLicenses::IDD, pParent)
{
    m_pKeyPackList = NULL;
	//{{AFX_DATA_INIT(CTempLicenses)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CTempLicenses::CTempLicenses(KeyPackList * pKeyPackList,CWnd* pParent/*=NULL*/)
    : CDialog(CTempLicenses::IDD, pParent)
{
    m_pKeyPackList = pKeyPackList;
}


void CTempLicenses::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTempLicenses)
	DDX_Control(pDX, IDC_TEMP_LICENSES, m_TempLic);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTempLicenses, CDialog)
	//{{AFX_MSG_MAP(CTempLicenses)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTempLicenses message handlers

BOOL CTempLicenses::OnInitDialog() 
{
	CDialog::OnInitDialog();
   // TODO: Add extra initialization here
    if(m_pKeyPackList == NULL)
        return TRUE;
    m_TempLic.ModifyStyle(LVS_LIST|LVS_ICON | LVS_SMALLICON,LVS_REPORT,0);
    LV_COLUMN lvC;
    CString ColumnText;
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = 125;
    for(int index = 0; index < NUM_LICENSE_COLUMNS; index ++)
    {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_LICENSE_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        m_TempLic.InsertColumn(index, &lvC);

    }
    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    ASSERT(pApp);
    CMainFrame * pWnd = (CMainFrame *)pApp->m_pMainWnd ;
    ASSERT(pWnd);
    POSITION pos = m_pKeyPackList->GetHeadPosition();
    while(pos)
    {
        CKeyPack *pKeyPack = m_pKeyPackList->GetNext(pos);
        ASSERT(pKeyPack);
        pWnd->AddLicensestoList(pKeyPack,&m_TempLic);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\tlshunt.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// TlsHunt.cpp : implementation file
//

#include "stdafx.h"
#include <lm.h>
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "RtList.h"
#include "lSmgrdoc.h"
#include "LtView.h"
#include "cntdlg.h"
#include "addkp.h"
#include "treenode.h"
#include "ntsecapi.h"
#include "lrwizapi.h"
#include "TlsHunt.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTlsHunt dialog

CTlsHunt::~CTlsHunt()
{
    if(m_hThread != NULL)
        CloseHandle(m_hThread);
}

CTlsHunt::CTlsHunt(CWnd* pParent /*=NULL*/)
    : CDialog(CTlsHunt::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTlsHunt)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hThread = NULL;
    memset(&m_EnumData, 0, sizeof(m_EnumData));
}   

void CTlsHunt::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTlsHunt)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTlsHunt, CDialog)
    //{{AFX_MSG_MAP(CTlsHunt)
    ON_WM_CREATE()
    //ON_MESSAGE(WM_DONEDISCOVERY, OnDoneDiscovery)
    ON_WM_CLOSE()
    ON_WM_CANCELMODE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTlsHunt message handlers

//------------------------------------------------------------------

BOOL 
CTlsHunt::ServerEnumCallBack(
    TLS_HANDLE hHandle,
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

++*/
{
    ServerEnumData* pEnumData = (ServerEnumData *)dwUserData;
    BOOL bCancel;

    bCancel = (InterlockedExchange(&(pEnumData->dwDone), pEnumData->dwDone) == 1);
    if(bCancel == TRUE)
    {
        return TRUE;
    }

    if(pszServerName && pszServerName[0] != _TEXT('\0'))
    {
#if DBG
        OutputDebugString(pszServerName);
        OutputDebugString(L"\n");
#endif

        CString itemTxt;

        itemTxt.Format(IDS_TRYSERVER, pszServerName);

        pEnumData->pWaitDlg->SendDlgItemMessage(
                                        IDC_TLSERVER_NAME, 
                                        WM_SETTEXT, 
                                        0, 
                                        (LPARAM)(LPCTSTR)itemTxt
                                    );
    }

    if(hHandle)
    {
        DWORD dwStatus;
        DWORD dwErrCode;
        TCHAR szServer[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwBufSize = sizeof(szServer) / sizeof(szServer[0]);


        if(pEnumData == NULL || pEnumData->pMainFrm == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return TRUE;
        }

        memset(szServer, 0, sizeof(szServer));
        dwStatus = TLSGetServerNameEx(
                                hHandle,
                                szServer,
                                &dwBufSize,
                                &dwErrCode
                            );

        if(dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS)
        {
            //
            // Make NT4 RPC call to ensure this server is compatible
            // with our version
            //
            pEnumData->pMainFrm->ConnectServer(szServer);
            pEnumData->dwNumServer++;
        }
    }

    //
    // Continue enumeration
    //
    return InterlockedExchange(&(pEnumData->dwDone), pEnumData->dwDone) == 1;
}


/////////////////////////////////////////////////////////////////////
DWORD WINAPI
CTlsHunt::DiscoveryThread(
    PVOID ptr
    )
/*++


++*/
{
    DWORD hResult;
    ServerEnumData* pEnumData = (ServerEnumData *)ptr;
    LPWSTR* pszEnterpriseServer = NULL;
    DWORD dwCount;
    DWORD index;
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        TLSInit();
        fInitialized = TRUE;
    }

    //
    // Look for all license server in domain
    //
    hResult = EnumerateTlsServer(
                            CTlsHunt::ServerEnumCallBack,
                            ptr,
                            3 * 1000,
                            FALSE
                        );  


    // Find enterprise server
    if(pEnumData->dwDone == 0)
    {
        hResult = GetAllEnterpriseServers(
                                        &pszEnterpriseServer,
                                        &dwCount
                                    );

        if(hResult == ERROR_SUCCESS && dwCount != 0 && pszEnterpriseServer != NULL)
        {
            TLS_HANDLE TlsHandle = NULL;

            //
            // Inform dialog
            //
            for(index = 0; index < dwCount && pEnumData->dwDone == 0; index++)
            {
                if(pszEnterpriseServer[index] == NULL)
                    continue;

                if(ServerEnumCallBack(
                                NULL, 
                                pszEnterpriseServer[index], 
                                pEnumData
                            ) == TRUE)
                {
                    continue;
                }

                TlsHandle = TLSConnectToLsServer(
                                            pszEnterpriseServer[index]
                                        );

                if(TlsHandle == NULL)
                {
                    continue;
                }


                DWORD dwVersion;
                RPC_STATUS rpcStatus;

                rpcStatus = TLSGetVersion( 
                                        TlsHandle, 
                                        &dwVersion 
                                    );

                if(rpcStatus != RPC_S_OK)
                {
                    continue;
                }

                if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
                {
                    continue;
                }

                ServerEnumCallBack(
                                TlsHandle, 
                                pszEnterpriseServer[index], 
                                pEnumData
                            );

                TLSDisconnectFromServer(TlsHandle);
            }
        } else
        {
            // Failure in GetAllEnterpriseServers

            pszEnterpriseServer = NULL;
            dwCount = 0;
        }
    }

    if(pszEnterpriseServer != NULL)
    {
        for( index = 0; index < dwCount; index ++)
        {
            if(pszEnterpriseServer[index] != NULL)
            {
                LocalFree(pszEnterpriseServer[index]);
            }
        }

        LocalFree(pszEnterpriseServer);
    }                      

    pEnumData->pWaitDlg->PostMessage(WM_DONEDISCOVERY);
    ExitThread(hResult);
    return hResult;
}


BOOL CTlsHunt::OnInitDialog() 
{
    CDialog::OnInitDialog();

    ASSERT(m_hThread != NULL);

    if(m_hThread != NULL)
    {
        ResumeThread(m_hThread);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

int CTlsHunt::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CDialog::OnCreate(lpCreateStruct) == -1)
        return -1;


    m_EnumData.pWaitDlg = this;
    m_EnumData.pMainFrm = (CMainFrame *)GetParentFrame();
    m_EnumData.dwNumServer = 0;
    m_EnumData.dwDone = 0;

    DWORD dwId;

    m_hThread = (HANDLE)CreateThread(
                                NULL, 
                                0, 
                                CTlsHunt::DiscoveryThread, 
                                &m_EnumData, 
                                CREATE_SUSPENDED, // suspended thread
                                &dwId
                            );
    
    if(m_hThread == NULL)
    {
        //
        // Can't create thread.
        //
        AfxMessageBox(IDS_CREATETHREAD);
        return -1;
    }
    
    return 0;
}

void CTlsHunt::OnCancel() 
{
    if( m_hThread != NULL && 
        WaitForSingleObject(m_hThread, 0) == WAIT_TIMEOUT )
    {
        InterlockedExchange(&(m_EnumData.dwDone), 1);

        CString txt;

        txt.LoadString(IDS_CANCELDISCOVERY);

        SendDlgItemMessage(
                        IDC_TLSERVER_NAME, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM)(LPCTSTR)txt
                    );
        
        CWnd* btn = GetDlgItem(IDCANCEL);

        ASSERT(btn);

        if(btn != NULL)
        {
            btn->EnableWindow(FALSE);
        }
    }
    else
    {
        CDialog::OnCancel();
    }
}

void CTlsHunt::OnDoneDiscovery()
{
    if(m_hThread != NULL)
    {
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    CDialog::EndDialog(0);
}

void CTlsHunt::OnClose() 
{
    if(m_hThread != NULL)
    {
        InterlockedExchange(&(m_EnumData.dwDone), 1);

        CString txt;

        txt.LoadString(IDS_CANCELDISCOVERY);

        SendDlgItemMessage(
                        IDC_TLSERVER_NAME, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM)(LPCTSTR)txt
                    );
        
        CWnd* btn = GetDlgItem(IDCANCEL);

        ASSERT(btn);

        if(btn != NULL)
        {
            btn->EnableWindow(FALSE);
        }
    }
    else
    {
        CDialog::OnClose();
    }
}

BOOL CTlsHunt::PreTranslateMessage(MSG* pMsg) 
{
    if(pMsg->message == WM_DONEDISCOVERY)
    {
        OnDoneDiscovery();
        return TRUE;
    }
    
    return CDialog::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\treenode.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	TreeNode.h

Abstract:
    
    This Module contains the CTreeNode class
    (Class used for representing every node in the tree view);

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include <afx.h>


class CTreeNode : public CObject
{
public:
    // constructor
    CTreeNode(NODETYPE NodeType, CObject* pObject) { m_NodeType = NodeType; m_pTreeObject = pObject; }
    // Returns the node type
    NODETYPE GetNodeType() { return m_NodeType; }
    // Returns the object pointed to by this node
    CObject *GetTreeObject() { return m_pTreeObject; }
    // Returns the sort order stored in the object
    ULONG GetSortOrder() { return m_SortOrder; }
    // Sets the sort order stored with the object
    void SetSortOrder(ULONG order) { m_SortOrder = order; }

private:
    NODETYPE m_NodeType;
    CObject* m_pTreeObject;
    ULONG m_SortOrder;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\templic.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#if !defined(AFX_TEMPLIC_H__C5B7596E_9ED0_11D1_8510_00C04FB6CBB5__INCLUDED_)
#define AFX_TEMPLIC_H__C5B7596E_9ED0_11D1_8510_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// TempLic.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTempLicenses dialog

class CTempLicenses : public CDialog
{
// Construction
public:
	CTempLicenses(CWnd* pParent = NULL);   // standard constructor
    CTempLicenses(KeyPackList * pKeyPackList,CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CTempLicenses)
	enum { IDD = IDD_TEMP_LICENSES };
	CListCtrl	m_TempLic;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTempLicenses)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTempLicenses)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	KeyPackList * m_pKeyPackList;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEMPLIC_H__C5B7596E_9ED0_11D1_8510_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lkplite\base24.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef _BASE24_H_
#define _BASE24_H_

#include <windows.h>

extern DWORD B24EncodeMSID(LPBYTE pbDataToEncode, TCHAR **pbEncodedData);
extern DWORD B24DecodeMSID(TCHAR * pbEncodedData, LPBYTE * pbDecodedData);


extern DWORD B24EncodeCNumber(LPBYTE pbDataToEncode, TCHAR **pbEncodedData);
extern DWORD B24DecodeCNumber(TCHAR * pbEncodedData, LPBYTE * pbDecodedData);


extern DWORD B24EncodeSPK(LPBYTE pbDataToEncode, TCHAR **pbEncodedData);
extern DWORD B24DecodeSPK(TCHAR * pbEncodedData, LPBYTE * pbDecodedData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lkplite\lkplite.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-2000 Microsoft Corporation
//
// File:
//
// Contents:
//
// History:
//
//---------------------------------------------------------------------------

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0400
#endif
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include "Shortsig.h"
#include "base24.h"
#include "lkplite.h"
#include "rc4.h"
#include "md5.h"

//internal functions
#define LKPLITE_PID_LEN					_tcslen(_TEXT("12345-123-1234567-12345"))

#define SIGNATURE_LEN	104

#define LKPLITE_PID_FIRSTCOPYOFFSET		10
#define LKPLITE_PID_SECONDCOPYOFFSET	18
#define LKPLITE_SPK_BITSTUFF			0x00000000000000FF

#define LKPLITE_RAWDATALEN				20

DWORD	ValidatePID ( LPTSTR lpszPID );
__int64 GetSPKIDFromPID ( LPTSTR lpszPID );


#ifndef SIG_VERIFY_ONLY
BYTE abLKPPrivateKey0[] =
{
	0x64, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xff, 0xab, 
	0xa9, 0xba, 0xae, 0xdf, 0x30, 0x01, 0xb7, 0x1e, 0x79, 0x64, 
	0x46, 0x00, 0x00, 0x00, 0x50, 0x6d, 0x54, 0x36, 0x05, 0x00, 
	0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x3d, 0xcb, 0x68, 0x79, 
	0x23, 0x52, 0x2c, 0x98, 0x24, 0x00, 0x00, 0x00, 0x83, 0x1c, 
	0x65, 0x18, 0x2b, 0xd6, 0x7b, 0x6f, 0x05, 0x00, 0x00, 0x00, 
	0x29, 0xe8, 0xe0, 0x1e, 0x71, 0xa0, 0x80, 0x40, 0x36, 0x26, 
	0x23, 0xe3, 0xab, 0x55, 0xa2, 0x7b, 0xac, 0xda, 0xf3, 0x29, 
	0x4d, 0xe1, 0x1a, 0xfa, 0x54, 0x41, 0xb7, 0xd3, 0x28, 0x27, 
	0x02, 0x7e, 0x9b, 0x2b, 0xc6, 0xf7, 0x6e, 0x82, 0x2c, 0xe4
};


BYTE abLSIDPrivateKey0[] =
{
	0x64,  0x00,  0x00,  0x00,  0x09,  0x00,  0x00,  0x00,  0x79,  0x6d,  
	0x1a,  0x6c,  0xae,  0xdf,  0x30,  0x01,  0x83,  0xa1,  0xc9,  0xb1,  
	0x46,  0x00,  0x00,  0x00,  0x1d,  0x6e,  0x56,  0x37,  0x05,  0x00,  
	0x00,  0x00,  0x64,  0x00,  0x00,  0x00,  0x49,  0x17,  0x6c,  0x21,  
	0x8e,  0x1d,  0x01,  0x1a,  0x22,  0x00,  0x00,  0x00,  0xa8,  0x60,  
	0x22,  0xb7,  0x36,  0xe3,  0x43,  0x57,  0x08,  0x00,  0x00,  0x00,  
	0x4b,  0x18,  0x12,  0x54,  0x39,  0x8f,  0x7c,  0x85,  0x88,  0xc4,  
	0x61,  0x16,  0x39,  0x17,  0x29,  0x67,  0xe2,  0xe0,  0x20,  0x2c,  
	0xcb,  0xeb,  0x5b,  0xd7,  0x75,  0xf0,  0xb8,  0xf3,  0x87,  0x48,  
	0x6d,  0x49,  0xce,  0x9a,  0xb3,  0x12,  0x82,  0x05,  0x51,  0xb5
};

#endif


BYTE abLKPPublicKey0[] =
{
	0x6c, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xb7, 0x1e, 
	0x79, 0x64, 0xae, 0xdf, 0x30, 0x01, 0x0c, 0x00, 0x00, 0x00, 
	0x23, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0xf1, 0x89, 
	0x3e, 0xb9, 0x7f, 0x5e, 0xc9, 0x40, 0x4f, 0x0d, 0x64, 0x2c, 
	0x9e, 0x1c, 0x5b, 0xd7, 0x43, 0xb3, 0x51, 0x59, 0x27, 0x81, 
	0xfb, 0x16, 0x86, 0xa7, 0xb5, 0x9d, 0x89, 0xdb, 0x52, 0xf6, 
	0x3e, 0x95, 0xc9, 0x4c, 0x7b, 0x34, 0x54, 0x01, 0xab, 0x3c, 
	0x10, 0xb9, 0x35, 0x40, 0x64, 0xba, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x39, 0x4d, 0x13, 0xde, 0xe2, 0xc9, 0x68, 0xb5, 
	0xef, 0x45, 0x67, 0x94, 0xde, 0x01, 0xdd, 0x35, 0x56, 0x30, 
	0x7b, 0xcd, 0xbc, 0xd5, 0x88, 0x77, 0xee, 0xf9, 0x5d, 0xa1, 
	0xaf, 0xab, 0xc2, 0xdf, 0xf8, 0x6c, 0x8c, 0x3d, 0xce, 0x4d, 
	0xab, 0x27, 0x6b, 0xcc, 0x64, 0x77, 0x8b, 0xbd, 0x71, 0x7b, 
	0xdd, 0x93, 0x05, 0xe5, 0xeb, 0xf1, 0xe0, 0x7c, 0xe8, 0x35, 
	0x0d, 0x4e, 0x31, 0x22, 0x23, 0x42, 0xaf, 0x33, 0x9f, 0x72, 
	0xda, 0xc9, 0x77, 0xa6, 0xe9, 0xcf, 0xac, 0x26, 0xe0, 0xb7, 
	0x6e, 0x50, 0xbb, 0x32, 0x71, 0x35, 0x32, 0xc2, 0x41, 0xdf, 
	0x76, 0x24, 0xbe, 0xdf, 0x4a, 0x90, 0xff, 0x2e, 0xdc, 0x16, 
	0x02, 0x6c, 0xd0, 0x85, 0xf5, 0xdd, 0xf0, 0x0d, 0xe6, 0x01, 
	0x75, 0x05, 0x75, 0x87, 0x3b, 0xb6, 0xc8, 0x51, 0x7f, 0x66, 
	0xcd, 0x2b, 0x52, 0x0b, 0x09, 0xec, 0xa5, 0x4a, 0xdf, 0x2b, 
	0xf0, 0xbd, 0x0e, 0x83, 0x2f, 0xa9, 0xbb, 0xde, 0x43, 0x6e, 
	0x4f, 0x38, 0x13, 0xa3, 0x70, 0x2e, 0x5e, 0x7f, 0xf2, 0x84, 
	0xaa, 0xfe, 0x12, 0x7d, 0x4e, 0x17, 0xad, 0x7a, 0x3c, 0x05, 
	0x40, 0x92, 0xf8, 0x34, 0x97, 0x43, 0x88, 0x93, 0xf1, 0x78, 
	0xe4, 0xe9, 0xe6, 0x4c, 0x2d, 0xf9, 0xcf, 0xf8, 0xb5, 0x34, 
	0x8c, 0x98, 0x56, 0x8d, 0x89, 0x9d, 0x34, 0xf5, 0xfa, 0xb6, 
	0x78, 0xfa, 0x5a, 0x85
};



BYTE abLSIDPublicKey0[] =
{
	0x6c,  0x01,  0x00,  0x00,  0x07,  0x00,  0x00,  0x00,  0x83,  0xa1,  
	0xc9,  0xb1,  0xae,  0xdf,  0x30,  0x01,  0x0c,  0x00,  0x00,  0x00,  
	0x23,  0x00,  0x00,  0x00,  0x45,  0x00,  0x00,  0x00,  0x31,  0x07,  
	0xcb,  0x01,  0x1e,  0x92,  0x74,  0x0b,  0x1e,  0x2b,  0x2d,  0x07,  
	0x68,  0xc5,  0xff,  0x21,  0xc5,  0x5c,  0x32,  0xb6,  0x44,  0xdb,  
	0x02,  0x09,  0xde,  0x2e,  0xc6,  0x6d,  0xb5,  0xc4,  0xd4,  0x44,  
	0x6f,  0xc7,  0x0d,  0xba,  0x4e,  0xe5,  0x0b,  0x0f,  0x92,  0xb1,  
	0x22,  0x25,  0xab,  0xdd,  0x86,  0x8d,  0x01,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0xdb,  0x86,  0x67,  0xfb,  0x5c,  0x8c,  0x53,  0x72,  
	0x0e,  0x49,  0x94,  0x97,  0x94,  0x15,  0xfc,  0x25,  0x0d,  0xdd,  
	0xa1,  0xe4,  0xa0,  0xf0,  0xc3,  0x17,  0xf6,  0x98,  0xce,  0x9c,  
	0x07,  0x31,  0x10,  0xb7,  0x73,  0x16,  0x4f,  0x91,  0xbb,  0xfa,  
	0x01,  0xde,  0x9e,  0x79,  0xf2,  0x66,  0x58,  0xf5,  0x77,  0x45,  
	0x55,  0xf0,  0xa8,  0xb8,  0x0c,  0x2c,  0x0f,  0x15,  0xc7,  0x28,  
	0xce,  0x81,  0x69,  0x4e,  0x55,  0xd5,  0xf3,  0x89,  0xdc,  0x11,  
	0x34,  0x09,  0x40,  0x94,  0x5c,  0xaa,  0xd0,  0x6a,  0x5a,  0x06,  
	0x8e,  0x62,  0x6e,  0x5f,  0x7e,  0x35,  0x44,  0x5f,  0x06,  0xb2,  
	0xa5,  0xe8,  0x3c,  0x1b,  0x4d,  0xb8,  0xc6,  0x5e,  0xe0,  0xe4,  
	0xa6,  0xac,  0x80,  0xef,  0x8c,  0x99,  0x23,  0x06,  0x70,  0xd6,  
	0x6c,  0x62,  0x01,  0xb6,  0xde,  0x3b,  0x0c,  0x5e,  0x2a,  0x96,  
	0x9e,  0x63,  0x58,  0x9f,  0xdf,  0xf1,  0xaf,  0x5d,  0x02,  0xb6,  
	0x84,  0xc1,  0x52,  0x1f,  0xbc,  0xb8,  0x0c,  0x72,  0x3c,  0x1b,  
	0xb4,  0x58,  0x51,  0xab,  0x73,  0x19,  0x65,  0xbb,  0xc6,  0xb4,  
	0xb2,  0x53,  0xeb,  0x17,  0x4c,  0x42,  0xc9,  0xc2,  0xcd,  0x7f,  
	0x88,  0x0f,  0xb8,  0xaa,  0xc4,  0xca,  0xaa,  0xe0,  0xa0,  0xe1,  
	0x5f,  0xdb,  0x6e,  0xb8,  0x26,  0xf9,  0x8d,  0x4a,  0xe7,  0xdb,  
	0x1e,  0xdc,  0xc7,  0xdf,  0xf0,  0x35,  0x88,  0xec,  0x1d,  0xbe,  
	0xab,  0xa4,  0x8d,  0x39  
};


//SPK functions
//SPK Format
//Total length = 160 bits
//SPK = 58 bits
//Signature = 120 bits
//SPK break down :
//  Bits 1 ..18 - Unique Id max value = 262144
//  Bit 19 - SPK Type = 0 = BASIC 1 = SELECT
//  Bits 20..56 =	SPK Id extracted from PID.
//					PID is in this format 12345-123-1234567-12345
//					we are using chars 11-16 and 19 thru' end of PID and converting it to a 
//					number.
//  Bits 57 .. end = signature for the first 56 bits
// 
#ifndef SIG_VERIFY_ONLY
DWORD LKPLiteGenSPK ( 
	LPTSTR   pszPID,			//PID for the product.  Should include the installation number
	DWORD	 dwUniqueId,		//unique Id to be put in the SPK
	short	 nSPKType,			//Can be 1 for select or 0 for BASIC
	LPTSTR * ppszSPK
	)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	BYTE		bSPK[LKPLITE_SPK_LEN] = {0xFF};
	__int64		n64SPK = 0;
	__int64		n64UniqueId = dwUniqueId;
	__int64		n64PID =0;
	

	//validate incomming parametetrs
	if ( NULL == pszPID || NULL == pszPID || 
		 (LKPLITE_SPK_SELECT != nSPKType  && LKPLITE_SPK_BASIC != nSPKType ) ||
		 0 ==dwUniqueId )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}
	//validate syntax of PID
	if ( ( dwRetCode = ValidatePID ( pszPID ) ) != ERROR_SUCCESS )
	{
		goto done;
	}
	//ALL OK so generate the SPK now
	n64SPK = dwUniqueId;
	n64SPK <<= 46;				//left shift this by 46 bits
	//Or the bit mask for select/basic cert types.
	if ( nSPKType == LKPLITE_SPK_SELECT )
	{
		n64SPK |= LKPLITE_SPK_SELECT_MASK;
	}
	else if ( nSPKType == LKPLITE_SPK_BASIC )
	{
		n64SPK |= LKPLITE_SPK_BASIC_MASK;
	}

	//extract the PID stuff and move it into the stuff
	n64PID = GetSPKIDFromPID ( pszPID );
	//move the pid left by 8 bits and or it with the main stuff
	n64PID <<= 8;
	//set the last 8 bits of this PID to 1's
	n64PID |= LKPLITE_SPK_BITSTUFF;
	//or the PID with SPK
	n64SPK |= n64PID;

	memcpy ( bSPK, ((BYTE *) (&n64SPK)) + 1, sizeof(n64SPK)-1);
	//get the signature and then
	//assign the pointer
/*
	dwRetCode =  CryptSignBatch(0, NULL, 7, bSPK, sizeof(abPrivateKey0),abPrivateKey0,
								sizeof(abPublicKey0), abPublicKey0, SIGNATURE_LEN,
								bSPK+7,1);
*/

	dwRetCode = CryptSign(0, NULL, 7, bSPK, sizeof(abLSIDPrivateKey0), abLSIDPrivateKey0,
						  sizeof(abLSIDPublicKey0), abLSIDPublicKey0, SIGNATURE_LEN,
						  bSPK+7);

	if (dwRetCode != SS_OK)
	{
		goto done;
	}
	//encrypt it with the pid passed in
	dwRetCode = LKPLiteEncryptUsingPID(pszPID,
									   bSPK,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode =  B24EncodeMSID((PBYTE)bSPK, ppszSPK);

done:
	return dwRetCode;
}
#endif



DWORD LKPLiteVerifySPK (
	LPTSTR	pszPID,			//PID to validate against
	LPTSTR	pszSPK,	
	DWORD *	pdwVerifyResult
	)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedSPK = NULL;
	__int64		n64SPK = 0;
	__int64		n64SPKPID =0;
	__int64		n64SPKVerifyPID =0;
	
	//common validations
	if ( NULL == pszPID || NULL == pszSPK || 
		 NULL == pdwVerifyResult )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}

	if ((dwRetCode = ValidatePID ( pszPID ))!= ERROR_SUCCESS)
	{
		goto done;
	}

	//now decode the stuff comming in 
	//base24 expects a string so we need to do this conversion

	
	dwRetCode =  B24DecodeMSID(pszSPK , &pbDecodedSPK);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}


	dwRetCode = LKPLiteDecryptUsingPID(pszPID,
									   pbDecodedSPK,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	
	//Call function to verify signature on SPK
	dwRetCode = CryptVerifySig(7, pbDecodedSPK, sizeof(abLSIDPublicKey0),
							   abLSIDPublicKey0, SIGNATURE_LEN, pbDecodedSPK+7);
	if (dwRetCode != SS_OK)
	{
		*pdwVerifyResult = LKPLITE_SPK_INVALID;
		goto done;
	}

	
	memcpy ( ((BYTE *) &n64SPK) + 1, pbDecodedSPK, sizeof(n64SPK) -1 );

	//now get the contents of SPK and then see if it matches with
	//the PID passed in
	//extract bits 	20 - 56 and then move them right 8 bits
	n64SPKPID = n64SPK & LKPLITE_SPK_PID_MASK;
	n64SPKPID >>= 8;
	n64SPKVerifyPID = GetSPKIDFromPID ( pszPID );
	if ( n64SPKVerifyPID != n64SPKPID )
	{
		*pdwVerifyResult = LKPLITE_SPK_INVALID;
	}
	else
	{
		*pdwVerifyResult = LKPLITE_SPK_VALID;
	}
	
done:
	if ( pbDecodedSPK )
		HeapFree (GetProcessHeap(),0,pbDecodedSPK );
	return dwRetCode;
}


DWORD LKPLiteCrackSPK  (
	LPTSTR		pszPID,	
	LPTSTR		pszSPK,			//Pointer to SPK	
	LPTSTR		pszPIDPart,		//PID Part of SPK
	DWORD  *	pdwUniqueId,	//uniqueId part of SPK
	short  *	pnSPKType		//Type of SPK - Select/Basic
	)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedSPK = NULL;
	__int64		n64SPK =0;
	__int64		n64PIDPart =0;
	__int64		n64UniqueId =0;

	LPTSTR		lpszEncodedSPK = NULL;

	//Validate the parameters
	if ( NULL == pszSPK || 	 NULL == pszPIDPart || 
		NULL == pdwUniqueId || NULL == pnSPKType
	   )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}
	//decode the SPK here
	dwRetCode =  B24DecodeMSID(pszSPK, &pbDecodedSPK);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}

	dwRetCode = LKPLiteDecryptUsingPID(pszPID,
									   pbDecodedSPK,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//get the SPK portion of it
	memcpy ( ((BYTE *) &n64SPK) + 1, pbDecodedSPK, sizeof(n64SPK) - 1);

	//get the first 20 bits into 
	n64UniqueId = n64SPK & LKPLITE_SPK_UNIQUEID_MASK;
	n64UniqueId >>= 46;
	*pdwUniqueId = (DWORD)n64UniqueId;
	//check to see select / basic mask
	if ( n64SPK & LKPLITE_SPK_SELECT_MASK )
	{
		*pnSPKType = LKPLITE_SPK_SELECT;
	}
	else
	{
		*pnSPKType = LKPLITE_SPK_BASIC;
	}

	//get the PID part
	n64PIDPart = n64SPK & LKPLITE_SPK_PID_MASK;
	n64PIDPart >>= 6;
	pszPIDPart = _i64tot (n64PIDPart, pszPIDPart, 10);
done:
	if ( pbDecodedSPK )
		HeapFree (GetProcessHeap(), 0, pbDecodedSPK );
	return dwRetCode;
}

//LKP functions
//LKP Format
// Bits 1..10		- Product Code		It is 256 for not which is NT 5.0 product code
// Bits 11..24		- Quantity		Max 9999
// Bits 25..36		- Serial num	Max 4K
// Bits 37..38		- Program Type 0-SELECT,1-MOLP, 2-RETAIL
// Bits 39..46		- Dt Of expiration in months from today
// Bits 47..53		- Version 1-99 
// Bits 54..56		- Upgrade / Full flag
// Bits 57 .. end	- Signature
//
#ifndef SIG_VERIFY_ONLY
DWORD LKPLiteGenLKP (
	LPTSTR		lpszPID,				//used for encrypting the LKPLite structure
	LPTSTR		lpszProductCode,		//Product Code
	DWORD		dwQuantity,				//quantity
	DWORD		dwSerialNum,			//serail number of SPK
	DWORD		dwExpirationMos,		//expiration in number of months from today
	DWORD		dwVersion,				//version number can be upto 99
	DWORD		dwUpgrade,				//upgrade or full license
	DWORD		dwProgramType,			//SELECT,MOLP or RETAIL
	LPTSTR  *	ppszLKPLite
	)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	__int64		n64LKPLite = _ttoi(lpszProductCode);
	__int64		n64Qty = dwQuantity;
	__int64		n64SerialNo = dwSerialNum;
	__int64		n64dtOfExp = dwExpirationMos;
	__int64		n64Version = dwVersion;
	__int64		n64Upgrade = dwUpgrade;
	__int64		n64Program = dwProgramType;

	BYTE		bLKP[LKPLITE_LKP_LEN] = {0};

	//validate params
	if ( NULL == lpszPID || NULL == lpszProductCode ||
		 ( dwQuantity <= 0 || dwQuantity > 9999)  ||
		 ( dwSerialNum <= 0 || dwSerialNum >= 0xFFF ) ||
		 ( dwExpirationMos <= 0 || dwExpirationMos >= 255) ||
		 ( dwVersion <= 0 || dwVersion >= 99) ||
		 ( dwUpgrade != 1 && dwUpgrade != 0 ) ||
		 ( dwProgramType != LKPLITE_PROGRAM_SELECT && dwProgramType != LKPLITE_PROGRAM_MOLP &&
		   dwProgramType != LKPLITE_PROGRAM_RETAIL)
	   )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}

	//move the product code to extreme left
	n64LKPLite <<= 54;

	//move the quantity to position 
	n64Qty <<= 40;
	n64LKPLite |= n64Qty;
	
	//move Serial number into position
	n64SerialNo <<= 28;
	n64LKPLite |= n64SerialNo;

	//move Program Type into position
	n64Program	<<= 26;
	n64LKPLite |= n64Program;

	//move dt of expitration into position
	n64dtOfExp <<= 18;
	n64LKPLite |= n64dtOfExp;	

	//move Version into place
	n64Version <<= 11;
	n64LKPLite |= n64Version;
	//move upgrade in place
	n64Upgrade <<= 8;
	n64LKPLite |= n64Upgrade;
	//set the last 8 bits of this PID to 1's
	n64LKPLite |= LKPLITE_SPK_BITSTUFF;

	memcpy ( bLKP, ((BYTE *) &n64LKPLite) + 1, sizeof(n64LKPLite ) - 1);
/*
	dwRetCode =  CryptSignBatch(0, NULL, 7, bLKP, sizeof(abPrivateKey0),abPrivateKey0,
								sizeof(abPublicKey0), abPublicKey0, SIGNATURE_LEN,
								bLKP+7,1);
*/
	//sign the lkp here
	dwRetCode = CryptSign(0, NULL, 7, bLKP, sizeof(abLKPPrivateKey0), abLKPPrivateKey0,
						  sizeof(abLKPPublicKey0), abLKPPublicKey0, SIGNATURE_LEN,
						  bLKP+7);

	if (dwRetCode != SS_OK)
	{
		goto done;
	}

	//encrypt it with the pid passed in
	dwRetCode = LKPLiteEncryptUsingPID(lpszPID,
									   bLKP,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

//	memset ( bLKP, 0xFF, sizeof(bLKP));
	
	//now encode the spk
	dwRetCode =  B24EncodeMSID((PBYTE)bLKP, ppszLKPLite);
done:

	return dwRetCode;
}
#endif



//This function has to verify the LKP by decrypting it
//and matching the signature
DWORD LKPLiteVerifyLKP (
	LPTSTR		lpszPID,				//PID for verifying the LKP lite blob
	LPTSTR		pszLKPLite,				//B24 encoded LKP
	DWORD *		pdwVerifyResult
)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedLKP = NULL;
	*pdwVerifyResult = LKPLITE_LKP_VALID;

	//decode the SPK here
	dwRetCode =  B24DecodeMSID(pszLKPLite, &pbDecodedLKP);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}

	dwRetCode = LKPLiteDecryptUsingPID(lpszPID,
									   pbDecodedLKP,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//Call function to verify signature on SPK
	dwRetCode = CryptVerifySig(7, pbDecodedLKP, sizeof(abLKPPublicKey0),
							   abLKPPublicKey0, SIGNATURE_LEN, pbDecodedLKP+7);
	if (dwRetCode != SS_OK)
	{
		*pdwVerifyResult = LKPLITE_SPK_INVALID;
	}
	
done:	
	if (pbDecodedLKP != NULL)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedLKP);
	}

	return dwRetCode;
}


DWORD LKPLiteCrackLKP (
	LPTSTR		lpszPID,
	LPTSTR		pszLKPLite,
	LPTSTR		lpszProductCode,
	DWORD   *	pdwQuantity,
	DWORD   *	pdwSerialNum,
	DWORD   *	pdwExpirationMos,
	DWORD   *	pdwVersion,
	DWORD	*	pdwUpgrade,
	DWORD	*	pdwProgramType
)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedLKP = NULL;
	__int64		n64LKPLite = 0;
	__int64		n64ProductCode = 0;
	__int64		n64Qty = 0;
	__int64		n64SerialNo = 0;
	__int64		n64dtOfExp = 0;
	__int64		n64Version = 0;
	__int64		n64Upgrade = 0;
	__int64		n64Program = 0;

	if ( NULL == lpszPID || NULL == pszLKPLite ||
		 NULL == lpszProductCode || NULL == pdwQuantity || 
		 NULL == pdwSerialNum || NULL == pdwExpirationMos || 
		 NULL == pdwVersion || NULL == pdwUpgrade ||
		 NULL == pdwProgramType || NULL == pdwProgramType
	   )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}

	//decode and decrypt the lkp here

	dwRetCode =  B24DecodeMSID(pszLKPLite, &pbDecodedLKP);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}

	dwRetCode = LKPLiteDecryptUsingPID(lpszPID,
									   pbDecodedLKP,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//copy all the stuff into int64 type

	memcpy ( ((BYTE *) &n64LKPLite) + 1, pbDecodedLKP, sizeof(n64LKPLite ) - 1 );

	// Decrypt it using the PID
	n64ProductCode = n64LKPLite & LKPLITE_LKP_PRODUCT_MASK;
	n64ProductCode  >>= 54;

	//move the quantity to position 
	n64Qty = n64LKPLite & LKPLITE_LKP_QUANTITY_MASK;
	n64Qty >>= 40;
	
	//move Serial number into position
	n64SerialNo = n64LKPLite & LKPLITE_LKP_SERAIL_NO_MASK;
	n64SerialNo >>= 28;
	
	//move Program Type into position
	n64Program	= n64LKPLite & LKPLITE_LKP_PROGRAM_MASK;
	n64Program	>>= 26;

	//move dt of expitration into position
	n64dtOfExp = n64LKPLite & LKPLITE_LKP_EXP_DATE_MASK;
	n64dtOfExp >>= 18;
	
	//move Version into place
	n64Version = n64LKPLite & LKPLITE_LKP_VERSION_MASK;
	n64Version >>= 11;
	
	//move upgrade in place
	n64Upgrade = n64LKPLite & LKPLITE_LKP_UPG_FULL_MASK;
	n64Upgrade >>= 8;

done:

	if ( ERROR_SUCCESS == dwRetCode )
	{
		_stprintf(lpszProductCode, _T("%03d"), n64ProductCode);
//		_i64tot ( n64ProductCode, lpszProductCode, 10 );
		*pdwQuantity = (DWORD)n64Qty;
		*pdwSerialNum = (DWORD)n64SerialNo;
		*pdwExpirationMos = (DWORD)n64dtOfExp;
		*pdwVersion = (DWORD)n64Version;
		*pdwUpgrade = (DWORD)n64Upgrade;
		*pdwProgramType = (DWORD)n64Program;
	}
	if ( pbDecodedLKP )
		HeapFree ( GetProcessHeap(),0, pbDecodedLKP );

	return dwRetCode;
}



//internal functions
DWORD ValidatePID ( LPTSTR lpszPID )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwPIDLen = _tcslen( lpszPID );
	DWORD	dwCounter =0;

	if (  dwPIDLen != LKPLITE_PID_LEN )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
	}
	else
	{
		//check for syntax
		for ( dwCounter = 0; dwCounter < dwPIDLen; dwCounter ++ )
		{
			if ( !_istdigit ( *(lpszPID + dwCounter ) ) )
			{
				switch(dwCounter)
				{
				case 5:
					if (*(lpszPID + dwCounter ) != _T('-') )
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 6:
					if (*(lpszPID + dwCounter ) != _T('O') && *(lpszPID + dwCounter ) != _T('o') )					
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 7:
					if (*(lpszPID + dwCounter ) != _T('E') && *(lpszPID + dwCounter ) != _T('e') )					
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 8:
					if (*(lpszPID + dwCounter ) != _T('M') && *(lpszPID + dwCounter ) != _T('m') )					
						dwRetCode = ERROR_INVALID_PARAMETER;												
					break;
				case 9:
					if (*(lpszPID + dwCounter ) != _T('-') )
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 17:
					if (*(lpszPID + dwCounter ) != _T('-') )
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				default:				
					dwRetCode = ERROR_INVALID_PARAMETER;
				}
			}
            else
            {
                switch(dwCounter)
                {
                    case 5:
                    case 9:
                    case 17:
                        dwRetCode = ERROR_INVALID_PARAMETER;
                        break;
                }
            }
		}
	}
	//can check here for mod 7 thing too but for now assume its OK.
	return dwRetCode;
}

//Assume that the PID comming in has aleady been validated
__int64 GetSPKIDFromPID ( LPTSTR lpszPID )
{
	__int64 n64PID;
	TCHAR	szPID[12] = {0};
	
	memcpy ( szPID, lpszPID + 10, 6 * sizeof(TCHAR));
	memcpy ( szPID + 6, lpszPID+ 18, 5 * sizeof(TCHAR));
	n64PID = _ttoi64(szPID);
	return n64PID;
}



DWORD LKPLiteGenConfNumber(LPTSTR	lpszLSID,
						   LPTSTR	lpszPID,
					       LPTSTR	*lpszConfirmation)
{
	BYTE * pbDecodedData = NULL;
	DWORD dwRetCode = ERROR_SUCCESS;
	DWORD dwConfirmation;

	// lpszLSID is base 24 encoded, so decode it first
	dwRetCode = B24DecodeMSID(lpszLSID, &pbDecodedData);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Decoded Data is available.  Copy the leading 4 bytes for generating the confirmation
	// Number
	memcpy(&dwConfirmation, pbDecodedData, sizeof(DWORD));

	// Encrypt this number using the PID
	dwRetCode = LKPLiteEncryptUsingPID(lpszPID, (BYTE *) &dwConfirmation, sizeof(DWORD));
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	
	// Now Encode the Encrypted stream
	dwRetCode = B24EncodeCNumber((BYTE *) &dwConfirmation, lpszConfirmation);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	
done:
	if (pbDecodedData)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedData);
	}

	return dwRetCode;
}





DWORD LKPLiteValConfNumber(LPTSTR	lpszLSID,
					   	   LPTSTR	lpszPID,
					       LPTSTR	lpszConfirmation)
{
	BYTE * pbDecodedLSID = NULL;
	BYTE * pbDecodedConf = NULL;
	DWORD dwRetCode = ERROR_SUCCESS;

	// lpszLSID is base 24 encoded, so decode it first
	dwRetCode = B24DecodeMSID(lpszLSID, &pbDecodedLSID);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Decode Confirmation Number
	dwRetCode = B24DecodeCNumber(lpszConfirmation, &pbDecodedConf);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Decrypt the leading 4 bytes 
	dwRetCode = LKPLiteDecryptUsingPID(lpszPID, pbDecodedConf, sizeof(DWORD));
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}


	if (memcmp(pbDecodedLSID, pbDecodedConf, sizeof(DWORD)) != 0)
	{
		// does not match
		dwRetCode = LKPLITE_INVALID_CONFNUM;
	}
	
done:
	if (pbDecodedLSID)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedLSID);
	}

	if (pbDecodedConf)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedConf);
	}

	return dwRetCode;
}


/////////////////////////////////////////////////////////

DWORD WINAPI
EncryptDecryptData(
    IN PBYTE pbParm,
    IN DWORD cbParm,
    IN OUT PBYTE pbData,
    IN DWORD cbData
    )
/*++

Abstract:

    Internal routine to encrypt/decrypt a blob of data

Parameter:

    pbParm : binary blob to generate encrypt/decrypt key.
    cbParm : size of binary blob.
    pbData : data to be encrypt/decrypt.
    cbData : size of data to be encrypt/decrypt.

Returns:

    ERROR_SUCCESS or error code.

Remark:


--*/
{
    DWORD dwRetCode = ERROR_SUCCESS;
    MD5_CTX md5Ctx;
    RC4_KEYSTRUCT rc4KS;
    BYTE key[16];
    int i;

    if(NULL == pbParm || 0 == cbParm)
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        return dwRetCode;
    }

    MD5Init(&md5Ctx);
    MD5Update(
            &md5Ctx,
            pbParm,
            cbParm
        );

    MD5Final(&md5Ctx);

    memset(key, 0, sizeof(key));

    for(i=0; i < 5; i++)
    {
        key[i] = md5Ctx.digest[i];
    }        

    //
    // Call RC4 to encrypt/decrypt data
    //
    rc4_key(
            &rc4KS, 
            sizeof(key), 
            key 
        );

    rc4(&rc4KS, cbData, pbData);

	return dwRetCode;
}

DWORD LKPLiteEncryptUsingPID(LPTSTR lpszPID,
							 BYTE * pbBufferToEncrypt,
							 DWORD dwLength)
{
	DWORD dwRetCode = ERROR_SUCCESS;

#if 1

    dwRetCode = EncryptDecryptData(
                                (PBYTE) lpszPID,
                                lstrlen(lpszPID)*sizeof(TCHAR),
                                pbBufferToEncrypt,
                                dwLength
                            );


#else

	BOOL bRet;
	HCRYPTPROV hProv = NULL;
	HCRYPTKEY hCKey = NULL;
	HCRYPTHASH hHash = NULL;

	bRet = CryptAcquireContext(&hProv,
							   NULL,
							   NULL,
							   PROV_RSA_FULL,
							   CRYPT_VERIFYCONTEXT);

	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}


	bRet = CryptCreateHash(hProv,
						   CALG_MD5,
						   0,
						   0,
						   &hHash);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptHashData(hHash,
						 (BYTE *) lpszPID,
						 lstrlen(lpszPID)*sizeof(TCHAR),
						 0);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptDeriveKey(hProv,
						  CALG_RC4,
						  hHash,
						  0,
						  &hCKey);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptEncrypt(hCKey,
						0,
						TRUE,
						0,
						pbBufferToEncrypt,
						&dwLength,
						dwLength);

	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

done:
	if (hCKey != NULL)
	{
		bRet = CryptDestroyKey(hCKey);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hHash != NULL)
	{
		bRet = CryptDestroyHash(hHash);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hProv != NULL)
	{
		bRet = CryptReleaseContext( hProv, 0 );

		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

#endif

	return dwRetCode;
}





DWORD LKPLiteDecryptUsingPID(LPTSTR lpszPID,
				 			 BYTE * pbBufferToDecrypt,
							 DWORD dwLength)
{
	DWORD dwRetCode = ERROR_SUCCESS;

#if 1

    dwRetCode = EncryptDecryptData(
                                (PBYTE) lpszPID,
                                lstrlen(lpszPID)*sizeof(TCHAR),
                                pbBufferToDecrypt,
                                dwLength
                            );
#else

	BOOL bRet;
	HCRYPTPROV hProv = NULL;
	HCRYPTKEY hCKey = NULL;
	HCRYPTHASH hHash = NULL;

	bRet = CryptAcquireContext(&hProv,
							   NULL,
							   NULL,
							   PROV_RSA_FULL,
							   CRYPT_VERIFYCONTEXT);

	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}


	bRet = CryptCreateHash(hProv,
						   CALG_MD5,
						   0,
						   0,
						   &hHash);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptHashData(hHash,
						 (BYTE *) lpszPID,
						 lstrlen(lpszPID)*sizeof(TCHAR),
						 0);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptDeriveKey(hProv,
						  CALG_RC4,
						  hHash,
						  0,
						  &hCKey);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptDecrypt(hCKey,
						0,
						TRUE,
						0,
						(BYTE *) pbBufferToDecrypt,
						&dwLength);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

done:
	if (hCKey != NULL)
	{
		bRet = CryptDestroyKey(hCKey);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hHash != NULL)
	{
		bRet = CryptDestroyHash(hHash);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hProv != NULL)
	{
		bRet = CryptReleaseContext( hProv, 0 );

		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

#endif

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\tlshunt.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#if !defined(AFX_TLSHUNT_H__9C41393C_53C6_11D2_BDDF_00C04FA3080D__INCLUDED_)
#define AFX_TLSHUNT_H__9C41393C_53C6_11D2_BDDF_00C04FA3080D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TlsHunt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTlsHunt dialog
class CMainFrame;

typedef struct __ServerEnumData {
    CDialog* pWaitDlg;
    CMainFrame* pMainFrm;
    DWORD dwNumServer;
    long dwDone;
} ServerEnumData;

#define WM_DONEDISCOVERY    (WM_USER+0x666)

class CTlsHunt : public CDialog
{
    static BOOL
    ServerEnumCallBack(
        TLS_HANDLE hHandle,
        LPCTSTR pszServerName,
        HANDLE dwUserData
    );

    static DWORD WINAPI
    DiscoveryThread(PVOID ptr);

    ServerEnumData m_EnumData;
    HANDLE m_hThread;

// Construction
public:

    BOOL
    IsUserCancel() {
        return m_EnumData.dwDone;
    }

    DWORD 
    GetNumServerFound() {
        return m_EnumData.dwNumServer;
    }

	CTlsHunt(CWnd* pParent = NULL);   // standard constructor
    ~CTlsHunt();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTlsHunt)
	enum { IDD = IDD_DISCOVERY };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTlsHunt)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTlsHunt)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual void OnCancel();
	afx_msg void OnDoneDiscovery();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TLSHUNT_H__9C41393C_53C6_11D2_BDDF_00C04FA3080D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lkplite\base24.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include <math.h>


class CDataCoding {
private:
	DWORD m_dwBaseDigits;

	DWORD m_dwEncodedLength;
	DWORD m_dwInputDataBits;
	DWORD m_dwInputDataBytes;

	DWORD m_dwDecodedLength;
	DWORD m_dwInputEncDataBytes;
	DWORD m_dwDecodedBits;

	TCHAR * m_tpBaseDigits;
	
public:
	CDataCoding(TCHAR * tpBaseDigits = NULL);

	void SetInputDataBitLen(DWORD dwBits);
	void SetInputEncDataLen(DWORD dwChars);
	DWORD SetBaseDigits(TCHAR * tpBaseDigits);
	DWORD EncodeData(LPBYTE pbSource,  //[IN]  Stream of Bytes to be encoded
					 TCHAR **pbEncodedData); //[OUT] Pointer to a string containing the encoded data
	DWORD DecodeData(TCHAR * pbEncodedData,
					 LPBYTE * pbDecodedData);

	~CDataCoding();
};


class CBase24Coding : public CDataCoding {
public:
	CBase24Coding(void) : CDataCoding(L"BCDFGHJKMPQRTVWXY2346789")
	{
		return;
	}
};







static CBase24Coding b24Global; 


// **************************************************************
DWORD B24EncodeMSID(LPBYTE pbSource, TCHAR **pbEncodedData)
{
	b24Global.SetInputDataBitLen(160);

	return b24Global.EncodeData(pbSource, pbEncodedData);
}


// ***************************************************************
DWORD B24DecodeMSID(TCHAR * pbEncodedData, LPBYTE * pbDecodedData)
{
	b24Global.SetInputEncDataLen(35);

	return b24Global.DecodeData(pbEncodedData, pbDecodedData);
}




// ***********************************************************
DWORD B24EncodeCNumber(LPBYTE pbSource, TCHAR **pbEncodedData)
{
	b24Global.SetInputDataBitLen(32);

	return b24Global.EncodeData(pbSource, pbEncodedData);
}


// ******************************************************************
DWORD B24DecodeCNumber(TCHAR * pbEncodedData, LPBYTE * pbDecodedData)
{
	b24Global.SetInputEncDataLen(7);

	return b24Global.DecodeData(pbEncodedData, pbDecodedData);
}




// *******************************************************
DWORD B24EncodeSPK(LPBYTE pbSource, TCHAR **pbEncodedData)
{
	b24Global.SetInputDataBitLen(114);

	return b24Global.EncodeData(pbSource, pbEncodedData);
}


// ******************************************************************
DWORD B24DecodeSPK(TCHAR * pbEncodedData, LPBYTE * pbDecodedData)
{
	b24Global.SetInputEncDataLen(25);

	return b24Global.DecodeData(pbEncodedData, pbDecodedData);
}



// *****************************************
CDataCoding::CDataCoding(TCHAR * tpBaseDigits)
{
	m_tpBaseDigits = NULL;
	m_dwBaseDigits = 0;
	m_dwEncodedLength = 0;
	m_dwInputDataBits = 0;
	m_dwInputDataBytes = 0;
	SetBaseDigits(tpBaseDigits);
}



// ********************************************
void CDataCoding::SetInputDataBitLen(DWORD dwBits)
{
	assert(dwBits > 0);
	assert(log(m_dwBaseDigits) > 0);

	// Determine How many Characters would be required to encode the data
	// What we have is a dwDataLength of Binary Data stream.
	// So, we can represent 2^(dwDataLength*8) amount of information using these bits
	// Assuming that our set of digits (which form the base for encoding) is X,
	// the above number should then equal X^(NumberofEncoded Digits)
	// So,
	double dLength = ((double) dwBits*log10(2)) /
					 ((double) log10(m_dwBaseDigits));

	// Now round - up
	m_dwEncodedLength = (DWORD) dLength;

	if ((double) m_dwEncodedLength < dLength)
	{
		// There was a decimal part
		m_dwEncodedLength++;
	}
	m_dwInputDataBits = dwBits;
	m_dwInputDataBytes = (dwBits / 8) + (dwBits % 8 ? 1 : 0);

	return;
}





// ***********************************************
void CDataCoding::SetInputEncDataLen(DWORD dwBytes)
{
	assert(dwBytes > 0);
	assert(log(m_dwBaseDigits) > 0);

	m_dwInputEncDataBytes = dwBytes;
	// Determine How many bits would be required to decode this data
	// So,

	double dLength = ((double) dwBytes*log10(m_dwBaseDigits))/
					 ((double) log10(2));

	// Now round - up
	m_dwDecodedBits = (DWORD) dLength;

	if ((double) m_dwDecodedBits < dLength)
	{
		// There was a decimal part
		m_dwDecodedBits++;
	}

	m_dwDecodedLength = (m_dwDecodedBits / 8) + (m_dwDecodedBits % 8 ? 1 : 0);

	return;
}




// **************************************************
DWORD CDataCoding::SetBaseDigits(TCHAR * tpBaseDigits)
{
	DWORD dwReturn = ERROR_SUCCESS;

	if (tpBaseDigits != NULL)
	{
		DWORD dwLen = wcslen(tpBaseDigits);
		assert(dwLen > 0);
		m_tpBaseDigits = (TCHAR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (dwLen+1)*sizeof(TCHAR));
		if (m_tpBaseDigits == NULL)
		{
			dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		}
		else
		{
			memcpy(m_tpBaseDigits, tpBaseDigits, (dwLen+1)*sizeof(TCHAR));
			m_dwBaseDigits = dwLen;
		}
	}
	else
	{
		if (m_tpBaseDigits != NULL)
		{
			HeapFree(GetProcessHeap(), 0, m_tpBaseDigits);
			m_tpBaseDigits = NULL;
			m_dwBaseDigits = 0;
		}
		assert(m_tpBaseDigits == NULL && m_dwBaseDigits == 0);
	}

	return dwReturn;
}







// ************************************************
DWORD CDataCoding::EncodeData(LPBYTE pbSource,  //[IN]  Stream of Bytes to be encoded
		 					  TCHAR **pbEncodedData)	 //[OUT] Pointer to a string containing the encoded data
// I allocate the Buffer, you should free it
{
	assert(m_dwInputDataBits > 0);
	assert(m_dwInputDataBytes > 0);
	assert(m_dwEncodedLength > 0);
	assert(m_tpBaseDigits != NULL);

	DWORD dwReturn = ERROR_SUCCESS;
	int nStartIndex = m_dwEncodedLength;
	*pbEncodedData = NULL;
	BYTE * pbDataToEncode = NULL;
	TCHAR * pbEncodeBuffer = NULL;

    if (NULL == pbEncodedData)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto done;
    }

    *pbEncodedData = NULL;

    pbEncodeBuffer = (TCHAR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
										(m_dwEncodedLength+1)*sizeof(TCHAR));
	if (pbEncodeBuffer == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		goto done;
	}

	// Now need to make a copy of the incoming data, so we can run the algorithm below
	pbDataToEncode = (BYTE *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwInputDataBytes);
	if (pbDataToEncode == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		goto done;
	}
	memcpy(pbDataToEncode, pbSource, m_dwInputDataBytes);
	

	// Let us get rid of the simple stuff
	pbEncodeBuffer[ nStartIndex--] = 0;

    for (; nStartIndex >= 0; --nStartIndex)
    {
        unsigned int i = 0;

        for (int nIndex = m_dwInputDataBytes-1; 0 <= nIndex; --nIndex)
        {
            i = (i * 256) + pbDataToEncode[nIndex];
            pbDataToEncode[ nIndex] = (BYTE)(i / m_dwBaseDigits);
            i %= m_dwBaseDigits;
        }
	
        // i now contains the remainder, which is the current digit
        pbEncodeBuffer[ nStartIndex] = m_tpBaseDigits[ i];
    }
	
	assert(dwReturn == ERROR_SUCCESS);
	*pbEncodedData = pbEncodeBuffer;

done:
	if (pbDataToEncode != NULL)
	{
		HeapFree(GetProcessHeap(), 0, pbDataToEncode);
	}

	if (dwReturn != ERROR_SUCCESS)
	{
		// There was an error, so free the memory that you allocated
		if (pbEncodeBuffer != NULL)
		{
			HeapFree(GetProcessHeap(), 0, pbEncodeBuffer);
		}
	}
	return dwReturn;
}





// *************************************************
DWORD CDataCoding::DecodeData(TCHAR * pbEncodedData,
							 LPBYTE * pbDecodedData)
// Again, I allocate the Buffer, you release it
{
	assert(m_dwDecodedBits > 0);
	assert(m_dwDecodedLength > 0);
	assert(m_tpBaseDigits != NULL);
	assert((DWORD) lstrlen(pbEncodedData) == m_dwInputEncDataBytes);

	DWORD dwReturn = ERROR_SUCCESS;
	TCHAR * tpTemp;
	DWORD dwDigit;
	unsigned int i;
	unsigned int nDecodedBytes, nDecodedBytesMax = 0;
	BYTE * pbDecodeBuffer = NULL;

    if (NULL == pbDecodedData)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto done;
    }

	*pbDecodedData = NULL;

    pbDecodeBuffer = (BYTE *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwDecodedLength);
	if ( pbDecodeBuffer == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		goto done;
	}
	
	memset(pbDecodeBuffer, 0, m_dwDecodedLength);

	while (*pbEncodedData)
	{
		// First Find the position of this character in the Base Encoding Character Set
		tpTemp = wcschr(m_tpBaseDigits, *pbEncodedData);
		if (tpTemp == NULL)
		{
			// Found a character which is not in base character set
			// ERROR ERROR
			dwReturn = ERROR_INVALID_DATA;
			goto done;
		}
		dwDigit = (DWORD)(tpTemp - m_tpBaseDigits);

        nDecodedBytes = 0;
        i = (unsigned int) dwDigit;

        while (nDecodedBytes <= nDecodedBytesMax)
        {
            i += m_dwBaseDigits * pbDecodeBuffer[ nDecodedBytes];
            pbDecodeBuffer[ nDecodedBytes] = (unsigned char)i;
            i /= 256;
            ++nDecodedBytes;
        }

        if (i != 0)
        {
			assert(nDecodedBytes < m_dwDecodedLength);

            pbDecodeBuffer[ nDecodedBytes] = (unsigned char)i;
            nDecodedBytesMax = nDecodedBytes;
        }

		pbEncodedData++;
	}

	assert(dwReturn == ERROR_SUCCESS);
	*pbDecodedData = pbDecodeBuffer;
	
done:
	if (dwReturn != ERROR_SUCCESS)
	{
		// There was an error, so free the memory that you allocated
		if (pbDecodeBuffer != NULL)
		{
			HeapFree(GetProcessHeap(), 0, pbDecodeBuffer);
		}
	}

	return dwReturn;
}






// **********************
CDataCoding::~CDataCoding()
{
	if (m_tpBaseDigits != NULL)
	{
		HeapFree(GetProcessHeap(), 0, m_tpBaseDigits);
		m_tpBaseDigits = NULL;
		m_dwBaseDigits = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lkplite\lkplite.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __LKPLITE__H__
#define __LKPLITE__H__



//SPK Stuff
#define LKPLITE_SPK_SELECT		1
#define LKPLITE_SPK_BASIC		0
#define LKPLITE_SPK_UNKNOWN		2

#define LKPLITE_SPK_LEN				25
//SPK Masks
#define LKPLITE_SPK_SELECT_MASK		0x0000200000000000
#define LKPLITE_SPK_BASIC_MASK		0x0000000000000000
#define LKPLITE_SPK_PID_MASK		0x00001FFFFFFFFF00
#define LKPLITE_SPK_UNIQUEID_MASK	0xFFFFC00000000000


#define LKPLITE_SPK_INVALID			1
#define LKPLITE_SPK_VALID			2
#define LKPLITE_SPK_INVALID_SIGN	3
#define LKPLITE_INVALID_CONFNUM		4


//LKP Stuff
#define	LKPLITE_PROGRAM_SELECT		0x0
#define	LKPLITE_PROGRAM_MOLP		0x1
#define	LKPLITE_PROGRAM_RETAIL		0x2

#define LKPLITE_LKP_LEN				25
#define LKPLITE_LKP_INVALID			1
#define LKPLITE_LKP_VALID			2
#define LKPLITE_LKP_INVALID_SIGN	3
//LKP Masks
#define LKPLITE_LKP_PRODUCT_MASK	0xFFC0000000000000
#define LKPLITE_LKP_QUANTITY_MASK	0x003FFF0000000000
#define LKPLITE_LKP_SERAIL_NO_MASK	0x000000FFF0000000
#define	LKPLITE_LKP_PROGRAM_MASK	0x000000000C000000
#define LKPLITE_LKP_EXP_DATE_MASK	0x0000000003FC0000
#define LKPLITE_LKP_VERSION_MASK	0x000000000003F800
#define LKPLITE_LKP_UPG_FULL_MASK	0x0000000000000700


//function declarations for SPK portion of the LKPLite
DWORD LKPLiteGenSPK ( 
	LPTSTR   pszPID,			//PID for the product.  Should include the installation number
	DWORD	 dwUniqueId,		//unique Id to be put in the SPK
	short	 nSPKType,			//Can be 1 for select or 0 for BASIC
	LPTSTR * ppszSPK
	);

DWORD LKPLiteVerifySPK (
	LPTSTR	pszPID,			//PID to validate against
	LPTSTR	pszSPK,
	DWORD *	pdwVerifyResult
	);

DWORD LKPLiteCrackSPK  (
	LPTSTR		pszPID,	
	LPTSTR		pszSPK,			//Pointer to SPK
	LPTSTR		pszPIDPart,		//PID Part of SPK
	DWORD  *	pdwUniqueId,	//uniqueId part of SPK
	short  *	pnSPKType		//Type of SPK - Select/Basic
	);
//function declarations for LKP portion of the LKPLite
DWORD LKPLiteGenLKP (
	LPTSTR		lpszPID,				//used for encrypting the LKPLite structure
	LPTSTR		lpszProductCode,		//Product Code
	DWORD		dwQuantity,				//quantity
	DWORD		dwSerialNum,			//serail number of SPK
	DWORD		dwExpirationMos,		//expiration in number of months from today
	DWORD		dwVersion,				//version number can be upto 99
	DWORD		dwUpgrade,				//upgrade or full license
	DWORD		dwProgramType,			//SELECT,MOLP or RETAIL
	LPTSTR  *	ppszLKPLite
	);

DWORD LKPLiteVerifyLKP (
	LPTSTR		lpszPID,				//PID for verifying the LKP lite blob
	LPTSTR		pszLKPLite,				//B24 encoded LKP
	DWORD *		pdwVerifyResult
);

DWORD LKPLiteCrackLKP (
	LPTSTR		lpszPID,
	LPTSTR		pszLKPLite,
	LPTSTR		lpszProductCode,
	DWORD   *	pdwQuantity,
	DWORD   *	pdwSerialNum,
	DWORD   *	pdwExpitaitonMos,
	DWORD   *	pdwVersion,
	DWORD	*	pdwUpgrade,
	DWORD	*	pdwProgramType
);

DWORD LKPLiteEncryptUsingPID(LPTSTR lpszPID,
							 BYTE * pbBufferToEncrypt,
							 DWORD dwLength);
DWORD LKPLiteDecryptUsingPID(LPTSTR lpszPID,
							 BYTE * pbBufferToEncrypt,
							 DWORD dwLength);
DWORD LKPLiteGenConfNumber(LPTSTR	lpszLSID,
					  	   LPTSTR	lpszPID,
					       LPTSTR	*lpszConfirmation);
DWORD LKPLiteValConfNumber(LPTSTR	lpszLSID,
						   LPTSTR	lpszPID,
					       LPTSTR	lpszConfirmation);

#endif	//__LKPLITE__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\chltype.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"

LRW_DLG_INT CALLBACK
CustInfoLicenseType(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			TCHAR szBuffer[ 1024];
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

			//
			//By default Check the first RADIO button.
			//
			SendDlgItemMessage(hwnd,IDC_RD_REG_SELECT,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);  
			LoadString(GetInstanceHandle(), IDS_SELECT_DESCRIPTION,
					   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
			SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
							   WM_SETTEXT,(WPARAM)0,
							   (LPARAM)(LPCTSTR)szBuffer);
		}
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == BN_CLICKED)
		{
			TCHAR szBuffer[ 1024];

			switch ( LOWORD(wParam) )       //from which control
			{
			case IDC_RD_REG_SELECT:
				LoadString(GetInstanceHandle(), IDS_SELECT_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				break;

			case IDC_RD_REG_MOLP:
				LoadString(GetInstanceHandle(), IDS_OPEN_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				break;

			case IDC_RD_REG_OTHER:
				LoadString(GetInstanceHandle(), IDS_OTHER_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				break;
			}
		}
		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				if(SendDlgItemMessage(hwnd,IDC_RD_REG_SELECT,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					GetGlobalContext()->GetContactDataObject()->sProgramName = PROGRAM_SELECT;
				}
				else if (SendDlgItemMessage(hwnd,IDC_RD_REG_MOLP,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					GetGlobalContext()->GetContactDataObject()->sProgramName = PROGRAM_MOLP;
				}
				else 
				{
					GetGlobalContext()->GetContactDataObject()->sProgramName = PROGRAM_RETAIL;
				}
				
				//
				// Check the Certificate is valid for the Selected Program
				//
				if (!CheckProgramValidity(GetGlobalContext()->GetContactDataObject()->sProgramName))
				{
					LRMessageBox(hwnd,IDS_ERR_CERT_NOT_ENOUGH);
					dwNextPage = IDD_LICENSETYPE;
				}
				else
				{
					dwNextPage = IDD_CONTACTINFO1;
				}

				GetGlobalContext()->SetInRegistery(szOID_BUSINESS_CATEGORY, GetGlobalContext()->GetContactDataObject()->sProgramName);

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
				
				if (dwNextPage != IDD_LICENSETYPE)
				{
					LRPush(IDD_LICENSETYPE);
				}

                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\chselect.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"


LRW_DLG_INT CALLBACK
CHRegisterSelectDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			CString sProductType;

			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );
			
			SendDlgItemMessage(hwnd, IDC_TXT_ENROLLMENT_NUMBER,	EM_SETLIMITTEXT, CH_SELECT_ENROLLMENT_NUMBER,0);
			SendDlgItemMessage(hwnd, IDC_TXT_QUANTITY,			EM_SETLIMITTEXT, CH_QTY_LEN,0);

			PopulateProductComboBox(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE));

			//
			//Set the properties of the up-down control
			//
			SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETBUDDY, (WPARAM)(HWND)GetDlgItem(hwnd,IDC_TXT_QUANTITY),(LPARAM)0);
			SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETRANGE, 0,(LPARAM) MAKELONG (9999, 1));

		}		
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString sProductCode;
					CString sProduct;
					CString sAgreementNumber;
					CString sEnrollmentNumber;
					CString sQuantity;
					LPTSTR  lpVal = NULL;					
					TCHAR   lpBuffer[ 128];
					DWORD   dwRetCode;
					int		nCurSel = -1;

					//
					//Read all the fields
					//
					lpVal = sEnrollmentNumber.GetBuffer(CH_SELECT_ENROLLMENT_NUMBER+1);
					GetDlgItemText(hwnd,IDC_TXT_ENROLLMENT_NUMBER,lpVal,CH_SELECT_ENROLLMENT_NUMBER+1);
					sEnrollmentNumber.ReleaseBuffer(-1);
					
					lpVal = sQuantity.GetBuffer(CH_QTY_LEN+2);
					GetDlgItemText(hwnd,IDC_TXT_QUANTITY, lpBuffer,CH_QTY_LEN+2);
					TCHAR *lpStart = lpBuffer;
					do 
					{
						if (*lpStart != (TCHAR) ',')
						{
							*lpVal++ = *lpStart;
						}
					} while ( *lpStart++ );
					sQuantity.ReleaseBuffer(-1);

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE));

					lpVal = sProduct.GetBuffer(LR_PRODUCT_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE), nCurSel, lpVal);
					sProduct.ReleaseBuffer(-1);

					// Send Product Code instead of Desc -- 01/08/99
					lpVal = sProductCode.GetBuffer(16);
					GetProductCode(sProduct,lpVal);
					sProductCode.ReleaseBuffer(-1);

					sProductCode.TrimLeft(); sProductCode.TrimRight();
					sEnrollmentNumber.TrimLeft();sEnrollmentNumber.TrimRight();
					sQuantity.TrimLeft(); sQuantity.TrimRight();
					
					if(
						sProduct.IsEmpty()			||
						sEnrollmentNumber.IsEmpty()	||
						sQuantity.IsEmpty()
					   )
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						dwNextPage	= IDD_CH_REGISTER_SELECT;
						goto NextDone;
					}

					if(
						!ValidateLRString(sProduct)			||
						!ValidateLRString(sAgreementNumber)	||
						!ValidateLRString(sEnrollmentNumber)
					  )
						
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						dwNextPage = IDD_CH_REGISTER_SELECT;
						goto NextDone;
					}
					
					if(_wtoi(sQuantity) < 1)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_QTY);
						dwNextPage	= IDD_CH_REGISTER_SELECT;
						goto NextDone;
					}

					GetGlobalContext()->GetLicDataObject()->sSelProductType		= sProductCode; //sProduct;
					GetGlobalContext()->GetLicDataObject()->sSelProductDesc		= sProduct;
					GetGlobalContext()->GetLicDataObject()->sSelMastAgrNumber	= sAgreementNumber;
					GetGlobalContext()->GetLicDataObject()->sSelEnrollmentNumber = sEnrollmentNumber;
					GetGlobalContext()->GetLicDataObject()->sSelQty				= sQuantity;

//					dwNextPage = IDD_PROCESSING;

                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_CH_REGISTER_SELECT);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\chmolp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"

LRW_DLG_INT CALLBACK
CHRegisterMOLPDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		SendDlgItemMessage(hwnd, IDC_TXT_AUTH_NUMBER,		EM_SETLIMITTEXT, CH_MOLP_AUTH_NUMBER_LEN	,0);		
		SendDlgItemMessage(hwnd, IDC_TXT_AGREEMENT_NUMBER,	EM_SETLIMITTEXT, CH_MOLP_AGREEMENT_NUMBER_LEN,0);
		SendDlgItemMessage(hwnd, IDC_TXT_QUANTITY,			EM_SETLIMITTEXT, CH_QTY_LEN,0);
		
		//
		//Set the properties of the up-down control
		//
		SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETBUDDY, (WPARAM)(HWND)GetDlgItem(hwnd,IDC_TXT_QUANTITY),(LPARAM)0);
		SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETRANGE, 0,(LPARAM) MAKELONG (9999, 1));
		

		PopulateProductComboBox(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE));
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString sProductCode;
					CString sProduct;
					CString sAgreementNumber;
					CString sCustomerName;
					CString sAuthNo;
					CString sQuantity;
					LPTSTR  lpVal = NULL;
					TCHAR   lpBuffer[ 128];
					DWORD   dwRetCode;
					int		nCurSel = -1;

					//
					//Read all the fields
					//
					lpVal = sAgreementNumber.GetBuffer(CH_MOLP_AGREEMENT_NUMBER_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_AGREEMENT_NUMBER,lpVal,CH_MOLP_AGREEMENT_NUMBER_LEN+1);
					sAgreementNumber.ReleaseBuffer(-1);

					lpVal = sAuthNo.GetBuffer(CH_MOLP_AUTH_NUMBER_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_AUTH_NUMBER,lpVal,CH_MOLP_AUTH_NUMBER_LEN+1);
					sAuthNo.ReleaseBuffer(-1);
					
					lpVal = sQuantity.GetBuffer(CH_QTY_LEN+2);
					GetDlgItemText(hwnd,IDC_TXT_QUANTITY, lpBuffer,CH_QTY_LEN+2);
					TCHAR *lpStart = lpBuffer;
					do 
					{
						if (*lpStart != (TCHAR) ',')
						{
							*lpVal++ = *lpStart;
						}
					} while ( *lpStart++ );

					sQuantity.ReleaseBuffer(-1);

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE));

					lpVal = sProduct.GetBuffer(LR_PRODUCT_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE), nCurSel, lpVal);
					sProduct.ReleaseBuffer(-1);

					// Send Product Code instead of Desc -- 01/08/99
					lpVal = sProductCode.GetBuffer(16);
					GetProductCode(sProduct,lpVal);
					sProductCode.ReleaseBuffer(-1);

					sProductCode.TrimLeft();		sProductCode.TrimRight();
					sAgreementNumber.TrimLeft();	sAgreementNumber.TrimRight();
					sAuthNo.TrimLeft();				sAuthNo.TrimRight();
					sQuantity.TrimLeft();			sQuantity.TrimRight();					
					

					if(
						sProduct.IsEmpty()			||
						sAgreementNumber.IsEmpty()	||
						sAuthNo.IsEmpty()			||
						sQuantity.IsEmpty()									
					   )
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);
						dwNextPage	= IDD_CH_REGISTER_MOLP;
						goto NextDone;
					}

					if(
						!ValidateLRString(sProduct)			||
						!ValidateLRString(sAgreementNumber)	||
						!ValidateLRString(sAuthNo)
					  )
						
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						dwNextPage = IDD_CH_REGISTER_MOLP;
						goto NextDone;
					}

					if(_wtoi(sQuantity) < 1)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_QTY);
						dwNextPage	= IDD_CH_REGISTER_MOLP;
						goto NextDone;
					}

					GetGlobalContext()->GetLicDataObject()->sMOLPProductType		= sProductCode; //sProduct;
					GetGlobalContext()->GetLicDataObject()->sMOLPProductDesc		= sProduct;
					GetGlobalContext()->GetLicDataObject()->sMOLPAgreementNumber	= sAgreementNumber;
					GetGlobalContext()->GetLicDataObject()->sMOLPAuthNumber			= sAuthNo;
					GetGlobalContext()->GetLicDataObject()->sMOLPQty				= sQuantity;

//					dwNextPage = IDD_PROCESSING;
                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_CH_REGISTER_MOLP);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\chstruct.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#include "winsock2.h"
#include "httpext.h"
#include "assert.h"
#pragma warning(disable:4200)

//
// Version Number for the CH Structs. (Build Number) 
//
#define CH_STRUCTS_VERSION_RC1		11
#define	CH_STRUCTS_CURRENT_VERSION	35


#define MAX_RETAILSPKCOUNT			20
#define LSSPK_LEN					96
#define PIN_LEN						96
#define REQUEST_ID_LEN				64
#define CA_CUSTMER_NAME_LEN			60
#define CA_ORG_UNIT_LEN				60
#define CA_ADDRESS_LEN				200
#define CA_CITY_LEN					30 
#define CA_STATE_LEN				30
#define CA_COUNTRY_LEN				2
#define CA_ZIP_LEN					16 
#define CA_NAME_LEN					30
#define CA_PHONE_LEN				64
#define CA_FAX_LEN					64
#define CA_EMAIL_LEN				64
#define CA_REVOKE_REASONCODE_LEN	4
#define CA_LSERVERID_LEN			32
#define PROGRAM_NAME_LEN			64
#define MAX_CERTTYPE_LEN			32

//Retail SPK Return Values
#define RETAIL_SPK_NULL						((TCHAR)'0')	
#define RETAIL_SPK_OK						((TCHAR)'1')
#define RETAIL_SPK_INVALID_SIGNATURE		((TCHAR)'2')
#define RETAIL_SPK_INVALID_PRODUCT_TYPE		((TCHAR)'3')
#define RETAIL_SPK_INVALID_SERIAL_NUMBER	((TCHAR)'4')
#define RETAIL_SPK_ALREADY_REGISTERED		((TCHAR)'5')
#define RETAIL_MAX_LENGTH					25			//25 TCHARS

//Select/Open override
#define OVERRIDE_MAX_SIZE                   10

typedef struct _CERTCUSTINFO_TAG_
{
	TCHAR	OrgName[CA_CUSTMER_NAME_LEN+1];
	TCHAR	OrgUnit[CA_ORG_UNIT_LEN+1];
	TCHAR	Address[CA_ADDRESS_LEN+1];
	TCHAR	City[CA_CITY_LEN+1];
	TCHAR	State[CA_STATE_LEN+1];
	TCHAR	Country[CA_COUNTRY_LEN+1];
	TCHAR	Zip[CA_ZIP_LEN+1];
	TCHAR	LName[CA_NAME_LEN+1];
	TCHAR	FName[CA_NAME_LEN+1];
	TCHAR	Phone[CA_PHONE_LEN+1];
	TCHAR   Fax[CA_FAX_LEN+1]; 
	TCHAR	Email[CA_EMAIL_LEN+1];
	TCHAR	LSID[CA_LSERVERID_LEN+1];
	TCHAR	ProgramName[PROGRAM_NAME_LEN];
} CERTCUSTINFO, * PCERTCUSTINFO;

#define HydraContent "application/octet-stream"
/*********************************************************************************************************
 * Hydra request header definitions                                                                      *
 *********************************************************************************************************/
enum RequestTypes
{
	PingRequest = 1,					//ping upto isapi extension
	CertificateRequest,					//New Certificate request
	CertificateDownload,				//certificate download request
	CertificateSignOnly,				//convert from SPK to certificate
	CertificateRevoke,					//Revoke current certificate
	CertificateReissue,					//Reissue the certificate
	CertificateDownloadAck,				//Certificate download ack request
	ValidateCert,						//Validate Certificate Request
	NewLicenseRequest,					//new license request
	ReturnLicenseRequest,				//return license request
	ReissueLicenseRequest,				//reissue last license key pack
	LKPDownloadAckRequest,				//acknowledgement 	
	NoOperation							//unknown operation
};


enum ResponseTypes
{
	Response_Invalid_Response = 0,
	Response_Success,
	Response_Failure,
	Response_InvalidData,
	Response_ServerError,
	Response_NotYetImplemented,
	Response_VersionMismatch,
	Response_Reg_Bad_SPK,
	Response_Reg_Bad_Cert,
	Response_Reg_Expired,
	Response_Reg_Revoked,
	Response_TDO_TDN_Failed,
	Response_License_Info_Failed,
	Response_Invalid_Conf_Num,
	Response_Conf_Num_Already_Used,
    Response_SelectMloLicense_NotValid,
    Response_NotASupervisor_NotValid,
	Response_Invalid_Transfer,
	Response_Denied_Other_Program_Id,
	Response_Invalid_Other_Program_Qty
};

enum TransactionStates
{
	Void	= 0,
	NotValidated,
	Validated,
	LicenceRequestPending,
	LicenceRequestGranted,
	UpgradeRequestPending
// ...
};

enum RegistrationMethods
{
	Reg_Internet = 0,
	Reg_Telephone,
	Reg_Fax
};

enum TransportTypes
{
	Transport_Internet =1,			//will be supported
	Transport_Disk,					
	Transport_Modem,
	Transport_FaxModem,
	Transport_Other				//unknown transport yet!
};

typedef struct TCB_DISK_PARAM_TAG
{
	char	*	pszFileName;
	char	*	pPostData;
	DWORD		dwPostDataLen;
}TCB_DISK_PARAM, * PTCB_DISK_PARAM;

typedef struct TCB_INTERNET_PARAM_TAG
{
	char *	pURL;
	char *	pPostData;
	DWORD	dwPostDataLen;
}TCB_INTERNET_PARAM, *PTCB_INTERNET_PARAM;


/*
 * This is the transport control block which is filled in prior to calling the
 * Send Request routine.
 *
 */
typedef struct TCB_TAG_
{
	RequestTypes	RequestType;			//request identifier
	TransportTypes	TransportType;			//transport identifier
	void *			pvParam;				//parameters based on the Transport Type
	void *			pvReserved;				//should be set to null at request time and then left alone.
	void *			pvResponse;				//void pointer to response
	DWORD			dwResponseLen;			//response length
	DWORD			dwRetCode;				//Return code from wait operation
}TCB, * PTCB;

/*
 * This is the generic structure of the request header that goes on the wire
 */
class RequestHeader
{
public:
	RequestHeader()	
		{	SetRequestType(NoOperation);
			SetResponseType(Response_Invalid_Response); 
			m_dwLanguageID	=	0;
			SetVersion(CH_STRUCTS_CURRENT_VERSION);
			SetRegistrationMethod(Reg_Internet);
		};


	void SetRequestType (enum RequestTypes Req) 
	{ 
		m_Request = (enum RequestTypes)htonl(Req); 
	};

	enum RequestTypes GetRequestType() 
	{ 
		return (enum RequestTypes) ntohl(m_Request); 
	};

	void SetResponseType (enum ResponseTypes eResp)
	{ 
		m_Response = (enum ResponseTypes)htonl(eResp); 
	};
	enum ResponseTypes GetResponseType() 
	{ 
		return (enum ResponseTypes) ntohl(m_Response); 
	};


	void SetRegistrationMethod (enum RegistrationMethods eRegM)
	{ 
		m_RegistrationMethod = (enum RegistrationMethods)htonl(eRegM); 
	};
	
	enum RegistrationMethods GetRegistrationMethod() 
	{ 
		return (enum RegistrationMethods) ntohl(m_RegistrationMethod); 
	};

	void SetLanguageId(DWORD dwLanguagwId) 
	{
		m_dwLanguageID = htonl(dwLanguagwId);
	};

	DWORD GetLanguageId()
	{
		return ntohl(m_dwLanguageID);
	};	

	void SetVersion(DWORD dwVersion)
	{
		m_dwVersion = htonl(dwVersion);
	};

	DWORD GetVersion()
	{
		return ntohl(m_dwVersion);
	}

private:
	enum RequestTypes			m_Request;								//Request Interaction Code
	enum ResponseTypes			m_Response;								//Response Type		
	enum RegistrationMethods	m_RegistrationMethod;					//Registration Method
	DWORD						m_dwLanguageID;							//languageId
	DWORD						m_dwVersion;							// Version for the Request Header
};

/*
 * Validation request header
 */
class Validate_Request
{
public:
	Validate_Request() 
	{	
		RequestHeader.SetRequestType(ValidateCert); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
	};

	~Validate_Request() {};
	
	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
        if (pbSPK != NULL)
        {
		    memcpy ( m_szSPK, pbSPK, dwSPKLen );
        }
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetCertBlobLen (DWORD dwCertBlobLen)
	{
		m_dwCertBlobLen = htonl(dwCertBlobLen);
	};

	DWORD GetCertBlobLen ()
	{
		return (ntohl(m_dwCertBlobLen));
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	DWORD			m_dwCertBlobLen;
	DWORD			m_dwDataLen;				//Length of the Body
	//variable data part
	//CErt Blob follows here
};
/*
 * Validation response header
 */
class Validate_Response
{
public:
	Validate_Response() 
	{ 
		RequestHeader.SetRequestType(ValidateCert); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset(m_szCertType,0,sizeof(m_szCertType));
	};
	
	inline void SetCHExchCertLen (DWORD dwCertLen) 
	{
		m_dwCHExchCertLen = htonl(dwCertLen);
	};

	inline DWORD GetCHExchCertLen () 
	{ 
		return ntohl(m_dwCHExchCertLen); 
	};

	inline void SetCHSignCertLen (DWORD dwCertLen) 
	{
		m_dwCHSignCertLen = htonl(dwCertLen);
	};

	inline DWORD GetCHSignCertLen () 
	{ 
		return ntohl(m_dwCHSignCertLen); 
	};

	inline void SetCHRootCertLen(DWORD dwRootCertLen) 
	{
		m_dwCHRootCertLen = htonl(dwRootCertLen);
	};

	inline DWORD GetCHRootCertLen () 
	{ 
		return ntohl(m_dwCHRootCertLen); 
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	void SetRetCode (DWORD dwRetCode )
	{
		m_dwRetCode = htonl(dwRetCode);
	}
	DWORD GetRetCode ()
	{
		return ntohl(m_dwRetCode);
	}
	void SetCertType(PBYTE pbCertType, DWORD dwCertTypeLen )
	{
		memcpy (m_szCertType, pbCertType, dwCertTypeLen );
	}
	LPTSTR GetCertType()
	{
		return ((LPTSTR)m_szCertType);
	}
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwRetCode;
	DWORD			m_dwCHRootCertLen;
	DWORD			m_dwCHExchCertLen;
	DWORD			m_dwCHSignCertLen;
	TCHAR			m_szCertType[MAX_CERTTYPE_LEN];
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable length response
	//1.CH Root Cert
	//2.CH Exch cert
	//3.CH Sign Cert
};

//Send the old certificate and SPK with this request and
//then get the response back
class CertRevoke_Request
{
public:
	CertRevoke_Request() 
	{ 
		RequestHeader.SetRequestType(CertificateRevoke); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset (m_szSPK,0,sizeof(m_szSPK));
		memset (m_LName, 0, sizeof(m_LName));
		memset (m_FName,0,sizeof(m_FName));
		memset (m_Phone, 0, sizeof(m_Phone));
		memset (m_FAX, 0, sizeof(m_FAX));
		memset (m_EMail,0,sizeof(m_EMail));
		memset (m_ReasonCode,0,sizeof(m_ReasonCode));
		m_dwExchgCertLen = 0;
		m_dwSignCertLen = 0;
		
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
        if (pbSPK != NULL)
        {
		    memcpy ( m_szSPK, pbSPK, dwSPKLen );
        }
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetExchgCertLen (DWORD dwExchgCertLen)
	{
		m_dwExchgCertLen = htonl(dwExchgCertLen);
	};

	DWORD GetExchgCertLen ()
	{
		return (ntohl(m_dwExchgCertLen));
	};

	void SetSignCertLen (DWORD dwSignCertLen)
	{
		m_dwSignCertLen = htonl(dwSignCertLen);
	};

	DWORD GetSignCertLen ()
	{
		return (ntohl(m_dwSignCertLen));
	};

	void SetLName ( PBYTE pbLName, DWORD dwLNameLen )
	{
		memcpy ( m_LName, pbLName, dwLNameLen );
	};
	LPTSTR GetLName ()
	{
		return ((LPTSTR)m_LName);
	};

	void SetFName ( PBYTE pbFName, DWORD dwFNameLen )
	{
		memcpy ( m_FName, pbFName, dwFNameLen );
	};
	LPTSTR GetFName ()
	{
		return ((LPTSTR)m_FName);
	};

	void SetPhone ( PBYTE pbPhone, DWORD dwPhoneLen )
	{
		memcpy ( m_Phone, pbPhone, dwPhoneLen );
	};
	LPTSTR GetPhone ()
	{
		return ((LPTSTR)m_Phone);
	};

	void SetFax ( PBYTE pbFAX, DWORD dwFAXLen )
	{
		memcpy ( m_FAX, pbFAX, dwFAXLen );
	};
	LPTSTR GetFax ()
	{
		return ((LPTSTR)m_FAX);
	};

	void SetEMail ( PBYTE pbEMail, DWORD dwEMailLen )
	{
		memcpy ( m_EMail, pbEMail, dwEMailLen);
	};
	LPTSTR GetEMail ()
	{
		return ((LPTSTR)m_EMail);
	};

	void SetReasonCode( PBYTE pbReasonCode, DWORD dwReasonCodeLen )
	{
		memcpy ( m_ReasonCode, pbReasonCode, dwReasonCodeLen );
	};
	LPTSTR GetReasonCode ()
	{
		return ((LPTSTR)m_ReasonCode);
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	DWORD			m_dwExchgCertLen;
	DWORD			m_dwSignCertLen;
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	TCHAR			m_LName[CA_NAME_LEN+1];			//LName of the revoker
	TCHAR			m_FName[CA_NAME_LEN+1];			//FName of the revoker
	TCHAR			m_Phone[CA_PHONE_LEN+1];			//phone 
	TCHAR			m_FAX[CA_FAX_LEN+1];			//FAX 
	TCHAR			m_EMail[CA_EMAIL_LEN+1];			//email - optional of the revoker
	TCHAR			m_ReasonCode[CA_REVOKE_REASONCODE_LEN+1];	//reason for revokation
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable length data
	//1.Exchange Cert Blob
	//2.Signature cert blob
};


//nothing to send back.  Either the operation succeeds or fails.
class CertRevoke_Response
{
public:
	CertRevoke_Response() 
	{ 
		RequestHeader.SetRequestType(CertificateRevoke); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
	}
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	DWORD			m_dwDataLen;				//Length of the Body
};

//reissue the certificate
//This is an online request.  We dont go thru' the e-mail loop etc. 
//This request accepts the old SPK and send the new SPK back.
//Then when the authenticate comes across, we do a signonly 
//of this cert and deposit the new cert into the system
class CertReissue_Request
{
public:
	CertReissue_Request() 
	{ 
		RequestHeader.SetRequestType(CertificateReissue); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset (m_szSPK,0,sizeof(m_szSPK));
		memset (m_LName,0,sizeof(m_LName));
		memset (m_FName,0,sizeof(m_FName));
		memset (m_Phone,0,sizeof(m_Phone));
		memset (m_FAX,0,sizeof(m_FAX));
		memset (m_EMail,0,sizeof(m_EMail));
		memset (m_ReasonCode,0,sizeof(m_ReasonCode));
		m_dwDataLen = 0;
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetLName ( PBYTE pbLName, DWORD dwLNameLen )
	{
		memcpy ( m_LName, pbLName, dwLNameLen );
	};
	LPTSTR GetLName ()
	{
		return ((LPTSTR)m_LName);
	};

	void SetFName ( PBYTE pbFName, DWORD dwFNameLen )
	{
		memcpy ( m_FName, pbFName, dwFNameLen );
	};
	LPTSTR GetFName ()
	{
		return ((LPTSTR)m_FName);
	};

	void SetPhone ( PBYTE pbPhone, DWORD dwPhoneLen )
	{
		memcpy ( m_Phone, pbPhone, dwPhoneLen );
	};
	LPTSTR GetPhone ()
	{
		return ((LPTSTR)m_Phone);
	};

	void SetFax ( PBYTE pbFAX, DWORD dwFAXLen )
	{
		memcpy ( m_FAX, pbFAX, dwFAXLen );
	};
	LPTSTR GetFax ()
	{
		return ((LPTSTR)m_FAX);
	};

	void SetEMail ( PBYTE pbEMail, DWORD dwEMailLen )
	{
		memcpy ( m_EMail, pbEMail, dwEMailLen);
	};
	LPTSTR GetEMail ()
	{
		return ((LPTSTR)m_EMail);
	};

	void SetReasonCode( PBYTE pbReasonCode, DWORD dwReasonCodeLen )
	{
		memcpy ( m_ReasonCode, pbReasonCode, dwReasonCodeLen );
	};
	LPTSTR GetReasonCode ()
	{
		return ((LPTSTR)m_ReasonCode);
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;					//Request Header
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	TCHAR			m_LName[CA_NAME_LEN+1];			//LName of the reissuer
	TCHAR			m_FName[CA_NAME_LEN+1];			//FName of the reissuer
	TCHAR			m_Phone[CA_PHONE_LEN+1];			//phone 
	TCHAR			m_FAX[CA_FAX_LEN+1];			//FAX
	TCHAR			m_EMail[CA_EMAIL_LEN+1];			//email - optional of the reissuer
	TCHAR			m_ReasonCode[CA_REVOKE_REASONCODE_LEN+1];	//reason for reissue
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable portion of this request
	//no variable portion here
};




class CertReissue_Response
{
public:
	CertReissue_Response() 
	{ 
		RequestHeader.SetRequestType(CertificateReissue); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szSPK,0,sizeof(m_szSPK));
		m_dwDataLen = 0;
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
    		memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];	//Registration Request Id
	TCHAR			m_szSPK[LSSPK_LEN];					//new SPK
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable Portion of the response
	//no variable portion here
};

/*
 * NewLicense KeyPack Requests
 */
class ReissueLKP_Request
{
public:
	ReissueLKP_Request()
	{
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(ReissueLicenseRequest);
		memset (m_szSPK,0,sizeof(m_szSPK));
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};
	void SetCertBlobLen (DWORD dwCertBlobLen)
	{
		m_dwCertBlobLen = htonl(dwCertBlobLen);
	};

	DWORD GetCertBlobLen ()
	{
		return (ntohl(m_dwCertBlobLen));
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	TCHAR			m_szSPK[LSSPK_LEN];			//SPK
	DWORD			m_dwCertBlobLen;			//certificate length
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable portion of the request
	//1.Cert Blob 
};

class ReissueLKP_Response
{
public:
	ReissueLKP_Response()
	{
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(ReissueLicenseRequest);

	}
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	void SetLKPLength(DWORD dwLKPLen)
	{
		m_dwLKPLen = htonl(dwLKPLen);
	};

	DWORD GetLKPLength()
	{
		return ( ntohl(m_dwLKPLen));
	};


	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	DWORD			m_dwLKPLen;
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable part of the request
	//1. Last LKP issued

};

class NewLKP_Request
{
public:
	NewLKP_Request () 
	{ 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(NewLicenseRequest);
		memset (m_szSPK,0,sizeof(m_szSPK));
		m_dwRetailSPKCount = 0;
		m_dwCertBlobLen = 0;
		m_dwNewLKPRequestLen = 0;

	};

	~NewLKP_Request () {};	

	void SetCertBlobLen ( DWORD dwCertBlobLen )
	{
		m_dwCertBlobLen = htonl(dwCertBlobLen);
	};

	DWORD GetCertBlobLen ( )
	{
		return( ntohl(m_dwCertBlobLen));
	};

	void SetNewLKPRequestLen ( DWORD dwNewLKPRequestLen )
	{
		m_dwNewLKPRequestLen = htonl(dwNewLKPRequestLen);
	};

	DWORD GetNewLKPRequestLen ( )
	{
		return( ntohl(m_dwNewLKPRequestLen ));
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetRetailSPKCount (DWORD dwRetailSPKCount)
	{
		assert(dwRetailSPKCount <= MAX_RETAILSPKCOUNT );
		m_dwRetailSPKCount = htonl(dwRetailSPKCount);
	};

	DWORD GetRetailSPKCount()
	{
		return ntohl(m_dwRetailSPKCount);
	};


	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwCertBlobLen;
	DWORD			m_dwNewLKPRequestLen;
	DWORD			m_dwRetailSPKCount;
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable length data here
	//1.Cert Blob
	//2. New LKP Request Blob
	//3. As many 25 character Retail SPK items as specified in count above
};

class NewLKP_Response
{
public:
	NewLKP_Response() 
	{ 	
		RequestHeader.SetRequestType(NewLicenseRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szRegRequestId,0,sizeof(m_szRegRequestId));
		memset ( m_szLicenseReqId,0,sizeof(m_szLicenseReqId));
		memset ( m_dwRetailSPKStatus, 0, sizeof(m_dwRetailSPKStatus));
	};
	
	void SetLKPLength(DWORD dwLKPLen)
	{
		m_dwLKPLen = htonl(dwLKPLen);
	};

	DWORD GetLKPLength()
	{
		return ( ntohl(m_dwLKPLen));
	};

	void SetRegRequestId (PBYTE pbRegReqId, DWORD dwRegReqIdLen)
	{
        if( pbRegReqId != NULL )
        {
		    memcpy (m_szRegRequestId, pbRegReqId, dwRegReqIdLen );
        }
	};

	LPTSTR GetRegRequestId ()
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetLicenseReqId (PBYTE pbLicenseReqId, DWORD dwLicenseReqIdLen)
	{
		memcpy (m_szLicenseReqId, pbLicenseReqId, dwLicenseReqIdLen);
	};

	LPTSTR GetLicenseReqId  ()
	{
		return ((LPTSTR)m_szLicenseReqId);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	void SetRetailSPKStatus ( DWORD dwIndex, TCHAR dwStatus )
	{
		assert ( dwIndex < MAX_RETAILSPKCOUNT );
		m_dwRetailSPKStatus[dwIndex] = dwStatus;
	};
	TCHAR GetRetailSPKStatus(DWORD dwIndex )
	{
		assert ( dwIndex < MAX_RETAILSPKCOUNT );
		return m_dwRetailSPKStatus[dwIndex];
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwLKPLen;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szLicenseReqId[REQUEST_ID_LEN];	
	TCHAR			m_dwRetailSPKStatus[MAX_RETAILSPKCOUNT];
	DWORD			m_dwDataLen;				//Length of the Body	
	//LKP here

};

class NewLKP_AckRequest
{
public:
	NewLKP_AckRequest()
	{
		RequestHeader.SetRequestType(LKPDownloadAckRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szRegRequestId,0,sizeof(m_szRegRequestId));
		memset ( m_szLicenseReqId,0,sizeof(m_szLicenseReqId));
		m_bAckType = 0;
		m_dwDataLen = 0;
	};

	void SetRegRequestId (PBYTE pbReqId, DWORD dwReqIdLen)
	{
        if(pbReqId != NULL)
        {
		    memcpy ( m_szRegRequestId, pbReqId, dwReqIdLen );
        }
	};

	LPTSTR GetRegRequestId ()
	{
		return ( (LPTSTR)m_szRegRequestId);
	};

	void SetAckType ( BYTE bAckType )
	{
		m_bAckType = bAckType;
	};

	BYTE GetAckType ()
	{
		return m_bAckType;
	};

	void SetLicenseReqId (PBYTE pbLicenseReqId, DWORD dwLicenseReqIdLen)
	{
		memcpy (m_szLicenseReqId, pbLicenseReqId, dwLicenseReqIdLen);
	};

	LPTSTR GetLicenseReqId  ()
	{
		return ((LPTSTR)m_szLicenseReqId);
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;		
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szLicenseReqId[REQUEST_ID_LEN];
	BYTE			m_bAckType;					//1 = success 2 = fail
	DWORD			m_dwDataLen;				//Length of the Body	
};

class NewLKP_AckResponse
{
public:
	NewLKP_AckResponse()
	{
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(LKPDownloadAckRequest);
		m_dwDataLen = 0;
	}

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwDataLen;				//Length of the Body		
	//nothing here
};

/*
 * Certificate Acknowledgement Request / Interactions
 */

class Certificate_AckRequest
{
public:
	Certificate_AckRequest () 
	{ 
		RequestHeader.SetRequestType(CertificateDownloadAck);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset (m_szRegRequestId,0,sizeof(m_szRegRequestId));
		m_bAckType = 0;
		m_dwDataLen = 0;
	};

	~Certificate_AckRequest () {};
	
	void SetRegRequestId (PBYTE pbReqId, DWORD dwReqIdLen)
	{
        if(pbReqId != NULL)
        {
		    memcpy ( m_szRegRequestId, pbReqId, dwReqIdLen );
        }
	};

	LPTSTR GetRegRequestId ()
	{
		return ( (LPTSTR)m_szRegRequestId);
	};

	void SetAckType ( BYTE bAckType )
	{
		m_bAckType = bAckType;
	};

	BYTE GetAckType ()
	{
		return m_bAckType;
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	BYTE			m_bAckType;					//1 = success 2 = fail
	DWORD			m_dwDataLen;				//Length of the Body		
	//no variable data
};

class Certificate_AckResponse
{
public:
	Certificate_AckResponse () 
	{ 
		RequestHeader.SetRequestType(CertificateDownloadAck);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
	};

	~Certificate_AckResponse () {};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwDataLen;				//Length of the Body		
	//no variable data
};


//Request for sendind the New CErt 
class NewCert_Request
{

public:
	NewCert_Request () 
	{ 
		RequestHeader.SetRequestType(CertificateRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
	};

	~NewCert_Request () {};

	DWORD GetExchgPKCS10Length() 
	{ 
		return ( ntohl(m_dwExchPKCS10Length) ); 
	};

	void SetExchgPKCS10Length(DWORD dwExchPKCS10Length) 
	{ 
		m_dwExchPKCS10Length = htonl(dwExchPKCS10Length); 
	};

	DWORD GetSignPKCS10Length() 
	{ 
		return ( ntohl(m_dwSignPKCS10Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS10Length) 
	{ 
		m_dwSignPKCS10Length = htonl(dwSignPKCS10Length); 
	};	

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetServerName(TCHAR * tc)
	{
		_stprintf(m_szLServerName, _T("%.*s"), MAX_COMPUTERNAME_LENGTH + 4, tc);
	}

	TCHAR * GetServerName(void)
	{
		return m_szLServerName;
	}
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwExchPKCS10Length;
	DWORD			m_dwSignPKCS10Length;
	CERTCUSTINFO	stCertInfo;
	TCHAR			m_szLServerName[MAX_COMPUTERNAME_LENGTH + 5];

	DWORD			m_dwDataLen;				//Length of the Body		
	//Variable data goes here
	//First Exchg PKCS10
	//Second Sign PKCS10
	
};

//New Certificate request response structure
class NewCert_Response
{
public:
	NewCert_Response () 
	{ 
		RequestHeader.SetRequestType(CertificateRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szSPK, 0, sizeof(m_szSPK ));
		memset ( m_szRegRequestId, 0, sizeof(m_szRegRequestId) );
	};

	~NewCert_Response () {};

	
	DWORD GetExchgPKCS7Length() 
	{ 
		return ( ntohl(m_dwExchPKCS7Length) ); 
	};

	void SetExchgPKCS7Length(DWORD dwExchPKCS7Length) 
	{ 
		m_dwExchPKCS7Length = htonl(dwExchPKCS7Length); 
	};

	DWORD GetSignPKCS7Length() 
	{ 
		return ( ntohl(m_dwSignPKCS7Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS7Length) 
	{ 
		m_dwSignPKCS7Length = htonl(dwSignPKCS7Length); 
	};
	
	DWORD GetRootCertLength() 
	{ 
		return ( ntohl(m_dwRootCertLength) ); 
	};

	void SetRootCertLength(DWORD dwRootCertLength) 
	{ 
		m_dwRootCertLength = htonl(dwRootCertLength); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
		    memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetSPK ( PBYTE pbSPK, DWORD dwSPKLen)
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ( )
	{
		return ((LPTSTR)m_szSPK);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwExchPKCS7Length;
	DWORD			m_dwSignPKCS7Length;
	DWORD			m_dwRootCertLength;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szSPK[LSSPK_LEN];
	DWORD			m_dwDataLen;				//Length of the Body
	//variable data part
	//1.Exchange PKCS7
	//2.Signature PKCS7
	//3.Root Cert
};

//Certificate sign only request structure
class CertificateSignOnly_Request
{
public:
	CertificateSignOnly_Request()
	{
		RequestHeader.SetRequestType(CertificateSignOnly);
		memset (m_szSPK,0,sizeof(m_szSPK));
	};

	~CertificateSignOnly_Request(){};	

	DWORD GetExchgPKCS10Length() 
	{ 
		return ( ntohl(m_dwExchPKCS10Length) ); 
	};

	void SetExchgPKCS10Length(DWORD dwExchPKCS10Length) 
	{ 
		m_dwExchPKCS10Length = htonl(dwExchPKCS10Length); 
	};

	DWORD GetSignPKCS10Length() 
	{ 
		return ( ntohl(m_dwSignPKCS10Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS10Length) 
	{ 
		m_dwSignPKCS10Length = htonl(dwSignPKCS10Length); 
	};


	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};
	void SetServerName(TCHAR * tc)
	{
		_stprintf(m_szLServerName, _T("%.*s"), MAX_COMPUTERNAME_LENGTH + 4, tc);
	}

	TCHAR * GetServerName(void)
	{
		return m_szLServerName;
	}

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwExchPKCS10Length;
	DWORD			m_dwSignPKCS10Length;	
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	TCHAR			m_szLServerName[MAX_COMPUTERNAME_LENGTH + 5];
	DWORD			m_dwDataLen;				//Length of the Body
	//variable data goes here
	//First Exchg PKCS10
	//Second Sign PKCS10
	

};
//Certificate sign only response structure
class CertificateSignOnly_Response
{
public:
	CertificateSignOnly_Response()
	{
		memset(m_szRegRequestId,0,sizeof(m_szRegRequestId));
		RequestHeader.SetRequestType(CertificateSignOnly);
	};

	~CertificateSignOnly_Response(){};
	
	DWORD GetExchgPKCS7Length() 
	{ 
		return ( ntohl(m_dwExchPKCS7Length) ); 
	};

	void SetExchgPKCS7Length(DWORD dwExchPKCS7Length) 
	{ 
		m_dwExchPKCS7Length = htonl(dwExchPKCS7Length); 
	};

	DWORD GetSignPKCS7Length() 
	{ 
		return ( ntohl(m_dwSignPKCS7Length) ); 
	};

	void SetSignPKCS7Length(DWORD dwSignPKCS7Length) 
	{ 
		m_dwSignPKCS7Length = htonl(dwSignPKCS7Length); 
	};
	
	DWORD GetRootCertLength() 
	{ 
		return ( ntohl(m_dwRootCertLength) ); 
	};

	void SetRootCertLength(DWORD dwRootCertLength) 
	{ 
		m_dwRootCertLength = htonl(dwRootCertLength); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
		    memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwExchPKCS7Length;
	DWORD			m_dwSignPKCS7Length;
	DWORD			m_dwRootCertLength;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	DWORD			m_dwDataLen;				//Length of the Body				
	//Variable data
	//first ExchgPKCS7
	//Second SignPKCS7
	//third Root CErt
};

class CertificateDownload_Request
{
public:
	CertificateDownload_Request () 
	{ 
		RequestHeader.SetRequestType(CertificateDownload);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
		memset ( m_szPIN,0,sizeof(m_szPIN));
	};

	~CertificateDownload_Request  () {};
	
	void SetPIN ( PBYTE pbPIN, DWORD dwPINLen )
	{
        if( pbPIN != NULL )
        {
		    memcpy ( m_szPIN, pbPIN, dwPINLen );
        }
	};

	LPTSTR GetPIN ( )
	{
		return ((LPTSTR)m_szPIN);
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			m_szPIN[PIN_LEN];
	DWORD			m_dwDataLen;				//Length of the Body
	//no variable data part!!
};


class CertificateDownload_Response
{
public:
	CertificateDownload_Response () 
	{ 
		RequestHeader.SetRequestType(CertificateDownload);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset(m_szRegRequestId,0,sizeof(m_szRegRequestId));
		memset(m_szSPK,0,sizeof(m_szSPK));
	};

	~CertificateDownload_Response  () {};	

	DWORD GetExchgPKCS7Length() 
	{ 
		return ( ntohl(m_dwExchPKCS7Length) ); 
	};

	void SetExchgPKCS7Length(DWORD dwExchPKCS7Length) 
	{ 
		m_dwExchPKCS7Length = htonl(dwExchPKCS7Length); 
	};

	DWORD GetSignPKCS7Length() 
	{ 
		return ( ntohl(m_dwSignPKCS7Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS7Length) 
	{ 
		m_dwSignPKCS7Length = htonl(dwSignPKCS7Length); 
	};
	
	DWORD GetRootCertLength() 
	{ 
		return ( ntohl(m_dwRootCertLength) ); 
	};

	void SetRootCertLength(DWORD dwRootCertLength) 
	{ 
		m_dwRootCertLength = htonl(dwRootCertLength); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
		    memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetSPK ( PBYTE pbSPK, DWORD dwSPKLen)
	{
        if(pbSPK != NULL)
        {
		    memcpy ( m_szSPK, pbSPK, dwSPKLen );
        }
	};

	LPTSTR GetSPK ( )
	{
		return ((LPTSTR)m_szSPK);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwExchPKCS7Length;
	DWORD			m_dwSignPKCS7Length;
	DWORD			m_dwRootCertLength;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szSPK[LSSPK_LEN];	
	DWORD			m_dwDataLen;				//Length of the Body					
	//variable data part
	//1.Exchange PKCS7
	//2.Signature PKCS7
	//3.Root Cert
};

//ping request and response class
class Ping_Request
{
public:
	Ping_Request () 
	{ 
		RequestHeader.SetRequestType(PingRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
		_tcscpy ( tszPingReqData, _TEXT("Houston we have a problem"));
	};

	~Ping_Request () {};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			tszPingReqData[32];			//32 characters
	DWORD			m_dwDataLen;				//Length of the Body
};

class Ping_Response
{
public:
	Ping_Response()
	{
		RequestHeader.SetRequestType(PingRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		_tcscpy ( tszPingResponse, _TEXT("Beam'er up Scottie!"));
	}

	~Ping_Response() {};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			tszPingResponse[32];
	DWORD			m_dwDataLen;				//Length of the Body
};


//stream header declarations
#define BLOCK_TYPE_NAME			1
#define BLOCK_TYPE_VALUE		2
#define BLOCK_TYPE_PROP_PAIR	3


typedef struct
{
	long		m_wType;
	long		m_lNameSize;
	long		m_lValueSize;

	void SetType (long lType) {m_wType = htonl(lType);};
	long GetType (){return  ntohl(m_wType);};
	void SetNameSize(long lNameSize) {m_lNameSize = htonl(lNameSize);};
	long GetNameSize(){return (ntohl(m_lNameSize));};
	void SetValueSize(long lValueSize){m_lValueSize = htonl(lValueSize);};
	long GetValueSize(){return (ntohl(m_lValueSize));};
} BLOCK_HDR;

#define STREAM_HDR_TITLE		_TEXT("ICB")			//header title
#define STREAM_HDR_TYPE			1						//header type

typedef struct
{
	TCHAR		m_szTitle[4];			//will be ICB for now 
	DWORD		m_wHeader;				//reserved for now will be implemented later
										//set it to 0x0000
	DWORD		m_itemCount;			//number of items in the stream!

	void SetHeader ( DWORD wHeader ) {m_wHeader = htonl(wHeader);};
	DWORD GetHeader (){return ntohl(m_wHeader);};
	void SetItemCount ( DWORD ItemCount ) { m_itemCount = htonl(ItemCount);};
	DWORD GetItemCount (){return ntohl(m_itemCount);};

} STREAM_HDR;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\def.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _DEF_H_
#define _DEF_H_

#define NO_OF_PAGES					19

#define	PG_NDX_WELCOME					0
#define	PG_NDX_GETREGMODE				1
#define	PG_NDX_CONTACTINFO1				2
#define	PG_NDX_CONTACTINFO2				3
#define PG_NDX_CONTINUEREG				4
#define	PG_NDX_PROGRESS					5
#define	PG_NDX_DLG_PIN					6
#define	PG_NDX_CH_REGISTER_SELECT		7
#define	PG_NDX_CH_REGISTER_MOLP			8
#define	PG_NDX_COUNTRYREGION			9
#define	PG_NDX_CH_REGISTER_1			10
#define	PG_NDX_RETAILSPK				11
#define	PG_NDX_TELREG					12
#define	PG_NDX_TELLKP					13
#define	PG_NDX_CONFREVOKE				14
#define	PG_NDX_TELREG_REISSUE			15
#define	PG_NDX_CERTLOG					16
#define	PG_NDX_WWWREG					17
#define	PG_NDX_WWWLKP					18
// #define	PG_NDX_FAX_REG_AGREEMENT		16
// #define	PG_NDX_FAX_CONTACTINFO			17
// #define	PG_NDX_FAX_CUSTINFO_a			18
// #define	PG_NDX_FAX_CUSTINFO_b			19
// #define	PG_NDX_PROGRESS_FAX				20
// #define	PG_NDX_FAX_LKP_AGREEMENT		21
// #define	PG_NDX_FAX_SELECT				22
// #define	PG_NDX_FAX_MOLP					23
// #define	PG_NDX_FAX_RETAIL				24
// #define	PG_NDX_COUNTRYREGION_FAX		26


//
// Dlgs for LS Properties 
//
#define PG_NDX_PROP_MODE		0
#define PG_NDX_PROP_PROGRAM		1
#define PG_NDX_PROP_CUSTINFO_a	2
#define PG_NDX_PROP_CUSTINFO_b	3

#define NO_OF_PROP_PAGES	4


// Various Request Types
#define REQUEST_NULL					0
#define REQUEST_CH_PING					1
#define REQUEST_CA_CERTREQUEST			2
#define REQUEST_CA_CERTDOWNLOAD			3
#define REQUEST_CA_CERTSIGNONLY			4
#define REQUEST_CA_REVOKECERT			5
#define REQUEST_CA_UPGRADECERT			6
#define REQUEST_CA_REISSUECERT			7
#define REQUEST_CH_AUTHENTICATE			8
#define REQUEST_CH_LKPREQUEST			9
#define REQUEST_CH_LKPACK				10
#define REQUEST_CH_RETURNLKP			11
#define REQUEST_CH_REISSUELKP			12


//
//LS Registration Modes
//
// Note : LRMODE_CA_ONLINE_REQUEST & LRMODE_REG_REQUEST are both Registration Request
// Online is for Internet and Reg_request is for Telephone/WWW
#define	LRMODE_CH_REQUEST				1
#define	LRMODE_CA_ONLINE_REQUEST		2
#define	LRMODE_CA_ONLINE_DOWNLOAD		3
#define LRMODE_CH_REISSUE_LASTREQUEST	4
#define LRMODE_CA_REVOKECERT			5
#define LRMODE_CA_REISSUECERT			6
#define	LRMODE_REG_REQUEST				7  


//
// Fax Request Types
//
#define FAX_REQUEST_BOTH		0
#define FAX_REQUEST_REG_ONLY	1
#define FAX_REQUEST_LKP_ONLY	2


#define LR_REGISTRATIONID_LEN		35
#define LR_LICENSESERVERID_LEN		23
#define LR_RETAILSPK_LEN			25
#define LR_CONFIRMATION_LEN			 7

#define MAX_RETAILSPKS_IN_BATCH		10


#define BASE24_CHARACTERS	_TEXT("BCDFGHJKMPQRTVWXY2346789")



//
//LRWiz States. CR - Certificate Request & LR - LKP Request/LKP Response
// 1 is used to determine whether to display PIN dlg in Online Mode
// 2 & 3 are used to determine which files to expect on the disk in Install from Disk mode
// LRSTATE_NEUTRAL means , end to end cycle is completed
// Like , Online CR created - Cert Downloaded & installed etc.
//
#define	LRSTATE_NEUTRAL						0
#define	LRSTATE_ONLINE_CR_CREATED			1
#define LRSTATE_FAX_ONE_REQUEST_CREATED		2
#define LRSTATE_FAX_BOTH_REQUEST_CREATED	3

//REG_KEYS
#define REG_LRWIZ_PARAMS			L"SOFTWARE\\MICROSOFT\\TermServLicensing\\LrWiz\\Params"
#define REG_LRWIZ_CSNUMBERS			L"SOFTWARE\\MICROSOFT\\TermServLicensing\\LrWiz\\CSNumbers"
#define REG_LRWIZ_CSFAX				L"SOFTWARE\\MICROSOFT\\TermServLicensing\\LrWiz\\FaxNumbers"
#define REG_LRWIZ_CSFAXREGION		"CSRFaxRegion"
#define REG_LRWIZ_CSPHONEREGION		"CSRPhoneRegion"
#define REG_LRWIZ_STATE				L"State"
#define REG_ROOT_CERT				L"Param0"
#define REG_EXCHG_CERT				L"Param1"
#define REG_SIGN_CERT				L"Param2"
#define REG_RA_URL					L"RA_URL"
#define REG_CH_SERVER				L"CH_SERVER"
#define REG_CH_EXTENSION			L"CH_EXTENSION"
#define	REG_LR_COUNT				L"LKPRC"
#define REG_WWW_SITE				L"WWW"

//General
#define	LR_MAX_MSG_TEXT			1024
#define	LR_MAX_MSG_CAPTION		64

#define LR_FIELD_DELIMITER		"~"
#define LS_SERVICE_NAME			L"TermServLicensing"
#define	LS_CRYPT_KEY_CONTAINER	L"tmpHydraLSKeyContainer"
#define szOID_NULL_EXT			"1.3.6.1.4.1.311.18"
//#define	szOID_NULL_EXT			"1.3.6.1.5.5.7.1.1"
#define MAX_NUM_EXTENSION		4

//Certificate Types
#define CA_CERT_TYPE_SELECT		"SELECT"
#define CA_CERT_TYPE_OTHER		"BASIC"

//Program names
#define PROGRAM_SELECT			_TEXT("SELECT")
#define PROGRAM_MOLP			_TEXT("MOLP")
#define PROGRAM_RETAIL			_TEXT("OTHER")

//Internal properties
#define _CERTBLOBTAG			_TEXT("CERTBLOB")
#define _MFGINFOTAG				_TEXT("MFGINFOTAG")

//program tags
#define _PROGRAMNAMETAG				_TEXT("REGPROGRAMNAME")

//Contact Information Tags

#define _CONTACTLNAMETAG			_TEXT("CONTACTLNAME")
#define _CONTACTFNAMETAG			_TEXT("CONTACTFNAME")
#define _CONTACTADDRESSTAG			_TEXT("CONTACTADDRESS")
#define _CONTACTPHONETAG			_TEXT("CONTACTPHONE")
#define _CONTACTFAXTAG				_TEXT("CONTACTFAX")
#define _CONTACTEMAILTAG			_TEXT("CONTACTEMAIL")
#define _CONTACTCITYTAG				_TEXT("CONTACTCITY")
#define _CONTACTCOUNTRYTAG			_TEXT("CONTACTCOUNTRY")
#define _CONTACTSTATE				_TEXT("CONTACTSTATE")
#define _CONTACTZIP					_TEXT("CONTACTZIP")


//Customer Information Tags
#define _CUSTOMERNAMETAG			_TEXT("CUSTOMERNAME")

//Select Information TAGS
#define _SELMASTERAGRNUMBERTAG		_TEXT("SELMASTERAGRNUMBERTAG")
#define _SELENROLLNUMBERTAG			_TEXT("SELENROLLNUMBER")
#define _SELPRODUCTTYPETAG			_TEXT("SELPRODUCTTYPE")
#define _SELQTYTAG					_TEXT("SELQTY")

//MOLP information
#define _MOLPAUTHNUMBERTAG			_TEXT("MOLPAUTHNUMBER")
#define _MOLPAGREEMENTNUMBERTAG		_TEXT("MOLPAGREEMENTNUMBER")
#define _MOLPPRODUCTTYPETAG			_TEXT("MOLPPRODUCTTYPE")
#define _MOLPQTYTAG					_TEXT("MOLPQTY")

//other (Retail) information
#define _OTHARBLOBTAG				_TEXT("OTHARBLOB")
//shipping information  - this will be required in case the
//user has not opted to use the same information as 
//shown in step 2 of registration.
#define _SHIPINFOPRESENT			_TEXT("SHIPINFOPRESENT")
#define _SHIPCONTACTLNAMETAG		_TEXT("SHIPCONTACTLNAME")
#define _SHIPCONTACTFNAMETAG		_TEXT("SHIPCONTACTFNAME")
#define _SHIPCONTACTADDRESSTAG		_TEXT("SHIPCONTACTADDRESS")
#define _SHIPCONTACTADDRESS1TAG		_TEXT("SHIPCONTACTADDRESS1")
#define _SHIPCONTACTADDRESS2TAG		_TEXT("SHIPCONTACTADDRESS2")
#define _SHIPCONTACTPHONETAG		_TEXT("SHIPCONTACTPHONE")
#define _SHIPCONTACTEMAILTAG		_TEXT("SHIPCONTACTEMAIL")
#define _SHIPCONTACTCITYTAG			_TEXT("SHIPCONTACTCITY")
#define _SHIPCONTACTCOUNTRYTAG		_TEXT("SHIPCONTACTCOUNTRY")
#define _SHIPCONTACTSTATE			_TEXT("SHIPCONTACTSTATE")
#define _SHIPCONTACTZIP				_TEXT("SHIPCONTACTZIP")
#define	_SHIPLSNAMETAG				_TEXT("SHIPLSNAME")

//Misc Property TAG
#define _OFFLINEREGFILENAMETAG		_TEXT("OFFLINEREGFILENAME")
#define _OFFLINESHIPFILENAMETAG		_TEXT("OFFLINESHIPFILENAME")

//Field lengths
#define CA_COMPANY_NAME_LEN			60
#define CA_ORG_UNIT_LEN				60
#define CA_ADDRESS_LEN				200
#define CA_CITY_LEN					30 
#define CA_STATE_LEN				30
#define CA_COUNTRY_LEN				2
#define CA_ZIP_LEN					16 
#define CA_NAME_LEN					30
#define CA_PHONE_LEN				64
#define CA_EMAIL_LEN				64
#define CA_FAX_LEN					64

#define	CA_PIN_LEN					42

//CH Field Lengths
#define CH_MOLP_AUTH_NUMBER_LEN			64
#define CH_MOLP_AGREEMENT_NUMBER_LEN	64
#define CH_SELECT_AGREEMENT_NUMBER		64
#define CH_SELECT_ENROLLMENT_NUMBER		64

#define CH_QTY_LEN						4

/*
#define CH_CONTACT_NAME_LEN				64
#define CH_ADDRESS_LEN					64
#define CH_PHONE_LEN					32
#define CH_EMAIL_LEN					64
#define CH_CITY_LEN						64
#define CH_COUNTRY_LEN					32
#define CH_STATE_LEN					32
#define CH_POSTAL_CODE_LEN				32
#define CH_CUSTOMER_NAME_LEN			64
*/

#define	LR_DRIVE_LEN					5

#define	LR_SHIPINFO_LEN					1024


//File Names
#define MFG_FILENAME			"mfr.bin"
#define CA_EXCHG_REQ_FILENAME	"exchgcert.req"		
#define CA_SIG_REQ_FILENAME		"sigcert.req"		
#define CA_EXCHG_RES_FILENAME	"exchgcert.rsp"		
#define CA_SIG_RES_FILENAME		"sigcert.rsp"		
#define CA_ROOT_RES_FILENAME	"lsroot.rsp"

#define CH_ROOT_CERT_FILENAME	"chroot.crt"
#define CH_EXCHG_CERT_FILENAME	"chexchg.crt"
#define CH_SIG_CERT_FILENAME	"chsig.crt"


#define CH_LKP_REQ_FILENAME		"newlkp.req"
#define CH_LKP_RES_FILENAME		"newlkp.rsp"


#define SHIP_INFO_FILENAME		"ship.inf"

// LKP ACK statuse
#define LKP_ACK					'2'
#define LKP_NACK				'3'

//
// Resource Ids for Country Code & Desc
//
#define	IDS_COUNTRY_START		500
#define	IDS_COUNTRY_END			739

//
// Resource Ids for Product Code & Desc
//
#define	IDS_PRODUCT_START               200
#define	IDS_PRODUCT_IC                  201
#define	IDS_PRODUCT_CONCURRENT          202
#define IDS_PRODUCT_WHISTLER            203
#define	IDS_PRODUCT_END                 204


#define	LR_COUNTRY_CODE_LEN		2
#define	LR_COUNTRY_DESC_LEN		64


#define IDS_REACT_REASONS_START		100
#define IDS_REACT_REASONS_END		103

#define IDS_DEACT_REASONS_START		150
#define IDS_DEACT_REASONS_END		151

#define CODE_TYPE_REACT				1
#define CODE_TYPE_DEACT				2


#define LR_REASON_CODE_LEN		2
#define LR_REASON_DESC_LEN		128


#define	LR_PRODUCT_CODE_LEN		3
#define	LR_PRODUCT_DESC_LEN		64

//
// Some constants used for progress bar
//
#define	PROGRESS_MAX_VAL		100			
#define	PROGRESS_STEP_VAL		1			
#define PROGRESS_WAIT_TIME		100			

//
// Constants required for Email validation
//
#define	EMAIL_MIN_LEN			6
#define	EMAIL_AT_CHAR			'@'
#define	EMAIL_DOT_CHAR			'.'
#define	EMAIL_SPACE_CHAR		' '
#define EMAIL_AT_DOT_STR		L"@."
#define	EMAIL_DOT_AT_STR		L".@"

#define	LR_SINGLE_QUOTE			'\''

#define LR_INVALID_CHARS		"\"~|"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\custcont.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"


LRW_DLG_INT CALLBACK ConfirmEMailDlgProc(IN HWND hwndDlg,  // handle to dialog box
										 IN UINT uMsg,     // message  
										 IN WPARAM wParam, // first message parameter
										 IN LPARAM lParam  // second message parameter
										)
{
	BOOL	bRetCode = FALSE;
	LPTSTR	lpVal = NULL;
	CString	sEmailConf;
	switch ( uMsg )
	{
	case WM_INITDIALOG:
		bRetCode = TRUE;
		break;
	case WM_COMMAND:
		switch ( LOWORD(wParam) )		//from which control
		{
		case IDOK:
			//Get the ITem text and store it in the global structure
			lpVal = sEmailConf.GetBuffer(CA_EMAIL_LEN+1);
			GetDlgItemText(hwndDlg,IDC_TXT_CONF_EMAIL,lpVal,CA_EMAIL_LEN+1);
			sEmailConf.ReleaseBuffer(-1);
			sEmailConf.TrimLeft(); sEmailConf.TrimRight();
			GetGlobalContext()->GetContactDataObject()->sEmailAddressConf =  sEmailConf;
			EndDialog(hwndDlg, IDOK);
			bRetCode = TRUE;
			break;
		default:
			break;
		}
		break;
	default:
		break;

	}
	return bRetCode;
}


LRW_DLG_INT CALLBACK
ContactInfo1DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		SendDlgItemMessage (hwnd , IDC_TXT_COMPANYNAME,	EM_SETLIMITTEXT, CA_COMPANY_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_ORGUNIT	  ,	EM_SETLIMITTEXT, CA_ORG_UNIT_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_LNAME,		EM_SETLIMITTEXT, CA_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FNAME,		EM_SETLIMITTEXT, CA_NAME_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_PHONE,		EM_SETLIMITTEXT, CA_PHONE_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FAX,			EM_SETLIMITTEXT, CA_FAX_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_EMAIL,		EM_SETLIMITTEXT, CA_EMAIL_LEN,0);

		//
		//Populate the values which were read from the Registry during Global Init
		//
		SetDlgItemText(hwnd,IDC_TXT_LNAME, GetGlobalContext()->GetContactDataObject()->sContactLName);
		SetDlgItemText(hwnd,IDC_TXT_FNAME, GetGlobalContext()->GetContactDataObject()->sContactFName);
		SetDlgItemText(hwnd,IDC_TXT_PHONE, GetGlobalContext()->GetContactDataObject()->sContactPhone);
		SetDlgItemText(hwnd,IDC_TXT_FAX,   GetGlobalContext()->GetContactDataObject()->sContactFax);
		SetDlgItemText(hwnd,IDC_TXT_EMAIL, GetGlobalContext()->GetContactDataObject()->sContactEmail);
		SetDlgItemText(hwnd,IDC_TXT_COMPANYNAME, GetGlobalContext()->GetContactDataObject()->sCompanyName);
		SetDlgItemText(hwnd,IDC_TXT_ORGUNIT, GetGlobalContext()->GetContactDataObject()->sOrgUnit);
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
				{
					//TCHAR	szEmailLabel[64];
					//TCHAR	szCapLabel[255];
					TCHAR szBuf[ 255];

                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK );

                    LoadString(GetInstanceHandle(),IDS_FAXOPTION_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));

					SetDlgItemText(hwnd, IDC_LBL_FAX, szBuf);

					if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
					{
						LoadString(GetInstanceHandle(),IDS_EMAIL_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));
					}
					else
					{
						LoadString(GetInstanceHandle(),IDS_EMAILOPTION_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));
					}
					SetDlgItemText(hwnd, IDC_LBL_EMAIL, szBuf);

					/* Email is optional now.
					//Change the lable of Caption & Email fields if it's Online Mode
					if(GetLRMode() == LRMODE_CH_REQUEST )
					{
						LoadString(GetInstanceHandle(),IDS_LBL_CONTACT_ONLINE,szCapLabel,255);
						SetDlgItemText(hwnd,IDC_LBL_CAPTION,szCapLabel);

						LoadString(GetInstanceHandle(),IDS_LBL_EMAIL_ONLINE,szEmailLabel,64);
						SetDlgItemText(hwnd,IDC_LBL_EMAIL,szEmailLabel);
					}
					else
					{
						LoadString(GetInstanceHandle(),IDS_LBL_CONTACT_OFFLINE,szCapLabel,255);
						SetDlgItemText(hwnd,IDC_LBL_CAPTION,szCapLabel);

						LoadString(GetInstanceHandle(),IDS_LBL_EMAIL_OFFLINE,szEmailLabel,64);
						SetDlgItemText(hwnd,IDC_LBL_EMAIL,szEmailLabel);
					}
					*/
				}
                break;

            case PSN_WIZNEXT:
				{
					CString sCompanyName;
					CString sOrgUnit;
					CString sLastName;
					CString sFirstName;
					CString sPhone;
					CString sFax;
					CString sEmail;
					LPTSTR  lpVal = NULL;					

					//Read all the fields
					lpVal = sCompanyName.GetBuffer(CA_COMPANY_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_COMPANYNAME,lpVal,CA_COMPANY_NAME_LEN+1);
					sCompanyName.ReleaseBuffer(-1);

					lpVal = sOrgUnit.GetBuffer(CA_ORG_UNIT_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ORGUNIT,lpVal,CA_ORG_UNIT_LEN+1);
					sOrgUnit.ReleaseBuffer(-1);

					lpVal = sLastName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_LNAME,lpVal,CA_NAME_LEN+1);
					sLastName.ReleaseBuffer(-1);
					
					lpVal = sFirstName.GetBuffer(CA_NAME_LEN+1);
	 				GetDlgItemText(hwnd,IDC_TXT_FNAME,lpVal,CA_NAME_LEN+1);
					sFirstName.ReleaseBuffer(-1);

					lpVal = sPhone.GetBuffer(CA_PHONE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_PHONE,lpVal,CA_PHONE_LEN+1);
					sPhone.ReleaseBuffer(-1);

					lpVal = sFax.GetBuffer(CA_FAX_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_FAX,lpVal,CA_FAX_LEN+1);
					sFax.ReleaseBuffer(-1);

					lpVal = sEmail.GetBuffer(CA_EMAIL_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_EMAIL,lpVal,CA_EMAIL_LEN+1);
					sEmail.ReleaseBuffer(-1);

					sFirstName.TrimLeft();   sFirstName.TrimRight();
					sLastName.TrimLeft();   sLastName.TrimRight();
					sPhone.TrimLeft();   sPhone.TrimRight(); 
					sFax.TrimLeft();   sFax.TrimRight(); 
					sEmail.TrimLeft();	 sEmail.TrimRight();
					sCompanyName.TrimLeft(); sCompanyName.TrimRight();
					sOrgUnit.TrimLeft(); sOrgUnit.TrimRight();
					
					if(sLastName.IsEmpty() || sFirstName.IsEmpty() || sCompanyName.IsEmpty() ||
					   (sEmail.IsEmpty() && GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET))
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						dwNextPage	= IDD_CONTACTINFO1;
						goto NextDone;
					}
					
					//
					// Check for the Invalid Characters
					//
					if( !ValidateLRString(sFirstName)	||
						!ValidateLRString(sLastName)	||
						!ValidateLRString(sPhone)		||
						!ValidateLRString(sEmail) 
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						dwNextPage = IDD_CONTACTINFO1;
						goto NextDone;
					}					
					
					dwNextPage = IDD_CONTACTINFO2;
					//
					// Validate email address if not empty
					//
					if(!sEmail.IsEmpty())
					{
						if(!ValidateEmailId(sEmail))
						{
							LRMessageBox(hwnd,IDS_ERR_INVALID_EMAIL);
							dwNextPage = IDD_CONTACTINFO1;
							goto NextDone;
						}

						if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
						{
							//Show dialog box to confirm the e-mail alias put in the dialog box
							if ( DialogBox ( GetInstanceHandle(),
											 MAKEINTRESOURCE(IDD_CONFIRM_EMAIL),
											 hwnd,
											 ConfirmEMailDlgProc ) == IDOK )
							{
								//Check to see if e-mail aliases match
								//if they match - proceed else stay right here
								if ( GetGlobalContext()->GetContactDataObject()->sEmailAddressConf.CompareNoCase(sEmail) != 0)
								{
									LRMessageBox(hwnd,IDS_EMAIL_MISMATCH);	
									dwNextPage	= IDD_CONTACTINFO1;
									goto NextDone;
								}
							}
							else
							{
								//user hit cancel.  So stay right where you are.
								LRMessageBox(hwnd,IDS_EMAIL_MISMATCH);	
								dwNextPage	= IDD_CONTACTINFO1;
								goto NextDone;
							}
						}
					}

					//
					//Finally update CHData object
					//
					GetGlobalContext()->GetContactDataObject()->sContactEmail = sEmail;
					GetGlobalContext()->GetContactDataObject()->sContactFName = sFirstName;
					GetGlobalContext()->GetContactDataObject()->sContactLName = sLastName;
					GetGlobalContext()->GetContactDataObject()->sContactPhone = sPhone;			
					GetGlobalContext()->GetContactDataObject()->sContactFax = sFax;			
					GetGlobalContext()->GetContactDataObject()->sCompanyName = sCompanyName;			
					GetGlobalContext()->GetContactDataObject()->sOrgUnit = sOrgUnit;			


					// Put into regsitery too
					GetGlobalContext()->SetInRegistery(szOID_RSA_emailAddr, (LPCTSTR) sEmail);
					GetGlobalContext()->SetInRegistery(szOID_COMMON_NAME, sFirstName);
					GetGlobalContext()->SetInRegistery(szOID_SUR_NAME, sLastName);
					GetGlobalContext()->SetInRegistery(szOID_TELEPHONE_NUMBER, sPhone);
					GetGlobalContext()->SetInRegistery(szOID_FACSIMILE_TELEPHONE_NUMBER, sFax);
					GetGlobalContext()->SetInRegistery(szOID_ORGANIZATION_NAME, sCompanyName);
					GetGlobalContext()->SetInRegistery(szOID_ORGANIZATIONAL_UNIT_NAME, sOrgUnit);

					//If no Error , go to the next page
					LRPush(IDD_CONTACTINFO1);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}



LRW_DLG_INT CALLBACK
ContactInfo2DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
    CString sCountryDesc;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		SendDlgItemMessage (hwnd , IDC_TXT_ADDRESS1,	EM_SETLIMITTEXT, CA_ADDRESS_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_CITY,		EM_SETLIMITTEXT, CA_CITY_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_STATE,		EM_SETLIMITTEXT, CA_STATE_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_ZIP,			EM_SETLIMITTEXT, CA_ZIP_LEN,0); 	
		
		
		PopulateCountryComboBox(GetDlgItem(hwnd,IDC_COMBO1));

		//
		//Populate the values which were read from the Registry during Global Init
		//
		SetDlgItemText(hwnd,IDC_TXT_ADDRESS1, GetGlobalContext()->GetContactDataObject()->sContactAddress);
		SetDlgItemText(hwnd,IDC_TXT_CITY	, GetGlobalContext()->GetContactDataObject()->sCity);
		SetDlgItemText(hwnd,IDC_TXT_STATE	, GetGlobalContext()->GetContactDataObject()->sState);
		SetDlgItemText(hwnd,IDC_TXT_ZIP		, GetGlobalContext()->GetContactDataObject()->sZip);

        GetCountryDesc(
                       GetGlobalContext()->GetContactDataObject()->sCountryCode,
                       sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1));
        sCountryDesc.ReleaseBuffer();

		ComboBox_SetCurSel(
                    GetDlgItem(hwnd,IDC_COMBO1),
                    ComboBox_FindStringExact(
                                    GetDlgItem(hwnd,IDC_COMBO1),
                                    0,
                                    sCountryDesc));

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString sAddress1;
					CString sCity;
					CString sState;
					LPTSTR  lpVal = NULL;
					CString sZip;
					CString sCountryDesc;
					CString sCountryCode;
					DWORD   dwRetCode;
					int		nCurSel = -1;

					//
					//Read all the fields
					//
					lpVal = sAddress1.GetBuffer(CA_ADDRESS_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ADDRESS1,lpVal,CA_ADDRESS_LEN+1);
					sAddress1.ReleaseBuffer(-1);
					
					lpVal = sCity.GetBuffer(CA_CITY_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_CITY,lpVal,CA_CITY_LEN+1);
					sCity.ReleaseBuffer(-1);

					lpVal = sState.GetBuffer(CA_STATE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_STATE,lpVal,CA_STATE_LEN+1);
					sState.ReleaseBuffer(-1);

					lpVal = sZip.GetBuffer(CA_ZIP_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ZIP,lpVal,CA_ZIP_LEN+1);
					sZip.ReleaseBuffer(-1);

			
					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_COMBO1));

					lpVal = sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_COMBO1), nCurSel, lpVal);
					sCountryDesc.ReleaseBuffer(-1);
					
					sAddress1.TrimLeft(); sAddress1.TrimRight();
					sCity.TrimLeft(); sCity.TrimRight();
					sState.TrimLeft(); sState.TrimRight();
					sZip.TrimLeft(); sZip.TrimRight();
					sCountryDesc.TrimLeft();sCountryDesc.TrimRight();

					if(sCountryDesc.IsEmpty())
//					if(sAddress1.IsEmpty() || sCity.IsEmpty() ||
//					   sState.IsEmpty() || sZip.IsEmpty() || sCountryDesc.IsEmpty())
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						dwNextPage	= IDD_CONTACTINFO2;
						goto NextDone;
					}

					if(
					   !ValidateLRString(sAddress1)	||
					   !ValidateLRString(sCity)		||
					   !ValidateLRString(sState)	||
					   !ValidateLRString(sZip)		||
					   !ValidateLRString(sCountryDesc)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						dwNextPage = IDD_CONTACTINFO2;
						goto NextDone;
					}


					lpVal = sCountryCode.GetBuffer(LR_COUNTRY_CODE_LEN+1);
					if (sCountryDesc.IsEmpty())
					{
						lstrcpy(lpVal, _TEXT(""));
					}
					else
					{
						GetCountryCode(sCountryDesc,lpVal);
					}
					sCountryCode.ReleaseBuffer(-1);

					//
					//Finally update CHData object
					//
					GetGlobalContext()->GetContactDataObject()->sCity			= sCity;
					GetGlobalContext()->GetContactDataObject()->sCountryDesc	= sCountryDesc;
					GetGlobalContext()->GetContactDataObject()->sCountryCode	= sCountryCode;
					GetGlobalContext()->GetContactDataObject()->sContactAddress	= sAddress1;
					GetGlobalContext()->GetContactDataObject()->sZip				= sZip;
					GetGlobalContext()->GetContactDataObject()->sState			= sState;					

					GetGlobalContext()->SetInRegistery(szOID_LOCALITY_NAME, sCity);
					GetGlobalContext()->SetInRegistery(szOID_COUNTRY_NAME, sCountryDesc);
					GetGlobalContext()->SetInRegistery(szOID_DESCRIPTION, sCountryCode);
					GetGlobalContext()->SetInRegistery(szOID_STREET_ADDRESS, sAddress1);
					GetGlobalContext()->SetInRegistery(szOID_POSTAL_CODE, sZip);
					GetGlobalContext()->SetInRegistery(szOID_STATE_OR_PROVINCE_NAME, sState);


                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
                    if (dwRetCode == ERROR_SUCCESS)
                    {
                        dwRetCode = LRGetLastRetCode();
                    }

                    if (dwRetCode != ERROR_SUCCESS)
                    {
                        LRMessageBox(hwnd, dwRetCode);
                        dwNextPage = IDD_CONTACTINFO2;
                    }
                    else
                    {
                        GetGlobalContext()->ClearWizStack();
                        LRPush(IDD_WELCOME);
                        dwNextPage = IDD_CONTINUEREG;
                    }

NextDone:	
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;				
					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\getmode.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include <assert.h>



static DWORD	g_dwAuthRetCode	= ERROR_SUCCESS;

static WIZCONNECTION g_enumPrevMethod = CONNECTION_DEFAULT;

DWORD WINAPI PingThread(void *pData)
{
	g_dwAuthRetCode = PingCH();	
	ExitThread(0);
	return 0;
}


LRW_DLG_INT CALLBACK 
GetModeDlgProc(IN HWND     hwnd,	
			   IN UINT     uMsg,		
			   IN WPARAM   wParam,	
			   IN LPARAM   lParam)
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
	HWND	hwndComboBox;
	TCHAR   lpBuffer[ 512];

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );


    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );  
        

		hwndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);
		assert(hwndComboBox != NULL); // Somebody has messed with the Res. Files.
		
		// Let user choose the mode of registration with Internet being default
		memset(lpBuffer,0,sizeof(lpBuffer));
		dwRetCode = LoadString(GetInstanceHandle(), IDS_INTERNETMODE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));        
		assert(dwRetCode != 0);        
		ComboBox_AddString(hwndComboBox,lpBuffer);		

		memset(lpBuffer,0,sizeof(lpBuffer));		
		dwRetCode = LoadString(GetInstanceHandle(), IDS_WWWMODE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
		assert(dwRetCode != 0);
		ComboBox_AddString(hwndComboBox,lpBuffer);

		memset(lpBuffer,0,sizeof(lpBuffer));
		dwRetCode = LoadString(GetInstanceHandle(), IDS_TELEPHONEMODE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
		assert(dwRetCode != 0);
		ComboBox_AddString(hwndComboBox,lpBuffer);
		

		if(GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET ||
		   GetGlobalContext()->GetActivationMethod() == CONNECTION_DEFAULT) //Partially fix bug # 577
		{
			ComboBox_SetCurSel(hwndComboBox, 0);			

			memset(lpBuffer,0,sizeof(lpBuffer));
			LoadString(GetInstanceHandle(),IDS_INTERNET_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
			SetDlgItemText(hwnd,IDC_TXT_DESC,lpBuffer);
            
		}

		if(GetGlobalContext()->GetActivationMethod() == CONNECTION_WWW )
		{
			ComboBox_SetCurSel(hwndComboBox, 1);

			memset(lpBuffer,0,sizeof(lpBuffer));
			LoadString(GetInstanceHandle(),IDS_WWW_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
			SetDlgItemText(hwnd,IDC_TXT_DESC,lpBuffer);
            
		}	

		if(GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE )
		{
			ComboBox_SetCurSel(hwndComboBox, 2);

			memset(lpBuffer,0,sizeof(lpBuffer));
			LoadString(GetInstanceHandle(),IDS_TELEPHONE_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
			SetDlgItemText(hwnd,IDC_TXT_DESC,lpBuffer);

		}        

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if(HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_MODEOFREG)
		{
			dwRetCode = ComboBox_GetCurSel((HWND)lParam);
			if(dwRetCode == 0)
			{
				memset(lpBuffer,0,sizeof(lpBuffer));
				LoadString(GetInstanceHandle(),IDS_INTERNET_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
				SetDlgItemText(hwnd,IDC_TXT_DESC,lpBuffer);
              
			}
			if(dwRetCode == 2)
			{
				memset(lpBuffer,0,sizeof(lpBuffer));
				LoadString(GetInstanceHandle(),IDS_TELEPHONE_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
				SetDlgItemText(hwnd,IDC_TXT_DESC,lpBuffer);
               
			}
			if(dwRetCode == 1)
			{
				memset(lpBuffer,0,sizeof(lpBuffer));
				LoadString(GetInstanceHandle(),IDS_WWW_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
				SetDlgItemText(hwnd,IDC_TXT_DESC,lpBuffer);
          
			}
		}

		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
			hwndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);
			assert(hwndComboBox != NULL); // Somebody has messed with the Res. Files.

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK );                
                break;

            case PSN_WIZNEXT:
				// What did the user choose ??
				dwRetCode = ComboBox_GetCurSel(hwndComboBox);
				assert(dwRetCode >= 0 && dwRetCode <= 2);

				switch(dwRetCode)
				{
				case 0:
					// Only applicable for Registration, so the Ping Goes Thru'
					dwRetCode = ShowProgressBox(hwnd, PingThread, 0, 0, 0);
					if(g_dwAuthRetCode == ERROR_SUCCESS)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_INTERNET);
						dwNextPage = GetGlobalContext()->GetEntryPoint();
					}
					else
					{
						LRMessageBox(hwnd,g_dwAuthRetCode,LRGetLastError());
						dwNextPage = IDD_DLG_GETREGMODE;
					}
					break;

				case 1:
					GetGlobalContext()->SetActivationMethod(CONNECTION_WWW);
					dwNextPage = IDD_DLG_WWWREG;
					break;

				case 2:
					GetGlobalContext()->SetActivationMethod(CONNECTION_PHONE);
					//Check if the Required Registry key is ok or not
					dwRetCode = GetGlobalContext()->CheckRegistryForPhoneNumbers();
					if(dwRetCode != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd,dwRetCode,LRGetLastError());
						dwNextPage = IDD_DLG_GETREGMODE;
					}
					else
						dwNextPage = IDD_DLG_COUNTRYREGION;

					break;

				default:
					GetGlobalContext()->SetActivationMethod(CONNECTION_DEFAULT);
					dwNextPage = IDD_DLG_GETREGMODE;
					break;
				}
				
		
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;

				if (dwNextPage != IDD_DLG_GETREGMODE)
				{
					LRPush(IDD_DLG_GETREGMODE);
				}

                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;                
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}






LRW_DLG_INT CALLBACK 
CountryRegionProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
	HWND	hWndCSR = GetDlgItem(hwnd, IDC_COUNTRYREGION );

	LVFINDINFO	lvFindInfo;
	int			nItem = 0;
	HWND	hWndListBox = 0 ;
	

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );


    switch (uMsg) 
    {	
    case WM_INITDIALOG:		

		pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
		LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		hWndListBox = GetDlgItem(hwnd, IDC_COUNTRYREGION );		

		//Setup columns in list view
		{
			LV_COLUMN	lvColumn;
			TCHAR		lpszHeader[ 128];
			lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
			lvColumn.fmt = LVCFMT_LEFT;
			lvColumn.cx  = 250;

			LoadString(GetInstanceHandle(), IDS_COUNTRYREGION_HEADER, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndCSR, 0, &lvColumn);

			lvColumn.pszText = _TEXT("");
			lvColumn.cx = 0;
			ListView_InsertColumn(hWndCSR, 1, &lvColumn);            
		}					

		g_enumPrevMethod = GetGlobalContext()->GetActivationMethod();

		if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
		{
			dwRetCode = PopulateCountryRegionComboBox(hWndCSR);
			//fix bug 575 BEGIN
			memset(&lvFindInfo,0,sizeof(lvFindInfo));
			lvFindInfo.flags = LVFI_STRING;
			lvFindInfo.psz	 = GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion;

			nItem = ListView_FindItem(hWndListBox,-1,&lvFindInfo);				
				
				
			ListView_SetItemState(hWndListBox,nItem,LVIS_SELECTED,LVIS_SELECTED);
			ListView_SetSelectionMark(hWndListBox,nItem);
			ListView_SetSelectionMark(hWndListBox,nItem);
			//fix bug 575 END
		}
	
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
	
				//
				// If the PrevMethod and The Current method don't match
				// then Country/Region list box must be reloaded
				//
				hWndListBox = GetDlgItem(hwnd, IDC_COUNTRYREGION );		
				if( GetGlobalContext()->GetActivationMethod()  != g_enumPrevMethod )
				{
					if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
					{
						dwRetCode = PopulateCountryRegionComboBox(hWndCSR);
					}
					
					g_enumPrevMethod = GetGlobalContext()->GetActivationMethod();
				}

				nItem = ListView_GetSelectionMark(hWndCSR);
				//Select the previous selected country
				if (nItem ==-1 && GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
				{
					dwRetCode = PopulateCountryRegionComboBox(hWndCSR);
					//fix bug 575 BEGIN
					memset(&lvFindInfo,0,sizeof(lvFindInfo));
					lvFindInfo.flags = LVFI_STRING;
					lvFindInfo.psz	 = GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion;

					nItem = ListView_FindItem(hWndListBox,-1,&lvFindInfo);				
						
						
					ListView_SetItemState(hWndListBox,nItem,LVIS_SELECTED,LVIS_SELECTED);
					ListView_SetSelectionMark(hWndListBox,nItem);
					ListView_SetSelectionMark(hWndListBox,nItem);
					//fix bug 575 END
				}

				PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
				// What did the user choose ??
				{
					TCHAR lpVal[ 128];
					int nItem = ListView_GetSelectionMark(hWndCSR);

					if (nItem != -1)
					{
						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 1;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = 128;

						ListView_GetItem(hWndCSR, &lvItem);				
					
						if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
						{
							GetGlobalContext()->SetCSRNumber(lpVal);
						}
					}
					else
					{
						LRMessageBox(hwnd, IDS_ERR_NOCOUNTRYSELECTED, 0);
						dwNextPage = IDD_DLG_COUNTRYREGION;
						bStatus = -1;
						LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
						break;
					}
				}

				if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
				{
					dwNextPage = GetGlobalContext()->GetEntryPoint();
				}
				else
				{
					dwNextPage = IDD_LICENSETYPE;
				}
/*
				dwNextPage = IDD_DLG_COUNTRYREGION;
				switch( GetGlobalContext()->GetWizAction() )
				{
				case WIZACTION_REGISTERLS:
				case WIZACTION_CONTINUEREGISTERLS:
					dwNextPage = IDD_DLG_TELREG;
					break;

				case WIZACTION_REREGISTERLS:
					break;

				case WIZACTION_UNREGISTERLS:
					break;

				case WIZACTION_DOWNLOADLKP:
					break;
				}

*/				bStatus = -1;
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				if (dwNextPage != IDD_DLG_COUNTRYREGION)
				{
					LRPush(IDD_DLG_COUNTRYREGION);
				}

                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;                
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\dlgproc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _DLGPROC_H_
#define _DLGPROC_H_
LRW_DLG_INT CALLBACK
CustInfoLicenseType(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
CHRegisterMOLPDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
CHRegisterSelectDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
ContactInfo1DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
ContactInfo2DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
ContinueRegFax(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
PINDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
ContinueReg(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
FaxLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
FaxRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
GetModeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
CountryRegionProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
CertLogProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
ConfRevokeProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
TelReissueProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
ProgressDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
RetailSPKProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK 
EditRetailSPKDlgProc(  
	IN HWND hwndDlg,
	IN UINT uMsg,   
	IN WPARAM wParam,
	IN LPARAM lParam 
 );

LRW_DLG_INT CALLBACK
TelLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
TelRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
WelcomeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
WWWRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
WWWLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\lrwizapi.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "lrwizapi.h"
#include "lrwizdll.h"

DWORD LSRegister(HWND hWndParent,LPTSTR szLSName)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	BOOL bRefresh;

	dwRetCode = StartWizard(hWndParent, WIZACTION_REGISTERLS, (LPCTSTR) szLSName, &bRefresh);

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\global.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "afxcoll.h"
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include "tlsapip.h"
#include "global.h"
#include "utils.h"
#include "assert.h"
#include "lrwizapi.h"
#include "lmcons.h"
#include "lmerr.h"
#include "lmserver.h"
#include "trust.h"
#include "chstruct.h"
#include "lkplite.h"
#include <wininet.h>


#define  ACTIVATIONMETHOD_KEY			"ACTIVATIONMETHOD"
#define  CSRNUMBER_KEY					"CSRNUMBER"

CGlobal::CGlobal()
{	

	m_hWndParent		=	NULL;
	m_hInstance			=	NULL;

	m_lpstrLSName		=	NULL;
	m_lpwstrLSName		=	NULL;

	m_lpstrCHServer     =	NULL;
	m_lpstrCHExtension  =	NULL;

	m_dwErrorCode		=	0;

	m_pReqAttr			=	NULL;

	m_dwReqAttrCount	=	0;

	m_pRegAttr			=	NULL;
	m_dwRegAttrCount	=	NULL;
	m_dwLSStatus		=   LSERVERSTATUS_UNREGISTER;

	m_ContactData.Initialize();
	m_LicData.Initialize();
	m_ActivationMethod = CONNECTION_INTERNET;

	m_dwExchangeCertificateLen  = 0;
	m_pbExchangeCertificate		= NULL;

	m_dwSignCertificateLen  = 0;
	m_pbSignCertificate		= NULL;

	m_dwExtenstionValueLen	= 0;
	m_pbExtensionValue		= NULL;

	m_lpstrPIN			= NULL;

	m_dwRequestType	= REQUEST_NULL;

	m_WizAction = WIZACTION_REGISTERLS;
	m_hOpenDirect = NULL;
	m_hConnect = NULL;
	m_hRequest = NULL;

	m_phLSContext = NULL;

	m_pRegistrationID[ 0] = m_pLicenseServerID[ 0] = 0;

	m_dwRefresh = 0;

	m_lpCSRNumber[ 0]	= 0;
	m_lpWWWSite[0]		= 0;

	m_pLSLKP[ 0] = m_pLSSPK[ 0] = 0;

	m_dwLastRetCode		= 0;

	m_dwLangId	= 0;

    m_fSupportConcurrent = FALSE;

    m_fSupportWhistlerCAL = FALSE;

	InitSPKList();
	//
	// Initialize the Wizard Page stack
	//
	ClearWizStack();
}



void CGlobal::FreeGlobal()
{
	if (m_pbSignCertificate != NULL)
	{
		LocalFree(m_pbSignCertificate);
		m_pbSignCertificate = NULL;
	}

	if (m_pbExchangeCertificate != NULL)
	{
		LocalFree(m_pbExchangeCertificate);
		m_pbExchangeCertificate = NULL;
	}

	if (m_lpwstrLSName)
	{
		delete m_lpwstrLSName;
		m_lpwstrLSName = NULL;
	}

	if(m_lpstrCHServer)
	{
		delete m_lpstrCHServer;
		m_lpstrCHServer = NULL;
	}

	if (m_lpstrCHExtension)
	{
		delete m_lpstrCHExtension;
		m_lpstrCHExtension = NULL;
	}

	if(m_pbExtensionValue)
	{
		delete m_pbExtensionValue;
		m_pbExtensionValue = NULL;
	}

	if(m_lpstrPIN)
	{
		delete m_lpstrPIN;
		m_lpstrPIN = NULL;
	}

	m_csaCountryDesc.RemoveAll();
	m_csaCountryCode.RemoveAll();

	m_csaProductDesc.RemoveAll();
	m_csaProductCode.RemoveAll();
	
	m_csaDeactReasonCode.RemoveAll();
	m_csaDeactReasonDesc.RemoveAll();

	m_csaReactReasonCode.RemoveAll();
	m_csaReactReasonDesc.RemoveAll();
}


CGlobal::~CGlobal()
{
	FreeGlobal();
}


void CGlobal::ClearWizStack()
{
	DWORD dwIndex;

	m_dwTop		= 0;

	for(dwIndex = 0 ; dwIndex < NO_OF_PAGES ; dwIndex++)
		m_dwWizStack[dwIndex] = 0;
}



PCONTACTINFO CGlobal::GetContactDataObject()
{
	return &m_ContactData;
}


PTSLICINFO CGlobal::GetLicDataObject()
{
	return &m_LicData;
}



DWORD CGlobal::InitGlobal()
{
	DWORD	dwRetCode = ERROR_SUCCESS;

	DWORD	dwDataLen		= 0;
	DWORD	dwDisposition	= 0;
	DWORD	dwType			= REG_SZ;
	HKEY	hKey			= NULL;

	LPTSTR	lpszValue		= NULL;
	LPTSTR	lpszDelimiter	= (LPTSTR)L"~";

	CString	sCountryDesc;
	LPTSTR	lpTemp			= NULL;

	TLSPrivateDataUnion		getParm;
	PTLSPrivateDataUnion	pRtn	=	NULL;
	error_status_t			esRPC	=	ERROR_SUCCESS;
	DWORD					dwRetDataType = 0;
    DWORD                   dwSupportFlags;
	TCHAR   lpBuffer[ 1024];
	

	m_ContactData.Initialize();
	m_LicData.Initialize();

	m_dwLSStatus		=   LSERVERSTATUS_UNREGISTER;
	m_phLSContext = NULL;


	//
	// Load Countries from the String Table
	//
	LoadCountries();


	LoadReasons();

	//
	// Get CH URL from the LS Registry
	//
	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_PARAMS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	

	//
	//LR State
	//
	m_dwLRState	= 0;
	dwType		= REG_DWORD;
	dwDataLen	= sizeof(m_dwLRState);
	RegQueryValueEx(hKey,
					REG_LRWIZ_STATE,
					0,
					&dwType,
					(LPBYTE)&m_dwLRState,
					&dwDataLen
					);

	lpBuffer[ 0] = 0;
	GetFromRegistery(ACTIVATIONMETHOD_KEY, lpBuffer, FALSE);
	if (_tcslen(lpBuffer) != 0)
	{
		m_ActivationMethod = (WIZCONNECTION) _ttoi(lpBuffer);
	}
	else
	{
		m_ActivationMethod = CONNECTION_DEFAULT; //Partially fix bug # 577
	}

    if ((m_ActivationMethod != CONNECTION_DEFAULT)
        && (m_ActivationMethod != CONNECTION_INTERNET)
        && (m_ActivationMethod != CONNECTION_WWW)
        && (m_ActivationMethod != CONNECTION_PHONE))
    {
        m_ActivationMethod = CONNECTION_DEFAULT;
    }

	GetFromRegistery(CSRNUMBER_KEY, m_lpCSRNumber, FALSE);


	//
	// LKP Request Count
	//
	m_dwLRCount	= 0;
	dwType		= REG_DWORD;
	dwDataLen	= sizeof(m_dwLRCount);
	RegQueryValueEx(hKey,
					REG_LR_COUNT,
					0,
					&dwType,
					(LPBYTE)&m_dwLRCount,
					&dwDataLen
					);


	// dwDataLen includes the null terminating char.
	// So if the key is empty,dwDataLen is 2 bytes, not 0. 
	// See raid bug id : 336.
	//
	//CH URL
	//
	dwType		= REG_SZ;
	dwDataLen	= 0;
	RegQueryValueEx(hKey,
					REG_CH_SERVER,
					0,
					&dwType,
					NULL,
					&dwDataLen
					);

	if(dwDataLen <= sizeof(TCHAR))
	{
		dwRetCode = IDS_ERR_CHURLKEY_EMPTY;
		goto done;
	}

	m_lpstrCHServer = new TCHAR[dwDataLen+1];
	memset(m_lpstrCHServer, 0, (dwDataLen+1)*sizeof(TCHAR) );
	
	RegQueryValueEx(hKey,
					REG_CH_SERVER,
					0,
					&dwType,
					(LPBYTE)m_lpstrCHServer,
					&dwDataLen
					);

	//
	//CH Extension
	//
	dwType		= REG_SZ;
	dwDataLen	= 0;
	RegQueryValueEx(hKey,
					REG_CH_EXTENSION,
					0,
					&dwType,
					NULL,
					&dwDataLen
					);

	if(dwDataLen <= sizeof(TCHAR))
	{
		dwRetCode = IDS_ERR_CHURLKEY_EMPTY;
		goto done;
	}

	m_lpstrCHExtension = new TCHAR[dwDataLen+1];
	memset(m_lpstrCHExtension, 0, (dwDataLen+1)*sizeof(TCHAR) );
	
	RegQueryValueEx(hKey,
					REG_CH_EXTENSION,
					0,
					&dwType,
					(LPBYTE)m_lpstrCHExtension,
					&dwDataLen
					);


	//
	// WWW site address
	//
	dwType		= REG_SZ;
	dwDataLen	= sizeof(m_lpWWWSite);
	dwRetCode = RegQueryValueEx(hKey,
					REG_WWW_SITE,
					0,
					&dwType,
					(LPBYTE)m_lpWWWSite,
					&dwDataLen
					);

	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_CHURLKEY_EMPTY;	
		goto done;
	}

	

	m_ContactData.sContactAddress = GetFromRegistery(szOID_STREET_ADDRESS, lpBuffer, FALSE);
	m_ContactData.sZip = GetFromRegistery(szOID_POSTAL_CODE, lpBuffer, FALSE);
	m_ContactData.sCity = GetFromRegistery(szOID_LOCALITY_NAME, lpBuffer, FALSE);
	m_ContactData.sCountryCode = GetFromRegistery(szOID_DESCRIPTION, lpBuffer, FALSE);
	m_ContactData.sCountryDesc = GetFromRegistery(szOID_COUNTRY_NAME, lpBuffer, FALSE);
	m_ContactData.sState = GetFromRegistery(szOID_STATE_OR_PROVINCE_NAME, lpBuffer, FALSE);
	m_ContactData.sCompanyName = GetFromRegistery(szOID_ORGANIZATION_NAME, lpBuffer, FALSE);
	m_ContactData.sOrgUnit = GetFromRegistery(szOID_ORGANIZATIONAL_UNIT_NAME, lpBuffer, FALSE);
	m_ContactData.sContactFax = GetFromRegistery(szOID_FACSIMILE_TELEPHONE_NUMBER, lpBuffer, FALSE);
	m_ContactData.sContactPhone = GetFromRegistery(szOID_TELEPHONE_NUMBER, lpBuffer, FALSE);
	m_ContactData.sContactLName = GetFromRegistery(szOID_SUR_NAME, lpBuffer, FALSE);
	m_ContactData.sContactFName = GetFromRegistery(szOID_COMMON_NAME, lpBuffer, FALSE);
	m_ContactData.sContactEmail = GetFromRegistery(szOID_RSA_emailAddr, lpBuffer, FALSE);
	m_ContactData.sProgramName = GetFromRegistery(szOID_BUSINESS_CATEGORY, lpBuffer, FALSE);	
	m_ContactData.sCSRFaxRegion = GetFromRegistery(REG_LRWIZ_CSFAXREGION, lpBuffer, FALSE);
	m_ContactData.sCSRPhoneRegion = GetFromRegistery(REG_LRWIZ_CSPHONEREGION, lpBuffer, FALSE);


	InitSPKList();

	SetLSLangId(GetUserDefaultUILanguage());

	//
	// Get the info for the License Server.
	//
	dwRetCode = ConnectToLS();
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	} 
	
	dwRetCode = TLSGetSupportFlags(
                        m_phLSContext,
                        &dwSupportFlags
                );
    
	if (dwRetCode == RPC_S_OK)
    {
        if (dwSupportFlags & SUPPORT_CONCURRENT)
        {
            m_fSupportConcurrent = TRUE;
        }
        else
        {
            m_fSupportConcurrent = FALSE;
        }

        if (dwSupportFlags & SUPPORT_WHISTLER_CAL)
        {
            m_fSupportWhistlerCAL = TRUE;            
        }
        else
        {
            m_fSupportWhistlerCAL = FALSE;
        }
    }
    else
    {
        m_fSupportConcurrent = FALSE;
        m_fSupportWhistlerCAL = FALSE;
        dwRetCode = RPC_S_OK;   // OK if this fails
    }

	//
	// Load Products from the String Table
	//
	LoadProducts();

done:
	DisconnectLS();

	if(pRtn)
		midl_user_free(pRtn);

	if(hKey)
		RegCloseKey(hKey);

	DisconnectLSRegistry();

	return dwRetCode;
}


DWORD CGlobal::CheckRequieredFields()
{
	DWORD	dwRetCode = ERROR_SUCCESS;
		
	//Validate sProgramName (Partially fix bug # 577)
	if ( (m_ContactData.sProgramName != PROGRAM_SELECT &&
		  m_ContactData.sProgramName != PROGRAM_MOLP &&
		  m_ContactData.sProgramName != PROGRAM_RETAIL)    ||

		  (m_ContactData.sCompanyName	== "" ||
		  m_ContactData.sContactLName	== "" ||
		  m_ContactData.sContactFName	== "" ||		  
		  m_ContactData.sCountryCode	== "" ||
		  m_ContactData.sCountryDesc	== "")             ||

		 (m_ContactData.sContactEmail	== "" &&
		 GetActivationMethod() == CONNECTION_INTERNET)      )
	{			
		dwRetCode = IDS_ERR_REQ_FIELD_EMPTY;	
	}
	
	return dwRetCode;

}

void CGlobal::SetLSStatus(DWORD dwStatus)
{
	m_dwLSStatus = dwStatus;
}

DWORD CGlobal::GetLSStatus(void)
{
	return m_dwLSStatus;
}


void CGlobal::SetInstanceHandle(HINSTANCE hInst)
{
	m_hInstance = hInst;
}

HINSTANCE CGlobal::GetInstanceHandle()
{
	return m_hInstance;
}

void CGlobal::SetLSName(LPCTSTR lpstrLSName)
{	

	if(m_lpwstrLSName)
	{
		delete m_lpwstrLSName;
		m_lpwstrLSName = NULL;
	}

	if (lpstrLSName != NULL)
	{
		m_lpwstrLSName	= new WCHAR[MAX_COMPUTERNAME_LENGTH + 1];
		wcscpy(m_lpwstrLSName,(LPWSTR)lpstrLSName);

		m_lpstrLSName = (LPTSTR) lpstrLSName;
	}
}


WIZCONNECTION	CGlobal::GetActivationMethod(void)
{
	return m_ActivationMethod;
}

void CGlobal::SetActivationMethod(WIZCONNECTION conn)
{
	TCHAR acBuf[ 32];

	_stprintf(acBuf, _T("%d"), conn);
	SetInRegistery(ACTIVATIONMETHOD_KEY, acBuf);

	m_ActivationMethod = conn;
}


WIZCONNECTION CGlobal::GetLSProp_ActivationMethod(void)
{
	return m_LSProp_ActivationMethod;
}

void CGlobal::SetLSProp_ActivationMethod(WIZCONNECTION conn)
{
	m_LSProp_ActivationMethod = conn;
}


WIZACTION	CGlobal::GetWizAction(void)
{
	return m_WizAction;
}

void CGlobal::SetWizAction(WIZACTION act)
{
	m_WizAction = act;
}


DWORD CGlobal::GetEntryPoint(void)
{
	DWORD dwReturn = 0;

	switch (m_ActivationMethod)
	{
	case CONNECTION_INTERNET:
		switch (m_WizAction)
		{
		case WIZACTION_REGISTERLS:
			dwReturn = IDD_LICENSETYPE;
			break;

		case WIZACTION_CONTINUEREGISTERLS:
			dwReturn = IDD_CONTINUEREG;
			break;

		case WIZACTION_DOWNLOADLKP:
			if (m_ContactData.sProgramName == PROGRAM_SELECT)
			{
				dwReturn = IDD_CH_REGISTER_SELECT;
			}
			else if (m_ContactData.sProgramName == PROGRAM_MOLP)
			{
				dwReturn = IDD_CH_REGISTER_MOLP;
			}
			else
			{
				dwReturn = IDD_DLG_RETAILSPK;
			}
			break;

		case WIZACTION_UNREGISTERLS:
		case WIZACTION_REREGISTERLS:
			dwReturn = IDD_DLG_CERTLOG_INFO;
			break;

		case WIZACTION_SHOWPROPERTIES:
			dwReturn = IDD_WELCOME;
			break;
		}
		break;

	case CONNECTION_PHONE:
		switch (m_WizAction)
		{
		case WIZACTION_REGISTERLS:
		case WIZACTION_CONTINUEREGISTERLS:
			dwReturn = IDD_DLG_TELREG;
			break;

		case WIZACTION_DOWNLOADLASTLKP:
		case WIZACTION_DOWNLOADLKP:
			// Calls Authenticate
			dwReturn = IDD_DLG_TELLKP;
			break;

		case WIZACTION_UNREGISTERLS:
			dwReturn = IDD_DLG_CONFREVOKE;
			break;

		case WIZACTION_REREGISTERLS:
			dwReturn = IDD_DLG_TELREG_REISSUE;
			break;

		case WIZACTION_SHOWPROPERTIES:
			dwReturn = IDD_WELCOME;
			break;
		}
		break;


	case CONNECTION_WWW:
		switch (m_WizAction)
		{
		case WIZACTION_REGISTERLS:
		case WIZACTION_CONTINUEREGISTERLS:
			dwReturn = IDD_DLG_WWWREG;
			break;

		case WIZACTION_DOWNLOADLASTLKP:
		case WIZACTION_DOWNLOADLKP:
			// Calls Authenticate
			dwReturn = IDD_DLG_WWWLKP;
			break;

		case WIZACTION_UNREGISTERLS:
		case WIZACTION_REREGISTERLS:
		case WIZACTION_SHOWPROPERTIES:
			dwReturn = IDD_WELCOME;
			break;
		}
		break;

	default:
		break;
	}

	return dwReturn;
}



DWORD CGlobal::LRGetLastError()
{
	DWORD dwRet;

	dwRet			= m_dwErrorCode;
	m_dwErrorCode	= 0;

	return dwRet;
}

void CGlobal::LRSetLastError(DWORD dwErrorCode)
{
	m_dwErrorCode = dwErrorCode;
}

 int CGlobal::LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwErrorCode /*=0*/)
{
	TCHAR	szBuf[LR_MAX_MSG_TEXT];
	TCHAR	szMsg[LR_MAX_MSG_TEXT];
	TCHAR	szCaption[LR_MAX_MSG_CAPTION];
    
    LoadString(GetInstanceHandle(),dwMsgId,szMsg,LR_MAX_MSG_TEXT);
	LoadString(GetInstanceHandle(),IDS_TITLE,szCaption,LR_MAX_MSG_CAPTION);
    
	if(dwErrorCode != 0)
	{
        DWORD dwRet = 0;
        LPTSTR lpszTemp = NULL;

        dwRet=FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                             NULL,
                             dwErrorCode,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             NULL);

	    
           
		_stprintf(szBuf,szMsg,dwErrorCode);

        if(dwRet != 0 && lpszTemp != NULL)
        {
            lstrcat(szBuf, _T(", "));
            lstrcat(szBuf, lpszTemp);                
            LocalFree(lpszTemp);
        }
	}
	else
	{
		_tcscpy(szBuf,szMsg);
	}    

	return MessageBox(hWndParent,szBuf,szCaption,MB_OK|MB_ICONSTOP);
}


BOOL CGlobal::IsLSRunning()
{
	DWORD dwRetCode = ERROR_SUCCESS;    
	
	if (ConnectToLS() != ERROR_SUCCESS)
	{
		return FALSE;        
	}

    DisconnectLS();

    
	return TRUE;	
}



DWORD CGlobal::ResetLSSPK(BOOL bGenKey)
{
	DWORD dwRetCode;

	error_status_t		esRPC			= ERROR_SUCCESS;

	dwRetCode = ConnectToLS();

	if(dwRetCode == ERROR_SUCCESS)
	{		
		// Make LS Regen Key call HERE
		dwRetCode = TLSTriggerReGenKey(m_phLSContext, bGenKey, &esRPC);

		if(dwRetCode != RPC_S_OK || esRPC != ERROR_SUCCESS)
		{
			dwRetCode = IDS_ERR_RPC_FAILED;		
		}
		else
		{
			dwRetCode = ERROR_SUCCESS;
		}
	}

	DisconnectLS();
	LRSetLastError(dwRetCode);

	return dwRetCode;
}





DWORD CGlobal::GetLSCertificates(PDWORD pdwServerStatus)
{
	DWORD				dwRetCode		= ERROR_SUCCESS;	
	PCONTEXT_HANDLE		phLSContext		= NULL;
	error_status_t		esRPC			= ERROR_SUCCESS;
	error_status_t		esTemp			= ERROR_SUCCESS;
	PBYTE				pCertBlob		= NULL;
	PBYTE				pSignCertBlob	= NULL;
	DWORD				dwCertBlobLen	= 0;
	DWORD				dwSignCertBlobLen = 0;
	DWORD				dwCertSize		= 0;
	DWORD				dwRegIDLength   = 0;
	DWORD				dwLSIDLen		= 0;
	
	HCRYPTPROV			hCryptProvider	= NULL;
	CRYPT_DATA_BLOB		CertBlob;
	HCERTSTORE			hCertStore		= NULL;
	PCCERT_CONTEXT		pcCertContext	= NULL; 
	PCERT_EXTENSION		pCertExtension	= NULL;
	BYTE * pByte = NULL;

	m_dwExchangeCertificateLen  = 0;
	if (m_pbExchangeCertificate != NULL)
	{
		LocalFree(m_pbExchangeCertificate);
	}
	if (m_pbSignCertificate != NULL)
	{
		LocalFree(m_pbSignCertificate);
	}

	m_pbSignCertificate			= NULL;
	m_pbExchangeCertificate		= NULL;
	*pdwServerStatus			= LSERVERSTATUS_UNREGISTER;
	m_pRegistrationID[0]		= NULL;
	m_pLicenseServerID[0]		= NULL;
    
	dwRetCode = ConnectToLS();
	if (dwRetCode != ERROR_SUCCESS)
	{		
		goto done;
	}

	// We need the License Server ID
	dwRetCode = TLSGetServerPID( m_phLSContext,
								 &dwLSIDLen,
								 &pByte,
								 &esRPC );
	if (dwRetCode != RPC_S_OK)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_FAILED;		
		goto done;
	}

	if (esRPC == LSERVER_E_DATANOTFOUND || 
		dwLSIDLen != sizeof(TCHAR)*(LR_LICENSESERVERID_LEN+1))
	{
		if (pByte != NULL)
		{
			LocalFree(pByte);
		}

		dwRetCode = IDS_ERR_NOLSID;
		goto done;
	}

	assert(esRPC == ERROR_SUCCESS && pByte != NULL);
	memcpy(m_pLicenseServerID, pByte, sizeof(TCHAR)*(LR_LICENSESERVERID_LEN+1));
	LocalFree(pByte);

	//Try and get the LSServerCertificate first	
	dwRetCode =  TLSGetServerCertificate (	m_phLSContext,
											FALSE,
											&pCertBlob,
											&dwCertBlobLen,
											&esRPC );
	if(dwRetCode != RPC_S_OK)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_FAILED;		
		goto done;
	}

	if (esRPC == LSERVER_I_TEMP_SELFSIGN_CERT )
	{
		// Certificate is NOT signed & does not have the SPK
		dwRetCode = ERROR_SUCCESS;
		goto done;
	}
	else 
	{
		// Certificate is either msft signed OR there is an SPK
		// in it.
		pByte = NULL;
		dwRetCode = TLSGetServerSPK( m_phLSContext,
									 &dwRegIDLength,
									 &pByte,
									 &esTemp );

		if (dwRetCode != RPC_S_OK)
		{
			LRSetLastError(dwRetCode);
			dwRetCode = IDS_ERR_RPC_FAILED;		
			goto done;
		}

		if (esTemp == LSERVER_E_DATANOTFOUND)
		{			
			if (pByte != NULL)
			{
				LocalFree(pByte);
			}

			dwRetCode = ERROR_SUCCESS;
			goto done;
		}

		if (esTemp != ERROR_SUCCESS)
		{
			if (pByte != NULL)
			{
				LocalFree(pByte);
			}
			LRSetLastError(dwRetCode);
			dwRetCode = IDS_ERR_RPC_FAILED;		
			goto done;
		}

		if (dwRegIDLength != sizeof(TCHAR)*(LR_REGISTRATIONID_LEN+1))
		{
			// What happened to the SPK's Length ??
			if (pByte != NULL)
			{
				LocalFree(pByte);
			}
			dwRetCode = IDS_ERR_INVALIDLENGTH;		
			LRSetLastError(dwRetCode);
			goto done;
		}

		assert(pByte != NULL);
		memcpy(m_pRegistrationID, pByte, sizeof(TCHAR)*(LR_REGISTRATIONID_LEN+1));
		LocalFree(pByte);
	}


	if(esRPC != LSERVER_I_SELFSIGN_CERTIFICATE && esRPC != ERROR_SUCCESS )
	{
		LRSetLastError(esRPC);
		dwRetCode = IDS_ERR_LS_ERROR;
		goto done;
	}

	m_pbExchangeCertificate		= pCertBlob;
	m_dwExchangeCertificateLen	= dwCertBlobLen;


	// Now that everything has succeded, let us get thesigning cert
	dwRetCode =  TLSGetServerCertificate (	m_phLSContext,
											TRUE,
											&pSignCertBlob,
											&dwSignCertBlobLen,
											&esRPC );

	if (dwRetCode == RPC_S_OK && esRPC == LSERVER_S_SUCCESS )
	{
		m_pbSignCertificate		= pSignCertBlob;
		m_dwSignCertificateLen	= dwSignCertBlobLen;
	}
	else
	{
		dwRetCode = ERROR_SUCCESS;  // Ignore this error;
		m_pbSignCertificate = NULL;
		m_dwSignCertificateLen  = 0;
	}
	

	//
	//Get the Extensions from the Certificate
	//	
	if ( esRPC != LSERVER_I_SELFSIGN_CERTIFICATE )
	{
		CertBlob.cbData = m_dwExchangeCertificateLen;
		CertBlob.pbData = m_pbExchangeCertificate;

		//Create the PKCS7 store and get the first cert out of it!
		dwRetCode = GetTempCryptContext(&hCryptProvider);
		if( dwRetCode != ERROR_SUCCESS )
		{
			LRSetLastError(dwRetCode);
			dwRetCode = IDS_ERR_CRYPT_ERROR;
			goto done;
		}

		hCertStore = CertOpenStore(	  CERT_STORE_PROV_PKCS7,
									  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
									  hCryptProvider,
									  CERT_STORE_NO_CRYPT_RELEASE_FLAG,
									  &CertBlob );

		if( NULL == hCertStore )
		{
			LRSetLastError(GetLastError());
			dwRetCode = IDS_ERR_CRYPT_ERROR;
			goto done;
		}
		
		//Get the cert from the store
		pcCertContext = CertEnumCertificatesInStore ( hCertStore, NULL );
		if ( !pcCertContext )
		{
			LRSetLastError(GetLastError());
			dwRetCode = IDS_ERR_CRYPT_ERROR;
			goto done;
		}

		//Get the extension and store the cert type in it
		pCertExtension = CertFindExtension ( szOID_NULL_EXT,
											 pcCertContext->pCertInfo->cExtension,
											 pcCertContext->pCertInfo->rgExtension
										   );
		if ( !pCertExtension )
		{
			LRSetLastError(CRYPT_E_NOT_FOUND);
			dwRetCode = IDS_ERR_CRYPT_ERROR;
			goto done;
		}
								 
		//Get the value and store it in the member function
		m_dwExtenstionValueLen = pCertExtension->Value.cbData;
		m_pbExtensionValue = new BYTE [m_dwExtenstionValueLen + 1 ];

		memset ( m_pbExtensionValue, 0, m_dwExtenstionValueLen  + 1 );
		memcpy ( m_pbExtensionValue, pCertExtension->Value.pbData, m_dwExtenstionValueLen );

		dwRetCode = ERROR_SUCCESS;
		*pdwServerStatus = LSERVERSTATUS_REGISTER_INTERNET;
	}
	else
	{
		// There is an SPK
		dwRetCode = ERROR_SUCCESS;
		*pdwServerStatus = LSERVERSTATUS_REGISTER_OTHER;
	}
	
done:

	DisconnectLS();
	
	if ( pcCertContext )
	{
		CertFreeCertificateContext ( pcCertContext );
	}

	if ( hCertStore )
	{
		CertCloseStore (hCertStore,CERT_CLOSE_STORE_CHECK_FLAG);
	}

	DoneWithTempCryptContext(hCryptProvider);

	return dwRetCode;
}

DWORD CGlobal::IsLicenseServerRegistered(PDWORD pdwServerStatus)
{
	DWORD				dwRetCode		= ERROR_SUCCESS;	
	PCONTEXT_HANDLE		phLSContext		= NULL;
	error_status_t		esRPC			= ERROR_SUCCESS;	
	PBYTE				pCertBlob		= NULL;	
	DWORD				dwCertBlobLen	= 0;
	
	
	*pdwServerStatus	= LSERVERSTATUS_UNREGISTER;
    
	dwRetCode = ConnectToLS();
	if (dwRetCode != ERROR_SUCCESS)
	{		
		goto done;
	}
	
	//Try and get the LSServerCertificate first	
	dwRetCode =  TLSGetServerCertificate (	m_phLSContext,
											FALSE,
											&pCertBlob,
											&dwCertBlobLen,
											&esRPC );
	if(dwRetCode != RPC_S_OK)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_FAILED;
		goto done;
	}

	if ( esRPC == ERROR_SUCCESS)
	{
		*pdwServerStatus = LSERVERSTATUS_REGISTER_INTERNET;
	}
	else if ( esRPC == LSERVER_I_SELFSIGN_CERTIFICATE )
	{
		*pdwServerStatus = LSERVERSTATUS_REGISTER_OTHER;
	}
	else if (esRPC == LSERVER_I_TEMP_SELFSIGN_CERT )
	{		
		*pdwServerStatus	= LSERVERSTATUS_UNREGISTER;		
	}
	else
	{
		LRSetLastError(esRPC);
		dwRetCode = IDS_ERR_LS_ERROR;		
	}

done:

	DisconnectLS();
	
	if ( pCertBlob )
	{
		LocalFree(pCertBlob);
	}
	
	return dwRetCode;	
}



DWORD CGlobal::GetTempCryptContext(HCRYPTPROV * phCryptProv)
{
	DWORD dwRetCode = ERROR_SUCCESS;

	*phCryptProv = NULL;
	if(!CryptAcquireContext(  phCryptProv,			// Address for handle to be returned.
							  NULL,					// Key Container Name.
							  NULL,					// Provider Name.
							  PROV_RSA_FULL,		// Need to do both encrypt & sign.
							  0
						   ) )
	{        
		if (!CryptAcquireContext(	phCryptProv,	// Address for handle to be returned.
									NULL,			// Key Container Name.
									NULL,			// Provider Name.
									PROV_RSA_FULL,	// Need to do both encrypt & sign.
									CRYPT_VERIFYCONTEXT 
								) )
		{
			dwRetCode = GetLastError();
     	}
	}

	return dwRetCode;
}

void CGlobal::DoneWithTempCryptContext(HCRYPTPROV hCryptProv)
{
	if ( hCryptProv )
		CryptReleaseContext ( hCryptProv, 0 );	
}



DWORD CGlobal::GetCHCert( LPTSTR lpstrRegKey , PBYTE * ppCert, DWORD * pdwLen )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	HKEY	hKey = NULL;
	DWORD	dwDisposition = 0;
	DWORD	dwType = REG_BINARY;

	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
		goto done;		

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_PARAMS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	
	
	RegQueryValueEx(hKey,  
					lpstrRegKey,
					0,
					&dwType,
					NULL,
					pdwLen
					);

	if(*pdwLen == 0)
	{
		dwRetCode = IDS_ERR_CHCERTKEY_EMPTY;
		goto done;
	}

	*ppCert = new BYTE[*pdwLen];
	memset(*ppCert,0,*pdwLen);
	RegQueryValueEx ( hKey,  
					lpstrRegKey,
					0,
					&dwType,
					*ppCert,
					pdwLen
				    );		
	

done:
 	if (hKey != NULL)
	{
		RegCloseKey(hKey);
	}

	DisconnectLSRegistry();
	return dwRetCode;
}

DWORD CGlobal::SetCHCert ( LPTSTR lpstrRegKey, PBYTE pCert, DWORD dwLen )
{
	DWORD	dwRetCode = ERROR_SUCCESS;	
	HKEY	hKey	  = NULL;
	DWORD	dwDisposition = 0;
	DWORD	dwDecodedCertLen = 0;
	PBYTE	pDecodedCert = NULL;

	/*
	//base 64 decode the blob
	LSBase64DecodeA( (const char *)pCert,
					 dwLen,
					 NULL,
					 &dwDecodedCertLen);

	pDecodedCert = new BYTE[dwDecodedCertLen];

	LSBase64DecodeA( (const char *)pCert,
					 dwLen,
					 pDecodedCert,
					 &dwDecodedCertLen);

	*/

	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_PARAMS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	
	
	RegSetValueEx ( hKey,  
					lpstrRegKey,
					0,
					REG_BINARY,
					pCert,
					dwLen
				   );

done :	

	if(pDecodedCert)
		delete pDecodedCert;

	if(hKey)
		RegCloseKey(hKey);
	
	DisconnectLSRegistry();
	return dwRetCode;
}

//
// This functions connects the LS Registry and stores the Reg Handle in 
// in the Member variable.
//
DWORD CGlobal::ConnectToLSRegistry()
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	TCHAR	szMachineName[MAX_COMPUTERNAME_LENGTH + 5];
	
	_tcscpy(szMachineName,L"\\\\");
	_tcscat(szMachineName,m_lpstrLSName);

	m_hLSRegKey = NULL;

	dwRetCode = RegConnectRegistry(szMachineName,HKEY_LOCAL_MACHINE,&m_hLSRegKey);
	if(dwRetCode != ERROR_SUCCESS)
	{		
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCONNECT_FAILD;
		return dwRetCode;
	}

	return dwRetCode;
}

void CGlobal::DisconnectLSRegistry()
{
	if(m_hLSRegKey)
		RegCloseKey(m_hLSRegKey);
}

DWORD CGlobal::ConnectToLS()
{
	DWORD dwRetCode = ERROR_SUCCESS;
	error_status_t	esRPC	= ERROR_SUCCESS;

	HCRYPTPROV hCryptProv;

	m_phLSContext = TLSConnectToLsServer((LPTSTR)m_lpwstrLSName);
    
	if (!m_phLSContext)
	{
		dwRetCode = IDS_ERR_LSCONNECT_FAILED;		
	}
	else
	{
		GetTempCryptContext(&hCryptProv);

		dwRetCode = TLSEstablishTrustWithServer(m_phLSContext, hCryptProv, CLIENT_TYPE_LRWIZ, &esRPC);

		if ( dwRetCode != RPC_S_OK || esRPC != LSERVER_S_SUCCESS)
		{
			dwRetCode = IDS_ERR_LCONNECTTRUST_FAILED; 

			TLSDisconnectFromServer(m_phLSContext);
			m_phLSContext = NULL;
		}
		DoneWithTempCryptContext(hCryptProv);
	}

	return dwRetCode;
}

void CGlobal::DisconnectLS()
{
	if (m_phLSContext)
	{
		TLSDisconnectFromServer(m_phLSContext);
		m_phLSContext = NULL;
	}
}


//
//  bstrPKCS7 is LS Client Auth Cert with BASE64 Encoding whereas
//  bstrRootCert is plain X509_ASN_ENCODING
//
DWORD CGlobal::DepositLSCertificates(PBYTE pbExchangePKCS7, 
									 DWORD dwExchangePKCS7Len,
									 PBYTE pbSignaturePKCS7,
									 DWORD dwSignaturePKCS7Len,
									 PBYTE pbRootCert,
									 DWORD dwRootCertLen)
{
	//LS CA Root Certificate BLOB in X509_ASN_ENCODING & BASE 64 Encoded
	PBYTE	pbLSEncodedRootBLOB		= pbRootCert;
	DWORD	dwLSEncodedRootBLOBLen	= dwRootCertLen;

	//LS CA Root Certificate BLOB in X509_ASN_ENCODING & BASE 64 Decoded
	PBYTE	pbLSDecodedRootBLOB		= NULL;			
	DWORD	dwLSDecodedRootBLOBLen	= 0;

	//LS Exchange Certificate BLOB(BASE64 encoded) along with LS CA Non-Root Certificate	
	PBYTE	pbLSEncodedExchgBLOB	= pbExchangePKCS7;
	DWORD	dwLSEncodedExchgBLOBLen	= dwExchangePKCS7Len;

	//LS Exchange Certificate BLOB(BASE64 decoded) along with LS CA Non-Root Certificate	
	PBYTE	pbLSDecodedExchgBLOB	= NULL;
	DWORD	dwLSDecodedExchgBLOBLen	= 0;
	
	//LS Signature Certificate BLOB(BASE64 encoded) along with LS CA Non-Root Certificate	
	PBYTE	pbLSEncodedSigBLOB		= pbSignaturePKCS7;
	DWORD	dwLSEncodedSigBLOBLen	= dwSignaturePKCS7Len;

	//LS Signature Certificate BLOB(BASE64 decoded) along with LS CA Non-Root Certificate	
	PBYTE	pbLSDecodedSigBLOB		= NULL;
	DWORD	dwLSDecodedSigBLOBLen	= 0;

	//Data blobs Required by CryptoAPIs
	CRYPT_DATA_BLOB LSExchgCertBlob;
	CRYPT_DATA_BLOB LSExchgCertStore;

	CRYPT_DATA_BLOB LSSigCertBlob;
	CRYPT_DATA_BLOB LSSigCertStore;	

	//Crypto Handles
	HCRYPTPROV	hCryptProv		=	NULL;
    HCERTSTORE	hExchgCertStore	=	NULL;
	HCERTSTORE	hSigCertStore	=	NULL;

	DWORD	dwRet				 = 0;
	PCCERT_CONTEXT  pCertContext =	NULL;	
	
	error_status_t	esRPC;

	//Decode LS Exchange Cert BLOB(BASE64 Encoded)
	LSBase64DecodeA((char *)pbLSEncodedExchgBLOB, dwLSEncodedExchgBLOBLen, NULL, &dwLSDecodedExchgBLOBLen);
	pbLSDecodedExchgBLOB = new BYTE[dwLSDecodedExchgBLOBLen];
	LSBase64DecodeA((char *)pbLSEncodedExchgBLOB, dwLSEncodedExchgBLOBLen, pbLSDecodedExchgBLOB, &dwLSDecodedExchgBLOBLen);

	//Decode LS Signature Cert BLOB(BASE64 Encoded)
	LSBase64DecodeA((char *)pbLSEncodedSigBLOB, dwLSEncodedSigBLOBLen, NULL, &dwLSDecodedSigBLOBLen);
	pbLSDecodedSigBLOB = new BYTE[dwLSDecodedSigBLOBLen];
	LSBase64DecodeA((char *)pbLSEncodedSigBLOB, dwLSEncodedSigBLOBLen, pbLSDecodedSigBLOB, &dwLSDecodedSigBLOBLen);

	//Decode LS Root Cert BLOB(BASE64 Encoded)
	LSBase64DecodeA((char *)pbLSEncodedRootBLOB, dwLSEncodedRootBLOBLen, NULL, &dwLSDecodedRootBLOBLen);
	pbLSDecodedRootBLOB = new BYTE[dwLSDecodedRootBLOBLen];
	LSBase64DecodeA((char *)pbLSEncodedRootBLOB, dwLSEncodedRootBLOBLen, pbLSDecodedRootBLOB, &dwLSDecodedRootBLOBLen);
	
	
	LSExchgCertStore.cbData = 0;
    LSExchgCertStore.pbData = NULL;

	LSSigCertStore.cbData = 0;
    LSSigCertStore.pbData = NULL;

	if(!CryptAcquireContext(&hCryptProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT ) )
    {
		dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }
	
	//Create a new memory store for LS Exchange Certificate Chain
	LSExchgCertBlob.cbData = dwLSDecodedExchgBLOBLen;
    LSExchgCertBlob.pbData = pbLSDecodedExchgBLOB;
	
    hExchgCertStore = CertOpenStore( CERT_STORE_PROV_PKCS7,
						             PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
								     hCryptProv,
									 CERT_STORE_NO_CRYPT_RELEASE_FLAG,
									 (void *)&LSExchgCertBlob);

    if( hExchgCertStore == NULL )
    {
        dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
		goto DepositExit;
    } 	
	
	//Add Root Certificate to the Store
	if(!CertAddEncodedCertificateToStore( hExchgCertStore,
										  X509_ASN_ENCODING,			
										  (const BYTE *)pbLSDecodedRootBLOB,	
										  dwLSDecodedRootBLOBLen,
										  CERT_STORE_ADD_REPLACE_EXISTING,
										  &pCertContext))
	{
		dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
		goto DepositExit;
	}
	


	//Save this store as PKCS7
	
	//Get the Required Length
	CertSaveStore(	hExchgCertStore,
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
					CERT_STORE_SAVE_AS_PKCS7,
					CERT_STORE_SAVE_TO_MEMORY,
					&LSExchgCertStore,
					0);

	LSExchgCertStore.pbData = new BYTE[LSExchgCertStore.cbData];	
	
	//Save the Store
	if(!CertSaveStore(	hExchgCertStore,
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&LSExchgCertStore,
						0)
					  )
	{
		dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
		goto DepositExit;
	}
	
	/******** Do the Same thing for the Signature Certificate ********/

	//Create a new memory store for LS Signature Certificate Chain
	LSSigCertBlob.cbData = dwLSDecodedSigBLOBLen;
    LSSigCertBlob.pbData = pbLSDecodedSigBLOB;
	
    hSigCertStore = CertOpenStore(	 CERT_STORE_PROV_PKCS7,
						             PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
								     hCryptProv,
									 CERT_STORE_NO_CRYPT_RELEASE_FLAG,
									 (void *)&LSSigCertBlob);

    if( hSigCertStore == NULL )
    {
        dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
		goto DepositExit;
    } 	
	//Verify certificate 
	//Add Root Certificate to the Store
	if(!CertAddEncodedCertificateToStore( hSigCertStore,
										  X509_ASN_ENCODING,			
										  (const BYTE *)pbLSDecodedRootBLOB,	
										  dwLSDecodedRootBLOBLen,
										  CERT_STORE_ADD_REPLACE_EXISTING,
										  &pCertContext))
	{
		dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
		goto DepositExit;
	}
	
	//Save this store as PKCS7
	
	//Get the Required Length
	CertSaveStore(	hSigCertStore,
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
					CERT_STORE_SAVE_AS_PKCS7,
					CERT_STORE_SAVE_TO_MEMORY,
					&LSSigCertStore,
					0);

	LSSigCertStore.pbData = new BYTE[LSSigCertStore.cbData];	
	
	//Save the Store
	if(!CertSaveStore(	hSigCertStore,	// in
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&LSSigCertStore,
						0))
	{
		dwRet = GetLastError();
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CRYPT_ERROR;
		goto DepositExit;
	}
	
	//Now verify the certificate chain for both exchange and 
	//signature certificates.

	dwRet = VerifyCertChain (	hCryptProv,
								hExchgCertStore,
								pbLSDecodedRootBLOB,	
								dwLSDecodedRootBLOBLen
							);

	if ( dwRet != ERROR_SUCCESS )
	{
		LRSetLastError(dwRet);
		goto DepositExit;
	}
								
	dwRet = VerifyCertChain (	hCryptProv,
								hSigCertStore,
								pbLSDecodedRootBLOB,	
								dwLSDecodedRootBLOBLen
							);

	if ( dwRet != ERROR_SUCCESS )
	{
		LRSetLastError(dwRet);
		goto DepositExit;
	}

	//Now Send Both Signature & Exchange BLOBs to LS.	
	dwRet = ConnectToLS();
	if(dwRet != ERROR_SUCCESS)
	{
		goto DepositExit;
	}    
	
	dwRet = TLSInstallCertificate( m_phLSContext,
								  CERTIFICATE_CA_TYPE,
								  1,
								  LSSigCertStore.cbData,
								  LSSigCertStore.pbData,
								  LSExchgCertStore.cbData,
								  LSExchgCertStore.pbData,
								  &esRPC
								 );

	if(dwRet != RPC_S_OK)
	{
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CERT_DEPOSIT_RPCERROR;
		goto DepositExit;
	}
	else if ( esRPC != ERROR_SUCCESS && ( esRPC < LSERVER_I_NO_MORE_DATA || esRPC > LSERVER_I_TEMP_SELFSIGN_CERT ) )
	{		
		dwRet = esRPC;
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_CERT_DEPOSIT_RPCERROR; //IDS_ERR_CERT_DEPOSIT_LSERROR;
		goto DepositExit;
	}

DepositExit :

	if(hCryptProv != NULL)
		CryptReleaseContext(hCryptProv,0);

	if(hExchgCertStore != NULL)
		CertCloseStore(hExchgCertStore,CERT_CLOSE_STORE_FORCE_FLAG);

	if(hSigCertStore != NULL)
		CertCloseStore(hSigCertStore,CERT_CLOSE_STORE_FORCE_FLAG);

	if(pbLSDecodedRootBLOB != NULL)
		delete pbLSDecodedRootBLOB;

	if(pbLSDecodedExchgBLOB != NULL)
		delete pbLSDecodedExchgBLOB;

	if(pbLSDecodedSigBLOB != NULL)
		delete pbLSDecodedSigBLOB;

	if(LSExchgCertStore.pbData != NULL)
		delete LSExchgCertStore.pbData;

	if(LSSigCertStore.pbData != NULL)
		delete LSSigCertStore.pbData;	
	
	return dwRet;
}


DWORD CGlobal::GetCryptContextWithLSKeys(HCRYPTPROV * lphCryptProv ) 
{
	DWORD		dwRetVal = ERROR_SUCCESS;
	DWORD		esRPC = ERROR_SUCCESS;

	PBYTE		pbExchKey = NULL;
	PBYTE		pbSignKey = NULL;	
	DWORD		cbExchKey = 0;
	DWORD		cbSignKey = 0;

	HCRYPTKEY	hSignKey;
	HCRYPTKEY	hExchKey;
    
	//
	//Create a new temp context
	//
	if (!CryptAcquireContext(lphCryptProv, LS_CRYPT_KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET) )
	{
		dwRetVal = GetLastError();

		//If the key container exists , recreate it after deleting the existing one
		if(dwRetVal == NTE_EXISTS)
		{
			// Delete
			if(!CryptAcquireContext(lphCryptProv, LS_CRYPT_KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_DELETEKEYSET))
			{
				dwRetVal = GetLastError();
				LRSetLastError(dwRetVal);
				dwRetVal = IDS_ERR_CRYPT_ERROR;
				goto done;		
			}

			// Recreate
			if(!CryptAcquireContext(lphCryptProv, LS_CRYPT_KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET))
			{
				dwRetVal = GetLastError();
				LRSetLastError(dwRetVal);
				dwRetVal = IDS_ERR_CRYPT_ERROR;
				goto done;		
			}

		}
		else
		{
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
			goto done;
		}
	}
	
	dwRetVal = ConnectToLS();
	if(dwRetVal != ERROR_SUCCESS)
	{
		goto done;
	}

	//
	//Now call retrieve keys and import them
	//
	dwRetVal = TLSGetLSPKCS10CertRequest  ( m_phLSContext,
											TLSCERT_TYPE_EXCHANGE,
											&cbExchKey,
											&pbExchKey,
											&esRPC 
										   );

	if ( dwRetVal != RPC_S_OK ) 
	{
		LRSetLastError(dwRetVal);
		dwRetVal = IDS_ERR_RPC_ERROR;
		goto done;
	}
	else if ( esRPC != ERROR_SUCCESS && esRPC != LSERVER_I_SELFSIGN_CERTIFICATE &&
			  esRPC != LSERVER_I_TEMP_SELFSIGN_CERT )
	{
		dwRetVal = esRPC;
		LRSetLastError(dwRetVal);
		dwRetVal = IDS_ERR_LSKEY_IMPORT_FAILED;
		goto done;
	}

	dwRetVal = TLSGetLSPKCS10CertRequest  ( m_phLSContext,
											TLSCERT_TYPE_SIGNATURE,
											&cbSignKey,
											&pbSignKey,
											&esRPC 
										   );

	if ( dwRetVal != RPC_S_OK ) 
	{
		LRSetLastError(dwRetVal);
		dwRetVal = IDS_ERR_RPC_ERROR;
		goto done;
	}
	else if ( esRPC != ERROR_SUCCESS && esRPC != LSERVER_I_SELFSIGN_CERTIFICATE &&
			  esRPC != LSERVER_I_TEMP_SELFSIGN_CERT )
	{
		dwRetVal = esRPC;
		LRSetLastError(dwRetVal);
		dwRetVal = IDS_ERR_LSKEY_IMPORT_FAILED;
		goto done;
	}

    if(!CryptImportKey(*lphCryptProv, pbSignKey, cbSignKey, NULL, 0, &hSignKey))
    {
        dwRetVal = GetLastError();
		LRSetLastError(dwRetVal);
		dwRetVal = IDS_ERR_CRYPT_ERROR;
        goto done;
    }

    if(!CryptImportKey ( *lphCryptProv, pbExchKey, cbExchKey, NULL, 0, &hExchKey))
    {
        dwRetVal = GetLastError();
		LRSetLastError(dwRetVal);
		dwRetVal = IDS_ERR_CRYPT_ERROR;
		goto done;
    }	

done:
	if ( pbExchKey )
		LocalFree(pbExchKey);

	if ( pbSignKey )
		LocalFree(pbSignKey);

	DisconnectLS();

	return dwRetVal;
}

void CGlobal::DoneWithCryptContextWithLSKeys(HCRYPTPROV hProv)
{
	if(hProv)
	{
		CryptReleaseContext (hProv, 0);		
	}
}


DWORD CGlobal::CreateLSPKCS10(HCRYPTPROV hCryptProv,int nType,CHAR **lppszPKCS10)
{
	DWORD dwRetVal = ERROR_SUCCESS;

    CERT_SIGNED_CONTENT_INFO	SignatureInfo;
	CERT_REQUEST_INFO			CertReqInfo;
    //HCRYPTPROV					hCryptProv=NULL;
    

    CERT_EXTENSION  rgExtension[MAX_NUM_EXTENSION];
    int             iExtCount=0;
    CERT_EXTENSIONS Extensions;

    CRYPT_ATTRIBUTE rgAttribute;
    CRYPT_ATTR_BLOB bAttr;

    CRYPT_BIT_BLOB bbKeyUsage;
    
    CERT_POLICIES_INFO	CertPolicyInfo;
    CERT_POLICY_INFO	CertPolicyOID;

    LPBYTE	pbRequest=NULL;
    DWORD	cbRequest=0;    
    DWORD	cch=0;   

	CERT_RDN_ATTR * prgNameAttr = NULL;

    // clean out the PKCS 10
    memset(rgExtension, 0, sizeof(rgExtension));
    memset(&Extensions, 0, sizeof(CERT_EXTENSIONS));
    memset(&rgAttribute, 0, sizeof(rgAttribute));
    memset(&bbKeyUsage, 0, sizeof(bbKeyUsage));
    memset(&bAttr, 0, sizeof(bAttr));
    memset(&SignatureInfo, 0, sizeof(SignatureInfo));

    memset(&CertPolicyInfo, 0, sizeof(CERT_POLICIES_INFO));
    memset(&CertPolicyOID, 0, sizeof(CERT_POLICY_INFO));

    memset(&CertReqInfo, 0, sizeof(CERT_REQUEST_INFO));
    CertReqInfo.dwVersion = CERT_REQUEST_V1;
    
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo=NULL;
    DWORD cbPubKeyInfo=0;

    do 
	{
		//
        //This function will call the CryptAcquireContext and import the LS Keys 
		//
		/* Moved out of this function
		if ( ( dwRetVal = GetCryptContextWithLSKeys (&hCryptProv )  )!= ERROR_SUCCESS )
		{
			break;
		}
		*/

        //
        // always strore everything in ANSI
        //
		prgNameAttr = CreateRDNAttr();

		if(prgNameAttr == NULL)
		{
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

        CERT_RDN rgRDN[] = {m_dwReqAttrCount, prgNameAttr};
        CERT_NAME_INFO Name = {1, rgRDN};
        
        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_NAME,
                               &Name,
                               NULL,
                               &CertReqInfo.Subject.cbData))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        CertReqInfo.Subject.pbData=(BYTE *) new BYTE[CertReqInfo.Subject.cbData];
		if ( !CertReqInfo.Subject.pbData )
		{
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

        
        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_NAME,
                               &Name,
                               CertReqInfo.Subject.pbData,
                               &CertReqInfo.Subject.cbData))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        // now get the public key out
        if(!CryptExportPublicKeyInfo(hCryptProv, nType, X509_ASN_ENCODING, NULL, &cbPubKeyInfo))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}

		pPubKeyInfo=(PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo];

        if ( NULL == pPubKeyInfo )
		{
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

        if(!CryptExportPublicKeyInfo(hCryptProv, nType,  X509_ASN_ENCODING, pPubKeyInfo, &cbPubKeyInfo))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}    

        CertReqInfo.SubjectPublicKeyInfo = *pPubKeyInfo;

		//no extensions here - we set them on the server side!
		
		//sign cert request !
        
        SignatureInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
        memset(&SignatureInfo.SignatureAlgorithm.Parameters, 0, sizeof(SignatureInfo.SignatureAlgorithm.Parameters));
        if(!CryptEncodeObject(CRYPT_ASN_ENCODING,
                              X509_CERT_REQUEST_TO_BE_SIGNED,
                              &CertReqInfo,
                              NULL,
                              &SignatureInfo.ToBeSigned.cbData))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}

        SignatureInfo.ToBeSigned.pbData = (LPBYTE)new BYTE [SignatureInfo.ToBeSigned.cbData];
		if (NULL == SignatureInfo.ToBeSigned.pbData ) 
        {
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

        if(!CryptEncodeObject(CRYPT_ASN_ENCODING,
                              X509_CERT_REQUEST_TO_BE_SIGNED,
                              &CertReqInfo,
                              SignatureInfo.ToBeSigned.pbData,
                              &SignatureInfo.ToBeSigned.cbData))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}


        if(!CryptSignCertificate( hCryptProv,
                                  nType,
                                  CRYPT_ASN_ENCODING,
                                  SignatureInfo.ToBeSigned.pbData,
                                  SignatureInfo.ToBeSigned.cbData,
                                  &SignatureInfo.SignatureAlgorithm,
                                  NULL,
                                  NULL,
                                  &SignatureInfo.Signature.cbData))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}

        SignatureInfo.Signature.pbData = new BYTE[SignatureInfo.Signature.cbData];
		if ( NULL == SignatureInfo.Signature.pbData )
        {
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

        if(!CryptSignCertificate( hCryptProv,
                                  nType,
                                  CRYPT_ASN_ENCODING,
                                  SignatureInfo.ToBeSigned.pbData,
                                  SignatureInfo.ToBeSigned.cbData,
                                  &SignatureInfo.SignatureAlgorithm,
                                  NULL,
                                  SignatureInfo.Signature.pbData,
                                  &SignatureInfo.Signature.cbData))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}

        // encode final signed request
        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_CERT,
                               &SignatureInfo,
                               NULL,
                               &cbRequest))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}

        pbRequest = new BYTE[cbRequest];
		if ( NULL == pbRequest )
        {
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_CERT,
                               &SignatureInfo,
                               pbRequest,
                               &cbRequest))
        {
			dwRetVal = GetLastError();
			LRSetLastError(dwRetVal);
			dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
		}

		//
        // base64 encoding
		//
        LSBase64EncodeA ( pbRequest, cbRequest, NULL, &cch);

        *lppszPKCS10 = new CHAR [cch+1];
		if(*lppszPKCS10 == NULL)
        {
			dwRetVal = IDS_ERR_OUTOFMEM;
			break;
		}

		memset ( *lppszPKCS10, 0, (cch+1)*sizeof(CHAR) );
        
        LSBase64EncodeA ( pbRequest, cbRequest, *lppszPKCS10, &cch);       
		

    } while(FALSE);


	//
	// free up all 
	//
	if(pPubKeyInfo != NULL)
		delete pPubKeyInfo;
	
	if(CertReqInfo.Subject.pbData != NULL)
		delete CertReqInfo.Subject.pbData;

    if(rgAttribute.rgValue)
        delete rgAttribute.rgValue[0].pbData;

	if(SignatureInfo.ToBeSigned.pbData != NULL)
		delete SignatureInfo.ToBeSigned.pbData;

	if(SignatureInfo.Signature.pbData != NULL)
		delete SignatureInfo.Signature.pbData;

	if(pbRequest != NULL)
		delete pbRequest;

	if(prgNameAttr != NULL)
		delete prgNameAttr;

	/*
	 Moved outside of this function
    if(hCryptProv)
	{
		DoneWithCryptContextWithLSKeys ( hCryptProv );
	}  
	*/
    return dwRetVal;
}

DWORD CGlobal::SetDNAttribute(LPCSTR lpszOID, LPSTR lpszValue)
{
	//store the item in an array here
	//so that it is easy to populate the 
	//cert request later
	//calling CreateLSPKCS10 will clear the array
	DWORD	dwRet = ERROR_SUCCESS;
	
	
	if ( !m_pReqAttr )
	{
		m_pReqAttr = (PREQ_ATTR)malloc (sizeof (REQ_ATTR ) );
	}
	else
	{
		m_pReqAttr = (PREQ_ATTR)realloc ( m_pReqAttr, sizeof(REQ_ATTR) * (m_dwReqAttrCount + 1));
	}

	if ( !m_pReqAttr )
	{
		dwRet = IDS_ERR_OUTOFMEM;
		goto done;
	}
	
	( m_pReqAttr + m_dwReqAttrCount)->lpszOID	= lpszOID;	

	( m_pReqAttr + m_dwReqAttrCount)->lpszValue = new CHAR[lstrlenA(lpszValue) + 1];
	lstrcpyA(( m_pReqAttr + m_dwReqAttrCount)->lpszValue,lpszValue);

	
	
	m_dwReqAttrCount++;
	
done:
	return dwRet;
}





LPCTSTR CGlobal::GetFromRegistery(LPCSTR lpszOID, LPTSTR lpszBuffer, BOOL bConnect)
{
	HKEY	hKey = NULL;
	DWORD	dwDisposition;
	DWORD	dwRet = ERROR_SUCCESS;
	DWORD   dwDataLen = 0;
	DWORD	dwType	= REG_SZ;

	_tcscpy(lpszBuffer, _T(""));

	if (bConnect)
	{
		dwRet = ConnectToLSRegistry();
		if(dwRet != ERROR_SUCCESS)
		{
			goto done;
		}
	}
	else
	{
		assert(m_hLSRegKey != NULL);
	}

	dwRet = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_PARAMS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if (dwRet != ERROR_SUCCESS)
	{
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	


	dwRet = RegQueryValueExA ( hKey, 
					  lpszOID,
					  0,
					  &dwType,
					  NULL,
					  &dwDataLen);

	if ( dwDataLen && dwRet == ERROR_SUCCESS )
	{
		char * cpBuf = new char[dwDataLen + 2];

		if (cpBuf == NULL)
		{
			goto done;
		}

		memset(cpBuf, 0, dwDataLen+2);

		RegQueryValueExA ( hKey, 
						  lpszOID,
						  0,
						  &dwType,
						  (LPBYTE) cpBuf,
						  &dwDataLen);

		memset(lpszBuffer, 0, sizeof(TCHAR)*(dwDataLen+2));
	
	    LSBase64DecodeA (cpBuf, lstrlenA(cpBuf), (PBYTE) lpszBuffer, &dwDataLen);

		delete cpBuf;
	}

done:
	if (hKey != NULL)
	{
		RegCloseKey(hKey);
	}

	if (bConnect)
	{
		DisconnectLSRegistry();
	}

	return lpszBuffer;
}



DWORD CGlobal::SetInRegistery(LPCSTR lpszOID, LPCTSTR lpszValue)
{
	HKEY	hKey = NULL;
	DWORD	dwDisposition;
	DWORD	dwRet = ERROR_SUCCESS;
	DWORD   dwLen = 0;
	char * cpOut;

	dwRet = ConnectToLSRegistry();
	if(dwRet != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRet = RegCreateKeyEx ( m_hLSRegKey,
							 REG_LRWIZ_PARAMS,
							 0,
							 NULL,
							 REG_OPTION_NON_VOLATILE,
							 KEY_ALL_ACCESS,
							 NULL,
							 &hKey,
							 &dwDisposition);
	
	if(dwRet != ERROR_SUCCESS)
	{
		LRSetLastError(dwRet);
		dwRet = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}

	if (_tcslen(lpszValue) != 0)
	{
	    LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), NULL, &dwLen);

		cpOut = new char[dwLen+1];
		if (cpOut == NULL)
		{
			dwRet = IDS_ERR_OUTOFMEM;
			goto done;
		}

		memset(cpOut, 0, dwLen+1);
        
		LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), cpOut, &dwLen);
	}
	else
	{
		cpOut = new char[2];
		memset(cpOut, 0, 2);
	}
	
	RegSetValueExA ( hKey, 
					lpszOID,
					0,
					REG_SZ,
					(PBYTE) cpOut,
					dwLen
				   );	
	delete cpOut;

done:
	if (hKey != NULL)
	{
		RegCloseKey(hKey);
	}
	DisconnectLSRegistry();

	return dwRet;
}



CERT_RDN_ATTR * CGlobal::CreateRDNAttr()
{
	CERT_RDN_ATTR * prgNameAttr = ( CERT_RDN_ATTR * )new BYTE [sizeof ( CERT_RDN_ATTR ) * m_dwReqAttrCount];
	DWORD dw = 0;

	if ( !prgNameAttr )
		goto done;

	for ( dw = 0; dw < m_dwReqAttrCount; dw ++ )
	{
		( prgNameAttr + dw )->pszObjId		= (LPSTR)( m_pReqAttr + dw)->lpszOID;
		( prgNameAttr + dw )->dwValueType	= CERT_RDN_PRINTABLE_STRING;
		( prgNameAttr + dw )->Value.cbData	= lstrlenA(( m_pReqAttr + dw)->lpszValue);
		( prgNameAttr + dw )->Value.pbData	= (PBYTE)( m_pReqAttr + dw)->lpszValue;
	}

done:
	return prgNameAttr;
}



TCHAR *	CGlobal::GetRegistrationID(void)
{
	return m_pRegistrationID;
}


TCHAR *	CGlobal::GetLicenseServerID(void)
{
	return m_pLicenseServerID;
}



DWORD CGlobal::GetRequestType()
{
	return m_dwRequestType;
}



void CGlobal::SetRequestType(DWORD dwMode)
{
	m_dwRequestType = dwMode;
}



BOOL CGlobal::IsOnlineCertRequestCreated()
{
	DWORD	dwRetCode		= ERROR_SUCCESS;
	DWORD	dwLRState		= 0;
	DWORD	dwDataLen		= 0;
	DWORD	dwDisposition	= 0;
	DWORD	dwType			= REG_SZ;
	HKEY	hKey			= NULL;

	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_PARAMS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}	

	
	dwLRState	= 0;
	dwType		= REG_DWORD;
	dwDataLen	= sizeof(dwLRState);
	RegQueryValueEx(hKey,
					REG_LRWIZ_STATE,
					0,
					&dwType,
					(LPBYTE)&dwLRState,
					&dwDataLen
					);

done:

	if(hKey)
		RegCloseKey(hKey);

	DisconnectLSRegistry();

	if(dwRetCode == ERROR_SUCCESS)
		return ( dwLRState == LRSTATE_ONLINE_CR_CREATED ) ? TRUE : FALSE;
	else
		return FALSE;
}

DWORD CGlobal::SetLRState(DWORD dwState)
{
	DWORD	dwRetCode		= ERROR_SUCCESS;
	DWORD	dwDataLen		= sizeof(dwState);
	DWORD	dwDisposition	= 0;
	DWORD	dwType			= REG_DWORD;
	HKEY	hKey			= NULL;

	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_PARAMS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}
	
	//
	// Persist LRCount
	//
	dwType		= REG_DWORD;
	dwDataLen	= sizeof(m_dwLRCount);

	RegSetValueEx ( hKey,  
					REG_LR_COUNT,
					0,
					dwType,
					(LPBYTE)&m_dwLRCount,
					dwDataLen
				   );

	//
	// Persist LRState if it is not LRSTATE_OFFLINE_LR_INSTALLED
	//
	dwType		= REG_DWORD;
	dwDataLen	= sizeof(dwState);
	RegSetValueEx ( hKey,  
					REG_LRWIZ_STATE,
					0,
					dwType,
					(LPBYTE)&dwState,
					dwDataLen
				   );
	m_dwLRState = dwState;

done:
	if(hKey)
		RegCloseKey(hKey);

	DisconnectLSRegistry();

	return dwRetCode;
}



DWORD CGlobal::ProcessRequest()
{
	DWORD dwRetCode = ERROR_SUCCESS;
 

	//
	// Before the processing the request, make sure LS is running
	//
	if(!IsLSRunning())
	{
		dwRetCode = IDS_ERR_LSCONNECT_FAILED;
		goto done;
	}

	switch(GetActivationMethod())
	{
	case CONNECTION_INTERNET:
		if (GetWizAction() == WIZACTION_REGISTERLS)
		{
			dwRetCode = ProcessIRegRequest();
		}
		else if (GetWizAction() == WIZACTION_CONTINUEREGISTERLS)
		{
			dwRetCode = ProcessCertDownload();
		}
		else if (GetWizAction() == WIZACTION_DOWNLOADLKP)
		{
			dwRetCode = ProcessDownloadLKP();
		}
		else if (GetWizAction() == WIZACTION_UNREGISTERLS)
		{
			dwRetCode = ProcessCHRevokeCert();
		}
		else if (GetWizAction() == WIZACTION_REREGISTERLS)
		{
			dwRetCode = ProcessCHReissueCert();
		}
		else if (GetWizAction() == WIZACTION_DOWNLOADLASTLKP)
		{
			dwRetCode = ProcessCHReissueLKPRequest();
		}
		break;

	case CONNECTION_PHONE:
	case CONNECTION_WWW:
		if (GetWizAction() == WIZACTION_REGISTERLS ||
			GetWizAction() == WIZACTION_REREGISTERLS ||
			GetWizAction() == WIZACTION_CONTINUEREGISTERLS)
		{
			dwRetCode = DepositLSSPK();
			if (dwRetCode != ERROR_SUCCESS)
			{
				dwRetCode = IDS_ERR_DEPOSITSPK;
			}
		}
        else if (GetWizAction() == WIZACTION_DOWNLOADLKP)
        {
            dwRetCode = DepositLSLKP();
        }
		else if (GetWizAction() == WIZACTION_UNREGISTERLS)
		{
			dwRetCode = ResetLSSPK();
		}
		break;
	}

done:

	LRSetLastRetCode(dwRetCode);

	return dwRetCode;
}




DWORD CGlobal::DepositLSSPK()
{
	DWORD				dwRetCode		= ERROR_SUCCESS;	
	error_status_t		esRPC			= ERROR_SUCCESS;
	CERT_EXTENSION		certExtension;
    CRYPT_OBJID_BLOB	oidValue;
	CERT_EXTENSIONS		certExts;
	TCHAR awBuffer[ 1024];

	dwRetCode = ConnectToLS();
	if(dwRetCode != ERROR_SUCCESS)
	{		
		goto done;
	}

	swprintf(awBuffer, szCertEXTENSION_VALUE_FMT, L"SELECT" /* "BASIC" */);
	assert(wcslen(awBuffer) < sizeof(awBuffer));

	oidValue.cbData = (wcslen(awBuffer)+1)*sizeof(TCHAR);
	oidValue.pbData = (unsigned char *) awBuffer;

	certExtension.pszObjId	= (char *) szCertEXTENSION_OID;
	certExtension.fCritical = TRUE;
	certExtension.Value		= oidValue;

	certExts.cExtension = 1;
	certExts.rgExtension = &certExtension;
	
	// We need the License Server ID
	dwRetCode = TLSDepositeServerSPK( m_phLSContext,
									  (wcslen(m_pLSSPK) + 1)*sizeof(TCHAR),
									  (BYTE *) m_pLSSPK,
									  &certExts,
									  &esRPC );
	if(dwRetCode != RPC_S_OK)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_FAILED;		
		goto done;
	}

	if (esRPC != LSERVER_S_SUCCESS)
	{
		// Some error occurred in depositing the SPK
		LRSetLastError(esRPC);
		dwRetCode = IDS_ERR_DEPOSITSPK;
	}
	else
	{
		// Everything suceeded
		memcpy(m_pRegistrationID, m_pLSSPK, (wcslen(m_pLSSPK) + 1)*sizeof(TCHAR));
		if (m_dwLRState == LRSTATE_ONLINE_CR_CREATED)
		{
			SetLRState(LRSTATE_NEUTRAL);
		}
	}


done:
	DisconnectLS();

	return dwRetCode;
}




DWORD CGlobal::SetLSLKP(TCHAR * tcLKP)
{
	if (wcsspn(tcLKP, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
	{
		// Extraneous characters in the SPK string
		return IDS_ERR_INVALIDID;
	}
	lstrcpy(m_pLSLKP, tcLKP);

	return ERROR_SUCCESS;
}



DWORD CGlobal::SetLSSPK(TCHAR * tcLKP)
{
	if (wcsspn(tcLKP, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
	{
		// Extraneous characters in the SPK string
		return IDS_ERR_INVALIDLSID;
	}

	if (lstrcmp(m_pRegistrationID, tcLKP) == 0)
	{
		return IDS_DUPLICATESPK;
	}

	lstrcpy(m_pLSSPK, tcLKP);

	return ERROR_SUCCESS;
}




DWORD CGlobal::DepositLSLKP(void)
{
	DWORD				dwRetCode		= ERROR_SUCCESS;	
	error_status_t		esRPC			= ERROR_SUCCESS;

	dwRetCode = ConnectToLS();
	if(dwRetCode != ERROR_SUCCESS)
	{		
		goto done;
	}

	// We need the License Server ID
	dwRetCode = TLSTelephoneRegisterLKP( m_phLSContext,
										 (wcslen(m_pLSLKP))*sizeof(TCHAR),
										 (BYTE *) m_pLSLKP,
										 &esRPC );
	if(dwRetCode != RPC_S_OK)
	{
		dwRetCode = IDS_ERR_RPC_FAILED;		
		goto done;
	}

	if (esRPC != LSERVER_S_SUCCESS)
	{
		// Some error occurred in depositing the SPK
		if (esRPC == LSERVER_E_DUPLICATE)
		{
			dwRetCode = IDS_ERR_DUPLICATE_LKP;
		}
		else
		{
			dwRetCode = IDS_ERR_DEPOSITLKP;
			LRSetLastError(esRPC);
		}
	}

done:
	DisconnectLS();
	
	return dwRetCode;
}







DWORD CGlobal::SetCertificatePIN(LPTSTR lpszPIN)
{
	m_lpstrPIN = new TCHAR[_tcslen(lpszPIN)+1];	

	if(m_lpstrPIN == NULL)
		return IDS_ERR_OUTOFMEM;

	_tcscpy(m_lpstrPIN,lpszPIN);

	return ERROR_SUCCESS;
}




void CGlobal::ClearCHRequestAttributes()
{
	DWORD	dwIndex = 0;

	if ( m_pRegAttr )
	{
		for(dwIndex=0;dwIndex<m_dwRegAttrCount;dwIndex++)
		{
			if((m_pRegAttr + dwIndex)->lpszAttribute)
				delete (m_pRegAttr + dwIndex)->lpszAttribute;

			if((m_pRegAttr + dwIndex)->lpszValue)
				delete (m_pRegAttr + dwIndex)->lpszValue;
		}

		free( m_pRegAttr );
		m_pRegAttr = NULL;
	}

	m_dwRegAttrCount = 0;
}

void CGlobal::ClearCARequestAttributes()
{
	DWORD dwIndex;

	if ( m_pReqAttr )
	{
		for(dwIndex=0;dwIndex<m_dwReqAttrCount;dwIndex++)
		{			
			if(( m_pReqAttr + dwIndex)->lpszValue)
				delete ( m_pReqAttr + dwIndex)->lpszValue;
		}

		free( m_pReqAttr );
		m_pReqAttr = NULL;
	}

	m_dwReqAttrCount = 0;
}

DWORD CGlobal::SetRegistrationAttribute ( LPWSTR lpszAttribute, LPCWSTR lpszValue, DWORD dwLen )
{
	DWORD dwRet;
	
	if ( !m_pRegAttr )
	{
		m_pRegAttr = (PREG_ATTR)malloc (sizeof (REG_ATTR ) );
	}
	else
	{
		m_pRegAttr = (PREG_ATTR)realloc ( m_pRegAttr, sizeof(REG_ATTR) * (m_dwRegAttrCount + 1));
	}

	if ( !m_pRegAttr )
	{
		dwRet = IDS_ERR_OUTOFMEM;
		goto done;
	}
	
	( m_pRegAttr + m_dwRegAttrCount)->lpszAttribute	= new WCHAR[lstrlenW(lpszAttribute) + 1];
	lstrcpyW(( m_pRegAttr + m_dwRegAttrCount)->lpszAttribute,lpszAttribute );
	

	
	
	( m_pRegAttr + m_dwRegAttrCount)->lpszValue		= new WCHAR[dwLen];
	memset(( m_pRegAttr + m_dwRegAttrCount)->lpszValue,0,dwLen * sizeof(WCHAR)); 
	memcpy(( m_pRegAttr + m_dwRegAttrCount)->lpszValue,lpszValue,dwLen * sizeof(WCHAR));

	( m_pRegAttr + m_dwRegAttrCount)->dwValueLen	= dwLen * sizeof(WCHAR);		//byte length

	m_dwRegAttrCount++;

done:
	
	return dwRet;
}


DWORD CGlobal::DepositLKPResponse(PBYTE pbResponseData, DWORD dwResponseLen)
{	
	DWORD			dwRetCode	= ERROR_SUCCESS;
	DWORD			dwLSRetCode = ERROR_SUCCESS;
	LPBYTE			pCHCertBlob = NULL;
	DWORD			dwCertBlobLen = 0;

	LPBYTE			pCHRootCertBlob = NULL;
	DWORD			dwRootCertBlobLen = 0;

	LPBYTE			lpDecodedKeyPackBlob = NULL;
	DWORD			dwDecodedKeyPackBlob = 0;
	
	LPBYTE			lpKeyPackBlob = NULL;
	DWORD			dwKeyPackBlobLen;	
	

	lpDecodedKeyPackBlob = lpKeyPackBlob		= pbResponseData;
	dwDecodedKeyPackBlob = dwKeyPackBlobLen		= dwResponseLen;
	


/*
	//Base64 decode the LKP!
	LSBase64DecodeA((const char *)lpKeyPackBlob,
					dwKeyPackBlobLen,
					NULL,
					&dwDecodedKeyPackBlob);

	lpDecodedKeyPackBlob = new BYTE[dwDecodedKeyPackBlob];

	if(lpDecodedKeyPackBlob == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	LSBase64DecodeA((const char *)lpKeyPackBlob,
					dwKeyPackBlobLen,
					lpDecodedKeyPackBlob,
					&dwDecodedKeyPackBlob);
	
*/

	//Get the CH Cert BLOB and CH Root Cert BLOB
	dwRetCode = GetCHCert(REG_SIGN_CERT, &pCHCertBlob, &dwCertBlobLen );
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	dwRetCode = GetCHCert(REG_ROOT_CERT, &pCHRootCertBlob, &dwRootCertBlobLen );
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	dwRetCode = ConnectToLS();
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	dwRetCode  = TLSRegisterLicenseKeyPack( m_phLSContext,
											pCHCertBlob,
											dwCertBlobLen,
											pCHRootCertBlob,
											dwRootCertBlobLen,
											lpDecodedKeyPackBlob,
											dwDecodedKeyPackBlob,
											&dwLSRetCode);

	if(dwRetCode != RPC_S_OK)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_ERROR;
		goto done;
	}

	if(dwLSRetCode != ERROR_SUCCESS )
	{
		LRSetLastError(dwLSRetCode);
		if ( dwLSRetCode != LSERVER_E_DUPLICATE )
		{			
			dwRetCode = IDS_ERR_DEPOSIT_LKP_FAILED;
		}
		else
		{
			dwRetCode = IDS_ERR_DUPLICATE_LKP;
		}
		goto done;
	}	

done:
/*
	if ( lpDecodedKeyPackBlob )
		delete lpDecodedKeyPackBlob;
*/
	if (pCHCertBlob != NULL)
	{
		delete pCHCertBlob;
	}

	if (pCHRootCertBlob != NULL)
	{
		delete pCHRootCertBlob;
	}
	DisconnectLS();

	return dwRetCode;
}


DWORD CGlobal:: EncryptBuffer ( PBYTE	pBuffer,			//Buffer to be encrypted
								DWORD	dwcbBufLen,			//buffer length
								DWORD	dwKeyContainerType,	//machine/user
								PBYTE	pCertificate,		//certificate blob
								DWORD	cbCertificate,		//number of bytes in the certificate
								PDWORD  pcbEncryptedBlob,	//number of bytes in the encrypted blob
								PBYTE	*ppbEncryptedBlob	//encrypted blob itself
							   ) 
{
	DWORD			dwRetCode = ERROR_SUCCESS;

    HCRYPTPROV		hCryptProv = NULL;
	EnvData			aEnvData;
	
	PCCERT_CONTEXT	pCertContext	= NULL;
	HCERTSTORE		hCertStore		= NULL;	
	
	CRYPT_DATA_BLOB CertBlob;

	//
	// Acquire the Crypt Context with LS Keys
	//
	dwRetCode = GetCryptContextWithLSKeys(&hCryptProv);

	if ( dwRetCode != ERROR_SUCCESS )
		goto done;

	//
	// Get the Certificate Context from the Certificate BLOB
	//
	CertBlob.pbData = pCertificate;
	CertBlob.cbData = cbCertificate;

    hCertStore = CertOpenStore( CERT_STORE_PROV_PKCS7,
                                PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                hCryptProv,
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                &CertBlob 
							  );
	
	if(hCertStore == NULL)
	{
		LRSetLastError(GetLastError());
		dwRetCode  = IDS_ERR_CRYPT_ERROR;
		goto done;
	}   

    //
    // Get the first certificate from the store
    //
    pCertContext = CertEnumCertificatesInStore( hCertStore, NULL );
    if( pCertContext == NULL)
    {
        LRSetLastError(GetLastError());
		dwRetCode  = IDS_ERR_CRYPT_ERROR;
		goto done;
    }	

	//EnvelopeData
	memset ( &aEnvData, 0, sizeof(EnvData));

    dwRetCode = EnvelopeData(	pCertContext, 
								dwcbBufLen, 
								pBuffer, 
								&aEnvData, 
								hCryptProv, 
								hCertStore 
							);

	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_CRYPT_ERROR;
		goto done;
	}

	dwRetCode = PackEnvData( &aEnvData, pcbEncryptedBlob, ppbEncryptedBlob);
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_CRYPT_ERROR;
		goto done;
	}

done:
    if( hCryptProv )
    {
        DoneWithCryptContextWithLSKeys(hCryptProv);
    }

	return dwRetCode;
}

DWORD CGlobal::EnvelopeData(
							PCCERT_CONTEXT		pCertContext,			//Certificate context to use
							DWORD               cbMessage,				//BLOB size
							PBYTE               pbMessage,				//BLOB Pointer
							PEnvData			pEnvelopedData,			//enveloped data
							HCRYPTPROV			hCryptProv,				//crypt provider
							HCERTSTORE			hCertStore				//certificate store
			  			   )
{

    HCRYPTKEY       hEncryptKey = 0, hPubKey = 0;
    DWORD           dwRetCode = ERROR_SUCCESS;
    DWORD           cbBufSize = 0;
  
	//
	//import public key data from the Certificate Context
	//
    if( !CryptImportPublicKeyInfoEx( hCryptProv, X509_ASN_ENCODING, 
                                     &pCertContext->pCertInfo->SubjectPublicKeyInfo, 
                                     CALG_RSA_KEYX, 0, NULL, &hPubKey ) )
    {
        goto ErrorReturn;
    }

    //
    // Generate a session key to encrypt the message
    //
    if( !CryptGenKey( hCryptProv, CALG_RC4, CRYPT_EXPORTABLE, &hEncryptKey ) )
    {
        goto ErrorReturn;
    }
        
    //
    // allocate enough memory to contain the encrypted data.  
    //
    // Note: 
    //
    // we are using the RC4 stream cipher, so the encrypted output buffer size will be the same
    // as the plaintext input buffer size.  If we change to block encryption algorithm,
    // then we need to determine the output buffer size which may be larger than the
    // input buffer size.
    //

    pEnvelopedData->cbEncryptedData = cbMessage;
    pEnvelopedData->pbEncryptedData = (PBYTE)LocalAlloc( GPTR, pEnvelopedData->cbEncryptedData );

    if( NULL == pEnvelopedData->pbEncryptedData )
    {
        goto ErrorReturn;
    }

    //
    // encrypt the message with the session key
    //

    memcpy( pEnvelopedData->pbEncryptedData, pbMessage, cbMessage );

    if( !CryptEncrypt( hEncryptKey, 0, TRUE, 0, pEnvelopedData->pbEncryptedData, 
                       &pEnvelopedData->cbEncryptedData, cbMessage ) )
    {
        goto ErrorReturn;
    }

    //
    // Determine the size of the buffer that we need to export the 
    // encryption key and then export the key.
    // The exported encryption key is encrypted with the receipient's
    // public key.
    //

    if( !CryptExportKey( hEncryptKey, hPubKey, SIMPLEBLOB, 0, NULL, 
                         &pEnvelopedData->cbEncryptedKey ) )
    {
        goto ErrorReturn;
    }
    
    pEnvelopedData->pbEncryptedKey = (PBYTE)LocalAlloc( GPTR, pEnvelopedData->cbEncryptedKey );
    
    if( NULL == pEnvelopedData->pbEncryptedKey )
    {
        goto ErrorReturn;
    }

    if( !CryptExportKey( hEncryptKey, hPubKey, SIMPLEBLOB, 0, pEnvelopedData->pbEncryptedKey, 
                         &pEnvelopedData->cbEncryptedKey ) )
    {
        goto ErrorReturn;
    }
        
done:

    if( hPubKey )
    {
        CryptDestroyKey( hPubKey );
    }

    if( hEncryptKey )
    {
        CryptDestroyKey( hEncryptKey );
    }

    if( pCertContext )
    {
        CertFreeCertificateContext( pCertContext );
    }
    
    if( hCertStore )
    {
        CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
    }

    if( hCryptProv )
    {
        CryptReleaseContext( hCryptProv, 0 );
    }        
    
    return( dwRetCode );

ErrorReturn:
    dwRetCode = GetLastError();
    goto done;
}

DWORD CGlobal::PackEnvData( 
							PEnvData     pEnvelopedData, 
							PDWORD       pcbPacked, 
							PBYTE        *ppbPacked 
						  )
{
    DWORD dwRetCode = ERROR_SUCCESS;
    PBYTE pCopyPos;

    //
    // determine the size of the buffer to allocate
    //

    *pcbPacked = pEnvelopedData->cbEncryptedData + pEnvelopedData->cbEncryptedKey +
                 ( sizeof( DWORD ) * 2 );

    *ppbPacked = (PBYTE)LocalAlloc( GPTR, *pcbPacked );

    if( NULL == ( *ppbPacked ) )
    {
        goto ErrorReturn;
    }

    pCopyPos = *ppbPacked;

    memcpy( pCopyPos, &pEnvelopedData->cbEncryptedKey, sizeof( DWORD ) );
    pCopyPos += sizeof( DWORD );

    memcpy( pCopyPos, pEnvelopedData->pbEncryptedKey, pEnvelopedData->cbEncryptedKey );
    pCopyPos += pEnvelopedData->cbEncryptedKey;

    memcpy( pCopyPos, &pEnvelopedData->cbEncryptedData, sizeof( DWORD ) );
    pCopyPos += sizeof( DWORD );

    memcpy( pCopyPos, pEnvelopedData->pbEncryptedData, pEnvelopedData->cbEncryptedData );    

done:

    return( dwRetCode );

ErrorReturn:

    dwRetCode = GetLastError();
	goto done;
}


DWORD CGlobal::SetCARequestAttributes()
{	
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwDisposition = 0;
	
	CString	sDelimiter = "~";
	TCHAR	chDelimiter= '~';
	CString	sPhoneLabel;
	CString	sFaxLabel;
	CString	sEmailLabel;
	CString	sLSNameLabel;
	CString	sName; 
	CString	sAddress; 
	LPTSTR	lpVal	= NULL;

	//Clear previous data if any
	ClearCARequestAttributes();

	lpVal = sPhoneLabel.GetBuffer(CA_PHONE_LEN+1);
	LoadString(GetInstanceHandle(),IDS_PHONE,lpVal,CA_PHONE_LEN+1);
	sPhoneLabel.ReleaseBuffer(-1);

	lpVal = sFaxLabel.GetBuffer(CA_PHONE_LEN+1);
	LoadString(GetInstanceHandle(),IDS_FAX, lpVal, CA_FAX_LEN+1);
	sFaxLabel.ReleaseBuffer(-1);

	lpVal = sEmailLabel.GetBuffer(CA_EMAIL_LEN+1);
	LoadString(GetInstanceHandle(),IDS_EMAIL,lpVal,CA_EMAIL_LEN+1);
	sEmailLabel.ReleaseBuffer(-1);
	
	lpVal = sLSNameLabel.GetBuffer(CA_EMAIL_LEN+1);
	LoadString(GetInstanceHandle(),IDS_LSNAME,lpVal,CA_EMAIL_LEN+1);
	sLSNameLabel.ReleaseBuffer(-1);

	sName		= m_ContactData.sContactLName + sDelimiter  + m_ContactData.sContactFName;
	sAddress	= m_ContactData.sContactAddress;
	LPSTR	lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)sName);
	SetDNAttribute(szOID_GIVEN_NAME,					lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sCompanyName);
	SetDNAttribute(szOID_COMMON_NAME,					lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sOrgUnit);
	SetDNAttribute(szOID_ORGANIZATIONAL_UNIT_NAME,		lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sContactEmail );
	SetDNAttribute(szOID_RSA_emailAddr,					lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sCertType );
	SetDNAttribute(szOID_TITLE,							lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sContactPhone );
	SetDNAttribute(szOID_TELEPHONE_NUMBER,				lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sContactFax );
	SetDNAttribute(szOID_FACSIMILE_TELEPHONE_NUMBER,	lpszTemp); delete lpszTemp;

	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sCity );
	SetDNAttribute(szOID_LOCALITY_NAME ,				lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sState);
	SetDNAttribute(szOID_STATE_OR_PROVINCE_NAME,		lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sCountryCode);
	SetDNAttribute(szOID_COUNTRY_NAME,					lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sZip);
	SetDNAttribute(szOID_POSTAL_CODE,					lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sCertType);
	SetDNAttribute(szOID_DESCRIPTION,					lpszTemp); delete lpszTemp;
	lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_lpstrLSName);
	SetDNAttribute(szOID_SUR_NAME,						lpszTemp); delete lpszTemp;

	return dwRetCode;
}

DWORD CGlobal::SetCHRequestAttributes()
{

	//Clear previous data if any
	ClearCHRequestAttributes();

	//
	//Program information
	//
	SetRegistrationAttribute ( _PROGRAMNAMETAG, (LPCTSTR)m_ContactData.sProgramName, m_ContactData.sProgramName.GetLength() );

	//
	//Contact information
	//	
	SetRegistrationAttribute ( _CONTACTLNAMETAG,	(LPCTSTR)m_ContactData.sContactLName,	m_ContactData.sContactLName.GetLength());	
	SetRegistrationAttribute ( _CONTACTFNAMETAG,	(LPCTSTR)m_ContactData.sContactFName,	m_ContactData.sContactFName.GetLength());	
	SetRegistrationAttribute ( _CONTACTADDRESSTAG,	(LPCTSTR)m_ContactData.sContactAddress,	m_ContactData.sContactAddress.GetLength());		
	SetRegistrationAttribute ( _CONTACTPHONETAG,	(LPCTSTR)m_ContactData.sContactPhone,	m_ContactData.sContactPhone.GetLength());	
	SetRegistrationAttribute ( _CONTACTFAXTAG,		(LPCTSTR)m_ContactData.sContactFax,		m_ContactData.sContactFax.GetLength());	
	SetRegistrationAttribute ( _CONTACTEMAILTAG,	(LPCTSTR)m_ContactData.sContactEmail,	m_ContactData.sContactEmail.GetLength());	
	SetRegistrationAttribute ( _CONTACTCITYTAG,		(LPCTSTR)m_ContactData.sCity,			m_ContactData.sCity.GetLength());	
	SetRegistrationAttribute ( _CONTACTCOUNTRYTAG,	(LPCTSTR)m_ContactData.sCountryCode,			m_ContactData.sCountryCode.GetLength());	
	SetRegistrationAttribute ( _CONTACTSTATE,		(LPCTSTR)m_ContactData.sState,			m_ContactData.sState.GetLength());	
	SetRegistrationAttribute ( _CONTACTZIP,			(LPCTSTR)m_ContactData.sZip,				m_ContactData.sZip.GetLength());


	//
	//customer information
	//	
	SetRegistrationAttribute ( _CUSTOMERNAMETAG, (LPCTSTR)m_ContactData.sCompanyName, m_ContactData.sCompanyName.GetLength());

	//Program related information
	if ( m_ContactData.sProgramName == PROGRAM_SELECT )
	{
		//Select		
		SetRegistrationAttribute ( _SELMASTERAGRNUMBERTAG,	(LPCTSTR)m_LicData.sSelMastAgrNumber,	m_LicData.sSelMastAgrNumber.GetLength() );		
		SetRegistrationAttribute ( _SELENROLLNUMBERTAG,		(LPCTSTR)m_LicData.sSelEnrollmentNumber, m_LicData.sSelEnrollmentNumber.GetLength());		
		SetRegistrationAttribute ( _SELPRODUCTTYPETAG,		(LPCTSTR)m_LicData.sSelProductType,		m_LicData.sSelProductType.GetLength());
		SetRegistrationAttribute ( _SELQTYTAG,				(LPCTSTR)m_LicData.sSelQty,				m_LicData.sSelQty.GetLength());
	}
	else if ( m_ContactData.sProgramName == PROGRAM_MOLP )
	{
		//MOLP		
		SetRegistrationAttribute ( _MOLPAUTHNUMBERTAG,		(LPCTSTR)m_LicData.sMOLPAuthNumber,		m_LicData.sMOLPAuthNumber.GetLength());		
		SetRegistrationAttribute ( _MOLPAGREEMENTNUMBERTAG, (LPCTSTR)m_LicData.sMOLPAgreementNumber, m_LicData.sMOLPAgreementNumber.GetLength());		
		SetRegistrationAttribute ( _MOLPPRODUCTTYPETAG,		(LPCTSTR)m_LicData.sMOLPProductType,		m_LicData.sMOLPProductType.GetLength());

		SetRegistrationAttribute ( _MOLPQTYTAG,				(LPCTSTR)m_LicData.sMOLPQty,				m_LicData.sMOLPQty.GetLength());
	}
	
	else if ( m_ContactData.sProgramName == PROGRAM_RETAIL )
	{
		//Retail
		//SetRegistrationAttribute ( _MFGINFOTAG, (LPCTSTR)m_CHData.sOthARBlob, m_CHData.sOthARBlob.GetLength(), FALSE );
	}

	//Shipping address information
	//For Offline , always put the shipping address info
	//for Online , no need to put the shipping address.	
	
	return ERROR_SUCCESS;
}


DWORD CGlobal::LoadCountries()
{
	DWORD	dwRetCode	= ERROR_SUCCESS;
	DWORD	dwIndex		= 0;
	CString	sCountry;
	LPTSTR	lpVal		= NULL;
	DWORD	dwSize		= LR_COUNTRY_DESC_LEN+LR_COUNTRY_CODE_LEN+128;

	LPTSTR	szDelimiter = (LPTSTR)L":";

	m_csaCountryDesc.SetSize(IDS_COUNTRY_END - IDS_COUNTRY_START + 1);
	m_csaCountryCode.SetSize(IDS_COUNTRY_END - IDS_COUNTRY_START + 1);

	for(dwIndex = IDS_COUNTRY_START;dwIndex <= IDS_COUNTRY_END;dwIndex++)
	{
		lpVal = sCountry.GetBuffer(dwSize);

		LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);	

		m_csaCountryDesc[dwIndex-IDS_COUNTRY_START] = _tcstok(lpVal,szDelimiter);
		m_csaCountryCode[dwIndex-IDS_COUNTRY_START] = _tcstok(NULL,szDelimiter);

		sCountry.ReleaseBuffer(-1);
	}

	return dwRetCode;
}

DWORD CGlobal::PopulateCountryComboBox(HWND hWndCmb)
{
	DWORD	dwRetCode	= ERROR_SUCCESS;
	DWORD	dwIndex		= 0;
	CString sDesc;
	LPTSTR	lpVal		= NULL;

	for(dwIndex=0;dwIndex <= IDS_COUNTRY_END - IDS_COUNTRY_START;dwIndex++)
	{
		sDesc = m_csaCountryDesc[dwIndex];

		lpVal = sDesc.GetBuffer(LR_COUNTRY_DESC_LEN);
		ComboBox_AddString(hWndCmb,lpVal);
		sDesc.ReleaseBuffer(-1);
	}
	
	return dwRetCode;
}

DWORD CGlobal::GetCountryCode(CString sDesc,LPTSTR szCode)
{
	DWORD dwRetCode =  ERROR_SUCCESS;
	DWORD dwIndex	=  0;

	for(dwIndex=0;dwIndex <= IDS_COUNTRY_END - IDS_COUNTRY_START;dwIndex++)
	{
		if(m_csaCountryDesc[dwIndex] == sDesc)
			break;
	}

	if(dwIndex > IDS_COUNTRY_END - IDS_COUNTRY_START)
		_tcscpy(szCode,CString(""));	//Not found
	else
		_tcscpy(szCode,m_csaCountryCode[dwIndex]);

	return dwRetCode;
}

DWORD CGlobal::GetCountryDesc(CString sCode,LPTSTR szDesc)
{
	DWORD dwRetCode =  ERROR_SUCCESS;
	DWORD dwIndex	=  0;

	for(dwIndex=0;dwIndex <= IDS_COUNTRY_END - IDS_COUNTRY_START;dwIndex++)
	{
		if(m_csaCountryCode[dwIndex] == sCode)
			break;
	}

	if(dwIndex > IDS_COUNTRY_END - IDS_COUNTRY_START)
		_tcscpy(szDesc,CString(""));  //Not found
	else
		_tcscpy(szDesc,m_csaCountryDesc[dwIndex]);

	return dwRetCode;
}


DWORD CGlobal::LoadProducts()
{
	DWORD	dwRetCode	= ERROR_SUCCESS;
	DWORD	dwIndex		= 0;
	CString	sProduct;
	LPTSTR	lpVal		= NULL;
	DWORD	dwSize		= LR_PRODUCT_DESC_LEN+LR_PRODUCT_CODE_LEN+128;
    BOOL    fWin2000    = !m_fSupportConcurrent;    
  

    DWORD   dwNumProducts = 0;
    
    if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
    { 
        dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
    }
    else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;
    }

    DWORD   dwArray     = 0;

	LPTSTR	szDelimiter = (LPTSTR)L":";

	m_csaProductDesc.SetSize(dwNumProducts);
	m_csaProductCode.SetSize(dwNumProducts);

	for(dwIndex = IDS_PRODUCT_START; dwIndex < (IDS_PRODUCT_START + dwNumProducts) ; dwIndex++)
	{
        if ( !m_fSupportConcurrent && dwIndex == IDS_PRODUCT_CONCURRENT)
            continue;               

        if( !m_fSupportWhistlerCAL && dwIndex == IDS_PRODUCT_WHISTLER)
            continue;

		lpVal = sProduct.GetBuffer(dwSize);

		LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);

		m_csaProductDesc[dwArray] = _tcstok(lpVal,szDelimiter);
		m_csaProductCode[dwArray] = _tcstok(NULL,szDelimiter);

        dwArray++;

		sProduct.ReleaseBuffer(-1);
	}

	return dwRetCode;
}



DWORD CGlobal::PopulateProductComboBox(HWND hWndCmb)
{
	DWORD	dwRetCode	= ERROR_SUCCESS;
	DWORD	dwIndex		= 0;
	CString sDesc;
	LPTSTR	lpVal		= NULL;
        
    DWORD   dwNumProducts = 0;
    
    if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
    { 
        dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
    }
    else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;
    }


	for(dwIndex=0; dwIndex < dwNumProducts; dwIndex++)
	{
		sDesc = m_csaProductDesc[dwIndex];

		lpVal = sDesc.GetBuffer(LR_PRODUCT_DESC_LEN);
		ComboBox_AddString(hWndCmb,lpVal);
		sDesc.ReleaseBuffer(-1);
	}
	
	return dwRetCode;
}


DWORD CGlobal::GetProductCode(CString sDesc,LPTSTR szCode)
{
	DWORD dwRetCode =  ERROR_SUCCESS;
	DWORD dwIndex	=  0;
  
    DWORD   dwNumProducts = 0;
    
    if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
    { 
        dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
    }
    else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;
    }


	for(dwIndex=0; dwIndex < dwNumProducts; dwIndex++)
	{
		if(m_csaProductDesc[dwIndex] == sDesc)
			break;
	}

	if(dwIndex >= dwNumProducts )  
		_tcscpy(szCode,CString(""));		//Not found
	else
		_tcscpy(szCode,m_csaProductCode[dwIndex]);

	return dwRetCode;
}

//Load all react and deact reasons



DWORD CGlobal::LoadReasons()
{
	DWORD	dwRetCode	= ERROR_SUCCESS;
	DWORD	dwIndex		= 0;
	CString	sReason;
	LPTSTR	lpVal		= NULL;
	DWORD	dwSize		= LR_REASON_CODE_LEN+LR_REASON_DESC_LEN+128;

	LPTSTR	szDelimiter = (LPTSTR)L":";

	m_csaReactReasonDesc.SetSize(  IDS_REACT_REASONS_END - IDS_REACT_REASONS_START + 1);
	m_csaReactReasonCode.SetSize( IDS_REACT_REASONS_END - IDS_REACT_REASONS_START + 1);
	
	m_csaDeactReasonDesc.SetSize(IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START + 1);
	m_csaDeactReasonCode.SetSize(IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START + 1);

	//load the reacr
	for(dwIndex = IDS_REACT_REASONS_START;dwIndex <= IDS_REACT_REASONS_END; dwIndex++)
	{
		lpVal = sReason.GetBuffer(dwSize);

		
		
		LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);	

		m_csaReactReasonDesc[dwIndex-IDS_REACT_REASONS_START] = _tcstok(lpVal,szDelimiter);
		m_csaReactReasonCode[dwIndex-IDS_REACT_REASONS_START] = _tcstok(NULL,szDelimiter);

		sReason.ReleaseBuffer(-1);
	}

	for ( dwIndex = IDS_DEACT_REASONS_START; dwIndex <= IDS_DEACT_REASONS_END; dwIndex ++ )
	{
		lpVal = sReason.GetBuffer(dwSize);
		
		LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);	

		m_csaDeactReasonDesc[dwIndex-IDS_DEACT_REASONS_START] = _tcstok(lpVal,szDelimiter);
		m_csaDeactReasonCode[dwIndex-IDS_DEACT_REASONS_START] = _tcstok(NULL,szDelimiter);
		sReason.ReleaseBuffer(-1);

	}

	return dwRetCode;
}

DWORD CGlobal::PopulateReasonComboBox(HWND hWndCmb, DWORD dwType)
{
	DWORD	dwRetCode	= ERROR_SUCCESS;
	DWORD	dwIndex		= 0;
	CString sDesc;
	LPTSTR	lpVal		= NULL;
	DWORD dwNumItems	= 0;

	//If combo box is already populated,just return success
	if(ComboBox_GetCount(hWndCmb) > 0)
		return dwRetCode;

	ComboBox_ResetContent( hWndCmb);
	if ( dwType == CODE_TYPE_REACT )
	{
		dwNumItems = IDS_REACT_REASONS_END - IDS_REACT_REASONS_START ;
	}
	else if ( dwType == CODE_TYPE_DEACT )
	{
		dwNumItems = IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START ;
	}
	else
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}
	for(dwIndex=0;dwIndex <= dwNumItems;dwIndex++)
	{
		if ( dwType == CODE_TYPE_REACT )
		{
			sDesc = m_csaReactReasonDesc[dwIndex];
		}
		else if ( dwType == CODE_TYPE_DEACT )
		{
			sDesc = m_csaDeactReasonDesc[dwIndex];
		}

		lpVal = sDesc.GetBuffer(LR_REASON_DESC_LEN);
		ComboBox_AddString(hWndCmb,lpVal);
		sDesc.ReleaseBuffer(-1);
	}
done:
	return dwRetCode;
}


DWORD CGlobal::GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType)
{
	DWORD dwRetCode =  ERROR_SUCCESS;
	DWORD dwIndex	=  0;
	DWORD	dwNumItems = 0;

	if ( dwType == CODE_TYPE_REACT )
	{
		dwNumItems = IDS_REACT_REASONS_END - IDS_REACT_REASONS_START ;
	}
	else if ( dwType == CODE_TYPE_DEACT )
	{
		dwNumItems = IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START ;
	}

	for(dwIndex=0;dwIndex <= dwNumItems;dwIndex++)
	{
		if ( dwType == CODE_TYPE_REACT )
		{
			if ( m_csaReactReasonDesc[dwIndex] == sDesc )
				break;
			
		}
		else if ( dwType == CODE_TYPE_DEACT )
		{
			if ( m_csaDeactReasonDesc[dwIndex] == sDesc )
				break;
		}
	}

	if(dwIndex > dwNumItems)
		_tcscpy(szCode,CString(""));	//Not found
	else
	{
		if ( dwType == CODE_TYPE_REACT )
		{
			_tcscpy(szCode,m_csaReactReasonCode[dwIndex]);			
		}
		else if ( dwType == CODE_TYPE_DEACT )
		{
			_tcscpy(szCode,m_csaDeactReasonCode[dwIndex]);			
		}
		
	}


	return dwRetCode;
}

DWORD CGlobal::GetReasonDesc(CString sCode,LPTSTR szDesc, DWORD dwType)
{
	DWORD dwRetCode =  ERROR_SUCCESS;
	DWORD dwIndex	=  0;
	DWORD dwNumItems = 0;
	if ( dwType == CODE_TYPE_REACT )
	{
		dwNumItems = IDS_REACT_REASONS_END - IDS_REACT_REASONS_START ;
	}
	else if ( dwType == CODE_TYPE_DEACT )
	{
		dwNumItems = IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START ;
	}


	for(dwIndex=0;dwIndex <= dwNumItems;dwIndex++)
	{
		if ( dwType == CODE_TYPE_REACT )
		{
			if ( m_csaReactReasonCode[dwIndex] == sCode )
				break;
			
		}
		else if ( dwType == CODE_TYPE_DEACT )
		{
			if ( m_csaDeactReasonCode[dwIndex] == sCode )
				break;
		}

	}

	if(dwIndex > dwNumItems)
		_tcscpy(szDesc,CString(""));  //Not found
	else
	{
		if ( dwType == CODE_TYPE_REACT )
		{
			_tcscpy(szDesc,m_csaReactReasonDesc[dwIndex]);			
		}
		else if ( dwType == CODE_TYPE_DEACT )
		{
			_tcscpy(szDesc,m_csaDeactReasonDesc[dwIndex]);			
		}
	}

	return dwRetCode;
}

DWORD CGlobal::CheckRegistryForPhoneNumbers()
{
	DWORD	dwRetCode		= ERROR_SUCCESS;
	DWORD	dwIndex			= 0;
	HKEY	hKey			= NULL;
	DWORD   dwDisposition	= 0;
	DWORD	dwType			= REG_SZ;
	DWORD   dwValName;
	DWORD	dwCS_Number;
	TCHAR   lpValueName[ 128];
	TCHAR	lpCS_Number[ 128];

	//
	// Try to open the required registry key
	//
	dwRetCode = ConnectToLSRegistry();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_CSNUMBERS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if (dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	

	do {
		dwValName		= sizeof(lpValueName)/sizeof(TCHAR);
		dwCS_Number		= sizeof(lpCS_Number);

		dwRetCode = RegEnumValue(hKey,
								 dwIndex,
								 lpValueName,
								 &dwValName,
								 NULL,
								 &dwType,
								 (BYTE *) lpCS_Number,
								 &dwCS_Number);

		if (dwRetCode == ERROR_NO_MORE_ITEMS)
		{
			dwRetCode = ERROR_SUCCESS;
			break;
		}
		else if (dwRetCode != ERROR_SUCCESS )
		{			
			break;
		}

		if(dwType != REG_SZ)
			continue;

		dwIndex++;		

	} while (1);

	if (dwIndex <= 0)
	{
		dwRetCode = IDS_ERR_REGERROR;
	}

done:
	if (hKey)
	{
		RegCloseKey(hKey);
	}

	DisconnectLSRegistry();
	
	return dwRetCode;
}

DWORD CGlobal::PopulateCountryRegionComboBox(HWND hWndCmb)
{
	DWORD	dwRetCode		= ERROR_SUCCESS;
	DWORD	dwIndex			= 0;
	HKEY	hKey			= NULL;
	DWORD   dwDisposition	= 0;
	DWORD	dwType			= REG_SZ;
	DWORD   dwValName;
	DWORD	dwCS_Number;
	LVITEM	lvItem;
	DWORD   nItem;
	TCHAR   lpValueName[ 128];
	TCHAR	lpCS_Number[ 128];


	//
	// Get CSR Numbers from the Reqgistry
	//
	dwRetCode = ConnectToLSRegistry();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx (m_hLSRegKey,
								REG_LRWIZ_CSNUMBERS,
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								NULL,
								&hKey,
								&dwDisposition);
	
	if (dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	


	//Clear the List first
	ListView_DeleteAllItems(hWndCmb);

	do {
		dwValName		= sizeof(lpValueName)/sizeof(TCHAR);
		dwCS_Number		= sizeof(lpCS_Number);

		dwRetCode = RegEnumValue(hKey,
								 dwIndex,
								 lpValueName,
								 &dwValName,
								 NULL,
								 &dwType,
								 (BYTE *) lpCS_Number,
								 &dwCS_Number);

		if (dwRetCode == ERROR_NO_MORE_ITEMS)
		{
			dwRetCode = ERROR_SUCCESS;
			break;
		}
		else if (dwRetCode != ERROR_SUCCESS )
		{			
			break;
		}

		dwIndex++;

		if(dwType != REG_SZ)
			continue;

		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = 0;
		lvItem.iSubItem = 0;
		lvItem.pszText = lpValueName;
		lvItem.cchTextMax = lstrlen(lpValueName);
		nItem = ListView_InsertItem(hWndCmb, &lvItem);

		lvItem.iSubItem = 1;
		lvItem.iItem = nItem;
		lvItem.pszText = lpCS_Number;
		lvItem.cchTextMax = lstrlen(lpCS_Number);
		ListView_SetItem(hWndCmb, &lvItem);

//		ComboBox_AddString(hWndCmb,lpVal);
	} while (1);

	if (dwIndex <= 0)
	{
		dwRetCode = IDS_ERR_REGERROR;
	}

done:
	if (hKey)
	{
		RegCloseKey(hKey);
	}

	DisconnectLSRegistry();
	
	return dwRetCode;
}

void CGlobal::LRSetLastRetCode(DWORD dwCode)
{
	m_dwLastRetCode = dwCode;
}

DWORD CGlobal::LRGetLastRetCode()
{
	return m_dwLastRetCode;
}

LPWSTR CGlobal::AnsiToUnicode ( LPSTR lpszBuf )
{
	LPWSTR lpwszRetBuf = NULL;
	long lBufLen = ::lstrlenA(lpszBuf) + 1;
	lpwszRetBuf = new WCHAR[ lBufLen ];
	memset ( lpwszRetBuf, 0, lBufLen * sizeof(TCHAR));
	MultiByteToWideChar  ( GetACP(),
						   MB_PRECOMPOSED,
						   lpszBuf,
						   -1,
						   lpwszRetBuf,
						   lBufLen
						   );

	return lpwszRetBuf;
}

LPSTR CGlobal::UnicodeToAnsi( LPWSTR lpwszBuf, DWORD dwLength )
{
	LPSTR lpszRetBuf = NULL;
	lpszRetBuf = new char[dwLength+1];
	memset ( lpszRetBuf,0,dwLength+1);
	WideCharToMultiByte(GetACP(),					// code page
						0,							// performance and mapping flags
						lpwszBuf,					// address of wide-character string
						dwLength,					// number of characters in string
						lpszRetBuf,					// address of buffer for new string
						//dwLength+1, //BUG # 585	// size of buffer
						(dwLength+1) * sizeof(TCHAR), // size of buffer in bytes						
						NULL,						// address of default for unmappable characters
						NULL						// address of flag set when default char. used
						);
	
	return lpszRetBuf;

}
LPSTR CGlobal::UnicodeToAnsi( LPWSTR lpwszBuf)
{
	LPSTR lpszRetBuf = NULL;
	long lBufLen = ::lstrlenW(lpwszBuf)+1;

	lpszRetBuf = new char[lBufLen];

	WideCharToMultiByte(GetACP(),							// code page
						0,								// performance and mapping flags
						lpwszBuf,						// address of wide-character string
						-1,								// number of characters in string
						lpszRetBuf,						// address of buffer for new string
						//lBufLen,	//BUG # 585			// size of buffer
						lBufLen * sizeof(TCHAR),		// size of buffer in bytes						
						NULL,							// address of default for unmappable characters
						NULL							// address of flag set when default char. used
						);
	return lpszRetBuf;
}

void CGlobal::LRPush(DWORD dwPageId)
{
	assert(m_dwTop < NO_OF_PAGES - 1);
	m_dwWizStack[m_dwTop++] = dwPageId;		
}

DWORD CGlobal::LRPop()
{
	assert(m_dwTop > 0);
	return m_dwWizStack[--m_dwTop];
}




BOOL CGlobal::ValidateEmailId(CString sEmailId)
{

	BOOL	bValid	= FALSE;
	int		dwLen	= 0;

	dwLen = sEmailId.GetLength();

	do
	{
		// Check the length
		if(dwLen < EMAIL_MIN_LEN)
			break;

		// Make sure it does not have spaces
		if(sEmailId.Find(EMAIL_SPACE_CHAR) != -1)
			break;

		// Make sure it has '@' & '.' in it
		if(sEmailId.Find(EMAIL_AT_CHAR) == -1 || sEmailId.Find(EMAIL_DOT_CHAR) == -1)
			break;

		// Make sure first char is not either EMAIL_AT_CHAR or EMAIL_DOT_CHAR
		if(sEmailId[0] == EMAIL_AT_CHAR || sEmailId[0] == EMAIL_DOT_CHAR)
			break;

		// Make sure last char is not either EMAIL_AT_CHAR or EMAIL_DOT_CHAR
		if(sEmailId[dwLen-1] == EMAIL_AT_CHAR || sEmailId[dwLen-1] == EMAIL_DOT_CHAR)
			break;

		// EMAIL_AT_CHAR should come only once
		if(sEmailId.Find(EMAIL_AT_CHAR) != sEmailId.ReverseFind(EMAIL_AT_CHAR))
			break;
		
		//It should not have these string "@." or ".@"
		if(sEmailId.Find(EMAIL_AT_DOT_STR) != -1 || sEmailId.Find(EMAIL_DOT_AT_STR) != -1)
			break;

		bValid = TRUE;
	}
	while(FALSE);

	return bValid;
}

BOOL  CGlobal::CheckProgramValidity (CString sProgramName )
{
	BOOL bRetCode = FALSE;


//	if(sProgramName == PROGRAM_SELECT)
//	{
//		//select
//		if(strstr ( (const char *)m_pbExtensionValue+3, CA_CERT_TYPE_SELECT ) )
//		{
//			bRetCode = TRUE;
//		}
//	}
//	else if ( sProgramName == PROGRAM_MOLP || sProgramName == PROGRAM_RETAIL )
//	{
		//retail or MOLP
//		if (strstr ( (const char *)m_pbExtensionValue+3, CA_CERT_TYPE_SELECT ) ||
//			strstr ( (const char *)m_pbExtensionValue+3, CA_CERT_TYPE_OTHER )
//		   )
//		{
			bRetCode = TRUE;
//		}
//	}
//
	return bRetCode;
}

//
// This function searches for Single quote (') and replaces it will two single quotes ('')
// This is because , SQL server gives error if the string contains single quote
//
void CGlobal::PrepareLRString(CString &sStr)
{
	CString sTemp;
	int		nIndex = 0;
	
	for(nIndex=0;nIndex < sStr.GetLength();nIndex++)
	{
		if(sStr[nIndex] == LR_SINGLE_QUOTE)
		{
			sTemp += LR_SINGLE_QUOTE;
			sTemp += LR_SINGLE_QUOTE;
		}
		else
			sTemp += sStr[nIndex];
	}

	sStr = sTemp;
}

//
// This functions checks for any invalid chars in the string
//
BOOL CGlobal::ValidateLRString(CString sStr)
{
	CString sInvalidChars = LR_INVALID_CHARS;

	if(sStr.FindOneOf(sInvalidChars) != -1)
		return FALSE;
	else
		return TRUE;
}

//
//Validate the certificate chain for a given store.  This is an overkill but
//will make it more robust!
//

DWORD CGlobal::VerifyCertChain (	HCRYPTPROV	hCryptProvider,			//handle to crypt prov
									HCERTSTORE	hCertStore,				//HAndle to store for verification
									PBYTE	pbRootCert,			//Root cert
									DWORD	dwcbRootCert
							)
{
	DWORD				dwRetVal = ERROR_SUCCESS;
	PCCERT_CONTEXT      pRootCertContext = NULL;
	PCCERT_CONTEXT		pCertContext = NULL;
	PCCERT_CONTEXT		pIssuerCertContext = NULL;

	DWORD				dwFlags = CERT_STORE_SIGNATURE_FLAG;

	if ( NULL == hCryptProvider  || NULL == hCertStore || NULL == pbRootCert || dwcbRootCert <= 0  ) 
	{
		LRSetLastError (ERROR_INVALID_PARAMETER);
		dwRetVal = IDS_ERR_CRYPT_ERROR;
		goto done;		
	}
	//Create a Root certificate context
	pRootCertContext = CertCreateCertificateContext (	X509_ASN_ENCODING,
														pbRootCert,
														dwcbRootCert
													);
	if ( pRootCertContext == NULL )
	{
		LRSetLastError (GetLastError());
		dwRetVal = IDS_ERR_CRYPT_ERROR;
		goto done;		
	}
	//check to see if there is a certificate with our extension in the store.  Then use that as the 
	//starting point
	dwRetVal = GetCertforExtension (hCryptProvider, hCertStore, szOID_NULL_EXT, &pCertContext);
	if ( dwRetVal != ERROR_SUCCESS )
	{
		LRSetLastError(dwRetVal );
		dwRetVal = IDS_ERR_CRYPT_ERROR;
		goto done;
	}

	//Walk the chain here
	do
	{        

        pIssuerCertContext = CertGetIssuerCertificateFromStore( hCertStore,
																pCertContext,
																NULL, // pIssuerCertContext,
																&dwFlags );
		if ( pIssuerCertContext )
		{

			//check to see the result.
			if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
			{
				LRSetLastError(GetLastError());
				dwRetVal = IDS_ERR_INVALID_CERT_CHAIN;
				break;
			}

			dwFlags = CERT_STORE_SIGNATURE_FLAG;
			CertFreeCertificateContext (pCertContext);
			pCertContext = pIssuerCertContext;
		}
	} while ( pIssuerCertContext );

	if ( dwRetVal != ERROR_SUCCESS )
	{
		goto done;
	}
	//Verify the last issuer against the root passed in
	dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if ( !CertVerifySubjectCertificateContext( pCertContext, pRootCertContext, &dwFlags ) )
    {
		dwRetVal = GetLastError();
        goto done;
	}
	//check to see the result.
	if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
	{
		LRSetLastError(GetLastError());
		dwRetVal = IDS_ERR_INVALID_CERT_CHAIN;
	}

done:
	if (pCertContext != NULL)
	{
		CertFreeCertificateContext(pCertContext);
	}

	if (pRootCertContext != NULL)
	{
		CertFreeCertificateContext(pRootCertContext);
	}

	return dwRetVal;
}


DWORD CGlobal::GetCertforExtension (HCRYPTPROV hCryptProv, HCERTSTORE hCertStore, LPSTR szOID_EXT, PCCERT_CONTEXT * ppCertContext)
{
	DWORD			dwRetVal = ERROR_SUCCESS;
	PCCERT_CONTEXT	pCurrentContext = NULL;
	PCCERT_CONTEXT	pPrevContext = NULL;
	PCERT_EXTENSION		pCertExtension	= NULL;

	if ( hCryptProv == NULL || hCertStore == NULL || ppCertContext == NULL )
	{
		dwRetVal = ERROR_INVALID_PARAMETER;
		goto done;
	}
	*ppCertContext = NULL;

	do
	{
		//Get the cert context
		pCurrentContext = CertEnumCertificatesInStore ( hCertStore, pPrevContext );
		if ( pCurrentContext )
		{
			//Check to see if the Extension is present in the cert context
			pCertExtension = CertFindExtension ( szOID_NULL_EXT,
												 pCurrentContext->pCertInfo->cExtension,
												 pCurrentContext->pCertInfo->rgExtension
												);
			if ( pCertExtension )
			{
				*ppCertContext = pCurrentContext;
				goto done;
			}
			pPrevContext = pCurrentContext;
		}

	} while ( pCurrentContext );

	dwRetVal = CRYPT_E_NOT_FOUND;		//CErt not found

done:
//	if ( pPrevContext )
//	{
//		CertFreeCertificateContext (pPrevContext);
//	}

	if ( !*ppCertContext && pCurrentContext )
	{
		CertFreeCertificateContext (pCurrentContext);
	}

	return dwRetVal;
}




DWORD CGlobal::FetchResponse(BYTE * bpResponse,
				  		     DWORD dwMaxLength,
							 PDWORD dwpDataLength)
{
	DWORD	dwCHRC			= ERROR_SUCCESS;	
	DWORD	dwBytesRead		= 0;
	BOOL	bRC				= FALSE;
	BYTE *  bpCurrent	    = bpResponse;

	*dwpDataLength = 0;

	assert(m_hOpenDirect != NULL);
	assert(m_hRequest != NULL);
	assert(m_hConnect != NULL);

	while ( dwMaxLength > 0 && (bRC = InternetReadFile ( m_hRequest, 
														 bpResponse,
														 dwMaxLength,
														 &dwBytesRead )) && dwBytesRead)
	{
		dwMaxLength -= dwBytesRead;
		(*dwpDataLength) += dwBytesRead;
	}

	if (!bRC)
	{
//		dwCHRC = GetLastError();
		dwCHRC = IDS_ERR_CHFETCHRESPONSE;
	}

	return dwCHRC;
}



DWORD CGlobal::InitCHRequest(void)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	const char	*pszAcceptedTypes[] = {"*/*",NULL};
	LPSTR	lpszCHName = UnicodeToAnsi((LPTSTR)(LPCTSTR) m_lpstrCHServer);
	LPSTR   lpszExtension = UnicodeToAnsi((LPTSTR)(LPCTSTR) m_lpstrCHExtension);
	
	assert(m_hOpenDirect == NULL);
	assert(m_hConnect == NULL);
	assert(m_hRequest == NULL);

	//m_hOpenDirect = InternetOpenA ( "LRWizDLL",  NULL, INTERNET_OPEN_TYPE_PRECONFIG, NULL, 0 ); //Bug # 526
	m_hOpenDirect = InternetOpenA ( "LRWizDLL",  INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );
	if (m_hOpenDirect == NULL)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	m_hConnect = InternetConnectA (m_hOpenDirect,
								   lpszCHName,										  
                                   INTERNET_DEFAULT_HTTPS_PORT ,
                                   NULL,
                                   NULL,
                                   INTERNET_SERVICE_HTTP,
                                   0,		
                                   0) ;
	if ( !m_hConnect )
	{
		dwRetCode = GetLastError();
		goto done;
	}


	m_hRequest = HttpOpenRequestA (	m_hConnect,
									"POST",
									lpszExtension,
									"HTTP/1.0",
									NULL,
									pszAcceptedTypes,
									INTERNET_FLAG_SECURE |
									INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
									NULL );	//(DWORD)this);
	if ( !m_hRequest )
	{
		dwRetCode = GetLastError();
		goto done;
	}

done:
	if (lpszCHName)
	{
		delete lpszCHName;
	}

	if (lpszExtension)
	{
		delete lpszExtension;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		CloseCHRequest();
	}

	return dwRetCode;
}



DWORD CGlobal::CloseCHRequest(void)
{
	if (m_hRequest)
	{
		InternetCloseHandle(m_hRequest);
		m_hRequest = NULL;
	}

	if (m_hConnect)
	{
		InternetCloseHandle(m_hConnect);
		m_hConnect = NULL;
	}

	if (m_hOpenDirect)
	{
		InternetCloseHandle(m_hOpenDirect);
		m_hOpenDirect = NULL;
	}

	return ERROR_SUCCESS;
}




DWORD CGlobal::Dispatch(BYTE * bpData,
					    DWORD dwLen)
{
	DWORD	dwCHRC = ERROR_SUCCESS;;

	DWORD		dwPostStatus = 0;
	DWORD		dwPostStatusSize = sizeof(dwPostStatus);
 	DWORD		dwFlags;
	DWORD		dwBufLen = sizeof(dwFlags);


	assert(m_hOpenDirect != NULL);
	assert(m_hRequest != NULL);
	assert(m_hConnect != NULL);

	try 
	{
		BOOL bRC = TRUE;
		char	szContentType[] = "Content-Type: application/octet-stream\r\n";

		if ( !HttpAddRequestHeadersA ( m_hRequest, szContentType, -1L, HTTP_ADDREQ_FLAG_ADD|HTTP_ADDREQ_FLAG_REPLACE ) )
		{
			DWORD  dwError = GetLastError();
		}
		
		bRC = HttpSendRequestA(	m_hRequest,
								NULL,
								0,
								bpData,	//binary data
								dwLen		//length of the data
							 );
		if (!bRC)
		{
			if (GetLastError() == ERROR_INTERNET_INVALID_CA)
			{
				InternetQueryOptionA(m_hRequest, INTERNET_OPTION_SECURITY_FLAGS,
									(LPVOID) &dwFlags, &dwBufLen);

				dwFlags |= SECURITY_FLAG_IGNORE_UNKNOWN_CA;

				InternetSetOptionA(m_hRequest, INTERNET_OPTION_SECURITY_FLAGS,
									(LPVOID) &dwFlags, sizeof(dwFlags));

				bRC = HttpSendRequestA(	m_hRequest,
										NULL,
										0,
										bpData,	//binary data
										dwLen);		//length of the data
			}
		}
		if (bRC)
		{		
			if ( HttpQueryInfoA( m_hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, (LPVOID)&dwPostStatus, &dwPostStatusSize, NULL ) )
			{
				if ( dwPostStatus != 200 )
				{
					dwCHRC = CH_ERROR_HTTPQRY_FAILED;
					throw dwCHRC;
				}
			}
			else
			{
				dwCHRC = GetLastError();
				throw dwCHRC;			
			}
		}
		else
		{
			dwCHRC = GetLastError();
			dwCHRC = CH_ERROR_SEND_FAILED;
			throw dwCHRC;			
		}
	}

	catch (DWORD dwRC)
	{
		dwCHRC = dwRC;
	}

	catch (...)
	{
		assert("Exception in Dispatch() !");
		dwCHRC = CH_ERROR_EXCEPTION;		
	}


	if (dwCHRC != ERROR_SUCCESS)
	{
		dwCHRC = IDS_ERR_SEND_FAILED;
	}
	
	return dwCHRC;
}	





DWORD CGlobal::PingCH(void)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	Ping_Request	pingData;
	Ping_Response   pingResp;
	BYTE bResponse[ 1024];
	DWORD dwDataLength;
	
	//
	// Set Language Id
	//
	pingData.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = Dispatch((BYTE *) &pingData, sizeof(Ping_Request));
	if (dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}


	dwRetCode = FetchResponse(bResponse, sizeof(bResponse), &dwDataLength);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Now let us ensure that we are getting the expected byte stream back
	// AND if we are, we are good to go.
	memcpy(&pingResp, bResponse, sizeof(Ping_Response));
	if (lstrcmp(pingResp.tszPingResponse, L"Beam'er up Scottie!") != 0)
	{
		// Expected Response	
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

done:
	CloseCHRequest();

	return dwRetCode;
}






DWORD CGlobal::ProcessIRegRequest()
{
	DWORD dwRetCode = ERROR_SUCCESS;
	NewCert_Request certRequest;
	NewCert_Response certResponse;
	Certificate_AckRequest certackRequest;
	Certificate_AckResponse	certackResponse;


	HCRYPTPROV	hCryptProv	 = NULL;
	LPWSTR	lpwszExchgPKCS10 = NULL;
	LPWSTR	lpwszSignPKCS10  = NULL;
	LPBYTE	lpszReqData		 = NULL;
	LPBYTE	lpszNextCopyPos	 = NULL;
	LPSTR	lpszExchgPKCS10	 = NULL;
	LPSTR	lpszSigPKCS10	 = NULL;
	DWORD   dwExchangeLen = 0;
	DWORD   dwSignLen = 0;
	DWORD   dwResponseLength = 0;
	PBYTE lpszResData	= NULL;

	DWORD  dwExchgCertLen	= 0;
	DWORD  dwSigCertLen		= 0;
	DWORD  dwRootCertLen	= 0;

	LPSTR	lpszExchCert = NULL;
	LPSTR	lpszSignCert = NULL;
	LPSTR	lpszRootCert = NULL;
	bool	bToSendAck = false;

	//
	// Set the LangId
	//
	certRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		return dwRetCode;
	}

	try
	{
		swprintf(certRequest.stCertInfo.OrgName, L"%.*s", CA_CUSTMER_NAME_LEN, (LPCTSTR) m_ContactData.sCompanyName);
		swprintf(certRequest.stCertInfo.OrgUnit, L"%.*s", CA_ORG_UNIT_LEN, (LPCTSTR) m_ContactData.sOrgUnit);
		swprintf(certRequest.stCertInfo.Address, L"%.*s", CA_ADDRESS_LEN, (LPCTSTR) m_ContactData.sContactAddress);
		swprintf(certRequest.stCertInfo.City, L"%.*s", CA_CITY_LEN, (LPCTSTR) m_ContactData.sCity);
		swprintf(certRequest.stCertInfo.State, L"%.*s", CA_STATE_LEN, (LPCTSTR) m_ContactData.sState);
		swprintf(certRequest.stCertInfo.Country, L"%.*s", CA_COUNTRY_LEN, (LPCTSTR) m_ContactData.sCountryCode);
		swprintf(certRequest.stCertInfo.Zip, L"%.*s", CA_ZIP_LEN, (LPCTSTR) m_ContactData.sZip);
		swprintf(certRequest.stCertInfo.LName, L"%.*s", CA_NAME_LEN, (LPCTSTR) m_ContactData.sContactLName);
		swprintf(certRequest.stCertInfo.FName, L"%.*s", CA_NAME_LEN, (LPCTSTR) m_ContactData.sContactFName);
		swprintf(certRequest.stCertInfo.Phone, L"%.*s", CA_PHONE_LEN, (LPCTSTR) m_ContactData.sContactPhone);
		swprintf(certRequest.stCertInfo.Fax, L"%.*s", CA_FAX_LEN, (LPCTSTR) m_ContactData.sContactFax);
		swprintf(certRequest.stCertInfo.Email, L"%.*s", CA_EMAIL_LEN, (LPCTSTR) m_ContactData.sContactEmail);
		swprintf(certRequest.stCertInfo.LSID, L"%.*s", CA_LSERVERID_LEN, (LPCTSTR) m_pLicenseServerID );
		swprintf(certRequest.stCertInfo.ProgramName, L"%.*s", 63, 
			(GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_SELECT ? L"SELECT" : L"BASIC"));

		//
		// GetGlobalContext()->GetContactDataObject()->sCertType is not set anywhere but is passed
		// to the back end as part of the PKCS10 Request.Not sure what it is used for in the back end
		// Anyway set it to proper value here. Arvind 06/28/99.
		//
		if(GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_SELECT)
			GetGlobalContext()->GetContactDataObject()->sCertType = CA_CERT_TYPE_SELECT;
		else 
			GetGlobalContext()->GetContactDataObject()->sCertType = CA_CERT_TYPE_OTHER;

		do
		{
			//
			//Set the attributes required for creating PKCS10
			//
			SetCARequestAttributes();


			//
			//This function will call the CryptAcquireContext and import the LS Keys 
			//			
			if ( ( dwRetCode = GetCryptContextWithLSKeys (&hCryptProv )  )!= ERROR_SUCCESS )
			{
				break;
			}

			dwRetCode = CreateLSPKCS10(hCryptProv,AT_KEYEXCHANGE, &lpszExchgPKCS10);
			if(dwRetCode != ERROR_SUCCESS)
				break;

			dwRetCode = CreateLSPKCS10(hCryptProv,AT_SIGNATURE, &lpszSigPKCS10);
			if(dwRetCode != ERROR_SUCCESS)
				break;			

			// Release the context
			if(hCryptProv)
			{
				DoneWithCryptContextWithLSKeys ( hCryptProv );
			}  
		
			//
			//Certificate Type
			//
			//Convert from multibyte to unicode
			lpwszExchgPKCS10 = AnsiToUnicode(lpszExchgPKCS10);
			lpwszSignPKCS10 = AnsiToUnicode(lpszSigPKCS10);

			dwExchangeLen = lstrlen(lpwszExchgPKCS10) * sizeof(WCHAR);
			dwSignLen = lstrlen(lpwszSignPKCS10) * sizeof(WCHAR);

			certRequest.SetExchgPKCS10Length(dwExchangeLen);
			certRequest.SetSignPKCS10Length(dwSignLen);
			certRequest.SetDataLen(dwExchangeLen+dwSignLen);

			certRequest.SetServerName(m_lpstrLSName);

			//Allocate buffer for the request
			lpszReqData = (LPBYTE) LocalAlloc( GPTR, dwExchangeLen+dwSignLen+sizeof(certRequest) );
			if(lpszReqData == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}

			lpszNextCopyPos = lpszReqData;
			memcpy(lpszNextCopyPos, &certRequest, sizeof(certRequest));
			lpszNextCopyPos += sizeof(certRequest);

			memcpy ( lpszNextCopyPos, lpwszExchgPKCS10, dwExchangeLen);
			lpszNextCopyPos += dwExchangeLen;

			memcpy ( lpszNextCopyPos, lpwszSignPKCS10, dwSignLen);		



			dwRetCode = Dispatch(lpszReqData, dwExchangeLen+dwSignLen+sizeof(certRequest));
			if ( lpszReqData )
			{
				LocalFree(lpszReqData);
			}
			if (dwRetCode != ERROR_SUCCESS)
			{
				LRSetLastError(dwRetCode);
				break;
			}


			dwRetCode = FetchResponse((BYTE *) &certResponse, sizeof(NewCert_Response), &dwResponseLength);
			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}

			if (dwResponseLength != sizeof(NewCert_Response))
			{
				// Got an invalid response back
				dwRetCode = IDS_ERR_CHBAD_DATA;
				break;
			}

			switch(certResponse.RequestHeader.GetResponseType())
			{
			case Response_Success:
				dwRetCode = ERROR_SUCCESS;
				break;

			case Response_Failure:
				dwRetCode = IDS_ERR_CHFAILURE;
				break;

			case Response_InvalidData:
				dwRetCode = IDS_ERR_CHINVALID_DATA;
				break;

			case Response_NotYetImplemented:
				dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
				break;

			case Response_ServerError:
				dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
				break;

			case Response_Invalid_Response:
			default:
				dwRetCode = IDS_ERR_CHBAD_DATA;
				break;
			}

			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}

			dwRetCode = SetLRState(LRSTATE_ONLINE_CR_CREATED);

			/*
			lpszResData = (PBYTE) LocalAlloc(GPTR, certResponse.GetDataLen() + 1);
			if(lpszResData == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}

			dwRetCode = FetchResponse(lpszResData, certResponse.GetDataLen() + 1,
									  &dwResponseLength);
			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}
			if (dwResponseLength != certResponse.GetDataLen())
			{
				// Didn't get the expected number of Bytes, also a problem
				dwRetCode = IDS_ERR_CHBAD_DATA;
				break;
			}

			bToSendAck = true;


			dwExchgCertLen = certResponse.GetExchgPKCS7Length();
			dwSigCertLen = certResponse.GetSignPKCS7Length();
			dwRootCertLen = certResponse.GetRootCertLength();
			if(dwRootCertLen == 0 || dwExchgCertLen == 0 || dwSigCertLen == 0 )
			{
				dwRetCode = IDS_ERR_CHBAD_DATA; //IDS_ERR_INVALID_PIN;
				break;
			}

			//
			// Exchange Certificate
			//
			lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchgCertLen/sizeof(WCHAR));
			if ( lpszExchCert == NULL )
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}			
			
			//
			// Signature Certificate
			//
			lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchgCertLen), dwSigCertLen/sizeof(WCHAR));
			if(lpszSignCert == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}


			//
			// Root Certificate
			//
			lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchgCertLen+dwSigCertLen),
										dwRootCertLen/sizeof(WCHAR));
			if(lpszRootCert == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}

			dwRetCode = DepositLSSPK(certResponse.GetSPK());
			if (dwRetCode != ERROR_SUCCESS)
			{
				
				//if (dwRetCode == IDS_ERR_DEPOSITSPK)
				//{
				//	dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
				//}
				
					break;
			}

			//
			//Deposit the Certs
			//
			dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
												lstrlenA(lpszExchCert),
												(PBYTE)lpszSignCert,
												lstrlenA(lpszSignCert),
												(PBYTE)lpszRootCert,
												lstrlenA(lpszRootCert)
											  );
			if ( dwRetCode != ERROR_SUCCESS )
			{
				break;
			}

			//dwRetCode = SetLRState(LRSTATE_NEUTRAL);

			//if the response comming back is SUCCESS, check for certificates
			//in the response structure.  If there is response
			//perform the deposit LS Certificates routine
			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}


			//
			// Now save the State in the Registry
			//
			//dwRetCode = SetLRState(LRSTATE_ONLINE_CR_CREATED);
			*/
		}
		while(false);

	}
	catch(...)
	{
		dwRetCode = IDS_ERR_EXCEPTION;
	}

	CloseCHRequest();

	if (bToSendAck == true)
	{
		if (InitCHRequest() == ERROR_SUCCESS)
		{
			// Everything deposited OK
			// Time to send the Ack
			certackRequest.SetRegRequestId((BYTE *) certResponse.GetRegRequestId(),
									   (lstrlen(certResponse.GetRegRequestId())+1)*sizeof(TCHAR));
			certackRequest.SetAckType((dwRetCode == ERROR_SUCCESS));
			Dispatch((BYTE *) &certackRequest, sizeof(certackRequest));
			// Ignore the Return value --- So what if the Ack gets lost

			// Read the response
			FetchResponse((BYTE *) &certackResponse, sizeof(certackResponse),
								  &dwResponseLength);
			// Ignore the Return value --- So what if the Ack gets lost
			CloseCHRequest();
		}
	}

	//
	//Free up Mem
	//

	ClearCARequestAttributes();

	if(lpszExchgPKCS10)
	{
		delete lpszExchgPKCS10;
	}

	if(lpszSigPKCS10)
	{
		delete lpszSigPKCS10;
	}

	if ( lpwszExchgPKCS10 )
	{
		delete lpwszExchgPKCS10;
	}

	if (lpwszSignPKCS10)
	{
		delete lpwszSignPKCS10;
	}

	if ( lpszExchCert )
	{
		delete lpszExchCert;
	}

	if ( lpszSignCert )
	{
		delete lpszSignCert;
	}

	if ( lpszRootCert )
	{
		delete lpszRootCert;
	}

	if (lpszResData)
	{
		LocalFree(lpszResData);
	}

	return dwRetCode;
}





DWORD CGlobal::ProcessCertDownload()
{
	DWORD dwRetCode = ERROR_SUCCESS;

	CertificateDownload_Request  certdownloadRequest;
	CertificateDownload_Response certdownloadResponse;
	Certificate_AckRequest certackRequest;
	Certificate_AckResponse	certackResponse;

	PBYTE lpszResData	= NULL;

	DWORD  dwExchgCertLen	= 0;
	DWORD  dwSigCertLen		= 0;
	DWORD  dwRootCertLen	= 0;

	LPSTR	lpszExchCert = NULL;
	LPSTR	lpszSignCert = NULL;
	LPSTR	lpszRootCert = NULL;
	DWORD   dwResponseLength;
	bool bToSendAck = false;
	
	//
	// Set the Language Id
	//
	certdownloadRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		return dwRetCode;
	}

	try
	{
		do
		{
			//
			// Create CHRequest for Certificate Download
			//
			certdownloadRequest.SetPIN((BYTE *) m_lpstrPIN, (lstrlenW(m_lpstrPIN)+1) * sizeof(WCHAR));

			dwRetCode = Dispatch((BYTE *) &certdownloadRequest, sizeof(CertificateDownload_Request));
			if(dwRetCode != ERROR_SUCCESS)
			{
				LRSetLastError(dwRetCode);
				break;
			}

			// Let us first Fetch the certdownloadResponse
			dwRetCode = FetchResponse((BYTE *) &certdownloadResponse,
									  sizeof(CertificateDownload_Response), &dwResponseLength);
			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}
			if (dwResponseLength != sizeof(CertificateDownload_Response))
			{
				// Didn't get the expected number of Bytes, also a problem
				dwRetCode = IDS_ERR_CHBAD_DATA;
				break;
			}
			switch(certdownloadResponse.RequestHeader.GetResponseType())
			{
			case Response_Success:
				dwRetCode = ERROR_SUCCESS;
				break;

			case Response_Failure:
//				dwRetCode = IDS_ERR_CHFAILURE;
				//dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
				dwRetCode = IDS_ERR_INVALID_PIN;
				break;

			case Response_InvalidData:
				dwRetCode = IDS_ERR_CHINVALID_DATA;
				break;

			case Response_NotYetImplemented:
				dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
				break;

			case Response_ServerError:
				dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
				break;

			case Response_Invalid_Response:
			default:
				dwRetCode = IDS_ERR_CHBAD_DATA;
				break;
			}

			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}


			// OK, allocate enough memory to read the rest fo the data
			lpszResData = (PBYTE) LocalAlloc(GPTR, certdownloadResponse.GetDataLen() + 1);
			if(lpszResData == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}

			dwRetCode = FetchResponse(lpszResData, certdownloadResponse.GetDataLen() + 1,
									  &dwResponseLength);
			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}
			if (dwResponseLength != certdownloadResponse.GetDataLen())
			{
				// Didn't get the expected number of Bytes, also a problem
				dwRetCode = IDS_ERR_CHBAD_DATA;
				break;
			}

			bToSendAck = true;

			dwExchgCertLen = certdownloadResponse.GetExchgPKCS7Length();
			dwSigCertLen = certdownloadResponse.GetSignPKCS7Length();
			dwRootCertLen = certdownloadResponse.GetRootCertLength();
			if(dwRootCertLen == 0 || dwExchgCertLen == 0 || dwSigCertLen == 0 )
			{
				dwRetCode = IDS_ERR_INVALID_PIN;
				break;
			}

			//
			// Exchange Certificate
			//
			lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchgCertLen/sizeof(WCHAR));
			if ( lpszExchCert == NULL )
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}			
			
			//
			// Signature Certificate
			//
			lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchgCertLen), dwSigCertLen/sizeof(WCHAR));
			if(lpszSignCert == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}


			//
			// Root Certificate
			//
			lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchgCertLen+dwSigCertLen),
										dwRootCertLen/sizeof(WCHAR));
			if(lpszRootCert == NULL)
			{
				dwRetCode = IDS_ERR_OUTOFMEM;
				break;
			}

			dwRetCode = SetLSSPK(certdownloadResponse.GetSPK());
			if (dwRetCode != ERROR_SUCCESS)
			{
				break;
			}


			dwRetCode = DepositLSSPK();
			if (dwRetCode != ERROR_SUCCESS)
			{
				if (dwRetCode == IDS_ERR_DEPOSITSPK)
				{
					dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
				}
				break;
			}


			//
			//Deposit the Certs
			//
			dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
												lstrlenA(lpszExchCert),
												(PBYTE)lpszSignCert,
												lstrlenA(lpszSignCert),
												(PBYTE)lpszRootCert,
												lstrlenA(lpszRootCert)
											  );
			if ( dwRetCode != ERROR_SUCCESS )
			{
				// If this happened and the SPK deposit succeeded, we have an 
				// inconsistent state, now
				DWORD dwReturn;
				DWORD dwOriginal = LRGetLastError();

				dwReturn = ResetLSSPK(FALSE);
				if (dwReturn != ERROR_SUCCESS)
				{
					// what to do, if even this failed.  OUCH OUCH
					dwRetCode = dwReturn;
				}
				LRSetLastError(dwOriginal);
				m_pRegistrationID[ 0] = 0;
				break;
			}
			else
			{
				dwRetCode = SetLRState(LRSTATE_NEUTRAL);
			}

		}
		while(false);
	}
	catch(...)
	{
		dwRetCode = IDS_ERR_EXCEPTION;
	}

	CloseCHRequest();


	// Now to send the Ack
	if (bToSendAck == true)
	{
		if (InitCHRequest() == ERROR_SUCCESS)
		{
			// Everything deposited OK
			// Time to send the Ack
			certackRequest.SetRegRequestId((BYTE *) certdownloadResponse.GetRegRequestId(),
									   (lstrlen(certdownloadResponse.GetRegRequestId())+1)*sizeof(TCHAR));
			certackRequest.SetAckType((dwRetCode == ERROR_SUCCESS));
			Dispatch((BYTE *) &certackRequest, sizeof(certackRequest));
			// Ignore the Return value --- So what if the Ack gets lost

			// Read the response
			FetchResponse((BYTE *) &certackResponse, sizeof(certackResponse),
								  &dwResponseLength);
			// Ignore the Return value --- So what if the Ack gets lost
			CloseCHRequest();
		}
	}
	
	if ( lpszExchCert )
	{
		delete lpszExchCert;
	}

	if ( lpszSignCert )
	{
		delete lpszSignCert;
	}

	if ( lpszRootCert )
	{
		delete lpszRootCert;
	}

	if (lpszResData)
	{
		LocalFree(lpszResData);
	}


	return dwRetCode;
}







DWORD CGlobal::AuthenticateLS()
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	DWORD		dwResponseLength;
	BYTE *		lpszReqData = NULL;
	BYTE *		lpszResData = NULL;
	Validate_Response  valResponse;
	Validate_Request   valRequest;


	if (GetLSStatus() == LSERVERSTATUS_REGISTER_OTHER)
	{
		DWORD dwStatus;
		// This LS was registered on the phone.  First perform SignOnly, Then read the certs into memory
		dwRetCode = ProcessCASignOnlyRequest();
		if (dwRetCode != ERROR_SUCCESS)
		{
			goto done;
		}

		dwRetCode = GetLSCertificates(&dwStatus);
		if (dwRetCode != ERROR_SUCCESS)
		{
			goto done;
		}

		assert(dwStatus == LSERVERSTATUS_REGISTER_INTERNET);
	}
	

	//
	// Set Language Id
	//
	valRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	lpszReqData = (PBYTE) LocalAlloc(GPTR, sizeof(Validate_Request)+m_dwExchangeCertificateLen);
	if(lpszReqData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}
	valRequest.SetDataLen(m_dwExchangeCertificateLen);
	valRequest.SetCertBlobLen(m_dwExchangeCertificateLen);
	valRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));

	memcpy(lpszReqData, &valRequest, sizeof(Validate_Request));
	memcpy(lpszReqData+sizeof(Validate_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen);

	dwRetCode = Dispatch(lpszReqData, sizeof(Validate_Request)+m_dwExchangeCertificateLen);
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}

	// Let us read the response
	dwRetCode = FetchResponse((BYTE *) &valResponse, sizeof(Validate_Response),
							  &dwResponseLength);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	if (dwResponseLength != sizeof(Validate_Response))
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

//	if (valResponse.m_dwRetCode != ERROR_SUCCESS)
//	{
//		dwRetCode = valResponse.m_dwRetCode;
//		goto done;
//	}
	switch(valResponse.RequestHeader.GetResponseType())
	{
	case Response_Success:
		dwRetCode = ERROR_SUCCESS;
		break;

	case Response_Failure:
//		dwRetCode = IDS_ERR_CHFAILURE;
		dwRetCode = IDS_ERR_AUTH_FAILED;
		break;

	case Response_Reg_Bad_SPK:
		dwRetCode = IDS_ERR_SPKBAD;
		break;

	case Response_Reg_Bad_Cert:
		dwRetCode = IDS_ERR_CERTBAD;
		break;

	case Response_Reg_Expired:
		dwRetCode = IDS_ERR_CERTEXPIRED;
		break;

	case Response_Reg_Revoked:
		dwRetCode = IDS_ERR_CERTREVOKED;
		break;

	case Response_InvalidData:
		dwRetCode = IDS_ERR_CHINVALID_DATA;
		break;

	case Response_NotYetImplemented:
		dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
		break;

	case Response_ServerError:
		dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
		break;

	case Response_Invalid_Response:
	default:
		dwRetCode = IDS_ERR_CHBAD_DATA;
		break;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}


	// OK, allocate enough memory to read the rest fo the data
	lpszResData = (PBYTE) LocalAlloc(GPTR, valResponse.GetDataLen() + 1);
	if(lpszResData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}


	dwRetCode = FetchResponse(lpszResData, valResponse.GetDataLen() + 1,
									  &dwResponseLength);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLength != valResponse.GetDataLen())
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	dwRetCode = SetCHCert ( REG_ROOT_CERT,
							lpszResData, 
							valResponse.GetCHRootCertLen());
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = SetCHCert ( REG_EXCHG_CERT,
							lpszResData+valResponse.GetCHRootCertLen(),
							valResponse.GetCHExchCertLen() );
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	dwRetCode = SetCHCert ( REG_SIGN_CERT,
							lpszResData+valResponse.GetCHRootCertLen()+valResponse.GetCHExchCertLen(),
							valResponse.GetCHSignCertLen() );

done:
	CloseCHRequest();

	if (lpszReqData)
	{
		LocalFree(lpszReqData);
	}

	if (lpszResData)
	{
		LocalFree(lpszResData);
	}


	return dwRetCode;
}





DWORD CGlobal::ProcessDownloadLKP()
{
	DWORD dwRetCode = ERROR_SUCCESS;
	NewLKP_Request			lkpRequest;
	NewLKP_Response			lkpResponse;
	NewLKP_AckRequest		lkpAckRequest;
	NewLKP_AckResponse		lkpAckResponse;
	PBYTE  pbLKPRequest	= NULL;
	PBYTE  lpszResData = NULL;
	DWORD  dwReqLen	= 0;
	DWORD  dwResponseLen;
	bool bToSendAck = false;

	//
	// Set Language ID
	//
	lkpRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//
	// Set LKP Request Attributes
	//
	SetCHRequestAttributes();
	lkpRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));

	//
	// Create LKP Request
	//
	dwRetCode = CreateLKPRequest(&pbLKPRequest, &lkpRequest, dwReqLen);
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = Dispatch(pbLKPRequest, dwReqLen);
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}


	// Let us first Fetch the certdownloadResponse
	dwRetCode = FetchResponse((BYTE *) &lkpResponse,
							  sizeof(NewLKP_Response), &dwResponseLen);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLen != sizeof(NewLKP_Response))
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	bToSendAck = true;

	// OK, allocate enough memory to read the rest fo the data
	lpszResData = (PBYTE) LocalAlloc(GPTR, lkpResponse.GetDataLen() + 1);
	if(lpszResData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	dwRetCode = FetchResponse(lpszResData, lkpResponse.GetDataLen() + 1,
							  &dwResponseLen);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	if (dwResponseLen != lkpResponse.GetDataLen())
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	switch(lkpResponse.RequestHeader.GetResponseType())
	{
	case Response_Success:
		dwRetCode = ERROR_SUCCESS;
		break;

	case Response_Failure:
		dwRetCode = IDS_ERR_CHFAILURE;
		break;

	case Response_SelectMloLicense_NotValid:
		dwRetCode = IDS_ERR_INVALID_PROGINFO;
		break;

	case Response_InvalidData:
		if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_RETAIL)
		{
			// For retail, if all the LKP were not approved, show the list
			// to the user
			for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
			{
				m_listRetailSPK[ i].tcStatus = lkpResponse.m_dwRetailSPKStatus[ i];
			}
			bToSendAck = false;
			dwRetCode = IDS_ERR_SPKERRORS;
		}
		else
		{
			dwRetCode = IDS_ERR_CHINVALID_DATA;
		}
		break;

	case Response_NotYetImplemented:
		dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
		break;

	case Response_ServerError:
		dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
		break;

	case Response_Invalid_Response:
	default:
		dwRetCode = IDS_ERR_CHBAD_DATA;
		break;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	dwRetCode = DepositLKPResponse(lpszResData, lkpResponse.GetLKPLength());			


	if (dwRetCode == ERROR_SUCCESS &&
	    GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_RETAIL)
	{
		InitSPKList();
	}
	

done:

	ClearCHRequestAttributes();

	CloseCHRequest();

	// Now to send the Ack
	if (bToSendAck == true)
	{
		if (InitCHRequest() == ERROR_SUCCESS)
		{
			// Everything deposited OK
			// Time to send the Ack
			lkpAckRequest.SetRegRequestId((BYTE *) lkpResponse.GetRegRequestId(),
									   (lstrlen(lkpResponse.GetRegRequestId())+1)*sizeof(TCHAR));
			lkpAckRequest.SetLicenseReqId((BYTE *) lkpResponse.GetLicenseReqId(),
									   (lstrlen(lkpResponse.GetLicenseReqId())+1)*sizeof(TCHAR));
			lkpAckRequest.SetAckType((dwRetCode == ERROR_SUCCESS));
			Dispatch((BYTE *) &lkpAckRequest, sizeof(NewLKP_AckRequest));
			// Ignore the Return value --- So what if the Ack gets lost

			// Read the response
			FetchResponse((BYTE *) &lkpAckResponse, sizeof(NewLKP_AckResponse),
								  &dwResponseLen);
			// Ignore the Return value --- So what if the Ack gets lost
			CloseCHRequest();
		}
	}

	if ( pbLKPRequest ) 
	{
		free(pbLKPRequest);
	}

	if (lpszResData)
	{
		LocalFree(lpszResData);
	}


	return dwRetCode;
}



DWORD CGlobal::CreateLKPRequest(PBYTE *  ppRequest, NewLKP_Request * nlkppRequest,
								DWORD &dwDataLen)
{
	DWORD			dwRetCode = ERROR_SUCCESS;
	STREAM_HDR		aStreamHdr;
	BLOCK_HDR		aBlkHdr;		

	DWORD			dwBufSize	= 0;
	BYTE *			pBuf		= NULL;

	PBYTE			pbCHCert = NULL;
	DWORD			dwCHCert = 0;

	PBYTE			pbEncryptedBuf = NULL;

	PBYTE			pbEncodedBlob = NULL;
	DWORD			dwEncodedBlob = 0;	
	DWORD			dwBufLen = 0;
	DWORD			i =0;

	dwDataLen = 0;

	//DWORD dwDecodeLen = 0;
	//PBYTE pbDecode = NULL;
	
	HANDLE	hFile		 = INVALID_HANDLE_VALUE;
	DWORD	dwRetSize	= 0;

	//
	//Create the stream header
	//
	_tcscpy ( aStreamHdr.m_szTitle, STREAM_HDR_TITLE );
	aStreamHdr.SetHeader(STREAM_HDR_TYPE);
	aStreamHdr.SetItemCount(0);

	dwBufSize = sizeof(STREAM_HDR);

	if ( ( pBuf = (BYTE *)malloc ( dwBufSize ) ) )
	{
		memcpy ( pBuf, &aStreamHdr, dwBufSize );
	}
	else
	{
		dwRetCode = IDS_ERR_OUTOFMEM;		
		goto done;
	}

	for ( i = 0; i < m_dwRegAttrCount; i++ )		
	{
		//Setup the header here - put name/value pair into a data buffer
		aBlkHdr.m_wType = BLOCK_TYPE_PROP_PAIR;
		aBlkHdr.SetNameSize(lstrlenW( ( m_pRegAttr + i)->lpszAttribute ) * sizeof(WCHAR) );
		aBlkHdr.SetValueSize(( m_pRegAttr + i)->dwValueLen );	
		
		if ( ( pBuf = (BYTE *)realloc (pBuf, dwBufSize + sizeof(BLOCK_HDR) + aBlkHdr.GetNameSize() + aBlkHdr.GetValueSize()) ) ) 
		{
			memcpy ( pBuf + dwBufSize, &aBlkHdr, sizeof ( BLOCK_HDR ) );
			memcpy ( pBuf + dwBufSize + sizeof(BLOCK_HDR) , ( m_pRegAttr + i)->lpszAttribute , aBlkHdr.GetNameSize());
			memcpy ( pBuf + dwBufSize + sizeof (BLOCK_HDR ) +  aBlkHdr.GetNameSize() , ( m_pRegAttr + i)->lpszValue , aBlkHdr.GetValueSize() );

			dwBufSize += sizeof(BLOCK_HDR) + aBlkHdr.GetNameSize()+ aBlkHdr.GetValueSize();

			((STREAM_HDR*)pBuf)->SetItemCount(((STREAM_HDR*)pBuf)->GetItemCount() + 1 ); 
		}
		else
		{
			dwRetCode = IDS_ERR_OUTOFMEM;			
			goto done;
		}
	}

/*
	Since the channel is secure , we need not encrypt the LKP Request.

	//Encrypt using the public key of the CH Cert.
	dwRetCode = GetCHCert( REG_EXCHG_CERT , &pbCHCert, &dwCHCert );
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	
	dwRetCode =  EncryptBuffer ( pBuf,			//Buffer to be encrypted
								 dwBufSize,				//buffer length
								 CRYPT_MACHINE_KEYSET,	//machine/user
								 pbCHCert,				//certificate blob
								 dwCHCert,				//number of bytes in the certificate
								 &dwDataLen,		//number of bytes in the encrypted blob										
								 &pbEncryptedBuf		//encrypted blob itself
								);	

	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
*/
	dwBufLen = 	dwBufSize + m_dwExchangeCertificateLen; //dwDataLen + m_dwExchangeCertificateLen;

	// Also need to allocate the extra memory to hold the retail stuff
	if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_RETAIL)
	{
		dwBufLen += (m_dwRetailSPKEntered*LR_RETAILSPK_LEN*sizeof(TCHAR));
	}

	nlkppRequest->RequestHeader.SetLanguageId(GetLSLangId());
	nlkppRequest->SetDataLen(dwBufLen);
	nlkppRequest->SetNewLKPRequestLen(dwBufSize); //(dwDataLen);
	nlkppRequest->SetCertBlobLen(m_dwExchangeCertificateLen);
	nlkppRequest->SetRetailSPKCount(m_dwRetailSPKEntered);

	*ppRequest = (PBYTE) malloc ( dwBufLen + sizeof(NewLKP_Request));
	if ( NULL == *ppRequest )
	{
		dwRetCode = IDS_ERR_OUTOFMEM;			
		goto done;
	}
	memset ( *ppRequest, 0, dwBufLen + sizeof(NewLKP_Request));
	memcpy((*ppRequest), nlkppRequest, sizeof(NewLKP_Request));
	memcpy ( ( *ppRequest )+sizeof(NewLKP_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen );
	//memcpy ( ( *ppRequest )+sizeof(NewLKP_Request)+m_dwExchangeCertificateLen, pbEncryptedBuf, dwDataLen);
	memcpy ( ( *ppRequest )+sizeof(NewLKP_Request)+m_dwExchangeCertificateLen, pBuf, dwBufSize);
	
	if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_RETAIL)
	{
		PBYTE pbCur = (*ppRequest)+sizeof(NewLKP_Request)+m_dwExchangeCertificateLen+dwBufSize; //dwDataLen;
		for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
		{
			memcpy(pbCur, m_listRetailSPK[ i].lpszSPK, LR_RETAILSPK_LEN*sizeof(TCHAR));
			pbCur += LR_RETAILSPK_LEN*sizeof(TCHAR);
		}

		//dwDataLen += (m_dwRetailSPKEntered*LR_RETAILSPK_LEN*sizeof(TCHAR));

	}

	//dwDataLen += (sizeof(NewLKP_Request) + m_dwExchangeCertificateLen);
	dwDataLen = sizeof(NewLKP_Request) + dwBufLen;

done:
	if ( pbEncryptedBuf )
	{
		LocalFree(pbEncryptedBuf);
	}

	if ( pBuf )
	{
		free ( pBuf );
	}

	if ( dwRetCode != ERROR_SUCCESS )
	{
		if (*ppRequest != NULL)
		{
			free ( *ppRequest );
		}
		dwBufLen = 0;
		*ppRequest = NULL;
	}

	return dwRetCode;
}




DWORD CGlobal::SetConfirmationNumber(TCHAR * tcConf)
{
	DWORD dwRetCode = ERROR_SUCCESS;

	if (wcsspn(tcConf, BASE24_CHARACTERS) != LR_CONFIRMATION_LEN)
	{
		// Extraneous characters in the SPK string
		dwRetCode = IDS_ERR_INVALID_CONFIRMATION_NUMBER;
	} 
	else if (LKPLiteValConfNumber(m_pRegistrationID, m_pLicenseServerID, tcConf) 
															!= ERROR_SUCCESS)
	{
		dwRetCode = IDS_ERR_INVALID_CONFIRMATION_NUMBER;
	}

	return dwRetCode;
}




DWORD CGlobal::InitSPKList(void)
{
	for (register int i = 0; i < MAX_RETAILSPKS_IN_BATCH; i++)
	{
		m_listRetailSPK[ i].lpszSPK[ 0] = 0;
		m_listRetailSPK[ i].tcStatus = RETAIL_SPK_NULL;
	}

	m_dwRetailSPKEntered = 0;

	return ERROR_SUCCESS;
}



void CGlobal::DeleteRetailSPKFromList(TCHAR * lpszRetailSPK)
{
	bool bFound = false;

	for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
	{
		if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
		{
			if (i < MAX_RETAILSPKS_IN_BATCH-1)
			{
				memcpy(m_listRetailSPK + i, 
					   m_listRetailSPK + i + 1,
					   sizeof(RETAILSPK)*(MAX_RETAILSPKS_IN_BATCH-i));
			}
			m_listRetailSPK[ MAX_RETAILSPKS_IN_BATCH-1].lpszSPK[ 0] = 0;
			m_listRetailSPK[ MAX_RETAILSPKS_IN_BATCH-1].tcStatus = RETAIL_SPK_NULL;
			bFound = true;
			m_dwRetailSPKEntered--;
			break;
		}
	}
	assert(bFound == true);

	return;
}

void CGlobal::ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK)
{
	bool bFound = false;

	for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
	{
		if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszOldSPK) == 0)
		{
			if (i < MAX_RETAILSPKS_IN_BATCH-1)
			{
				_tcscpy(m_listRetailSPK[i].lpszSPK,lpszNewSPK);
				m_listRetailSPK[i].tcStatus = RETAIL_SPK_NULL;
			}		
			
			bFound = true;			
			break;
		}
	}
	assert(bFound == true);

	return;
}


void CGlobal::LoadFromList(HWND hListView)
{

	for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
	{
		InsertIntoSPKDisplayList(hListView,
								 m_listRetailSPK[ i].lpszSPK,
								 m_listRetailSPK[ i].tcStatus);
	}

	return;
}



void CGlobal::UpdateSPKStatus(TCHAR * lpszRetailSPK,
							  TCHAR tcStatus)
{
	bool bFound = false;

	for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
	{
		if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
		{
			m_listRetailSPK[ i].tcStatus = tcStatus;
			bFound = true;
			break;
		}
	}

	assert(bFound == true);

	return;
}




void CGlobal::InsertIntoSPKDisplayList(HWND hListView,
							  TCHAR * lpszRetailSPK,
							  TCHAR tcStatus)
{
	LVITEM	lvItem;
	TCHAR   lpszBuffer[ 128];
	DWORD	dwStringToLoad = IDS_RETAILSPKSTATUS_UNKNOWN;
	DWORD   nItem;

	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = 0;
	lvItem.iSubItem = 0;
	lvItem.pszText = lpszRetailSPK;
	lvItem.cchTextMax = lstrlen(lpszRetailSPK);
	nItem = ListView_InsertItem(hListView, &lvItem);

	lvItem.iSubItem = 1;
	lvItem.iItem = nItem;

	switch(tcStatus)
	{
	case RETAIL_SPK_NULL:
		dwStringToLoad = IDS_RETAILSPKSTATUS_PENDING;
		break;

	case RETAIL_SPK_OK:
		dwStringToLoad = IDS_RETAILSPKSTATUS_OK;
		break;

	case RETAIL_SPK_INVALID_SIGNATURE:
		dwStringToLoad = IDS_RETAILSPKSTATUS_INVALID_SIGNATURE;
		break;

	case RETAIL_SPK_INVALID_PRODUCT_TYPE:
		dwStringToLoad = IDS_RETAILSPKSTATUS_INVALID_PRODUCT_TYPE;
		break;

	case RETAIL_SPK_INVALID_SERIAL_NUMBER:
		dwStringToLoad = IDS_RETAILSPKSTATUS_INVALID_SERIAL_NUMBER;
		break;

	case RETAIL_SPK_ALREADY_REGISTERED:
		dwStringToLoad = IDS_RETAILSPKSTATUS_ALREADY_REGISTERED;
		break;
	}

	LoadString(GetInstanceHandle(), dwStringToLoad, lpszBuffer, sizeof(lpszBuffer)/sizeof(TCHAR));

	lvItem.pszText = lpszBuffer;
	lvItem.cchTextMax = lstrlen(lpszBuffer);

	ListView_SetItem(hListView, &lvItem);

	return;
}





DWORD CGlobal::AddRetailSPKToList(HWND hListView,
								  TCHAR * lpszRetailSPK)
{
	if (m_dwRetailSPKEntered == MAX_RETAILSPKS_IN_BATCH)
	{
		return IDS_ERR_TOOMANYSPK;
	}

	assert(m_listRetailSPK[ m_dwRetailSPKEntered].lpszSPK[ 0] == 0);
	assert(m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus == RETAIL_SPK_NULL);

	DWORD dwRetCode = ERROR_SUCCESS;
	if (_tcsspn(lpszRetailSPK, BASE24_CHARACTERS) != LR_RETAILSPK_LEN)
	{
		// Extraneous characters in the SPK string
		dwRetCode = IDS_ERR_INVALIDSPK;
	}

	// Now check for duplication
	for (register unsigned int i = 0; dwRetCode == ERROR_SUCCESS && i < m_dwRetailSPKEntered; i++)
	{
		if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
		{
			dwRetCode = IDS_ERR_DUPLICATESPK;
		}
	}


	if (dwRetCode == ERROR_SUCCESS)
	{
		lstrcpy(m_listRetailSPK[ m_dwRetailSPKEntered].lpszSPK, lpszRetailSPK);
		m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus = RETAIL_SPK_NULL;

		InsertIntoSPKDisplayList(hListView, 
								 lpszRetailSPK,
								 m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus);
		m_dwRetailSPKEntered++;
	}


	return dwRetCode;
}


DWORD CGlobal::ValidateRetailSPK(TCHAR * lpszRetailSPK)
{
	DWORD dwRetCode = ERROR_SUCCESS;

	if (_tcsspn(lpszRetailSPK, BASE24_CHARACTERS) != LR_RETAILSPK_LEN)
	{
		// Extraneous characters in the SPK string
		dwRetCode = IDS_ERR_INVALIDSPK;
	}

	// Now check for duplication
	for (register unsigned int i = 0; dwRetCode == ERROR_SUCCESS && i < m_dwRetailSPKEntered; i++)
	{
		if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
		{
			dwRetCode = IDS_ERR_DUPLICATESPK;
		}
	}

	return dwRetCode;
}

DWORD CGlobal::ProcessCASignOnlyRequest()
{
	DWORD dwRetCode = ERROR_SUCCESS;
	CertificateSignOnly_Request certsoRequest;
	CertificateSignOnly_Response certsoResponse;

	HCRYPTPROV	hCryptProv	 = NULL;
	LPWSTR	lpwszExchgPKCS10 = NULL;
	LPWSTR	lpwszSignPKCS10  = NULL;
	LPBYTE	lpszReqData		 = NULL;
	LPBYTE	lpszResData		 = NULL;
	LPBYTE	lpszNextCopyPos	 = NULL;
	LPSTR	lpszExchgPKCS10	 = NULL;
	LPSTR	lpszSigPKCS10	 = NULL;
	DWORD   dwExchangeLen = 0;
	DWORD   dwSignLen = 0;
	DWORD	dwRootLen = 0;
	DWORD   dwResponseLength = 0;
	LPSTR	lpszExchCert = NULL;
	LPSTR	lpszSignCert = NULL;
	LPSTR	lpszRootCert = NULL;

	//
	// Set Language Id
	//
	certsoRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		return dwRetCode;
	}

	SetCARequestAttributes();


	//
	//This function will call the CryptAcquireContext and import the LS Keys 
	//			
	if ( ( dwRetCode = GetCryptContextWithLSKeys (&hCryptProv )  )!= ERROR_SUCCESS )
	{
		goto done;
	}

	dwRetCode = CreateLSPKCS10(hCryptProv,AT_KEYEXCHANGE, &lpszExchgPKCS10);
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = CreateLSPKCS10(hCryptProv,AT_SIGNATURE, &lpszSigPKCS10);
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Release the context
	if(hCryptProv)
	{
		DoneWithCryptContextWithLSKeys ( hCryptProv );
	}  
		
	//
	//Certificate Type
	//
	//Convert from multibyte to unicode
	lpwszExchgPKCS10 = AnsiToUnicode(lpszExchgPKCS10);
	lpwszSignPKCS10 = AnsiToUnicode(lpszSigPKCS10);

	dwExchangeLen = lstrlen(lpwszExchgPKCS10) * sizeof(WCHAR);
	dwSignLen = lstrlen(lpwszSignPKCS10) * sizeof(WCHAR);

	certsoRequest.SetExchgPKCS10Length(dwExchangeLen);
	certsoRequest.SetSignPKCS10Length(dwSignLen);
	certsoRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
	certsoRequest.SetDataLen(dwExchangeLen+dwSignLen);
   
	certsoRequest.SetServerName(m_lpstrLSName);

	//Allocate buffer for the request
	lpszReqData = (LPBYTE) LocalAlloc( GPTR, dwExchangeLen+dwSignLen+sizeof(certsoRequest) );
	if(lpszReqData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	lpszNextCopyPos = lpszReqData;
	memcpy(lpszNextCopyPos, &certsoRequest, sizeof(certsoRequest));
	lpszNextCopyPos += sizeof(certsoRequest);

	memcpy ( lpszNextCopyPos, lpwszExchgPKCS10, dwExchangeLen);
	lpszNextCopyPos += dwExchangeLen;

	memcpy ( lpszNextCopyPos, lpwszSignPKCS10, dwSignLen);		

	dwRetCode = Dispatch(lpszReqData, dwExchangeLen+dwSignLen+sizeof(certsoRequest));
	if ( lpszReqData )
	{
		LocalFree(lpszReqData);
	}
	if (dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}


	dwRetCode = FetchResponse((BYTE *) &certsoResponse, 
							  sizeof(CertificateSignOnly_Response),
							  &dwResponseLength);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLength != sizeof(CertificateSignOnly_Response))
	{
		// Got an invalid response back
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	switch(certsoResponse.RequestHeader.GetResponseType())
	{
	case Response_Success:
		dwRetCode = ERROR_SUCCESS;
		break;

	case Response_Failure:
//		dwRetCode = IDS_ERR_CHFAILURE;
		dwRetCode = IDS_ERR_AUTH_FAILED;
		break;

	case Response_Reg_Bad_SPK:
		dwRetCode = IDS_ERR_SPKBAD;
		break;

	case Response_Reg_Expired:
		dwRetCode = IDS_ERR_CERTEXPIRED;
		break;

	case Response_Reg_Revoked:
		dwRetCode = IDS_ERR_CERTREVOKED;
		break;

	case Response_InvalidData:
		dwRetCode = IDS_ERR_CHINVALID_DATA;
		break;

	case Response_NotYetImplemented:
		dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
		break;

	case Response_ServerError:
		dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
		break;

	case Response_Invalid_Response:
	default:
		dwRetCode = IDS_ERR_CHBAD_DATA;
		break;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}


	// OK, allocate enough memory to read the rest fo the data
	lpszResData = (PBYTE) LocalAlloc(GPTR, certsoResponse.GetDataLen() + 1);
	if(lpszResData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	dwRetCode = FetchResponse(lpszResData, certsoResponse.GetDataLen() + 1,
							  &dwResponseLength);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLength != certsoResponse.GetDataLen() ||
		dwResponseLength <= 0)
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	dwExchangeLen = certsoResponse.GetExchgPKCS7Length();
	dwSignLen = certsoResponse.GetSignPKCS7Length();
	dwRootLen = certsoResponse.GetRootCertLength();
	if(dwRootLen == 0 || dwExchangeLen == 0 || dwSignLen == 0 )
	{
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	//
	// Exchange Certificate
	//
	lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchangeLen/sizeof(WCHAR));
	if ( lpszExchCert == NULL )
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}			
	
	//
	// Signature Certificate
	//
	lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchangeLen), dwSignLen/sizeof(WCHAR));
	if(lpszSignCert == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}


	//
	// Root Certificate
	//
	lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchangeLen+dwSignLen),
								dwRootLen/sizeof(WCHAR));
	if(lpszRootCert == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	//
	//Deposit the Certs
	//
	dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
										lstrlenA(lpszExchCert),
										(PBYTE)lpszSignCert,
										lstrlenA(lpszSignCert),
										(PBYTE)lpszRootCert,
										lstrlenA(lpszRootCert)
									  );
	if ( dwRetCode != ERROR_SUCCESS )
	{
		goto done;
	}


done:

	ClearCARequestAttributes();

	CloseCHRequest();
	//
	//Free up Certificate Mem
	//
	if(lpszExchgPKCS10)
	{
		delete lpszExchgPKCS10;
	}

	if(lpszSigPKCS10)
	{
		delete lpszSigPKCS10;
	}

	if ( lpwszExchgPKCS10 )
	{
		delete lpwszExchgPKCS10;
	}

	if (lpwszSignPKCS10)
	{
		delete lpwszSignPKCS10;
	}


	if ( lpszExchCert )
	{
		delete lpszExchCert;
	}

	if ( lpszSignCert )
	{
		delete lpszSignCert;
	}

	if ( lpszRootCert )
	{
		delete lpszRootCert;
	}

	if (lpszResData)
	{
		LocalFree(lpszResData);
	}

	return dwRetCode;
}







DWORD CGlobal::ProcessCHReissueLKPRequest()
{
	DWORD dwRetCode = ERROR_SUCCESS;
	ReissueLKP_Request	lkpRequest;
	ReissueLKP_Response	lkpResponse;
	PBYTE	lpszReqData = NULL;
	PBYTE	lpszResData = NULL;
	DWORD  dwResponseLen;

	//
	// Set Language Id
	//
	lkpRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	//
	// Set LKP Request Attributes
	//
	lkpRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
	lkpRequest.SetCertBlobLen(m_dwExchangeCertificateLen);
	lkpRequest.SetDataLen(m_dwExchangeCertificateLen);


	// OK, allocate enough memory to read the rest fo the data
	lpszReqData = (PBYTE) LocalAlloc(GPTR, sizeof(ReissueLKP_Request)+m_dwExchangeCertificateLen);
	if(lpszReqData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	memcpy(lpszReqData, &lkpRequest, sizeof(ReissueLKP_Request));
	memcpy(lpszReqData+sizeof(ReissueLKP_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen );

	dwRetCode = Dispatch(lpszReqData, sizeof(ReissueLKP_Request)+m_dwExchangeCertificateLen);
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}


	// Let us first Fetch the certdownloadResponse
	dwRetCode = FetchResponse((BYTE *) &lkpResponse,
							  sizeof(ReissueLKP_Response), &dwResponseLen);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLen != sizeof(ReissueLKP_Response))
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	switch(lkpResponse.RequestHeader.GetResponseType())
	{
	case Response_Success:
		dwRetCode = ERROR_SUCCESS;
		break;

	case Response_Failure:
		dwRetCode = IDS_ERR_CHFAILURE;
		break;

	case Response_InvalidData:
		dwRetCode = IDS_ERR_CHINVALID_DATA;
		break;

	case Response_NotYetImplemented:
		dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
		break;

	case Response_ServerError:
		dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
		break;

	case Response_Invalid_Response:
	default:
		dwRetCode = IDS_ERR_CHBAD_DATA;
		break;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// OK, allocate enough memory to read the rest fo the data
	lpszResData = (PBYTE) LocalAlloc(GPTR, lkpResponse.GetDataLen() + 1);
	if(lpszResData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	dwRetCode = FetchResponse(lpszResData, lkpResponse.GetDataLen() + 1, &dwResponseLen);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}


	if (dwResponseLen != lkpResponse.GetDataLen() || dwResponseLen <= 0)
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	dwRetCode = DepositLKPResponse(lpszResData, lkpResponse.GetLKPLength());			


done:
	CloseCHRequest();

	if (lpszReqData)
	{
		LocalFree(lpszReqData);
	}

	if (lpszResData)
	{
		LocalFree(lpszResData);
	}


	return dwRetCode;
}




DWORD CGlobal::ProcessCHRevokeCert()
{
	DWORD dwRetCode = ERROR_SUCCESS;
	CertRevoke_Request	crRequest;
	CertRevoke_Response	crResponse;
	PBYTE	lpszReqData = NULL;
	DWORD  dwResponseLen;
	error_status_t		esRPC			= ERROR_SUCCESS;

	//
	// Set Language Id
	//
	crRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = ConnectToLS();
	if(dwRetCode != ERROR_SUCCESS)
	{		
		goto done;
	}

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//
	// Set CR Request Attributes
	//
	crRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
	crRequest.SetLName((BYTE *) (LPCTSTR) m_ContactData.sContactLName, (wcslen(m_ContactData.sContactLName)+1)*sizeof(TCHAR));
	crRequest.SetFName((BYTE *) (LPCTSTR) m_ContactData.sContactFName, (wcslen(m_ContactData.sContactFName)+1)*sizeof(TCHAR));
	crRequest.SetPhone((BYTE *) (LPCTSTR) m_ContactData.sContactPhone, (wcslen(m_ContactData.sContactPhone)+1)*sizeof(TCHAR));
	crRequest.SetFax((BYTE *) (LPCTSTR) m_ContactData.sContactFax, (wcslen(m_ContactData.sContactFax)+1)*sizeof(TCHAR));
	crRequest.SetEMail((BYTE *) (LPCTSTR) m_ContactData.sContactEmail, (wcslen(m_ContactData.sContactEmail)+1)*sizeof(TCHAR));
	crRequest.SetReasonCode((BYTE *) (LPCTSTR) m_ContactData.sReasonCode, (wcslen(m_ContactData.sReasonCode)+1)*sizeof(TCHAR));

	
	crRequest.SetExchgCertLen(m_dwExchangeCertificateLen);
	crRequest.SetSignCertLen(m_dwSignCertificateLen);

	crRequest.SetDataLen(m_dwExchangeCertificateLen+m_dwSignCertificateLen);


	// OK, allocate enough memory to read the rest fo the data
	lpszReqData = (PBYTE) LocalAlloc(GPTR, sizeof(CertRevoke_Request)+m_dwExchangeCertificateLen+m_dwSignCertificateLen);
	if(lpszReqData == NULL)
	{
		dwRetCode = IDS_ERR_OUTOFMEM;
		goto done;
	}

	memcpy(lpszReqData, &crRequest, sizeof(CertRevoke_Request));
	memcpy(lpszReqData+sizeof(CertRevoke_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen );
	memcpy(lpszReqData+sizeof(CertRevoke_Request)+m_dwExchangeCertificateLen, 
		   m_pbSignCertificate,
		   m_dwSignCertificateLen );

	dwRetCode = Dispatch(lpszReqData, sizeof(CertRevoke_Request)+m_dwExchangeCertificateLen+m_dwSignCertificateLen);
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}

	dwRetCode = FetchResponse((BYTE *) &crResponse,
							  sizeof(CertRevoke_Response), &dwResponseLen);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLen != sizeof(CertRevoke_Response))
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	switch(crResponse.RequestHeader.GetResponseType())
	{
	case Response_Success:
		dwRetCode = ERROR_SUCCESS;
		break;

	case Response_Failure:
		dwRetCode = IDS_ERR_CHFAILURE;
		break;

	case Response_InvalidData:
		dwRetCode = IDS_ERR_CHINVALID_DATA;
		break;

	case Response_NotYetImplemented:
		dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
		break;

	case Response_ServerError:
		dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
		break;

	case Response_Invalid_Response:
	default:
		dwRetCode = IDS_ERR_CHBAD_DATA;
		break;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Make LS Regen Key call HERE
	dwRetCode = TLSTriggerReGenKey(m_phLSContext, TRUE, &esRPC);

	if(dwRetCode != RPC_S_OK || esRPC != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_FAILED;		
		goto done;
	}

done:
	CloseCHRequest();

	DisconnectLS();

	if (lpszReqData)
	{
		LocalFree(lpszReqData);
	}

	return dwRetCode;
}

DWORD CGlobal::ProcessCHReissueCert()
{
	HKEY	hKey			= NULL;
	DWORD	dwDisposition	= 0;
	
	CString sName	= m_ContactData.sContactLName + "~" + m_ContactData.sContactFName;
	CString sPhone	= m_ContactData.sContactPhone;
	CString sFax	= m_ContactData.sContactFax;
	CString sEmail	= m_ContactData.sContactEmail;

	DWORD dwRetCode = ERROR_SUCCESS;
	CertReissue_Request	crRequest;
	CertReissue_Response	crResponse;
	DWORD  dwResponseLen;
	error_status_t		esRPC			= ERROR_SUCCESS;

	//
	// Set Language Id
	//
	crRequest.RequestHeader.SetLanguageId(GetLSLangId());

	dwRetCode = ConnectToLS();
	if(dwRetCode != ERROR_SUCCESS)
	{		
		goto done;
	}

	dwRetCode = InitCHRequest();
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//
	// Set CR Request Attributes
	//
	crRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
	crRequest.SetLName((BYTE *) (LPCTSTR) m_ContactData.sContactLName, (wcslen(m_ContactData.sContactLName)+1)*sizeof(TCHAR));
	crRequest.SetFName((BYTE *) (LPCTSTR) m_ContactData.sContactFName, (wcslen(m_ContactData.sContactFName)+1)*sizeof(TCHAR));
	crRequest.SetPhone((BYTE *) (LPCTSTR) m_ContactData.sContactPhone, (wcslen(m_ContactData.sContactPhone)+1)*sizeof(TCHAR));
	crRequest.SetFax((BYTE *) (LPCTSTR) m_ContactData.sContactFax, (wcslen(m_ContactData.sContactFax)+1)*sizeof(TCHAR));
	crRequest.SetEMail((BYTE *) (LPCTSTR) m_ContactData.sContactEmail, (wcslen(m_ContactData.sContactEmail)+1)*sizeof(TCHAR));
	crRequest.SetReasonCode((BYTE *) (LPCTSTR) m_ContactData.sReasonCode, (wcslen(m_ContactData.sReasonCode)+1)*sizeof(TCHAR));

	dwRetCode = Dispatch((BYTE *) &crRequest, sizeof(CertReissue_Request));
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		goto done;
	}

	dwRetCode = FetchResponse((BYTE *) &crResponse, sizeof(CertReissue_Response), &dwResponseLen);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	if (dwResponseLen != sizeof(CertReissue_Response))
	{
		// Didn't get the expected number of Bytes, also a problem
		dwRetCode = IDS_ERR_CHBAD_DATA;
		goto done;
	}

	switch(crResponse.RequestHeader.GetResponseType())
	{
	case Response_Success:
		dwRetCode = ERROR_SUCCESS;
		break;

	case Response_Failure:
		dwRetCode = IDS_ERR_CHFAILURE;
		break;

	case Response_InvalidData:
		dwRetCode = IDS_ERR_CHINVALID_DATA;
		break;

	case Response_NotYetImplemented:
		dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
		break;

	case Response_ServerError:
		dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
		break;

	case Response_Invalid_Response:
	default:
		dwRetCode = IDS_ERR_CHBAD_DATA;
		break;
	}

	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}


	// Make LS Regen Key call HERE
	dwRetCode = TLSTriggerReGenKey(m_phLSContext, TRUE, &esRPC);

	if(dwRetCode != RPC_S_OK || esRPC != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_RPC_FAILED;		
		goto done;
	}
	DisconnectLS();

	// Deposit the New SPK
	dwRetCode = SetLSSPK(crResponse.GetSPK());
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = DepositLSSPK();
	if(dwRetCode != ERROR_SUCCESS)
		goto done;

	// Set the new values in the Registry.
	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx ( m_hLSRegKey,
							 REG_LRWIZ_PARAMS,
							 0,
							 NULL,
							 REG_OPTION_NON_VOLATILE,
							 KEY_ALL_ACCESS,
							 NULL,
							 &hKey,
							 &dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}	
/*	
	//Name	
	RegSetValueEx ( hKey, 
					szOID_GIVEN_NAME_W,
					0,
					REG_SZ,
					(CONST BYTE *)(LPCTSTR)sName,
					sName.GetLength() * sizeof(TCHAR)
				   );	
	
	//Phone	
	RegSetValueEx ( hKey, 
					szOID_TELEPHONE_NUMBER_W,
					0,
					REG_SZ,
					(CONST BYTE *)(LPCTSTR)sPhone,
					sPhone.GetLength() * sizeof(TCHAR)
				   );	

	//Email Address	
	RegSetValueEx ( hKey, 
					szOID_RSA_emailAddr_W,
					0,
					REG_SZ,
					(CONST BYTE *)(LPCTSTR)sEmail,
					sEmail.GetLength() * sizeof(TCHAR)
				   );
*/
	
done:

	if(hKey)
		RegCloseKey(hKey);

	DisconnectLSRegistry();

	CloseCHRequest();

	DisconnectLS();

	return dwRetCode;
}


void CGlobal::SetCSRNumber(TCHAR * tcp)
{
	SetInRegistery(CSRNUMBER_KEY, tcp);

	lstrcpy(m_lpCSRNumber, tcp);
	return;
}

TCHAR * CGlobal::GetCSRNumber(void)
{
	return m_lpCSRNumber;
}

void CGlobal::SetWWWSite(TCHAR * tcp)
{
	lstrcpy(m_lpWWWSite, tcp);
	return;
}

TCHAR * CGlobal::GetWWWSite(void)
{
	return m_lpWWWSite;
}

void CGlobal::SetModifiedRetailSPK(CString sRetailSPK)
{
	m_sModifiedRetailsSPK = sRetailSPK;
}

void CGlobal::GetModifiedRetailSPK(CString &sRetailSPK)
{
	sRetailSPK = m_sModifiedRetailsSPK;
}

DWORD CGlobal::GetLSLangId()
{
	return m_dwLangId;
}

void  CGlobal::SetLSLangId(DWORD dwLangId)
{
	m_dwLangId = dwLangId;
}

int CALLBACK EnumFontFamExProc(
  CONST LOGFONTW *lpelfe,    // pointer to logical-font data
  CONST TEXTMETRICW *lpntme,  // pointer to physical-font data
  DWORD FontType,             // type of font
  LPARAM lParam             // application-defined data
)
{
	LOCALESIGNATURE ls;
	CHARSETINFO cs;
	BOOL rc ;
	DWORD dwLCID = LOCALE_USER_DEFAULT ;
 
	rc = GetLocaleInfo(dwLCID, LOCALE_FONTSIGNATURE, (LPWSTR)& ls, sizeof(ls) / sizeof(TCHAR));

	rc = TranslateCharsetInfo((ULONG *)lpelfe->lfCharSet, &cs, TCI_SRCCHARSET);


	if (rc != 0)
		rc = GetLastError();
 

	if (cs.fs.fsCsb[0] & ls.lsCsbSupported[0]){
		// return fontname
        _tcscpy((TCHAR *)lParam, lpelfe->lfFaceName);		
		return(0); // return 0 to finish the enumeration
	}
	return(1); // return 1 to continue
}
 

void GetDefaultFont(TCHAR *szFontName, HDC hdc)
{

//retrieve the list of installed fonts
LOGFONT lf ;

		
	//to enumerate all styles and charsets of all fonts:
	lf.lfFaceName[0] = '\0';
	lf.lfCharSet = DEFAULT_CHARSET;
	lf.lfWeight = FW_BOLD;


    EnumFontFamiliesEx(
	hdc,                   // handle to device context
	&lf,       // pointer to LOGFONT structure
	EnumFontFamExProc,  // pointer to callback function
	(LPARAM) szFontName,             // application-supplied data
	0// reserved; must be zero
	);
 

	
}


#define	MARGINX		25//50		// X Margin in 100th of an inch
#define MARGINY		25//50		// Y Margin in 100th of an inch
//#define MAX_LABEL	30		// Max Number of chars in a label

#define MAX_PRINT_CHARS 32

int WordWrapAndPrint(HDC hdc, LPCTSTR lpcText, HFONT hBoldFont, long lCharHt, int iValueStartPosX, int iLineStartPosY) 
{
	TCHAR		szBuffer[1024];	
	TCHAR		*lpTemp = NULL;
	
    if (NULL == lpcText)
    {
        return 0;
    }

	_tcscpy(szBuffer, lpcText);
	
	lpTemp = _tcstok(szBuffer,L"\r\n");

	// If no data , just go to the next line
	if(lpTemp == NULL)
		iLineStartPosY -= lCharHt;			

	while(lpTemp)
	{
		while (_tcslen(lpTemp) > MAX_PRINT_CHARS){
			SelectObject(hdc, hBoldFont);
			TextOut(hdc,iValueStartPosX,iLineStartPosY,lpTemp,MAX_PRINT_CHARS);
			iLineStartPosY -= lCharHt;	
			lpTemp += MAX_PRINT_CHARS ;			
		}

		if (_tcslen(lpTemp) > 0){
			SelectObject(hdc, hBoldFont);
			TextOut(hdc,iValueStartPosX,iLineStartPosY,lpTemp,_tcslen(lpTemp));

			iLineStartPosY -= lCharHt;	

			lpTemp = _tcstok(NULL,L"\r\n");
		}
	}
	return iLineStartPosY ;
}

UINT GetMaxLabelLength(HDC hdc, HFONT   m_hNormalFont, HINSTANCE hInstance)
{
        TCHAR	tcLabel[512] = {0};
        int     iTextExtent;
        int     iLen;
        SIZE    size;


        LoadString(hInstance, IDS_FAX, tcLabel, 512);
    	iLen = _tcslen(tcLabel);
	    SelectObject(hdc, m_hNormalFont);
        GetTextExtentPoint32( hdc, 
                                 tcLabel,
                                 iLen,
                                 &size );
        iTextExtent = size.cx;

        LoadString(hInstance, IDS_RETURN_FAX, tcLabel, 512);
    	iLen = _tcslen(tcLabel);
        GetTextExtentPoint32( hdc, 
                                 tcLabel,
                                 iLen,
                                 &size );
        if (size.cx > iTextExtent) //if (size.cy > iTextExtent)
            iTextExtent = size.cx;

		return(iTextExtent ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\global.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _GLOBAL_H_
#define	_GLOBAL_H_

#include "precomp.h"
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
#include <wininet.h>
#include "wincrypt.h"
#include "license.h"
#include "tlsapip.h"
#include "lrwizapi.h"
#include "chstruct.h"

#define szOID_GIVEN_NAME_W					L"2.5.4.42"
#define szOID_COMMON_NAME_W					L"2.5.4.3"
#define szOID_COUNTRY_NAME_W				L"2.5.4.6"
#define szOID_LOCALITY_NAME_W				L"2.5.4.7"
#define szOID_STATE_OR_PROVINCE_NAME_W		L"2.5.4.8"
#define szOID_STREET_ADDRESS_W				L"2.5.4.9"
#define szOID_POSTAL_CODE_W					L"2.5.4.17"
#define szOID_TELEPHONE_NUMBER_W			L"2.5.4.20"
#define szOID_FACSIMILE_TELEPHONE_NUMBER_W  L"2.5.4.23"
#define szOID_RSA_emailAddr_W				L"1.2.840.113549.1.9.1"


#define szCertEXTENSION_OID				"1.3.6.1.4.1.311.18"
#define szCertEXTENSION_VALUE_FMT		_TEXT("TLS~%s")


#define CH_ERROR_SUCCESS		ERROR_SUCCESS
#define	CH_ERROR_BASE			0x3000
#define	CH_ERROR_BAD_DATA		(CH_ERROR_BASE + 1)
#define	CH_ERROR_BAD_PARAM		(CH_ERROR_BASE + 2)
#define	CH_ERROR_BAD_REQUEST	(CH_ERROR_BASE + 3)
#define	CH_ERROR_NO_DATA		(CH_ERROR_BASE + 4)
#define	CH_ERROR_OUT_OF_MEMORY	(CH_ERROR_BASE + 5)
#define	CH_ERROR_EXCEPTION		(CH_ERROR_BASE + 6)
#define	CH_ERROR_HTTPQRY_FAILED (CH_ERROR_BASE + 7)
#define	CH_ERROR_SERVER_ERROR	(CH_ERROR_BASE + 8)
#define	CH_ERROR_SEND_FAILED	(CH_ERROR_BASE + 9)
#define	CH_ERROR_BAD_MFBLOB		(CH_ERROR_BASE + 10)


#define NUMBER_OF_BATCHES			7
#define CHARS_IN_BATCH				5


typedef struct
{
	TCHAR lpszSPK[ LR_RETAILSPK_LEN+1];
	TCHAR	tcStatus;
} RETAILSPK, *PRETAILSPK;


typedef struct
{
	LPWSTR	lpszAttribute;
	LPWSTR	lpszValue;
	DWORD	dwValueLen;
}REG_ATTR, * PREG_ATTR;

typedef struct 
{
	LPCSTR lpszOID;
	LPSTR lpszValue;
} REQ_ATTR, * PREQ_ATTR;

typedef struct _Enveloped_Data
{
    DWORD   cbEncryptedKey;
    PBYTE   pbEncryptedKey;
    DWORD   cbEncryptedData;
    PBYTE   pbEncryptedData;

} EnvData, * PEnvData;


typedef	struct _CONTACT_INFO_TAG
{
	//program related information
	CString sProgramName;			//Can be Select, MOLP, Retail ...

	CString sCertType;

	//Contact information
	CString sCompanyName;
	CString sOrgUnit;
	CString sContactLName;
	CString sContactFName;
	CString sContactAddress;	
	CString sContactPhone;
	CString sContactFax;
	CString sContactEmail;
	CString sEmailAddressConf;
	CString sCity;
	CString sCountryCode;
	CString sCountryDesc;
	CString sState;
	CString sZip;
	CString sReasonCode;
	CString sCSRFaxRegion;
	CString sCSRPhoneRegion;

	void Initialize()
	{
		sProgramName = sContactLName = sContactFName = sContactAddress = 
		sContactPhone = sCity = sCountryCode = sCountryDesc = sState = sZip = 
		sContactEmail = sCompanyName = sOrgUnit = sReasonCode = sContactFax = 
		sEmailAddressConf = sCertType = sCSRFaxRegion = sCSRPhoneRegion = "";
	};
} CONTACTINFO, *PCONTACTINFO;


// Formerly named "LICINFO", but that conflicts with ocidl.h

typedef	struct _LIC_INFO_TAG
{
	//Select Information
	CString sSelMastAgrNumber;
	CString sSelEnrollmentNumber;
	CString sSelProductType;
	CString sSelProductDesc;
	CString sSelQty;

	//MOLP information	
	CString sMOLPAuthNumber;		//authorization number
	CString sMOLPAgreementNumber;	//agreement number
	CString sMOLPProductType;		//product type
	CString sMOLPProductDesc;
	CString sMOLPQty;				//quantity 

	void Initialize()
	{
		sSelMastAgrNumber = sSelEnrollmentNumber = sSelProductType = sSelProductDesc = 
		sSelQty = sMOLPAuthNumber = sMOLPAgreementNumber  = sMOLPProductType = sMOLPProductDesc = 
		sMOLPQty = "";
	};
} TSLICINFO, *PTSLICINFO;




typedef struct FAX_DATA_TAG
{
	CString sRequestType;
	CString sAgreementType;
	CString sProductId;
	CString sLSId;
	CString sFName;
	CString sLName;	
	CString sCompanyName;
	CString sOrgUnit;
	CString sAddress;
	CString sCity;
	CString sState;
	CString sZip;
	CString sCountryCode;
	CString	sCountryDesc;	
	CString sPhoneNumber;
	CString sFaxNumber;
	CString sEmailAddress;
	CString sLicenseType;
	CString	sQuantity;
	CString	sSelEnrollNumber;
	CString sMolpAuthNumber;
	CString sMolpLicNumber;
	
	void Initialize() 
	{
		sRequestType	= "";
		sAgreementType	= "";
		sProductId		= "";
		sLSId			= "";
		sCompanyName	= "";		
		sOrgUnit		= "";
		sAddress		= "";
		sCity			= "";
		sState			= "";
		sCountryCode	= "";
		sCountryDesc	= "";
		sZip			= "";
		sLName			= "";
		sFName			= "";
		sPhoneNumber	= "";
		sFaxNumber		= "";
		sEmailAddress	= "";
		sLicenseType	= "";
		sQuantity		= "";
		sSelEnrollNumber= "";
		sMolpAuthNumber = "";
		sMolpLicNumber	= "";

	};
	
}FAX_DATA, * PFAX_DATA;

class CGlobal
{
public:

	CGlobal();
	~CGlobal();

	void FreeGlobal(void);

//Public Data Members
public:
	

//Public Member Functions
public:

	DWORD PingCH(void);

	void		SetInstanceHandle(HINSTANCE hInst);
	HINSTANCE	GetInstanceHandle();
	void		SetLSName(LPCTSTR lpwszLSName);
	DWORD		InitGlobal(); 
	DWORD		CheckRequieredFields();
	DWORD		LRGetLastError();
	int			LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwErrorCode = 0);
	DWORD		AuthenticateLS();

	DWORD		SetCHCert(LPTSTR lpstrRegKey, PBYTE pCert, DWORD dwLen);
	DWORD		GetCHCert(LPTSTR lpstrRegKey, PBYTE * ppCert, DWORD * pdwLen );
	BOOL		IsLSRunning();	
	
	DWORD		GetLSCertificates(PDWORD pdwLSStatus);
	DWORD		IsLicenseServerRegistered(PDWORD pdwServerStatus);

	PCONTACTINFO	GetContactDataObject();
	PTSLICINFO	GetLicDataObject();

	DWORD		GetRequestType();
	void		SetRequestType(DWORD dwMode);

	DWORD		ResetLSSPK(BOOL bGenKey = TRUE);
	TCHAR *		GetRegistrationID(void);
	TCHAR *		GetLicenseServerID(void);

	BOOL		IsOnlineCertRequestCreated();

	DWORD		SetLRState(DWORD dwState);

	DWORD		ProcessRequest();

	DWORD		SetCertificatePIN(LPTSTR lpszPIN);
	
	DWORD		PopulateCountryComboBox(HWND hWndCmb);
	DWORD		GetCountryCode(CString sDesc,LPTSTR szCode);
	DWORD		GetCountryDesc(CString sCode,LPTSTR szDesc);

	DWORD		PopulateProductComboBox(HWND hWndCmb);
	DWORD		GetProductCode(CString sDesc,LPTSTR szCode);
	
	DWORD		PopulateReasonComboBox(HWND hWndCmb, DWORD dwType);
	DWORD		GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType);
	DWORD		GetReasonDesc(CString sCode,LPTSTR szDesc, DWORD dwType);

	DWORD		PopulateCountryRegionComboBox(HWND hWndCmb);

	DWORD		CheckRegistryForPhoneNumbers();
	
	void		LRSetLastRetCode(DWORD dwCode);
	DWORD		LRGetLastRetCode();

	void		SetCSRNumber(TCHAR *);
	TCHAR *		GetCSRNumber(void);

	void		SetWWWSite(TCHAR *);
	TCHAR *		GetWWWSite(void);

	void		LRPush(DWORD dwPageId);
	DWORD		LRPop();
	void		ClearWizStack();

	DWORD		DepositLSSPK();
	DWORD		SetLSLKP(TCHAR * tcLKP);
	DWORD		SetLSSPK(TCHAR * tcLKP);


	BOOL		ValidateEmailId(CString sEmailId);
	BOOL		CheckProgramValidity(CString sProgramName);
	BOOL		ValidateLRString(CString sStr);

	LPSTR		UnicodeToAnsi( LPWSTR lpwszBuf);
	LPSTR		UnicodeToAnsi( LPWSTR lpwszBuf, DWORD dwLength );
	LPWSTR		AnsiToUnicode ( LPSTR lpszBuf );

	void	SetReFresh(DWORD dw) { m_dwRefresh = dw; }
	DWORD	GetReFresh(void)
	{
		return m_dwRefresh;
	}

	void  DeleteRetailSPKFromList(TCHAR * lpszRetailSPK);
	DWORD AddRetailSPKToList(HWND hListView, TCHAR * lpszRetailSPK);
	void  LoadFromList(HWND hListView);
	void  UpdateSPKStatus(TCHAR * lpszRetailSPK, TCHAR tcStatus);
	
	DWORD SetConfirmationNumber(TCHAR * tcConf);

	void SetModifiedRetailSPK(CString sRetailSPK);
	void GetModifiedRetailSPK(CString &sRetailSPK);

	void ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK);
	DWORD ValidateRetailSPK(TCHAR * lpszRetailSPK);

	DWORD GetLSLangId();
	void  SetLSLangId(DWORD dwLangId);	


	void SetLSStatus(DWORD dwStatus);
	DWORD GetLSStatus(void);

	DWORD GetEntryPoint(void);

	WIZCONNECTION	GetActivationMethod(void);
	void SetActivationMethod(WIZCONNECTION conn);

	WIZCONNECTION GetLSProp_ActivationMethod(void);
	void SetLSProp_ActivationMethod(WIZCONNECTION conn);

	WIZACTION	GetWizAction(void);
	void		SetWizAction(WIZACTION act);
	DWORD	SetInRegistery(LPCSTR lpszOID, LPCTSTR lpszValue);
	LPCTSTR GetFromRegistery(LPCSTR lpszOID, LPTSTR lpszBuffer, BOOL bConnect = TRUE);

	DWORD	SetEncodedInRegistry(LPCSTR lpszOID, LPCTSTR lpszValue);

//Private Member functions
protected:
	void	LRSetLastError(DWORD dwErrorCode);

	DWORD	GetTempCryptContext(HCRYPTPROV * phCryptProv);
	void	DoneWithTempCryptContext(HCRYPTPROV hCryptProv);	

	DWORD	GetCryptContextWithLSKeys(HCRYPTPROV * lphCryptProv ); 
	void	DoneWithCryptContextWithLSKeys(HCRYPTPROV hProv);

	DWORD	LoadCountries();
	DWORD	LoadReasons();
	DWORD	LoadProducts();

	DWORD	ConnectToLSRegistry();
	void	DisconnectLSRegistry();
	DWORD	ConnectToLS();
	void	DisconnectLS();

	DWORD	ProcessDownloadLKP();
	DWORD	ProcessIRegRequest();
	DWORD	ProcessCertDownload();
	DWORD	ProcessCASignOnlyRequest();
	DWORD	ProcessCHReissueLKPRequest();
	DWORD	DepositLSLKP(void);
	DWORD	ProcessCHRevokeCert(void);
	DWORD	ProcessCHReissueCert(void);


	DWORD	CreateLKPRequest(PBYTE * ppbLKPRequest, NewLKP_Request * newlkpp, DWORD &dwBufLen);
	DWORD	DepositLKPResponse(PBYTE pbResponseData, DWORD dwResponseLen);

	DWORD	CreateLSPKCS10(HCRYPTPROV hCryptProv,int nType, CHAR **lppszPKCS10);
	DWORD	DepositLSCertificates(PBYTE pbExchangePKCS7, 
								 DWORD dwExchangePKCS7Len,
								 PBYTE pbSignaturePKCS7,
								 DWORD dwSignaturePKCS7Len,
								 PBYTE pbRootCert,
								 DWORD dwRootCertLen);

	DWORD	SetCARequestAttributes();
	DWORD	SetCHRequestAttributes();
	
	void	ClearCHRequestAttributes();
	void	ClearCARequestAttributes();

	DWORD	SetRegistrationAttribute ( LPWSTR lpszAttribute, LPCWSTR lpszValue, DWORD dwLen );
	DWORD	SetDNAttribute(LPCSTR lpszOID, LPSTR lpszValue);

	
	void	PrepareLRString(CString &sStr);

	CERT_RDN_ATTR * CreateRDNAttr();

	//Crypto Related functions
	DWORD	EncryptBuffer ( PBYTE	pBuffer,
							DWORD	dwcbBufLen,
							DWORD	dwKeyContainerType,
							PBYTE	pCertificate,
							DWORD	cbCertificate,
							PDWORD  pcbEncryptedBlob,
							PBYTE	*ppbEncryptedBlob
						   );

	DWORD	EnvelopeData(
							PCCERT_CONTEXT		pCertContext,
							DWORD               cbMessage,
							PBYTE               pbMessage,
							PEnvData			pEnvelopedData,
							HCRYPTPROV			hCryptProv,
							HCERTSTORE			hCertStore
  		  				);

	DWORD	PackEnvData( 
							PEnvData     pEnvelopedData, 
							PDWORD       pcbPacked, 
							PBYTE        *ppbPacked 
						);
	DWORD GetCertforExtension (	HCRYPTPROV hCryptProv, 
								HCERTSTORE hCertStore, 
								LPSTR szOID_EXT, 
								PCCERT_CONTEXT * ppCertContext);


	DWORD VerifyCertChain (	HCRYPTPROV	hCryptProvider,			//handle to crypt prov
							HCERTSTORE	hCertStore,				//HAndle to store for verification
							PBYTE	pbRootCert,			//Root cert
							DWORD	dwcbRootCert
							);

	DWORD InitCHRequest(void);
	DWORD CloseCHRequest(void);
	DWORD Dispatch(BYTE * bpData, DWORD dwLen);

	DWORD FetchResponse(BYTE * bpResponse,
				  		DWORD dwMaxLength,
						PDWORD dwpDataLength);

	DWORD InitSPKList(void);
	void InsertIntoSPKDisplayList(HWND hListView,
								  TCHAR * lpszRetailSPK,
								  TCHAR tcStatus);	

//Private Data members
private:	
	DWORD		m_dwLSStatus;
	HWND		m_hWndParent;
	HINSTANCE	m_hInstance;
	LPTSTR		m_lpstrLSName;
	LPWSTR		m_lpwstrLSName;
	LPTSTR		m_lpstrCHServer;
	LPTSTR		m_lpstrCHExtension;
	DWORD		m_dwErrorCode;
	HKEY		m_hLSRegKey;

	DWORD		m_dwExchangeCertificateLen;
	PBYTE		m_pbExchangeCertificate;

	DWORD		m_dwSignCertificateLen;
	PBYTE		m_pbSignCertificate;

	DWORD		m_dwExtenstionValueLen;
	PBYTE		m_pbExtensionValue;
	
	PREQ_ATTR	m_pReqAttr;					//For the Cert Request
	DWORD		m_dwReqAttrCount;

	PREG_ATTR   m_pRegAttr;					//For the LKP Request
	DWORD		m_dwRegAttrCount;

	PCONTEXT_HANDLE m_phLSContext;

    BOOL        m_fSupportConcurrent;

    BOOL        m_fSupportWhistlerCAL;

	CONTACTINFO	m_ContactData;
	TSLICINFO	m_LicData;

	DWORD       m_dwRequestType;
	DWORD		m_dwLRState;
	DWORD		m_dwLRCount;				//LKP Request Count

	LPTSTR		m_lpstrPIN;

	TCHAR		m_lpCSRNumber[128];
	TCHAR		m_lpWWWSite[255];

	CStringArray	m_csaCountryCode;
	CStringArray	m_csaCountryDesc;

	CStringArray	m_csaProductCode;
	CStringArray	m_csaProductDesc;

	CStringArray	m_csaDeactReasonCode;
	CStringArray	m_csaDeactReasonDesc;

	CStringArray	m_csaReactReasonCode;
	CStringArray	m_csaReactReasonDesc;

	DWORD			m_dwLastRetCode;

	DWORD			m_dwRefresh;

	HINTERNET m_hOpenDirect;
	HINTERNET m_hConnect;
	HINTERNET m_hRequest;

	TCHAR m_pRegistrationID[ LR_REGISTRATIONID_LEN+1];
	TCHAR m_pLicenseServerID[ LR_LICENSESERVERID_LEN+1];
	TCHAR m_pLSLKP[ LR_REGISTRATIONID_LEN+1];
	TCHAR m_pLSSPK[ LR_REGISTRATIONID_LEN+1];


	//Stores page traversal order. Implemented as a stack
	DWORD		m_dwWizStack[NO_OF_PAGES];
	DWORD		m_dwTop;

	DWORD		m_dwRetailSPKEntered;
	RETAILSPK	m_listRetailSPK[ MAX_RETAILSPKS_IN_BATCH];

	CString		m_sModifiedRetailsSPK;

	DWORD		m_dwLangId;

	WIZCONNECTION	m_ActivationMethod;
	WIZCONNECTION	m_LSProp_ActivationMethod;
	WIZACTION		m_WizAction;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\lrwizapi.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef __LRWIZAPI_H__
#define __LRWIZAPI_H__

#include "windows.h"

#define LRWIZ_ERROR_BASE				6000
//Return codes for LRWIZAPI
#define LRWIZ_SUCCESS					ERROR_SUCCESS
#define LRWIZ_OPERATION_CANCELLED		(LRWIZ_ERROR_BASE + 1)
#define LRWIZ_OPERATION_EXIT			(LRWIZ_ERROR_BASE + 2)
#define LRWIZ_ERROR_INITIALIZE			(LRWIZ_ERROR_BASE + 3)
#define LRWIZ_ERROR_PREREG				(LRWIZ_ERROR_BASE + 4)
#define LRWIZ_ERROR_AUTHENTICATE		(LRWIZ_ERROR_BASE + 5)
#define LRWIZ_INVALID_REQUEST_TYPE		(LRWIZ_ERROR_BASE + 6)
#define LRWIZ_ERROR_ACCEPTING_PKCS7		(LRWIZ_ERROR_BASE + 7)
#define LRWIZ_ERROR_DEPOSITING_CH_CERT	(LRWIZ_ERROR_BASE + 8)
#define LRWIZ_ERROR_PROCSSING_CH_DISK   (LRWIZ_ERROR_BASE + 9)
#define LRWIZ_ERROR_CREATING_PKCS10		(LRWIZ_ERROR_BASE + 10)
#define ERROR_CONNECTING_TO_RA			(LRWIZ_ERROR_BASE + 11)
#define ERROR_INVALID_RA_RESPONSE		(LRWIZ_ERROR_BASE + 12)
#define LRWIZ_ERROR_NO_CERT				(LRWIZ_ERROR_BASE + 13)
#define ERROR_CONNECTING_TO_CH			(LRWIZ_ERROR_BASE + 14)
#define ERROR_INVALID_CH_RESPONSE		(LRWIZ_ERROR_BASE + 15)
#define LRWIZ_ERROR_UPGRADE_REQUIRED	(LRWIZ_ERROR_BASE + 16)
#define	LRWIZ_ERROR_LS_NOT_RUNNING		(LRWIZ_ERROR_BASE + 17)
#define	LRWIZ_ERROR_CREATE_FAILED		(LRWIZ_ERROR_BASE + 18)
#define LRWIZ_ERROR_NTVERSION_LT_5		(LRWIZ_ERROR_BASE + 19)


#define LSERVERSTATUS_UNREGISTER        0   // server not register
#define LSERVERSTATUS_WAITFORPIN        1   // server is waiting for PIN
#define LSERVERSTATUS_REGISTER_INTERNET 2   // server is internet register
#define LSERVERSTATUS_REGISTER_OTHER    3   // server is non-internet register

typedef enum {
    WIZACTION_REGISTERLS,
    WIZACTION_DOWNLOADLKP,
    WIZACTION_UNREGISTERLS,
    WIZACTION_REREGISTERLS,
    WIZACTION_DOWNLOADLASTLKP,
    WIZACTION_SHOWPROPERTIES,
	WIZACTION_CONTINUEREGISTERLS
} WIZACTION;

typedef enum {
    CONNECTION_DEFAULT,
    CONNECTION_INTERNET,
    CONNECTION_WWW,
    CONNECTION_PHONE,
    CONNECTION_FAX      // only used for backwards compatibility
} WIZCONNECTION;

#ifdef __cplusplus
extern "C"
{
#endif

//
// Function return ERROR_SUCCESS or error code, 
// pConnectionType returns connection type set 
// by user
//
DWORD
GetConnectionType(
    HWND hWndParent,
    LPCTSTR pszLSName,
    WIZCONNECTION* pConnectionType       
);


//
// Function return ERROR_SUCCESS or error code.
// pdwServerStatus returns LSERVERSTATUS_XXXX
//
DWORD 
IsLicenseServerRegistered(
    HWND hWndParent, 
    LPCTSTR pszLSName,
    PDWORD pdwServerStatus
);


//
// Function return ERRROR_SUCCESS or error code.
// pbRefresh returns TRUE if LicMgr need to refresh server, 
// FALSE otherwise.
//
DWORD 
StartWizard(
    HWND hWndParent, 
    WIZACTION WizAction,
    LPCTSTR pszLSName, 
    PBOOL pbRefresh
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\lrwizdll.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _LRWIZDLL_H_
#define _LRWIZDLL_H_

#include "def.h"
#include "lrwizapi.h"

struct PageInfo
{	
	int				LRMode;
	int				LROperation;
	DWORD			dwPrevPage;
    UINT			CurrentPage;
    UINT			TotalPages;
	HFONT			hBigBoldFont;
	HFONT			hBoldFont;
};

BOOL WINAPI
DllMain(
	HANDLE hInstance,
	ULONG ul_reason_for_call,
	LPVOID lpReserved);

DWORD 
StartWizard(
    HWND hWndParent, 
    WIZACTION WizAction,
    LPTSTR pszLSName, 
    PBOOL pbRefresh
);

#ifdef XX
DWORD 
StartLRWiz(
	HWND hWndParent,
	LPTSTR wszLSName);
#endif

BOOL 
LRIsLSRunning();

VOID
SetControlFont(
    IN HFONT    hFont, 
    IN HWND     hwnd, 
    IN INT      nId
    );

VOID 
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    );

VOID
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    );

DWORD ShowProperties(HWND hWndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\oper.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include <assert.h>

extern HINSTANCE g_hInstance;


void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;



LRW_DLG_INT CALLBACK
TelReissueProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	DWORD dwRetCode;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

        // Now set the Limit of the data entry fields
        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
        break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
			cwRegistrationID = GetGlobalContext()->GetRegistrationID();
			hwndLSID = GetDlgItem(hwnd, IDC_MSID);
			swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
				 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
				 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
				 cwRegistrationID + 30);
	
			SetWindowText(hwndLSID, awBuffer);
		}
		break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		break ;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
                break;

            case PSN_WIZNEXT:
				{
					// Let us get the Information Entered First & concatenate everything into
					// One String
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					
					// OK, Now we have the Information provided by the user
					// Need to validate
					if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
					{
						// Extraneous characters in the SPK string
						LRMessageBox(hwnd, IDS_ERR_INVALIDLSID, 0);
						dwNextPage = IDD_DLG_TELREG_REISSUE;
					}
					else 
					{
						dwRetCode = SetLSSPK(tcUserValue);
						if (dwRetCode != ERROR_SUCCESS)
						{
							LRMessageBox(hwnd, dwRetCode);	
							dwNextPage = IDD_DLG_TELREG_REISSUE;
						}
						else
						{
							dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
							dwNextPage = IDD_PROGRESS;
							LRPush(IDD_DLG_TELREG_REISSUE);
						}
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}




LRW_DLG_INT CALLBACK
ConfRevokeProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	DWORD dwRetCode;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        
		SendDlgItemMessage (hwnd, IDC_REVOKE_CONFIRMATION_NUMBER, EM_SETLIMITTEXT,
							LR_CONFIRMATION_LEN, 0);
        break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
			cwRegistrationID = GetGlobalContext()->GetRegistrationID();
			hwndLSID = GetDlgItem(hwnd, IDC_MSID2);
			swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
				 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
				 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
				 cwRegistrationID + 30);
	
			SetWindowText(hwndLSID, awBuffer);
		}
		break;


    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
                break;

            case PSN_WIZNEXT:
				{
					TCHAR lpBuffer[ LR_CONFIRMATION_LEN+1];

					GetDlgItemText(hwnd,IDC_REVOKE_CONFIRMATION_NUMBER, lpBuffer,
								   LR_CONFIRMATION_LEN+1);

					if (SetConfirmationNumber(lpBuffer) != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CONFIRMATION_NUMBER);	
						dwNextPage = IDD_DLG_CONFREVOKE;
					}
					else
					{
						dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
						dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_CONFREVOKE);
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}



LRW_DLG_INT CALLBACK
CertLogProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		SendDlgItemMessage (hwnd , IDC_TXT_LNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_PHONE,	EM_SETLIMITTEXT, CA_PHONE_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_EMAIL,	EM_SETLIMITTEXT, CA_EMAIL_LEN,0);
		SetDlgItemText(hwnd, IDC_TXT_LNAME, GetGlobalContext()->GetContactDataObject()->sContactLName);
		SetDlgItemText(hwnd, IDC_TXT_FNAME, GetGlobalContext()->GetContactDataObject()->sContactFName);
		SetDlgItemText(hwnd, IDC_TXT_PHONE, GetGlobalContext()->GetContactDataObject()->sContactPhone);
		SetDlgItemText(hwnd, IDC_TXT_EMAIL, GetGlobalContext()->GetContactDataObject()->sContactEmail);
        break;

	case WM_SHOWWINDOW:
		//bad bad.  The view should get data from 
		//the doc and render it as it wants!
		if ( GetGlobalContext()->GetWizAction() == WIZACTION_UNREGISTERLS )
		{
			PopulateReasonComboBox(GetDlgItem(hwnd,IDC_COMBO_REASONS), CODE_TYPE_DEACT);

			// Reason code is not required here - CR23
			// Hack - combo is hidden and first reason code is sent over to the backend
			ShowWindow(GetDlgItem(hwnd,IDC_COMBO_REASONS),SW_HIDE);
			ShowWindow(GetDlgItem(hwnd,IDC_LBL_REASON),SW_HIDE);
			ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_COMBO_REASONS),0);
		}
		if ( GetGlobalContext()->GetWizAction() == WIZACTION_REREGISTERLS )
		{
			PopulateReasonComboBox(GetDlgItem(hwnd,IDC_COMBO_REASONS), CODE_TYPE_REACT);

			// Reason codes are required in this case
			ShowWindow(GetDlgItem(hwnd,IDC_COMBO_REASONS),SW_SHOW);
			ShowWindow(GetDlgItem(hwnd,IDC_LBL_REASON),SW_SHOW);
		}
		

		break;
    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				//Populate the values which were read from the Registry during Global Init
				//
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
                break;

            case PSN_WIZNEXT:
				{
					CString sLastName;
					CString sFirstName;
					CString sPhone;
					CString sEmail;
					CString sReasonDesc;
					CString sReasonCode;
					LPTSTR  lpVal = NULL;					
					DWORD dwRetCode;
					int nCurSel = -1;

					//
					//Read all the fields
					//
					lpVal = sLastName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_LNAME,lpVal,CA_NAME_LEN+1);
					sLastName.ReleaseBuffer(-1);
					
					lpVal = sFirstName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_FNAME,lpVal,CA_NAME_LEN+1);
					sFirstName.ReleaseBuffer(-1);

					lpVal = sPhone.GetBuffer(CA_PHONE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_PHONE,lpVal,CA_PHONE_LEN+1);
					sPhone.ReleaseBuffer(-1);

					lpVal = sEmail.GetBuffer(CA_EMAIL_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_EMAIL,lpVal,CA_EMAIL_LEN+1);
					sEmail.ReleaseBuffer(-1);

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_COMBO_REASONS));
					lpVal = sReasonDesc.GetBuffer(LR_REASON_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_COMBO_REASONS), nCurSel, lpVal);
					sReasonDesc.ReleaseBuffer(-1);

					sFirstName.TrimLeft();   sFirstName.TrimRight();
					sLastName.TrimLeft();   sLastName.TrimRight();
					sPhone.TrimLeft();   sPhone.TrimRight(); 
					sEmail.TrimLeft();	 sEmail.TrimRight();					
					sReasonDesc.TrimLeft();sReasonDesc.TrimRight();
					
					if(sLastName.IsEmpty() || sFirstName.IsEmpty() || sReasonDesc.IsEmpty()) // sEmail.IsEmpty()
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						dwNextPage	= IDD_DLG_CERTLOG_INFO;
						goto NextDone;
					}
					
					//
					// Check for the Invalid Characters
					//
					if( !ValidateLRString(sFirstName)	||
						!ValidateLRString(sLastName)	||
						!ValidateLRString(sPhone)		||
						!ValidateLRString(sEmail) 
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						dwNextPage = IDD_DLG_CERTLOG_INFO;
						goto NextDone;
					}
					
					if(!sEmail.IsEmpty())
					{
						if(!ValidateEmailId(sEmail))
						{
							LRMessageBox(hwnd,IDS_ERR_INVALID_EMAIL);
							dwNextPage = IDD_DLG_CERTLOG_INFO;
							goto NextDone;
						}
					}

					lpVal = sReasonCode.GetBuffer(LR_REASON_CODE_LEN+1);
					if ( GetGlobalContext()->GetWizAction() == WIZACTION_UNREGISTERLS )
					{
						GetReasonCode(sReasonDesc,lpVal, CODE_TYPE_DEACT);
					}
					else if ( GetGlobalContext()->GetWizAction() == WIZACTION_REREGISTERLS )
					{
						GetReasonCode(sReasonDesc,lpVal, CODE_TYPE_REACT);
					}

					
					sReasonCode.ReleaseBuffer(-1);
					
					//
					//Finally update CAData object
					//
					GetGlobalContext()->GetContactDataObject()->sContactEmail = sEmail;
					GetGlobalContext()->GetContactDataObject()->sContactFName = sFirstName;
					GetGlobalContext()->GetContactDataObject()->sContactLName = sLastName;
					GetGlobalContext()->GetContactDataObject()->sContactPhone = sPhone;			
					GetGlobalContext()->GetContactDataObject()->sReasonCode   = sReasonCode;
					
					//
					//If no Error , go to the next page
					//
					dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
					dwNextPage = IDD_PROGRESS;
					LRPush( IDD_DLG_CERTLOG_INFO );
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\lrwizdll.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif

#include "wincrypt.h"
#include "tlsapip.h"
#include "lrwizapi.h"
#include "wincrypt.h"
#include "dlgproc.h"
#include "propdlgs.h"

#include "global.h"
#include "utils.h"

#define  ACTIVATIONMETHOD_KEY			"ACTIVATIONMETHOD"

CGlobal		*g_CGlobal = NULL;


BOOL   WINAPI   DllMain (HANDLE hInst,ULONG ul_reason_for_call,LPVOID lpReserved)
{ 
	switch(ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		if (g_CGlobal == NULL)
		{
			g_CGlobal = new CGlobal;
			if (g_CGlobal == NULL)
			{
				return FALSE;
			}

			SetInstanceHandle((HINSTANCE)hInst);
		}
		break;

	case DLL_PROCESS_DETACH:
		if (g_CGlobal != NULL)
		{
			delete g_CGlobal;
			g_CGlobal = NULL;
		}
		break;

	default:
		break;
	}
	
	return TRUE;
}




DWORD 
IsLicenseServerRegistered(HWND hWndParent, 
						  LPCTSTR pszLSName,
						  PDWORD pdwServerStatus)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	
	GetGlobalContext()->SetLSName(pszLSName);

	if (!GetGlobalContext()->IsLSRunning())
	{		
		dwRetCode = LRWIZ_ERROR_LS_NOT_RUNNING;
		goto done;
	}	

	dwRetCode = GetGlobalContext()->IsLicenseServerRegistered(pdwServerStatus);

	if (dwRetCode == ERROR_SUCCESS && *pdwServerStatus == LSERVERSTATUS_UNREGISTER &&
		GetGlobalContext()->IsOnlineCertRequestCreated())
	{
		*pdwServerStatus = LSERVERSTATUS_WAITFORPIN;
	}

	GetGlobalContext()->FreeGlobal();

done:
	return dwRetCode;
}





DWORD
GetConnectionType(HWND hWndParent,
				  LPCTSTR pszLSName,
				  WIZCONNECTION* pConnectionType)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	TCHAR lpBuffer[64];

//	*pConnectionType = GetGlobalContext()->GetActivationMethod();

	//
	// Connect to the given LS Registry & read the current ConnectionType.
	//
	GetGlobalContext()->SetLSName(pszLSName);
	GetGlobalContext()->GetFromRegistery(ACTIVATIONMETHOD_KEY, lpBuffer, TRUE);

	if (_tcslen(lpBuffer) != 0)
	{
		*pConnectionType = (WIZCONNECTION) _ttoi(lpBuffer);

        if (*pConnectionType == CONNECTION_FAX)
            *pConnectionType = CONNECTION_DEFAULT;
	}
	else
	{
		*pConnectionType = CONNECTION_DEFAULT;
	}

	GetGlobalContext()->FreeGlobal();

	return dwRetCode;
}




DWORD 
StartWizard(
    HWND hWndParent, 
    WIZACTION WizAction,
    LPCTSTR pszLSName, 
    PBOOL pbRefresh
)
{
	DWORD			dwRetCode			= LRWIZ_SUCCESS;
    BOOL            bStatus             = TRUE;
    PageInfo        PageInfo            = {0};
    PROPSHEETPAGE   psp                 = {0};
    HPROPSHEETPAGE  ahpsp[NO_OF_PAGES]  = {0};
    PROPSHEETHEADER psh                 = {0};
	UINT			i = 0;
	DWORD			dwLSStatus = 0;
	
	GetGlobalContext()->SetWizAction(WizAction);

	GetGlobalContext()->SetLSName(pszLSName);

	if(!GetGlobalContext()->IsLSRunning())
	{
		LRMessageBox(hWndParent,IDS_ERR_LSCONNECT_FAILED);
		dwRetCode = LRWIZ_ERROR_LS_NOT_RUNNING;
		goto done;
	}

	dwRetCode = GetGlobalContext()->InitGlobal();
	if (dwRetCode != ERROR_SUCCESS)
	{
		LRMessageBox(hWndParent,dwRetCode,LRGetLastError());
		goto done;
	}

	dwRetCode = GetGlobalContext()->GetLSCertificates(&dwLSStatus);
	if (dwRetCode != ERROR_SUCCESS)
	{	
		LRMessageBox(hWndParent,dwRetCode,LRGetLastError());
		goto done;
	}	

	if (dwLSStatus == LSERVERSTATUS_UNREGISTER && GetGlobalContext()->IsOnlineCertRequestCreated())
	{
		dwLSStatus = LSERVERSTATUS_WAITFORPIN;
	}

	//
	// Show properties if WizAction is WIZACTION_SHOWPROPERTIES
	//
	if(WizAction == WIZACTION_SHOWPROPERTIES)
	{
		dwRetCode = ShowProperties(hWndParent);
		*pbRefresh = GetReFresh();
		return dwRetCode;
	}

	// verify the registry entries if the LS is already registered and the 
	// connection method is Internet
	if ((GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET ||
		 GetGlobalContext()->GetActivationMethod() == CONNECTION_DEFAULT) 
		 && dwLSStatus == LSERVERSTATUS_REGISTER_INTERNET )
	{
		dwRetCode = GetGlobalContext()->CheckRequieredFields();
		if (dwRetCode != ERROR_SUCCESS)
		{
			LRMessageBox(hWndParent,dwRetCode,LRGetLastError());
			goto done;
		}
	}

	if (dwLSStatus == LSERVERSTATUS_WAITFORPIN)
	{
		GetGlobalContext()->SetWizAction(WIZACTION_CONTINUEREGISTERLS);
	}

	assert(dwLSStatus == LSERVERSTATUS_UNREGISTER ||
		   dwLSStatus == LSERVERSTATUS_WAITFORPIN ||
		   dwLSStatus == LSERVERSTATUS_REGISTER_INTERNET ||
		   dwLSStatus == LSERVERSTATUS_REGISTER_OTHER);


	GetGlobalContext()->SetLSStatus(dwLSStatus);

	//Create All the pages here
	// New Welcome page which explains the process, etc.
    psp.dwSize              = sizeof( psp );
    psp.hInstance           = GetInstanceHandle();
    psp.lParam              = (LPARAM)&PageInfo;	
	psp.pfnDlgProc          = WelcomeDlgProc;
    psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_WELCOME );
    ahpsp[PG_NDX_WELCOME]	= CreatePropertySheetPage( &psp );

	// New page for choosing the Mode of Registration
    psp.dwSize              = sizeof( psp );
    psp.dwFlags             = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance           = GetInstanceHandle();
    psp.lParam              = (LPARAM)&PageInfo;	
	psp.pfnDlgProc          = GetModeDlgProc;
    psp.pszHeaderTitle		= MAKEINTRESOURCE( IDS_TITLE20 );
    psp.pszHeaderSubTitle	= MAKEINTRESOURCE( IDS_SUBTITLE20 );
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_DLG_GETREGMODE );
    ahpsp[PG_NDX_GETREGMODE]= CreatePropertySheetPage( &psp );


	//
	//Customer Information(2) page for CA Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ContactInfo1DlgProc;	
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE4 );
    psp.pszHeaderSubTitle		= MAKEINTRESOURCE( IDS_SUBTITLE4 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_CONTACTINFO1 );
    ahpsp[PG_NDX_CONTACTINFO1]	= CreatePropertySheetPage( &psp );


	//
	//Customer Information(1) page for CA Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ContactInfo2DlgProc;	
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE3 );
    psp.pszHeaderSubTitle		= MAKEINTRESOURCE( IDS_SUBTITLE3 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_CONTACTINFO2 );
    ahpsp[PG_NDX_CONTACTINFO2]	= CreatePropertySheetPage( &psp );	

	
#ifdef XXX
	//
	//Processing Request page(Online)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ProcessingDlgProc;	
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE5 );    
	psp.pszHeaderSubTitle		= MAKEINTRESOURCE( IDS_SUBTITLE5 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_PROCESSING );
    ahpsp[PG_NDX_PROCESSING]	= CreatePropertySheetPage( &psp );
#endif


	//
	//Registration Complete page for CA Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_HIDEHEADER;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ProgressDlgProc;    
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_PROGRESS );
    ahpsp[PG_NDX_PROGRESS]		= CreatePropertySheetPage( &psp );



	//
	//Certificate PIN page for CA Request(Online)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= PINDlgProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE9 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE9 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_PIN );
    ahpsp[PG_NDX_DLG_PIN]				= CreatePropertySheetPage( &psp );

	//
	//Choose Program page for CH Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CustInfoLicenseType;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE10 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE10 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_LICENSETYPE );
    ahpsp[PG_NDX_CH_REGISTER_1]			= CreatePropertySheetPage( &psp );


	//
	// Select Program & Client License Information page for CH Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CHRegisterSelectDlgProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE11 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE11 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_CH_REGISTER_SELECT);
    ahpsp[PG_NDX_CH_REGISTER_SELECT]	= CreatePropertySheetPage( &psp );


	//
	//Molp Program & Client License Information page for CH Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CHRegisterMOLPDlgProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE12 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE12 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_CH_REGISTER_MOLP);
    ahpsp[PG_NDX_CH_REGISTER_MOLP]		= CreatePropertySheetPage( &psp );


	//
	// Options after registering
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= ContinueReg;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE18 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE18 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_CONTINUEREG );
    ahpsp[PG_NDX_CONTINUEREG]			= CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Telephone Registration
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= TelRegProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE19 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE19 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_TELREG);
    ahpsp[PG_NDX_TELREG]	   		    = CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Telephone LKP stuff
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= TelLKPProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE21 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE21 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_TELLKP);
    ahpsp[PG_NDX_TELLKP]	   		    = CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Retail SPK Implementation
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= RetailSPKProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE22 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE22 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_RETAILSPK );
    ahpsp[PG_NDX_RETAILSPK]	   		    = CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Cert Log Infor (before re-issuing/revoking certs)
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CertLogProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE24 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE24 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_CERTLOG_INFO );
    ahpsp[PG_NDX_CERTLOG]   		    = CreatePropertySheetPage( &psp );


	// Telephone Revocation
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= ConfRevokeProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE25 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE25 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_CONFREVOKE );
    ahpsp[PG_NDX_CONFREVOKE]   		    = CreatePropertySheetPage( &psp );

	// Telephone re-issue
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= TelReissueProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE26 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE26 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_TELREG_REISSUE );
    ahpsp[PG_NDX_TELREG_REISSUE] 	    = CreatePropertySheetPage( &psp );


	// Telephone Country/Region
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CountryRegionProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE27 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE27 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_COUNTRYREGION );
    ahpsp[PG_NDX_COUNTRYREGION] 	    = CreatePropertySheetPage( &psp );


	// WWW Registration
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= WWWRegProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE28 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE28 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_WWWREG);
    ahpsp[PG_NDX_WWWREG]		 	    = CreatePropertySheetPage( &psp );

	// WWW LKP Download
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= WWWLKPProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE29 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE29 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_WWWLKP);
    ahpsp[PG_NDX_WWWLKP]			    = CreatePropertySheetPage( &psp );

    psh.dwFlags             = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;

	//psh.pszbmWatermark      = 0;
    //psh.pszbmHeader         = 0;
    psh.pszbmWatermark      = MAKEINTRESOURCE(IDB_CLIENT_CONN);
    psh.pszbmHeader         = MAKEINTRESOURCE(IDB_CLIENT_CONN_HDR);
                    
    psh.dwSize              = sizeof( psh );
    psh.hInstance           = GetInstanceHandle();
    psh.hwndParent          = hWndParent;
    psh.pszCaption		    = MAKEINTRESOURCE( IDS_TITLE );
    psh.phpage              = ahpsp;
    psh.nStartPage          = 0;
    psh.nPages              = NO_OF_PAGES;
    PageInfo.TotalPages     = NO_OF_PAGES;


    //
    // Create the bold fonts.
    // 
    SetupFonts( GetInstanceHandle(), NULL, &PageInfo.hBigBoldFont, &PageInfo.hBoldFont );

    //
    // Validate all the pages.
    //
    for(i = 0; i < NO_OF_PAGES; i++ )
    {
        if( ahpsp[i] == 0 )
        {
            bStatus = FALSE;
        }
    }

    //
    // Display the wizard.
    //
    if( bStatus )
    {   
        if( PropertySheet( &psh ) == -1 )
        {
            bStatus = FALSE;
        }
    }

    if( !bStatus )
    {
        //
        // Manually destroy the pages if something failed.
        //
        for(i = 0; i < psh.nPages; i++)
        {
            if( ahpsp[i] )
            {
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }

    //
    // Destroy the fonts that were created.
    //
    DestroyFonts( PageInfo.hBigBoldFont, PageInfo.hBoldFont );

done:
	if(!bStatus)
	{
		LRMessageBox(hWndParent,IDS_ERR_CREATE_FAILED);
		dwRetCode = LRWIZ_ERROR_CREATE_FAILED;
	}

	if (dwRetCode == 0 || dwRetCode == LRWIZ_SUCCESS)
	{
		*pbRefresh = GetReFresh();
	}

	GetGlobalContext()->FreeGlobal();

    return dwRetCode;
}

VOID
SetControlFont(
    IN HFONT    hFont, 
    IN HWND     hwnd, 
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}

VOID 
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT FontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) 
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) 
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    } 
    else 
    {
        FontSize = 12;
    }

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);
    }
}

VOID 
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}

DWORD ShowProperties(HWND hWndParent)
{
	DWORD			dwRetCode = ERROR_SUCCESS;
	BOOL            bStatus             = TRUE;    
    PROPSHEETPAGE   psp                 = {0};
    HPROPSHEETPAGE  ahpsp[NO_OF_PROP_PAGES]  = {0};
    PROPSHEETHEADER psh                 = {0};
	UINT i = 0;

	//
	//Create All the pages here
	//

	// Registration Mode Page
	memset(&psp,0,sizeof(psp));
    psp.dwSize              = sizeof( psp );
    psp.dwFlags             = PSP_DEFAULT | PSP_USETITLE | PSP_PREMATURE ; 
    psp.hInstance           = GetInstanceHandle();
    psp.lParam              = NULL;	
	psp.pfnDlgProc          = PropModeDlgProc;
    psp.pszTitle			= MAKEINTRESOURCE( IDS_TITLE36 );
	psp.pszHeaderTitle		= MAKEINTRESOURCE( IDS_TITLE36 );
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_DLG_PROP_MODE);
	
    ahpsp[PG_NDX_PROP_MODE]= CreatePropertySheetPage( &psp );
	
	//Program Type Page
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT |  PSP_USETITLE | PSP_PREMATURE; 
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= NULL;
	psp.pfnDlgProc				= PropProgramDlgProc;
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE37 );
    psp.pszTitle				= MAKEINTRESOURCE( IDS_TITLE37 );
	psp.pszTemplate				= MAKEINTRESOURCE( IDD_DLG_PROP_PROGRAM);
    ahpsp[PG_NDX_PROP_PROGRAM]	= CreatePropertySheetPage( &psp );	


	// Customer Information (I) page
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT |  PSP_USETITLE | PSP_PREMATURE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= NULL;
	psp.pfnDlgProc				= PropCustInfoADlgProc;
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE38 );
	psp.pszTitle				= MAKEINTRESOURCE( IDS_TITLE38 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_DLG_PROP_CUSTINFO_a);
    ahpsp[PG_NDX_PROP_CUSTINFO_a]	= CreatePropertySheetPage( &psp );


	// Customer Information (II) page
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT |  PSP_USETITLE | PSP_PREMATURE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= NULL;
	psp.pfnDlgProc				= PropCustInfoBDlgProc;
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE39 );
	psp.pszTitle				= MAKEINTRESOURCE( IDS_TITLE39 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_DLG_PROP_CUSTINFO_b);
    ahpsp[PG_NDX_PROP_CUSTINFO_b]	= CreatePropertySheetPage( &psp );


	psh.dwFlags             = PSH_DEFAULT | PSH_PROPTITLE | PSH_NOAPPLYNOW| PSH_NOCONTEXTHELP;
    psh.dwSize              = sizeof( psh );
    psh.hInstance           = GetInstanceHandle();
    psh.hwndParent          = hWndParent;
    psh.pszCaption          = MAKEINTRESOURCE( IDS_TITLE );
    psh.phpage              = ahpsp;
    psh.nStartPage          = 0;
    psh.nPages              = NO_OF_PROP_PAGES;    
	
    //
    // Validate all the pages.
    //
    for( i = 0; i < NO_OF_PROP_PAGES; i++ )
    {
        if( ahpsp[i] == 0 )
        {
            bStatus = FALSE;
        }
    }

    //
    // Display the wizard.
    //
    if( bStatus )
    {   
        if( PropertySheet( &psh ) == -1 )
        {
            bStatus = FALSE;
        }
    }

    if( !bStatus )
    {
        //
        // Manually destroy the pages if something failed.
        //
        for(i = 0; i < psh.nPages; i++)
        {
            if( ahpsp[i] )
            {
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }    

	if(!bStatus)
	{
		LRMessageBox(hWndParent,IDS_ERR_CREATE_FAILED);
		dwRetCode = LRWIZ_ERROR_CREATE_FAILED;
	}

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\pindlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "PINDlg.h"

LRW_DLG_INT CALLBACK
PINDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	TCHAR * cwLicenseServerID;
	HWND	hwndLSID;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );					
		cwLicenseServerID = GetLicenseServerID();

  		// Get the License Server ID, provided by the License Server
		hwndLSID = GetDlgItem(hwnd, IDC_MSID);

		// Let us format the License Server ID for showing.
		SetWindowText(hwndLSID, cwLicenseServerID);
		SendDlgItemMessage (hwnd , IDC_TXT_PIN,	EM_SETLIMITTEXT, CA_PIN_LEN,0);
		
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString	sPIN;
					LPTSTR	lpVal = NULL;
					DWORD dwRetCode;
					
					lpVal = sPIN.GetBuffer(CA_PIN_LEN + 1);
					GetDlgItemText(hwnd,IDC_TXT_PIN,lpVal,CA_PIN_LEN+1);
					sPIN.ReleaseBuffer(-1);

					sPIN.TrimLeft(); sPIN.TrimRight();

					if (sPIN.IsEmpty())
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						dwNextPage	= IDD_DLG_PIN;						
					}
					else
					{				
						SetCertificatePIN((LPTSTR)(LPCTSTR)sPIN);
						dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

                        dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_PIN);
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}








LRW_DLG_INT CALLBACK
ContinueReg(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		//
		//By default Check the first RADIO button.
		//
		SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);  

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == BN_CLICKED)
		{
			switch (LOWORD(wParam))
			{
			case IDC_REG_POSTPONE:
				if (SendDlgItemMessage(hwnd, IDC_REG_POSTPONE, BM_GETCHECK, 
									(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					TCHAR szBuf[ LR_MAX_MSG_TEXT];
					LoadString(GetInstanceHandle(), IDS_ALTFINISHTEXT, szBuf,LR_MAX_MSG_TEXT);
					//PropSheet_CancelToClose(GetParent( hwnd ));
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH );
//					PropSheet_SetFinishText( GetParent( hwnd ), szBuf);
				}
				break;

			case IDC_REG_COMPLETE:
				if (SendDlgItemMessage(hwnd, IDC_REG_COMPLETE, BM_GETCHECK, 
									(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				break;

			case IDC_REG_RESTART:
				if (SendDlgItemMessage(hwnd, IDC_REG_RESTART, BM_GETCHECK, 
									(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				break;
			}
		}
		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:   
				SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);  //Fix bug# 627
				SendDlgItemMessage(hwnd,IDC_REG_POSTPONE,BM_SETCHECK,(WPARAM)BST_UNCHECKED,(LPARAM)0);  //Fix bug# 627
				SendDlgItemMessage(hwnd,IDC_REG_RESTART,BM_SETCHECK,(WPARAM)BST_UNCHECKED,(LPARAM)0);  //Fix bug# 627


				if(SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				else if (SendDlgItemMessage(hwnd,IDC_REG_POSTPONE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					TCHAR szBuf[ LR_MAX_MSG_TEXT];
					LoadString(GetInstanceHandle(), IDS_ALTFINISHTEXT, szBuf,LR_MAX_MSG_TEXT);
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH | PSWIZB_BACK);
//					PropSheet_SetFinishText( GetParent( hwnd ), szBuf);
				}
				else 
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				
//                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				if(SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					GetGlobalContext()->SetLSStatus(LSERVERSTATUS_WAITFORPIN);
					GetGlobalContext()->SetWizAction(WIZACTION_CONTINUEREGISTERLS);

					dwNextPage = IDD_DLG_PIN;
				}
				else if (SendDlgItemMessage(hwnd,IDC_REG_POSTPONE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
//					GetGlobalContext()->GetContactDataObject()->sProgramName = PROGRAM_MOLP;
//					EndDialog(hwnd);
//					PropSheet_PressButton(hwnd, PSWIZB_FINISH);
				}
				else 
				{
					// Restart
					GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
					GetGlobalContext()->SetLSStatus(LSERVERSTATUS_UNREGISTER);
					GetGlobalContext()->SetWizAction(WIZACTION_REGISTERLS);
					GetGlobalContext()->ClearWizStack();
					dwNextPage = IDD_WELCOME;
				}
				
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
				if (dwNextPage != IDD_WELCOME)
				{
					LRPush(IDD_CONTINUEREG);
				}

                break;

            case PSN_WIZBACK:
				GetGlobalContext()->SetLSStatus(LSERVERSTATUS_WAITFORPIN);
				GetGlobalContext()->SetWizAction(WIZACTION_CONTINUEREGISTERLS);
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:


Abstract:

    Precompiled header file

Author:


Revision History:

--*/
#pragma warning (disable: 4514) /* Unreferenced inline function removed     */
#pragma warning (disable: 4201) /* Nameless union/struct                    */
#pragma warning (disable: 4706) /* Assignment within conditional expression */

#include <afx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INC_OLE2
//#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <tchar.h>




#ifdef _WIN64
#define LRW_GWL_USERDATA    GWLP_USERDATA
#define LRW_DWL_MSGRESULT   DWLP_MSGRESULT
#define LRW_DLG_INT         __int64
#define LRW_LONG_PTR        LONG_PTR
#define LRW_GETWINDOWLONG   GetWindowLongPtr
#define LRW_SETWINDOWLONG   SetWindowLongPtr
#else
#define LRW_GWL_USERDATA    GWL_USERDATA
#define LRW_DWL_MSGRESULT   DWL_MSGRESULT
#define LRW_DLG_INT         INT
#define LRW_LONG_PTR        LONG
#define LRW_GETWINDOWLONG   GetWindowLong
#define LRW_SETWINDOWLONG   SetWindowLong
#endif




#include "lrwizdll.h"
#include "resource.h"
#include "def.h"
#include "utils.h"
#include "dlgproc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\pindlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _PINDLG_H_
#define _PINDLG_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\propdlgs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _PROP_DLGS_H_
#define _PROP_DLGS_H_

LRW_DLG_INT CALLBACK 
PropModeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
PropProgramDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
PropCustInfoADlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
PropCustInfoBDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

#endif //_PROP_DLGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\propdlgs.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "propdlgs.h"

LRW_DLG_INT CALLBACK 
PropModeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	DWORD	dwRetCode = ERROR_SUCCESS;	
	BOOL	bStatus = TRUE;    	

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			TCHAR		lpBuffer[ 512];			
			LVFINDINFO	lvFindInfo;
			int			nItem = 0;

			HWND	hWndComboBox = GetDlgItem(hwnd,IDC_COMBO_MODE);
			HWND	hWndListBox = GetDlgItem(hwnd, IDC_COUNTRYREGION );		

			{
				LV_COLUMN	lvColumn;
				TCHAR		lpszHeader[ 128];
				
				lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
				lvColumn.fmt = LVCFMT_LEFT;
				lvColumn.cx  = 250;

				LoadString(GetInstanceHandle(), IDS_COUNTRYREGION_HEADER, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
				lvColumn.pszText = lpszHeader;
				ListView_InsertColumn(hWndListBox, 0, &lvColumn);

				lvColumn.pszText = _TEXT("");
				lvColumn.cx = 0;
				ListView_InsertColumn(hWndListBox, 1, &lvColumn);
			}				

			memset(lpBuffer,0,sizeof(lpBuffer));
			dwRetCode = LoadString(GetInstanceHandle(), IDS_INTERNETMODE, lpBuffer, 512);
			ComboBox_AddString(hWndComboBox,lpBuffer);		

			memset(lpBuffer,0,sizeof(lpBuffer));		
			dwRetCode = LoadString(GetInstanceHandle(), IDS_WWWMODE, lpBuffer, 512);				
			ComboBox_AddString(hWndComboBox,lpBuffer);

			memset(lpBuffer,0,sizeof(lpBuffer));
			dwRetCode = LoadString(GetInstanceHandle(), IDS_TELEPHONEMODE, lpBuffer, 512);
			ComboBox_AddString(hWndComboBox,lpBuffer);		

			//
			// Set the Current Activation Method
			//
			GetGlobalContext()->SetLSProp_ActivationMethod(GetGlobalContext()->GetActivationMethod());

			ListView_DeleteAllItems(GetDlgItem(hwnd, IDC_COUNTRYREGION));

			if(GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET ||
			   GetGlobalContext()->GetActivationMethod() == CONNECTION_DEFAULT)
			{
				ComboBox_SetCurSel(hWndComboBox, 0);

				EnableWindow(GetDlgItem(hwnd,IDC_LBL_COUNTRYREGION),FALSE);
				EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION),FALSE);
			}

			if(GetGlobalContext()->GetActivationMethod() == CONNECTION_WWW )
			{
				ComboBox_SetCurSel(hWndComboBox, 1);

				EnableWindow(GetDlgItem(hwnd,IDC_LBL_COUNTRYREGION),FALSE);
				EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION),FALSE);
			}	

			if(GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE )
			{
				ComboBox_SetCurSel(hWndComboBox, 2);

				EnableWindow(GetDlgItem(hwnd,IDC_LBL_COUNTRYREGION),TRUE);
				EnableWindow(hWndListBox,TRUE);

				dwRetCode = PopulateCountryRegionComboBox(hWndListBox);
				if (dwRetCode != ERROR_SUCCESS)
				{					
					LRMessageBox(hwnd, dwRetCode, LRGetLastError());
				}

				memset(&lvFindInfo,0,sizeof(lvFindInfo));
				lvFindInfo.flags = LVFI_STRING;
				lvFindInfo.psz	 = GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion;

				nItem = ListView_FindItem(hWndListBox,-1,&lvFindInfo);				
				
				
				ListView_SetItemState(hWndListBox,nItem,LVIS_SELECTED,LVIS_SELECTED);
				ListView_SetSelectionMark(hWndListBox,nItem);
				ListView_SetSelectionMark(hWndListBox,nItem);
			}			
		}
		break;


	case WM_COMMAND:
		if(HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_COMBO_MODE)
		{
			LVFINDINFO	lvFindInfo;
			int			nItem = 0;

			HWND	hWndListBox = GetDlgItem(hwnd, IDC_COUNTRYREGION );
			HWND	hWndComboBox = GetDlgItem(hwnd,IDC_COMBO_MODE);

			SetReFresh(1);
			dwRetCode = ComboBox_GetCurSel((HWND)lParam);

			ListView_DeleteAllItems(hWndListBox);

			//Enable Country/Region List Box in case of Telephone
			if(dwRetCode == 2)
			{
				EnableWindow(GetDlgItem(hwnd,IDC_LBL_COUNTRYREGION),TRUE);
				EnableWindow(hWndListBox,TRUE);

                GetGlobalContext()->SetLSProp_ActivationMethod(CONNECTION_PHONE);

                dwRetCode = PopulateCountryRegionComboBox(hWndListBox);
                if (dwRetCode != ERROR_SUCCESS)
                {					
                    LRMessageBox(hwnd, dwRetCode, LRGetLastError());
                }

                memset(&lvFindInfo,0,sizeof(lvFindInfo));
                lvFindInfo.flags = LVFI_STRING;
                lvFindInfo.psz	 = GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion;
                
                nItem = ListView_FindItem(hWndListBox,-1,&lvFindInfo);		 
                
					
                ListView_SetItemState(hWndListBox,nItem,LVIS_SELECTED,LVIS_SELECTED);
                ListView_SetSelectionMark(hWndListBox,nItem);
                ListView_SetSelectionMark(hWndListBox,nItem);

			}
			else
			{
				if(dwRetCode == 0) // Internet
				{
					GetGlobalContext()->SetLSProp_ActivationMethod(CONNECTION_INTERNET);
				}
				else
				{
					GetGlobalContext()->SetLSProp_ActivationMethod(CONNECTION_WWW);	
				}

				EnableWindow(GetDlgItem(hwnd,IDC_LBL_COUNTRYREGION),FALSE);
				EnableWindow(hWndListBox,FALSE);
			}			
		}

		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
                break;
            
			case PSN_APPLY:
				{
					HWND	hWndComboBox = GetDlgItem(hwnd,IDC_COMBO_MODE);
					HWND	hWndListBox = GetDlgItem(hwnd, IDC_COUNTRYREGION );

					long	lReturnStatus = PSNRET_NOERROR;

					TCHAR	szItemText[255];
					int		nItem = 0;

					dwRetCode = ComboBox_GetCurSel(hWndComboBox);
					assert(dwRetCode >= 0 && dwRetCode <= 2);

					//Internet
					if(dwRetCode == 0)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_INTERNET);
					}

					// WWW
					if(dwRetCode == 1)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_WWW);						
					}

					// Phone
					if(dwRetCode == 2)
					{
						TCHAR lpVal[ 128];

						GetGlobalContext()->SetActivationMethod(CONNECTION_PHONE);

						nItem = ListView_GetSelectionMark(hWndListBox);

						if(nItem == -1)
						{
							LRMessageBox(hwnd, IDS_ERR_NOCOUNTRYSELECTED, 0);
							lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
							goto done;
						}

						ListView_GetItemText(hWndListBox,nItem,0,szItemText,sizeof(szItemText)/sizeof(TCHAR));

						GetGlobalContext()->SetInRegistery(REG_LRWIZ_CSPHONEREGION,szItemText);


						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 1;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = 128;

						ListView_GetItem(hWndListBox, &lvItem);				
						GetGlobalContext()->SetCSRNumber(lpVal);
					}

done:
					if(lReturnStatus != PSNRET_NOERROR)
						PropSheet_SetCurSel(GetParent(hwnd),NULL,PG_NDX_PROP_MODE);

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, lReturnStatus);
				}
				break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


LRW_DLG_INT CALLBACK
PropProgramDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	
    BOOL	bStatus = TRUE;   
	static BOOL bIsFirstTime = TRUE ; //Ignore the first click in the radio buttons (solve Bug #439)
	static int iSelectedOption = IDC_RD_REG_SELECT;

    switch (uMsg) 
    {
    case WM_INITDIALOG:       
		{
			TCHAR szBuffer[ 1024];
			bIsFirstTime = TRUE ;
			if(GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_SELECT)
			{
				SendDlgItemMessage(hwnd,IDC_RD_REG_SELECT,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);
				LoadString(GetInstanceHandle(), IDS_SELECT_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				SetFocus(GetDlgItem(hwnd, IDC_RD_REG_SELECT));
				iSelectedOption = IDC_RD_REG_SELECT;
			}
			else if(GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_MOLP)
			{
				SendDlgItemMessage(hwnd,IDC_RD_REG_MOLP,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);
				LoadString(GetInstanceHandle(), IDS_OPEN_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				SetFocus(GetDlgItem(hwnd, IDC_RD_REG_MOLP));
				iSelectedOption = IDC_RD_REG_MOLP;
			}
			else if(GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_RETAIL)
			{
				SendDlgItemMessage(hwnd,IDC_RD_REG_OTHER,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);	
				LoadString(GetInstanceHandle(), IDS_OTHER_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				SetFocus(GetDlgItem(hwnd, IDC_RD_REG_OTHER));
				iSelectedOption = IDC_RD_REG_OTHER;
			}
			else	//By default Check the first RADIO button.		
			{
				SendDlgItemMessage(hwnd,IDC_RD_REG_SELECT,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);  
				LoadString(GetInstanceHandle(), IDS_SELECT_DESCRIPTION,
						   szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
				SendDlgItemMessage(hwnd, IDC_DESCRIPTION,
								   WM_SETTEXT,(WPARAM)0,
								   (LPARAM)(LPCTSTR)szBuffer);
				SetFocus(GetDlgItem(hwnd, IDC_RD_REG_SELECT));
				iSelectedOption = IDC_RD_REG_SELECT;
			}
		}
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == BN_CLICKED)
		{
			TCHAR szBuffer[ 1024];

			
			
				switch ( LOWORD(wParam) )       //from which control
				{
				case IDC_RD_REG_SELECT:
					if (bIsFirstTime == TRUE){ //Ignore the first click (solve Bug #439)					
						SetFocus(GetDlgItem(hwnd, iSelectedOption));				
					}
					else
					{
						LoadString(GetInstanceHandle(), IDS_SELECT_DESCRIPTION, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
						SendDlgItemMessage(hwnd, IDC_DESCRIPTION, WM_SETTEXT,(WPARAM)0, (LPARAM)(LPCTSTR)szBuffer);					
					}
					break;

				case IDC_RD_REG_MOLP:
					LoadString(GetInstanceHandle(), IDS_OPEN_DESCRIPTION, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
					SendDlgItemMessage(hwnd, IDC_DESCRIPTION, WM_SETTEXT,(WPARAM)0, (LPARAM)(LPCTSTR)szBuffer);					
					break;

				case IDC_RD_REG_OTHER:
					LoadString(GetInstanceHandle(), IDS_OTHER_DESCRIPTION, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
					SendDlgItemMessage(hwnd, IDC_DESCRIPTION, WM_SETTEXT,(WPARAM)0, (LPARAM)(LPCTSTR)szBuffer);					
					break;
				}
				bIsFirstTime = FALSE ;			
		}
		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                                    
                break;
			case PSN_APPLY:
				{
					if(SendDlgItemMessage(hwnd,IDC_RD_REG_SELECT,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
					{
						GetGlobalContext()->SetInRegistery(szOID_BUSINESS_CATEGORY,PROGRAM_SELECT);
						//GetGlobalContext()->SetEncodedInRegistry(szOID_BUSINESS_CATEGORY,PROGRAM_SELECT);
					}
					else if (SendDlgItemMessage(hwnd,IDC_RD_REG_MOLP,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
					{
						GetGlobalContext()->SetInRegistery(szOID_BUSINESS_CATEGORY,PROGRAM_MOLP);
					}
					else 
					{
						GetGlobalContext()->SetInRegistery(szOID_BUSINESS_CATEGORY,PROGRAM_RETAIL);
					}
				}
				break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

LRW_DLG_INT CALLBACK
PropCustInfoADlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   	
    BOOL	bStatus = TRUE;    

    switch (uMsg) 
    {
    case WM_INITDIALOG:        

		SendDlgItemMessage (hwnd , IDC_TXT_COMPANYNAME,	EM_SETLIMITTEXT, CA_COMPANY_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_ORGUNIT	  ,	EM_SETLIMITTEXT, CA_ORG_UNIT_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_LNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_PHONE,	EM_SETLIMITTEXT, CA_PHONE_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_EMAIL,	EM_SETLIMITTEXT, CA_EMAIL_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FAX,		EM_SETLIMITTEXT, CA_FAX_LEN,0);

		//
		//Populate the values which were read from the Registry during Global Init
		//	
		//
		//Populate the values which were read from the Registry during Global Init
		//
		SetDlgItemText(hwnd,IDC_TXT_LNAME, GetGlobalContext()->GetContactDataObject()->sContactLName);
		SetDlgItemText(hwnd,IDC_TXT_FNAME, GetGlobalContext()->GetContactDataObject()->sContactFName);
		SetDlgItemText(hwnd,IDC_TXT_PHONE, GetGlobalContext()->GetContactDataObject()->sContactPhone);
		SetDlgItemText(hwnd,IDC_TXT_FAX,   GetGlobalContext()->GetContactDataObject()->sContactFax);
		SetDlgItemText(hwnd,IDC_TXT_EMAIL, GetGlobalContext()->GetContactDataObject()->sContactEmail);
		SetDlgItemText(hwnd,IDC_TXT_COMPANYNAME, GetGlobalContext()->GetContactDataObject()->sCompanyName);
		SetDlgItemText(hwnd,IDC_TXT_ORGUNIT, GetGlobalContext()->GetContactDataObject()->sOrgUnit);

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:				
				{
					TCHAR szBuf[ 255];

                    LoadString(GetInstanceHandle(),IDS_FAXOPTION_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));

					SetDlgItemText(hwnd, IDC_LBL_FAX, szBuf);

					if (GetGlobalContext()->GetLSProp_ActivationMethod() == CONNECTION_INTERNET)
					{
						LoadString(GetInstanceHandle(),IDS_EMAIL_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));
					}
					else
					{
						LoadString(GetInstanceHandle(),IDS_EMAILOPTION_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));
					}

					SetDlgItemText(hwnd, IDC_LBL_EMAIL, szBuf);
				}
                break;

			case PSN_APPLY:
				{
					CString sCompanyName;
					CString sOrgUnit;
					CString sLastName;
					CString sFirstName;
					CString sPhone;
					CString sFax;
					CString sEmail;
					LPTSTR  lpVal = NULL;					

					long	lReturnStatus = PSNRET_NOERROR;

					//Read all the fields
					lpVal = sCompanyName.GetBuffer(CA_COMPANY_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_COMPANYNAME,lpVal,CA_COMPANY_NAME_LEN+1);
					sCompanyName.ReleaseBuffer(-1);

					lpVal = sOrgUnit.GetBuffer(CA_ORG_UNIT_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ORGUNIT,lpVal,CA_ORG_UNIT_LEN+1);
					sOrgUnit.ReleaseBuffer(-1);

					lpVal = sLastName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_LNAME,lpVal,CA_NAME_LEN+1);
					sLastName.ReleaseBuffer(-1);
					
					lpVal = sFirstName.GetBuffer(CA_NAME_LEN+1);
	 				GetDlgItemText(hwnd,IDC_TXT_FNAME,lpVal,CA_NAME_LEN+1);
					sFirstName.ReleaseBuffer(-1);

					lpVal = sPhone.GetBuffer(CA_PHONE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_PHONE,lpVal,CA_PHONE_LEN+1);
					sPhone.ReleaseBuffer(-1);

					lpVal = sFax.GetBuffer(CA_FAX_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_FAX,lpVal,CA_FAX_LEN+1);
					sFax.ReleaseBuffer(-1);

					lpVal = sEmail.GetBuffer(CA_EMAIL_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_EMAIL,lpVal,CA_EMAIL_LEN+1);
					sEmail.ReleaseBuffer(-1);

					sFirstName.TrimLeft();   sFirstName.TrimRight();
					sLastName.TrimLeft();   sLastName.TrimRight();
					sPhone.TrimLeft();   sPhone.TrimRight(); 
					sFax.TrimLeft();   sFax.TrimRight(); 
					sEmail.TrimLeft();	 sEmail.TrimRight();
					sCompanyName.TrimLeft(); sCompanyName.TrimRight();
					sOrgUnit.TrimLeft(); sOrgUnit.TrimRight();
					
					if(sLastName.IsEmpty() || sFirstName.IsEmpty() || sCompanyName.IsEmpty() ||
					  (sEmail.IsEmpty()  && GetGlobalContext()->GetLSProp_ActivationMethod() == CONNECTION_INTERNET))
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}
					
					//
					// Check for the Invalid Characters
					//
					if( !ValidateLRString(sFirstName)	||
						!ValidateLRString(sLastName)	||
						!ValidateLRString(sPhone)		||
						!ValidateLRString(sEmail)		||
						!ValidateLRString(sFax)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}										
					
					//
					// Validate email address if not empty
					//
					if(!sEmail.IsEmpty())
					{
						if(!ValidateEmailId(sEmail))
						{
							LRMessageBox(hwnd,IDS_ERR_INVALID_EMAIL);
							lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
							goto done;
						}						
					}					

					// Put into regsitery too
					GetGlobalContext()->SetInRegistery(szOID_RSA_emailAddr, (LPCTSTR) sEmail);
					GetGlobalContext()->SetInRegistery(szOID_COMMON_NAME, sFirstName);
					GetGlobalContext()->SetInRegistery(szOID_SUR_NAME, sLastName);
					GetGlobalContext()->SetInRegistery(szOID_TELEPHONE_NUMBER, sPhone);
					GetGlobalContext()->SetInRegistery(szOID_FACSIMILE_TELEPHONE_NUMBER, sFax);
					GetGlobalContext()->SetInRegistery(szOID_ORGANIZATION_NAME, sCompanyName);
					GetGlobalContext()->SetInRegistery(szOID_ORGANIZATIONAL_UNIT_NAME, sOrgUnit);
done:
					if(lReturnStatus != PSNRET_NOERROR)
						PropSheet_SetCurSel(GetParent(hwnd),NULL,PG_NDX_PROP_CUSTINFO_a);

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, lReturnStatus);
				}
				break;
            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


LRW_DLG_INT CALLBACK
PropCustInfoBDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   	
    BOOL	bStatus = TRUE;    
    CString sCountryDesc;

    switch (uMsg) 
    {
    case WM_INITDIALOG:        

		SendDlgItemMessage (hwnd , IDC_TXT_ADDRESS1,	EM_SETLIMITTEXT, CA_ADDRESS_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_CITY,		EM_SETLIMITTEXT, CA_CITY_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_STATE,		EM_SETLIMITTEXT, CA_STATE_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_ZIP,			EM_SETLIMITTEXT, CA_ZIP_LEN,0); 	
		
		
		PopulateCountryComboBox(GetDlgItem(hwnd,IDC_COMBO1));

		//
		//Populate the values which were read from the Registry during Global Init
		//
		SetDlgItemText(hwnd,IDC_TXT_ADDRESS1, GetGlobalContext()->GetContactDataObject()->sContactAddress);
		SetDlgItemText(hwnd,IDC_TXT_CITY	, GetGlobalContext()->GetContactDataObject()->sCity);
		SetDlgItemText(hwnd,IDC_TXT_STATE	, GetGlobalContext()->GetContactDataObject()->sState);
		SetDlgItemText(hwnd,IDC_TXT_ZIP		, GetGlobalContext()->GetContactDataObject()->sZip);

        GetCountryDesc(
                       GetGlobalContext()->GetContactDataObject()->sCountryCode,
                       sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1));
        sCountryDesc.ReleaseBuffer();

		ComboBox_SetCurSel(
                    GetDlgItem(hwnd,IDC_COMBO1),
                    ComboBox_FindStringExact(
                                    GetDlgItem(hwnd,IDC_COMBO1),
                                    0,
                                    (LPCTSTR)sCountryDesc));

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                          
                break;
			case PSN_APPLY:
				{
					LPTSTR  lpVal = NULL;
					CString sAddress1;
					CString sCity;
					CString sState;					
					CString sZip;
					CString sCountryDesc;
					CString sCountryCode;
					int		nCurSel = -1;

					long	lReturnStatus = PSNRET_NOERROR;

					//
					//Read all the fields
					//
					lpVal = sAddress1.GetBuffer(CA_ADDRESS_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ADDRESS1,lpVal,CA_ADDRESS_LEN+1);
					sAddress1.ReleaseBuffer(-1);
					
					lpVal = sCity.GetBuffer(CA_CITY_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_CITY,lpVal,CA_CITY_LEN+1);
					sCity.ReleaseBuffer(-1);

					lpVal = sState.GetBuffer(CA_STATE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_STATE,lpVal,CA_STATE_LEN+1);
					sState.ReleaseBuffer(-1);

					lpVal = sZip.GetBuffer(CA_ZIP_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ZIP,lpVal,CA_ZIP_LEN+1);
					sZip.ReleaseBuffer(-1);

			
					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_COMBO1));

					lpVal = sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_COMBO1), nCurSel, lpVal);
					sCountryDesc.ReleaseBuffer(-1);
					
					sAddress1.TrimLeft(); sAddress1.TrimRight();
					sCity.TrimLeft(); sCity.TrimRight();
					sState.TrimLeft(); sState.TrimRight();
					sZip.TrimLeft(); sZip.TrimRight();
					sCountryDesc.TrimLeft();sCountryDesc.TrimRight();					

					if(
					   !ValidateLRString(sAddress1)	||
					   !ValidateLRString(sCity)		||
					   !ValidateLRString(sState)	||
					   !ValidateLRString(sZip)		||
					   !ValidateLRString(sCountryDesc)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}

					if (sCountryDesc.IsEmpty()) 
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}

					lpVal = sCountryCode.GetBuffer(LR_COUNTRY_CODE_LEN+1);
					GetCountryCode(sCountryDesc,lpVal);
					sCountryCode.ReleaseBuffer(-1);

					GetGlobalContext()->SetInRegistery(szOID_LOCALITY_NAME, sCity);
					GetGlobalContext()->SetInRegistery(szOID_COUNTRY_NAME, sCountryDesc);
					GetGlobalContext()->SetInRegistery(szOID_DESCRIPTION, sCountryCode);
					GetGlobalContext()->SetInRegistery(szOID_STREET_ADDRESS, sAddress1);
					GetGlobalContext()->SetInRegistery(szOID_POSTAL_CODE, sZip);
					GetGlobalContext()->SetInRegistery(szOID_STATE_OR_PROVINCE_NAME, sState);
done:
					if(lReturnStatus != PSNRET_NOERROR)
						PropSheet_SetCurSel(GetParent(hwnd),NULL,PG_NDX_PROP_CUSTINFO_b);

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, lReturnStatus);
				}
				break;
            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\progress.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "commdlg.h"

LRW_DLG_INT CALLBACK 
ProgressDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

			//
			//Set the Font for the Title Fields
			//
			SetControlFont( pi->hBigBoldFont, hwnd, IDC_BIGBOLDTITLE);	    			
		}
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == IDC_NEXTACTION)
		{

			if (SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_GETCHECK, 
								(WPARAM)0,(LPARAM)0) == BST_CHECKED)
			{
				PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT);
			}
			else
			{
				PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
			}
		}
		break;

    case WM_NOTIFY:
        {
			DWORD	dwNextPage = 0;
            LPNMHDR pnmh = (LPNMHDR)lParam;
		
            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
				{
					DWORD	dwRetCode	= 0;
					DWORD	dwErrorCode = 0;
					TCHAR	szBuf[LR_MAX_MSG_TEXT];
					TCHAR	szMsg[LR_MAX_MSG_TEXT];

					dwRetCode = LRGetLastRetCode();

					//
					// If everything successful, display the message depending
					// on the Mode
					//			
					SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_SETCHECK,
						   (WPARAM)BST_UNCHECKED,(LPARAM)0);
					ShowWindow(GetDlgItem(hwnd, IDC_NEXTACTION), SW_HIDE);
					ShowWindow(GetDlgItem(hwnd, IDC_BTN_PRINT), SW_HIDE);

					if (dwRetCode == ERROR_SUCCESS)
					{
						LoadString(GetInstanceHandle(), IDS_FINALSUCCESSMESSAGE, szBuf,LR_MAX_MSG_TEXT);
						SetDlgItemText(hwnd, IDC_MESSAGE, szBuf);

                        switch (GetGlobalContext()->GetWizAction())
                        {
							case WIZACTION_CONTINUEREGISTERLS:
							case WIZACTION_REGISTERLS:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT);
								ShowWindow(GetDlgItem(hwnd, IDC_NEXTACTION), SW_SHOW);
								dwRetCode = IDS_MSG_CERT_INSTALLED;
								SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_SETCHECK,
									   (WPARAM)BST_CHECKED,(LPARAM)0);
								SetReFresh(1);
								break;

							case WIZACTION_DOWNLOADLKP:
                            case WIZACTION_DOWNLOADLASTLKP:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								dwRetCode = IDS_MSG_LKP_PROCESSED;
								SetReFresh(1);
								break;

							case WIZACTION_REREGISTERLS:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								dwRetCode = IDS_MSG_CERT_REISSUED;
								SetReFresh(1);
								break;

							case WIZACTION_UNREGISTERLS:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								dwRetCode = IDS_MSG_CERT_REVOKED;
								SetReFresh(1);
								break;

							default:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								break;
                        }

                        SetLRState(LRSTATE_NEUTRAL);

						LoadString(GetInstanceHandle(),dwRetCode,szMsg,LR_MAX_MSG_TEXT);
					}
					else //Include the Error code , if any ,in the msg 
					{
						LoadString(GetInstanceHandle(), IDS_FINALFAILMESSAGE, szBuf,LR_MAX_MSG_TEXT);
						SetDlgItemText(hwnd, IDC_MESSAGE, szBuf);

						LoadString(GetInstanceHandle(),dwRetCode,szBuf,LR_MAX_MSG_TEXT);
						dwErrorCode = LRGetLastError();
						if( dwErrorCode != 0)
						{
							_stprintf(szMsg,szBuf,dwErrorCode);
						}
						else
						{
							_tcscpy(szMsg,szBuf);
						}

						//Enable Back button in case of error
//						LRPop();
						PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_BACK);
					}		

					SetDlgItemText(hwnd,IDC_EDIT1,szMsg);						
				}				
                break;

            case PSN_WIZNEXT:				
				if (SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_GETCHECK,
								       (WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					switch (GetGlobalContext()->GetWizAction())
					{
					case WIZACTION_REGISTERLS:
					case WIZACTION_CONTINUEREGISTERLS:
						// Go to Obtain LKPs
						// Go to the PIN screen
						DWORD dwStatus;
						DWORD dwRetCode = GetGlobalContext()->GetLSCertificates(&dwStatus);

						// Error Handling $$BM

						GetGlobalContext()->ClearWizStack();
						dwNextPage = IDD_WELCOME;

						if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
						{
							GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
							GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_INTERNET);
						}
						else
						{
							GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
							GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_OTHER);
						}
						GetGlobalContext()->SetWizAction(WIZACTION_DOWNLOADLKP);
						break;
					}
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
	            break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\retail.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include <commctrl.h>
#include "utils.h"
//#include <assert.h>

extern HINSTANCE g_hInstance;

void SetDeleteKeyStatus(int iValue) ;
int GetDeleteKeyStatus(void) ;

void MoveCaretRetail(int nID, HWND  hwnd )
{
	POINT Pt;
	int iCaretIndex  ;
	DWORD	dwNext = 0;	
	TCHAR tcUserValue[ CHARS_IN_BATCH + 1];
	DWORD dwLen ;


	GetCaretPos(&Pt); 
	iCaretIndex = (int) SendMessage(GetDlgItem(hwnd,nID), EM_CHARFROMPOS, 0, MAKELPARAM(Pt.x, Pt.y));

	GetDlgItemText(hwnd,nID, tcUserValue, CHARS_IN_BATCH+1);
	dwLen = _tcslen(tcUserValue);

	switch(iCaretIndex)
	{

	case 0: //Move to left edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_RETAILSPK2:		
				dwNext = IDC_RETAILSPK1;
			break ;

			case IDC_RETAILSPK3:		
				dwNext = IDC_RETAILSPK2;
			break ;


			case IDC_RETAILSPK4:		
				dwNext = IDC_RETAILSPK3;
			break ;

			case IDC_RETAILSPK5:		
				dwNext = IDC_RETAILSPK4;
			break ;			
		}
		


		if (dwNext != -1 && dwLen == 0 && GetDeleteKeyStatus() == 0)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_END,0);
		}
		break;

	case 5: //Move to right edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_RETAILSPK1:		
				dwNext = IDC_RETAILSPK2;
			break ;

			case IDC_RETAILSPK2:		
				dwNext = IDC_RETAILSPK3;
			break ;

			case IDC_RETAILSPK3:
				dwNext = IDC_RETAILSPK4;
			break ;

			case IDC_RETAILSPK4:
				dwNext = IDC_RETAILSPK5;
			break ;
		}

		if (dwNext != -1)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_HOME,0);
		}
		break;
	}

}



LRW_DLG_INT CALLBACK 
RetailSPKProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
	HWND	hWndListView = GetDlgItem(hwnd, IDC_RETAILSPKLIST );
	HWND	hSPKField = GetDlgItem(hwnd, IDC_RETAILSPK1);

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

	int lo = LOWORD(wParam);
	int hi = HIWORD(wParam);

	if(hi == 1)
	{
		int b = 0;
	}

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );     
		SendDlgItemMessage (hwnd, IDC_RETAILSPK1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);		

		//Setup columns in list view
		{
			LV_COLUMN	lvColumn;
			TCHAR		lpszHeader[ 128];
			
			lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
			lvColumn.fmt = LVCFMT_LEFT;
			lvColumn.cx  = 225;

			LoadString(GetInstanceHandle(), IDS_RETAIL_HEADERSPK, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndListView, 0, &lvColumn);

			lvColumn.cx  = 150;
			LoadString(GetInstanceHandle(), IDS_RETAIL_HEADERSTATUS, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndListView, 1, &lvColumn);

			// Now that this is done, pre-populate the List Control from the Internal
			// List, if any
 			ListView_SetItemCount(hWndListView, MAX_RETAILSPKS_IN_BATCH);
		}
        break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			// List is being shown
			// Clean-it up & Load the list view
			ListView_DeleteAllItems(hWndListView);
			LoadFromList(hWndListView);
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaretRetail(LOWORD(wParam), hwnd ) ;		
			
		}

		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		else
		{
			switch ( LOWORD(wParam) )		//from which control
			{	
			case IDC_ADDBUTTON:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					TCHAR lpVal[ LR_RETAILSPK_LEN+1];

					GetDlgItemText(hwnd,IDC_RETAILSPK1, lpVal, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK2, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK3, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK4, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK5, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					
					if ((dwRetCode=AddRetailSPKToList(hWndListView, lpVal)) != ERROR_SUCCESS)
					{					
						// Could not validate the SPK because of SOME reason
						LRMessageBox(hwnd,dwRetCode);

						if(dwRetCode == IDS_ERR_TOOMANYSPK)
						{
							// Blank out the field & continue
							SetDlgItemText(hwnd, IDC_RETAILSPK1, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK2, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK3, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK4, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK5, _TEXT(""));
						}
					}
					else
					{

						// Blank out the field & continue
						SetDlgItemText(hwnd, IDC_RETAILSPK1, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK2, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK3, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK4, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK5, _TEXT(""));
					}
					SetFocus(hSPKField);
				}
				break;

			case IDC_DELETEBUTTON:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					TCHAR lpVal[ LR_RETAILSPK_LEN+1];
					int nItem = ListView_GetSelectionMark(hWndListView);

					if (nItem != -1)
					{
						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 0;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = LR_RETAILSPK_LEN+1;

						ListView_GetItem(hWndListView, &lvItem);

						// Something is selected, Delete it
						ListView_DeleteItem(hWndListView, nItem);

						DeleteRetailSPKFromList(lvItem.pszText);

						ListView_SetSelectionMark(hWndListView, -1);
					}
					SetFocus(hSPKField);
				}
				break;

			case IDC_EDITBUTTON:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					CString sModifiedRetailSPK;
					TCHAR lpVal[ LR_RETAILSPK_LEN+1];
					int nItem = ListView_GetSelectionMark(hWndListView);

					if (nItem != -1 )
					{
						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 0;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = LR_RETAILSPK_LEN+1;

						ListView_GetItem(hWndListView, &lvItem);
						
						SetModifiedRetailSPK(lvItem.pszText);
					
						//Show dialog box to Edit the SPK
						if ( DialogBox ( GetInstanceHandle(),
										 MAKEINTRESOURCE(IDD_EDIT_RETAILSPK),
										 hwnd,
										 EditRetailSPKDlgProc
										 ) == IDOK )
						{
							//Get the modified SPK
							GetModifiedRetailSPK(sModifiedRetailSPK);
							ModifyRetailSPKFromList(lvItem.pszText,(LPTSTR)(LPCTSTR)sModifiedRetailSPK);
							ListView_SetItemText(hWndListView,nItem,0,(LPTSTR)(LPCTSTR)sModifiedRetailSPK);						
						}
						ListView_SetSelectionMark(GetDlgItem(hwnd,IDC_RETAILSPKLIST),-1);
					}
					SetFocus(hSPKField);
					
				}
			}
		}
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
		{
			BOOL  bGoNextPage = TRUE ;
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				{
					DWORD dwStyle = BS_DEFPUSHBUTTON|BS_CENTER|BS_VCENTER|BS_NOTIFY|WS_GROUP;
					SendDlgItemMessage (hwnd, IDC_ADDBUTTON, BM_SETSTYLE,(WPARAM)LOWORD(dwStyle), MAKELPARAM(TRUE, 0));
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
				}
                break;

            case PSN_WIZNEXT:
				TCHAR lpVal[ LR_RETAILSPK_LEN+1];
				DWORD dwRetCode;				

				if (GetFocus() == GetDlgItem(hwnd,IDC_ADDBUTTON)) //Fix bug #312
				{
					bGoNextPage = FALSE;
				}

				// Read the SPK from the Field
				GetDlgItemText(hwnd,IDC_RETAILSPK1, lpVal, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK2, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK3, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK4, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK5, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);

				if (lstrlen(lpVal) != 0)
				{
					dwRetCode = AddRetailSPKToList(hWndListView, lpVal);					
					if (dwRetCode != IDS_ERR_TOOMANYSPK && dwRetCode != ERROR_SUCCESS)
					{
						// Could not validate the SPK because of SOME reason
						dwNextPage = IDD_DLG_RETAILSPK;
						LRMessageBox(hwnd, dwRetCode);
						SetFocus(hSPKField);
					}
					else
					{
						SetDlgItemText(hwnd, IDC_RETAILSPK1, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK2, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK3, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK4, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK5, _TEXT(""));

						
						if (bGoNextPage == FALSE)
						{
							dwNextPage = IDD_DLG_RETAILSPK;
							SetFocus(hSPKField);
						}
						else
							dwNextPage = IDD_PROGRESS;
					}
				}
				else if (ListView_GetItemCount(hWndListView) <= 0)
				{
					LRMessageBox(hwnd, IDS_NOSPKSTOPROCESS);	
					dwNextPage = IDD_DLG_RETAILSPK;
				}
				else 
				{
					dwNextPage = IDD_PROGRESS;
//					LRPush(IDD_DLG_RETAILSPK);
				}

				if (dwNextPage == IDD_PROGRESS)
				{
                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

					LRPush( IDD_DLG_RETAILSPK );
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;                
                break;
			
			case NM_KILLFOCUS:
				if(pnmh->idFrom == IDC_RETAILSPKLIST && GetFocus() != GetDlgItem(hwnd,IDC_ADDBUTTON) &&
				     GetFocus() != GetDlgItem(hwnd,IDC_EDITBUTTON) && GetFocus() != GetDlgItem(hwnd,IDC_DELETEBUTTON))
				{
					ListView_SetSelectionMark(GetDlgItem(hwnd,IDC_RETAILSPKLIST),-1);
				}
				break;
            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


LRW_DLG_INT CALLBACK EditRetailSPKDlgProc(  IN HWND hwndDlg,  // handle to dialog box
											IN UINT uMsg,     // message  
											IN WPARAM wParam, // first message parameter
											IN LPARAM lParam  // second message parameter
										 )
{
	BOOL	bRetCode = FALSE;
	TCHAR lpVal[ LR_RETAILSPK_LEN+1];
	
	
	switch ( uMsg )
	{
	case WM_INITDIALOG:
		{
			CString sFullRetailSPK;
			CString sSPK1,sSPK2,sSPK3,sSPK4,sSPK5;
			int		nIndex = 0;
			
			LPTSTR	lpVal = NULL;

			sFullRetailSPK.Empty();
			sSPK1.Empty();
			sSPK2.Empty();
			sSPK3.Empty();
			sSPK4.Empty();
			sSPK5.Empty();

			GetModifiedRetailSPK(sFullRetailSPK);

			sSPK1 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK2 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK3 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK4 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK5 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);

			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);

			SetDlgItemText(hwndDlg, IDC_RETAILSPK1, sSPK1);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK2, sSPK2);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK3, sSPK3);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK4, sSPK4);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK5, sSPK5);

			bRetCode = TRUE;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaretRetail(LOWORD(wParam), hwndDlg ) ;		
			
		}

		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		else
		{
			switch ( LOWORD(wParam) )		//from which control
			{
			case IDOK:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					DWORD dwRetCode = ERROR_SUCCESS;
					CString sOldRetailSPK;

					GetModifiedRetailSPK(sOldRetailSPK);

					GetDlgItemText(hwndDlg,IDC_RETAILSPK1, lpVal, CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK2, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK3, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK4, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK5, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);

					//Set the new spk only if changed 
					if(_tcsicmp(sOldRetailSPK,(LPCTSTR)lpVal))
					{
						dwRetCode = ValidateRetailSPK(lpVal);
						if(dwRetCode != ERROR_SUCCESS)
						{
							LRMessageBox(hwndDlg, dwRetCode);
							return TRUE;
						}

						SetModifiedRetailSPK(lpVal);
					}				

					EndDialog(hwndDlg, IDOK);
					bRetCode = TRUE;
				}
				break;

			case IDCANCEL:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					EndDialog(hwndDlg, IDCANCEL);
					bRetCode = TRUE;
				}

			default:
				break;
			}
		}
		break;
	default:
		break;

	}
	return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LRWizDLL.rc
//Copyright (c) 1998 - 2000 Microsoft Corporation
//
#define IDS_UNKNOWN_REGISTRATION_ERROR  6
#define IDS_REQUIRED_FIELDS             9
#define IDS_PROCESS_CA_REQUEST          11
#define IDS_PROCESS_LKP_REQUEST         12
#define IDS_ERROR_ACCEPT_PKCS7          19
#define IDS_ERROR_DEPOSITING_CH_CERT    20
#define IDS_PHONE                       21
#define IDS_EMAIL                       22
#define IDS_WELCOME_CAPTION             23
#define IDS_CAREQUEST1_CAPTION          24
#define IDS_CAREQUEST2_CAPTION          25
#define IDS_CAREQUEST3_CAPTION          26
#define IDS_CHREQUEST1_CAPTION          27
#define IDS_CHREQUEST2_CAPTION          28
#define IDS_CHREQUEST_RETAIL_CAPTION    29
#define IDS_CUSTOMER_INFO               30
#define IDS_MAKE_DISK                   31
#define IDS_PROCESSING_REQUEST          32
#define IDS_SHIPPING_ADDRESS            33
#define IDS_CERT_NOT_ENOUGH             34
#define IDS_SUCCESS_INSTALL_CERT_ONLINE 35
#define IDS_FAIL_INSTALL_CERT_ONLINE    36
#define IDS_PIN_CAPTION                 37
#define IDS_SUCCESS_CREATE_ONLINE       38
#define IDS_TITLE                       39
#define IDS_SUCCESS_CREATE_CA_ONLINE    40
#define IDS_FAIL_CA_CREATE_ONLINE       41
#define IDS_FAIL_CH_CREATE_ONLINE       42
#define IDS_UPGRADE_REQD                43
#define IDS_REQUIRED_EMAIL              44
#define IDS_EMAIL_FORMAT                45
#define IDS_SUCCESS_INSTALL_GET_LKP     46
#define IDS_OUTBOUND_DISK_CA            47
#define IDS_INTERNETMODE                48
#define IDS_TELEPHONEMODE               49
#define IDD_DLG_PROP_MODE               112
#define IDB_STAR                        129
#define IDB_PANEL01                     131
#define IDB_PANEL02                     132
#define IDB_DISK                        133
#define IDB_LINE                        139
#define IDD_WELCOME                     140
#define IDC_WELCOME_LOGO                141
#define IDC_BOLDTITLE                   141
#define IDD_CA_REQUEST_2                142
#define IDC_RD_MANUAL                   143
#define IDD_DLG_CUSTOMERINFO            144
#define IDC_RD_INSTALL                  145
#define IDD_CA_REQUEST_4                146
#define IDD_CA_REQUEST_3                146
#define IDC_RD_INTERNET                 147
#define IDC_BTN_NEXT                    1001
#define IDC_FINISH                      1002
#define IDC_COMBO_MODE                  1002
#define IDC_BACK                        1003
#define IDC_DONE                        1004
#define IDC_LBL_FAX                     1004
#define IDC_BMP_LOGO                    1005
#define IDC_LBL_COUNTRYREGION           1005
#define IDC_TXT_PIN                     1008
#define IDC_HELP1                       1009
#define IDC_PROGRESSBAR                 1010
#define IDC_TOTAL_SIZE                  1011
#define IDC_RATE                        1012
#define IDC_EST_TIME                    1013
#define IDC_BTN_LKP                     1014
#define IDC_STATIC_EMAIL_STAR           1015
#define IDC_COMBO1                      1018
#define IDC_SPIN1                       1020
#define IDC_LIST1                       1022
#define IDC_RETAILSPKLIST               1022
#define IDC_BIGBOLDTITLE                1023
#define IDC_LBL_EMAIL                   1024
#define IDC_EDIT1                       1025
#define IDC_LBL_EMAIL2                  1025
#define IDC_LBL_REASON                  1025
#define IDC_LBL_CAPTION                 1027
#define IDC_TXT_CONF_EMAIL              1028
#define IDC_MODEOFREG                   1029
#define IDC_TELEPHONEINFO               1031
#define IDC_TELEPHONEREQUESTTAG         1031
#define IDC_TELEINFOTAG                 1032
#define IDC_TXT_TELEINFO                1033
#define IDC_TXT_TELEINFO1               1033
#define IDC_TXT_TELEINFO2               1034
#define IDC_TXT_TELEINFO3               1035
#define IDC_REGISTRATIONID              1036
#define IDC_RETAILSPK4                  1036
#define IDC_TXT_TELEINFO4               1037
#define IDC_TXT_TELEINFO5               1038
#define IDC_LICENSESERVERID             1039
#define IDC_TXT_TELEINFO6               1040
#define IDC_TXT_TELEINFO7               1041
#define IDC_MSID                        1042
#define IDC_LICENSESERVERIDOLD          1042
#define IDC_RETAILSPK                   1043
#define IDC_MSID2                       1043
#define IDC_ADDBUTTON                   1044
#define IDC_DELETEBUTTON                1045
#define IDC_STATIC_LSID                 1046
#define IDC_DOWN_NEWLKP                 1047
#define IDC_DOWN_LASTLKP                1048
#define IDC_REISSUE_CERT                1049
#define IDC_REVOKE_CERT                 1050
#define IDC_COMBO_REASONS               1051
#define IDCREVOKE_CONFIRMATION_NUMBER   1052
#define IDC_REVOKE_CONFIRMATION_NUMBER  1052
#define IDC_CSRINFO                     1054
#define IDC_COUNTRYREGION               1055
#define IDC_RETAILSPK1                  1056
#define IDC_RETAILSPK2                  1057
#define IDC_RETAILSPK3                  1058
#define IDC_RETAILSPK5                  1059
#define IDC_EDITBUTTON                  1060
#define IDC_TXT_DESC                    1062
#define IDC_TXT_WWWINFO                 1063
#define IDC_WWWINFO                     1064
#define IDC_TXT_FAX                     1065
#define IDC_BTN_PRINT                   1066
#define IDC_TAB1                        1067
#define IDC_CHANGEACTMETHOD             1068
#define IDC_TXT_COMPANYNAME             1069
#define IDC_CHANGECUSTINFO              1069
#define IDC_TXT_ORGUNIT                 1070
#define IDC_RESTARTACTIVATION           1071
#define IDC_NEXTACTION                  1072
#define IDC_REG_COMPLETE                1074
#define IDC_REG_POSTPONE                1075
#define IDC_REG_RESTART                 1076
#define IDC_COMPANYNAME                 1079
#define IDC_ACTIVATIONMETHOD            1080
#define IDC_LICENSETYPE                 1081
#define IDC_PRODUCTID                   1082
#define IDC_DESCRIPTION                 1084
#define IDD_CA_REQUEST_1                1200
#define IDC_RD_SELECT                   1201
#define IDC_RD_OTHER                    1202
#define IDC_CERT_TYPE                   1301
#define IDC_TXT_NAME                    1302
#define IDC_TXT_ORG_UNIT                1303
#define IDC_TXT_ADDRESS1                1305
#define IDC_TXT_ADDRESS2                1306
#define IDC_TXT_ADDRESS3                1307
#define IDC_TXT_STATE                   1309
#define IDC_TXT_ZIP                     1311
#define IDC_TXT_PHONE                   1314
#define IDC_TXT_EMAIL                   1315
#define IDD_CH_SHIPPING_ADDRESS         1400
#define IDD_SHIPPING_ADDRESS            1400
#define IDC_TXT_SHIP_PHONE              1403
#define IDC_TXT_SHIP_EMAIL              1404
#define IDD_LICENSETYPE                 1500
#define IDC_RD_REG_SELECT               1501
#define IDC_RD_REG_MOLP                 1502
#define IDC_RD_REG_OTHER                1503
#define IDD_CH_REGISTER_SELECT          1600
#define IDC_TXT_ENROLLMENT_NUMBER       1603
#define IDD_CH_REGISTER_MOLP            1700
#define IDC_TXT_CUSTOMER_NAME           1701
#define IDC_TXT_AUTH_NUMBER             1702
#define IDC_TXT_AGREEMENT_NUMBER        1703
#define IDC_TXT_MAILING_ADDRESS4        1710
#define IDC_TXT_MAILING_ADDRESS3        1711
#define IDC_CMD_PRODUCT_TYPE            1716
#define IDC_TXT_QUANTITY                1717
#define IDD_CH_REGISTER_OTHER           1800
#define IDC_CMB_LOCATION                1801
#define IDC_CHK_SHIPPING_ADDRESS        1802
#define IDC_TXT_LNAME                   1803
#define IDC_TXT_FNAME                   1804
#define IDC_TXT_PHONE_NUMBER            1805
#define IDC_TXT_EMAIL_ADDRESS           1806
#define IDC_TXT_MAILING_ADDRESS         1807
#define IDC_TXT_MAILING_ADDRESS2        1808
#define IDC_TXT_MAILING_ADDRESS5        1809
#define IDC_TXT_CITY                    1810
#define IDC_TXT_STATE_PROVINCE          1811
#define IDC_TXT_COUNTRY                 1812
#define IDC_TXT_POSTAL_CODE             1813
#define IDC_CMB_DRIVE_SELECT            1901
#define IDC_MESSAGE                     1902
#define IDD_DLG_PHONEINFO               5004
#define IDD_DLG_WWWLKP                  5004
#define IDD_PROGRESS                    5005
#define IDD_CONTACTINFO1                5006
#define IDD_CONTACTINFO2                5007
#define IDD_DLG_CUSTOMERINFO_a          5008
#define IDD_DLG_PROP_CUSTINFO_a         5008
#define IDD_DLG_CUSTOMERINFO_b          5009
#define IDD_DLG_PROP_CUSTINFO_b         5009
#define IDD_SHIPPING_ADDRESS_a          5010
#define IDD_SHIPPING_ADDRESS_b          5011
#define IDD_AUTHENTICATE                5013
#define IDB_CLIENT_CONN                 5014
#define IDB_CLIENT_CONN_HDR             5015
#define IDB_LIC_REGISTR                 5016
#define IDB_LIC_REGISTR_HDR             5018
#define IDD_CONFIRM_EMAIL               5020
#define IDD_DLG_PIN                     5025
#define IDD_DLG_GETREGMODE              5026
#define IDD_DLG_TELREG                  5027
#define IDD_DLG_RETAILSPK               5028
#define IDD_DLG_OPERATIONS              5029
#define IDD_DLG_CERTLOG_INFO            5030
#define IDD_DLG_CONFREVOKE              5031
#define IDD_DLG_TELREG_REISSUE          5032
#define IDD_DLG_COUNTRYREGION           5033
#define IDD_EDIT_RETAILSPK              5034
#define IDD_DLG_WWWREG                  5035
#define IDD_DLG_TELLKP1                 5036
#define IDD_DLG_TELLKP                  5036
#define IDD_CONTINUEREG                 5049
#define IDD_DIALOG1                     5050
#define IDD_CONTINUEREGFAX              5050
#define IDD_DLG_PROP_PROGRAM            5051
#define IDS_REG_ERR_AX00001             10001
#define IDS_REG_ERR_AX00002             10002
#define IDS_REG_ERR_AX00003             10003
#define IDS_REG_ERR_AX00004             10004
#define IDS_REG_ERR_AX00005             10005
#define IDS_REG_ERR_AX00006             10006
#define IDS_REG_ERR_RG00001             20001
#define IDS_REG_ERR_RG00002             20002
#define IDS_REG_ERR_RG00003             20003
#define IDS_REG_ERR_RG00004             20004
#define IDS_REG_ERR_RG00005             20005
#define IDS_REG_ERR_RG00006             20006
#define IDS_REG_ERR_RG00007             20007
#define IDS_REG_ERR_RG00008             20008
#define IDS_REG_ERR_RG00009             20009
#define IDS_REG_ERR_RG00010             20010
#define IDS_REG_ERR_RG00011             20011
#define IDS_REG_ERR_RG00012             20012
#define IDS_REG_ERR_RG00013             20013
#define IDS_REG_ERR_RG00014             20014
#define IDS_REG_ERR_RG00020             20020
#define IDS_ERROR_CONTACTING_CH         20021
#define IDS_REG_ERR_RG00024             20024
#define IDS_REG_ERR_RG00025             20025
#define IDS_REG_ERR_RG00027             20027
#define IDS_REG_ERR_RG00028             20028
#define IDS_REG_ERR_RG00029             20029
#define IDS_REG_ERR_RG00030             20030
#define IDS_REG_ERR_RG00041             20041
#define IDS_REG_ERR_RG00042             20042
#define IDS_REG_ERR_RG00043             20043
#define IDS_REG_ERR_RG00044             20044
#define IDS_REG_ERR_RG00045             20045
#define IDS_REG_ERR_RG00046             20046
#define IDS_REG_ERR_RG00047             20047
#define IDS_REG_ERR_RG00048             20048
#define IDS_REG_ERR_RG00049             20049
#define IDS_REG_ERR_RG00050             20050
#define IDS_TITLE1                      20051
#define IDS_TITLE2                      20053
#define IDS_TITLE3                      20054
#define IDS_LARGEFONTNAME               20055
#define IDS_LARGEFONTSIZE               20056
#define IDS_TITLE4                      20057
#define IDS_TITLE5                      20058
#define IDS_TITLE6                      20059
#define IDS_LS_NOT_REGISTERED           20060
#define IDS_LBL_EMAIL_ONLINE            20061
#define IDS_LBL_EMAIL_OFFLINE           20062
#define IDS_TITLE7                      20063
#define IDS_TITLE8                      20064
#define IDS_TITLE9                      20065
#define IDS_TITLE10                     20066
#define IDS_TITLE11                     20067
#define IDS_TITLE12                     20068
#define IDS_TITLE13                     20069
#define IDS_TITLE14                     20070
#define IDS_TITLE15                     20071
#define IDS_TITLE16                     20072
#define IDS_ERR_CREATE_FAILED           20073
#define IDS_ERR_LSCONNECT_FAILED        20074
#define IDS_ERR_RPC_FAILED              20075
#define IDS_ERR_NO_CERT                 20076
#define IDS_ERR_LS_ERROR                20077
#define IDS_ERR_CRYPT_ERROR             20078
#define IDS_ERR_OUTOFMEM                20079
#define IDS_ERR_CH_ERROR                20080
#define IDS_ERR_REGCONNECT_FAILD        20081
#define IDS_ERR_REGCREATE_FAILED        20082
#define IDS_ERR_CHCERTKEY_EMPTY         20083
#define IDS_ERR_CHURLKEY_EMPTY          20084
#define IDS_ERR_RAURLKEY_EMPTY          20085
#define IDS_ERR_CERT_DEPOSIT_LSERROR    20087
#define IDS_ERR_CERT_DEPOSIT_RPCERROR   20088
#define IDS_ERR_RPC_ERROR               20089
#define IDS_ERR_LSKEY_IMPORT_FAILED     20090
#define IDS_ERR_FIELD_EMPTY             20092
#define IDS_ERR_INVALID_CHAR            20093
#define IDS_ERR_INVALID_EMAIL           20094
#define IDS_PRODUCT_TYPE1               20095
#define IDS_PRODUCT_TYPE2               20096
#define IDS_ERR_DRIVE_LOAD_FAILED       20097
#define IDS_TITLE17                     20098
#define IDS_ERR_INVALID_OP              20099
#define IDS_ERR_EXCEPTION               20100
#define IDS_ERR_RA_ERROR                20101
#define IDS_ERR_INVALID_PIN             20102
#define IDS_ERR_SELECT_DRIVE            20103
#define IDS_ERR_MFG_READ_FAILED         20104
#define IDS_ERR_DEPOSIT_LKP_FAILED      20105
#define IDS_ERR_WRITE_FILE_FAILED       20106
#define IDS_ERR_CHDISK_READ_FAILED      20107
#define IDS_ERR_EXCHG_READ_FAILED       20108
#define IDS_ERR_SIGCERT_READ_FAILED     20109
#define IDS_ERR_ROOTCERT_READ_FAILED    20110
#define IDS_ERR_CHEXCHG_READ_FAILED     20111
#define IDS_ERR_CHSIG_READ_FAILED       20112
#define IDS_ERR_CHROOT_READ_FAILED      20113
#define IDS_MSG_PROCESSING              20114
#define IDS_ERR_EMPTY_RES_FILE          20115
#define IDS_MSG_CR_SUBMITTED            20116
#define IDS_MSG_LKP_PROCESSED           20117
#define IDS_MSG_CERT_INSTALLED          20118
#define IDS_MSG_CR_CREATED              20119
#define IDS_MSG_LR_CREATED              20120
#define IDS_SUBTITLE1                   20121
#define IDS_SUBTITLE2                   20122
#define IDS_SUBTITLE3                   20123
#define IDS_SUBTITLE4                   20124
#define IDS_SUBTITLE5                   20125
#define IDS_SUBTITLE6                   20126
#define IDS_SUBTITLE7                   20127
#define IDS_SUBTITLE8                   20128
#define IDS_SUBTITLE9                   20129
#define IDS_SUBTITLE10                  20130
#define IDS_SUBTITLE11                  20131
#define IDS_SUBTITLE12                  20132
#define IDS_SUBTITLE13                  20133
#define IDS_SUBTITLE14                  20134
#define IDS_SUBTITLE15                  20135
#define IDS_SUBTITLE16                  20136
#define IDS_SUBTITLE17                  20137
#define IDS_MSG_AUTHENTICATING          20138
#define IDS_TITLE18                     20139
#define IDS_SUBTITLE18                  20140
#define IDS_MSG_AUTHENTICATE            20141
#define IDS_MSG_PROCESS                 20142
#define IDS_ERR_AUTH_FAILED             20143
#define IDS_ERR_CHEXT_NOT_FOUND         20144
#define IDS_ERR_LSRAEXT_NOT_FOUND       20145
#define IDS_ERR_LKPREQ_FAILED           20146
#define IDS_ERR_CERTREQ_FAILED          20147
#define IDS_LBL_CONTACT_ONLINE          20148
#define IDS_LBL_CONTACT_OFFLINE         20149
#define IDS_ERR_CERT_NOT_ENOUGH         20150
#define IDS_LSNAME                      20151
#define IDS_ERR_INVALID_QTY             20152
#define IDS_ERR_DUPLICATE_LKP           20153
#define IDS_EMAIL_MISMATCH              20154
#define IDS_ERR_INVALID_CERT_CHAIN      20155
#define IDS_ERR_BAD_MFGBLOB             20156
#define IDS_TITLE19                     20157
#define IDS_SUBTITLE19                  20158
#define IDS_ERR_LCONNECTTRUST_FAILED    20163
#define IDS_ERR_INVALIDLENGTH           20164
#define IDS_TITLE20                     20165
#define IDS_SUBTITLE20                  20166
#define IDS_ERR_NOLSID                  20167
#define IDS_ERR_DEPOSITSPK              20168
#define IDS_TITLE21                     20169
#define IDS_SUBTITLE21                  20170
#define IDS_ERR_DEPOSITLKP              20171
#define IDS_TITLE22                     20172
#define IDS_SUBTITLE22                  20173
#define IDS_IDS_ERR_CONNECTFAILED       20174
#define IDS_RETAIL_HEADERSPK            20175
#define IDS_RETAIL_HEADERSTATUS         20176
#define IDS_RETAILSPKSTATUS_PENDING     20177
#define IDS_RETAILSPKSTATUS_UNKNOWN     20178
#define IDS_ERR_INVALIDSPK              20179
#define IDS_ERR_DUPLICATESPK            20180
#define IDS_TITLE23                     20181
#define IDS_SUBTITLE23                  20182
#define IDS_ERR_SEND_FAILED             20183
#define IDS_ERR_CHFETCHRESPONSE         20184
#define IDS_ERR_CHBAD_DATA              20185
#define IDS_ERR_SPKERRORS               20186
#define IDS_RETAILSPKSTATUS_OK          20187
#define IDS_RETAILSPKSTATUS_INVALID_SIGNATURE 20188
#define IDS_RETAILSPKSTATUS_INVALID_PRODUCT_TYPE 20189
#define IDS_RETAILSPKSTATUS_INVALID_SERIAL_NUMBER 20190
#define IDS_RETAILSPKSTATUS_ALREADY_REGISTERED 20191
#define IDS_ERR_CHSERVER_PROBLEM        20192
#define IDS_ERR_CHINVALID_DATA          20193
#define IDS_ERR_CHFAILURE               20194
#define IDS_ERR_CHNOT_IMPLEMENTED       20195
#define IDS_MSG_CERT_REVOKED            20196
#define IDS_MSG_REVOKECERT              20197
#define IDS_MSG_CERT_REISSUED           20198
#define IDS_TITLE24                     20199
#define IDS_SUBTITLE24                  20200
#define IDS_TITLE25                     20201
#define IDS_SUBTITLE25                  20202
#define IDS_TITLE26                     20203
#define IDS_SUBTITLE26                  20204
#define IDS_ERR_INVALID_CONFIRMATION_NUMBER 20205
#define IDS_ERR_INVALID_SPK             20206
#define IDS_TITLE27                     20207
#define IDS_SUBTITLE27                  20208
#define IDS_COUNTRYREGION_HEADER        20209
#define IDS_CSNUMBER_HEADER             20210
#define IDS_DUPLICATESPK                20210
#define IDS_NOSPKSTOPROCESS             20211
#define IDS_ERR_INVALIDID               20212
#define IDS_ERR_TOOMANYSPK              20213
#define IDS_ERR_NOCOUNTRYSELECTED       20214
#define IDS_MSG_LSIDACCEPTED            20215
#define IDS_ERR_CERTBAD                 20216
#define IDS_ERR_CERTREVOKED             20217
#define IDS_ERR_CERTEXPIRED             20218
#define IDS_ERR_SPKBAD                  20219
#define IDS_ERR_REGERROR                20220
#define IDS_MSG_REQUEST_LKP_NOW         20221
#define IDS_WWWMODE                     20222
#define IDS_INTERNET_DESC               20223
#define IDS_TELEPHONE_DESC              20224
#define IDS_WWW_DESC                    20225
#define IDS_TITLE28                     20226
#define IDS_SUBTITLE28                  20227
#define IDS_TITLE29                     20228
#define IDS_SUBTITLE29                  20229
#define IDS_WWWINFO                     20230
#define IDS_MSG_WWWREG_SUCCESS          20231
#define IDS_AGREEMENT_SELECT            20236
#define IDS_AGREEMENT_MOLP              20237
#define IDS_AGREEMENT_OTHER             20238
#define IDS_TO                          20242
#define IDS_FAX                         20243
#define IDS_DATE                        20244
#define IDS_PAGES                       20245
#define IDS_RETURN_FAX                  20246
#define IDS_COMMENT1                    20247
#define IDS_REQUEST                     20248
#define IDS_AGREEMENT                   20249
#define IDS_PRODUCT_ID                  20250
#define IDS_LSID                        20251
#define IDS_FIRST_NAME                  20252
#define IDS_LAST_NAME                   20253
#define IDS_COMPANY                     20254
#define IDS_ORGUNIT                     20255
#define IDS_ADDRESS                     20256
#define IDS_CITY                        20257
#define IDS_STATE                       20258
#define IDS_ZIP                         20259
#define IDS_COUNTRY                     20260
#define IDS_PHONE_NUMBER                20261
#define IDS_EMAIL_ADDRESS               20262
#define IDS_LIC_TYPE                    20263
#define IDS_QUANTITY                    20264
#define IDS_ENROLL                      20265
#define IDS_AUTH                        20266
#define IDS_LIC                         20267
#define IDS_LIC_CODES                   20268
#define IDS_FAX_TO                      20269
#define IDS_TITLE30                     20270
#define IDS_SUBTITLE30                  20271
#define IDS_TITLE31                     20272
#define IDS_SUBTITLE31                  20273
#define IDS_MSG_CONTINUEREGISTRATION    20274
#define IDS_MSG_UNREGISTERED            20275
#define IDS_MSG_DOWNLOADLKP             20276
#define IDS_MSG_CBOX_CONTREGISTRATION   20277
#define IDS_COUNTRYREGION_HEADER2       20277
#define IDS_MSG_CBOX_OBTAINLKPS         20278
#define IDS_TITLE36                     20278
#define IDS_MSG_REREGISTRATION          20279
#define IDS_MSG_UNREGISTRATION          20280
#define IDS_FINALFAILMESSAGE            20281
#define IDS_ALTFINISHTEXT               20282
#define IDS_TITLE37                     20283
#define IDS_TITLE38                     20284
#define IDS_TITLE39                     20285
#define IDS_MSG_DOWNLOADLASTLKP         20286
#define IDS_FINALSUCCESSMESSAGE         20287
#define IDS_FAX_LABEL                   20288
#define IDS_FAXOPTION_LABEL             20289
#define IDS_EMAIL_LABEL                 20292
#define IDS_EMAILOPTION_LABEL           20293
#define IDS_ERR_INVALIDLSID             20294
#define IDS_ERR_INVALID_PROGINFO        20295
#define IDS_SELECT_DESCRIPTION          20296
#define IDS_OPEN_DESCRIPTION            20297
#define IDS_OTHER_DESCRIPTION           20298
#define IDS_ERR_REQ_FIELD_EMPTY         20299

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5051
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1085
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\utils.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//
//This file contains wrapper C functions for CGlobal Object
//

#include "precomp.h"
#include "utils.h"

#ifndef TLSPERF
#include "global.h"
extern CGlobal *g_CGlobal;
#else
#include "globalPerf.h"
extern CGlobalPerf *g_CGlobal;
#endif

#include "assert.h"


// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD LSBase64EncodeA(
							IN BYTE const *pbIn,
							IN DWORD cbIn,
							OUT CHAR *pchOut,
							OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
	2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
	pchOutT += cchOutEncode;
    }
    else
    {
	DWORD cCol;

	assert(cchOutEncode <= *pcchOut);
	cCol = 0;
	while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
	{
	    BYTE ab3[3];

	    if (cCol == CB_BASE64LINEMAX/4)
	    {
		cCol = 0;
		*pchOutT++ = '\r';
		*pchOutT++ = '\n';
	    }
	    cCol++;
	    memset(ab3, 0, sizeof(ab3));

	    ab3[0] = *pbIn++;
	    if (cbIn > 1)
	    {
		ab3[1] = *pbIn++;
		if (cbIn > 2)
		{
		    ab3[2] = *pbIn++;
		}
	    }

	    *pchOutT++ = abEncode[ab3[0] >> 2];
	    *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	    *pchOutT++ = (cbIn > 1)?
			abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	    *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	    cbIn -= 3;
	}
	*pchOutT++ = '\r';
	*pchOutT++ = '\n';
	assert((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}

DWORD LSBase64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut)
{
    DWORD err = ERROR_SUCCESS;
    DWORD cchInDecode, cbOutDecode;
    CHAR const *pchInEnd;
    CHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	{
	    // skip all whitespace

	    if (*pchInT == ' ' ||
	        *pchInT == '\t' ||
	        *pchInT == '\r' ||
	        *pchInT == '\n')
	    {
		continue;
	    }

	    if (0 != cchInDecode)
	    {
		if ((cchInDecode % 4) == 0)
		{
		    break;			// ends on quantum boundary
		}

		// The length calculation may stop in the middle of the last
		// translation quantum, because the equal sign padding
		// characters are treated as invalid input.  If the last
		// translation quantum is not 4 bytes long, it must be 2 or 3
		// bytes long.

		if (*pchInT == '=' && (cchInDecode % 4) != 1)
		{
		    break;				// normal termination
		}
	    }
	    err = ERROR_INVALID_DATA;
	    goto error;
	}
	cchInDecode++;
    }
    assert(pchInT <= pchInEnd);
    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	pbOutT += cbOutDecode;
    }
    else
    {
	// Decode one quantum at a time: 4 bytes ==> 3 bytes

	assert(cbOutDecode <= *pcbOut);
	pchInT = pchIn;
	while (cchInDecode > 0)
	{
	    DWORD i;
	    BYTE ab4[4];

	    memset(ab4, 0, sizeof(ab4));
	    for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	    {
		while (
		    sizeof(abDecode) > (unsigned) *pchInT &&
		    63 < abDecode[*pchInT])
		{
		    pchInT++;
		}
		assert(pchInT < pchInEnd);
		ab4[i] = (BYTE) *pchInT++;
	    }

	    // Translate 4 input characters into 6 bits each, and deposit the
	    // resulting 24 bits into 3 output bytes by shifting as appropriate.

	    // out[0] = in[0]:in[1] 6:2
	    // out[1] = in[1]:in[2] 4:4
	    // out[2] = in[2]:in[3] 2:6

	    *pbOutT++ =
		(BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	    if (i > 2)
	    {
		*pbOutT++ =
		  (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	    }
	    if (i > 3)
	    {
		*pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	    }
	    cchInDecode -= i;
	}
	assert((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}



#ifndef TLSPERF
CGlobal * GetGlobalContext(void)
#else
CGlobalPerf * GetGlobalContext(void)
#endif
{
	return g_CGlobal;
}



DWORD WINAPI ProcessThread(void *pData)
{
	DWORD	dwRetCode  = ERROR_SUCCESS;

	dwRetCode = ProcessRequest();

	/*
	DWORD	dwTime		= 1;
	HWND	*phProgress	= (HWND *)pData;

	SendMessage(g_hProgressWnd, PBM_SETRANGE, 0, MAKELPARAM(0,PROGRESS_MAX_VAL));
	
	//
	// Increment the progress bar every second till you get Progress Event
	//
	SendMessage(g_hProgressWnd, PBM_SETPOS ,(WPARAM)1, 0);
	do
	{		
		SendMessage(g_hProgressWnd, PBM_DELTAPOS ,(WPARAM)PROGRESS_STEP_VAL, 0);
	}
	while(WAIT_TIMEOUT == WaitForSingleObject(g_hProgressEvent,PROGRESS_SLEEP_TIME));
 
	SendMessage(g_hProgressWnd, PBM_SETPOS  ,(WPARAM)PROGRESS_MAX_VAL, 0);

	*/

	ExitThread(0);

	return 0;
}



static	DWORD (*g_pfnThread)(void *);
static void * g_vpData;
LRW_DLG_INT CALLBACK 
ProgressProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


DWORD ShowProgressBox(HWND hwnd,
					  DWORD (*pfnThread)(void *vpData),
					  DWORD dwTitle,
					  DWORD dwProgressText,
					  void * vpData)
{
	DWORD dwReturn = ERROR_SUCCESS;

	g_pfnThread = pfnThread;
	g_vpData = vpData;

	DialogBox( GetGlobalContext()->GetInstanceHandle(), 
			   MAKEINTRESOURCE(IDD_AUTHENTICATE),
			   hwnd,
			   ProgressProc);

	return dwReturn;
}




LRW_DLG_INT CALLBACK 
ProgressProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    BOOL	bStatus = FALSE;
	static int nCounter;
	static HWND hProgress;
	static HANDLE hThread;

    if (uMsg == WM_INITDIALOG)
	{
		DWORD	dwTID		=	0;

		ShowWindow(hwnd, SW_SHOWNORMAL);

		SetTimer(hwnd, 1, 500, NULL);

		hProgress = GetDlgItem(hwnd, IDC_PROGRESSBAR);
		hThread = CreateThread(NULL, 0, g_pfnThread, g_vpData, 0, &dwTID);

		//Set the range & the initial position
		SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,PROGRESS_MAX_VAL));
		SendMessage(hProgress, PBM_SETPOS  ,(WPARAM)0, 0);


		// Set Title & the Introductory text



		// Create thread to process the request
	}
	else if (uMsg == WM_CLOSE)
	{
		KillTimer(hwnd, 1);
	}
	else if (uMsg == WM_TIMER)
	{
		if (WAIT_OBJECT_0 != WaitForSingleObject(hThread, 0))
		{
			nCounter++;

			if (nCounter < PROGRESS_MAX_VAL-5)
			{
				SendMessage(hProgress, PBM_DELTAPOS ,(WPARAM)PROGRESS_STEP_VAL, 0);
			}
		}
		else
		{
			SendMessage(hProgress, PBM_SETPOS  ,(WPARAM)PROGRESS_MAX_VAL, 0);
			CloseHandle(hThread);
			EndDialog(hwnd, 0);
		}
	}

    return bStatus;
}










void SetInstanceHandle(HINSTANCE hInst)
{
	g_CGlobal->SetInstanceHandle(hInst);
}

void SetLSName(LPTSTR lpstrLSName)
{
	g_CGlobal->SetLSName(lpstrLSName);
}

HINSTANCE GetInstanceHandle()
{
	return g_CGlobal->GetInstanceHandle();
}

DWORD InitGlobal()
{
	return g_CGlobal->InitGlobal();
}

DWORD CheckRequieredFields()
{
	return g_CGlobal->CheckRequieredFields();
}
//
//	This function loads the Message Text from the String Table and displays 
//	the given message
//
int LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwErrorCode /*=0*/)
{
	return g_CGlobal->LRMessageBox(hWndParent,dwMsgId,dwErrorCode);
}

// 
//	This function tries to connect to the LS using LSAPI and returns TRUE if 
//	successful to connect else returns FALSE
//
BOOL IsLSRunning()
{
	return g_CGlobal->IsLSRunning();
}

//
//	This function gets LS Certs and stores Certs & Cert Extensions in the
//	CGlobal object. If no certs , it returns IDS_ERR_NO_CERT
//


//
// This function is used only in ONLINE mode to authenticate LS. 
// Assumption - GetLSCertificates should have been called before calling
// this function.
//
DWORD AuthenticateLS()
{
	return g_CGlobal->AuthenticateLS();
}

DWORD LRGetLastError()
{
	return g_CGlobal->LRGetLastError();
}


TCHAR * GetRegistrationID(void)
{
	return g_CGlobal->GetRegistrationID();
}


TCHAR * GetLicenseServerID(void)
{
	return g_CGlobal->GetLicenseServerID();
}


void SetRequestType(DWORD dwMode)
{
	g_CGlobal->SetRequestType(dwMode);
}


int GetRequestType(void)
{
	return g_CGlobal->GetRequestType();
}


BOOL IsOnlineCertRequestCreated()
{
	return g_CGlobal->IsOnlineCertRequestCreated();
}

DWORD SetLRState(DWORD dwState)
{
	return g_CGlobal->SetLRState(dwState);
}

DWORD SetCertificatePIN(LPTSTR lpszPIN)
{
	return g_CGlobal->SetCertificatePIN(lpszPIN);
}

DWORD PopulateCountryComboBox(HWND hWndCmb)
{
	return g_CGlobal->PopulateCountryComboBox(hWndCmb);
}

DWORD GetCountryCode(CString sDesc,LPTSTR szCode)
{
	return g_CGlobal->GetCountryCode(sDesc,szCode);
}

DWORD PopulateProductComboBox(HWND hWndCmb)
{
	return g_CGlobal->PopulateProductComboBox(hWndCmb);
}

DWORD GetProductCode(CString sDesc,LPTSTR szCode)
{
	return g_CGlobal->GetProductCode(sDesc,szCode);
}

DWORD PopulateReasonComboBox(HWND hWndCmb, DWORD dwType)
{
	return g_CGlobal->PopulateReasonComboBox(hWndCmb, dwType);
}

DWORD GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType)
{
	return g_CGlobal->GetReasonCode(sDesc,szCode, dwType);
}


DWORD ProcessRequest()
{
	return g_CGlobal->ProcessRequest();
}

void LRSetLastRetCode(DWORD dwCode)
{
	g_CGlobal->LRSetLastRetCode(dwCode);
}

DWORD LRGetLastRetCode()
{
	return g_CGlobal->LRGetLastRetCode();
}

void LRPush(DWORD dwPageId)
{
	g_CGlobal->LRPush(dwPageId);
}

DWORD LRPop()
{
	return g_CGlobal->LRPop();
}

BOOL ValidateEmailId(CString sEmailId)
{
	return g_CGlobal->ValidateEmailId(sEmailId);
}

BOOL CheckProgramValidity(CString sProgramName)
{
	return g_CGlobal->CheckProgramValidity(sProgramName);
}

BOOL ValidateLRString(CString sStr)
{
	return g_CGlobal->ValidateLRString(sStr);
}


DWORD PopulateCountryRegionComboBox(HWND hWndCmb)
{
	return g_CGlobal->PopulateCountryRegionComboBox(hWndCmb);
}

DWORD SetLSLKP(TCHAR * tcLKP)
{
	return g_CGlobal->SetLSLKP(tcLKP);
}



DWORD PingCH(void)
{
	return g_CGlobal->PingCH();
}


DWORD AddRetailSPKToList(HWND hListView, TCHAR * lpszRetailSPK)
{
	return g_CGlobal->AddRetailSPKToList(hListView, lpszRetailSPK);
}



void DeleteRetailSPKFromList(TCHAR * lpszRetailSPK)
{
	g_CGlobal->DeleteRetailSPKFromList(lpszRetailSPK);

	return;
}


void LoadFromList(HWND hListView)
{
	g_CGlobal->LoadFromList(hListView);

	return;
}


void UpdateSPKStatus(TCHAR * lpszRetailSPK, TCHAR tcStatus)
{
	g_CGlobal->UpdateSPKStatus(lpszRetailSPK, tcStatus);

	return;
}


DWORD SetConfirmationNumber(TCHAR * tcConf)
{
	return g_CGlobal->SetConfirmationNumber(tcConf);
}


DWORD SetLSSPK(TCHAR * tcp)
{
	return g_CGlobal->SetLSSPK(tcp);
}



void	SetCSRNumber(TCHAR * tcp)
{
	g_CGlobal->SetCSRNumber(tcp);

	return;
}

TCHAR * GetCSRNumber(void)
{
	return g_CGlobal->GetCSRNumber();
}

void	SetWWWSite(TCHAR * tcp)
{
	g_CGlobal->SetWWWSite(tcp);

	return;
}

TCHAR * GetWWWSite(void)
{
	return g_CGlobal->GetWWWSite();
}


DWORD ResetLSSPK(void)
{
	return g_CGlobal->ResetLSSPK();

}


void SetReFresh(DWORD dw)
{
	g_CGlobal->SetReFresh(dw);
}


DWORD GetReFresh(void)
{
	return g_CGlobal->GetReFresh();
}

void SetModifiedRetailSPK(CString sRetailSPK)
{
	g_CGlobal->SetModifiedRetailSPK(sRetailSPK);
}

void GetModifiedRetailSPK(CString &sRetailSPK)
{
	g_CGlobal->GetModifiedRetailSPK(sRetailSPK);
}

void ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK)
{
	g_CGlobal->ModifyRetailSPKFromList(lpszOldSPK,lpszNewSPK);
}

DWORD ValidateRetailSPK(TCHAR * lpszRetailSPK)
{
	return g_CGlobal->ValidateRetailSPK(lpszRetailSPK);
}

DWORD	GetCountryDesc(CString sCode,LPTSTR szDesc)
{
	return g_CGlobal->GetCountryDesc(sCode, szDesc);
}


DWORD CGlobal::SetEncodedInRegistry(LPCSTR lpszOID, LPCTSTR lpszValue)
{
	HKEY	hKey = NULL;
	DWORD	dwDisposition = 0;
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD   dwLen = 0;
	char * cpOut;

	HCRYPTPROV	hProv = NULL;
	HCRYPTKEY	hCKey = NULL;
	HCRYPTHASH	hHash = NULL;

	PBYTE pbKey = NULL;
	DWORD cbKey = 0;

	if(!CryptAcquireContext(&hProv,
							 NULL,
							 NULL,
							 PROV_RSA_FULL,
							 CRYPT_VERIFYCONTEXT))
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptCreateHash(hProv,
					   CALG_MD5,
					   0,
					   0,
					   &hHash))	
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptHashData(hHash,
					 (BYTE *) lpszValue,
					 lstrlen(lpszValue)*sizeof(TCHAR),
					 0))	
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptDeriveKey(hProv,
					  CALG_RC4,
					  hHash,
					  CRYPT_EXPORTABLE,
					  &hCKey))
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptExportKey(
						hCKey,
						NULL,
						PUBLICKEYBLOB,
						0,
						NULL,
						&cbKey))
	{
		dwRetCode = GetLastError();
		if(dwRetCode != ERROR_SUCCESS && dwRetCode != ERROR_MORE_DATA)
			goto done;

		pbKey = (PBYTE)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,cbKey);

		if(!CryptExportKey(
							hCKey,
							NULL,
							PUBLICKEYBLOB,
							0,
							pbKey,
							&cbKey))
		{
			dwRetCode = GetLastError();
			goto done;
		}
	}


	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx ( m_hLSRegKey,
							 REG_LRWIZ_PARAMS,
							 0,
							 NULL,
							 REG_OPTION_NON_VOLATILE,
							 KEY_ALL_ACCESS,
							 NULL,
							 &hKey,
							 &dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}

	if (_tcslen(lpszValue) != 0)
	{
	    LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), NULL, &dwLen);

		cpOut = new char[dwLen+1];
		if (cpOut == NULL)
		{
			dwRetCode = IDS_ERR_OUTOFMEM;
			goto done;
		}

		memset(cpOut, 0, dwLen+1);
        
		LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), cpOut, &dwLen);
	}
	else
	{
		cpOut = new char[2];
		memset(cpOut, 0, 2);
	}
	
	RegSetValueExA ( hKey, 
					lpszOID,
					0,
					REG_SZ,
					(PBYTE) cpOut,
					dwLen
				   );	
	delete cpOut;

done:
	if (hKey != NULL)
	{
		RegCloseKey(hKey);
	}

	DisconnectLSRegistry();

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\telproc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include <assert.h>
#include "precomp.h"


static int iDeleteKeyStatus = 0;


void SetDeleteKeyStatus(int iValue)
{
	iDeleteKeyStatus = iValue;
}

int GetDeleteKeyStatus(void) 
{
	return iDeleteKeyStatus ;
}


void MoveCaret(int nID, HWND  hwnd )
{
	POINT Pt;
	int iCaretIndex  ;
	DWORD	dwNext = 0;	
	TCHAR tcUserValue[ CHARS_IN_BATCH + 1];
	DWORD dwLen ;


	GetCaretPos(&Pt); 
	iCaretIndex = (int) SendMessage(GetDlgItem(hwnd,nID), EM_CHARFROMPOS, 0, MAKELPARAM(Pt.x, Pt.y));

	GetDlgItemText(hwnd,nID, tcUserValue, CHARS_IN_BATCH+1);
	dwLen = _tcslen(tcUserValue);

	switch(iCaretIndex)
	{

	case 0: //Move to left edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_TXT_TELEINFO2:		
				dwNext = IDC_TXT_TELEINFO1;
			break ;

			case IDC_TXT_TELEINFO3:		
				dwNext = IDC_TXT_TELEINFO2;
			break ;


			case IDC_TXT_TELEINFO4:		
				dwNext = IDC_TXT_TELEINFO3;
			break ;

			case IDC_TXT_TELEINFO5:		
				dwNext = IDC_TXT_TELEINFO4;
			break ;

			case IDC_TXT_TELEINFO6:
				dwNext = IDC_TXT_TELEINFO5;
			break ;

			case IDC_TXT_TELEINFO7:		
				dwNext = IDC_TXT_TELEINFO6;
			break ;
		}
		


		if (dwNext != -1 && dwLen == 0 && GetDeleteKeyStatus() == 0)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_END,0);
		}
		break;

	case 5: //Move to right edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_TXT_TELEINFO1:		
				dwNext = IDC_TXT_TELEINFO2;
			break ;

			case IDC_TXT_TELEINFO2:		
				dwNext = IDC_TXT_TELEINFO3;
			break ;

			case IDC_TXT_TELEINFO3:
				dwNext = IDC_TXT_TELEINFO4;
			break ;

			case IDC_TXT_TELEINFO4:
				dwNext = IDC_TXT_TELEINFO5;
			break ;

			case IDC_TXT_TELEINFO5:
				dwNext = IDC_TXT_TELEINFO6;
			break ;

			case IDC_TXT_TELEINFO6:
				dwNext = IDC_TXT_TELEINFO7;
			break ;
		}

		if (dwNext != -1)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_HOME,0);
		}
		break;
	}

}


LRW_DLG_INT CALLBACK 
TelLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE; 
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	DWORD dwRetCode;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

        // Now set the Limit of the data entry fields
        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));
		break;


	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}

		
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;


            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwRegistrationID = GetGlobalContext()->GetRegistrationID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_MSID);
				swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
						 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
						 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
						 cwRegistrationID + 30);
			
				SetWindowText(hwndLSID, awBuffer);
				SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				dwRetCode = SetLSLKP(tcUserValue);
				if (dwRetCode != ERROR_SUCCESS)
				{
					LRMessageBox(hwnd, dwRetCode);	
					dwNextPage = IDD_DLG_TELLKP;
				}
				else 
				{
					dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_DLG_TELLKP);
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\telrproc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include <assert.h>
#include "precomp.h"

void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;

LRW_DLG_INT CALLBACK 
TelRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	DWORD   dwReturn;
	HWND    hwndLSID;
	TCHAR * cwLicenseServerID;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:

        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));
		break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		break ;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;


            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwLicenseServerID = GetLicenseServerID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_LICENSESERVERID);
				SetWindowText(hwndLSID, cwLicenseServerID);
				SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
				{
					// Extraneous characters in the SPK string
					LRMessageBox(hwnd, IDS_ERR_INVALIDLSID, 0);
					dwNextPage = IDD_DLG_TELREG;
				}
				else 
				{
					dwReturn = GetGlobalContext()->SetLSSPK(tcUserValue);
					if (dwReturn != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd, dwReturn, LRGetLastError());
						dwNextPage = IDD_DLG_TELREG;
					}
					else
					{
						dwReturn = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
						dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_TELREG);
					}
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\welcome.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include <assert.h>

static DWORD	g_dwAuthRetCode	= ERROR_SUCCESS;

DWORD WINAPI AuthThread(void *pData);


LRW_DLG_INT CALLBACK 
AuthProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK 
WelcomeDlgProc(IN HWND     hwnd,	
			   IN UINT     uMsg,		
			   IN WPARAM   wParam,	
			   IN LPARAM   lParam)
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );


    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

        SetControlFont( pi->hBigBoldFont, hwnd, IDC_BIGBOLDTITLE);	    
		GetGlobalContext()->ClearWizStack();
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				{
					TCHAR	szMsg[LR_MAX_MSG_TEXT];

					SetDlgItemText(hwnd, IDC_PRODUCTID, GetGlobalContext()->GetLicenseServerID());

					if (GetGlobalContext()->GetWizAction() != WIZACTION_REGISTERLS &&
						GetGlobalContext()->GetWizAction() != WIZACTION_CONTINUEREGISTERLS)
					{
						SetDlgItemText(hwnd, IDC_COMPANYNAME, GetGlobalContext()->GetContactDataObject()->sCompanyName);					

						if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_SELECT)
						{
							LoadString(GetInstanceHandle(),IDS_AGREEMENT_SELECT,szMsg,LR_MAX_MSG_TEXT);
						}
						else if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_MOLP)
						{
							LoadString(GetInstanceHandle(),IDS_AGREEMENT_MOLP,szMsg,LR_MAX_MSG_TEXT);
						}
						else
						{
							LoadString(GetInstanceHandle(),IDS_AGREEMENT_OTHER,szMsg,LR_MAX_MSG_TEXT);
						}

						SetDlgItemText(hwnd, IDC_LICENSETYPE, szMsg);

						if(GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
						{
							LoadString(GetInstanceHandle(),IDS_INTERNETMODE,szMsg,LR_MAX_MSG_TEXT);
							SetDlgItemText(hwnd, IDC_ACTIVATIONMETHOD, szMsg);
						}

						if(GetGlobalContext()->GetActivationMethod() == CONNECTION_WWW)
						{
							LoadString(GetInstanceHandle(),IDS_WWWMODE,szMsg,LR_MAX_MSG_TEXT);
							SetDlgItemText(hwnd, IDC_ACTIVATIONMETHOD, szMsg);
						}

						if(GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
						{
							LoadString(GetInstanceHandle(),IDS_TELEPHONEMODE,szMsg,LR_MAX_MSG_TEXT);
							SetDlgItemText(hwnd, IDC_ACTIVATIONMETHOD, szMsg);
						}

					}
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT );

					switch (GetGlobalContext()->GetWizAction())
					{
					case WIZACTION_DOWNLOADLKP:
						LoadString(GetInstanceHandle(), IDS_MSG_DOWNLOADLKP, szMsg,LR_MAX_MSG_TEXT);
						break;

					case WIZACTION_REGISTERLS:
						LoadString(GetInstanceHandle(), IDS_MSG_UNREGISTERED, szMsg,LR_MAX_MSG_TEXT);
						break;

					case WIZACTION_CONTINUEREGISTERLS:
						LoadString(GetInstanceHandle(), IDS_MSG_CONTINUEREGISTRATION, szMsg,LR_MAX_MSG_TEXT);
						break;

					case WIZACTION_REREGISTERLS:
						LoadString(GetInstanceHandle(), IDS_MSG_REREGISTRATION, szMsg,LR_MAX_MSG_TEXT);
						break;

					case WIZACTION_UNREGISTERLS:
						LoadString(GetInstanceHandle(), IDS_MSG_UNREGISTRATION, szMsg,LR_MAX_MSG_TEXT);
						break;

					case WIZACTION_DOWNLOADLASTLKP:
						LoadString(GetInstanceHandle(), IDS_MSG_DOWNLOADLASTLKP, szMsg,LR_MAX_MSG_TEXT);
						break;
					}
					SetDlgItemText(hwnd, IDC_BOLDTITLE, szMsg);
				}
                break;

            case PSN_WIZNEXT:
				if (GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLASTLKP)
				{
					if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
					{
						// Solve Bug 610 BEGIN
						dwRetCode = ShowProgressBox(hwnd, AuthThread, 0, 0, 0);
						if(g_dwAuthRetCode == ERROR_SUCCESS)
						{						
							//Previos code BEGIN
							dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
							if (dwRetCode == ERROR_SUCCESS)
							{
								dwRetCode = LRGetLastRetCode();
							}

							if (dwRetCode != ERROR_SUCCESS)
							{
								LRMessageBox(hwnd, dwRetCode);
								dwNextPage = IDD_WELCOME;
							}
							else
							{
								dwNextPage = IDD_PROGRESS;
							}
							//Previous code END
						}
						else if (g_dwAuthRetCode == IDS_ERR_SPKBAD ||
								 g_dwAuthRetCode == IDS_ERR_CERTREVOKED)
						{	
							TCHAR	szMsg[LR_MAX_MSG_TEXT];
							TCHAR	szCaption[LR_MAX_MSG_CAPTION];	

							LoadString(GetInstanceHandle(),g_dwAuthRetCode, szMsg,LR_MAX_MSG_TEXT);
							LoadString(GetInstanceHandle(),IDS_TITLE,szCaption,LR_MAX_MSG_CAPTION);

							if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
							{
								SetCursor(LoadCursor(NULL,IDC_WAIT));
								g_dwAuthRetCode = ResetLSSPK();
								SetCursor(LoadCursor(NULL,IDC_ARROW));
								if (g_dwAuthRetCode == ERROR_SUCCESS)
								{
									// Start all over again
									GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
									GetGlobalContext()->SetLSStatus(LSERVERSTATUS_UNREGISTER);
									GetGlobalContext()->SetWizAction(WIZACTION_REGISTERLS);
									GetGlobalContext()->ClearWizStack();
									dwNextPage = IDD_WELCOME;
								}
								else
								{
									LRMessageBox(hwnd,g_dwAuthRetCode,LRGetLastError());
									dwNextPage = IDD_WELCOME;
								}
							}
							else
							{
								dwNextPage = IDD_WELCOME;
							}
						}
						else if (g_dwAuthRetCode == IDS_ERR_CERTBAD ||
								 g_dwAuthRetCode == IDS_ERR_CERTEXPIRED)
						{
							TCHAR	szMsg[LR_MAX_MSG_TEXT];
							TCHAR	szCaption[LR_MAX_MSG_CAPTION];	

							LoadString(GetInstanceHandle(), g_dwAuthRetCode, szMsg, LR_MAX_MSG_TEXT);
							LoadString(GetInstanceHandle(), IDS_TITLE, szCaption, LR_MAX_MSG_CAPTION);

							if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
							{
								// Go to Reissue Cert
								GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
								GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_INTERNET);
								GetGlobalContext()->SetWizAction(WIZACTION_REREGISTERLS);
								dwNextPage = IDD_DLG_CERTLOG_INFO;
							}
							else
							{
								dwNextPage = IDD_WELCOME;
							}
						}
						else
						{
							LRMessageBox(hwnd,g_dwAuthRetCode,LRGetLastError());
							dwNextPage = IDD_WELCOME;
						}
					}
					else
					{
						dwNextPage = GetGlobalContext()->GetEntryPoint();
					}
					// Solve Bug 610 END
				}
				else if (GetGlobalContext()->GetWizAction() == WIZACTION_REGISTERLS)
				{
                    dwNextPage = IDD_DLG_GETREGMODE;
				}
				else if (GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLKP ||
						 GetGlobalContext()->GetWizAction() == WIZACTION_UNREGISTERLS ||
						 GetGlobalContext()->GetWizAction() == WIZACTION_REREGISTERLS)
				{
					if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
					{
						dwRetCode = ShowProgressBox(hwnd, AuthThread, 0, 0, 0);
						if(g_dwAuthRetCode == ERROR_SUCCESS)
						{
							dwNextPage = GetGlobalContext()->GetEntryPoint();
						}
						else if (g_dwAuthRetCode == IDS_ERR_SPKBAD ||
								 g_dwAuthRetCode == IDS_ERR_CERTREVOKED)
						{	
							TCHAR	szMsg[LR_MAX_MSG_TEXT];
							TCHAR	szCaption[LR_MAX_MSG_CAPTION];	

							LoadString(GetInstanceHandle(),g_dwAuthRetCode, szMsg,LR_MAX_MSG_TEXT);
							LoadString(GetInstanceHandle(),IDS_TITLE,szCaption,LR_MAX_MSG_CAPTION);

							if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
							{
								SetCursor(LoadCursor(NULL,IDC_WAIT));
								g_dwAuthRetCode = ResetLSSPK();
								SetCursor(LoadCursor(NULL,IDC_ARROW));
								if (g_dwAuthRetCode == ERROR_SUCCESS)
								{
									// Start all over again
									GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
									GetGlobalContext()->SetLSStatus(LSERVERSTATUS_UNREGISTER);
									GetGlobalContext()->SetWizAction(WIZACTION_REGISTERLS);
									GetGlobalContext()->ClearWizStack();
									dwNextPage = IDD_WELCOME;
								}
								else
								{
									LRMessageBox(hwnd,g_dwAuthRetCode,LRGetLastError());
									dwNextPage = IDD_WELCOME;
								}
							}
							else
							{
								dwNextPage = IDD_WELCOME;
							}
						}
						else if (g_dwAuthRetCode == IDS_ERR_CERTBAD ||
								 g_dwAuthRetCode == IDS_ERR_CERTEXPIRED)
						{
							TCHAR	szMsg[LR_MAX_MSG_TEXT];
							TCHAR	szCaption[LR_MAX_MSG_CAPTION];	

							LoadString(GetInstanceHandle(), g_dwAuthRetCode, szMsg, LR_MAX_MSG_TEXT);
							LoadString(GetInstanceHandle(), IDS_TITLE, szCaption, LR_MAX_MSG_CAPTION);

							if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
							{
								// Go to Reissue Cert
								GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
								GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_INTERNET);
								GetGlobalContext()->SetWizAction(WIZACTION_REREGISTERLS);
								dwNextPage = IDD_DLG_CERTLOG_INFO;
							}
							else
							{
								dwNextPage = IDD_WELCOME;
							}
						}
						else
						{
							LRMessageBox(hwnd,g_dwAuthRetCode,LRGetLastError());
							dwNextPage = IDD_WELCOME;
						}
					}
					else
					{
						dwNextPage = GetGlobalContext()->GetEntryPoint();
					}
				}
				else
				{
					dwNextPage = GetGlobalContext()->GetEntryPoint();
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				if (dwNextPage != IDD_WELCOME)
				{
					LRPush(IDD_WELCOME);
				}
				bStatus = -1;
				break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}








DWORD WINAPI AuthThread(void *pData)
{
	g_dwAuthRetCode = AuthenticateLS();	

	ExitThread(0);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\wwwlkp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include <assert.h>
#include "precomp.h"

void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;




LRW_DLG_INT CALLBACK 
WWWLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	DWORD dwRetCode;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];
//	TCHAR	szWWWInfo[512];
//	TCHAR	szWWWInfoFormat[512];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

        // Now set the Limit of the data entry fields
        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		break ;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;


            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwRegistrationID = GetGlobalContext()->GetRegistrationID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_MSID);
				swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
						 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
						 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
						 cwRegistrationID + 30);
			
				SetWindowText(hwndLSID, awBuffer);

				SetDlgItemText(hwnd, IDC_WWWINFO, GetWWWSite());

				// Set WWW Info
//				LoadString(GetInstanceHandle(),IDS_WWWINFO, szWWWInfoFormat, sizeof(szWWWInfoFormat)/sizeof(TCHAR));
//				_stprintf(szWWWInfo,szWWWInfoFormat,GetWWWSite());
//				SetWindowText(GetDlgItem(hwnd, IDC_TXT_WWWINFO), szWWWInfo);
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				dwRetCode = SetLSLKP(tcUserValue);
				if (dwRetCode != ERROR_SUCCESS)
				{
					LRMessageBox(hwnd, dwRetCode);	
					dwNextPage = IDD_DLG_WWWLKP;
				}
				else 
				{
					dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_DLG_WWWLKP);
				}


				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\wwwreg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _WWWREG_H_
#define _WWWREG_H_

LRW_DLG_INT CALLBACK
WWWRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
WWWLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

#endif //_WWWREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\utils.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _UTILS_H_
#define	_UTILS_H_
#include "global.h"



#ifndef TLSPERF
CGlobal * GetGlobalContext(void);
#else
CGlobalPerf * GetGlobalContext(void);
#endif


DWORD ShowProgressBox(HWND hwnd,
					  DWORD (*pfnThread)(void *),
					  DWORD dwTitle,
					  DWORD dwProgressText,
					  void * vpData = NULL);

DWORD WINAPI ProcessThread(void *pData);


int			LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwErrorCode = 0);
void		SetInstanceHandle(HINSTANCE hInst);
HINSTANCE	GetInstanceHandle();
//DWORD		CheckServerNT5 ();
void	SetLSName(LPTSTR lpstrLSName);
DWORD	InitGlobal();
DWORD	CheckRequieredFields();
BOOL	IsLSRunning();
DWORD	AuthenticateLS();
DWORD	LRGetLastError();



void SetRequestType(DWORD dwMode);
int GetRequestType(void);

TCHAR * SetRegistrationID(void);
TCHAR * GetLicenseServerID(void);

BOOL	IsOnlineCertRequestCreated();

DWORD	SetLRState(DWORD dwState);

DWORD LSBase64EncodeA(BYTE const *pbIn,DWORD cbIn,CHAR *pchOut,DWORD *pcchOut);
DWORD LSBase64DecodeA(CHAR const *pchIn,DWORD cchIn,BYTE *pbOut,DWORD *pcbOut);

DWORD SetCertificatePIN(LPTSTR lpszPIN);

DWORD	PopulateCountryComboBox(HWND hWndCmb);
DWORD	GetCountryCode(CString sDesc,LPTSTR szCode);

DWORD	PopulateProductComboBox(HWND hWndCmb);
DWORD	GetProductCode(CString sDesc,LPTSTR szCode);

DWORD PopulateReasonComboBox(HWND hWndCmb, DWORD dwType);
DWORD GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType);

DWORD	ProcessRequest();

void	LRSetLastRetCode(DWORD dwId);
DWORD	LRGetLastRetCode();

void	LRPush(DWORD dwPageId);
DWORD	LRPop();

BOOL	ValidateEmailId(CString sEmailId);
BOOL	CheckProgramValidity(CString sProgramName);
BOOL	ValidateLRString(CString sStr);



extern DWORD SetLSLKP(TCHAR * tcLKP);
extern DWORD PingCH(void);
extern DWORD AddRetailSPKToList(HWND hListView, TCHAR * lpszRetailSPK);
extern void DeleteRetailSPKFromList(TCHAR * lpszRetailSPK);
extern void LoadFromList(HWND hListView);
extern void UpdateSPKStatus(TCHAR * lpszRetailSPK, TCHAR tcStatus);
extern DWORD SetLSSPK(TCHAR * tcp);

extern DWORD SetConfirmationNumber(TCHAR * tcConf);
extern DWORD PopulateCountryRegionComboBox(HWND hWndCmb);

extern DWORD ResetLSSPK(void);

extern void	SetCSRNumber(TCHAR *);
extern TCHAR * GetCSRNumber(void);

extern void	SetWWWSite(TCHAR *);
extern TCHAR * GetWWWSite(void);

extern void	SetReFresh(DWORD dw);
extern DWORD GetReFresh(void);

extern void SetModifiedRetailSPK(CString sRetailSPK);
extern void GetModifiedRetailSPK(CString &sRetailSPK);

extern void ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK);
extern DWORD ValidateRetailSPK(TCHAR * lpszRetailSPK);

extern	DWORD	GetCountryDesc(CString sCode,LPTSTR szDesc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lrwizapi\wwwreg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include <assert.h>
#include "precomp.h"
#include "wwwreg.h"


void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;


LRW_DLG_INT CALLBACK 
WWWRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	DWORD   dwReturn;
	HWND    hwndLSID;
	TCHAR * cwLicenseServerID;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:

        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		break ;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwLicenseServerID = GetLicenseServerID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_LICENSESERVERID);
				SetWindowText(hwndLSID, cwLicenseServerID);
				SetWindowText(GetDlgItem(hwnd, IDC_WWWINFO), GetWWWSite());
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
				{
					// Extraneous characters in the SPK string
					LRMessageBox(hwnd, IDS_ERR_INVALIDLSID, 0);
					dwNextPage = IDD_DLG_WWWREG;
				}
				else 
				{
					dwReturn = GetGlobalContext()->SetLSSPK(tcUserValue);
					if (dwReturn != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd, dwReturn, LRGetLastError());
						dwNextPage = IDD_DLG_WWWREG;
					}
					else
					{
						dwReturn = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
						dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_WWWREG);
					}
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lsreport\lsrepdef.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        lsrepdef.h
//
// Contents:    Definitions for LSReport, including resource defs
//
// History:     06-15-99    t-BStern    Created
//
//---------------------------------------------------------------------------

#ifndef __lslsdef_h
#define __lslsdef_h

#define TYPESTR_LENGTH 3*10
#define PRODSTR_LENGTH 3*26
#define NOEXPIRE_LENGTH 3*13
#define HEADER_LENGTH 3*74
#define TLS_ERROR_LENGTH 256

#define ERROR_BASE        (1 << 29)
#define ERROR_NO_SERVERS  (ERROR_BASE+1)
#define ERROR_BAD_SYNTAX  (ERROR_BASE+2)
#define ERROR_BAD_CONNECT (ERROR_BASE+3)

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND 2
#endif

/* Resource table defines */
#define IDS_NO_FOPEN               100
#define IDS_NO_SERVERS             101
#define IDS_NOT_LS                 ERROR_FILE_NOT_FOUND
#define IDS_ENUMERATE_FAILED       103
#define IDS_BAD_LOOP               104

#define IDS_TEMPORARY_LICENSE      120
#define IDS_ACTIVE_LICENSE         121
#define IDS_UPGRADED_LICENSE       122
#define IDS_REVOKED_LICENSE        123
#define IDS_PENDING_LICENSE        124
#define IDS_CONCURRENT_LICENSE     125
#define IDS_UNKNOWN_LICENSE        126

#define IDS_HELP_USAGE1            130
#define IDS_HELP_USAGE2            131
#define IDS_HELP_USAGE3            132
#define IDS_HELP_USAGE4            133
#define IDS_HELP_USAGE5            134
#define IDS_HELP_USAGE6            135
#define IDS_HELP_USAGE7            136
#define IDS_HELP_USAGE8            137
#define IDS_HELP_USAGE9            138
#define IDS_HELP_USAGE10           139
#define IDS_HELP_USAGE11           140
#define IDS_HELP_USAGE12           141
#define IDS_HELP_USAGE13           142

#define IDS_DEFAULT_FILE           160
#define IDS_HEADER_TEXT            161
#define IDS_NO_EXPIRE              162

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lsreport\lsreport.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        lsreport.cpp
//
// Contents:    LSReport engine - complete back end
//
// History:     06-10-99    t-BStern    Created
//
//---------------------------------------------------------------------------

#include "lsreport.h"
#include "lsrepdef.h"
#include <time.h>
#include <oleauto.h>

TCHAR noExpire[NOEXPIRE_LENGTH] = { 0 };
TCHAR header[HEADER_LENGTH] = { 0 };

TCHAR szTemp[TYPESTR_LENGTH] = { 0 };
TCHAR szActive[TYPESTR_LENGTH] = { 0 };
TCHAR szUpgrade[TYPESTR_LENGTH] = { 0 };
TCHAR szRevoked[TYPESTR_LENGTH] = { 0 };
TCHAR szPending[TYPESTR_LENGTH] = { 0 };
TCHAR szConcur[TYPESTR_LENGTH] = { 0 };
TCHAR szUnknown[TYPESTR_LENGTH] = { 0 };


// Returns TRUE on success.

BOOL
InitLSReportStrings(VOID)
{
    return (
        LoadString(NULL, IDS_HEADER_TEXT, header, HEADER_LENGTH) &&
        
        LoadString(NULL, IDS_NO_EXPIRE, noExpire, NOEXPIRE_LENGTH) &&
        
        LoadString(NULL, IDS_TEMPORARY_LICENSE, szTemp, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_ACTIVE_LICENSE, szActive, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_UPGRADED_LICENSE, szUpgrade, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_REVOKED_LICENSE, szRevoked, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_PENDING_LICENSE, szPending, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_CONCURRENT_LICENSE, szConcur, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_UNKNOWN_LICENSE, szUnknown, TYPESTR_LENGTH)
    );
}


// Given a keypack and a machine to connect to, read every license in that kp.
// Is not called directly.

DWORD
LicenseLoop(
    IN FILE *OutFile,
    IN LPWSTR szName, // who owns this keypack?
    IN DWORD kpID, // which keypack
    IN LPCTSTR szProductDesc,
    IN BOOL bTempOnly,
    IN const PSYSTEMTIME stStart,
    IN const PSYSTEMTIME stEnd,
    IN BOOL fUseLimits) // are the above 2 parms valid
{
    TLS_HANDLE subHand;
    DWORD dwStatus;
    DWORD dwErrCode = ERROR_SUCCESS;
    WCHAR msg[TLS_ERROR_LENGTH];
    LSLicense lsl;

    subHand = TLSConnectToLsServer(szName);

    if (subHand == NULL)
    {
        // The machine suddenly went away.

        ShowError(GetLastError(), NULL, TRUE);
        dwErrCode = ERROR_BAD_CONNECT;
    }
    else
    {
        lsl.dwKeyPackId = kpID;
        dwStatus = TLSLicenseEnumBegin(
            subHand,
            LSLICENSE_SEARCH_KEYPACKID,
            TRUE,
            &lsl,
            &dwErrCode);

        if (dwErrCode != ERROR_SUCCESS)
        {
            TLSGetLastError(subHand, TLS_ERROR_LENGTH, msg, &dwStatus);
            _fputts(msg, stderr);
            return dwErrCode;
        }
        else if (dwStatus)
        {
            return dwStatus;
        }
        do {
            dwStatus = TLSLicenseEnumNext(subHand, &lsl, &dwErrCode);
            if ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS)) {
                if ((lsl.ucLicenseStatus == LSLICENSE_STATUS_TEMPORARY) ||
                    !bTempOnly) { // Does it fit the temp. requirements?
                    // We want to print if at any of the following are true:
                    // a) There are no limits
                    // b) Issued between stStart and stEnd
                    // c) Expired between stStart and stEnd
                    // d) issued before stStart and expired after stEnd
                    if (!fUseLimits // case a
                        || ((CompDate(lsl.ftIssueDate, stStart) >= 0) &&
                        (CompDate(lsl.ftIssueDate, stEnd) <= 0)) // case b
                        || ((CompDate(lsl.ftExpireDate, stStart) >= 0) &&
                        (CompDate(lsl.ftExpireDate, stEnd) <= 0)) // case c
                        || ((CompDate(lsl.ftIssueDate, stStart) <= 0) &&
                        (CompDate(lsl.ftExpireDate, stEnd) >= 0))) // case d
                    {
                        PrintLicense(szName, // print it.
                            &lsl,
                            szProductDesc,
                            OutFile);
                    } // end check cases
                } // end check for temp license
            } // end good getnext
        } while ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS));

        if (dwStatus != RPC_S_OK)
        {
            return ShowError(dwStatus, NULL, TRUE);
        }

        if (dwErrCode != LSERVER_I_NO_MORE_DATA)
        {
            TLSGetLastError(subHand, TLS_ERROR_LENGTH, msg, &dwStatus);
            _fputts(msg, stderr);
        }

        TLSLicenseEnumEnd(subHand, &dwErrCode);

        if (dwErrCode != ERROR_SUCCESS)
        {
            TLSGetLastError(subHand, TLS_ERROR_LENGTH, msg, &dwStatus);
            _fputts(msg, stderr);
        }

        TLSDisconnectFromServer(subHand);
    }
    return dwErrCode;
}

// Given a machine to connect to, iterate through the keypacks.
// Is not called directly.
DWORD
KeyPackLoop(
    IN FILE *OutFile,
    IN LPWSTR szName, // machine to connect to
    IN BOOL bTempOnly,
    IN const PSYSTEMTIME stStart,
    IN const PSYSTEMTIME stEnd,
    IN BOOL fUseLimits) // do we care about the previous 2 parms?
{
    TLS_HANDLE hand;
    DWORD dwStatus, dwErrCode;
    LSKeyPack lskpKeyPack;
    TCHAR msg[TLS_ERROR_LENGTH];
    
    hand = TLSConnectToLsServer(szName);
    if (hand == NULL)
    {
        return GetLastError();
    }
    lskpKeyPack.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
    dwStatus = TLSKeyPackEnumBegin(hand,
        LSKEYPACK_SEARCH_ALL,
        FALSE,
        &lskpKeyPack,
        &dwErrCode);
    if (dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }
    if (dwStatus != RPC_S_OK)
    {
        return dwStatus;
    }
    do {
        dwStatus = TLSKeyPackEnumNext(hand, &lskpKeyPack, &dwErrCode);
        if ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS))
        {
            LicenseLoop(OutFile,
                szName,
                lskpKeyPack.dwKeyPackId,
                lskpKeyPack.szProductDesc,
                bTempOnly,
                stStart,
                stEnd,
                fUseLimits);
        }
    } while ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS));
    if (dwStatus != RPC_S_OK)
    {
        return ShowError(dwStatus, NULL, TRUE);
    }
    if (dwErrCode != LSERVER_I_NO_MORE_DATA)
    {
        TLSGetLastError(hand, TLS_ERROR_LENGTH, msg, &dwStatus);
        _fputts(msg, stderr);
    }
    TLSKeyPackEnumEnd(hand, &dwErrCode);
    if (dwErrCode != ERROR_SUCCESS)
    {
        TLSGetLastError(hand, TLS_ERROR_LENGTH, msg, &dwStatus);
        _fputts(msg, stderr);
    }
    TLSDisconnectFromServer(hand);
    return dwErrCode;
}

// If bTempOnly is FALSE, all licenses will be dumped to the file.  Otherwise,
// only Temporary licenses will be written.  This is the one function to call
// to do all of the program's magic.
DWORD
ExportLicenses(
    IN FILE *OutFile, // must be opened for writing first
    IN PServerHolder pshServers,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME stStart,
    IN const PSYSTEMTIME stEnd,
    IN BOOL fUseLimits) // are the above 2 parms valid?
{
    DWORD i;
    DWORD dwStatus;
    DWORD dwRetVal = ERROR_SUCCESS;
    
    _fputts(header, OutFile);
    for (i = 0; i < pshServers->dwCount; i++) {
        dwStatus = KeyPackLoop(OutFile,
            pshServers->pszNames[i],
            fTempOnly,
            stStart,
            stEnd,
            fUseLimits);
        if (dwStatus != ERROR_SUCCESS)
        {
            INT_PTR arg;

            dwRetVal = dwStatus;
            arg = (INT_PTR)pshServers->pszNames[i];
            ShowError(IDS_BAD_LOOP, &arg, FALSE);
            ShowError(dwStatus, NULL, TRUE);
        }
    }
    if (dwRetVal == ERROR_SUCCESS)
    {
        // Show a success banner.
        
        ShowError(ERROR_SUCCESS, NULL, TRUE);
    }
    return dwRetVal;
}

// Performs actual output.  of must be open.
// Not called directly.
VOID
PrintLicense(
    IN LPCWSTR szName, // server allocating this license
    IN const LPLSLicense p,
    IN LPCTSTR szProductDesc,
    IN FILE *of)
{
    // All of these are used solely to convert a time_t to a short date.
    BSTR bszDate;
    UDATE uDate;
    DATE Date;
    HRESULT hr;
    LPTSTR szType;
    
    // server name
    _fputts(szName, of);
    
    // license ID and keypack ID
    _ftprintf(of, _T("\t%d\t%d\t"),
        p->dwLicenseId,
        p->dwKeyPackId);
    
    // license holder (machine)
    _fputts(p->szMachineName, of);
    _fputtc('\t', of);
    
    // license requestor (username)
    _fputts(p->szUserName, of);
    _fputtc('\t', of);
    
    // Print issue date in locale-appropriate way
    UnixTimeToSystemTime((const time_t)p->ftIssueDate, &uDate.st);

    hr = VarDateFromUdate(&uDate, 0, &Date);

    if (S_OK != hr)
    {
        return;
    }

    hr = VarBstrFromDate(Date, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), VAR_DATEVALUEONLY, &bszDate);

    if (S_OK != hr)
    {
        return;
    }

    _fputts(bszDate, of);
    SysFreeString(bszDate);
    _fputtc('\t', of);
    
    // print either "No Expiration" or locale-nice expiration date
    if (0x7FFFFFFF != p->ftExpireDate)
    {
        _fputts(noExpire, of);
    }
    else
    {
        UnixTimeToSystemTime((const time_t)p->ftExpireDate, &uDate.st);

        hr = VarDateFromUdate(&uDate, 0, &Date);

        if (S_OK != hr)
        {
            return;
        }

        hr = VarBstrFromDate(Date, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), VAR_DATEVALUEONLY, &bszDate);

        if (S_OK != hr)
        {
            return;
        }

        _fputts(bszDate, of);
        SysFreeString(bszDate);
    }
    _fputtc('\t', of);
    
    // Assign the right kind of text for the type of license,
    // and then print the license type.
    switch (p->ucLicenseStatus) {
    case LSLICENSE_STATUS_TEMPORARY:
        szType = szTemp;
        break;
    case LSLICENSE_STATUS_ACTIVE:
        szType = szActive;
        break;
    case LSLICENSE_STATUS_UPGRADED:
        szType = szUpgrade;
        break;
    case LSLICENSE_STATUS_REVOKE:
        szType = szRevoked;
        break;
    case LSLICENSE_STATUS_PENDING:
        szType = szPending;
        break;
    case LSLICENSE_STATUS_CONCURRENT:
        szType = szConcur;
        break;
    case LSLICENSE_STATUS_UNKNOWN:
        // Fall through
    default:
        szType = szUnknown;
    }
    _fputts(szType, of);
    _fputtc('\t', of);
    
    // Print the description
    _fputts(szProductDesc, of);
    _fputtc('\n', of);
}

// returns <0 if when is before st, ==0 if they are the same date, and
// >0 if when is after st.
int CompDate(
    IN DWORD when, // treated as a time_t
    IN const PSYSTEMTIME st)
{
    time_t when_t;

    //
    // time_t is 64 bits in win64.  Convert, being careful to sign extend.
    //

    when_t = (time_t)((LONG)(when));
    struct tm *t = localtime(&when_t);

    if ((t->tm_year+1900) < st->wYear) {
        return -1;
    }
    if ((t->tm_year+1900) > st->wYear) {
        return 1;
    }
    if  ((t->tm_mon+1) < st->wMonth) {
        return -1;
    }
    if ((t->tm_mon+1) > st->wMonth) {
        return 1;
    }
    if (t->tm_mday < st->wDay) {
        return -1;
    }
    if (t->tm_mday > st->wDay) {
        return 1;
    }
    return 0;
}


// From the Platform SDK.
void
UnixTimeToFileTime(
    IN time_t t,
    OUT LPFILETIME pft)
{
    // Note that LONGLONG is a 64-bit value
    LONGLONG ll;
    
    ll = Int32x32To64(t, 10000000) + 116444736000000000;
    pft->dwLowDateTime = (DWORD)ll;
    pft->dwHighDateTime = (DWORD)(ll >> 32);
}

// Also from the Platform SDK.
void
UnixTimeToSystemTime(
    IN time_t t,
    OUT LPSYSTEMTIME pst)
{
    FILETIME ft;
    
    UnixTimeToFileTime(t, &ft);
    FileTimeToSystemTime(&ft, pst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lsreport\lsreport.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        lsreport.h
//
// Contents:    Prototypes and structures for LSReport.
//
// History:     06-05-99    t-BStern    Created
//
//---------------------------------------------------------------------------

#ifndef __lsls_h
#define __lsls_h

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <windef.h>
#include <winnt.h>
#include <rpc.h>
#include <hydrals.h>
#include <tlsapi.h>
#include <winsta.h>

typedef struct _ServerHolder {
    LPWSTR *pszNames;
    DWORD dwCount;
} ServerHolder, *PServerHolder;

BOOL
InitLSReportStrings(VOID);

DWORD
ShowError(
    IN DWORD dwStatus,
    IN INT_PTR *args,
    IN BOOL fSysError
);

DWORD
ExportLicenses(
    IN FILE *OutFile,
    IN PServerHolder pshServers,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME pstStart,
    IN const PSYSTEMTIME pstEnd,
    IN BOOL fUseLimits
);

VOID
PrintLicense(
    IN LPCTSTR szName,
    IN const LPLSLicense pLSLicense,
    IN LPCTSTR szProductId,
    IN FILE *outFile
);

BOOL 
ServerEnumCallBack(
    IN TLS_HANDLE hHandle,
    IN LPCTSTR pszServerName,
    IN OUT HANDLE dwUserData
);

INT
CompDate(
    IN DWORD dwWhen,
    IN const PSYSTEMTIME pstWhen
);

int
usage(
    IN int retVal
);

DWORD
LicenseLoop(
    IN FILE *OutFile,
    IN LPWSTR szName,
    IN DWORD dwKeyPackId,
    IN LPCTSTR szProductId,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME pstStart,
    IN const PSYSTEMTIME pstEnd,
    IN BOOL fUseLimits
);

DWORD
KeyPackLoop(
    IN FILE *OutFile,
    IN LPWSTR szName,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME pstStart,
    IN const PSYSTEMTIME pstEnd,
    IN BOOL fUseLimits
);

void
UnixTimeToFileTime(
    IN time_t t,
    OUT LPFILETIME pft
);

void
UnixTimeToSystemTime(
    IN time_t t,
    OUT LPSYSTEMTIME pst
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\pidapi\inc\shortsig.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------


// MS CD Key
#ifdef __cplusplus
extern "C" {
#endif

typedef int SSRETCODE;  // type for return codes

#define SS_OK 0
#define SS_BAD_KEYLENGTH 1
#define SS_OTHER_ERROR 2
#define SS_INVALID_SIGNATURE 3

// The first DWORD of a Public or Private key is the total length of the key including
// the DWORD length

#ifndef SIG_VERIFY_ONLY ///////////////////////////////////////////////////////

SSRETCODE CryptInit();  // Not needed for CryptVerifySig()

SSRETCODE CryptGetKeyLens(
    LONG cbitSig,       // [IN] count of bits in Sig
    LONG *pcbPrivate,   // [OUT] ptr to number of bytes in the private key
    LONG *pcbPublic);   // [OUT] ptr to number of bytes in the private key

SSRETCODE CryptKeyGen(
    LONG  cbRandom,     // [IN] count of random Bytes
    LPVOID pvRandom,    // [IN] ptr to array of random Bytes
    LONG  cbitsSig,     // [IN] count of bits in Sig
    LPVOID pvKeyPrivate,// [OUT] the generated private key
    LPVOID pvKeyPublic);// [OUT] the generated public key

SSRETCODE CryptSign(
    LONG cbRandom,      // [IN] count of random Bytes
    LPVOID pvRandom,    // [IN] ptr to array of random Bytes
    LONG  cbMsg,        // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to sign
    LONG  cbKeyPrivate, // [IN] number of bytes in private key (from CryptGetKeyLens)
    LPVOID pvKeyPrivate,// [IN] the generated private key (from CryptKeyGen)
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);       // [OUT] the digital signature

SSRETCODE CryptSignBatch(
    LONG cbRandom,      // [IN] count of random Bytes
    LPVOID pvRandom,    // [IN] ptr to array of random Bytes
    LONG  cbMsg,        // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to sign
    LONG  cbKeyPrivate, // [IN] number of bytes in private key (from CryptGetKeyLens)
    LPVOID pvKeyPrivate,// [IN] the generated private key (from CryptKeyGen)
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig,       // [OUT] the digital signature
    LONG cMsg);         // [IN]  the count of messages to sign

SSRETCODE CryptAuthenticate(
    LONG  cbMsg,        // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to authenticate
    LONG  cbKeyPrivate, // [IN] number of bytes in private key (from CryptGetKeyLens)
    LPVOID pvKeyPrivate,// [IN] the generated private key (from CryptKeyGen)
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature

SSRETCODE CryptVerifySigFast(
    LONG   cbMsg,       // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to Authenticate
    LONG   cbKeyPublic, // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG   cbitsSig,    // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature

#endif  // ndef SIG_VERIFY_ONLY ///////////////////////////////////////////////

SSRETCODE CryptVerifySig(
    LONG cbMsg,         // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to verify
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature (from CryptSign)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\lsreport\main.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        main.cpp
//
// Contents:    Front end to license "needer"; lists TS licenses
//
// History:     06-05-99    t-BStern    Created
//
//---------------------------------------------------------------------------

// The goal here is to export
//  all [temporary] licenses [issued between <shortdate1> and <shortdate2>]
//  to a file [named <outFile>] [only from server[s] <S>]
//
// So possible command lines are:
//  lsls    |    lsls /T /D 1/1/99 2/2/00 /F outfile ls-server ls2 ls3

#include "lsreport.h"
#include "lsrepdef.h"
#include <oleauto.h>


// I found that ErrorPrintf didn't do %1-style formatting, so this does
// complete formatting and stderr output.  It is referenced by code in
// lsreport.cpp, so if the program becomes GUI-based, ShowError needs to
// maintain a presence.

DWORD
ShowError(
    IN DWORD dwStatus, // This is both the return value and the resource ID.
    IN INT_PTR *args, // Casted to va_list* and passed to FormatMessage.
    IN BOOL fSysError // Use the system message table (T) or the module (F)?
) {
    LPTSTR lpSysError;
    TCHAR szBuffer[TLS_ERROR_LENGTH];
    DWORD dwFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    DWORD dwRet;
    
    if ((dwStatus == ERROR_FILE_NOT_FOUND) || !fSysError)
    {
        // We need to special-case File-not-Found because the system error
        // is insufficiently educational.  FnF really means that the server
        // is not running TS.
        int retVal;
        retVal = LoadString(NULL, dwStatus, szBuffer, TLS_ERROR_LENGTH);
        if (!retVal)
        {
            // This is a more serious error.
            
            dwStatus = GetLastError();
        }
        else
        {
            dwFlag = FORMAT_MESSAGE_FROM_STRING;
        }
    }
    dwRet = FormatMessage(dwFlag |
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_ARGUMENT_ARRAY, // Tell FM to use INT_PTRs internally.
        szBuffer,
        dwStatus,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpSysError,
        0,
        (va_list *)args); // FormatMessage requires va_lists, even
            // if the arguments are flagged as being INT_PTRs.

    if ((dwRet != 0) && (lpSysError != NULL))
    {
        _fputts(lpSysError, stderr);
        LocalFree(lpSysError);
    }

    return dwStatus;
}


// Used only to enumerate the License Servers around, and thereby build a list
// Used in EnumerateTlsServer()

BOOL 
ServerEnumCallBack(
                   IN TLS_HANDLE hHandle,
                   IN LPCWSTR pszServerName,
                   IN HANDLE dwUserData // Really a PServerHolder
                   ) {
    LPWSTR *block;
    PServerHolder pSrvHold; // The casts get so hairy that I'll do this.
    pSrvHold = (PServerHolder)dwUserData;
    if ((hHandle != NULL) && (pSrvHold != NULL))
    {
        if (pSrvHold->pszNames == NULL)
        {
            // We need to allocate the names list for the first time.
            
            block = (LPWSTR *)LocalAlloc(0, sizeof (LPWSTR));
        } else {
            // The names list needs to get bigger.
            
            block = (LPWSTR *)LocalReAlloc(pSrvHold->pszNames,
                (1+pSrvHold->dwCount) * sizeof (LPWSTR),
                0);
        }
        if (block != NULL)
        {
            // We can add a name to the list.
            
            pSrvHold->pszNames = block;
            pSrvHold->pszNames[pSrvHold->dwCount] = _tcsdup(pszServerName);
            pSrvHold->dwCount++;
        }
        // It's okay if we have to stick with the names we already have.
    }
    return FALSE;
}

BOOL
SortDates(
    PSYSTEMTIME pstStart,
    PSYSTEMTIME pstEnd)
{
    BOOL fSwapped = FALSE;
    FILETIME ftStart, ftEnd;
    SYSTEMTIME stHolder;
    SystemTimeToFileTime(pstStart, &ftStart);
    SystemTimeToFileTime(pstEnd, &ftEnd);

    if ((ftStart.dwHighDateTime > ftEnd.dwHighDateTime) ||
        ((ftStart.dwHighDateTime == ftEnd.dwHighDateTime) &&
        (ftStart.dwLowDateTime > ftEnd.dwLowDateTime)))
    {
        // We need to swap.

        stHolder.wYear = pstStart->wYear;
        stHolder.wMonth = pstStart->wMonth;
        stHolder.wDay = pstStart->wDay;

        pstStart->wYear = pstEnd->wYear;
        pstStart->wMonth = pstEnd->wMonth;
        pstStart->wDay = pstEnd->wDay;

        pstEnd->wYear = stHolder.wYear;
        pstEnd->wMonth = stHolder.wMonth;
        pstEnd->wDay = stHolder.wDay;

        fSwapped = TRUE;
    }
    return fSwapped;
}


// All that wmain needs to do is parse the command line and
// therefore collect a list of machines to connect to, along with
// any options passed, and open & close the (possibly command-line
// specified) output file.

extern "C" int _cdecl
wmain(
    int argc,
    WCHAR *argv[],
    WCHAR // *envp[]
) {
    // These represent which command-line options were chosen.
    BOOL fTempOnly = FALSE;
    BOOL fError = FALSE;
    BOOL fDateSpec = FALSE;
    
    DWORD dwStatus;
    DWORD dwSrvLoc; // This is a bitfield.
    ServerHolder srvHold; // This holds all the servers.
    
    // These are for parsing the command-line-specified date(s).
    DATE startDate;
    DATE endDate;
    UDATE usDate;
    UDATE ueDate;
    
    // Basic file I/O.
    TCHAR ofName[MAX_PATH+1] = { 0 };
    FILE *outFile;
    
    int i;
    INT_PTR arg; // All of my strings have at most 1 parm.
    
    dwSrvLoc = 0;
    srvHold.dwCount = 0;
    srvHold.pszNames = NULL;
    if (!(LoadString(NULL, IDS_DEFAULT_FILE, ofName, MAX_PATH) &&
        InitLSReportStrings()))
    {
        return ShowError(GetLastError(), NULL, TRUE);
    }
    for (i = 1; (i < argc) && !fError; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (argv[i][1]) {
            case 'F': case 'f': // format: /F [path\]filename
                if (i+1 == argc)
                {
                    // They didn't include enough parameters.

                    fError = TRUE;
                } else {
                    i++;
                    _tcsncpy(ofName, argv[i], MAX_PATH);
                }
                break;
            case 'D': case 'd': // format: /D startdate [enddate]

                // Do a lot of date manipulation.

                if (i+1 == argc)
                {
                    fError = TRUE;
                }
                else
                {
                    i++;
                    dwStatus = VarDateFromStr(argv[i],
                        LOCALE_USER_DEFAULT,
                        VAR_DATEVALUEONLY,
                        &startDate);
                    if (dwStatus != S_OK)
                    {
                        // The date couldn't get converted.

                        ShowError(dwStatus, NULL, TRUE);
                        fError = TRUE;
                        break;
                    }
                    if (VarUdateFromDate(startDate, 0, &usDate) != S_OK)
                    {
                        // We don't want to set error, because the user can't
                        // fix this with command line syntax.  We're out of
                        // memory or something.  ABEND.
                        
                        return ShowError(GetLastError(), NULL, TRUE);
                    }
                    i++;
                    if (i < argc)
                    {
                        dwStatus = VarDateFromStr(argv[i],
                            LOCALE_USER_DEFAULT,
                            VAR_DATEVALUEONLY,
                            &endDate);
                        if (dwStatus != S_OK)
                        {
                            ShowError(dwStatus, NULL, TRUE);
                            fError = TRUE;
                            break;
                        }
                        if (VarUdateFromDate(endDate, 0, &ueDate) != S_OK)
                        {
                            return ShowError(GetLastError(), NULL, TRUE);
                        }
                    }
                    else
                    {
                        // We have to use today's date, because they didn't
                        // give us an EndDate.
                        
                        GetSystemTime(&ueDate.st); // Fill in the SystemTime.
                    }
                    
                    // Check if the dates are in the right order.
                    // If the user gives us only /D 1/1/2022 and it is 1999, I
                    // choose not to have a fit and die.

                    SortDates(&usDate.st, &ueDate.st);
                    fDateSpec = TRUE;
                }
                break;
            case 'T': case 't': // Format: /T
                fTempOnly = TRUE;
                break;
            // case '?': case 'H': case 'h': // Format: /?
            default: // Let the default get this, since it'll work the same.

                // This'll show syntax help.

                fError = TRUE;
                break;
            } // switch
        }
        else
        {
            // It wasn't -T or /F or something.
            // It must be a server name, since it's not anything else.
            
            dwSrvLoc |= (1 << i); // Tag this is as a server name.
            srvHold.dwCount++;
        }
    } // argc loop

    if (fError)
    {
        ShowError(IDS_HELP_USAGE1, NULL, FALSE);
        // Set the exe name:
        arg = (INT_PTR)argv[0];
        ShowError(IDS_HELP_USAGE2, &arg, FALSE);
        ShowError(IDS_HELP_USAGE3, NULL, FALSE);
        ShowError(IDS_HELP_USAGE4, NULL, FALSE);
        ShowError(IDS_HELP_USAGE5, NULL, FALSE);
        ShowError(IDS_HELP_USAGE6, NULL, FALSE);
        ShowError(IDS_HELP_USAGE7, NULL, FALSE);
        ShowError(IDS_HELP_USAGE8, NULL, FALSE);
        ShowError(IDS_HELP_USAGE9, NULL, FALSE);
        ShowError(IDS_HELP_USAGE10, NULL, FALSE);
        ShowError(IDS_HELP_USAGE11, NULL, FALSE);
        ShowError(IDS_HELP_USAGE12, &arg, FALSE);
        ShowError(IDS_HELP_USAGE13, &arg, FALSE);
        
        return ERROR_BAD_SYNTAX;
    }
    outFile = _tfopen(ofName, _T("w"));
    if (outFile == NULL)
    {
        // This is an extra level of indirection for FormatMessage.
        arg = (INT_PTR)&ofName;
        ShowError(IDS_NO_FOPEN, &arg, FALSE);
        return ShowError(GetLastError(), NULL, TRUE);
    }

    TLSInit();

    if (dwSrvLoc)
    {
        int holder;
        
        srvHold.pszNames = (LPWSTR *)LocalAlloc(0,
            srvHold.dwCount * sizeof (LPWSTR *));
        if (srvHold.pszNames == NULL)
        {
            dwStatus = ShowError(GetLastError(), NULL, TRUE);
            goto done;
        }

        holder = 0;
        for (i = 1; i < argc; i++) { // argc (less one) == max # of servers.
            if (dwSrvLoc & (1 << i)) {
                srvHold.pszNames[holder] = _tcsdup(argv[i]);
                holder++;
            }
        }
    }
    else
    {
        // We need to collect a list of servers.
        LPTSTR *pszEntSrvNames;
        DWORD dwEntSrvNum;
        HRESULT hrEntResult;
        
        dwStatus = EnumerateTlsServer(
            ServerEnumCallBack,
            &srvHold,
            3000, // seems a good timeout
            FALSE);

        hrEntResult = GetAllEnterpriseServers(&pszEntSrvNames, &dwEntSrvNum);
        if (SUCCEEDED(hrEntResult))
        {
            DWORD j, k;
            BOOL fFound;
            
            for (k = 0; k < dwEntSrvNum; k++) {
                fFound = FALSE;
                for (j = 0; j < srvHold.dwCount; j++) {
                    if (!_tcscmp(srvHold.pszNames[j], pszEntSrvNames[k]))
                    {
                        fFound = TRUE;
                        break;
                    }
                }
                if (!fFound)
                {
                    // This is a new name.
                    
                    LPTSTR *block;
                    if (srvHold.pszNames == NULL)
                    {
                        // We have to allocate names for the first time.
                        
                        block = (LPTSTR *)LocalAlloc(0, sizeof (LPTSTR));
                    }
                    else
                    {
                        // Try to increase the array.
                        
                        block = (LPTSTR *)LocalReAlloc(srvHold.pszNames,
                            (1+srvHold.dwCount) * sizeof (LPTSTR),
                            0);
                        
                    }

                    if (block != NULL)
                    {
                        // We can add a name to the list.
                        
                        srvHold.pszNames = block;
                        srvHold.pszNames[srvHold.dwCount] = pszEntSrvNames[k];
                        srvHold.dwCount++;
                    }
                    else
                    {
                        // If we can't copy it into our array, we should drop it.

                        LocalFree(pszEntSrvNames[k]);
                    }
                    
                    // End need to add name
                }
                
                // End loop through existing servers
            }

            // We've removed all of the names from this one way or the other.
            LocalFree(pszEntSrvNames);
            
            // End <GetEntSrv worked>
        }
        
        // Autodiscovery complete.
    }
    if (srvHold.dwCount)
    {
        dwStatus = ExportLicenses(
            outFile,
            &srvHold,
            fTempOnly,
            &usDate.st,
            &ueDate.st,
            fDateSpec);
        do {
            free(srvHold.pszNames[--srvHold.dwCount]);
        } while (srvHold.dwCount);
        LocalFree(srvHold.pszNames);
    }
    else
    {
        arg = (INT_PTR)argv[0];
        ShowError(IDS_NO_SERVERS, &arg, FALSE);
        dwStatus = ERROR_NO_SERVERS;
    }

done:
    fclose(outFile);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\pidapi\inc\digpid.h ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    digpid.h

Abstract:

--*/

// DigPid.h

#ifdef __cplusplus
extern "C" {
#endif

#define INVALID_PID 0xFFFFFFFF

typedef enum {
    ltFPP,
    ltCCP,
    ltOEM,
    ltSelect,
    ltMLP,
    ltMOLP,
    ltMSDN
} LICENSETYPE;
typedef DWORD DWLICENSETYPE;


typedef struct {
    DWORD dwLength;
    WORD  wVersionMajor;
    WORD  wVersionMinor;
    char  szPid2[24];
    DWORD dwKeyIdx;
    char  szSku[16];
    BYTE  abCdKey[16];
    DWORD dwCloneStatus;
    DWORD dwTime;
    DWORD dwRandom;
    DWLICENSETYPE dwlt;
    DWORD adwLicenseData[2];
    char  szOemId[8];
    DWORD dwBundleId;

    char  aszHardwareIdStatic[8];

    DWORD dwHardwareIdTypeStatic;
    DWORD dwBiosChecksumStatic;
    DWORD dwVolSerStatic;
    DWORD dwTotalRamStatic;
    DWORD dwVideoBiosChecksumStatic;

    char  aszHardwareIdDynamic[8];

    DWORD dwHardwareIdTypeDynamic;
    DWORD dwBiosChecksumDynamic;
    DWORD dwVolSerDynamic;
    DWORD dwTotalRamDynamic;
    DWORD dwVideoBiosChecksumDynamic;

    DWORD dwCrc32;
} DIGITALPID, *PDIGITALPID, FAR *LPDIGITALPID;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\common.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        common.h
//
// Contents:    
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#ifndef _LS_COMMON_H
#define _LS_COMMON_H

#include <windows.h>
#include <wincrypt.h>
#include <ole2.h>

#ifdef __cplusplus
extern "C" {
#endif

    HRESULT LogEvent(LPTSTR lpszSource,
                     DWORD  dwEventType,
                     WORD   wCatalog,
                     DWORD  dwIdEvent,
                     WORD   cStrings,
                     TCHAR **apwszStrings);

    LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


    BOOL
    ConvertWszToBstr( OUT BSTR *pbstr,
                      IN WCHAR const *pwc,
                      IN LONG cb);

    BOOL 
    ConvertBstrToWsz(IN      BSTR pbstr,
                     OUT     LPWSTR * pWsz);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\dbgout.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include "dbgout.h"
#include "locks.h"

//CCriticalSection CS;

void
DebugOutput(
    HANDLE hConsole,
    LPTSTR format,
    va_list* vaList
    )
/*++
++*/
{
    TCHAR  buf[8096];
    DWORD  dump;
    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    // CS.Lock();

    try {
        memset(buf, 0, sizeof(buf));
        _sntprintf(
                buf,
                sizeof(buf)/sizeof(buf[0]),
                _TEXT(" %d [%d:%d:%d:%d:%d.%d] : "),
                GetCurrentThreadId(),
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond,
                sysTime.wMilliseconds
            );

        _vsntprintf(
                buf + lstrlen(buf),
                sizeof(buf)/sizeof(buf[0]) - lstrlen(buf),
                format,
                *vaList
            );

        OutputDebugString(buf);
        if(hConsole != NULL)
        {
            WriteConsole(
                        hConsole,
                        buf,
                        _tcslen(buf),
                        &dump,
                        NULL
                    );
        }
    }
    catch(...) {
    }

    // CS.UnLock();

    return;
}


void
TLSDebugOutput(
    HANDLE hConsole,
    LPTSTR format, ...
    )
/*++
++*/
{
    va_list marker;
    va_start(marker, format);

    DebugOutput(hConsole, format, &marker);

    va_end(marker);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\dbgout.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DEBUG_OUTPUT__
#define __DEBUG_OUTPUT__

#include <windows.h>
#include <stdio.h>
#include <tchar.h>


#ifdef __cplusplus
extern "C" {
#endif

void
TLSDebugOutput(
    HANDLE hConsole,
    LPTSTR format, ...
);

void
DebugOutput(
    HANDLE hConsole,
    LPTSTR format,
    va_list* vaList
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\common.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        
//
// Contents:    
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "common.h"

//---------------------------------------------------------------------------
// FUNCTION: LogEvent(	DWORD   dwEventType,                 	     
//                      DWORD   dwIdEvent,               
//                      WORD    cStrings,                            
//                      LPTSTR *apwszStrings);           
//                                                        
// PURPOSE: add the event to the event log                
//                                                               
// INPUT: the event ID to report in the log, the number of insert
//        strings, and an array of null-terminated insert strings
//                                                               
// RETURNS: none                                                 
//---------------------------------------------------------------------------
HRESULT LogEvent(LPTSTR lpszSource,
                 DWORD  dwEventType,
                 WORD   wCatalog,
                 DWORD  dwIdEvent,
                 WORD   cStrings,
                 TCHAR **apwszStrings)
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType;

    wElogType = (WORD) dwEventType;
    if(hAppLog=RegisterEventSource(NULL, lpszSource)) 
    {
        bSuccess = ReportEvent(hAppLog,
		    	               wElogType,
			                   wCatalog,
			                   dwIdEvent,
			                   NULL,
			                   cStrings,
    			               0,
	    		               (const TCHAR **) apwszStrings,
		    	               NULL);

        DeregisterEventSource(hAppLog);
    }

    return((bSuccess) ? S_OK : GetLastError());
}

//---------------------------------------------------------------------------
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = _TEXT('\0');  //remove cr and newline character
        _sntprintf( lpszBuf, dwSize, _TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}

BOOL
ConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb)
{
    BOOL fOk = FALSE;
    BSTR bstr;

    do
    {
    bstr = NULL;
    if (NULL != pwc)
    {
        if (-1 == cb)
        {
            cb = wcslen(pwc) * sizeof(WCHAR);
        }
        bstr = SysAllocStringByteLen((char const *) pwc, cb);
        if (NULL == bstr)
        {
            break;
        }
    }
    if (NULL != *pbstr)
    {
        SysFreeString(*pbstr);
    }
    *pbstr = bstr;
    fOk = TRUE;
    } while (FALSE);
    return(fOk);
}

BOOL ConvertBstrToWsz(
    IN      BSTR pbstr,
    OUT     LPWSTR * pWsz)
{
    LPWSTR wstrRequest = NULL;
    int wLen = 0;
    int returnvalue;

    if (pWsz != NULL)
        SysFreeString((BSTR) *pWsz);

    returnvalue = MultiByteToWideChar(GetACP(), 0, (LPCSTR) pbstr, -1, *pWsz, wLen);
    if (returnvalue == 0)
    {
        return FALSE;
    }
    else if (wLen == 0)
    {
        if((*pWsz = (LPWSTR) SysAllocStringLen (NULL, returnvalue)) == NULL)
            return FALSE;
        returnvalue = MultiByteToWideChar(GetACP(), 0, (LPCSTR) pbstr, -1, *pWsz, returnvalue);
        if (returnvalue == 0)
        {
            return FALSE;
        }
        else
            SysFreeString(pbstr);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\secstore.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __SECSTORE_H__
#define __SECSTORE_H__

#include <windows.h>
#include <ntsecapi.h>

#ifdef __cplusplus
extern "C"{
#endif

DWORD
RetrieveKey(PWCHAR      pwszKeyName,
            PBYTE *     ppbKey,
            DWORD *     pcbKey );

DWORD
StoreKey(   PWCHAR  pwszKeyName,
            BYTE *  pbKey,
            DWORD   cbKey );

DWORD
OpenPolicy( LPWSTR      ServerName,
            DWORD       DesiredAccess,
            PLSA_HANDLE PolicyHandle );

void
InitLsaString(  PLSA_UNICODE_STRING LsaString,
                LPWSTR              String );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\svcrole.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        svcrole.h
//
// Contents:    This is the include to include common we need
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __SVCROLE_H__
#define __SVCROLE_H__

#include <windows.h>
#include <ntsecapi.h>

// Netxxx API includes
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>

typedef enum _SERVER_ROLE_IN_DOMAIN
{
    SERVERROLE_ERROR,
    SERVERROLE_NOT4,
    SERVERROLE_NOTSERVER,
    SERVERROLE_STANDALONE,
    SERVERROLE_SERVER,
    SERVERROLE_PDC,
    SERVERROLE_BDC,
    SERVERROLE_NT4DOMAIN
} SERVER_ROLE_IN_DOMAIN;

#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    GetMachineGroup(
        LPWSTR pszServer,
        LPWSTR* pszGroupName
    );
    
    BOOL 
    IsDomainController( 
        LPWSTR Server, 
        LPBOOL bDomainController 
    );

    SERVER_ROLE_IN_DOMAIN 
    GetServerRoleInDomain( 
        LPWSTR Server 
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\svcrole.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        svcrole.c
//
// Contents:    This is the include to include common we need
//
// History:     
//
//---------------------------------------------------------------------------
#include "svcrole.h"
#include "secstore.h"
#include <dsgetdc.h>
#include <dsrole.h>

///////////////////////////////////////////////////////////////////////////////////

BOOL
GetMachineGroup(
    LPWSTR pszMachineName,
    LPWSTR* pszGroupName
    )

/*++


Note:

    Code modified from DISPTRUS.C

--*/

{
    LSA_HANDLE PolicyHandle; 
    DWORD dwStatus;
    NTSTATUS Status; 
    NET_API_STATUS nas = NERR_Success; // assume success 
 
    BOOL bSuccess = FALSE; // assume this function will fail 

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain = NULL; 
    LPWSTR szPrimaryDomainName = NULL; 
    LPWSTR DomainController = NULL; 
 
    // 
    // open the policy on the specified machine 
    // 
    Status = OpenPolicy( 
                    pszMachineName, 
                    POLICY_VIEW_LOCAL_INFORMATION, 
                    &PolicyHandle 
                ); 
 
    if(Status != ERROR_SUCCESS) 
    { 
        SetLastError( dwStatus = LsaNtStatusToWinError(Status) ); 
        return FALSE;
    } 
 
    // 
    // get the primary domain 
    // 
    Status = LsaQueryInformationPolicy( 
                            PolicyHandle, 
                            PolicyPrimaryDomainInformation, 
                            (PVOID *)&PrimaryDomain 
                        ); 

    if(Status != ERROR_SUCCESS) 
    {
        goto cleanup;  
    }

    *pszGroupName = (LPWSTR)LocalAlloc( 
                                    LPTR,
                                    PrimaryDomain->Name.Length + sizeof(WCHAR) // existing length + NULL 
                                ); 
 
    if(*pszGroupName != NULL) 
    { 
        // 
        // copy the existing buffer to the new storage, appending a NULL 
        // 
        lstrcpynW( 
            *pszGroupName, 
            PrimaryDomain->Name.Buffer, 
            (PrimaryDomain->Name.Length / sizeof(WCHAR)) + 1 
            ); 

        bSuccess = TRUE;
    } 
 

cleanup:

    if(PrimaryDomain != NULL)
    {
        LsaFreeMemory(PrimaryDomain); 
    }


    // 
    // close the policy handle 
    // 
    if(PolicyHandle != INVALID_HANDLE_VALUE) 
    {
        LsaClose(PolicyHandle); 
    }

    if(!bSuccess) 
    { 
        if(Status != ERROR_SUCCESS) 
        {
            SetLastError( LsaNtStatusToWinError(Status) ); 
        }
        else if(nas != NERR_Success) 
        {
            SetLastError( nas ); 
        }
    } 
 
    return bSuccess; 
}

///////////////////////////////////////////////////////////////////////////////////
BOOL 
IsDomainController(
    LPWSTR Server, 
    LPBOOL bDomainController 
    ) 
/*++


++*/
{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;
    nas = NetServerGetInfo( (LPTSTR)Server,
                            101,
                            (LPBYTE *)&si101 );

    if(nas != NERR_Success) 
    {
        SetLastError(nas);
        return FALSE; 
    }

    if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) )
    {
        // we are dealing with a DC
        // 
        *bDomainController = TRUE;
    }
    else 
    {
        *bDomainController = FALSE;
    }

    NetApiBufferFree(si101);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////
SERVER_ROLE_IN_DOMAIN 
GetServerRoleInDomain( 
    LPWSTR szServer 
    )
/*++


++*/
{
    SERVER_ROLE_IN_DOMAIN dwRetCode=SERVERROLE_ERROR;

    NET_API_STATUS nas;  
    NTSTATUS Status;  
    DWORD dwStatus;

    LSA_HANDLE PolicyHandle=INVALID_HANDLE_VALUE;     
    BOOL bPdc;

    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain=NULL; 
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain=NULL; 

    PSERVER_INFO_101 lpServerInfo101=NULL;

    GUID DomainGuid;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;


    //
    // Check if we're in a workgroup, if this call
    // failed, we use NetApi to retrieve information
    //
    dwStatus = DsRoleGetPrimaryDomainInformation(
                                                 NULL,
                                                 DsRolePrimaryDomainInfoBasic,
                                                 (PBYTE *) &pDomainInfo
                                                 );

    if ((dwStatus == NO_ERROR) && (pDomainInfo != NULL))
    {
        switch (pDomainInfo->MachineRole)
        {
            case DsRole_RoleStandaloneWorkstation:
            case DsRole_RoleStandaloneServer:
                dwRetCode = SERVERROLE_STANDALONE;
                goto cleanup;
                break;
        }

        //
        // check if we are in NT5 domain
        //
        dwStatus = DsGetDcName(
                               NULL,
                               NULL,
                               &DomainGuid,
                               NULL,
                               DS_DIRECTORY_SERVICE_PREFERRED,
                               &pDomainControllerInfo
                               );

        if(dwStatus == NO_ERROR && pDomainControllerInfo != NULL)
        {
            if(!(pDomainControllerInfo->Flags & DS_DS_FLAG))
            {
                //
                // We are in NT4 domain
                //
                dwRetCode = SERVERROLE_NT4DOMAIN;
                goto cleanup;
            }
        }
    }

    if(dwRetCode != SERVERROLE_ERROR)
    {
        // we already have information, don't try
        // NetApi anymore...
        goto cleanup;
    }

    //
    // Get Server information
    //
    nas = NetServerGetInfo( (LPTSTR)szServer, 
                            101,    // info-level         
                            (LPBYTE *)&lpServerInfo101 );  
    
    if(nas != NERR_Success)
    {
        dwRetCode=SERVERROLE_ERROR;
        SetLastError(nas);
        goto cleanup;
    }

    //     
    // open the policy on the specified machine     
    // 
    Status = OpenPolicy( szServer, 
                         POLICY_VIEW_LOCAL_INFORMATION,                 
                         &PolicyHandle );      
    
    if(Status != ERROR_SUCCESS) 
    { 
        SetLastError( LsaNtStatusToWinError(Status) );
        dwRetCode = SERVERROLE_ERROR;
        goto cleanup;
    }   

    // 
    // get the primary domain         
    // 
    Status = LsaQueryInformationPolicy( PolicyHandle, 
                                        PolicyPrimaryDomainInformation,
                                        (VOID **)&PrimaryDomain );
    
    if(Status != ERROR_SUCCESS) 
    {
        SetLastError( LsaNtStatusToWinError(Status) );
        dwRetCode = SERVERROLE_ERROR;
        goto cleanup;
    }   

    // 
    // if the primary domain Sid is NULL, we are a non-member
    //
    if(PrimaryDomain->Sid == NULL) 
    { 
        dwRetCode = SERVERROLE_STANDALONE;
        goto cleanup;
    } 

    // 
    // get the AccountDoamin domain         
    // 
    Status = LsaQueryInformationPolicy( PolicyHandle, 
                                        PolicyAccountDomainInformation,
                                        (VOID **)&AccountDomain );

    if(Status != ERROR_SUCCESS) 
    {
        SetLastError( LsaNtStatusToWinError(Status) );
        dwRetCode = SERVERROLE_ERROR;
        goto cleanup;
    }

    // 
    // if the primary domain Sid == AccountDomain Sid, we are DC
    //
    if(EqualSid(PrimaryDomain->Sid, AccountDomain->DomainSid) == FALSE)
    { 
        dwRetCode = SERVERROLE_SERVER;
        goto cleanup;
    }

    dwRetCode = (lpServerInfo101->sv101_type & SV_TYPE_DOMAIN_CTRL) ? SERVERROLE_PDC : SERVERROLE_BDC;

cleanup:
    if(AccountDomain)
    {
        LsaFreeMemory(AccountDomain); 
    }

    if(PrimaryDomain)
    {
        LsaFreeMemory(PrimaryDomain); 
    }

    if(PolicyHandle != INVALID_HANDLE_VALUE)
    {
        LsaClose(PolicyHandle); 
    }

    if(lpServerInfo101 != NULL)
    {
        NetApiBufferFree(lpServerInfo101);
    }

    if(pDomainControllerInfo != NULL)
    {
        NetApiBufferFree(pDomainControllerInfo);
    }

    if(pDomainInfo != NULL)
    {
        DsRoleFreeMemory(pDomainInfo);        
    }

    return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\common\secstore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:
//
//	secstore.c
//
// Contents:    
//
// History:     
//---------------------------------------------------------------------------
#include "secstore.h"
#include <stdlib.h>
#include <tchar.h>

///////////////////////////////////////////////////////////////////////////////
DWORD
RetrieveKey(
    PWCHAR      pwszKeyName,
    PBYTE *     ppbKey,
    DWORD *     pcbKey )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, pwszKeyName );

    Status = OpenPolicy( NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    if (NULL == pSecretData)
    {
        return ERROR_INTERNAL_ERROR;
    }

    if(pSecretData->Length)
    {
        *ppbKey = ( LPBYTE )LocalAlloc( LPTR, pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    ZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
StoreKey(
    PWCHAR  pwszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( &SecretKeyName, pwszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


///////////////////////////////////////////////////////////////////////////////
DWORD
OpenPolicy(
    LPWSTR      ServerName,
    DWORD       DesiredAccess,
    PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle ) );
}


///////////////////////////////////////////////////////////////////////////////
void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR              String )
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\debug\tsctst\tsctst.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <rpc.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <crt/io.h>
#include <wincrypt.h>
#include "license.h"
#include "certutil.h"

BYTE        g_pSecretKey[1024];
DWORD       g_cbSecretKey=sizeof(g_pSecretKey);

#define SAFESTRCPY(dest, source) \
    _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest) - sizeof(TCHAR)))

#define COMMON_STORE    TEXT("Software\\Microsoft\\MSLicensing\\Store")
#define LICENSE_VAL     TEXT("ClientLicense")

LPCSTR 
FileTimeText( 
    FILETIME *pft )
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime( pft, &ftLocal );

    if( FileTimeToSystemTime( &ftLocal, &st ) )
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
    
        strcpy(buf, asctime(&ctm));
    
        buf[strlen(buf)-1] = 0;
    }
    else
    {
        sprintf( buf, 
                 "<FILETIME %08lX:%08lX>", 
                 pft->dwHighDateTime,
                 pft->dwLowDateTime );
    }

    return buf;
}

void MyReportError(DWORD errCode)
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet=FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             errCode,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             NULL);

    if(dwRet != 0)
    {
        _tprintf(_TEXT("Error : %s (%d)\n"), lpszTemp, errCode);
        if(lpszTemp)
            LocalFree((HLOCAL)lpszTemp);
    }

    return;
}
//------------------------------------------------------------------------------------------
void DumpLicensedProduct(PLICENSEDPRODUCT pLicensedInfo)
{
    _tprintf(_TEXT("Version - 0x%08x\n"), pLicensedInfo->dwLicenseVersion);
    _tprintf(_TEXT("Quantity - %d\n"), pLicensedInfo->dwQuantity);
    _tprintf(_TEXT("Issuer - %s\n"), pLicensedInfo->szIssuer);
    _tprintf(_TEXT("Scope - %s\n"), pLicensedInfo->szIssuerScope);

    if(pLicensedInfo->szLicensedClient)
        _tprintf(_TEXT("Issued to machine - %s\n"), pLicensedInfo->szLicensedClient);

    if(pLicensedInfo->szLicensedUser)
        _tprintf(_TEXT("Issued to user - %s\n"), pLicensedInfo->szLicensedUser);

    _tprintf(_TEXT("Licensed Product\n"));
    _tprintf(_TEXT("\tHWID - 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x\n"),
             pLicensedInfo->Hwid.dwPlatformID,
             pLicensedInfo->Hwid.Data1,
             pLicensedInfo->Hwid.Data2,
             pLicensedInfo->Hwid.Data3,
             pLicensedInfo->Hwid.Data4);
    
    _tprintf(_TEXT("\tlanguage ID - 0x%08x\n"), pLicensedInfo->LicensedProduct.dwLanguageID);
    _tprintf(_TEXT("\tPlatform ID - 0x%08x\n"), pLicensedInfo->LicensedProduct.dwPlatformID);    
    _tprintf(_TEXT("\tProduct Version - 0x%08x\n"), pLicensedInfo->LicensedProduct.pProductInfo->dwVersion);
    _tprintf(_TEXT("\tCompany Name - %s\n"), pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName);
    _tprintf(_TEXT("\tProduct ID - %s\n"), pLicensedInfo->LicensedProduct.pProductInfo->pbProductID);

    for(DWORD i=0; i < pLicensedInfo->dwNumLicensedVersion; i++)
    {
        _tprintf(_TEXT("Licensed Product Version %04d.%04d, Flag 0x%08x\n"),
                 pLicensedInfo->pLicensedVersion[i].wMajorVersion,
                 pLicensedInfo->pLicensedVersion[i].wMinorVersion,
                 pLicensedInfo->pLicensedVersion[i].dwFlags);

        if (pLicensedInfo->pLicensedVersion[i].dwFlags & LICENSED_VERSION_TEMPORARY)
        {
            _tprintf(_TEXT("Temporary\t"));
        }
        else
        {
            _tprintf(_TEXT("Permanent\t"));
        }

        if (pLicensedInfo->pLicensedVersion[i].dwFlags & LICENSED_VERSION_RTM)
        {
            _tprintf(_TEXT("RTM\t"));
        }
        else
        {
            _tprintf(_TEXT("Beta\t"));
        }

        _tprintf(_TEXT("\n"));
    }

    printf("Not Before - %x %x %s\n",
             pLicensedInfo->NotBefore.dwHighDateTime,
             pLicensedInfo->NotBefore.dwLowDateTime,
             FileTimeText(&pLicensedInfo->NotBefore));
    
    printf("Not After - %x %x %s\n",
             pLicensedInfo->NotAfter.dwHighDateTime,
             pLicensedInfo->NotAfter.dwLowDateTime,
             FileTimeText(&pLicensedInfo->NotAfter));
}

int __cdecl main(int argc, char *argv[])
{
    HKEY hKey, hKeyStore;
    LPBYTE  lpKeyValue=NULL;
    DWORD   cbKeyValue;
    DWORD   dwStatus;
    DWORD   dwKeyType;
    TCHAR   lpName[128];
    DWORD   cName;
    FILETIME ftWrite;
    LICENSEDPRODUCT LicensedInfo[10];
    DWORD   dwNum;
    ULARGE_INTEGER  SerialNumber;
    BYTE pbKey[1024];
    DWORD cbKey=1024;
    LICENSE_STATUS lstatus;

    dwStatus=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          COMMON_STORE,
                          0,
                          KEY_READ,
                          &hKey);
                          
    if(dwStatus != ERROR_SUCCESS)
    {
        _tprintf(_TEXT("Can't open key - %ld\n"), dwStatus);
        return 0;
    }

    LSInitCertutilLib( 0 );

    LicenseGetSecretKey( &cbKey, pbKey );

    for (DWORD dwKey = 0; dwStatus == ERROR_SUCCESS; dwKey++)
    {
        cName = sizeof(lpName) / sizeof(TCHAR);

        dwStatus=RegEnumKeyEx(hKey,
                              dwKey,
                              lpName,
                              &cName,
                              NULL,
                              NULL,
                              NULL,
                              &ftWrite);
                          
        if (ERROR_SUCCESS == dwStatus)
        {
            dwStatus = RegOpenKeyEx(hKey,
                                    lpName,
                                    0,
                                    KEY_READ,
                                    &hKeyStore);
            
            if(dwStatus != ERROR_SUCCESS)
            {
                _tprintf(_TEXT("can't open store - %d\n"), dwStatus);
                goto cleanup;
            }

            cbKeyValue=0;
            dwStatus = RegQueryValueEx(hKeyStore,
                                       LICENSE_VAL,
                                       NULL,
                                       &dwKeyType,
                                       NULL,
                                       &cbKeyValue);

            if(dwStatus != ERROR_SUCCESS)
            {
                _tprintf(_TEXT("can't get value size - %d\n"), dwStatus);
                RegCloseKey(hKeyStore);
                goto cleanup;
            }

            lpKeyValue = (LPBYTE)malloc(cbKeyValue);
            if(!lpKeyValue)
            {
                _tprintf(_TEXT("Can't allocate %d bytes\n"), cbKeyValue);
                RegCloseKey(hKeyStore);
                goto cleanup;
            }

            dwStatus = RegQueryValueEx(hKeyStore,
                                       LICENSE_VAL,
                                       NULL,
                                       &dwKeyType,
                                       lpKeyValue,
                                       &cbKeyValue);
            if(dwStatus != ERROR_SUCCESS)
            {
                _tprintf(_TEXT("can't get value - %d\n"), dwStatus);
                free(lpKeyValue);
                RegCloseKey(hKeyStore);
                goto cleanup;
            }

            memset(LicensedInfo, 0, sizeof(LicensedInfo));

            dwNum = 10;

            lstatus = LSVerifyDecodeClientLicense(lpKeyValue, cbKeyValue, pbKey, cbKey, &dwNum, LicensedInfo);

            if (lstatus == LICENSE_STATUS_OK)
            {
                for (DWORD i = 0; i < dwNum; i++)
                {
                    _tprintf(_TEXT("\n*** License # %d ***\n"), i+1);
                    DumpLicensedProduct(LicensedInfo+i);
                }
                LSFreeLicensedProduct(LicensedInfo);
            }
            else
            {
                _tprintf(_TEXT("can't decode license - %d, %d\n"), lstatus, GetLastError());
                free(lpKeyValue);
                RegCloseKey(hKeyStore);
                goto cleanup;
            }

            free(lpKeyValue);

            RegCloseKey(hKeyStore);

            _tprintf(_TEXT("\n\n"));
        }            
    }

cleanup:
    RegCloseKey(hKey);

    LSShutdownCertutilLib();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\debug\tslicmode\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server License Mode Utility"
#define VER_INTERNALNAME_STR        "tslicmode"
#define VER_ORIGINALFILENAME_STR    "tslicmode.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\debug\tsctst\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Client License Dump"
#define VER_INTERNALNAME_STR        "tsctst"
#define VER_ORIGINALFILENAME_STR    "tsctst.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\debug\tslicmode\tslicmode.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <rpc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <crt/io.h>
#include <wincrypt.h>
#include <winsta.h>
#include <license.h>



/*****************************************************************************
 *
 *  MIDL_user_allocate
 *
 *    Handles RPC's allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

extern "C" void __RPC_FAR * __RPC_USER
midl_user_allocate(
    size_t Size
    )
{
    return( LocalAlloc(LMEM_FIXED,Size) );
}

/*****************************************************************************
 *
 *  MIDL_user_free
 *
 *    Handles RPC's de-allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

void __RPC_USER
midl_user_free(
    void __RPC_FAR *p
    )
{
    LocalFree( p );
}

void MyReportError(DWORD errCode)
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet=FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             errCode,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             NULL);

    if(dwRet != 0)
    {
        _tprintf(_TEXT("Error : %s (%d)\n"), lpszTemp, errCode);
        if(lpszTemp)
            LocalFree((HLOCAL)lpszTemp);
    }

    return;
}

void Usage(char * szName)
{
    wprintf(L"Usage: %S\n"
        L"\t-s <mode> - Set licensing mode\n"
        L"\t-g - Get licensing mode\n"
        L"\t-l - List available licensing modes\n"
        L"\t-i <mode> - Get information about licensing mode\n"
        L"\n"
        L"\t\t0:\tPersonal Terminal Server\n"
        L"\t\t1:\tRemote Administration\n"
        L"\t\t2:\tPer Seat\n"
        L"\t\t3:\tInternet Connector\n"
        L"\t\t4:\tPer Session\n"
            ,
            szName
        );
    return;
}

int __cdecl main(int argc, char *argv[])
{
    DWORD       dwStatus;
    DWORD       dwNewStatus;
    BOOL        fSet = FALSE;
    BOOL        fGet = FALSE;
    BOOL        fList = FALSE;
    BOOL        fInfo = FALSE;
    ULONG       ulMode;
    HANDLE      hServer = NULL;
    BOOL        fRet;
    ULONG       *pulPolicyIds = NULL;
    ULONG       cPolicies;
    ULONG       ulInfoStructVersion = LCPOLICYINFOTYPE_CURRENT;
    LPLCPOLICYINFO_V1W pPolicyInfo = NULL;

    if (argc < 2)
    {
        Usage(argv[0]);
        goto cleanup;
    }

    if ((argv[1][1] == 's') || (argv[1][1] == 'S'))
    {
        if (argc < 3)
        {
            Usage(argv[0]);
            goto cleanup;
        }

        ulMode = atol(argv[2]);

        fSet = TRUE;
    }
    else if ((argv[1][1] == 'i') || (argv[1][1] == 'I'))
    {
        if (argc < 3)
        {
            Usage(argv[0]);
            goto cleanup;
        }

        ulMode = atol(argv[2]);

        fInfo = TRUE;
    }
    else if ((argv[1][1] == 'g') || (argv[1][1] == 'G'))
    {
        fGet = TRUE;
    }
    else if ((argv[1][1] == 'l') || (argv[1][1] == 'L'))
    {
        fList = TRUE;
    }
    else
    {
        Usage(argv[0]);
        goto cleanup;
    }

    hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        wprintf(L"Connect to server failed\n");
        MyReportError(GetLastError());
        goto cleanup;
    }

    if (fGet)
    {
        fRet = ServerLicensingGetPolicy(
                                        hServer,
                                        &ulMode
                                        );

        wprintf(L"Get Mode\n");

        if (fRet)
        {
            wprintf(L"Mode: %d\n"
                    ,
                    ulMode
                    );
        }
        else
        {
            wprintf(L"Failed\n");
            MyReportError(GetLastError());
        }
    }
    else if (fList)
    {
        fRet = ServerLicensingGetAvailablePolicyIds(
                                                    hServer,
                                                    &pulPolicyIds,
                                                    &cPolicies
                                                    );
        wprintf(L"List Modes\n");

        if (fRet)
        {
            wprintf(L"Modes: \n");

            for (ULONG i = 0; i < cPolicies; i++)
            {
                wprintf(L"%d "
                        ,
                        pulPolicyIds[i]
                        );
            }

            wprintf(L"\n");

            MIDL_user_free(pulPolicyIds);
        }
        else
        {
            wprintf(L"Failed\n");
            MyReportError(GetLastError());
        }
    }
    else if (fSet)
    {
        dwStatus = ServerLicensingSetPolicy(hServer,
                                            ulMode,
                                            &dwNewStatus);

        wprintf(L"Set Mode\n"
                L"RPC Status: %d\n"
                L"New Mode Status: %d\n"
                ,
                dwStatus,
                dwNewStatus
                );

        if (ERROR_SUCCESS != dwStatus)
            MyReportError(dwStatus);
        else if (ERROR_SUCCESS != dwNewStatus)
            MyReportError(dwNewStatus);

    }
    else if (fInfo)
    {
        fRet = ServerLicensingGetPolicyInformation(
                                                   hServer,
                                                   ulMode,
                                                   &ulInfoStructVersion,
                                                   (LPLCPOLICYINFOGENERIC *) &pPolicyInfo
                                                   );

        if (fRet)
        {
            wprintf(L"Get Mode Info\n"
                    L"Name: %s\n"
                    L"Description: %s\n"
                    ,
                    pPolicyInfo->lpPolicyName,
                    pPolicyInfo->lpPolicyDescription
                );

            ServerLicensingFreePolicyInformation((LPLCPOLICYINFOGENERIC *)&pPolicyInfo);
        }
        else
        {
            wprintf(L"Failed\n");
            MyReportError(GetLastError());
        }
}

    ServerLicensingClose(hServer);

cleanup:

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\esetup\publish.cpp ===
/*
**	Copyright (c) 1998 Microsoft Corporation
**	All Rights Reserved
**
*/
#include <windows.h>
#include <wchar.h>
#include <objbase.h>
#include <winbase.h>

// Required by SSPI.H
#define SECURITY_WIN32
#include <sspi.h>

#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <activeds.h>

#define CWSTR_SIZE(x)       (sizeof(x) - (sizeof(WCHAR) * 2))
#define DWSTR_SIZE(x)       ((wcslen(x) + 1) * sizeof(WCHAR))

#define LICENSE_SETTINGS                L"TS-Enterprise-License-Server"
#define LICENSE_SETTINGS2               L"CN=TS-Enterprise-License-Server"
#define LICENSE_SETTINGS_OBJECT_CLASS   L"LicensingSiteSettings"
#define LICENSE_SETTINGS_FORMAT         L"LDAP://CN=%ws,CN=%ws,CN=%ws,%ws"
#define LICENSE_SETTINGS_SIZE           CWSTR_SIZE(LICENSE_SETTINGS)
#define LICENSE_SETTINGS_FORMAT_SIZE    CWSTR_SIZE(LICENSE_SETTINGS_FORMAT)
#define SITES               L"sites"
#define SITES_SIZE          CWSTR_SIZE(SITES)
#define SITE_SERVER         L"siteServer"
#define SITE_FORMAT         L"LDAP://CN=%ws,CN=%ws,%ws"
#define SITE_FORMAT_SIZE    CWSTR_SIZE(SITE_FORMAT)
#define CONFIG_CNTNR        L"ConfigurationNamingContext"
#define ROOT_DSE_PATH       L"LDAP://RootDSE"

HRESULT GetLicenseSettingsObjectP(VARIANT *pvar,
                                 LPWSTR *ppwszLicenseSettings,
                                 LPWSTR *ppwszSiteName,
                                 IADs **ppADs)
{
    HRESULT          hr;
    DWORD            dwErr;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs = NULL;

    VariantInit(pvar);
    
    dwErr = DsGetSiteName(NULL, ppwszSiteName);

    if (dwErr != 0)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"DsGetSiteName failed %d - 0x%x\n",dwErr,HRESULT_FROM_WIN32(dwErr));
#endif
        return HRESULT_FROM_WIN32(dwErr);
    }

    //
    // Obtain the path to the configuration container.
    //

    hr = ADsGetObject(ROOT_DSE_PATH, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject (%ws) failed 0x%x \n",ROOT_DSE_PATH,dwErr);
#endif
        goto CleanExit;
    }

    hr = pADs->Get(CONFIG_CNTNR, pvar);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Get (%ws) failed 0x%x \n",CONFIG_CNTNR,hr);
#endif
        goto CleanExit;
    }

    if (V_VT(pvar) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Bad pvar 0x%x \n",hr);
#endif
        goto CleanExit;
    }

    pwszConfigContainer = pvar->bstrVal;  // For sake of readability.

    //
    // Build the X.500 path to the LicenseSettings object.
    //

    *ppwszLicenseSettings = (LPWSTR)LocalAlloc(
                                    LPTR,
                                    LICENSE_SETTINGS_FORMAT_SIZE
                                        + LICENSE_SETTINGS_SIZE
                                        + DWSTR_SIZE(*ppwszSiteName)
                                        + SITES_SIZE
                                        + DWSTR_SIZE(pwszConfigContainer)
                                        + sizeof(WCHAR));

    if (*ppwszLicenseSettings == NULL) {
        hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
        wprintf(L"LocalAlloc failed 0x%x \n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(*ppwszLicenseSettings,
             LICENSE_SETTINGS_FORMAT,
             LICENSE_SETTINGS,
             *ppwszSiteName,
             SITES,
             pwszConfigContainer);

    hr = ADsGetObject(*ppwszLicenseSettings, IID_IADs, (void **)ppADs);

CleanExit:

#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject (%ws) failed? 0x%x \n",*ppwszLicenseSettings,hr);
#endif

    if (NULL != pADs) {
        pADs->Release();
    }

    return hr;
}

HRESULT
GetServerPos(IADs *pADs,
              VARIANT *pvar,
              LONG *plLower,
              LONG *plUpper,
              LONG *plPos,
              WCHAR *ComputerName
             )
{
    HRESULT          hr;
    VARIANT          var;
    SAFEARRAY        *psaServers;

    VariantInit(&var);

    hr = pADs->GetEx(SITE_SERVER,pvar);
    if (FAILED(hr))
    {
        hr = S_FALSE;   // already gone
        goto CleanExit;
    }

    psaServers = V_ARRAY(pvar);
    if (NULL == psaServers)
    {
        hr = S_FALSE;      // already gone
        goto CleanExit;
    }

    hr= SafeArrayGetLBound( psaServers, 1, plLower );
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    hr= SafeArrayGetUBound( psaServers, 1, plUpper );
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    for( *plPos = *plLower; *plPos <= *plUpper; *plPos++ )
    {
        VariantClear( &var );
        hr = SafeArrayGetElement( psaServers, plPos, &var );
        if (SUCCEEDED(hr) && (V_VT(&var) == VT_BSTR) && (V_BSTR(&var) != NULL))
        {
            if (0 == lstrcmpi(V_BSTR(&var),ComputerName))
            {
                hr = S_OK;
                goto CleanExit;
            }
        }
    }

    hr = S_FALSE;

CleanExit:
    VariantClear(&var);

    return hr;
}

extern "C" 
HRESULT
PublishEnterpriseServer()
{
    LPWSTR           pwszSiteName = NULL;
    DWORD            dwErr;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs         = NULL;
    IADs *           pADs2        = NULL;
    IADsContainer *  pADsContainer = NULL;
    VARIANT          var;
    VARIANT          var2;
    VARIANT          var3;
    VARIANT          var4;
    LPWSTR           pwszLicenseSettings = NULL;
    LPWSTR           pwszSite = NULL;
    IDispatch *      pDisp = NULL;
	WCHAR            ComputerName[MAX_PATH+1];
    ULONG            ulen;
   	BOOL             br;
    HRESULT          hr;
    LONG             lLower,lUpper,lPos;
    SAFEARRAYBOUND   sabServers;
    LPWSTR           pwszDN         = NULL;
    DS_NAME_RESULT * pDsResult      = NULL;
    HANDLE           hDS;
    LPWSTR           rgpwszNames[2];
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    LPWSTR           pwszDomain;
    WCHAR            wszName[MAX_PATH + 1];

    //
	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE
    //
	hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"CoInitializeEx failed 0x%lx\n",hr);
#endif
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    VariantInit(&var3);
    VariantInit(&var4);
    
    // Get the computer name of the local computer.
    ulen = sizeof(ComputerName) / sizeof(TCHAR);
    br = GetComputerName(ComputerName, &ulen);

    if (!br)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
#ifdef PRIVATEDEBUG
        wprintf(L"GetComputerName failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Get domain name
    //
    hr = DsGetDcName(NULL,
                     NULL,
                     NULL,
                     NULL,
                     DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_FLAT_NAME,
                     &pDCInfo);


    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsGetDcName failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    pwszDomain = pDCInfo->DomainName;

    //
    // Bind to the DS (get a handle for use with DsCrackNames).
    //

    hr = DsBind(NULL, pwszDomain, &hDS);

    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsBind failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Request the DS-DN of this server's computer object.
    //

    if (lstrlen(pwszDomain) + lstrlen(ComputerName) + 3 > sizeof(wszName) / sizeof(WCHAR))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Domain or ComputerName too long\n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(wszName,
             L"%ws\\%ws$",
             pwszDomain,
             ComputerName);

    rgpwszNames[0] = wszName;
    rgpwszNames[1] = NULL;

    hr = DsCrackNames(hDS,
                      DS_NAME_NO_FLAGS,
                      DS_UNKNOWN_NAME,
                      DS_FQDN_1779_NAME,
                      1,
                      &rgpwszNames[0],
                      &pDsResult);

    DsUnBind(&hDS);

    if (hr != ERROR_SUCCESS)
    {

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (pDsResult->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDsResult->rItems[0].status == DS_NAME_ERROR_RESOLVING) {
            hr = ERROR_PATH_NOT_FOUND;
        }
        else {
            hr = pDsResult->rItems[0].status;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames (%ws) result bad 0x%lx\n",ComputerName,hr);
#endif
        goto CleanExit;
    }

    V_VT(&var3) = VT_BSTR;
    pwszDN = pDsResult->rItems[0].pName;
    V_BSTR(&var3) = SysAllocString(pwszDN);
    
    if (NULL == V_BSTR(&var3))
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }

    hr = GetLicenseSettingsObjectP(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);

    pwszConfigContainer = var.bstrVal;

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        // Doesn't yet exist, create it

        //
        // Build the X.500 path to the Site object.
        //

        pwszSite = (LPWSTR)LocalAlloc(LPTR,
                                      SITE_FORMAT_SIZE
                                      + DWSTR_SIZE(pwszSiteName)
                                      + SITES_SIZE
                                      + DWSTR_SIZE(pwszConfigContainer)
                                      + sizeof(WCHAR));

        if (pwszSite == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        wsprintf(pwszSite,
                 SITE_FORMAT,
                 pwszSiteName,
                 SITES,
                 pwszConfigContainer);

        hr = ADsGetObject(pwszSite,
                          IID_IADsContainer,
                          (void **)&pADsContainer);
        
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject (%ws) failed 0x%lx\n",pwszSite,hr);
#endif
            goto CleanExit;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"Got container (%ws)\n",pwszSite);
#endif

        //
        // Create the license settings leaf object.
        //

        hr = pADsContainer->Create(LICENSE_SETTINGS_OBJECT_CLASS,
                                   LICENSE_SETTINGS2,
                                   &pDisp);

        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Create (LICENSE_SETTINGS) failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"Created (%ws)\n",LICENSE_SETTINGS2);
#endif

        hr = pDisp->QueryInterface(IID_IADs,
                                   (void **)&pADs2);

        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"QueryInterface failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }

        hr = pADs2->Put(SITE_SERVER,var3);
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Put (%ws) failed 0x%lx\n",SITE_SERVER,hr);
#endif
            goto CleanExit;
        }

        //
        // Persist the change via SetInfo.
        //

        hr = pADs2->SetInfo();
        
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"SetInfo (%ws)=(%ws) failed 0x%lx\n",SITE_SERVER,V_BSTR(&var3),hr);
#endif
            goto CleanExit;
        }

    } else if (SUCCEEDED(hr))
    {
        // Already exists; update it

        hr = GetServerPos(pADs,&var2,&lLower,&lUpper,&lPos,pwszDN);

        if (FAILED(hr) || (hr == S_OK))
        {
#ifdef PRIVATEDEBUG
        wprintf(L"GetServerPos failed ? 0x%lx\n",hr);
#endif
            goto CleanExit;
        }

        hr = ADsBuildVarArrayStr( &(V_BSTR(&var3)), 1, &var4);
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsBuildVarArrayStr (%ws) failed 0x%lx\n",V_BSTR(&var3),hr);
#endif
            goto CleanExit;
        }

        hr = pADs->PutEx(ADS_PROPERTY_APPEND,SITE_SERVER,var4);

        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"PutEx (%ws)=(%ws) failed 0x%lx\n",SITE_SERVER,V_BSTR(&var3),hr);
#endif
            goto CleanExit;
        }

        hr = pADs->SetInfo();
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"SetInfo 2 failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }
    } else
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetLicenseSettingsObject failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);
    VariantClear(&var3);
    VariantClear(&var4);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (pwszSite != NULL) {
        LocalFree(pwszSite);
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (NULL != pADs2) {
        pADs2->Release();
    }

    if (NULL != pDisp) {
        pDisp->Release();
    }

    if (NULL != pADsContainer) {
        pADsContainer->Release();
    }

    if (pDsResult != NULL) {
        DsFreeNameResult(pDsResult);
    }

    if (pDCInfo != NULL) {
        NetApiBufferFree(pDCInfo); // Allocated from DsGetDcName
    }

    CoUninitialize();

    return hr;
}

extern "C"
HRESULT
UnpublishEnterpriseServer()
{
    IADs *           pADs         = NULL;
    HRESULT          hr;
    LPWSTR           pwszLicenseSettings = NULL;
    LPWSTR           pwszSiteName = NULL;
    VARIANT          var;
    VARIANT          var2;
    VARIANT          var3;
    SAFEARRAYBOUND   sabServers;
	WCHAR            ComputerName[MAX_PATH+1];
    ULONG            ulen;
   	BOOL             br;
    LONG             lPos,lLower, lUpper;
    DS_NAME_RESULT * pDsResult      = NULL;
    HANDLE           hDS;
    LPWSTR           rgpwszNames[2];
    LPWSTR           pwszDN;
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    LPWSTR           pwszDomain;
    WCHAR            wszName[MAX_PATH + 1];

	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE

	hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    VariantInit(&var3);
    
    // Get the computer name of the local computer.
    ulen = sizeof(ComputerName) / sizeof(TCHAR);
    br=GetComputerName(ComputerName,
                       &ulen);
    if (!br)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CleanExit;
    }

    //
    // Get domain name
    //
    hr = DsGetDcName(NULL,
                     NULL,
                     NULL,
                     NULL,
                     DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_FLAT_NAME,
                     &pDCInfo);


    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsGetDcName failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    pwszDomain = pDCInfo->DomainName;

    //
    // Bind to the DS (get a handle for use with DsCrackNames).
    //

    hr = DsBind(NULL, pwszDomain, &hDS);

    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsBind failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Request the DS-DN of this server's computer object.
    //

    if (lstrlen(pwszDomain) + lstrlen(ComputerName) + 3 > sizeof(wszName) / sizeof(WCHAR))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Domain or ComputerName too long\n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(wszName,
             L"%ws\\%ws$",
             pwszDomain,
             ComputerName);

    rgpwszNames[0] = wszName;
    rgpwszNames[1] = NULL;

    hr = DsCrackNames(hDS,
                      DS_NAME_NO_FLAGS,
                      DS_UNKNOWN_NAME,
                      DS_FQDN_1779_NAME,
                      1,
                      &rgpwszNames[0],
                      &pDsResult);

    DsUnBind(&hDS);

    if (hr != ERROR_SUCCESS)
    {

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (pDsResult->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDsResult->rItems[0].status == DS_NAME_ERROR_RESOLVING) {
            hr = ERROR_PATH_NOT_FOUND;
        }
        else {
            hr = pDsResult->rItems[0].status;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames result bad 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    V_VT(&var3) = VT_BSTR;
    pwszDN = pDsResult->rItems[0].pName;
    V_BSTR(&var3) = SysAllocString(pwszDN);
    
    if (NULL == V_BSTR(&var3))
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }

    hr = GetLicenseSettingsObjectP(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        hr = S_OK;      // already gone
        goto CleanExit;
    }

    if (FAILED(hr))
    {
        goto CleanExit;
    }

#ifdef PRIVATEDEBUG
        wprintf(L"pADs %ws NULL \n",(pADs == NULL) ? L"==" : L"!=");
        if (NULL == pADs)
        {
            goto CleanExit;
        }
#endif

    hr = GetServerPos(pADs,&var2,&lLower,&lUpper,&lPos,pwszDN);

    if (FAILED(hr))
    {
        goto CleanExit;
    }

    if (hr == S_FALSE)
    {
        hr = S_OK;      // Already gone
        goto CleanExit;
    }

    if (lLower == lUpper)
    {
        // only one element, delete
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR,SITE_SERVER,var2);
        if (FAILED(hr)) {
            goto CleanExit;
        }
    }
    else
    {
        if (lPos != lUpper)
        {
            // move the last element here
            SafeArrayGetElement(V_ARRAY(&var2),&lUpper,&var3);
            SafeArrayPutElement(V_ARRAY(&var2),&lPos,&var3);
        }

        sabServers.lLbound = lLower;
        sabServers.cElements = lUpper-lLower;

        SafeArrayRedim(V_ARRAY(&var2),&sabServers);
                    
        hr = pADs->Put(SITE_SERVER,var2);
        if (FAILED(hr)) {
            goto CleanExit;
        }
    }

    hr = pADs->SetInfo();
    if (FAILED(hr)) {
        goto CleanExit;
    }

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);
    VariantClear(&var3);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (pDCInfo != NULL) {
        NetApiBufferFree(pDCInfo); // Allocated from DsGetDcName
    }

    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\hpool.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __HANDLE_POOL_H__
#define __HANDLE_POOL_H__

#include <windows.h>
#include <limits.h>
#include "locks.h"


/////////////////////////////////////////////////////////////////////////////
//
//  handle pool template class
//
//  Note that STL's LIST class is used instead of VECTOR
//
/////////////////////////////////////////////////////////////////////////////
template<class T, DWORD max=ULONG_MAX>
class CHandlePool 
{
private:
    long m_NumWaiting;

    // HUEIWANG 1/23/98
    // C++ compiler 10.00.5256 can't compile STL
    // _STD list<T> m_Handles;                // STL's list 

    typedef struct _HandleList {
        BOOL bAvailable;
        T m_Value;
        struct _HandleList *next;
    } HandleList, *LPHandleList;

    //
    // List of handles in the pool
    //
    LPHandleList m_Handles;
    DWORD m_TotalHandles;

    //
    // Semaphore for available handles
    //
    CTSemaphore<0, LONG_MAX> m_Available;

    // critical section guarding m_Handles.
    CCriticalSection m_CS;                  
    
    //DWORD m_MaxHandles;                     

public:

    CHandlePool();
    ~CHandlePool();   

    HRESULT 
    AcquireHandle(
        T* pHandle, 
        DWORD dwWaitFile=INFINITE
    );

    BOOL
    AcquireHandleEx(
        IN HANDLE hWaitHandle,
        IN OUT T* pHandle, 
        IN DWORD dwWaitFime=INFINITE
    );

    void 
    ReleaseHandle(
        T pRetHandle
    );

    DWORD 
    GetNumberAvailable();

    DWORD 
    GetMaxHandles() { 
        return max; 
    }
};

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline CHandlePool<T, max>::CHandlePool()
{
    // m_MaxHandles=max;

    m_NumWaiting=0;
    m_Handles=NULL;
    m_TotalHandles=0;
}

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline CHandlePool<T, max>::~CHandlePool()
{
    // delete all handles still in cache
    // might result in handle leak.
    //for(_STD list<T>::iterator it=m_Handles.begin(); it != m_Handles.end(); it++)
    //    delete it;

    while(m_Handles)
    {
        LPHandleList ptr;

        ptr=m_Handles;
        m_Handles = m_Handles->next;
        delete ptr;
    }
}

//--------------------------------------------------------------------------------    

template<class T, DWORD max>
inline BOOL 
CHandlePool<T, max>::AcquireHandleEx(
    IN HANDLE hWaitHandle,
    IN OUT T* pHandle, 
    IN DWORD dwWaitFime /* infinite */
    )
/*
*/
{
    BOOL bSuccess;

    InterlockedIncrement(&m_NumWaiting);
    bSuccess = m_Available.AcquireEx(
                                hWaitHandle, 
                                dwWaitFime, 
                                FALSE
                            );

    // Available is a semaphore not mutex object.
    if(bSuccess == TRUE)
    {
        // Object Constructor will lock critical section and
        // destructor will unlock critical section
        CCriticalSectionLocker locker(m_CS);

        //assert(m_Handles.size());
        //*pHandle = m_Handles.front();
        //m_Handles.pop_front();
        LPHandleList ptr;

        assert(m_Handles != NULL);
        *pHandle = m_Handles->m_Value;
        ptr=m_Handles;
        m_Handles = m_Handles->next;
        delete ptr;
        m_TotalHandles--;
    }

    InterlockedDecrement(&m_NumWaiting);
    return bSuccess;
}


//--------------------------------------------------------------------------------    
template<class T, DWORD max>
inline HRESULT CHandlePool<T, max>::AcquireHandle(
    IN OUT T* pHandle, 
    IN DWORD dwWaitFime /* infinite */
    )
/*
*/
{
    DWORD status;

    InterlockedIncrement(&m_NumWaiting);
    status = m_Available.Acquire(dwWaitFime, FALSE);

    // Available is a semaphore not mutex object.
    if(status == WAIT_OBJECT_0)
    {
        // Object Constructor will lock critical section and
        // destructor will unlock critical section
        CCriticalSectionLocker locker(m_CS);

        //assert(m_Handles.size());
        //*pHandle = m_Handles.front();
        //m_Handles.pop_front();
        LPHandleList ptr;

        assert(m_Handles != NULL);
        *pHandle = m_Handles->m_Value;
        ptr=m_Handles;
        m_Handles = m_Handles->next;
        delete ptr;
        m_TotalHandles--;

        status = ERROR_SUCCESS;
    }

    InterlockedDecrement(&m_NumWaiting);
    return status;
}

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline void CHandlePool<T, max>::ReleaseHandle(
    T pRetHandle
    )
/*
*/
{
    if(pRetHandle)
    {
        CCriticalSectionLocker lock(m_CS);
        if( InterlockedExchange(&m_NumWaiting, m_NumWaiting) > 0 || 
            m_TotalHandles < max)
        {
            //m_Handles.push_back(pRetHandle);
            LPHandleList ptr;

            ptr = new HandleList;
            ptr->m_Value = pRetHandle;
            ptr->next = m_Handles;
            m_Handles = ptr;
            m_TotalHandles++;
            m_Available.Release(1);
        }
        else
        {
            // only cache so many handles.
            delete pRetHandle;
        }
    }

    return;
}

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline DWORD CHandlePool<T, max>::GetNumberAvailable()
{
    UINT numAvailable;

    m_CS.Lock();

    // numAvailable = m_Handles.size();
    numAvailable = m_TotalHandles;

    m_CS.UnLock();
    return numAvailable;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\lscommon.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        lscommon.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __LSCOMMON_H__
#define __LSCOMMON_H__

//
// Setup related
//
#define SZAPPNAME                       "lserver"
#define SZSERVICENAME                   "TermServLicensing"
#define SZSERVICEDISPLAYNAME            "Terminal Server Licensing"
#define LSERVER_DEFAULT_DBDIR           "lserver"
#define SZDEPENDENCIES                  "RPCSS\0\0"
#define SZACCESSDRIVERNAME              "Microsoft Access Driver (*.mdb)"

#define LSERVER_LSA_PASSWORD_KEYNAME    _TEXT("TermServLiceningPwd-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")
#define LSERVER_LSA_LASTRUN             _TEXT("TermServLicensingStatus-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")
#define LSERVER_LSA_SETUPID             _TEXT("TermServLicensingSetupId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

//
// Keep this here for License Server OC setup.
//
#define LSERVER_LSA_STRUCT_VERSION      0x00010000  // version 1.0
typedef struct {
    DWORD dwVersion;
    DWORD dwMaxKeyPackId;
    DWORD dwMaxLicenseId;
} TLServerLastRunState, *LPTLServerLastRunState;

#define LSERVER_LSA_LASTRUN_VER_CURRENT LSERVER_LSA_STRUCT_VERSION20
typedef struct {
    DWORD dwVersion;
    DWORD dwMaxKeyPackId;
    DWORD dwMaxLicenseId;
    FILETIME ftLastShutdownTime;
} TLServerLastRun, *LPTLServerLastRun;

#define LSERVER_LSA_STRUCT_VERSION20    0x00020000

#define LSERVER_DEFAULT_DBPATH          _TEXT("%SYSTEMROOT%\\SYSTEM32\\LSERVER\\")
#define LSERVER_DEFAULT_USER            _TEXT("sa")
#define LSERVER_DEFAULT_PWD             _TEXT("password")
#define LSERVER_DEFAULT_EDB             _TEXT("TLSLic.edb")
#define LSERVER_DEFAULT_EMPTYEDB        _TEXT("Empty.edb")


//-----------------------------------------------------------------------------
//
// TODO - client need to define this
//
#define LSERVER_DISCOVERY_PARAMETER_KEY "Software\\Microsoft\\MSLicensing\\Parameters"
#define LSERVER_LOOKUP_TIMEOUT          "TimeOut"
#define LSERVER_LOOKUP_DEFAULT_TIMEOUT  1*1000  // default to 1 second timeout


//-----------------------------------------------------------------------------
//
// RPC 
//
#define RPC_ENTRYNAME           "/.:/HydraLSFrontEnd"
#define RPC_PROTOSEQTCP         "ncacn_ip_tcp"
#define RPC_PROTOSEQLPC         "ncalrpc"

 
#define RPC_PROTOSEQNP          "ncacn_np" 
#define HLSPIPENAME             "HydraLsPipe"
#define LSNAMEPIPE              "\\pipe\\HydraLsPipe"


#define SERVERMAILSLOTNAME     "HydraLsServer"
#define CLIENTMAILSLOTNAME     "HydraLsClient"


#define MAX_MAILSLOT_MSG_SIZE   MAX_COMPUTERNAME_LENGTH+_MAX_PATH+80

//
// Currently supported mailslot protocol
//
#define LSERVER_DISCOVERY       "DISC"
#define LSERVER_CHALLENGE       "CHAL"
#define LSERVER_OPEN_BLK        '<'
#define LSERVER_CLOSE_BLK       '>'

// -------------------------------------------------------------------------------
//
// Current database version
//
//

#define W2K_BETA3_JETBLUE_DBVERSION     0x00000001
#define W2K_RTM_JETBLUE_DBVERSION       0x00000002
#define ENFORCE_JETBLUE_DBVERSION       0x80000000

#ifdef ENFORCE_LICENSING

#define TLS_BETA_DBVERSION      ENFORCE_JETBLUE_DBVERSION | W2K_BETA3_JETBLUE_DBVERSION
#define TLS_CURRENT_DBVERSION   ENFORCE_JETBLUE_DBVERSION | W2K_RTM_JETBLUE_DBVERSION

#else

#define TLS_BETA_DBVERSION      W2K_BETA3_JETBLUE_DBVERSION
#define TLS_CURRENT_DBVERSION   W2K_RTM_JETBLUE_DBVERSION

#endif

#define IS_ENFORCE_VERSION(x) (x & 0x80000000)
#define DATABASE_VERSION(x) (x & 0x7FFFFFFF)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\esetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       esetup.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-02-98   RobLeit     Created
//
//----------------------------------------------------------------------------

#ifndef __ESETUP_H__
#define __ESETUP_H__

#ifdef __cplusplus
extern "C" {
#endif

HRESULT PublishEnterpriseServer();
HRESULT UnpublishEnterpriseServer();

#ifdef __cplusplus
};
#endif

#endif // __ESETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\tlsassrt.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSASSERT_H__
#define __TLSASSERT_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#define TLSASSERT(exp)  ASSERT(exp)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\locks.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        
//
// Contents:    
//
// History:     12-09-97    HueiWang    
//
//---------------------------------------------------------------------------
#ifndef __LS_LOCKS_H
#define __LS_LOCKS_H

#include <windows.h>
#include "assert.h"

#define ARRAY_COUNT(a) sizeof(a) / sizeof(a[0])

typedef enum { WRITER_LOCK, READER_LOCK, NO_LOCK } RWLOCK_TYPE;
//-------------------------------------------------------------------------
template <int init_count, int max_count>
class CTSemaphore {
private:
    HANDLE m_semaphore;

public:
    CTSemaphore() : m_semaphore(NULL)
    { 
        m_semaphore=CreateSemaphore(NULL, init_count, max_count, NULL); 
        assert(m_semaphore != NULL);
    }

    ~CTSemaphore()                 
    { 
        if(m_semaphore) 
            CloseHandle(m_semaphore); 
    }

    DWORD Acquire(int WaitTime=INFINITE, BOOL bAlertable=FALSE) 
    { 
        return WaitForSingleObjectEx(m_semaphore, WaitTime, bAlertable);
    }

    BOOL
    AcquireEx(
            HANDLE hHandle, 
            int dwWaitTime=INFINITE, 
            BOOL bAlertable=FALSE
        ) 
    /*++

    --*/
    { 
        BOOL bSuccess = TRUE;
        DWORD dwStatus;
        HANDLE hHandles[] = {m_semaphore, hHandle};

        if(hHandle == NULL || hHandle == INVALID_HANDLE_VALUE)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            bSuccess = FALSE;
        }
        else
        {
            dwStatus = WaitForMultipleObjectsEx(
                                        sizeof(hHandles)/sizeof(hHandles[0]),
                                        hHandles,
                                        FALSE,
                                        dwWaitTime,
                                        bAlertable
                                    );

            if(dwStatus != WAIT_OBJECT_0)
            {
                bSuccess = FALSE;
            }
        }

        return bSuccess;
    }


    BOOL Release(long count=1)          
    { 
        return ReleaseSemaphore(m_semaphore, count, NULL); 
    }

    BOOL IsGood()
    { 
        return m_semaphore != NULL; 
    }
};
//-------------------------------------------------------------------------
class CCriticalSection {
    CRITICAL_SECTION m_CS;
    BOOL m_bGood;
public:
    CCriticalSection(
        DWORD dwSpinCount = 4000    // see InitializeCriticalSection...
    ) : m_bGood(TRUE)
    { 
        
        __try {
            InitializeCriticalSectionAndSpinCount(&m_CS,  dwSpinCount); 
        } 
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError(GetExceptionCode());
            m_bGood = FALSE;
        }
    }

    ~CCriticalSection()              
    { 
        if(IsGood() == TRUE)
        {
            DeleteCriticalSection(&m_CS); 
        }
    }

    BOOL
    IsGood() { return m_bGood; }

    void Lock() 
    {
        EnterCriticalSection(&m_CS);
    }

    void UnLock()
    {
        LeaveCriticalSection(&m_CS);
    }

    BOOL TryLock()
    {
        return TryEnterCriticalSection(&m_CS);
    }
};
//--------------------------------------------------------------------------
class CCriticalSectionLocker {
public:
    CCriticalSectionLocker( CCriticalSection& m ) : m_cs(m) 
    { 
        m.Lock(); 
    }

    ~CCriticalSectionLocker() 
    { 
        m_cs.UnLock(); 
    }
private:
    CCriticalSection& m_cs;
};

//-----------------------------------------------------------
class CSafeCounter {
private:
    //CCriticalSection m_cs;
    long m_Counter;

    //inline void 
    //Lock() 
    //{
    //    m_cs.Lock();
    //}

    //inline void 
    //Unlock() 
    //{
    //    m_cs.UnLock();
    //}

public:

    CSafeCounter(
        long init_value=0
        ) : 
        m_Counter(init_value) 
    /*++

    --*/
    {
    }

    ~CSafeCounter() 
    {
    }

    operator+=(long dwValue)
    {
        long dwNewValue;

        //Lock();
        //dwNewValue = (m_Counter += dwValue);
        //Unlock();
        //return dwNewValue;

        dwNewValue = InterlockedExchangeAdd( &m_Counter, dwValue );
        return dwNewValue += dwValue;
    }

    operator-=(long dwValue)
    {
        long dwNewValue;

        //Lock();
        //dwNewValue = (m_Counter -= dwValue);
        //Unlock();
        //return dwNewValue;

        dwNewValue = InterlockedExchangeAdd( &m_Counter, -dwValue );
        return dwNewValue -= dwValue;
    }

    operator++() 
    {
        //long dwValue;
        //Lock();
        //dwValue = ++m_Counter;
        //Unlock();
        //return dwValue;        

        return InterlockedIncrement(&m_Counter);
    }

    operator++(int) 
    {
        //long dwValue;
        //Lock();
        //dwValue = m_Counter++;
        //Unlock();
        //return dwValue;

        long lValue;
        lValue = InterlockedIncrement(&m_Counter);
        return --lValue;
    }

    operator--() 
    {
        //long dwValue;
        //Lock();
        //dwValue = --m_Counter;
        //Unlock();
        //return dwValue;        

        return InterlockedDecrement(&m_Counter);
    }

    operator--(int) 
    {
        //long dwValue;

        //Lock();
        //dwValue = m_Counter--;
        //Unlock();
        //return dwValue;        
        long lValue;

        lValue = InterlockedDecrement(&m_Counter);
        return ++lValue;
    }

    operator long()
    {
        //long lValue;

        //Lock();
        //lValue = m_Counter;
        //Unlock();
        //return lValue;

        return InterlockedExchange(&m_Counter, m_Counter);
    }

    //operator DWORD()
    //{
    //    long dwValue;

    //    Lock();
    //    dwValue = m_Counter;
    //    Unlock();
    //    return dwValue;
    //}

    operator=(const long dwValue)
    {
        //Lock();
        //m_Counter = dwValue;
        //Unlock();
        //return dwValue;

        InterlockedExchange(&m_Counter, dwValue);
        return dwValue;
    }
};    

//-------------------------------------------------------------------------
// HueiWang 12/23/97 need more testing...
class CRWLock 
{ 
private:
    HANDLE hMutex;
    HANDLE hWriterMutex;
    HANDLE hReaderEvent;
    long   iReadCount;
    long   iWriteCount;

    long   iReadEntry;
    long   iWriteEntry;

public:

    CRWLock()  
    { 
        BOOL bSuccess=Init(); 
        assert(bSuccess == TRUE);
    }

    ~CRWLock() 
    { 
        Cleanup();  
    }

    //-----------------------------------------------------------
    BOOL 
    Init()
    {
        hReaderEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
        hMutex = CreateEvent(NULL,FALSE,TRUE,NULL);
        hWriterMutex = CreateMutex(NULL,FALSE,NULL);
        if(!hReaderEvent || !hMutex || !hWriterMutex)
            return FALSE;

        iReadCount = -1;
        iWriteCount = -1;
        iReadEntry = 0;
        iWriteEntry = 0;

        return (TRUE);
    }

    //-----------------------------------------------------------
    void 
    Cleanup()
    {
        CloseHandle(hReaderEvent);
        CloseHandle(hMutex);
        CloseHandle(hWriterMutex);

        iReadCount = -1;
        iWriteCount = -1;
        iReadEntry = 0;
        iWriteEntry = 0;
    }

    //-----------------------------------------------------------
    void 
    Acquire(
        RWLOCK_TYPE lockType
        )
    /*++

    ++*/
    {
        if (lockType == WRITER_LOCK) 
        {  
            InterlockedIncrement(&iWriteCount);
            WaitForSingleObject(hWriterMutex,INFINITE);
            WaitForSingleObject(hMutex, INFINITE);

            assert(InterlockedIncrement(&iWriteEntry) == 1);
            assert(InterlockedExchange(&iReadEntry, iReadEntry) == 0);
        } 
        else 
        {   
            if (InterlockedIncrement(&iReadCount) == 0) 
            { 
                WaitForSingleObject(hMutex, INFINITE);
                SetEvent(hReaderEvent);
            }

            WaitForSingleObject(hReaderEvent,INFINITE);
            InterlockedIncrement(&iReadEntry);
            assert(InterlockedExchange(&iWriteEntry, iWriteEntry) == 0);
        }
    }

    //-----------------------------------------------------------
    void 
    Release(
        RWLOCK_TYPE lockType
        )
    /*++

    ++*/
    {
        if (lockType == WRITER_LOCK) 
        { 
            InterlockedDecrement(&iWriteEntry);
            InterlockedDecrement(&iWriteCount);
            SetEvent(hMutex);
            ReleaseMutex(hWriterMutex);
        } 
        else if(lockType == READER_LOCK) 
        {
            InterlockedDecrement(&iReadEntry);
            if (InterlockedDecrement(&iReadCount) < 0) 
            { 
              ResetEvent(hReaderEvent);
              SetEvent(hMutex);
            }
        }
    }

    long GetReadCount()   
    { 
        return iReadCount+1;  
    }

    long GetWriteCount()  
    { 
        return iWriteCount+1; 
    }
};

//---------------------------------------------------------------------
// 
//
class CCMutex {
public:
    HANDLE  hMutex;

    CCMutex() : hMutex(NULL) { 
        hMutex=CreateMutex(NULL, FALSE, NULL); 
    }

    ~CCMutex() { 
        CloseHandle(hMutex); 
    }  

    DWORD Lock(
            DWORD dwWaitTime=INFINITE, 
            BOOL bAlertable=FALSE
    ) 
    { 
        return WaitForSingleObjectEx(
                        hMutex, 
                        dwWaitTime, 
                        bAlertable);
    }

    BOOL Unlock() {
        return ReleaseMutex(hMutex);
    }
};

//---------------------------------------------------------------------------------

class CCEvent {
    BOOL    bManual;

public:
    HANDLE  hEvent;

    CCEvent(
        BOOL bManual, 
        BOOL bInitState) : 
    hEvent(NULL), 
    bManual(bManual) 
    {
        hEvent=CreateEvent(
                        NULL, 
                        bManual, 
                        bInitState, 
                        NULL);
    }

    ~CCEvent() {
        CloseHandle(hEvent);
    }

    DWORD Lock( DWORD dwWaitTime=INFINITE, 
                BOOL bAlertable=FALSE) 
    {
        return WaitForSingleObjectEx(
                        hEvent, 
                        dwWaitTime, 
                        bAlertable);
    }

    BOOL SetEvent() {
        return ::SetEvent(hEvent);
    }

    BOOL ResetEvent() {
        return ::ResetEvent(hEvent);
    }

    BOOL PulseEvent() {
        return ::PulseEvent(hEvent);
    }

    BOOL IsManual() {
        return bManual;
    }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\tlsstl.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
// stl.h supplemental header
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>
using namespace std;


#endif	/* _STL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\jetblue\jbbase.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include "JetBlue.h"


//----------------------------------------------------------------
BOOL
ConvertMJBstrToMWstr(
    JB_STRING in,
    DWORD length,
    LPTSTR* out
    )
/*

*/
{
#if defined(UNICODE) && !defined(JET_BLUE_SUPPORT_UNICODE)
    if(in == NULL)
    {
        *out = NULL;
        return TRUE;
    }

    int bufSize;

    bufSize = MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            in,
                            length,
                            NULL,
                            0
                        );

    if(bufSize == 0)
    {
        return FALSE;
    }

    *out = (LPTSTR)LocalAlloc(LPTR, bufSize * sizeof(TCHAR));
    if(*out == NULL)
    {
        return FALSE;
    }

    return (MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            in,
                            length,
                            *out, 
                            bufSize
                        ) != 0);
    
#else

    *out = in;
    return TRUE;

#endif
}

//----------------------------------------------------------------
BOOL
ConvertJBstrToWstr(
    JB_STRING   in,
    LPTSTR*     out
    )
/*
*/
{
    return ConvertMJBstrToMWstr(in, -1, out);
}
    
//----------------------------------------------------------------
BOOL
ConvertMWstrToMJBstr(
    LPCTSTR in, 
    DWORD length,
    JB_STRING* out
    )
/* 
*/
{
#if defined(UNICODE) && !defined(JET_BLUE_SUPPORT_UNICODE)

    if(in == NULL)
    {
        *out = NULL;
        return TRUE;
    }

    
    int bufSize;

    bufSize = WideCharToMultiByte(
                            GetACP(),
                            0,
                            in,
                            length,
                            NULL,
                            0,
                            NULL,
                            NULL
                        );

    if(bufSize == 0)
    {
        return FALSE;
    }

    *out = (LPSTR)LocalAlloc(LPTR, bufSize);
    if(*out == NULL)
    {
        return FALSE;
    }

    return (WideCharToMultiByte( GetACP(),
                                 0,
                                 in,
                                 length, 
                                 *out, 
                                 bufSize,
                                 NULL,
                                 NULL) != 0);
#else

    *out = in;
    return TRUE;

#endif
}


//----------------------------------------------------------------
BOOL 
ConvertWstrToJBstr(
    LPCTSTR in, 
    JB_STRING* out
    )
{
    return ConvertMWstrToMJBstr( in, -1, out );
}

//----------------------------------------------------------------
void
FreeJBstr( JB_STRING pstr )
{
#if defined(UNICODE) && !defined(JET_BLUE_SUPPORT_UNICODE)

    if(pstr)
        LocalFree(pstr);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\trust.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSTRUST_H__
#define __TLSTRUST_H__


#define RANDOM_CHALLENGE_DATASIZE   32  // 128 bits data.
#define RUN_MD5_HASH_TIMES          5   // time to hash data.

#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI
TLSEstablishTrustWithServer(
    IN TLS_HANDLE hHandle,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSGenerateRandomChallengeData(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE* ppbChallengeData,
    IN PDWORD pcbChallengeData
);

DWORD WINAPI
TLSVerifyChallengeResponse(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallengeData,
    IN PTLSCHALLENGERESPONSEDATA pServerChallengeResponseData
);

DWORD
TLSGenerateChallengeResponseData(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pChallengeData,
    OUT PBYTE* pbResponseData,
    OUT PDWORD cbResponseData
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\include\tlsapip.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSAPIP_H__
#define __TLSAPIP_H__

#include <wincrypt.h>
#include "tlsapi.h"
#include "tlsrpc.h"

#define TLSCERT_TYPE_EXCHANGE    1
#define TLSCERT_TYPE_SIGNATURE   2

#define ENTERPRISE_SERVER_MULTI   L"EnterpriseServerMulti"

#define TLS_RTM_VERSION_BIT 0x20000000
#define IS_LSSERVER_RTM(x) ((x & TLS_RTM_VERSION_BIT) > 0)

#define TLS_VERSION_ENTERPRISE_BIT  0x80000000
#define CURRENT_TLSERVER_VERSION(version)  HIBYTE(LOWORD(version))

#define GET_LSSERVER_MAJOR_VERSION(version)   HIBYTE(LOWORD(version))
#define GET_LSSERVER_MINOR_VERSION(version)   LOBYTE(LOWORD(version))
#define IS_ENFORCE_LSSERVER(version) \
    ((version & 0x40000000) > 0)

//#define PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY (30)  /* 30 seconds */
#define PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY (60*60*24*7)  /* 7 days */

//
// TLSInstallCertificate() certificate type.
//
#define CERTIFICATE_CA_TYPE     1
#define CERTITICATE_MF_TYPE     2
#define CERTIFICATE_CH_TYPE     3
#define CERTIFICATE_SPK_TYPE    4

#define CERTIFICATE_LEVEL_ROOT  0

typedef struct _LSHydraCertRequest {
    DWORD                   dwHydraVersion;
    PBYTE                   pbEncryptedHwid;
    DWORD                   cbEncryptedHwid;
    LPTSTR                  szSubjectRdn;
    PCERT_PUBLIC_KEY_INFO   SubjectPublicKeyInfo;
    DWORD                   dwNumCertExtension;
    PCERT_EXTENSION         pCertExtensions;
} LSHydraCertRequest, *LPLSHydraCertRequest, *PLSHydraCertRequest;


#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI
RequestToTlsRequest( 
    const LICENSEREQUEST* lpRequest, 
    TLSLICENSEREQUEST* lpRpcRequest 
);

DWORD WINAPI
TlsRequestToRequest(
    TLSLICENSEREQUEST* lpRpcRequest ,
    LICENSEREQUEST* lpRequest
);

DWORD WINAPI 
TLSReplicateKeyPack(
    TLS_HANDLE hHandle,
    DWORD cbLsIdentification,
    PBYTE pbLsIdentification,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
);

DWORD WINAPI 
TLSAuditLicenseKeyPack(
    TLS_HANDLE hHandle,
    DWORD dwKeyPackId,
    FILETIME ftStartTime,
    FILETIME ftEndTime,
    BOOL bResetCounter,
    LPTLSKeyPackAudit lplsAudit,
    PDWORD dwErrCode
);

DWORD WINAPI
TLSRetrieveTermServCert( 
    TLS_HANDLE hHandle,
    DWORD cbResponseData,
    PBYTE pbResponseData,
    PDWORD cbCert,
    PBYTE* pbCert,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSRequestTermServCert( 
    TLS_HANDLE hHandle,
    LPLSHydraCertRequest pRequest,
    PDWORD cbChallengeData,
    PBYTE* pbChallengeData,
    PDWORD pdwErrCode
);

DWORD WINAPI 
TLSInstallCertificate( 
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     DWORD dwCertLevel,
     DWORD cbSingnatureCert,
     PBYTE pbSingnatureCert,
     DWORD cbExchangeCert,
     PBYTE pbExchangeCert,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerCertificate( 
     TLS_HANDLE hHandle,
     BOOL bSignCert,
     PBYTE *ppCertBlob,
     PDWORD pdwCertBlobLen,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSRegisterLicenseKeyPack( 
     TLS_HANDLE hHandle,
     LPBYTE pbCHCertBlob,
     DWORD cbCHCertBlobSize,
     LPBYTE pbRootCertBlob,
     DWORD cbRootCertBlob,
     LPBYTE lpKeyPackBlob,
     DWORD dwKeyPackBlobLen,
     PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetLSPKCS10CertRequest(
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     PDWORD pcbdata,
     PBYTE* ppbData,
     PDWORD pdwErrCode
);


DWORD WINAPI 
TLSKeyPackAdd( 
     TLS_HANDLE hHandle,
     LPLSKeyPack lpKeypack,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackSetStatus( 
     TLS_HANDLE hHandle,
     DWORD dwSetParm,
     LPLSKeyPack lpKeyPack,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseSetStatus( 
     TLS_HANDLE hHandle,
     DWORD dwSetParam,
     LPLSLicense lpLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSReturnKeyPack( 
     TLS_HANDLE hHandle,
     DWORD dwKeyPackId,
     DWORD dwReturnReason,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSReturnLicense( 
    TLS_HANDLE hHandle,
    DWORD dwKeyPackId,
    DWORD dwLicenseId,
    DWORD dwReturnReason,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSAnnounceServer(
    TLS_HANDLE hHandle,
    DWORD dwType,
    FILETIME* ftTime,
    LPTSTR pszSetupId,
    LPTSTR pszDomainName,
    LPTSTR pszMachineName,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSLookupServer(
    TLS_HANDLE hHandle,
    LPTSTR pszLookupSetupId,
    LPTSTR pszLsSetupId,
    PDWORD pcbSetupId,
    LPTSTR pszDomainName,
    PDWORD pcbDomainName,
    LPTSTR pszLsName,
    PDWORD pcbMachineName,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSAnnounceLicensePack(
    TLS_HANDLE hHandle,
    PTLSReplRecord pReplRecord,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSReturnLicensedProduct( 
    PCONTEXT_HANDLE phContext,
    PTLSLicenseToBeReturn pClientLicense,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSTriggerReGenKey(
    IN TLS_HANDLE hHandle,
    IN BOOL bReserved,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSSetTlsPrivateData(
    IN TLS_HANDLE hHandle,
    IN DWORD dwPrivateDataType,
    IN PTLSPrivateDataUnion pPrivateData,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetTlsPrivateData(
    IN TLS_HANDLE hHandle,
    IN DWORD dwGetDataType,
    IN PTLSPrivateDataUnion pGetParm,
    OUT PDWORD pdwRetDataType,
    OUT PTLSPrivateDataUnion* ppRetData,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSResponseServerChallenge(
    IN TLS_HANDLE hHandle,
    IN PTLSCHALLENGERESPONSEDATA pClientResponse,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSChallengeServer(
    IN TLS_HANDLE hHandle,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallenge,
    OUT PTLSCHALLENGERESPONSEDATA* ppServerResponse,
    OUT PTLSCHALLENGEDATA* ppServerChallenge,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSTelephoneRegisterLKP(
    TLS_HANDLE hHandle,
    DWORD cbData,
    PBYTE pbData,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetServerUniqueId(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbByte,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetServerPID(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbByte,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetServerSPK(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbByte,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSDepositeServerSPK(
    TLS_HANDLE hHandle,
    DWORD cbSPK,
    PBYTE pbSPK,
    PCERT_EXTENSIONS pCertExtensions,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSAllocateInternetLicense(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PDWORD pcbLicense,
    OUT PBYTE* ppbLicense,
    IN OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSReturnInternetLicense(
    IN TLS_HANDLE hHandle,
    IN const DWORD cbLicense,
    IN const PBYTE pbLicense,
    OUT PDWORD pdwErrCode
);


DWORD WINAPI
TLSAllocateInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PTLSInternetLicense pInternetLicense,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSReturnInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const LICENSEREQUEST* pRequest,
    IN const ULARGE_INTEGER* pulSerialNumber,
    IN const DWORD dwQuantity,
    OUT PDWORD pdwErrCode
);

BOOL
TLSIsBetaNTServer();

BOOL
TLSIsLicenseEnforceEnable();

BOOL
TLSRefreshLicenseServerCache(
    DWORD dwTimeOut
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\legacy\client\hydrals-c.c ===
#include <hydrals_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\jetblue\jetblue.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include "JetBlue.h"
#include "locks.h"


#ifdef USE_SINGLE_JET_CALL
CCriticalSection g_JetCallLock;
#define SINGLE_JET_CALL  CCriticalSectionLocker lock(g_JetCallLock)
#else
#define SINGLE_JET_CALL
#endif


DWORD
DeleteFilesInDirectory(
    IN LPTSTR szDir,
    IN LPTSTR szFilesToBeDelete,
    IN BOOL bIncludeSubdir
    )
/*++


--*/
{
    TCHAR  szFile[MAX_PATH+1];
    HANDLE hFile;
    WIN32_FIND_DATA findData;
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    if (lstrlen(szDir) + lstrlen(szFilesToBeDelete) + 2 > sizeof(szFile) / sizeof(TCHAR))
    {
        return ERROR_INVALID_DATA;
    }

    wsprintf(
            szFile,
            _TEXT("%s\\%s"),
            szDir,
            szFilesToBeDelete
        );

    hFile = FindFirstFile(
                        szFile,
                        &findData
                    );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    // _tprintf(_TEXT("Deleting %s\n"), szDir);

    while(bSuccess == TRUE)
    {
        if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && bIncludeSubdir == TRUE)
        {
            if( lstrcmp(findData.cFileName, _TEXT(".")) != 0 &&
                lstrcmp(findData.cFileName, _TEXT("..")) != 0 )
            {

                if (lstrlen(szDir) + lstrlen(findData.cFileName) + 2 <= sizeof(szFile) / sizeof(TCHAR))
                {
                    wsprintf(szFile, _TEXT("%s\\%s"), szDir, findData.cFileName);
                    bSuccess = DeleteFilesInDirectory(
                                        szFile,
                                        szFilesToBeDelete,
                                        bIncludeSubdir
                                        );
                }
            }
        }
        else
        {
            if (lstrlen(szDir) + lstrlen(findData.cFileName) + 2 <= sizeof(szFile) / sizeof(TCHAR))
            {
                wsprintf(
                    szFile,
                    _TEXT("%s\\%s"),
                    szDir,
                    findData.cFileName
                    );

                bSuccess = DeleteFile(szFile);
            }
        }

        if(bSuccess == TRUE)
        {
            // return FALSE with error code set to ERROR_NO_MORE_FILES
            bSuccess = FindNextFile(hFile, &findData);
        }
    }

    dwStatus = GetLastError();

    FindClose(hFile);

    return (dwStatus == ERROR_NO_MORE_FILES) ? ERROR_SUCCESS : dwStatus;
}



//----------------------------------------------------------------
JET_ERR
ConvertTLSJbColumnDefToJbColumnCreate(
    IN const PTLSJBColumn pTlsJbColumn,
    IN OUT JET_COLUMNCREATE* pJetColumnCreate
    )
/*
*/
{
    pJetColumnCreate->cbStruct = sizeof(JET_COLUMNCREATE);
    if(ConvertWstrToJBstr(pTlsJbColumn->pszColumnName, &pJetColumnCreate->szColumnName) == FALSE)
    {
        return JET_errInvalidParameter;
    }

    pJetColumnCreate->coltyp = pTlsJbColumn->colType;
    pJetColumnCreate->cbMax = pTlsJbColumn->cbMaxLength;
    pJetColumnCreate->grbit = pTlsJbColumn->jbGrbit;
    pJetColumnCreate->pvDefault = pTlsJbColumn->pbDefValue;
    pJetColumnCreate->cbDefault = pTlsJbColumn->cbDefValue;
    pJetColumnCreate->cp = pTlsJbColumn->colCodePage;

    return JET_errSuccess;
}

//----------------------------------------------------------------
JET_ERR
ConvertTlsJBTableIndexDefToJbIndexCreate(
    IN const PTLSJBIndex pTlsJbTableIndex,
    IN OUT JET_INDEXCREATE* pJetIndexCreate
    )
/*
*/
{
    JET_ERR jetError = JET_errSuccess;
    DWORD count=0;

    pJetIndexCreate->cbStruct = sizeof(JET_INDEXCREATE);
    if(ConvertWstrToJBstr(pTlsJbTableIndex->pszIndexName, &pJetIndexCreate->szIndexName) == FALSE)
    {
        jetError = JET_errInvalidParameter;
        goto cleanup;
    }

    if(pTlsJbTableIndex->pszIndexKey && pTlsJbTableIndex->cbKey == 0)
    {
        count++;

        // need double NULL terminate
        while(pTlsJbTableIndex->pszIndexKey[count] != _TEXT('\0') ||
              pTlsJbTableIndex->pszIndexKey[count-1] != _TEXT('\0'))
        {
            //
            // this max. is pseudo impose.
            //
            if(count >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
            {
                jetError = JET_errInvalidParameter;
                goto cleanup;
            }

            count++;
        }

        // pTlsJbTableIndex->cbKey = count;
    }
    else
    {
        count = pTlsJbTableIndex->cbKey;
    }

    if(ConvertMWstrToMJBstr(pTlsJbTableIndex->pszIndexKey, count, &pJetIndexCreate->szKey) == FALSE)
    {
        jetError = JET_errInvalidParameter;
        goto cleanup;
    }

    pJetIndexCreate->cbKey = pTlsJbTableIndex->cbKey;
    pJetIndexCreate->grbit = pTlsJbTableIndex->jbGrbit;
    pJetIndexCreate->ulDensity = pTlsJbTableIndex->ulDensity;


cleanup:
    return jetError;
}



//////////////////////////////////////////////////////////////////////
//
// JBInstance implementaion
//
//////////////////////////////////////////////////////////////////////
JBInstance::JBInstance() :
    JBError(),
    m_JetInstance(0),
    m_bInit(FALSE),
    m_NumSession(0)
{
}

//--------------------------------------------------------------------

JBInstance::~JBInstance()
{
    if(m_bInit == FALSE)
    {
        return;
    }

    //JB_ASSERT(m_NumSession == 0);
    //if(m_NumSession != 0)
    //{
    //    throw JBError(JET_errTooManyActiveUsers);
    //}

    JBTerminate();
}

//--------------------------------------------------------------------

BOOL
JBInstance::JBInitJetInstance()
{
    char szLogFilePath[MAX_PATH+1];
    LPTSTR pszLogPath=NULL;
    BOOL bSuccess;


    if(m_bInit == TRUE)
    {
        SetLastJetError(JET_errAlreadyInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetInit(&m_JetInstance);

    if(m_JetErr == JET_errMissingLogFile)
    {
        //
        // Delete log file and retry operation again
        //
        bSuccess = GetSystemParameter(
                                    0,
                                    JET_paramLogFilePath,
                                    NULL,
                                    (PBYTE)szLogFilePath,
                                    sizeof(szLogFilePath)
                                );

        if(bSuccess == TRUE && ConvertJBstrToWstr(szLogFilePath, &pszLogPath))
        {
            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_RESLOG,
                            FALSE
                        );

            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_EDBLOG,
                            FALSE
                        );

            m_JetErr = JetInit(&m_JetInstance);
        }
    }

    m_bInit = IsSuccess();
    return m_bInit;
}

//--------------------------------------------------------------------

BOOL
JBInstance::JBTerminate(
    IN JET_GRBIT grbit,
    IN BOOL bDeleteLogFile
    )
{
    char szLogFilePath[MAX_PATH+1];
    LPTSTR pszLogPath=NULL;
    BOOL bSuccess;

    if(m_bInit == FALSE)
        return TRUE;

    //
    // LSTESTER bug - one thread was still in enumeration while
    //  the other thread shutdown server
    //

    //if(m_NumSession > 0)
    //{
    //    JB_ASSERT(m_NumSession == 0);
    //    SetLastJetError(JET_errTooManyActiveUsers);
    //    return FALSE;
    //}

    SINGLE_JET_CALL;

    m_JetErr = JetTerm2(m_JetInstance, grbit);
    // JB_ASSERT(m_JetErr == JET_errSuccess);

    if(m_JetErr == JET_errSuccess && bDeleteLogFile == TRUE)
    {
        //
        // Delete log file.
        //
        bSuccess = GetSystemParameter(
                                    0,
                                    JET_paramLogFilePath,
                                    NULL,
                                    (PBYTE)szLogFilePath,
                                    sizeof(szLogFilePath)
                                );

        if(bSuccess == TRUE && ConvertJBstrToWstr(szLogFilePath, &pszLogPath))
        {
            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_RESLOG,
                            FALSE
                        );

            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_EDBLOG,
                            FALSE
                        );
        }
    }

    m_bInit = FALSE;

    // need to add operator= to this class.
    // m_NumSession = 0;   // force terminate.

    if(pszLogPath != NULL)
    {
        LocalFree(pszLogPath);
    }

    return (m_JetErr == JET_errSuccess);
}

//--------------------------------------------------------------------

BOOL
JBInstance::SetSystemParameter(
    IN JET_SESID SesId,
    IN unsigned long lParamId,
    IN ULONG_PTR lParam,
    IN PBYTE sz
    )
{
    LPSTR lpszParm=NULL;

    if(lParamId == JET_paramSystemPath ||
       lParamId == JET_paramTempPath ||
       lParamId == JET_paramLogFilePath )
    {
        if(ConvertWstrToJBstr((LPTSTR)sz, &lpszParm) == FALSE)
        {
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }
    }
    else
    {
        lpszParm = (LPSTR)sz;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetSetSystemParameter(
                    &m_JetInstance,
                    SesId,
                    lParamId,
                    lParam,
                    (const char *)lpszParm
                );

    if(lParamId == JET_paramSystemPath || lParamId == JET_paramTempPath ||
       lParamId == JET_paramLogFilePath )
    {
        FreeJBstr(lpszParm);
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBInstance::GetSystemParameter(
    IN JET_SESID SesId,
    IN unsigned long lParamId,
    IN ULONG_PTR* plParam,
    IN PBYTE sz,
    IN unsigned long cbMax
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetGetSystemParameter(
                    m_JetInstance,
                    SesId,
                    lParamId,
                    plParam,
                    (char *)sz,
                    cbMax
                );

    return IsSuccess();
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_SESID
JBInstance::BeginJetSession(
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszPwd
    )
{
    JET_SESID sesId = JET_sesidNil;
    LPSTR lpszUserName=NULL;
    LPSTR lpszPwd=NULL;

    if(m_bInit == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return JET_sesidNil;
    }

    if(ConvertWstrToJBstr(pszUserName, &lpszUserName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszPwd, &lpszPwd) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetBeginSession(
                            m_JetInstance,
                            &sesId,
                            lpszUserName,
                            lpszPwd
                        );
    }

    if(IsSuccess() == TRUE)
    {
        m_NumSession++;
    }

cleanup:

    FreeJBstr(lpszUserName);
    FreeJBstr(lpszPwd);

    return IsSuccess() ? sesId : JET_sesidNil;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBInstance::EndJetSession(
    IN JET_SESID JetSessionID,
    IN JET_GRBIT grbit
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetEndSession(JetSessionID, grbit);

    if(IsSuccess() == TRUE)
    {
        m_NumSession--;
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBInstance::EndSession(
    IN JET_SESID sesId,
    IN JET_GRBIT grbit
    )
{
    return EndJetSession( sesId, grbit );
}


//----------------------------------------------------------------------------
// Implementation for JBSession
//----------------------------------------------------------------------------

JBSession::JBSession(
    IN JBInstance& JetInstance,
    IN JET_SESID JetSessID
    ) :
    JBError(),
    m_JetInstance(JetInstance),
    m_JetSessionID(JetSessID),
    m_TransactionLevel(0),
    m_JetDBInitialized(0)
/*

*/
{
}

//-----------------------------------------------------------

JBSession::JBSession(
    IN JBSession& JetSession
    ) :
    JBError(),
    m_JetInstance(JetSession.GetJetInstance()),
    m_JetSessionID(JET_sesidNil),
    m_TransactionLevel(0),
    m_JetDBInitialized(0)
{
    if(DuplicateSession(JetSession.GetJetSessionID()) == FALSE)
    {
        JB_ASSERT(FALSE);
        throw JBError(GetLastJetError());
    }
}

//-----------------------------------------------------------

JBSession::~JBSession()
/*

*/
{
    if(IsValid() == TRUE && EndSession() == FALSE)
    {
        // do nothing, license server uses only global instance
        // JB_ASSERT(FALSE);
        // throw JBError(GetLastJetError());
    }
}

//----------------------------------------------------------

CLASS_PRIVATE BOOL
JBSession::DuplicateSession(
    IN JET_SESID sessID
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetDupSession(sessID, &m_JetSessionID);
    return IsSuccess();
}


//----------------------------------------------------------

CLASS_PRIVATE JET_DBID
JBSession::OpenJetDatabase(
    IN LPCTSTR pszFile,
    IN LPCTSTR pszConnect,
    IN JET_GRBIT grbit
    )
{
    JET_DBID jdbId = JET_dbidNil;
    LPSTR lpszFile=NULL;
    LPSTR lpszConnect=NULL;

    if(ConvertWstrToJBstr(pszFile, &lpszFile) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszConnect, &lpszConnect) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(AttachDatabase(pszFile, grbit) == FALSE)
        goto cleanup;

    {
        SINGLE_JET_CALL;

        m_JetErr = JetOpenDatabase(
                            m_JetSessionID,
                            lpszFile,
                            lpszConnect,
                            &jdbId,
                            grbit
                        );
    }

    if(IsSuccess() == TRUE)
    {
        m_JetDBInitialized++;
    }

cleanup:
    FreeJBstr(lpszFile);
    FreeJBstr(lpszConnect);

    return IsSuccess() ? jdbId : JET_dbidNil;
}

//----------------------------------------------------------

CLASS_PRIVATE BOOL
JBSession::CloseJetDatabase(
    IN JET_DBID jdbId,
    IN JET_GRBIT grbit
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetCloseDatabase(
                        m_JetSessionID,
                        jdbId,
                        grbit
                    );

    if(IsSuccess() == TRUE)
    {
        m_JetDBInitialized--;
    }

    return (IsSuccess());
}

//----------------------------------------------------------

CLASS_PRIVATE JET_DBID
JBSession::CreateJetDatabase(
    IN LPCTSTR pszFile,
    IN LPCTSTR pszConnect,
    IN JET_GRBIT grbit
    )
{
    JET_DBID jdbId = JET_dbidNil;

    LPSTR lpszFile=NULL;
    LPSTR lpszConnect=NULL;

    if(ConvertWstrToJBstr(pszFile, &lpszFile) == FALSE)
    {
        SetLastError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszConnect, &lpszConnect) == FALSE)
    {
        SetLastError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetCreateDatabase(
                            m_JetSessionID,
                            lpszFile,
                            lpszConnect,
                            &jdbId,
                            grbit
                        );
    }


    if(IsSuccess() == TRUE)
    {
        m_JetDBInitialized++;
    }

cleanup:
    FreeJBstr(lpszFile);
    FreeJBstr(lpszConnect);

    return IsSuccess() ? jdbId : JET_dbidNil;
}

//----------------------------------------------------------

BOOL
JBSession::BeginSession(
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszPwd
    )
/*

*/
{
    BOOL bSuccess;

    if(m_JetInstance.IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    if(m_JetSessionID != JET_sesidNil)
    {
        SetLastJetError(JET_errAlreadyInitialized);
        return FALSE;
    }

    m_JetSessionID = m_JetInstance.BeginJetSession(
                            pszUserName,
                            pszPwd
                        );

    if(m_JetSessionID == JET_sesidNil)
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//----------------------------------------------------------

BOOL
JBSession::EndSession(
    IN JET_GRBIT grbit /* JET_bitTermComplete  */
    )
/*

*/
{
    BOOL bSuccess;

    if(GetTransactionLevel() != 0)
    {
        //
        // Terminate existing transaction
        //
        bSuccess = EndAllTransaction(FALSE);
        if(bSuccess == FALSE)
        {
            JB_ASSERT(FALSE);
            SetLastJetError(JET_errTransTooDeep);
            return FALSE;
        }
    }

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    if(m_JetDBInitialized > 0)
    {
        JB_ASSERT(m_JetDBInitialized);
        SetLastJetError(JET_errTooManyActiveUsers);
        return FALSE;
    }

    //
    // Huei - routine to be phrased out ?
    //
    bSuccess=m_JetInstance.EndSession(
                            m_JetSessionID,
                            grbit
                        );

    if(bSuccess == TRUE)
    {
        m_JetSessionID = JET_sesidNil;
    }
    else
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//------------------------------------------------------------

BOOL
JBSession::SetSystemParameter(
    IN unsigned long lParamId,
    IN ULONG_PTR lParam,
    IN const PBYTE sz
    )
{
    BOOL bSuccess;

    bSuccess = m_JetInstance.SetSystemParameter(
                            m_JetSessionID,
                            lParamId,
                            lParam,
                            sz
                        );

    if(bSuccess == FALSE)
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::GetSystemParameter(
    IN unsigned long lParamId,
    IN ULONG_PTR* plParam,
    IN PBYTE sz,
    IN unsigned long cbMax
    )
{
    BOOL bSuccess;

    bSuccess = m_JetInstance.GetSystemParameter(
                            m_JetSessionID,
                            lParamId,
                            plParam,
                            sz,
                            cbMax
                        );

    if(bSuccess == FALSE)
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//--------------------------------------------------------------------
BOOL
JBSession::AttachDatabase(
    IN LPCTSTR pszFileName,
    IN JET_GRBIT grbit
    )
{
    LPSTR lpszFileName=NULL;

    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszFileName, &lpszFileName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetAttachDatabase(
                            m_JetSessionID,
                            lpszFileName,
                            grbit
                        );
    }

cleanup:

    FreeJBstr(lpszFileName);
    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::DetachDatabase(
    IN LPCTSTR pszFileName
    )
{
    LPSTR lpszFileName = NULL;

    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszFileName, &lpszFileName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetDetachDatabase(
                            m_JetSessionID,
                            lpszFileName
                        );
    }

cleanup:

    FreeJBstr(lpszFileName);
    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::BeginTransaction()
{
    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetBeginTransaction(
                        m_JetSessionID
                    );

    if(IsSuccess() == TRUE)
    {
        m_TransactionLevel++;
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::CommitTransaction(
    IN JET_GRBIT grbit
    )
{
    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetCommitTransaction(
                        m_JetSessionID,
                        grbit
                    );

    if(IsSuccess() == TRUE)
    {
        m_TransactionLevel --;
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::RollbackTransaction(
    IN JET_GRBIT grbit
    )
{
    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetRollback(
                        m_JetSessionID,
                        grbit
                    );
    if(IsSuccess() == TRUE)
        m_TransactionLevel--;

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::EndAllTransaction(
    IN BOOL bCommit,
    IN JET_GRBIT grbit
    )
{
    BOOL bEnd = TRUE;

    while(m_TransactionLevel > 0 && bEnd == TRUE)
    {
        bEnd = (bCommit == TRUE) ?
                    CommitTransaction(grbit) : RollbackTransaction(grbit);
    }

    return bEnd;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBSession::CloseDatabase(
    JET_DBID jdbId,
    JET_GRBIT grbit
    )
{
    return CloseJetDatabase(jdbId, grbit);
}



//////////////////////////////////////////////////////////////////////
//
// JBDatabase
//
//////////////////////////////////////////////////////////////////////

JBDatabase::JBDatabase(
    IN JBSession& jbSession,
    IN JET_DBID jdbId,              /* JET_dbidNil */
    IN LPCTSTR pszDatabase          // NULL
    ) :
    JBError(),
    m_JetSession(jbSession),
    m_JetDbId(jdbId),
    m_TableOpened(0)
/*

*/
{
    if(pszDatabase)
    {
        _tcscpy(m_szDatabaseFile, pszDatabase);
    }
    else
    {
        memset(m_szDatabaseFile, 0, sizeof(m_szDatabaseFile));
    }
}

//--------------------------------------------------------------------

JBDatabase::~JBDatabase()
{
    if(CloseDatabase() == FALSE)
    {
        // do nothing, license server uses only global instance.
        // JB_ASSERT(FALSE);
        // throw JBError(GetLastJetError());
    }
}

//--------------------------------------------------------------------

BOOL
JBDatabase::CloseDatabase(
    IN JET_GRBIT grbit
    )
{
    BOOL bSuccess;

    //
    // Verify we have properly initialized
    //
    if(IsValid() == FALSE)
        return TRUE;

    //
    // No table is still opened from the DB ID
    //
    if(m_TableOpened > 0)
    {
        JB_ASSERT(FALSE);
        SetLastJetError(JET_errTooManyActiveUsers);
        return FALSE;
    }

    //
    // Close the database
    //
    bSuccess = m_JetSession.CloseJetDatabase(
                            m_JetDbId,
                            grbit
                        );

    if(bSuccess == FALSE || m_JetSession.DetachDatabase(m_szDatabaseFile) == FALSE)
    {
        m_JetErr = m_JetSession.GetLastJetError();
    }
    else
    {
        m_JetDbId = JET_dbidNil;
        memset(m_szDatabaseFile, 0, sizeof(m_szDatabaseFile));
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::OpenJetTable(
    IN LPCTSTR pszTableName,
    IN void* pvParam,  // NULL
    IN unsigned long cbParam, // 0
    JET_GRBIT grbit // JET_bitTableUpdatable
    )
/*

*/
{
    LPSTR lpszTableName = NULL;

    JET_TABLEID tableid = JET_tableidNil;
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr=JetOpenTable(
                    m_JetSession.GetJetSessionID(),
                    m_JetDbId,
                    lpszTableName,
                    pvParam,
                    cbParam,
                    grbit,
                    &tableid
                );
    }

    if(IsSuccess() == TRUE)
    {
        m_TableOpened++;
    }

cleanup:

    FreeJBstr(lpszTableName);
    return tableid;
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::DuplicateJetCursor(
    // IN JET_SESID sesId,
    IN JET_TABLEID srcTableid,
    IN JET_GRBIT grbit
    )
/*

*/
{
    JET_TABLEID tableid = JET_tableidNil;

    SINGLE_JET_CALL;
    m_JetErr = JetDupCursor(
                        GetJetSessionID(),
                        srcTableid,
                        &tableid,
                        0  // grbit must be zero
                    );

    if(IsSuccess() == TRUE)
    {
        m_TableOpened++;
    }

    return (IsSuccess() == TRUE) ? tableid : JET_tableidNil;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBDatabase::CloseJetTable(
    // IN JET_SESID sesId,
    IN JET_TABLEID tableid
    )
/*
*/
{
    // JetBlue AC with empty table
    SINGLE_JET_CALL;

    try {
        m_JetErr = JetCloseTable(
                            GetJetSessionID(),
                            tableid
                        );
    }
    catch(...) {
        m_JetErr = JET_errSuccess;
    }

    if(IsSuccess())
    {
        m_TableOpened--;
    }

    return IsSuccess();
}


//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::CreateJetTable(
    LPCTSTR pszTableName,
    unsigned long lPage, // 0
    unsigned long lDensity // 20
    )
/*
*/
{
    JET_TABLEID tableid = JET_tableidNil;
    JB_STRING lpszTableName=NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetCreateTable(
                        GetJetSessionID(),
                        m_JetDbId,
                        lpszTableName,
                        lPage,
                        lDensity,
                        &tableid
                    );
    }

    if(IsSuccess() == FALSE)
    {
        goto cleanup;
    }

    m_TableOpened++;

cleanup:

    FreeJBstr(lpszTableName);
    return tableid;
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::CreateJetTableEx(
        LPCTSTR pszTableName,
        const PTLSJBTable table_attribute,
        const PTLSJBColumn columns,
        const DWORD num_columns,
        const PTLSJBIndex table_index,
        const DWORD num_table_index
    )
/*

*/
{
    JET_TABLEID tableid = JET_tableidNil;
    JB_STRING lpszTableName=NULL;
    JET_TABLECREATE table_create;
    JET_COLUMNCREATE* column_create=NULL;
    JET_INDEXCREATE* index_create=NULL;
    DWORD index=0;

    SINGLE_JET_CALL;

    table_create.szTableName = NULL;
    table_create.szTemplateTableName = NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }


    table_create.cbStruct = sizeof(JET_TABLECREATE);
    table_create.szTableName = lpszTableName;

    if(ConvertWstrToJBstr(table_attribute->pszTemplateTableName, &table_create.szTemplateTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    table_create.ulPages = table_attribute->ulPages;
    table_create.ulDensity = (table_attribute->ulDensity < 20 || table_attribute->ulDensity > 100) ?
                                        TLS_JETBLUE_DEFAULT_TABLE_DENSITY : table_attribute->ulDensity;

    table_create.grbit = table_attribute->jbGrbit;

    //
    // form a JET_TABLECREATE structure
    //
    column_create = (JET_COLUMNCREATE *)AllocateMemory(
                                            sizeof(JET_COLUMNCREATE) * num_columns
                                        );

    if(column_create == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    index_create = (JET_INDEXCREATE *)AllocateMemory(
                                            sizeof(JET_INDEXCREATE) * num_table_index
                                        );

    if(index_create == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    for(index=0; index < num_columns; index++)
    {
        if(ConvertTLSJbColumnDefToJbColumnCreate( columns+index, column_create+index ) == FALSE)
        {
            goto cleanup;
        }
    }

    for(index=0; index < num_table_index; index++)
    {
        if(ConvertTlsJBTableIndexDefToJbIndexCreate( table_index+index, index_create+index ) == FALSE)
            goto cleanup;
    }

    table_create.rgcolumncreate = column_create;
    table_create.cColumns = num_columns;
    table_create.rgindexcreate = index_create;
    table_create.cIndexes = num_table_index;

    m_JetErr = JetCreateTableColumnIndex(
                                GetJetSessionID(),
                                GetJetDatabaseID(),
                                &table_create
                            );
    if(IsSuccess() == TRUE)
    {
        tableid = table_create.tableid;
    }

cleanup:
    if(column_create != NULL)
    {
        for(index=0; index < num_columns; index++)
        {
            if(column_create[index].szColumnName != NULL)
            {
                FreeJBstr(column_create[index].szColumnName);
            }
        }

        FreeMemory(column_create);
    }

    if(index_create != NULL)
    {
        for(index=0; index < num_table_index; index++)
        {
            if(index_create[index].szIndexName != NULL)
            {
                FreeJBstr(index_create[index].szIndexName);
            }

            if(index_create[index].szKey != NULL)
            {
                FreeJBstr(index_create[index].szKey);
            }
        }

        FreeMemory(index_create);
    }

    if(table_create.szTemplateTableName)
        FreeJBstr(table_create.szTemplateTableName);

    if(table_create.szTableName)
        FreeJBstr(table_create.szTableName);

    return tableid;
}

//--------------------------------------------------------------------

JET_TABLEID
JBDatabase::CreateTable(
    LPCTSTR pszTableName,
    unsigned long lPage, // 0
    unsigned long lDensity // 20
    )
/*
*/
{
    JET_TABLEID tableid;

    tableid = CreateJetTable(
                        pszTableName,
                        lPage,
                        lDensity
                    );

    if(tableid == JET_tableidNil)
    {
        m_JetErr = GetLastJetError();
    }

    return tableid;
}

//-------------------------------------------------------------------

JET_TABLEID
JBDatabase::CreateTableEx(
    LPCTSTR pszTableName,
    const PTLSJBTable table_attribute,
    const PTLSJBColumn columns,
    DWORD num_columns,
    const PTLSJBIndex index,
    DWORD num_index
    )
/*
*/
{
    JET_TABLEID tableid;

    tableid = CreateJetTableEx(
                        pszTableName,
                        table_attribute,
                        columns,
                        num_columns,
                        index,
                        num_index
                    );

    if(tableid == JET_tableidNil)
    {
        m_JetErr = GetLastJetError();
    }

    return tableid;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBDatabase::CloseTable(
    JET_TABLEID tableid
    )
/*
    ? Verify this table ID is from this DB/Session
*/
{
    return CloseJetTable( tableid );
}

//--------------------------------------------------------------------

BOOL
JBDatabase::DeleteTable(
    IN LPCTSTR pszTableName
    )
/*
    TODO - ? verify this table is in this database
*/
{
    JB_STRING lpszTableName=NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetDeleteTable(
                        GetJetSessionID(),
                        GetJetDatabaseID(),
                        lpszTableName
                    );
    }

    //if(IsSuccess() == FALSE)
    //    goto cleanup;

cleanup:

    FreeJBstr(lpszTableName);
    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBDatabase::OpenDatabase(
    LPCTSTR szFile,
    LPCTSTR szConnect,      // NULL
    JET_GRBIT grbit         // 0
    )
/*
*/
{
    m_JetDbId = m_JetSession.OpenJetDatabase(
                                szFile,
                                szConnect,
                                grbit
                            );

    if(m_JetDbId == JET_dbidNil)
    {
        m_JetErr = m_JetSession.GetLastJetError();
    }
    else
    {
        _tcscpy(m_szDatabaseFile, szFile);
    }

    return m_JetDbId != JET_dbidNil;
}

//--------------------------------------------------------------------

BOOL
JBDatabase::CreateDatabase(
    LPCTSTR szFile,
    LPCTSTR szConnect,      // NULL
    JET_GRBIT grbit         // 0
    )
/*
*/
{
    m_JetDbId = m_JetSession.CreateJetDatabase(
                                szFile,
                                szConnect,
                                grbit
                            );

    if(m_JetDbId == JET_dbidNil)
    {
        m_JetErr = m_JetSession.GetLastJetError();
    }
    else
    {
        _tcscpy(m_szDatabaseFile, szFile);
    }

    return m_JetDbId != JET_dbidNil;
}


//////////////////////////////////////////////////////////////////////
//
// JBTable
//
//////////////////////////////////////////////////////////////////////
JBColumn JBTable::m_ErrColumn;


JBTable::JBTable(
    JBDatabase& JetDatabase,
    LPCTSTR pszTableName,
    JET_TABLEID tableid
) :
JBError(),
m_JetDatabase(JetDatabase),
m_JetTableId(tableid),
m_JetColumns(NULL),
m_NumJetColumns(0),
m_InEnumeration(FALSE),
m_InsertRepositionBookmark(FALSE)
/*

*/
{
    if(pszTableName)
    {
        _tcscpy(m_szTableName, pszTableName);
    }
    else
    {
        memset(m_szTableName, 0, sizeof(m_szTableName));
    }
}

//--------------------------------------------------------------------

JBTable::JBTable(
    JBTable& jbTable
) :
JBError(),
m_JetDatabase(jbTable.GetJetDatabase()),
m_JetColumns(NULL),
m_NumJetColumns(0),
m_InEnumeration(FALSE)
/*
*/
{
    // duplicate jet cursor
    _tcscpy(m_szTableName, jbTable.GetTableName());

    m_JetTableId = m_JetDatabase.DuplicateJetCursor(
                                    jbTable.GetJetTableID(),
                                    0
                                );
    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }
}

//--------------------------------------------------------------------

JBTable::~JBTable()
{
    if(m_JetTableId == JET_tableidNil)
        return;

    CloseTable();
}


//--------------------------------------------------------------------
CLASS_PRIVATE JET_COLUMNID
JBTable::AddJetColumn(
        LPCTSTR pszColumnName,
        const JET_COLUMNDEF* pColumnDef,
        const PVOID pbDefaultValue,         // NULL
        const unsigned long cbDefaultValue // 0
    )
/*
*/
{
    DebugOutput(
            _TEXT("Adding column %s to table %s, type %d\n"),
            pszColumnName,
            GetTableName(),
            pColumnDef->coltyp
        );

    JB_STRING lpszColumnName=NULL;
    JET_COLUMNID columnid = (DWORD)JET_NIL_COLUMN;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszColumnName, &lpszColumnName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetAddColumn(
                        GetJetSessionID(),
                        GetJetTableID(),
                        lpszColumnName,
                        pColumnDef,
                        pbDefaultValue,
                        cbDefaultValue,
                        &columnid
                    );
    }

cleanup:

    DebugOutput(
            _TEXT("AddJetColumn returns %d\n"),
            GetLastJetError()
        );

    FreeJBstr(lpszColumnName);
    return columnid;
}


//--------------------------------------------------------------------
BOOL
JBTable::AddIndex(
    JBKeyBase* key
    )
/*
*/
{
    return AddJetIndex(
                key->GetIndexName(),
                key->GetIndexKey(),
                key->GetKeyLength(),
                key->GetJetGrbit(),
                key->GetJetDensity()
            );
}

//--------------------------------------------------------------------

BOOL
JBTable::AddJetIndex(
    LPCTSTR pszIndexName,
    LPCTSTR pszKey,
    unsigned long cbKey,
    JET_GRBIT grbit, /* 0 */
    unsigned long lDensity /* 20 */
    )
/*

*/
{
    DebugOutput(
            _TEXT("Adding Index %s to table %s\n"),
            pszIndexName,
            GetTableName()
        );

    JB_STRING lpszIndexName=NULL;
    JB_STRING lpszKeyName=NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszIndexName, &lpszIndexName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertMWstrToMJBstr(pszKey, cbKey, &lpszKeyName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetCreateIndex(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            grbit,
                            lpszKeyName,
                            cbKey,
                            lDensity
                        );
    }

cleanup:
    DebugOutput(
            _TEXT("Adding index %s returns %d\n"),
            pszIndexName,
            GetLastJetError()
        );

    FreeJBstr(lpszIndexName);
    FreeJBstr(lpszKeyName);

    return IsSuccess();
}

BOOL
JBTable::DoesIndexExist(
    LPCTSTR pszIndexName
    )
{
    JB_STRING lpszIndexName=NULL;
    JET_INDEXID idx;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszIndexName, &lpszIndexName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetGetTableIndexInfo(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            &idx,
                            sizeof(JET_INDEXID),
                            JET_IdxInfoIndexId
                            );

        // if this succeeds, the index exists
    }

cleanup:

    FreeJBstr(lpszIndexName);

    return IsSuccess();

}


//--------------------------------------------------------------------
BOOL
JBTable::CloseTable()
{
    BOOL bSuccess;

    if(m_JetTableId == JET_tableidNil)
        return TRUE;

    bSuccess = m_JetDatabase.CloseTable(
                                m_JetTableId
                            );
    if(bSuccess == FALSE)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    //
    // Force close on table.
    //
    m_JetTableId = JET_tableidNil;

    if(m_JetColumns)
        delete [] m_JetColumns;

    m_JetColumns = NULL;
    m_NumJetColumns = 0;

    return bSuccess;
}

//--------------------------------------------------------------------

BOOL
JBTable::CreateOpenTable(
    IN LPCTSTR pszTableName,
    IN unsigned long lPage, // 0
    IN unsigned long lDensity // 20
    )
/*
*/
{
    if(m_JetTableId != JET_tableidNil)
    {
        SetLastJetError(JET_errInvalidParameter);
        return FALSE;
    }

    DebugOutput(
            _TEXT("Creating Table %s\n"),
            pszTableName
        );

    m_JetTableId = m_JetDatabase.CreateJetTable(
                                    pszTableName,
                                    lPage,
                                    lDensity
                                );

    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    return (m_JetTableId != JET_tableidNil);
}

//--------------------------------------------------------------------

BOOL
JBTable::OpenTable(
    IN LPCTSTR pszTableName,
    IN void* pvParam,
    IN unsigned long cbParam,
    IN JET_GRBIT grbit
    )
/*
*/
{
    DebugOutput(
            _TEXT("Opening table %s\n"),
            pszTableName
        );

    JB_ASSERT(m_JetTableId == JET_tableidNil);

    if(m_JetTableId != JET_tableidNil)
    {
        SetLastJetError(JET_errTableInUse);
        return FALSE;
    }

    m_JetTableId = m_JetDatabase.OpenJetTable(
                                pszTableName,
                                pvParam,
                                cbParam,
                                grbit
                            );

    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }
    else
    {
        // load column info in the table
        _tcscpy(m_szTableName, pszTableName);

        if(LoadTableInfo() == FALSE)
        {
            // force a close on table
            CloseTable();
        }
    }

    DebugOutput(
            _TEXT("Open table %s return code %d\n"),
            pszTableName,
            GetLastJetError()
        );

    return (m_JetTableId != JET_tableidNil);
}

//--------------------------------------------------------------------

JBTable*
JBTable::DuplicateCursor(
    JET_GRBIT grbit /* 0 */
    )
/*
*/
{
    JET_TABLEID tableid;

    tableid = m_JetDatabase.DuplicateJetCursor(
                                    m_JetTableId,
                                    grbit
                                );
    if(tableid == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    return new JBTable(
                    m_JetDatabase,
                    GetTableName(),
                    tableid
                );
}


//--------------------------------------------------------------------

JBTable&
JBTable::operator=(const JBTable& srcTable)
{
    if(this == &srcTable)
        return *this;

    // database has to be the same
    // verify database is consistent


    _tcscpy(m_szTableName, srcTable.GetTableName());

    m_JetTableId = m_JetDatabase.DuplicateJetCursor(
                                    srcTable.GetJetTableID(),
                                    0
                                );
    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    return *this;
}

//--------------------------------------------------------------------
int
JBTable::AddColumn(
    int numColumns,
    PTLSJBColumn pColumnDef
    )
/*
*/
{
    JET_COLUMNDEF  column;
    JET_COLUMNID   jet_columnid;

    for(int i=0; i < numColumns; i++)
    {
        memset(&column, 0, sizeof(column));

        column.cbStruct = sizeof(JET_COLUMNDEF);
        column.coltyp = (pColumnDef+i)->colType;
        column.wCountry = (pColumnDef+i)->wCountry;
        column.langid = (pColumnDef+i)->langid;
        column.cp = (pColumnDef+i)->colCodePage;
        column.cbMax = (pColumnDef+i)->cbMaxLength;
        column.grbit = (pColumnDef+i)->jbGrbit;

        jet_columnid = AddJetColumn(
                                (pColumnDef+i)->pszColumnName,
                                &column,
                                (pColumnDef+i)->pbDefValue,
                                (pColumnDef+i)->cbDefValue
                            );

        if(jet_columnid == JET_NIL_COLUMN)
            break;
    }

    // return which column cause trouble
    return i;
}

//--------------------------------------------------------------------
int
JBTable::AddIndex(
    int numIndex,
    PTLSJBIndex pIndex
    )
/*
*/
{
    unsigned long keylength;

    for(int i=0; i < numIndex; i++)
    {
        if((pIndex+i)->cbKey == -1)
        {
            // calculate index key length
            keylength = 2;

            while((pIndex+i)->pszIndexKey[keylength-1] != _TEXT('\0') ||
                  (pIndex+i)->pszIndexKey[keylength-2] != _TEXT('\0'))
            {
                if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
                {
                    SetLastJetError(JET_errInvalidParameter);
                    break;
                }

                keylength++;
            }
        }
        else
        {
            keylength = (pIndex+i)->cbKey;
        }

        if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
        {
            SetLastJetError(JET_errInvalidParameter);
            break;
        }

        if(AddJetIndex(
                    (pIndex+i)->pszIndexName,
                    (pIndex+i)->pszIndexKey,
                    keylength,
                    (pIndex+i)->jbGrbit,
                    (pIndex+i)->ulDensity
                ) == FALSE)
        {
            break;
        }
    }

    return (i >= numIndex) ? 0 : i;
}

//-------------------------------------------------------------

CLASS_PRIVATE BOOL
JBTable::LoadTableInfo()
/*
*/
{
#if 1
    LPSTR lpszTableName=NULL;
    JET_COLUMNLIST columns;
    unsigned long cbMax;
    JET_RETINFO jetRetInfo;
    char lpszColumnName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars;
    unsigned long index;

    SINGLE_JET_CALL;

    if(ConvertWstrToJBstr(GetTableName(), &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    memset(&columns, 0, sizeof(columns));
    columns.cbStruct = sizeof(JET_COLUMNLIST);
    cbMax = sizeof(JET_COLUMNLIST);

    m_JetErr = JetGetColumnInfo(
                            GetJetSessionID(),
                            GetJetDatabaseID(),
                            lpszTableName,
                            NULL,
                            (PVOID)&columns,
                            cbMax,
                            1                   // retrieve column list
                        );
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    // Table has just been created
    //
    if(columns.cRecord == 0)
        goto cleanup;

    m_JetColumns = new JBColumn[columns.cRecord];
    if(m_JetColumns == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    SetLastJetError(JET_errSuccess);

    //
    // TODO - use JBColumn class to retrieve value
    //
    m_NumJetColumns = columns.cRecord;
    for(index=0;
        index < columns.cRecord && IsSuccess() == TRUE;
        index++)
    {
        m_JetColumns[index].AttachToTable(this);

        if(m_JetColumns[index].LoadJetColumnInfoFromJet(&columns) == FALSE)
        {
            m_JetErr = m_JetColumns[index].GetLastJetError();
            break;
        }

        m_JetErr = JetMove(
                            GetJetSessionID(),
                            columns.tableid,
                            JET_MoveNext,
                            0
                        );

    }

    if(GetLastJetError() == JET_errNoCurrentRecord && index >= columns.cRecord)
    {
        // otherwise - got to be a JetBlue bug here.
        SetLastJetError(JET_errSuccess);
    }


    //
    //
    //
cleanup:

    FreeJBstr(lpszTableName);
    if(IsSuccess() == FALSE && m_JetColumns)
    {
        delete [] m_JetColumns;
        m_JetColumns = NULL;
        m_NumJetColumns = 0;
    }

    return IsSuccess();
#else
    LPSTR lpszTableName=NULL;
    JET_COLUMNLIST columns;
    unsigned long cbMax;
    JET_RETINFO jetRetInfo;
    unsigned long cbActual;
    char lpszColumnName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars;
    unsigned long index;
    SINGLE_JET_CALL;


    if(ConvertWstrToJBstr(GetTableName(), &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    memset(&columns, 0, sizeof(columns));
    columns.cbStruct = sizeof(JET_COLUMNLIST);
    cbMax = sizeof(JET_COLUMNLIST);


    m_JetErr = JetGetColumnInfo(
                            GetJetSessionID(),
                            GetJetDatabaseID(),
                            lpszTableName,
                            NULL,
                            (PVOID)&columns,
                            cbMax,
                            1                   // retrieve column list
                        );
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    // Table has just been created
    //
    if(columns.cRecord == 0)
        goto cleanup;

    // retrieve column name, column id, column type and column size
    m_Columns = (PJetColumns) AllocateMemory(sizeof(JetColumns) * columns.cRecord);
    if(m_Columns == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    SetLastJetError(JET_errSuccess);

    //
    // TODO - use JBColumn class to retrieve value
    //
    m_NumColumns = columns.cRecord;
    for(index=0;
        index < columns.cRecord && IsSuccess() == TRUE;
        index++)
    {
        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        // retrieve column name
        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcolumnname,
                                lpszColumnName,
                                sizeof(lpszColumnName),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        NumChars = MultiByteToWideChar(
                            GetACP(),
                            MB_PRECOMPOSED,
                            lpszColumnName,
                            cbActual,
                            (m_Columns+index)->pszColumnName,
                            sizeof((m_Columns+index)->pszColumnName)
                        );

        if(NumChars == 0)
        {
            SetLastJetError(JET_errInvalidParameter);
            continue;
        }

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        // retrieve column ID
        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcolumnid,
                                &((m_Columns+index)->colId),
                                sizeof((m_Columns+index)->colId),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcoltyp,
                                &((m_Columns+index)->colType),
                                sizeof((m_Columns+index)->colType),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidcbMax,
                                &((m_Columns+index)->cbMaxLength),
                                sizeof((m_Columns+index)->cbMaxLength),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );

        if(IsSuccess() == FALSE)
            continue;

        memset(&jetRetInfo, 0, sizeof(JET_RETINFO));
        jetRetInfo.cbStruct = sizeof(JET_RETINFO);

        m_JetErr = JetRetrieveColumn(
                                GetJetSessionID(),
                                columns.tableid,
                                columns.columnidgrbit,
                                &((m_Columns+index)->jbGrbit),
                                sizeof((m_Columns+index)->jbGrbit),
                                &cbActual,
                                0,
                                &jetRetInfo
                            );
        DebugOutput(
                _TEXT("Loaded Column name %s, Column Type %d, Column ID %d\n"),
                m_Columns[index].pszColumnName,
                m_Columns[index].colType,
                m_Columns[index].colId
            );

        if(IsSuccess() == FALSE)
            continue;

        m_JetErr = JetMove(
                            GetJetSessionID(),
                            columns.tableid,
                            JET_MoveNext,
                            0
                        );

    }

    if(GetLastJetError() == JET_errNoCurrentRecord && index >= columns.cRecord)
    {
        // otherwise - got to be a JetBlue bug here.
        SetLastJetError(JET_errSuccess);
    }


    //
    //
    //
cleanup:
    FreeJBstr(lpszTableName);
    if(IsSuccess() == FALSE && m_Columns)
    {
        FreeMemory(m_Columns);
        m_Columns = NULL;
        m_NumColumns = 0;
    }

    return IsSuccess();
#endif
}


//-------------------------------------------------------------

JET_COLUMNID
JBTable::GetJetColumnID(
    LPCTSTR pszColumnName
    )
/*
*/
{
    int index;

    index = GetJetColumnIndex(pszColumnName);
    if(index < 0 || index >= m_NumJetColumns)
    {
        return (DWORD)JET_NIL_COLUMN;
    }

    return m_JetColumns[index].GetJetColumnID();
}

//-------------------------------------------------------------

int
JBTable::GetJetColumnIndex(
    LPCTSTR pszColumnName
    )
/*
*/
{
    if(m_JetColumns == NULL || m_NumJetColumns == 0)
    {
        SetLastJetError(JET_errNotInitialized);
        return -1;
    }

    for(int index=0; index < m_NumJetColumns; index++)
    {
        if(_tcsicmp(m_JetColumns[index].GetJetColumnName(), pszColumnName) == 0)
            break;
    }

    return (index >= m_NumJetColumns) ? -1 : index;
}

//-------------------------------------------------------------

JBColumn*
JBTable::FindColumnByIndex(
    const int index
    )
/*
*/
{
    if(m_JetColumns == NULL || m_NumJetColumns == 0)
    {
        SetLastJetError(JET_errNotInitialized);
        return NULL;
    }

    if(index < 0 || index >= m_NumJetColumns)
    {
        SetLastJetError(JET_errInvalidParameter);
        return NULL;
    }

    return m_JetColumns+index;
}

//--------------------------------------------------------------

JBColumn*
JBTable::FindColumnByColumnId(
    const JET_COLUMNID JetColId
    )
/*
*/
{
    if(m_JetColumns == NULL || m_NumJetColumns == 0)
    {
        SetLastJetError(JET_errNotInitialized);
        return NULL;
    }

    for(int index=0; index < m_NumJetColumns; index++)
    {
        if(m_JetColumns[index].GetJetColumnID() == JetColId)
            break;
    }

    return FindColumnByIndex( index );
}

//--------------------------------------------------------------

JBColumn*
JBTable::FindColumnByName(
    LPCTSTR pszColumnName
    )
/*
*/
{
    return FindColumnByIndex(GetJetColumnIndex(pszColumnName));
}

//--------------------------------------------------------------

BOOL
JBTable::BeginUpdate(
    BOOL bUpdate /* false */
    )
/*
*/
{
    if(GetTransactionLevel() == 0)
    {
        SetLastJetError(JET_errNotInTransaction);
        JB_ASSERT(FALSE);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetPrepareUpdate(
                            GetJetSessionID(),
                            GetJetTableID(),
                            (bUpdate) ? JET_prepReplace : JET_prepInsert
                        );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::EndUpdate(
    BOOL bDisacrd /* FALSE */
    )
/*
*/
{
    BYTE pBookmark[JET_cbBookmarkMost+1];
    DWORD cbActual = 0;

    SINGLE_JET_CALL;

    //
    // Hack for work item table.
    //
    m_JetErr = JetUpdate(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pBookmark,
                        JET_cbBookmarkMost,
                        &cbActual
                    );

    if(IsSuccess() && m_InsertRepositionBookmark)
    {
        GotoBookmark(pBookmark, cbActual);
    }

    return IsSuccess();
}

//-------------------------------------------------------------
BOOL
JBTable::SetCurrentIndex(
    LPCTSTR pszIndexName,
    JET_GRBIT grbit /* JET_bitMoveFirst */
    )
/*++

--*/
{
    if(IsValid() == FALSE || m_InEnumeration == TRUE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    //
    // Can't be in enumeration and and try to set index
    //
    JB_ASSERT(m_InEnumeration == FALSE);

    char* lpszIndexName=NULL;

    if(ConvertWstrToJBstr(pszIndexName, &lpszIndexName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetSetCurrentIndex2(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            grbit
                        );
    }

    if(IsSuccess())
    {
        m_InEnumeration = TRUE;
    }

cleanup:

    FreeJBstr(lpszIndexName);
    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::EnumBegin(
    LPCTSTR pszIndexName,
    JET_GRBIT grbit /* JET_bitMoveFirst */
    )
/*
*/
{
    if(m_InEnumeration == TRUE)
    {
        //
        // Force terminate enumeration
        //
        EnumEnd();
    }

    return SetCurrentIndex(pszIndexName, grbit);
}

//-------------------------------------------------------------

JBTable::ENUM_RETCODE
JBTable::EnumNext(
    JET_GRBIT crow  /* JET_MoveNext */,
    JET_GRBIT grbit /* 0 */
    )
/*
*/
{
    if(m_InEnumeration == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        return ENUM_ERROR;
    }

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return ENUM_ERROR;
    }

    ENUM_RETCODE retCode = ENUM_CONTINUE;

    while( retCode == ENUM_CONTINUE )
    {
        MoveToRecord(crow, grbit);

        switch(m_JetErr)
        {
            case JET_errSuccess:
                retCode = ENUM_SUCCESS;
                break;

            case JET_errNoCurrentRecord:
                retCode = ENUM_END;
                break;

            case JET_errRecordDeleted:
                retCode = ENUM_CONTINUE;
                break;

            default:
                retCode = ENUM_ERROR;
        }
    }

    return retCode;
}

//-------------------------------------------------------------

BOOL
JBTable::SeekToKey(
    JBKeyBase* key,
    DWORD dwSeachParam,
    JET_GRBIT jetseekgrbit /* =JET_bitSeekGE */
    )
/*
*/
{
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

#ifdef DEBUG_SEEK
    LPTSTR szKey=key->GetIndexKey();
#endif

    EnumBegin(
            key->GetIndexName(),
            JET_bitMoveFirst
        );

    if(IsSuccess() == FALSE)
        return FALSE;

    if(key->IsEmptyValue() == TRUE)
    {
        return TRUE;
    }

    PVOID pbData;
    unsigned long cbData;
    JET_GRBIT key_grbit=JET_bitNewKey;

    SetLastJetError(JET_errSuccess);

    for(DWORD dwComponent=0;
        dwComponent < key->GetNumKeyComponents();
        dwComponent++)
    {
        if(key->GetSearchKey(dwComponent, &pbData, &cbData, &key_grbit, dwSeachParam) == FALSE)
            break;

        if(MakeKey(pbData, cbData, key_grbit) == FALSE)
            break;
    }

#ifdef DEBUG_SEEK
    PVOID pb=NULL;
    DWORD cb=0;
    unsigned long actual;

    SINGLE_JET_CALL;

    m_JetErr = JetRetrieveKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pb,
                        cb,
                        &actual,
                        0
                    );

    pb = (PVOID)AllocateMemory(actual);
    cb = actual;

    m_JetErr = JetRetrieveKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pb,
                        cb,
                        &actual,
                        0
                    );

    FreeMemory(pb);
#endif

    return IsSuccess() ? SeekValue(jetseekgrbit) : FALSE;
}

//-------------------------------------------------------------

BOOL
JBTable::EnumBegin(
    JBKeyBase* key,
    DWORD dwSearchParam
    )
/*
*/
{
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    if(m_InEnumeration == TRUE)
    {
        // what do we do???
    }

    return SeekToKey(key, dwSearchParam);
}



//-------------------------------------------------------------

BOOL
JBTable::GetCurrentIndex(
    LPTSTR pszIndexName,
    unsigned long* bufferSize
    )
/*
*/
{
    char lpszIndexName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars=0;

    SINGLE_JET_CALL;

    m_JetErr = JetGetCurrentIndex(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            sizeof(lpszIndexName)
                        );

    if(IsSuccess() == FALSE)
        goto cleanup;

    NumChars = MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpszIndexName,
                        -1,
                        pszIndexName,
                        *bufferSize
                    );

    if(NumChars == 0)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    *bufferSize = NumChars;

cleanup:

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::GetBookmark(
    PVOID pbBuffer,
    PDWORD pcbBufSize
    )
/*++

--*/
{
    DWORD cbBufferSize = *pcbBufSize;

    SINGLE_JET_CALL;

    m_JetErr = JetGetBookmark(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pbBuffer,
                        cbBufferSize,
                        pcbBufSize
                    );

    if(m_JetErr == JET_errBufferTooSmall)
    {
        SetLastJetError(m_JetErr);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::GotoBookmark(
    PVOID pbBuffer,
    DWORD cbBuffer
    )
/*++

--*/
{
    SINGLE_JET_CALL;

    m_JetErr = JetGotoBookmark(
                            GetJetSessionID(),
                            GetJetTableID(),
                            pbBuffer,
                            cbBuffer
                        );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::ReadLock()
{
    SINGLE_JET_CALL;

    m_JetErr = JetGetLock(
                    GetJetSessionID(),
                    GetJetTableID(),
                    JET_bitReadLock
                );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::WriteLock()
{
    SINGLE_JET_CALL;

    m_JetErr = JetGetLock(
                    GetJetSessionID(),
                    GetJetTableID(),
                    JET_bitWriteLock
                );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::RetrieveKey(
    PVOID pbData,
    unsigned long cbData,
    unsigned long* pcbActual,
    JET_GRBIT grbit
    )
/*
*/
{
    unsigned long cbActual;
    SINGLE_JET_CALL;

    m_JetErr = JetRetrieveKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pbData,
                        cbData,
                        (pcbActual) ? pcbActual : &cbActual,
                        grbit  // user2.doc - unuse.
                    );
    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::MoveToRecord(
    long crow,
    JET_GRBIT grbit
    )
/*
*/
{
    SINGLE_JET_CALL;
    m_JetErr = JetMove(
                    GetJetSessionID(),
                    GetJetTableID(),
                    crow,
                    grbit
                );

    return IsSuccess();
}

//-------------------------------------------------------------
unsigned long
JBTable::GetIndexRecordCount(
    unsigned long max
    )
/*
*/
{
    unsigned long count;
    SINGLE_JET_CALL;

    m_JetErr = JetIndexRecordCount(
                            GetJetSessionID(),
                            GetJetTableID(),
                            &count,
                            max
                        );

    return IsSuccess() ? count : 0;
}

//-------------------------------------------------------------

BOOL
JBTable::MakeKey(
    PVOID pbData,
    unsigned long cbData,
    JET_GRBIT grbit
    )
/*
*/
{
    SINGLE_JET_CALL;

    m_JetErr = JetMakeKey(
                        GetJetSessionID(),
                        GetJetTableID(),
                        pbData,
                        cbData,
                        grbit
                    );

    return IsSuccess();
}

//-------------------------------------------------------------

BOOL
JBTable::SeekValue(
    JET_GRBIT grbit
    )
/*
*/
{
    SINGLE_JET_CALL;

    m_JetErr = JetSeek(
                    GetJetSessionID(),
                    GetJetTableID(),
                    grbit
                );

    return IsSuccess();
}


//-------------------------------------------------------------

BOOL
JBTable::DeleteRecord()
/*
*/
{
    SINGLE_JET_CALL;

    // must have current record set
    m_JetErr = JetDelete(
                        GetJetSessionID(),
                        GetJetTableID()
                    );

    return IsSuccess();
}


//
//////////////////////////////////////////////////////////////
//
CLASS_PRIVATE void
JBColumn::Cleanup()
/*
*/
{
    memset(m_szColumnName, 0, sizeof(m_szColumnName));
}

//-----------------------------------------------------------

JBColumn::JBColumn(JBTable* pJetTable) :
m_pJetTable(pJetTable),
m_JetColId(0),
m_JetColType(JET_coltypNil),
m_JetMaxColLength(0),
m_JetGrbit(0),
m_JetColCodePage(TLS_JETBLUE_COLUMN_CODE_PAGE),
m_JetColCountryCode(TLS_JETBLUE_COLUMN_COUNTRY_CODE),
m_JetColLangId(TLS_JETBLUE_COLUMN_LANGID),
m_cbActual(0),
m_pbDefValue(NULL),
m_cbDefValue(0),
m_JetNullColumn(FALSE)
/*
*/
{
    Cleanup();
}

//-----------------------------------------------------------

CLASS_PRIVATE JET_ERR
JBColumn::RetrieveColumnValue(
    IN JET_SESID sesid,
    IN JET_TABLEID tableid,
    IN JET_COLUMNID columnid,
    IN OUT PVOID pbBuffer,
    IN unsigned long cbBuffer,
    IN unsigned long offset
    )
/*
*/
{
    m_JetRetInfo.cbStruct = sizeof(m_JetRetInfo);
    m_JetRetInfo.ibLongValue = offset;
    m_JetNullColumn = FALSE;
    m_cbActual = 0;

    SINGLE_JET_CALL;

    //
    // JETBLUE bug??? passing zeror buffer size returns Column NULL
    //
    m_JetErr = JetRetrieveColumn(
                            sesid,
                            tableid,
                            columnid,
                            pbBuffer,
                            cbBuffer,
                            &m_cbActual,
                            0,
                            NULL // &m_JetRetInfo
                        );

    if(m_JetErr == JET_wrnColumnNull)
        m_JetNullColumn = TRUE;

    return IsSuccess();
}

//-----------------------------------------------------------

CLASS_PRIVATE BOOL
JBColumn::LoadJetColumnInfoFromJet(
    const JET_COLUMNLIST* pColumnList
    )
/*
*/
{
    char lpszColumnName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars;

    //
    // retrieve column name
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcolumnname,
                lpszColumnName,
                sizeof(lpszColumnName)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    NumChars = MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpszColumnName,
                        m_cbActual,
                        m_szColumnName,
                        sizeof(m_szColumnName)/sizeof(m_szColumnName[0])
                    );

    if(NumChars == 0)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    //DebugOutput(
    //        _TEXT("Load column %s"),
    //        m_szColumnName
    //    );

    //
    // retrieve column ID
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcolumnid,
                &m_JetColId,
                sizeof(m_JetColId)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tColId - %d"),
    //        m_JetColId
    //    );

    //
    // Retrieve Column Type
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcoltyp,
                &m_JetColType,
                sizeof(m_JetColType)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tCol Type %d"),
    //        m_JetColType
    //    );

    //
    // Retrieve Max. length for LongText and Long Binary
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidcbMax,
                &m_JetMaxColLength,
                sizeof(m_JetMaxColLength)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tMax Col Length %d"),
    //        m_JetMaxColLength
    //    );

    //
    // Retrieve Column Grbit
    //
    RetrieveColumnValue(
                GetJetSessionID(),
                pColumnList->tableid,
                pColumnList->columnidgrbit,
                &m_JetGrbit,
                sizeof(m_JetGrbit)
            );

    if(IsSuccess() == FALSE)
        goto cleanup;

    //DebugOutput(
    //        _TEXT("\tCol grbit %d"),
    //        m_JetGrbit
    //    );

cleanup:

    //DebugOutput(
    //        _TEXT("\n")
    //    );

    return IsSuccess();
}

//-----------------------------------------------------------
BOOL
JBColumn::IsValid() const
/*
*/
{
    return m_pJetTable != NULL && m_pJetTable->IsValid();
}

//-----------------------------------------------------------

BOOL
JBColumn::InsertColumn(
    PVOID pbData,
    unsigned long cbData,
    unsigned long offset
    )
/*
*/
{
    //JET_SETINFO setinfo;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        return IsSuccess();
    }

    SINGLE_JET_CALL;

    // if(GetJetColumnType() == JET_coltypLongText || GetJetColumnType() == JET_coltypLongBinary)
    if(pbData == NULL || cbData == 0)
    {
        m_JetErr = JetSetColumn(
                            GetJetSessionID(),
                            GetJetTableID(),
                            GetJetColumnID(),
                            0,
                            0,
                            JET_bitSetZeroLength,
                            NULL
                        );

        if(IsSuccess() == FALSE)
            return FALSE;

        m_JetErr = JetSetColumn(
                            GetJetSessionID(),
                            GetJetTableID(),
                            GetJetColumnID(),
                            0,
                            0,
                            0,
                            NULL
                        );

        if(IsSuccess() == FALSE)
            return FALSE;
    }

    m_JetErr = JetSetColumn(
                        GetJetSessionID(),
                        GetJetTableID(),
                        GetJetColumnID(),
                        pbData,
                        cbData,
                        0,
                        NULL
                    );

    return IsSuccess();
}

//-----------------------------------------------------------

BOOL
JBColumn::FetchColumn(
    PVOID pbData,
    unsigned long cbData,
    unsigned long starting_offset
    )
/*
    pass NULL and 0 to determine buffer size needed.
*/
{
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
    }
    else
    {
        RetrieveColumnValue(
                    GetJetSessionID(),
                    GetJetTableID(),
                    GetJetColumnID(),
                    pbData,
                    cbData,
                    starting_offset
                );
    }

    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\jetblue\jetblue.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __JETBLUE_H__
#define __JETBLUE_H__

#include "JBDef.h"
#include "locks.h"

#define JETBLUE_EDBLOG      _TEXT("edb*.log")
#define JETBLUE_RESLOG      _TEXT("res?.log")


class JBError;
class JBSession;
class JBDatabase;
class JBTable;
class JBColumn;


// class JBIndex;
// class JBRecordSet;

//
/////////////////////////////////////////////////////////////////////
//
class JBInstance : public JBError {
    friend class JBSession;

    friend operator==(const JBInstance& jbInst1, const JBInstance& jbInst2);
    friend operator!=(const JBInstance& jbInst1, const JBInstance& jbInst2);

private:

    JET_INSTANCE    m_JetInstance;

    // DWORD    m_NumSession;

    CSafeCounter    m_NumSession;
    BOOL            m_bInit;

private:

    JET_SESID
    BeginJetSession(
        LPCTSTR pszUserName=NULL,
        LPCTSTR pszPwd=NULL
    );

    BOOL
    EndJetSession(
        JET_SESID JetSessionID,
        JET_GRBIT grbit = 0
    );

    BOOL
    EndSession(
        JET_SESID sesId,
        JET_GRBIT grbit
    );

public:

    JBInstance();
    ~JBInstance();

    BOOL
    SetSystemParameter(
        JET_SESID SesId,
        unsigned long lParamId,
        ULONG_PTR lParam,
        PBYTE sz
    );

    BOOL
    GetSystemParameter(
        JET_SESID SesId,
        unsigned long lParamId,
        ULONG_PTR* plParam,
        PBYTE sz,
        unsigned long cbMax
    );

    const JET_INSTANCE
    GetInstanceID() const {
        return m_JetInstance;
    }

    BOOL
    JBInitJetInstance();

    BOOL
    JBTerminate(
        JET_GRBIT grbit = JET_bitTermComplete,
        BOOL bDeleteLogFile = FALSE
    );

    BOOL
    IsValid() const
    {
        return m_bInit;
    }

};

//--------------------------------------------------------------------

inline BOOL
operator==(
    const JBInstance& jbInst1,
    const JBInstance& jbInst2
    )
{
    return jbInst1.GetInstanceID() == jbInst2.GetInstanceID();
}

inline BOOL
operator!=(
    const JBInstance& jbInst1,
    const JBInstance& jbInst2
    )
{
    return !(jbInst1 == jbInst2);
}

//
/////////////////////////////////////////////////////////////////////
//
class JBSession : public JBError {

    friend class JBDatabase;

private:

    JBInstance&  m_JetInstance;

    JET_SESID    m_JetSessionID;

    // JetBlue Transaction is session base
    int          m_TransactionLevel;


    // DWORD        m_JetDBInitialized;
    CSafeCounter m_JetDBInitialized;
    // CCriticalSection    m_JetSessionLock;

private:

    JET_DBID
    OpenJetDatabase(
        LPCTSTR szDatabase,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    CloseJetDatabase(
        JET_DBID jdbId,
        JET_GRBIT grbit=0
    );

    JET_DBID
    CreateJetDatabase(
        LPCTSTR szFileName,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    DuplicateSession(
        JET_SESID sesID
    );

    JBInstance&
    GetJetInstance() {
        return m_JetInstance;
    }

    BOOL
    CloseDatabase(
        JET_DBID jdbId,
        JET_GRBIT grbit=0
    );

public:

    JBSession(JBSession& JetSession);       // JetDupSession()
    JBSession(
            JBInstance& JetInstance,
            JET_SESID JetSessID=JET_sesidNil
    );

    ~JBSession();


    BOOL
    IsValid() const {
        return m_JetInstance.IsValid() &&
               m_JetSessionID != JET_sesidNil;
    }

    BOOL
    BeginSession(
        LPCTSTR szUserName=NULL,
        LPCTSTR szPwd=NULL
    );

    BOOL
    EndSession(
        JET_GRBIT grbit = JET_bitTermComplete
    );

    const JBInstance&
    GetJetInstance() const {
        return m_JetInstance;
    }

    const JET_SESID
    GetJetSessionID() const {
        return m_JetSessionID;
    }

    BOOL
    SetSystemParameter(
        unsigned long lParamId,
        ULONG_PTR lParam,
        const PBYTE sz
    );

    BOOL
    GetSystemParameter(
        unsigned long lParamId,
        ULONG_PTR* plParam,
        PBYTE sz,
        unsigned long cbMax
    );

    //
    // make JetBlue aware of database
    //
    BOOL
    AttachDatabase(
        LPCTSTR szFileName,
        JET_GRBIT grbit=0
    );

    BOOL
    DetachDatabase(
        LPCTSTR szFileName
    );

    //
    // Transaction
    //
    BOOL
    BeginTransaction();

    BOOL
    CommitTransaction(JET_GRBIT grbit=0);

    BOOL
    RollbackTransaction(JET_GRBIT grbit=JET_bitRollbackAll);

    int
    GetTransactionLevel() const {
        return m_TransactionLevel;
    }

    BOOL
    EndAllTransaction(
        BOOL bCommit=FALSE,
        JET_GRBIT grbit=0
    );

    BOOL
    Compatible(const JBSession& jbSess) const {
        return GetJetInstance() == jbSess.GetJetInstance();
    }

    //CCriticalSection&
    //GetSessionLock()
    //{
    //    return m_JetSessionLock;
    //}
};


//
/////////////////////////////////////////////////////////////////////
//
class JBDatabase : public JBError {
    friend class JBTable;

private:
    JBSession&      m_JetSession;
    TCHAR           m_szDatabaseFile[MAX_PATH+1];

    CSafeCounter    m_TableOpened;

    // DWORD        m_TableOpened;

    JET_DBID m_JetDbId;

private:

    JET_TABLEID
    OpenJetTable(
        LPCTSTR pszTableName,
        void* pvParam=NULL,
        unsigned long cbParam=0,
        JET_GRBIT grbit=JET_bitTableUpdatable
    );

    JET_TABLEID
    DuplicateJetCursor(
        // JET_SESID sesId,
        JET_TABLEID tableid,
        JET_GRBIT grbit=0       // must be zero
    );

    JET_TABLEID
    CreateJetTable(
        LPCTSTR pszTableName,
        unsigned long lPage=0,
        unsigned long lDensity=20
    );

    BOOL
    CloseJetTable(
        // JET_SESID sesId,
        JET_TABLEID tableid
    );

    JET_TABLEID
    CreateJetTableEx(
        LPCTSTR pszTableName,
        const PTLSJBTable table_attribute,
        const PTLSJBColumn columns,
        const DWORD num_columns,
        const PTLSJBIndex index,
        const DWORD num_index
    );

    BOOL
    CloseTable(
        JET_TABLEID tableid
    );

public:

    JBDatabase(
        JBSession& jbSession,
        JET_DBID jdbId=JET_dbidNil,
        LPCTSTR pszDatabase=NULL
    );

    ~JBDatabase();

    BOOL
    IsValid() const {
        return m_JetSession.IsValid() && m_JetDbId != JET_dbidNil;
    }

    const JBSession&
    GetJetSession() const {
        return m_JetSession;
    }

    const JET_SESID
    GetJetSessionID() const {
        return m_JetSession.GetJetSessionID();
    }

    const JET_DBID
    GetJetDatabaseID() const {
        return m_JetDbId;
    }

    BOOL
    Compatible(const JBDatabase& jbDatabase) const {
        return GetJetSession().Compatible(jbDatabase.GetJetSession());
    }

    LPCTSTR
    GetDatabaseName() const {
        return m_szDatabaseFile;
    }

    BOOL
    OpenDatabase(
        LPCTSTR szDatabase,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    CreateDatabase(
        LPCTSTR szDatabase,
        LPCTSTR szConnect=NULL,
        JET_GRBIT grbit=0
    );

    BOOL
    CloseDatabase(
        JET_GRBIT grbit=0
    );

    BOOL
    DeleteTable(
        LPCTSTR pszTableName
    );

    //
    // tableid return from JetCreateTable is not usable
    //
    JET_TABLEID
    CreateTable(
        LPCTSTR pszTableName,
        unsigned long lPage=0,
        unsigned long lDensity=20
    );

    JET_TABLEID
    CreateTableEx(
        LPCTSTR pszTableName,
        const PTLSJBTable table_attribute,
        const PTLSJBColumn columns,
        DWORD num_columns,
        const PTLSJBIndex index,
        DWORD num_index
    );

    //JBTable*
    //CreateTable(
    //    LPCTSTR pszTableName,
    //    unsigned long lPage=0,
    //    unsigned long lDensity=20
    //);

    //JBTable*
    //CreateTableEx(
    //    LPCTSTR pszTableName,
    //    const PTLSJBTable table_attribute,
    //    const PTLSJBColumn columns,
    //    DWORD num_columns,
    //    const PTLSJBIndex index,
    //    DWORD num_index
    //);

    //
    // Transaction
    //
    BOOL
    BeginTransaction() {
        return m_JetSession.BeginTransaction();
    }

    BOOL
    CommitTransaction(JET_GRBIT grbit=0) {
        return m_JetSession.CommitTransaction(grbit);
    }

    BOOL
    RollbackTransaction(JET_GRBIT grbit=JET_bitRollbackAll) {
        return m_JetSession.RollbackTransaction(grbit);
    }

    int
    GetTransactionLevel() const {
        return m_JetSession.GetTransactionLevel();
    }


    //CCriticalSection&
    //GetSessionLock() {
    //    return m_JetSession.GetSessionLock();
    //}
};

//
/////////////////////////////////////////////////////////////////////
//
// Pure virtual base struct for index
//
struct JBKeyBase {

    BOOL m_EmptyValue;

    JBKeyBase() : m_EmptyValue(TRUE) {}

    void
    SetEmptyValue(BOOL bEmpty) { m_EmptyValue = bEmpty; }

    virtual JET_GRBIT
    GetJetGrbit() {
        return JET_bitIndexIgnoreNull;
    }

    virtual unsigned long
    GetJetDensity() {
        return TLS_TABLE_INDEX_DEFAULT_DENSITY;
    }

    virtual BOOL
    IsEmptyValue() {
        return m_EmptyValue;
    }

    virtual DWORD
    GetKeyLength() {
        LPCTSTR pszIndexKey = GetIndexKey();
        DWORD keylength;

        // calculate index key length, terminated with double 0
        keylength = 2;

        while(pszIndexKey[keylength-1] != _TEXT('\0') ||
              pszIndexKey[keylength-2] != _TEXT('\0'))
        {
            if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
            {
                DebugBreak();   // error
                return TLS_JETBLUE_MAX_INDEXKEY_LENGTH;
            }

            keylength++;
        }

        return keylength;
    }

    // ----------------------------------------------------
    // Virtual function must be implemented
    // ----------------------------------------------------
    virtual BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchType
    )=0;

    virtual LPCTSTR
    GetIndexName()=0;

    virtual LPCTSTR
    GetIndexKey() = 0;

    virtual DWORD
    GetNumKeyComponents() = 0;
};

//
/////////////////////////////////////////////////////////////////////
//
struct JBIndexStructBase {
    virtual LPCTSTR
    GetIndexName() = 0;

    virtual LPCTSTR
    GetIndexKey() = 0;

    virtual DWORD
    GetNumKeyComponent() = 0;

    virtual BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchType
    ) = 0;
};

//
/////////////////////////////////////////////////////////////////////
//
class JBTable : public JBError {
    friend class JBDatabase;

private:
    static JBColumn m_ErrColumn;

    JBDatabase& m_JetDatabase;
    TCHAR       m_szTableName[MAX_TABLENAME_LENGTH+1];

    JET_TABLEID m_JetTableId;

    typedef struct JetColumns {
        TCHAR           pszColumnName[MAX_JETBLUE_NAME_LENGTH];

        JET_COLTYP      colType;
        JET_COLUMNID    colId;
        unsigned long   cbMaxLength;    // max length of column

        JET_GRBIT       jbGrbit;

    } JetColumns, *PJetColumns;

    //PJetColumns     m_Columns;
    //int             m_NumColumns;

    JBColumn*       m_JetColumns;
    int             m_NumJetColumns;
    BOOL            m_InEnumeration;

    BOOL            m_InsertRepositionBookmark;

private:

    JBDatabase&
    GetJetDatabase() {
        return m_JetDatabase;
    }

    JET_COLUMNID
    AddJetColumn(
        LPCTSTR pszColumnName,
        const JET_COLUMNDEF* pColumnDef,
        const PVOID pbDefaultValue=NULL,
        const unsigned long cbDefaultValue=0
    );

    BOOL
    LoadTableInfo();

public:

    void
    SetInsertRepositionBookmark(
        BOOL bRepo
        )
    /*++
    --*/
    {
        m_InsertRepositionBookmark = bRepo;
        return;
    }

    typedef enum {
        ENUM_ERROR=0,
        ENUM_SUCCESS,
        ENUM_END,
        ENUM_CONTINUE
    } ENUM_RETCODE;

    int
    GetNumberOfColumns() {
        return m_NumJetColumns;
    }

    JBTable(
        JBDatabase& JetDatabase,
        LPCTSTR pszTableName=NULL,
        JET_TABLEID tableid=JET_tableidNil
    );

    JBTable(
        JBTable& jbTable
    );

    ~JBTable();

    BOOL
    IsValid() const {
        return m_JetTableId != JET_tableidNil && m_JetDatabase.IsValid();
    }

    const JBDatabase&
    GetJetDatabase() const {
        return m_JetDatabase;
    }

    const JET_TABLEID
    GetJetTableID() const {
        return m_JetTableId;
    }

    const JET_SESID
    GetJetSessionID() const {
        return m_JetDatabase.GetJetSessionID();
    }

    const JET_DBID
    GetJetDatabaseID() const {
        return m_JetDatabase.GetJetDatabaseID();
    }

    LPCTSTR
    GetTableName() const {
        return m_szTableName;
    }

    JBTable*
    DuplicateCursor(
        JET_GRBIT grbit=0
    );

    JBTable&
    operator=(const JBTable& srcTable);

    BOOL
    CloseTable();

    BOOL
    CreateOpenTable(
        LPCTSTR pszTableName,
        unsigned long lPage=0,
        unsigned long lDensity=20
    );


    BOOL
    OpenTable(
        LPCTSTR pszTableName,
        void* pvParam=NULL,
        unsigned long cbParam=0,
        JET_GRBIT grbit=0
    );


    BOOL
    AddIndex(
        JBKeyBase* key
    );

    int
    AddIndex(
        int numIndex,
        PTLSJBIndex pIndex
    );

    BOOL
    DoesIndexExist(
        LPCTSTR pszIndexName
        );

    int
    AddColumn(
        int numColumns,
        PTLSJBColumn pColumnDef
    );

    BOOL
    AddJetIndex(
        LPCTSTR pszIndexName,
        LPCTSTR pszKey,
        unsigned long cbKey,
        JET_GRBIT jetGrbit,
        unsigned long lDensity=20
    );

    // ----------------------------------------------
    // Transaction
    // ----------------------------------------------
    BOOL
    BeginTransaction() {
        return m_JetDatabase.BeginTransaction();
    }

    BOOL
    CommitTransaction(JET_GRBIT grbit=0) {
        return m_JetDatabase.CommitTransaction(grbit);
    }

    BOOL
    RollbackTransaction(JET_GRBIT grbit=JET_bitRollbackAll) {
        return m_JetDatabase.RollbackTransaction(grbit);
    }

    int
    GetTransactionLevel() const {
        return m_JetDatabase.GetTransactionLevel();
    }

    JBColumn*
    FindColumnByName(LPCTSTR pszColumnName);

    JBColumn*
    FindColumnByIndex(const int index);

    JBColumn*
    FindColumnByColumnId(const JET_COLUMNID);

#if 1
    JBColumn&
    operator[](LPCTSTR pszColumnName) {
        JBColumn* jb = FindColumnByName(pszColumnName);
        return (jb) ? *jb : m_ErrColumn;
    }

    JBColumn&
    operator[](const int index) {
        JBColumn* jb = FindColumnByIndex(index);
        return (jb) ? *jb : m_ErrColumn;
    }

    JBColumn&
    operator[](const JET_COLUMNID jetid) {
        JBColumn* jb = FindColumnByColumnId(jetid);
        return (jb) ? *jb : m_ErrColumn;
    }

#else

    JBColumn*
    operator[](LPCTSTR pszColumnName) {
        return FindColumn(pszColumnName);
    }

    JBColumn*
    operator[](const int index) {
        return FindColumn(index);
    }

    JBColumn*
    operator[](const JET_COLUMNID jetid) {
        return FindColumn(jetid);
    }

#endif

    JET_COLUMNID
    GetJetColumnID(LPCTSTR pszColumnName);

    int
    GetJetColumnIndex(LPCTSTR pszColumnName);

    BOOL
    ReadLock();

    BOOL
    WriteLock();

    BOOL
    BeginUpdate(BOOL bUpdate = FALSE);

    BOOL
    EndUpdate(
        BOOL bDiscard = FALSE
    );

    BOOL
    SeekToKey(
        JBKeyBase* key,
        DWORD dwSearchType,
        JET_GRBIT jet_seek_grbit=JET_bitSeekGE
    );

    BOOL
    RetrieveKey(
        PVOID pbData,
        unsigned long cbData,
        unsigned long* pcbActual=NULL,
        JET_GRBIT grbit=0
    );

    //
    //  Enumeration
    //
    BOOL
    EnumBegin(
        LPCTSTR pszIndexName=NULL,      // enumeration thru primary index
        JET_GRBIT grbit=JET_bitMoveFirst
    );

    BOOL
    MoveToRecord(
        long crow=JET_MoveNext,
        JET_GRBIT grbit=0
    );

    BOOL
    EnumBegin(
        JBKeyBase* key,
        DWORD dwParam=0
    );

    ENUM_RETCODE
    EnumNext(
        JET_GRBIT crow=JET_MoveNext,
        JET_GRBIT grbit=0 //JET_bitMoveKeyNE  // limit our traveral to index
    );

    void
    EnumEnd()
    {
        m_InEnumeration = FALSE;
    }

    //-----------------------------------------------------------
    BOOL
    SetCurrentIndex(
        LPCTSTR pszIndexName,
        JET_GRBIT grbit = JET_bitMoveFirst
    );

    //-----------------------------------------------------------

    BOOL
    GetCurrentIndex(
        LPTSTR pszIndexName,
        unsigned long* bufferSize
    );

    BOOL
    EndOfRecordSet() {
        return m_JetErr == JET_errNoCurrentRecord;
    }

    unsigned long
    GetIndexRecordCount(
        unsigned long max=0xFFFFFFFF
    );

    BOOL
    MakeKey(
        PVOID pbData,
        unsigned long cbData,
        JET_GRBIT grbit=JET_bitNewKey
    );

    BOOL
    SeekValue(JET_GRBIT grbit=JET_bitSeekEQ);

    BOOL
    SeekValueEx(
        PVOID pbData,
        unsigned long cbData,
        JET_GRBIT keyGrbit,
        JET_GRBIT seekGrbit
        )
    /*

        Only work for single component key

    */
    {
        if(MakeKey(pbData, cbData, keyGrbit) == FALSE)
            return FALSE;

        return SeekValue(seekGrbit);
    }

    BOOL
    DeleteRecord();

    BOOL
    GetBookmark(
        PVOID pbBookmark,
        PDWORD pcbBookmark
    );

    BOOL
    GotoBookmark(
        PVOID pbBookmark,
        DWORD cbBookmark
    );

    //CCriticalSection&
    //GetSessionLock() {
    //    return m_JetDatabase.GetSessionLock();
    //}
};

//------------------------------------------------------------------------

struct JBColumnBufferBase {
    virtual PVOID
    GetInputBuffer() = 0;

    virtual PVOID
    GetOutputBuffer() = 0;

    virtual DWORD
    GetInputBufferLength() = 0;

    virtual DWORD
    GetOutputBufferLength() = 0;
};

//------------------------------------------------------------------------

class JBColumn : public JBError {
    friend class JBTable;

private:

    JBTable*        m_pJetTable;

    TCHAR           m_szColumnName[MAX_JETBLUE_NAME_LENGTH+1];

    JET_COLUMNID    m_JetColId;
    JET_COLTYP      m_JetColType;
    unsigned long   m_JetMaxColLength;
    JET_GRBIT       m_JetGrbit;

    PVOID           m_pbDefValue;
    int             m_cbDefValue;

    unsigned long   m_JetColCodePage;
    unsigned long   m_JetColCountryCode;
    unsigned long   m_JetColLangId;
    unsigned long   m_cbActual;

    JET_RETINFO     m_JetRetInfo;
    BOOL            m_JetNullColumn;

    //-------------------------------------------------------------

    void Cleanup();

    BOOL
    LoadJetColumnInfoFromJet(
        const JET_COLUMNLIST* column
    );

    JET_ERR
    RetrieveColumnValue(
        JET_SESID sesid,
        JET_TABLEID tableid,
        JET_COLUMNID columnid,
        PVOID pbBuffer,
        unsigned long cbBuffer,
        unsigned long offset=0
    );

    void
    AttachToTable( JBTable* pJetTable ) {
        m_pJetTable = pJetTable;
        return;
    }

public:

    JBColumn(JBTable* pJetTable=NULL);
    ~JBColumn() {}

    const unsigned long
    GetMaxColumnLength() const {
        return m_JetMaxColLength;
    }

    BOOL
    IsValid() const;

    const JET_COLTYP
    GetJetColumnType() const {
        return m_JetColType;
    }

    const JET_COLUMNID
    GetJetColumnID() const {
        return m_JetColId;
    }

    const JET_SESID
    GetJetSessionID() const {
        return (m_pJetTable) ? m_pJetTable->GetJetSessionID() : JET_sesidNil;
    }

    const JET_TABLEID
    GetJetTableID() const {
        return (m_pJetTable) ? m_pJetTable->GetJetTableID() : JET_tableidNil;
    }

    LPCTSTR
    GetJetColumnName() const {
        return (IsValid()) ? m_szColumnName : NULL;
    }

    const JBTable*
    GetJetTable() const {
        return m_pJetTable;
    }

    //
    // TODO - append to long binary column
    //
    BOOL
    InsertColumn(
        PVOID pbData,
        unsigned long cbData,
        unsigned long starting_offset=0
    );

    BOOL
    FetchColumn(
        PVOID pbData,
        unsigned long cbData,
        unsigned long starting_offset=0     // for future enhancement
    );

    void
    SetRetrieveOffset( unsigned long offset ) {
        m_JetRetInfo.ibLongValue = offset;
    }

    JBTable*
    GetWorkingTable() {
        return m_pJetTable;
    }

    unsigned long
    GetDataSize() {
        return m_cbActual;
    }

    //-----------------------------------------------

    BOOL
    FetchColumn(
        JBColumnBufferBase* pBuffer,
        DWORD offset=0
        )
    /*
    */
    {
        return FetchColumn(
                    pBuffer->GetInputBuffer(),
                    pBuffer->GetInputBufferLength(),
                    offset
                );
    }

    BOOL
    InsertColumn(
        JBColumnBufferBase* pBuffer,
        DWORD offset=0
        )
    /*
    */
    {
        return FetchColumn(
                    pBuffer->GetOutputBuffer(),
                    pBuffer->GetOutputBufferLength(),
                    offset
                );
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\legacy\inc\lsclient.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __LSCLIENT_H__
#define __LSCLIENT_H__

#include <windows.h>
#include "tlsdef.h"
#include "hydrals.h"

typedef BOOL (* LSENUMERATECALLBACK)(RPC_BINDING_HANDLE hBinding, HANDLE dwUserData);

#ifdef __cplusplus
extern "C" {
#endif

    HRESULT 
    EnumerateLsServer(LPCTSTR szDomain, LPCTSTR szScope, DWORD dwPlatformType, LSENUMERATECALLBACK fCallBack, HANDLE dwUserData, DWORD dwTimeOut);
     
    PCONTEXT_HANDLE
    ConnectToAnyLsServer(LPCTSTR szScope, DWORD dwPlatformType);

    PCONTEXT_HANDLE
    ConnectToLsServer( LPTSTR szLsServer );

    void
    DisconnectFromServer( PCONTEXT_HANDLE pContext );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\jetblue\jbdef.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __JBDEF_H__
#define __JBDEF_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <esent.h>
#include "tlsdef.h"
#include "tlsassrt.h"

#ifdef JB_ASSERT
#undef JB_ASSERT
#endif

#pragma warning(disable: 4018)
#pragma warning(disable: 4512)

#define JB_ASSERT TLSASSERT
#define MAX_JB_ERRSTRING    512

//
// 
// 
#define INDEXNAME               _TEXT("idx")
#define SEPERATOR               _TEXT("_")
#define JBSTRING_NULL           _TEXT("")
#define JETBLUE_NULL            _TEXT("")

#define INDEX_SORT_ASCENDING    _TEXT("+")
#define INDEX_SORT_DESCENDING   _TEXT("-")
#define INDEX_END_COLNAME       _TEXT("\0")

#define JB_COLTYPE_TEXT         JET_coltypLongBinary
//#define JB_COLTYPE_TEXT         JET_coltypLongText
//------------------------------------------------------------------
//
// JetBlue does not support UNICODE string
//
//------------------------------------------------------------------
#undef JET_BLUE_SUPPORT_UNICODE


#ifdef JET_BLUE_SUPPORT_UNICODE

    typedef LPTSTR JB_STRING;

#else

    typedef LPSTR JB_STRING;

#endif

//----------------------------------------------------------------

#ifndef AllocateMemory

    #define AllocateMemory(size) \
        LocalAlloc(LPTR, size)

#endif

#ifndef FreeMemory

    #define FreeMemory(ptr) \
        if(ptr)             \
        {                   \
            LocalFree(ptr); \
            ptr=NULL;       \
        }

#endif

#ifndef ReallocateMemory

    #define ReallocateMemory(ptr, size)                 \
                LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

//
// Private member function
//
#define CLASS_PRIVATE


//
// No define for NIL instance ID
// 
#define JET_NIL_INSTANCE        JET_sesidNil


//
// No define for NIL column id
// 
#define JET_NIL_COLUMN        JET_sesidNil

//
// No define for max table name length,
// user2.doc says 64 ASCII
//
#define MAX_TABLENAME_LENGTH    32

//
// Jet Blue text only 255 BYTES
//
#define MAX_JETBLUE_TEXT_LENGTH LSERVER_MAX_STRING_SIZE


//
// Jet Blue Index, Column, ... name length
//
#define MAX_JETBLUE_NAME_LENGTH 64


//
// Jet Blue column code page must be 1200 or 1250
//
#define TLS_JETBLUE_COLUMN_CODE_PAGE 1252


//
// Jet Blue Text column language ID
//
#define TLS_JETBLUE_COLUMN_LANGID   0x409

//
// Jet Blue Column Country Code
//
#define TLS_JETBLUE_COLUMN_COUNTRY_CODE 1


//
// Max Jet Blue index key length - 127 fix columns
//
#define TLS_JETBLUE_MAX_INDEXKEY_LENGTH \
    (127 + 1) * MAX_JETBLUE_NAME_LENGTH


//
// Max. Jet Blue key length documented is 255 in user2.doc
//


//
// Default table density
//
#define TLS_JETBLUE_DEFAULT_TABLE_DENSITY   20


//
// JetBlue max key size - user2.doc
//
#define TLS_JETBLUE_MAX_KEY_LENGTH          255

//
//
#define TLS_TABLE_INDEX_DEFAULT_DENSITY  20

///////////////////////////////////////////////////////////////
//
// Various structure
//
///////////////////////////////////////////////////////////////
typedef struct __TLSJBTable {
    LPCTSTR         pszTemplateTableName;
    unsigned long   ulPages;
    unsigned long   ulDensity;
    JET_GRBIT       jbGrbit;
} TLSJBTable, *PTLSJBTable;

typedef struct __TLSJBColumn {
    TCHAR           pszColumnName[MAX_JETBLUE_NAME_LENGTH];

    JET_COLTYP      colType;
    unsigned long   cbMaxLength;    // max length of column

    JET_GRBIT       jbGrbit;

    PVOID           pbDefValue;     // column default value
    int             cbDefValue;

    unsigned short  colCodePage;
    unsigned short  wCountry;
    unsigned short  langid;
} TLSJBColumn, *PTLSJBColumn;    

typedef struct __TLSJBIndex {
    TCHAR           pszIndexName[MAX_JETBLUE_NAME_LENGTH];
    LPTSTR          pszIndexKey;
    unsigned long   cbKey;          // length of key
    JET_GRBIT       jbGrbit;
    unsigned long   ulDensity;
} TLSJBIndex, *PTLSJBIndex;



#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    ConvertJBstrToWstr(
        JB_STRING   in,
        LPTSTR*     out
    );

    BOOL 
    ConvertWstrToJBstr(
        LPCTSTR in, 
        JB_STRING* out
    );

    void
    FreeJBstr( 
        JB_STRING pstr 
    );
   
    BOOL
    ConvertMWstrToMJBstr(
        LPCTSTR in, 
        DWORD length,
        JB_STRING* out
    );

    BOOL
    ConvertMJBstrToMWstr(
        JB_STRING in,
        DWORD length,
        LPTSTR* out
    );

#ifdef __cplusplus
}
#endif

///////////////////////////////////////////////////////////////
//
// Various template class
//
///////////////////////////////////////////////////////////////
template <class Type, int size> struct FixArray;
template <class Type> struct Array;

typedef FixArray<TCHAR, MAX_JETBLUE_TEXT_LENGTH> JetBlueText;
typedef FixArray<char, MAX_JETBLUE_TEXT_LENGTH> JetBlueBinary;

typedef Array<TCHAR> JetBlueLongText;
typedef Array<char> JetBlueLongBinary;

// ----------------------------------------------------------
//
// Variable length array template
// Another choice is use vector<> in STL.
//
// ----------------------------------------------------------
template<class Type>
struct Array {
public:

    Type*   m_Data;
    int     m_Size;

private:
    BOOL    m_UseExistingBuffer;    // m_Data point to user 
                                    // buffer

    BOOL
    init(const Type* v, int size) {
        if(m_UseExistingBuffer == FALSE)
        {
            if(size > m_Size)
            {
                FreeBuffer();

                m_Data = new Type[m_Size = size];
                if(m_Data == NULL)
                    return FALSE;
            }
        }

        for(int i=0; i < min(size, m_Size); i++)
            m_Data[i] = v[i];

        return TRUE;
    }

    void 
    FreeBuffer() {
        if(m_Data && m_UseExistingBuffer == FALSE)
            delete [] m_Data;

        m_UseExistingBuffer = FALSE;
        m_Data = NULL;
        m_Size = 0;
    }

public:

    Array() : m_Data(NULL), m_Size(0), m_UseExistingBuffer(FALSE) {}
    Array(int size) {
        m_Data = new Type[m_Size = size];
        JB_ASSERT(m_Data != NULL);
    }

    Array(const Type* v, int count) {
        init(v, size);
    }

    ~Array() { 
        FreeBuffer();
    }
        
    Array(const Array<Type>& v) {
        init(v.m_Data, v.size);
    }

    void
    UseBuffer( Type* v, int size ) {
        FreeBuffer();

        m_Data = v;
        m_Size = size;
        m_UseExistingBuffer = TRUE;
    }

    Array& 
    operator=(const Array& v) {
        if(this == &v)
            return *this;

        init(v.GetBufferPtr(), v.GetArrayCount());
        return *this;
    }

    Array&
    operator+=(const Array& v) {
        int m_OldSize = m_Size;

        JB_ASSERT(Expand(v.GetArrayCount()));
        
        for(int i=m_OldSize; i< m_Size; i++)
        {
            m_Data[i] = v[i-m_OldSize];
        }

        return *this;
    }
        
    Type&
    operator[](int index) {
        JB_ASSERT(index < m_Size && m_Data != NULL);
        return m_Data[index];
    }
   
    operator Type*() const {
        return m_Data;
    }

    operator PVOID() const {
        return (PVOID) m_Data;
    }

    BOOL
    Expand(int size) {
        Type* ptr;

        ptr = new Type[m_Size+size];

        for(int i=0; i < m_Size; i++)
            ptr[i] = m_Data[i];

        delete [] m_Data;
        m_Data = ptr;
        m_Size += size;

        return TRUE;
    }

    PVOID
    GetBufferPtr() {
        return (PVOID) m_Data;
    }

    int
    GetBufferSize() { 
        return m_Size * sizeof(m_Data[0]); 
    }

    int
    GetArrayCount() {
        return m_Size;
    }

    virtual Type*
    operator=(const Type* v) {
        JB_ASSERT(FALSE);
        return *this;
    };

    virtual Type*
    operator+=(const Type* v) {
        JB_ASSERT(FALSE);
        return *this;
    };
};

inline TCHAR*
Array<TCHAR>::operator=(const TCHAR* src) {
    init(src, _tcslen(src)+1);

    return m_Data;
}

inline TCHAR*
Array<TCHAR>::operator+=(const TCHAR* src) {
    Expand(_tcslen(src)+1);

    _tcscat(m_Data, src);

    return m_Data;
}

/////////////////////////////////////////////////////////////////////////
//
// Fix Array template class
//
// Not much benefit from deriving from Array template
/////////////////////////////////////////////////////////////////////////
       
template< class Type, int size >
struct FixArray : public Array<Type> {
    //
    // Currently only for STRING, use STL vector for
    // for general use.
    //
    Type m_Data[size+1];        // one more for string

    FixArray() : Array<Type>() {
        memset(m_Data, 0, sizeof(m_Data));
        Array<Type>::UseBuffer(m_Data, size);
    } 

    FixArray(const Type* v) : Array<Type>() {
        Array<Type>::UseBuffer(m_Data, size);
        *this = v;
    }

    FixArray(const Type* v, int length) : Array<Type>() {
        Array<Type>::UseBuffer(m_Data, size);
        Array<Type>::Array<Type>(m_Data, length);
    }

    FixArray<Type, size>&
    operator=(const FixArray<Type, size>& v) {
        if(this == &v)
            return *this;

        *this = (Type *)v;
        return *this;
    }

    virtual Type*
    operator+=(const Type* v) {
        JB_ASSERT(FALSE);
        return m_Data;
    };

    virtual Type*
    operator=(const Type* v) { 
        JB_ASSERT(FALSE);
        return m_Data;
    }
};

//-----------------------------------------------------------------

inline TCHAR* 
JetBlueText::operator=(
    const TCHAR* v
    )
/*
*/
{
    int numCharsToCopy = min(_tcslen(v), size);
 
    _tcsncpy(
            m_Data, 
            v, 
            numCharsToCopy
    );

    m_Data[numCharsToCopy] = _TEXT('\0');
    return m_Data;
}

inline TCHAR* 
JetBlueText::operator+=(
    const TCHAR* v
    )
/*
*/
{
    int length=_tcslen(m_Data);

    _tcsncpy(
            m_Data+length, 
            v, 
            min(_tcslen(v), size-length)
    );

    return m_Data;
}


//
/////////////////////////////////////////////////////////////////////
//
class JBError {
public:

    JET_ERR m_JetErr;

    JBError() : m_JetErr(JET_errSuccess) {}

    JBError(const JET_ERR jet_error) : m_JetErr(jet_error) {}

    const JET_ERR 
    GetLastJetError() const { 
        return m_JetErr; 
    }

    void
    SetLastJetError(JET_ERR jetError = JET_errSuccess) { 
        m_JetErr = jetError; 
    }

    BOOL 
    IsSuccess() const {
        return m_JetErr >= JET_errSuccess;
    }

    BOOL
    GetJBErrString(
        const JET_ERR jbErr,
        LPTSTR* pszErrString
    )
    /*++

    --*/
    {
        BOOL bStatus=FALSE;
        JET_ERR err;
        CHAR szAnsiBuffer[MAX_JB_ERRSTRING+1];
    
        if(pszErrString == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return bStatus;
        }

        memset(szAnsiBuffer, 0, sizeof(szAnsiBuffer));
        err = JetGetSystemParameter(
                            JET_instanceNil,
                            JET_sesidNil,
                            JET_paramErrorToString,
                            (ULONG_PTR *) &jbErr,
                            szAnsiBuffer,
                            MAX_JB_ERRSTRING
                        );
        
        if(err == JET_errBufferTooSmall || err == JET_errSuccess)
        {
            // return partial error string.
            if(ConvertJBstrToWstr(szAnsiBuffer, pszErrString))
            {
                bStatus = TRUE;
            }
        }

        return bStatus;
    }
                
    void
    DebugOutput(
        LPTSTR format, ...
        ) const 
    /*++
    ++*/
    {
        va_list marker;
        va_start(marker, format);

#ifdef DEBUG_JETBLUE
        TCHAR  buf[8096];
        DWORD  dump;

        __try {
            memset(buf, 0, sizeof(buf));

            _vsntprintf(
                    buf, 
                    sizeof(buf)/sizeof(buf[0]), 
                    format, 
                    marker
                );

            _tprintf(_TEXT("%s"), buf);

            // OutputDebugString(buf);
       }
       __except(EXCEPTION_EXECUTE_HANDLER) {
       }
#endif

        va_end(marker);
    }
};

//------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\legacy\marshal\marshal.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <stddef.h>
#include "hydrals.h"
#include "license.h"

void __RPC_USER 
LICENSE_REQUEST_TYPE_to_xmit( LICENSE_REQUEST_TYPE __RPC_FAR * pRequest,
                              LICENSE_REQUEST_XMIT_TYPE  __RPC_FAR * __RPC_FAR * pRequestXmit)
{
    DWORD size;

    size = sizeof(LICENSE_REQUEST_XMIT_TYPE) + 
                pRequest->pProductInfo->cbCompanyName + 
                pRequest->pProductInfo->cbProductID +
                pRequest->cbEncryptedHwid;

    *pRequestXmit = (LICENSE_REQUEST_XMIT_TYPE *)midl_user_allocate(size);

    // copy request structure
    (*pRequestXmit)->dwLangId = pRequest->dwLanguageID;
    (*pRequestXmit)->dwPlatformId = pRequest->dwPlatformID;
    (*pRequestXmit)->cbEncryptedHwid = pRequest->cbEncryptedHwid;

    // copy product requested
    (*pRequestXmit)->dwVersion = pRequest->pProductInfo->dwVersion;
    (*pRequestXmit)->cbCompanyName = pRequest->pProductInfo->cbCompanyName;
    (*pRequestXmit)->cbProductId = pRequest->pProductInfo->cbProductID;

     memcpy( &((*pRequestXmit)->pbData[0]),
            pRequest->pProductInfo->pbCompanyName, 
            pRequest->pProductInfo->cbCompanyName);

    memcpy( &((*pRequestXmit)->pbData[0]) + pRequest->pProductInfo->cbCompanyName, 
            pRequest->pProductInfo->pbProductID, 
            pRequest->pProductInfo->cbProductID);

    if(pRequest->cbEncryptedHwid)
    {
        memcpy( &((*pRequestXmit)->pbData[0]) + pRequest->pProductInfo->cbCompanyName + pRequest->pProductInfo->cbProductID, 
                pRequest->pbEncryptedHwid, 
                pRequest->cbEncryptedHwid);
    }
}


void __RPC_USER 
LICENSE_REQUEST_TYPE_from_xmit( LICENSE_REQUEST_XMIT_TYPE  __RPC_FAR *pRequestXmit, 
                                LICENSE_REQUEST_TYPE __RPC_FAR * pRequest)
{
    pRequest->cbEncryptedHwid = pRequestXmit->cbEncryptedHwid;
    pRequest->dwLanguageID = pRequestXmit->dwLangId;
    pRequest->dwPlatformID = pRequestXmit->dwPlatformId;
    pRequest->pProductInfo = (PProduct_Info)midl_user_allocate(sizeof(Product_Info));

    pRequest->pProductInfo->dwVersion = pRequestXmit->dwVersion;
    pRequest->pProductInfo->cbCompanyName = pRequestXmit->cbCompanyName;
    pRequest->pProductInfo->cbProductID = pRequestXmit->cbProductId;

    pRequest->pProductInfo->pbCompanyName = (PBYTE)midl_user_allocate(pRequestXmit->cbCompanyName+sizeof(CHAR));
    memcpy(pRequest->pProductInfo->pbCompanyName, &(pRequestXmit->pbData[0]), pRequestXmit->cbCompanyName);

    pRequest->pProductInfo->pbProductID = (PBYTE)midl_user_allocate(pRequestXmit->cbProductId+sizeof(CHAR));
    memcpy(pRequest->pProductInfo->pbProductID, 
           &(pRequestXmit->pbData[0]) + pRequest->pProductInfo->cbCompanyName, 
           pRequestXmit->cbProductId);

    if(pRequestXmit->cbEncryptedHwid)
    {
        pRequest->pbEncryptedHwid = (PBYTE)midl_user_allocate(pRequestXmit->cbEncryptedHwid);
        memcpy(pRequest->pbEncryptedHwid, 
               &(pRequestXmit->pbData[0]) + pRequest->pProductInfo->cbCompanyName + pRequest->pProductInfo->cbProductID,
               pRequestXmit->cbEncryptedHwid);
    }
    else
    {
        pRequest->pbEncryptedHwid = NULL;
    }
}

void __RPC_USER 
LICENSE_REQUEST_TYPE_free_xmit(LICENSE_REQUEST_XMIT_TYPE  __RPC_FAR *ptr)
{
    midl_user_free(ptr);
}

void __RPC_USER 
LICENSE_REQUEST_TYPE_free_inst( LICENSE_REQUEST_TYPE __RPC_FAR *pRequest )
{
    if(pRequest->pProductInfo)
    {
        if(pRequest->pbEncryptedHwid)
            midl_user_free(pRequest->pbEncryptedHwid);

        if(pRequest->pProductInfo->pbProductID)
            midl_user_free(pRequest->pProductInfo->pbProductID);

        if(pRequest->pProductInfo->pbCompanyName)
            midl_user_free(pRequest->pProductInfo->pbCompanyName);

        midl_user_free(pRequest->pProductInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\clilic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        clilic.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __CLIENTLICNESE_H__
#define __CLIENTLICNESE_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

void 
TLSDBLockLicenseTable();

void 
TLSDBUnlockLicenseTable();

DWORD
TLSDBLicenseFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAllParm,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT lpSearch,
    IN OUT LPLICENSEDCLIENT lpFound
);

DWORD
TLSDBLicenseEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch
);

DWORD
TLSDBLicenseEnumBeginEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch,
    IN JET_GRBIT jet_seek_grbit
);

DWORD
TLSDBLicenseEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT LPLICENSEDCLIENT lplsLicense
);

DWORD
TLSDBLicenseEnumNextEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bReverse,
    IN BOOL bAnyRecord,
    IN OUT LPLICENSEDCLIENT lplsLicense
);

void
TLSDBLicenseEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
);


DWORD
TLSDBLicenseAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense
);

DWORD
TLSDBLicenseDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bInternalCall
);

DWORD
TLSDBDeleteEnumeratedLicense(
    IN PTLSDbWorkSpace pDbWkSpace
);

DWORD
TLSDBLicenseUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bInternalCall
);

DWORD
TLSDBLicenseSetValue( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwSetParm,
    IN LPLICENSEDCLIENT lpLicense,
    IN BOOL bPointerOnRecord
);

DWORD
TLSDBLicenseGetCert( 
    IN PTLSDbWorkSpace pDbWorkSpace,
    IN DWORD dwLicenseId, 
    IN OUT PDWORD cbCert, 
    IN OUT PBYTE pbCert 
);

DWORD
TLSDBLicenseAdd(
    IN PTLSDbWorkSpace pDbWorkSpace,
    LPLICENSEDCLIENT pLicense, 
    DWORD cbLicense, 
    PBYTE pbLicense
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\clrhouse.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        clrhouse.h
//
// Contents:    
//              All Clearing house related function
//
// History:     
// 
// Note:        
//---------------------------------------------------------------------------
#ifndef __LICENSE_SERVER_CLEARING_HOUSE_H__
#define __LICENSE_SERVER_CLEARING_HOUSE_H__

//-----------------------------------------------------------------------------
//
// Registry key for storing various certificates
//
#define LSERVER_CERTIFICATE_STORE_BASE              LSERVER_SERVER_CERTIFICATE_REGKEY

//-----------------------------------------------------------------------------
// Actual License Server Certificate
//
#define LSERVER_CERTIFICATE_STORE_SIGNATURE         "Signature"
#define LSERVER_CERTIFICATE_STORE_EXCHANGE          "Exchange"

//-----------------------------------------------------------------------------
// License Server Certificate Chain 
//
#define LSERVER_CERTIFICATE_CHAIN_SIGNATURE         "SignatureChain"
#define LSERVER_CERTIFICATE_CHAIN_EXCHANGE          "ExchangeChain"


#define LSERVER_CERTIFICATE_STORE_CA                "CA"
#define LSERVER_CERTIFICATE_STORE_RA                "RA"
#define LSERVER_CERTIFICATE_STORE_CH                "CH"
#define LSERVER_CERTIFICATE_STORE_ROOT              "ROOT"

//------------------------------------------------------------------------------
//
// Registry key for CA certificate
// 
#define LSERVER_CERTIFICATE_REG_CA_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CA)

#define LSERVER_CERTIFICATE_REG_CA_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CA)


//------------------------------------------------------------------------------
//
// Registry key for RA certificate
// 
#define LSERVER_CERTIFICATE_REG_MF_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_RA)

#define LSERVER_CERTIFICATE_REG_MF_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_RA)


//------------------------------------------------------------------------------
//
// Registry key for CH certificate
//
#define LSERVER_CERTIFICATE_REG_CH_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CH)

#define LSERVER_CERTIFICATE_REG_CH_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_CH)

//------------------------------------------------------------------------------
//
// Registry key for ROOT certificate
//
#define LSERVER_CERTIFICATE_REG_ROOT_SIGNATURE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_SIGNATURE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_ROOT)

#define LSERVER_CERTIFICATE_REG_ROOT_EXCHANGE \
    LSERVER_CERTIFICATE_STORE_BASE _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_EXCHANGE) _TEXT("\\") _TEXT(LSERVER_CERTIFICATE_STORE_ROOT)


#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    TLSChainIssuerCertificate( 
        HCRYPTPROV hCryptProv, 
        HCERTSTORE hChainFromStore, 
        HCERTSTORE hChainToStore, 
        PCCERT_CONTEXT pSubjectContext 
    );

    HCERTSTORE
    CertOpenRegistryStore(
        HKEY hKeyType, 
        LPCTSTR szSubKey, 
        HCRYPTPROV hCryptProv, 
        HKEY* phKey
    );
    
    DWORD 
    TLSSaveCertAsPKCS7(
        PBYTE pbCert, 
        DWORD cbCert, 
        PBYTE* ppbEncodedCert, 
        PDWORD pcbEncodedCert
    );

    DWORD
    IsCertificateLicenseServerCertificate(
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwCertType,
        IN DWORD cbPKCS7Cert, 
        IN PBYTE pbPKCS7Cert,
        IN OUT DWORD* cbLsCert,
        IN OUT PBYTE* pbLsCert
    );

    DWORD
    TLSSaveRootCertificateToReg(
        HCRYPTPROV hCryptProv, 
        HKEY hKey, 
        DWORD cbEncodedCert, 
        PBYTE pbEncodedCert
    );

    DWORD
    TLSSaveCertificateToReg(
        HCRYPTPROV hCryptProv, 
        HKEY hKey, 
        DWORD cbPKCS7Cert, 
        PBYTE pbPKCS7Cert
    );

    DWORD 
    TLSSaveRootCertificatesToStore(  
        IN HCRYPTPROV    hCryptProv,
        IN DWORD         cbSignatureCert, 
        IN PBYTE         pbSignatureCert, 
        IN DWORD         cbExchangeCert, 
        IN PBYTE         pbExchangeCert
    );

    DWORD
    TLSSaveCertificatesToStore(
        IN HCRYPTPROV    hCryptProv,
        IN DWORD         dwCertType,
        IN DWORD         dwCertLevel,
        IN DWORD         cbSignatureCert, 
        IN PBYTE         pbSignatureCert, 
        IN DWORD         cbExchangeCert, 
        IN PBYTE         pbExchangeCert
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\legacy\lsclient\lsclient.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        lsclient.cpp
//
// Contents:    Client's RPC binding routine and Hydra License Server Lookup 
//              routine.
//
// History:     01-09-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include "lsclient.h"
#include "lscommon.h"

//+------------------------------------------------------------------------
// Function:   ConnectToLsServer()
//
// Description:
//
//      Binding to sepecific hydra license server
//
// Arguments:
//
//      szLsServer - Hydra License Server name
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      error.
//-------------------------------------------------------------------------
PCONTEXT_HANDLE 
ConnectLsServer( LPTSTR szLsServer, LPTSTR szProtocol, LPTSTR szEndPoint, DWORD dwAuthLevel )
{
    LPTSTR  szBindingString;
    RPC_BINDING_HANDLE hBinding=NULL;
    RPC_STATUS status;
    PCONTEXT_HANDLE pContext=NULL;

    status = RpcStringBindingCompose(0,
                                     szProtocol,
                                     szLsServer,
                                     szEndPoint,
                                     0,
                                     &szBindingString);

    if(status!=RPC_S_OK)
        return NULL;

    status=RpcBindingFromStringBinding( szBindingString, &hBinding);
    RpcStringFree( &szBindingString );
    if(status != RPC_S_OK)
        return NULL;

    status=RpcBindingSetAuthInfo(hBinding,
                                 0,
                                 dwAuthLevel,
                                 RPC_C_AUTHN_WINNT,
                                 0,
                                 0);
    if(status == RPC_S_OK)
    {
        // Obtain context handle from server
        status = LSConnect( hBinding, &pContext );
    }

    SetLastError((status == RPC_S_OK) ? ERROR_SUCCESS : status);
    return pContext;
}
//-------------------------------------------------------------------------
PCONTEXT_HANDLE 
ConnectToLsServer( LPTSTR szLsServer )
{
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1] ;
    PCONTEXT_HANDLE pContext=NULL;
    DWORD cbMachineName=MAX_COMPUTERNAME_LENGTH;

    GetComputerName(szMachineName, &cbMachineName);
    if(_tcsicmp(szMachineName, szLsServer) == 0)
    {
        pContext=ConnectLsServer(szLsServer, _TEXT(RPC_PROTOSEQLPC), NULL, RPC_C_AUTHN_LEVEL_DEFAULT);
        if(GetLastError() >= LSERVER_ERROR_BASE)
        {
            return NULL;
        }
        // try to connect with TCP protocol, if local procedure failed
    }

    if(pContext == NULL)
    {
        pContext=ConnectLsServer(szLsServer, _TEXT(RPC_PROTOSEQNP), _TEXT(LSNAMEPIPE), RPC_C_AUTHN_LEVEL_NONE);
    }

    return pContext;
}
//-------------------------------------------------------------------------
void
DisconnectFromServer( PCONTEXT_HANDLE pContext )
{
    LSDisconnect( &pContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\conlic.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        conlic.cpp
//
// Contents:    
//              all routine deal with cross table query
//
// History:     
//              Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "conlic.h"
#include "db.h"
#include "misc.h"
#include "keypack.h"
#include "clilic.h"
#include "globals.h"


//--------------------------------------------------------------------------
// Function:
//  DBQueryConcurrentLicenses()
// 
// Description:
//  Query number concurrent license issued to server
//
// Arguments:
//  See LSDBAllocateConcurrentLicense()
//
// Returns:
//  See LSDBAllocateConcurrentLicense()
//
//-------------------------------------------------------------------------
DWORD 
TLSDBQueryConcurrentLicenses(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPTSTR szHydra, 
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT long* dwQuantity 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if( pDbWkSpace == NULL || 
        pRequest == NULL || 
        pRequest == NULL ||
        dwQuantity == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    TLSLICENSEPACK keypack_search;
    TLSLICENSEPACK keypack_found;

    //keypack_search.ucAgreementType = LSKEYPACKTYPE_CONCURRENT;

    lstrcpyn(
            keypack_search.szCompanyName, 
            (LPCTSTR)pRequest->pszCompanyName,
            sizeof(keypack_search.szCompanyName) / sizeof(keypack_search.szCompanyName[0])
        );

    lstrcpyn(
            keypack_search.szProductId, 
            (LPTSTR)pRequest->pszProductId,
            sizeof(keypack_search.szProductId)/sizeof(keypack_search.szProductId[0])
        );


    keypack_search.wMajorVersion = HIWORD(pRequest->dwProductVersion);
    keypack_search.wMinorVersion = LOWORD(pRequest->dwProductVersion);
    keypack_search.dwPlatformType = pRequest->dwPlatformID;
    LICENSEDCLIENT license_search;
    LICENSEDCLIENT license_found;

    *dwQuantity = 0;


    //
    // Only allow one thread to enter - Jet not fast enough in updating entry
    //
    TLSDBLockKeyPackTable();

    dwStatus = TLSDBKeyPackEnumBegin(
                            pDbWkSpace, 
                            TRUE,
                            LSKEYPACK_SEARCH_PRODUCTID, //LICENSEDPACK_FIND_LICENSEPACK,
                            &keypack_search
                        );

    while(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                pDbWkSpace,
                                &keypack_found
                            );
        if(dwStatus != ERROR_SUCCESS)
            break;

        //
        // should be a big internal error since keypack type
        // is on our wish list.
        //
        //if(keypack_found.ucAgreementType != keypack_search.ucAgreementType)
        //    continue;

        if( keypack_found.wMajorVersion != keypack_search.wMajorVersion ||
            keypack_found.wMinorVersion != keypack_search.wMinorVersion )
        {
            continue;
        }
    
        if( _tcsicmp(keypack_found.szCompanyName, keypack_search.szCompanyName) != 0 )
        {
            continue;
        }

        if( _tcsicmp(keypack_found.szProductId, keypack_search.szProductId) != 0 )
        {
            continue;
        }


        //
        // Enumerate thru licensed table to sum up all license issued.
        //
        license_search.dwKeyPackId = keypack_found.dwKeyPackId;
        
        dwStatus = TLSDBLicenseEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LSLICENSE_SEARCH_KEYPACKID,
                                &license_search
                            );

        while(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSDBLicenseEnumNext(
                                    pDbWkSpace,
                                    &license_found
                                );

            if(dwStatus != ERROR_SUCCESS)
                break;

            if(szHydra && _tcsicmp(license_found.szMachineName, szHydra) == 0)
            {
                (*dwQuantity) += license_found.dwNumLicenses;
            }
        }

        TLSDBLicenseEnumEnd(pDbWkSpace);

        //
        // error in looping thru license table
        //
        if(dwStatus != TLS_I_NO_MORE_DATA)
            break;

        dwStatus = ERROR_SUCCESS;
    }
    
    TLSDBKeyPackEnumEnd(pDbWkSpace);

    TLSDBUnlockKeyPackTable();

    if(dwStatus == TLS_I_NO_MORE_DATA)
        dwStatus = ERROR_SUCCESS;

    return dwStatus;
}

//--------------------------------------------------------------------------
// Function:
//  DBReturnConcurrentLicenses()
// 
// Description:
//  return concurrent license from concurrent key pack
//
// Arguments:
//  See LSDBAllocateConcurrentLicense()
//
// Returns:
//  See LSDBAllocateConcurrentLicense()
//
//-------------------------------------------------------------------------
DWORD
TLSDBReturnConcurrentLicenses( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPTSTR szHydraServer,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT long* dwQuantity 
    )
{
    //
    // return concurrent license works differently from normal return
    // need to find the concurrent keypack then find the license issued
    // to particular hydra server 
    //
    DWORD dwStatus=ERROR_SUCCESS;

    if( pDbWkSpace == NULL || 
        pRequest == NULL || 
        pRequest == NULL ||
        dwQuantity == NULL ||
        szHydraServer == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    LICENSEDCLIENT license_search;
    LICENSEDCLIENT license_found;
    TLSLICENSEPACK keypack_search;
    TLSLICENSEPACK keypack_found;

    keypack_search.pbDomainSid = NULL;
    keypack_found.pbDomainSid = NULL;

    DWORD dwNumLicenseToBeReturned = abs(*dwQuantity);

    SAFESTRCPY(
            license_search.szMachineName,
            szHydraServer
        );

    TLSDBLockKeyPackTable();

    dwStatus = TLSDBLicenseEnumBegin(
                            pDbWkSpace,
                            TRUE,
                            LSLICENSE_SEARCH_MACHINENAME,
                            &license_search
                        );

    while(dwStatus == ERROR_SUCCESS && dwNumLicenseToBeReturned > 0)
    {
        // FreeTlsLicensePack(&keypack_found);

        dwStatus = TLSDBLicenseEnumNext(
                                pDbWkSpace,
                                &license_found
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        if(license_found.ucLicenseStatus != LSLICENSE_STATUS_CONCURRENT)
        {
            continue;
        }

        //
        // Look into keypack table to see if this keypack has same product info
        //
        keypack_search.dwKeyPackId = license_found.dwKeyPackId;

        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_EXSEARCH_DWINTERNAL,
                                &keypack_search,
                                &keypack_found
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            // TODO - log an error
            continue;
        }

        //if(keypack_found.ucAgreementType != LSKEYPACKTYPE_CONCURRENT)
        //{
            // TODO - log an error
        //    continue;
        //}

        if( keypack_found.wMajorVersion != HIWORD(pRequest->dwProductVersion) ||
            keypack_found.wMinorVersion != LOWORD(pRequest->dwProductVersion) )
        {
            continue;
        }

        if( _tcsicmp(
                    keypack_found.szCompanyName, 
                    (LPTSTR)pRequest->pszCompanyName) != 0)
        {
            continue;
        }

        if(_tcsicmp(
                    keypack_found.szProductId, 
                    (LPTSTR)pRequest->pszProductId) != 0)
        {
            continue;
        }
        
        // 
        // Return number of license back to keypack
        //

        //
        // NOTE - KeyPackFind() position the cursor on the record we need
        // to update
        keypack_found.dwNumberOfLicenses += license_found.dwNumLicenses;

        BOOL bSuccess;

        GetSystemTimeAsFileTime(&(keypack_found.ftLastModifyTime));
        bSuccess = pDbWkSpace->m_LicPackTable.UpdateRecord(
                                                keypack_found,
                                                LICENSEDPACK_ALLOCATE_LICENSE_UPDATE_FIELD
                                            );
        if(bSuccess == FALSE)
        {
            SetLastError(
                    dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackTable.GetLastJetError())
                );
        }
        else
        {

            // license table cursor is on the record we want to delete
            // need to delete this record
            bSuccess = pDbWkSpace->m_LicensedTable.DeleteRecord();
            if(bSuccess == FALSE)
            {
                SetLastError(
                        dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicensedTable.GetLastJetError())
                    );
            }
            else
            {
                dwNumLicenseToBeReturned -= license_found.dwNumLicenses;
            }
        }
    }

    TLSDBLicenseEnumEnd(pDbWkSpace);

    *dwQuantity = abs(*dwQuantity) - dwNumLicenseToBeReturned;

    TLSDBUnlockKeyPackTable();

    return dwStatus;          
}

//--------------------------------------------------------------------------
// Function:
//  DBAllocateConcurrentLicense()
// 
// Description:
//  Allocate concurrent license from concurrent key pack
//
// Arguments:
//  See LSDBAllocateConcurrentLicense()
//
// Returns:
//  See LSDBAllocateConcurrentLicense()
//
//-------------------------------------------------------------------------
DWORD
TLSDBGetConcurrentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPTSTR szHydraServer,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT long* plQuantity 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSearchedType = 0;
    DWORD dwSuggestType;
    DWORD dwPMAdjustedType = LSKEYPACKTYPE_UNKNOWN;
    DWORD dwLocakType = LSKEYPACKTYPE_UNKNOWN;

    if( pDbWkSpace == NULL || 
        pRequest == NULL || 
        pRequest == NULL ||
        plQuantity == NULL ||
        szHydraServer == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    LONG lNumLicenseWanted = *plQuantity;

    TLSDBLicenseAllocation allocated;
    TLSDBAllocateRequest AllocateRequest;

    TLSLICENSEPACK LicenseKeyPack[10];

    memset(LicenseKeyPack, 0, sizeof(LicenseKeyPack));

    DWORD allocation_vector[10];

    //AllocateRequest.ucAgreementType = LSKEYPACKTYPE_CONCURRENT;
    AllocateRequest.szCompanyName = (LPTSTR)pRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pRequest->pszProductId;
    AllocateRequest.dwVersion = pRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pRequest->dwPlatformID;
    AllocateRequest.dwLangId = pRequest->dwLanguageID;
    AllocateRequest.dwScheme = ALLOCATE_EXACT_VERSION;
    memset(&allocated, 0, sizeof(allocated));

    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    do {
        dwSuggestType = dwLocakType;
        dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                pRequest->hClient,
                                                REQUEST_KEYPACKTYPE,
                                                UlongToPtr (dwSuggestType),
                                                (PVOID *)&dwPMAdjustedType
                                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        dwLocakType = (dwPMAdjustedType & ~LSKEYPACK_RESERVED_TYPE);
        if(dwLocakType > LSKEYPACKTYPE_LAST)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );
            
            break;
        }

        if(dwSearchedType & (0x1 << dwLocakType))
        {
            //
            // we already went thru this license pack, policy module error
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    dwStatus = TLS_E_POLICYMODULERECURSIVE,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            break;
        }

        dwSearchedType |= (0x1 << dwLocakType);
        AllocateRequest.ucAgreementType = dwPMAdjustedType;

        while(lNumLicenseWanted > 0 && dwStatus == ERROR_SUCCESS)
        {
            AllocateRequest.dwNumLicenses = lNumLicenseWanted;

            for(int index=0; index < sizeof(LicenseKeyPack) / sizeof(LicenseKeyPack[0]); index++)
            {
                if(LicenseKeyPack[index].pbDomainSid != NULL)
                {   
                    // memory leak
                    LicenseKeyPack[index].Cleanup();
                }
            }

            memset(allocation_vector, 0, sizeof(allocation_vector));
            memset(LicenseKeyPack, 0, sizeof(LicenseKeyPack));

            allocated.dwBufSize = sizeof(allocation_vector)/sizeof(allocation_vector[0]);
            allocated.pdwAllocationVector = allocation_vector;
            allocated.lpAllocateKeyPack = LicenseKeyPack;

            dwStatus = AllocateLicensesFromDB(
                                    pDbWkSpace,
                                    &AllocateRequest,
                                    TRUE,       // fCheckAgreementType
                                    &allocated
                                );

            if(dwStatus != ERROR_SUCCESS)
            {
                continue;
            }

            LICENSEDCLIENT issuedLicense;

            for(int i=0; i < allocated.dwBufSize; i++)
            {
                memset(&issuedLicense, 0, sizeof(issuedLicense));

                //
                // Update Licensed Table
                //
                issuedLicense.dwLicenseId = TLSDBGetNextLicenseId();
                issuedLicense.dwKeyPackId = LicenseKeyPack[i].dwKeyPackId;
    
                issuedLicense.dwNumLicenses = allocation_vector[i];
                issuedLicense.ftIssueDate = time(NULL);

                issuedLicense.ftExpireDate = INT_MAX;
                issuedLicense.ucLicenseStatus = LSLICENSE_STATUS_CONCURRENT;

                _tcscpy(issuedLicense.szMachineName, szHydraServer);
                _tcscpy(issuedLicense.szUserName, szHydraServer);

                // put license into license table
                dwStatus = TLSDBLicenseAdd(
                                pDbWkSpace, 
                                &issuedLicense, 
                                0,
                                NULL
                            );
        
                if(dwStatus != ERROR_SUCCESS)
                    break;

                lNumLicenseWanted -= allocation_vector[i];
            }
        }
    } while(dwLocakType != LSKEYPACKTYPE_UNKNOWN && lNumLicenseWanted > 0);

    *plQuantity -= lNumLicenseWanted;
    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();

    if(dwStatus != ERROR_SUCCESS)
    {
        if(lNumLicenseWanted == 0)
        {
            dwStatus = ERROR_SUCCESS;
        }
        else if(*plQuantity != 0)
        {
            dwStatus = TLS_I_NO_MORE_DATA;
        }
    }

    return dwStatus;
}

//+------------------------------------------------------------------------                          
//  Function:
//      LSDBAllocateConcurrentLicense()
//
//  Description:
//      Allocate/Query/Return concurrent license from concurrent key pack
//
//  Arguments:
//      IN sqlStmt - SQL statement to be used.
//      IN szHydraServer - server that request concurrent license
//      IN pRequest - requested product.
//      IN OUT dwQuantity - see Notes
//
//  Return:
//      ERROR_SUCCESS
//      TLS_E_ODBC_ERROR
//
//  Note:
//    dwQuantity INPUT                        RETURN
//    -------------------------------------   --------------------------------------
//    > 0 number of license requested         Number of licenses successfully allocated
//    = 0 query number of license issued      Number of licenses Issued to server
//        to server                               
//    < 0 number of license to be returned    Number of licenses successfully returned
//
//  Calling routine must check for return from dwQuantity.
//------------------------------------------------------------------------------
DWORD
TLSDBAllocateConcurrentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPTSTR szHydraServer,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT long* dwQuantity 
    )
/*
*/
{
    DWORD status=ERROR_SUCCESS;

    if(*dwQuantity < 0)
    {
        // return licenses, on return, (positive number), number of license actually
        // returned.
        status = TLSDBReturnConcurrentLicenses(
                            pDbWkSpace, 
                            szHydraServer, 
                            pRequest, 
                            dwQuantity
                        );
    }
    else if(*dwQuantity == 0)
    {
        status = TLSDBQueryConcurrentLicenses(
                            pDbWkSpace, 
                            szHydraServer, 
                            pRequest, 
                            dwQuantity
                        );
    }
    else
    {
        status = TLSDBGetConcurrentLicense(
                            pDbWkSpace, 
                            szHydraServer, 
                            pRequest, 
                            dwQuantity
                        );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\ch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        ch.cpp
//
// Contents:    
//              All Clearing house related function
//
// History:     
// 
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "clrhouse.h"
#include "globals.h"
#include "gencert.h"


/*****************************************************************************

*****************************************************************************/
BOOL
TLSChainIssuerCertificate( 
    HCRYPTPROV hCryptProv, 
    HCERTSTORE hChainFromStore, 
    HCERTSTORE hChainToStore, 
    PCCERT_CONTEXT pSubjectContext 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertIssuer=NULL;
    PCCERT_CONTEXT pCurrentSubject = NULL;
    DWORD dwFlags;

    //
    // Increase reference count on Subject context.
    //
    // From MSDN: Currently, a copy is not made of the context, and the
    // returned pointer to a context has the same value as the pointer to a
    // context that was input.
    //

    pCurrentSubject = CertDuplicateCertificateContext(
                                                pSubjectContext
                                            );

    
    while( TRUE )
    {
        dwFlags = CERT_STORE_SIGNATURE_FLAG;   
        pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hChainFromStore, 
                                            pCurrentSubject,
                                            NULL,
                                            &dwFlags
                                        );

        CertFreeCertificateContext(pCurrentSubject);
        if(!pCertIssuer)
        {
            dwStatus = GetLastError();
            break;
        }

        if(dwFlags & CERT_STORE_SIGNATURE_FLAG)
        {
            //
            // we have invalid signature from certificate
            //
            dwStatus =  TLS_E_INVALID_DATA;
            break;
        }      

        if(!CertAddCertificateContextToStore( 
                                        hChainToStore, 
                                        pCertIssuer,
                                        CERT_STORE_ADD_REPLACE_EXISTING,
                                        NULL
                                    ))
        {
            dwStatus = GetLastError();
            break;
        }

        pCurrentSubject = pCertIssuer;
    }

    if(dwStatus == CRYPT_E_SELF_SIGNED)
    {
        dwStatus = ERROR_SUCCESS;
    }

    SetLastError(dwStatus);

    if(pCertIssuer)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

    return dwStatus == ERROR_SUCCESS;
}

/*****************************************************************************

*****************************************************************************/
HCERTSTORE
CertOpenRegistryStore(
    HKEY hKeyType, 
    LPCTSTR szSubKey, 
    HCRYPTPROV hCryptProv, 
    HKEY* phKey
    )
/*
*/
{
    DWORD dwStatus;
    HCERTSTORE hCertStore;

    dwStatus=RegOpenKeyEx(hKeyType, szSubKey, 0, KEY_ALL_ACCESS, phKey);
    if(dwStatus != ERROR_SUCCESS)
    {
        SetLastError(dwStatus);
        return NULL;
    }

    hCertStore = CertOpenStore( 
                            CERT_STORE_PROV_REG,
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            hCryptProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                            (PVOID)*phKey
                        );

    return hCertStore;
}

/*****************************************************************************

    TransferCertFromStoreToStore()

*****************************************************************************/
DWORD
TransferCertFromStoreToStore(
    HCERTSTORE hSrcStore, 
    HCERTSTORE hDestStore
    )
/*
*/
{
    PCCERT_CONTEXT pCertContext=NULL;
    PCCERT_CONTEXT pPrevCertContext=NULL;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        pCertContext = CertEnumCertificatesInStore(hSrcStore, pPrevCertContext);
        if(pCertContext)
        {
            if(!CertAddCertificateContextToStore( 
                                    hDestStore, 
                                    pCertContext,
                                    CERT_STORE_ADD_REPLACE_EXISTING,
                                    NULL
                                ))
            {
                dwStatus = GetLastError();
                break;
            }
        }

        pPrevCertContext = pCertContext;
    } while( pCertContext != NULL );

    if(GetLastError() == CRYPT_E_NOT_FOUND)
    {
        dwStatus = ERROR_SUCCESS;
    }

    return dwStatus;
}

/*****************************************************************************

    LSSaveCertAsPKCS7()

*****************************************************************************/
DWORD 
TLSSaveCertAsPKCS7(
    PBYTE pbCert, 
    DWORD cbCert, 
    PBYTE* ppbEncodedCert, 
    PDWORD pcbEncodedCert
    )
/*
*/
{
    DWORD           dwStatus=ERROR_SUCCESS;

    HCRYPTPROV      hCryptProv=g_hCryptProv;
    HCERTSTORE      hStore=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;

    do {
        //
        // Must have call CryptoInit()
        //if(!CryptAcquireContext(&hCryptProv, _TEXT(KEYCONTAINER), MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
        //{
        //    LSLogEvent(EVENTLOG_ERROR_TYPE, TLS_E_CRYPT_ACQUIRE_CONTEXT, dwStatus=GetLastError());
        //    break;
        //}

        hStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        NULL
                    );

        if(!hStore)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_OPEN_CERT_STORE, 
                    dwStatus=GetLastError()
                );
            break;
        }

        pCertContext = CertCreateCertificateContext(
                                            X509_ASN_ENCODING,
                                            pbCert,
                                            cbCert
                                        );

        if(!pCertContext)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_CREATE_CERTCONTEXT, 
                    dwStatus=GetLastError()
                );  
            break;
        }

        //
        // always start from empty so CERT_STORE_ADD_ALWAYS
        if(!CertAddCertificateContextToStore(
                                hStore, 
                                pCertContext, 
                                CERT_STORE_ADD_ALWAYS, 
                                NULL
                            ))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,  
                    TLS_E_GENERATECLIENTELICENSE,  
                    TLS_E_ADD_CERT_TO_STORE, 
                    dwStatus=GetLastError()
                );  
            break;
        }

#ifdef ENFORCE_LICENSING
        if(g_bHasHydraCert && g_hCaStore)
        {
            if(!TLSChainIssuerCertificate( 
                                    hCryptProv,
                                    g_hCaStore,
                                    hStore,
                                    pCertContext
                                ))
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_GENERATECLIENTELICENSE,
                        TLS_E_ADD_CERT_TO_STORE, 
                        dwStatus=GetLastError()
                    );  
                break;
            }
        }
#endif

        CRYPT_DATA_BLOB saveBlob;
        memset(&saveBlob, 0, sizeof(saveBlob));

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0) && (dwStatus=GetLastError()) != ERROR_MORE_DATA)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            break;
        }

        if(!(saveBlob.pbData = (PBYTE)midl_user_allocate(saveBlob.cbData)))
        {
            dwStatus=GetLastError();
            break;
        }

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            break;
        }
        
        *ppbEncodedCert = saveBlob.pbData;
        *pcbEncodedCert = saveBlob.cbData;

    } while(FALSE);    

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return (dwStatus == ERROR_SUCCESS) ? ERROR_SUCCESS : TLS_E_SAVE_STORE;
}

//--------------------------------------------------------------------------
//
static LONG
OpenCertRegStore( 
    LPCTSTR szSubKey, 
    PHKEY phKey
    )
/*
*/
{
    DWORD dwDisposition;

    return RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szSubKey,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    phKey,
                    &dwDisposition
                );
}

//--------------------------------------------------------------------------
//
static DWORD
IsHydraRootOIDInCert(
    PCCERT_CONTEXT pCertContext,
    DWORD dwKeyType
    )
/*
*/
{
    BOOL bFound=FALSE;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_EXTENSION pCertExtension=pCertInfo->rgExtension;
    PCERT_PUBLIC_KEY_INFO pbPublicKey=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize = 0;

    //
    // Must have a CH root extension.
    //
    for(DWORD i=0; i < pCertInfo->cExtension && bFound == FALSE; i++, pCertExtension++)
    {
        bFound=(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_ROOT) == 0);
    }

    if(bFound == TRUE)
    {
        //
        // Public Key must be the same
        //
        dwStatus = TLSExportPublicKey(
                            g_hCryptProv,
                            dwKeyType,
                            &dwSize,
                            &pbPublicKey
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            bFound = CertComparePublicKeyInfo(
                                        X509_ASN_ENCODING, 
                                        pbPublicKey,
                                        &(pCertContext->pCertInfo->SubjectPublicKeyInfo)
                                    );

            if(bFound == FALSE)
            {
                dwStatus = TLS_E_CH_INSTALL_NON_LSCERTIFICATE;
            }
        }
    }
    else
    {
        dwStatus = TLS_E_CH_LSCERTIFICATE_NOTFOUND;
    }
        
    FreeMemory(pbPublicKey);
    return dwStatus;
}

//---------------------------------------------------------------------------
// Functions:
//      IsCertificateLicenseServerCertificate()
//
// Abstract:
//      Find License Server certificate in PKCS 7 certificate blob
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      cbPKCS7Cert - Size of PKCS7 certificate.
//      pbPKCS7Cert - pointer to PKCS7 certificate
//      cbLsCert - size of encoded license server certificate.
//      pbLsCert - pointer to pointer to receive license server encoded certificate.
//
// Returns:
//      ERROR_SUCCESS
//      TLS_E_INVALID_DATA
//      Crypto. error code.
//---------------------------------------------------------------------------
DWORD
IsCertificateLicenseServerCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertType,
    IN DWORD cbPKCS7Cert, 
    IN PBYTE pbPKCS7Cert,
    IN OUT DWORD* cbLsCert,
    IN OUT PBYTE* pbLsCert
    ) 
/*
*/
{
    //
    // Certificate must be in PCKS 7 format.
    //
    DWORD dwStatus=ERROR_SUCCESS;
    HCERTSTORE  hCertStore=NULL;
    PCCERT_CONTEXT  pPrevCertContext=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;

    CRYPT_DATA_BLOB Serialized;

    Serialized.pbData = pbPKCS7Cert;
    Serialized.cbData = cbPKCS7Cert;

    hCertStore = CertOpenStore( 
                            CERT_STORE_PROV_PKCS7,
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            hCryptProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                            &Serialized
                        );

    if(!hCertStore)
    {
        return dwStatus=GetLastError();
    }

    //
    // enumerate all certificate and find certificate with our extension.
    //
    do {
        pCertContext = CertEnumCertificatesInStore(
                                            hCertStore, 
                                            pPrevCertContext
                                        );
        if(pCertContext)
        {
            dwStatus = IsHydraRootOIDInCert(
                                        pCertContext, 
                                        dwCertType
                                    );

            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // this is our certificate.
                //
                *pbLsCert = (PBYTE)AllocateMemory(*cbLsCert = pCertContext->cbCertEncoded);
                if(*pbLsCert)
                {
                    memcpy(
                            *pbLsCert, 
                            pCertContext->pbCertEncoded, 
                            pCertContext->cbCertEncoded
                        );
                }
                else
                {
                    dwStatus = GetLastError();
                }

                break;
            }
            else if(dwStatus == TLS_E_CH_INSTALL_NON_LSCERTIFICATE)
            {
                break;
            }

            //
            // reset status code.
            //
            dwStatus = ERROR_SUCCESS;
        }

        pPrevCertContext = pCertContext;
    } while( pCertContext != NULL );

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pPrevCertContext);
    }

    if(hCertStore)
    {
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);    
    }

    return dwStatus;
}


//---------------------------------------------------------------------------
// Functions:
//      LSSaveCertificateToReg()
//
// Abstract:
//      
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      
//      
//      
//      
//
// Returns:
//      
//      
//      
//---------------------------------------------------------------------------
DWORD
TLSSaveRootCertificateToReg(
    HCRYPTPROV hCryptProv, 
    HKEY hKey, 
    DWORD cbEncodedCert, 
    PBYTE pbEncodedCert
    )
/*
*/
{
    PCCERT_CONTEXT  pCertContext=NULL;
    HCERTSTORE      hCertSaveStore=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;


    do {
        hCertSaveStore = CertOpenStore( 
                                    CERT_STORE_PROV_REG,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    hCryptProv,
                                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                    (PVOID)hKey
                                );
        if(!hCertSaveStore)
        {
            // dwStatus = GetLastError();
            dwStatus = TLS_E_INVALID_DATA;
            break;
        }

        pCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbEncodedCert,
                                        cbEncodedCert
                                    );

        if(!pCertContext)
        {
            // dwStatus = GetLastError();
            dwStatus = TLS_E_INVALID_DATA;
            break;
        }

        if(!CertAddCertificateContextToStore( 
                                hCertSaveStore, 
                                pCertContext,
                                CERT_STORE_ADD_REPLACE_EXISTING,
                                NULL
                            ))
        {
            dwStatus=GetLastError();
        }
    } while(FALSE);

    if(pCertContext)
    {
        CertFreeCertificateContext( pCertContext );
    }

    if(hCertSaveStore)
    {
        CertCloseStore(
                    hCertSaveStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    return dwStatus;
}

//---------------------------------------------------------------------------
// Functions:
//      LSSaveCertificateToReg()
//
// Abstract:
//      
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      
//      
//      
//      
//
// Returns:
//      
//      
//      
//---------------------------------------------------------------------------
DWORD
TLSSaveCertificateToReg(
    HCRYPTPROV hCryptProv, 
    HKEY hKey, 
    DWORD cbPKCS7Cert, 
    PBYTE pbPKCS7Cert
    )
/*
*/
{
    //
    // Certificate must be in PCKS 7 format.
    //
    DWORD           dwStatus=ERROR_SUCCESS;
    HCERTSTORE      hCertOpenStore=NULL;
    HCERTSTORE      hCertSaveStore=NULL;

    PCCERT_CONTEXT  pPrevCertContext=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;

    CRYPT_DATA_BLOB Serialized;

    Serialized.pbData = pbPKCS7Cert;
    Serialized.cbData = cbPKCS7Cert;

    hCertOpenStore = CertOpenStore( 
                                CERT_STORE_PROV_PKCS7,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                hCryptProv,
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                &Serialized
                            );

    if(!hCertOpenStore)
    {
        // dwStatus = GetLastError();
        dwStatus = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    hCertSaveStore = CertOpenStore( 
                                CERT_STORE_PROV_REG,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                hCryptProv,
                                CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                (PVOID)hKey
                            );

    if(!hCertSaveStore)
    {
        dwStatus = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    dwStatus = TransferCertFromStoreToStore(
                                hCertOpenStore, 
                                hCertSaveStore
                            );

cleanup:    
    if(hCertSaveStore)
    {
        CertCloseStore(
                    hCertSaveStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    if(hCertOpenStore)
    {
        CertCloseStore(
                    hCertOpenStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );    
    }

    return dwStatus;
}

//---------------------------------------------------------------------------
// Functions:
//      LSSaveRootCertificatesToStore()
//
// Abstract:
//      
//      Save root certificate to license server certificate store.
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      cbSignatureCert - size of root's signature certificate.
//      pbSignatureCert - pointer to root's signature certificate.
//      cbExchangeCert - size of root's exchange certficate.
//      pbExchangeCert - pointer to root's exchange certificate
//
// Returns:
//      
//---------------------------------------------------------------------------
DWORD 
TLSSaveRootCertificatesToStore(  
    IN HCRYPTPROV    hCryptProv,
    IN DWORD         cbSignatureCert, 
    IN PBYTE         pbSignatureCert, 
    IN DWORD         cbExchangeCert, 
    IN PBYTE         pbExchangeCert
    )
/*
*/
{
    HKEY    hKey;
    LONG    status=ERROR_SUCCESS;

    if(cbSignatureCert == 0 && cbExchangeCert == 0)
    {
        return status = TLS_E_INVALID_DATA;
    }

    if(cbSignatureCert)
    {
        status = OpenCertRegStore(
                            LSERVER_CERTIFICATE_REG_ROOT_SIGNATURE, 
                            &hKey
                        );
        if(status != ERROR_SUCCESS)
            return status;

        status = TLSSaveRootCertificateToReg( 
                            hCryptProv, 
                            hKey, 
                            cbSignatureCert, 
                            pbSignatureCert
                        );
        RegCloseKey(hKey);
        if(status != ERROR_SUCCESS)
            return status;            
    }

    if(cbExchangeCert)
    {
        status = OpenCertRegStore(
                            LSERVER_CERTIFICATE_REG_ROOT_EXCHANGE, 
                            &hKey
                        );
        if(status != ERROR_SUCCESS)
            return status;

        status=TLSSaveRootCertificateToReg(
                            hCryptProv, 
                            hKey, 
                            cbExchangeCert, 
                            pbExchangeCert
                        );
        RegCloseKey(hKey);
    }

    return status;
}

//---------------------------------------------------------------------------
// Functions:
//      LSSaveCertificatesToStore()
//
// Abstract:
//      
//
// Parameters:
//      hCryptProv - Cryto. Provider
//      
//      
//      
//      
//
// Returns:
//      
//      
//      
//---------------------------------------------------------------------------
DWORD
TLSSaveCertificatesToStore(
    IN HCRYPTPROV    hCryptProv,
    IN DWORD         dwCertType,
    IN DWORD         dwCertLevel,
    IN DWORD         cbSignatureCert, 
    IN PBYTE         pbSignatureCert, 
    IN DWORD         cbExchangeCert, 
    IN PBYTE         pbExchangeCert
    )
/*
*/
{
    HKEY    hKey;
    LONG    status = ERROR_SUCCESS;
    LPTSTR  szRegSignature;
    LPTSTR  szRegExchange;

    switch(dwCertType)
    {
        case CERTIFICATE_CA_TYPE:
            szRegSignature = LSERVER_CERTIFICATE_REG_CA_SIGNATURE;
            szRegExchange = LSERVER_CERTIFICATE_REG_CA_EXCHANGE;
            break;
                                        
        case CERTITICATE_MF_TYPE:
            szRegSignature = LSERVER_CERTIFICATE_REG_MF_SIGNATURE;
            szRegExchange = LSERVER_CERTIFICATE_REG_MF_EXCHANGE;
            break;

        case CERTIFICATE_CH_TYPE:
            szRegSignature = LSERVER_CERTIFICATE_REG_CH_SIGNATURE;
            szRegExchange = LSERVER_CERTIFICATE_REG_CH_EXCHANGE;
            break;

        default:
            status = TLS_E_INVALID_DATA;
            return status;
    }

    if(cbSignatureCert)
    {
        status = OpenCertRegStore(szRegSignature, &hKey);
        if(status != ERROR_SUCCESS)
            return status;

        status=TLSSaveCertificateToReg(
                            hCryptProv, 
                            hKey, 
                            cbSignatureCert, 
                            pbSignatureCert
                        );

        RegCloseKey(hKey);
        if(status != ERROR_SUCCESS)
            return status;            
    }

    if(cbExchangeCert)
    {
        status = OpenCertRegStore(szRegExchange, &hKey);
        if(status != ERROR_SUCCESS)
            return status;

        status=TLSSaveCertificateToReg(
                                hCryptProv, 
                                hKey, 
                                cbExchangeCert, 
                                pbExchangeCert
                            );
        RegCloseKey(hKey);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\db.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        db.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DB_H__
#define __DB_H__


#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSDBValidateLicense(
        PTLSDbWorkSpace      pDbWkSpace,
        IN PHWID             phWid,
        IN PLICENSEREQUEST   pLicensedProduct,
        IN DWORD             dwKeyPackId, 
        IN DWORD             dwLicenseId,
        OUT PTLSLICENSEPACK   lpKeyPack,
        OUT LPLICENSEDCLIENT  lpLicense
    );

    DWORD 
    TLSDBDeleteLicense(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId, 
        DWORD dwLicenseId
    );

    DWORD 
    TLSDBRevokeLicense(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPacKId, 
        IN DWORD dwLicenseId
    );

    DWORD 
    TLSDBReturnLicense(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId, 
        IN DWORD dwLicenseId,
        IN DWORD dwNewLicenseStatus
    );

    DWORD 
    TLSDBReturnLicenseToKeyPack(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId, 
        IN int dwNumLicense
    );

    DWORD 
    TLSDBRevokeKeyPack(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId
    );

    DWORD 
    TLSDBReturnKeyPack(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId
    );

    DWORD 
    TLSDBDeleteKeyPack(
        PTLSDbWorkSpace pDbWkSpace,
        IN DWORD dwKeyPackId
    );

    DWORD
    VerifyTLSDBAllocateRequest(
        IN PTLSDBAllocateRequest pRequest 
    );

    DWORD
    AllocateLicensesFromDB(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PTLSDBAllocateRequest pRequest,
        IN BOOL fCheckAgreementType,
        IN OUT PTLSDBLicenseAllocation pAllocated
    );


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\db.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        db.cpp
//
// Contents:    
//              all routine deal with cross table query
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "db.h"
#include "clilic.h"
#include "keypack.h"
#include "kp.h"
#include "lkpdesc.h"


/****************************************************************************
Function:
    LSDBValidateLicense()

Description:
    Routine to validate license agaist database, must call LSDecodeLicense()
    to convert hydra license to LICENSEREQUEST structure.

Arguments:
    IN CSQLStmt* - SQL Statement handle to use
    IN PLICENSEREQUEST - License in the form of LICENSEREQUEST structure
    IN dwKeyPackId - KeyPack table's ID that is license is issued from
    IN dwLicenseId - License tables's License ID 
    OUT LPKEYPACK - KeyPack record this license is issued from, NULL if not
                      interested in this value.
    OUT LPLICENSE - Corresponding license record for this license, NULL if
                      not interest in this value.

Returns:
    ERROR_SUCCESS
    TLS_E_INVALID_LICENSE
    TLS_E_INTERNAL
    ODBC error.
****************************************************************************/
DWORD
TLSDBValidateLicense(
    PTLSDbWorkSpace      pDbWkSpace,
    //IN PBYTE             pbLicense,
    //IN DWORD             cbLicense,
    IN PHWID             phWid,
    IN PLICENSEREQUEST   pLicensedProduct,
    IN DWORD             dwKeyPackId, 
    IN DWORD             dwLicenseId,
    OUT PTLSLICENSEPACK   lpKeyPack,
    OUT LPLICENSEDCLIENT  lpLicense
    )
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwMatchCount=0;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    TLSLICENSEPACK keypack_search;
    TLSLICENSEPACK keypack_found;

    LICENSEDCLIENT license_search;
    LICENSEDCLIENT license_found;
    int count=0;
    BOOL bValid=TRUE;

    memset(&license_search, 0, sizeof(LICENSEDCLIENT));
    keypack_found.pbDomainSid = NULL;

    license_search.dwLicenseId = dwLicenseId;
    dwStatus = TLSDBLicenseEnumBegin(
                        pDbWkSpace,
                        TRUE,
                        LSLICENSE_SEARCH_LICENSEID,
                        &license_search
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        if(IS_JB_ERROR(dwStatus) != TRUE)
        {
            SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        }

        goto cleanup;
    }

    do
    {
        dwStatus=TLSDBLicenseEnumNext(
                                pDbWkSpace, 
                                &license_found
                            );

        if(dwStatus != ERROR_SUCCESS)
            break;

        count++;
    } while(count < 1);

    TLSDBLicenseEnumEnd(pDbWkSpace);

    if(count != 1)
    {
        // can't find the license
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        goto cleanup;
    }

    if(count > 1)
    {
        // more than one entry in database has identical
        // license id
        SetLastError(dwStatus = TLS_E_INTERNAL);
        goto cleanup;
    }

    //
    // Not issue by this license server???
    //
    if(license_found.dwKeyPackId != dwKeyPackId)
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        goto cleanup;
    }

    //
    // new license request might pass different HWID
    //
    dwMatchCount += (int)(license_found.dwSystemBiosChkSum == phWid->dwPlatformID);
    dwMatchCount += (int)(license_found.dwVideoBiosChkSum == phWid->Data1);
    dwMatchCount += (int)(license_found.dwFloppyBiosChkSum == phWid->Data2);
    dwMatchCount += (int)(license_found.dwHardDiskSize == phWid->Data3);
    dwMatchCount += (int)(license_found.dwRamSize == phWid->Data4);

    if(dwMatchCount < LICENSE_MIN_MATCH)
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
    }

    //
    // Verify against KeyPack Table
    //
    memset(&keypack_search, 0, sizeof(keypack_search));
    keypack_search.dwKeyPackId = dwKeyPackId;

    dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LSKEYPACK_EXSEARCH_DWINTERNAL,
                            &keypack_search,
                            &keypack_found
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        if(IS_JB_ERROR(dwStatus) != TRUE)
        {
            SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        }

        goto cleanup;
    }

    // match KeyPack's Product ID, Version, Language ID, PlatformID
    // structure change, no more product version.
    if(pLicensedProduct->dwPlatformID != keypack_found.dwPlatformType ||
       _tcsicmp((LPTSTR)pLicensedProduct->pProductInfo->pbCompanyName, keypack_found.szCompanyName) ||
       _tcsicmp((LPTSTR)pLicensedProduct->pProductInfo->pbProductID, keypack_found.szProductId) )
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
    }

cleanup:

    //FreeTlsLicensePack(&keypack_found);

    if(dwStatus == ERROR_SUCCESS)
    {
        if(lpKeyPack)
        {
            *lpKeyPack = keypack_found;
        }

        if(lpLicense)
        {
            *lpLicense = license_found;
        }
    }

    return dwStatus;
}

/*************************************************************************
Function:
    LSDBDeleteLicense()

*************************************************************************/
DWORD 
TLSDBDeleteLicense(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId, 
    DWORD dwLicenseId
    )
/*
*/
{
    // TODO - license entry base on license id
    // 1) Return license back to key pack
    // 2) 'Physically' delete the license.

    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBRevokeLicense()

*************************************************************************/
DWORD 
TLSDBRevokeLicense(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPacKId, 
    IN DWORD dwLicenseId
)
{
    // Set License Status to revoked
    // Return License to KeyPack

    // call LSDBDeleteKeyPack() and if not successful, insert into RevokeLicenseTable
    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBReturnLicense()

*************************************************************************/
DWORD 
TLSDBReturnLicense(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId, 
    IN DWORD dwLicenseId,
    IN DWORD dwNewLicenseStatus
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwQuantity = 1;

    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    //
    // no verification on record got updated.
    //
    LICENSEDCLIENT license;
    license.dwLicenseId = dwLicenseId;
    license.ucLicenseStatus = dwNewLicenseStatus;

    //
    // use undocumented feature to delete license
    //
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RETURN,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("Deleting license ID %d issued by keypack %d\n"),
            license.dwLicenseId,
            dwKeyPackId
        );

    if (dwNewLicenseStatus == LSLICENSESTATUS_DELETE)
    {
        // get number of CALs in this license

        LICENSEDCLIENT licenseFound;

        dwStatus = TLSDBLicenseFind(
                        pDbWkSpace,
                        TRUE,
                        LSLICENSE_SEARCH_LICENSEID,
                        &license,
                        &licenseFound
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwQuantity = licenseFound.dwNumLicenses;
        }
    }

    dwStatus = TLSDBLicenseSetValue(
                        pDbWkSpace, 
                        LSLICENSE_EXSEARCH_LICENSESTATUS, 
                        &license,
                        FALSE
                    );

    if(dwStatus == ERROR_SUCCESS && dwNewLicenseStatus == LSLICENSESTATUS_DELETE)
    {
        dwStatus = TLSDBReturnLicenseToKeyPack(
                                    pDbWkSpace, 
                                    dwKeyPackId, 
                                    dwQuantity
                                );
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();
    return dwStatus;
}


/*************************************************************************
Function:
    LSDBReturnLicenseToKeyPack()
*************************************************************************/
DWORD 
TLSDBReturnLicenseToKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId, 
    IN int dwNumLicense
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSDBLockKeyPackTable();

    #ifdef DBG
    DWORD dwPrevNumLicense=0;
    #endif

    TLSLICENSEPACK found;
    TLSLICENSEPACK search;

    found.pbDomainSid = NULL;

    do {

        // retrieve number of licenses
        search.dwKeyPackId = dwKeyPackId;
        dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LSKEYPACK_EXSEARCH_DWINTERNAL,
                            &search,
                            &found
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            if(IS_JB_ERROR(dwStatus) == FALSE)
            {
                SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
            }
            break;
        }

        if(search.dwKeyPackId != found.dwKeyPackId)
        {
            TLSASSERT(FALSE);
        }

        #ifdef DBG
        dwPrevNumLicense = found.dwNumberOfLicenses;
        #endif

        // set the number of licenses issued by 1
        switch( (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) )
        {
            case LSKEYPACKTYPE_RETAIL:
            case LSKEYPACKTYPE_CONCURRENT:
            case LSKEYPACKTYPE_OPEN:
            case LSKEYPACKTYPE_SELECT:
                // number of licenses available
                found.dwNumberOfLicenses += dwNumLicense;
                break;

            case LSKEYPACKTYPE_FREE:
            case LSKEYPACKTYPE_TEMPORARY:
                // number of license issued
                if(found.dwNumberOfLicenses > 0)
                {
                    found.dwNumberOfLicenses -= dwNumLicense;
                }
                break;

            default:
                SetLastError(dwStatus = TLS_E_CORRUPT_DATABASE);
        }
    
        #ifdef DBG
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RETURN,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Returning license to keypack %d - from %d to %d\n"),
                found.dwKeyPackId,
                dwPrevNumLicense,
                found.dwNumberOfLicenses
            );
        #endif

        //
        // use undocumented feature to delete temp. keypack
        if( (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) == LSKEYPACKTYPE_TEMPORARY && 
            found.dwNumberOfLicenses == 0)
        {
            found.ucKeyPackStatus = LSKEYPACKSTATUS_DELETE;
            
            // delete keypack desc table
            LICPACKDESC keyPackDesc;

            memset(&keyPackDesc, 0, sizeof(LICPACKDESC));
            keyPackDesc.dwKeyPackId = found.dwKeyPackId;
            TLSDBKeyPackDescSetValue(
                                pDbWkSpace, 
                                KEYPACKDESC_SET_DELETE_ENTRY, 
                                &keyPackDesc
                            );
        }

        dwStatus=TLSDBKeyPackSetValues(
                            pDbWkSpace, 
                            TRUE, 
                            LSKEYPACK_EXSEARCH_AVAILABLE, 
                            &found
                        );
    } while(FALSE);

    //FreeTlsLicensePack(&found);
    TLSDBUnlockKeyPackTable();
    return dwStatus;
}

/*************************************************************************
Function:
    LSDBRevokeKeyPack()

*************************************************************************/
DWORD 
TLSDBRevokeKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId
    )
{
    // Set Key Pack Status to Revoke
    // Insert this key pack into RevokeKeyPackTable ???
    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBReturnKeyPack()

*************************************************************************/
DWORD 
TLSDBReturnKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId
    )
{
    // Same as RevokeKeyPack except status is return
    // Delete Key pack only when all license has been returned.
    return ERROR_SUCCESS;
}

/*************************************************************************
Function:
    LSDBDeleteKeyPack()

*************************************************************************/
DWORD 
TLSDBDeleteKeyPack(
    PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwKeyPackId
    )
{
    // Delete Only when all license has been returned.
    return ERROR_SUCCESS;
}


//+------------------------------------------------------------------------
//  Function: 
//      AllocateLicenses()
//
//  Description:
//      Allocate license from key Pack
//
//  Arguments:
//      IN lpSqlStmt - sql statement handle
//      IN ucKeyPackType - key pack type to allocate license from
//      IN szCompanyName - Product Company
//      IN szProductId - Product Name
//      IN dwVersion - Product Version
//      IN dwPlatformId - Product PlatformId
//      IN dwLangId - Product Lanugage Id
//      IN OUT lpdwNumLicense - number of license to be allocated and on
//                              return, number of licenses actually allocated
//      IN bufSize - number of interested keypack that has requested license
//      IN OUT lpAllocationVector - number of license allocated from list of 
//                                  key pack that has requested licenses.
//      IN OUT LPKEYPACK - key Pack that license was allocated from
//
//  Returns:
//      TLS_E_INVALID_DATA      Invalid parameter
//      TLS_I_NO_MORE_DATA      No key pack has the requested license
//
//  Notes:
//      To keep code clean/simple, call ReturnLicenses() for returning 
//      licenses
//-------------------------------------------------------------------------
DWORD
VerifyTLSDBAllocateRequest(
    IN PTLSDBAllocateRequest pRequest 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    UCHAR ucAgreementType;

    if(pRequest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    ucAgreementType = (pRequest->ucAgreementType & ~pRequest->ucAgreementType);

    if(ucAgreementType < LSKEYPACKTYPE_FIRST || ucAgreementType > LSKEYPACKTYPE_LAST)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("AllocateLicenses() invalid keypack type - %d\n"),
                pRequest->ucAgreementType
            );
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->szCompanyName == NULL || _tcslen(pRequest->szCompanyName) == 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("AllocateLicenses() invalid company name\n")
            );
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->szProductId == NULL || _tcslen(pRequest->szProductId) == 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("AllocateLicenses() invalid product id\n")
            );
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
    }

cleanup:
    return dwStatus;
}
//----------------------------------------------------------------------

DWORD
AllocateLicensesFromDB(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBAllocateRequest pRequest,
    IN BOOL fCheckAgreementType,
    IN OUT PTLSDBLicenseAllocation pAllocated
    )
/*
*/
{
    DWORD status=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || pRequest == NULL || pAllocated == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE, 
                DBG_ALL_LEVEL,
                _TEXT("pDbWkSpace is NULL...\n")
            );

        SetLastError(status = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return status;
    }

    status = VerifyTLSDBAllocateRequest(pRequest);
    if(status != ERROR_SUCCESS)
        return status;

    if(pAllocated->dwBufSize <= 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_ALLOCATELICENSE, 
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("AllocateLicenses() invalid return buffer size\n")
            );
        SetLastError(status = TLS_E_INVALID_DATA);
        return status;
    }

    #ifdef DBG
    DWORD dwPrevNumLicense;
    #endif

    BOOL bProductInstalled=FALSE;
    DWORD bufIndex=0;
    TLSLICENSEPACK keypack_search;
    TLSLICENSEPACK keypack_found;

    DWORD dwNumLicenses = pRequest->dwNumLicenses;          // number of license wanted/returned
    DWORD dwTotalAllocated=0;

    memset(&keypack_search, 0, sizeof(keypack_search));
    memset(&keypack_found, 0, sizeof(keypack_found));

    keypack_search.ucAgreementType = pRequest->ucAgreementType;
    _tcscpy(keypack_search.szCompanyName, pRequest->szCompanyName);
    _tcscpy(keypack_search.szProductId, pRequest->szProductId);
    keypack_search.wMajorVersion = HIWORD(pRequest->dwVersion);
    keypack_search.wMinorVersion = LOWORD(pRequest->dwVersion);
    keypack_search.dwPlatformType = pRequest->dwPlatformId;

    LicPackTable& licpack_table=pDbWkSpace->m_LicPackTable;
    time_t current_time=time(NULL);

    //
    // Lock Key Pack table
    // Only update requires locking, read might get in-correct value.
    //

    //
    // Only allow one thread to enter - Jet not fast enough in updating entry
    //
    TLSDBLockKeyPackTable();

    status = TLSDBKeyPackEnumBegin(
                            pDbWkSpace, 
                            TRUE,
                            LSKEYPACK_SEARCH_PRODUCTID | (fCheckAgreementType ? LICENSEDPACK_FIND_LICENSEPACK : 0),
                            &keypack_search
                        );

    if(status != ERROR_SUCCESS)
        goto cleanup;

    try {

        while(status == ERROR_SUCCESS && dwNumLicenses != 0 && bufIndex < pAllocated->dwBufSize)
        {
            status = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    &keypack_found
                                );
            if(status != ERROR_SUCCESS)
                break;


            //
            // Skip remote keypack
            //
            if(keypack_found.ucAgreementType & LSKEYPACK_REMOTE_TYPE)
            {
                continue;
            }

            if(keypack_found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
            {
                continue;
            }

            if(fCheckAgreementType
               && (keypack_found.ucAgreementType != pRequest->ucAgreementType))
            {
                continue;
            }

            UCHAR ucKeyPackStatus = keypack_found.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

            // Allocating licenses
            //
            // Throw away any key pack that has bad status
            // one of the reason why can't returning license in this routine
            // for returning license, we should not care about key pack 
            // status.
            if(ucKeyPackStatus == LSKEYPACKSTATUS_UNKNOWN ||
               ucKeyPackStatus == LSKEYPACKSTATUS_RETURNED ||
               ucKeyPackStatus == LSKEYPACKSTATUS_REVOKED ||
               ucKeyPackStatus == LSKEYPACKSTATUS_OTHERS)
            {
                continue;
            }

            //
            // we find the product, make sure the version is what we want.
            //
            bProductInstalled=TRUE;

            // Expired keypack
            // TODO - update table here.
            if((DWORD)keypack_found.dwExpirationDate < current_time)
               continue;

            //
            // never allocate from older version
            //
            if( keypack_found.wMajorVersion < HIWORD(pRequest->dwVersion) )
            {
                continue;
            }

            //
            // Same major version but older minor
            //
            if( keypack_found.wMajorVersion == HIWORD(pRequest->dwVersion) && 
                keypack_found.wMinorVersion < LOWORD(pRequest->dwVersion) )
            {
                continue;
            }

            if(pRequest->dwScheme == ALLOCATE_EXACT_VERSION)
            {
                if(keypack_found.wMajorVersion != HIWORD(pRequest->dwVersion) ||
                   keypack_found.wMinorVersion < LOWORD(pRequest->dwVersion) )
                {
                    continue;
                }
            }

            UCHAR ucAgreementType = (keypack_found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE);

            //
            // Verify number of licenses left
            //
            if((ucAgreementType == LSKEYPACKTYPE_SELECT ||
                ucAgreementType == LSKEYPACKTYPE_RETAIL || 
                ucAgreementType == LSKEYPACKTYPE_CONCURRENT ||
			    ucAgreementType == LSKEYPACKTYPE_OPEN) &&
                keypack_found.dwNumberOfLicenses == 0)
            {
                continue;
            }

            pAllocated->lpAllocateKeyPack[bufIndex] = keypack_found;

            #ifdef DBG
            dwPrevNumLicense = pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses;
            #endif

            if( ucAgreementType != LSKEYPACKTYPE_RETAIL && 
                ucAgreementType != LSKEYPACKTYPE_CONCURRENT &&
		        ucAgreementType != LSKEYPACKTYPE_OPEN &&
                ucAgreementType != LSKEYPACKTYPE_SELECT )
            {
                // For Free/temporary license, number of available license is
                // how many license has been issued
                pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses += dwNumLicenses;
                pAllocated->pdwAllocationVector[bufIndex] = dwNumLicenses;

                dwTotalAllocated += dwNumLicenses;
                pAllocated->lpAllocateKeyPack[bufIndex].dwNextSerialNumber += dwNumLicenses;
                dwNumLicenses=0;
            } 
            else 
            {
                int allocated=min(dwNumLicenses, keypack_found.dwNumberOfLicenses);

                pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses -= allocated;
                dwNumLicenses -= allocated;
                pAllocated->pdwAllocationVector[bufIndex] = allocated;

                dwTotalAllocated += allocated;
                pAllocated->lpAllocateKeyPack[bufIndex].dwNextSerialNumber += allocated;
            }

            #if DBG
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_ALLOCATELICENSE,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Updating keypack %d number of license from %d to %d\n"),
                    pAllocated->lpAllocateKeyPack[bufIndex].dwKeyPackId,
                    dwPrevNumLicense,
                    pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses
                );
            #endif

            //
            // Update number of licenses available for this keypack and license id in keypack
            //
            GetSystemTimeAsFileTime(&(pAllocated->lpAllocateKeyPack[bufIndex].ftLastModifyTime));
            if(licpack_table.UpdateRecord(
                                pAllocated->lpAllocateKeyPack[bufIndex],
                                LICENSEDPACK_ALLOCATE_LICENSE_UPDATE_FIELD
                            ) == FALSE)
            {
                SetLastError(status = SET_JB_ERROR(licpack_table.GetLastJetError()));
                TLSASSERT(FALSE);
                break;
            }

            #ifdef DBG
            TLSLICENSEPACK test;

            if(licpack_table.FetchRecord(test) == FALSE)
            {
                SetLastError(status = SET_JB_ERROR(licpack_table.GetLastJetError()));
                TLSASSERT(FALSE);
            }
        
            if(test.dwKeyPackId != pAllocated->lpAllocateKeyPack[bufIndex].dwKeyPackId ||
               test.dwNumberOfLicenses != pAllocated->lpAllocateKeyPack[bufIndex].dwNumberOfLicenses)
            {
                TLSASSERT(FALSE);
            }

            //FreeTlsLicensePack(&test);
            #endif

            bufIndex++;
        }
    } 
    catch(...) 
    {
        SetLastError(status = TLS_E_INTERNAL);
    }

    //
    // terminate enumeration.
    //
    TLSDBKeyPackEnumEnd(pDbWkSpace);
    if(status == TLS_I_NO_MORE_DATA)
    {
        if(bufIndex != 0)
        {
            status = ERROR_SUCCESS;
        }
        else if(!bProductInstalled)
        {
            SetLastError(status = TLS_E_PRODUCT_NOTINSTALL);
        }
    }

    pAllocated->dwBufSize = bufIndex;
    pAllocated->dwTotalAllocated = dwTotalAllocated;   
    pAllocated->dwBufSize = bufIndex;

cleanup:

    TLSDBUnlockKeyPackTable();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\conlic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        conlic.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __CONLIC_H__
#define __CONLIC_H__
#include "server.h"
#include "init.h"

#ifdef __cplusplus
extern "C" {
#endif

DWORD
TLSDBAllocateConcurrentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPTSTR szHydraServer,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT long* dwQuantity 
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\dblevel.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        dblevel.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DBLEVEL_H__

#define __DBLEVEL_H__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\debug.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        debug.h
//
// Contents:    Debugging define in license server
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DEBUG_H__
#define __DEBUG_H__

//------------------------------------------------------
#define DEBUG_LEVEL                     0x000003FF
#define DEBUG_SEVERITY                  0x00000C00
#define DEBUG_MODULE                    0xFFFFF000

//
// 
// Debug level : Bit 0 to 13 (total of 14 debug level)
//


//
// severity code : Bit 30 and 31 
//
#define DBG_SUCCESS                     0x00
#define DBG_INFORMATION                 0x01
#define DBG_WARNING                     0x10
#define DBG_ERROR                       0x11

//
// Facility Code : Bit 14 - 29 
//
#define DBG_FACILITY_JETBLUE            0x00001
#define DBG_FACILITY_RPC                0x00002
#define DBG_FACILITY_KEYPACK            0x00004
#define DBG_FACILITY_LICENSED           0x00008
#define DBG_FACILITY_KEYPACKDESC        0x00010
#define DBG_FACILITY_ALLOCATELICENSE    0x00020
#define DBG_FACILITY_INIT               0x00040
#define DBG_FACILITY_LOCK               0x00080
#define DBG_FACILITY_HANDLEPOOL         0x00100
#define DBG_FACILITY_RETURN             0x00200
#define DBG_FACILITY_UPGRADE            0x00400
#define DBG_FACILITY_POLICY             0x00800
#define DBG_FACILITY_WORKMGR            0x01000
#define DBG_FACILITY_WKSTORAGE          0x02000
#define DBG_FACILITY_SRVLIST            0x04000
#define DBG_FACILITY_JOB                0x08000

//
// All level
//
#define DBG_ALL_LEVEL                   DEBUG_LEVEL

//
// Debug Level
// 
#define DBGLEVEL_FUNCTION_ERROR         0x0001
#define DBGLEVEL_FUNCTION_TRACE         0x0001
#define DBGLEVEL_FUNCTION_DETAILSIMPLE  0x0002
#define DBGLEVEL_FUNCTION_DETAILFULL    0x0004
#define DBGLEVEL_FUNCTION_ALL           DBG_ALL_LEVEL  


//-------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

    void
    InitDBGPrintf(
        IN BOOL bConsole,
        IN LPTSTR DbgEventSrc,  // unuse for now
        IN DWORD dwDebug
    );

    void 
    DBGPrintf(
        DWORD dwSeverityCode,
        DWORD dwModule,
        DWORD dwLevel, 
        LPTSTR format, ... 
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\debug.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        debug.cpp
//
// Contents:    License Server debugging spew routine
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "debug.h"
#include "locks.h"
#include "dbgout.h"


//-----------------------------------------------------------
static HANDLE   DbgConsole=NULL;
//static LPTSTR   DbgEventSrc;

static DWORD    DbgSeverityCode=0;
static DWORD    DbgLevel=0;
static DWORD    DbgModule=0;
//CCriticalSection ConsoleLock;


//-----------------------------------------------------------
void
InitDBGPrintf(
    IN BOOL bConsole,
    IN LPTSTR DbgEventSrc,  // unuse for now
    IN DWORD dwDebug
    )
/*
*/
{
    DbgSeverityCode = (dwDebug & DEBUG_SEVERITY) >> 10;
    DbgModule = (dwDebug & DEBUG_MODULE) >> 12;
    DbgLevel = dwDebug & DEBUG_LEVEL;

    if(DbgConsole == NULL && bConsole == TRUE)
    {
        // allocate a console, ignore error
        AllocConsole();
        DbgConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    return;
}

//-----------------------------------------------------------

void 
DBGPrintf(
    DWORD dwSeverityCode,
    DWORD dwModule,
    DWORD dwLevel, 
    LPTSTR format, ... 
    )
/*
*/
{
    if((dwModule & DbgModule) == 0)
        return;

    //
    // Report all error
    //
    if((dwSeverityCode & DbgSeverityCode) == 0)
        return;

    if((dwLevel & DbgLevel) == 0)
        return;

    va_list marker;

    va_start(marker, format);
    DebugOutput(DbgConsole, format, &marker);
    va_end(marker);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\findlost.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        findlost.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __FINDLOST_H__
#define __FINDLOST_H__
#include "server.h"

#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSFindLicense(
        IN PLICENSEDPRODUCT pLicProduct,
        OUT PLICENSEDCLIENT pLicClient
    );

    DWORD
    TLSFindDbLicensedProduct(
        IN PTLSDBLICENSEDPRODUCT pLicProduct,
        OUT PLICENSEDCLIENT pLicClient
    );

    DWORD
    TLSDBFindLostLicense(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PTLSDBLICENSEREQUEST pLicenseRequest,
        IN PHWID pHwid,
        IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
        OUT PUCHAR pucMarked
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\expperm.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 2000-2000
//
// File:        expperm.cpp
//
// Contents:    
//
// History:     
//
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <tchar.h>
#include <process.h>
#include "lscommon.h"
#include "debug.h"
#include "globals.h"
#include "db.h"
#include "keypack.h"
#include "clilic.h"
#include "server.h"

#define EXPIRE_THREAD_INITIAL_SLEEP     (1000*60)    /* 1 minute */

//---------------------------------------------------------------------
unsigned int WINAPI
ExpirePermanentThread(void* ptr)
{
    HANDLE hEvent=(HANDLE) ptr;
    DWORD dwStatus=ERROR_SUCCESS;
    LICENSEDCLIENT search_license;

    memset(&search_license,0,sizeof(search_license));

    //
    // Signal initializer thread we are ready
    //
    SetEvent(hEvent);

    DBGPrintf(
              DBG_INFORMATION,
              DBGLEVEL_FUNCTION_DETAILSIMPLE,
              DBG_ALL_LEVEL,
              _TEXT("ExpirePermanent : ready...\n")
              );                

    //
    // Give service chance to initialize
    //
    Sleep(EXPIRE_THREAD_INITIAL_SLEEP);


    //
    // Forever loop
    //
    while(1)
    {
        PTLSDbWorkSpace pDbWkSpace = NULL;
        LICENSEDCLIENT found_license;
        TLSLICENSEPACK search_keypack;
        TLSLICENSEPACK found_keypack;

        search_license.ftExpireDate = time(NULL);

        memset(&found_license,0,sizeof(found_license));
        memset(&search_keypack,0,sizeof(search_keypack));
        memset(&found_keypack,0,sizeof(found_keypack));

        if (!(ALLOCATEDBHANDLE(pDbWkSpace, g_EnumDbTimeout)))
        {
            goto do_sleep;
        }

        TLSDBLockKeyPackTable();
        TLSDBLockLicenseTable();

        CLEANUPSTMT;

        dwStatus = TLSDBLicenseEnumBeginEx(
                              USEHANDLE(pDbWkSpace),
                              TRUE,
                              LSLICENSE_SEARCH_EXPIREDATE,
                              &search_license,
                              JET_bitSeekLE
                              );

        if (ERROR_SUCCESS != dwStatus)
        {
            TLSDBUnlockLicenseTable();        
            TLSDBUnlockKeyPackTable();
            FREEDBHANDLE(pDbWkSpace);

            goto do_sleep;

        }

        while (1)
        {
            dwStatus = TLSDBLicenseEnumNextEx(
                              USEHANDLE(pDbWkSpace),
                              TRUE,    // bReverse
                              TRUE,     // bAnyRecord
                              &found_license
                              );

            if(dwStatus != ERROR_SUCCESS)
            {
                goto next_time;
            }

            //
            // See if this is the right product type
            //
            search_keypack.dwKeyPackId = found_license.dwKeyPackId;

            dwStatus = TLSDBKeyPackFind(
                          USEHANDLE(pDbWkSpace),
                          TRUE,
                          LSKEYPACK_EXSEARCH_DWINTERNAL,
                          &search_keypack,
                          &found_keypack
                          );

            if(dwStatus != ERROR_SUCCESS)
            {
                continue;
            }

            //
            // only check licenses that we reissue
            //
            if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
               found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT &&
               found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE &&
               found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN )
            {
                continue;
            }

            UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus &
                    ~LSKEYPACKSTATUS_RESERVED;

            //
            // Don't check pending activation key pack
            //
            if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE)
            {
                continue;
            }

            //
            // Only check per-seat and concurrent
            //
            if ((_tcsnicmp(found_keypack.szProductId,
                         TERMSERV_PRODUCTID_SKU,
                         _tcslen(TERMSERV_PRODUCTID_SKU)) != 0)
                && (_tcsnicmp(found_keypack.szProductId,
                         TERMSERV_PRODUCTID_CONCURRENT_SKU,
                         _tcslen(TERMSERV_PRODUCTID_CONCURRENT_SKU)) != 0))
            {
                continue;
            }

            BEGIN_TRANSACTION(pDbWorkSpace);

            //
            //  Return currently enumerated license.
            //

            dwStatus = TLSDBDeleteEnumeratedLicense(USEHANDLE(pDbWkSpace));

            if (dwStatus == ERROR_SUCCESS)
            {
                //
                //  Adjust available license number.
                //

                dwStatus = TLSDBReturnLicenseToKeyPack(
                            USEHANDLE(pDbWkSpace),
                            found_license.dwKeyPackId,
                            1
                            );
            }

            if (dwStatus == ERROR_SUCCESS)
            {
                COMMIT_TRANSACTION(pDbWkSpace);

                InterlockedIncrement(&g_lPermanentLicensesReturned);
            }
            else
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            
        }

next_time:

        TLSDBLicenseEnumEnd(USEHANDLE(pDbWkSpace));

        TLSDBUnlockLicenseTable();        
        TLSDBUnlockKeyPackTable();

        FREEDBHANDLE(pDbWkSpace);

do_sleep:

        if (WAIT_OBJECT_0 == WaitForSingleObject(GetServiceShutdownHandle(),g_dwReissueExpireThreadSleep))
        {
            break;
        }

        DBGPrintf(
                  DBG_INFORMATION,
                  DBG_FACILITY_RPC,
                  DBGLEVEL_FUNCTION_DETAILSIMPLE,
                  _TEXT("ExpirePermanent : woke up\n")
                  );                

    }
            
    //
    // Initializer function will close the event handle
    //

    return dwStatus;
}


//---------------------------------------------------------------------
DWORD
InitExpirePermanentThread()
/*++

++*/
{
    HANDLE hThread = NULL;
    unsigned int  dwThreadId;
    HANDLE hEvent = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE waithandles[2];


    //
    // Create a event for namedpipe thread to signal it is ready.
    //
    hEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,  // non-signal
                        NULL
                    );
        
    if(hEvent == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hThread = (HANDLE)_beginthreadex(
                                NULL,
                                0,
                                ExpirePermanentThread,
                                hEvent,
                                0,
                                &dwThreadId
                            );

    if(hThread == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    waithandles[0] = hEvent;
    waithandles[1] = hThread;
    
    //
    // Wait 30 second for thread to complete initialization
    //
    dwStatus = WaitForMultipleObjects(
                                sizeof(waithandles)/sizeof(waithandles[0]), 
                                waithandles, 
                                FALSE,
                                30*1000
                            );

    if(dwStatus == WAIT_OBJECT_0)
    {    
        //
        // thread is ready
        //
        dwStatus = ERROR_SUCCESS;
    }
    else 
    {
        if(dwStatus == (WAIT_OBJECT_0 + 1))
        {
            //
            // Thread terminate abnormally
            //
            GetExitCodeThread(
                        hThread,
                        &dwStatus
                    );
        }
        else
        {
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        }
    }
    

cleanup:

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hThread != NULL)
    {
        CloseHandle(hThread);
    }


    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\findlost.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        findlost.cpp
//
// Contents:    
//              Find lost license
//
// History:     
//              Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "findlost.h"
#include "misc.h"
#include "db.h"
#include "clilic.h"
#include "keypack.h"
#include "kp.h"
#include "lkpdesc.h"

//++-------------------------------------------------------------------
DWORD
DBFindLicenseExact(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICENSEDPRODUCT pLicProduct,
    OUT LICENSEDCLIENT *pFoundLicense
    )
/*++

Abstract:

    Find license based on exact match of client HWID

Parameter:

    pDbWkSpace : workspace handle.
    pLicProduct : product to request license.
    pFoundLicense: found license

Returns:

    TLS_E_RECORD_NOTFOUND: HWID not found
++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL  bFound=FALSE;
    DWORD dwMatchHwidCount;
    LICENSEDCLIENT search_license;
    TLSLICENSEPACK search_keypack;
    TLSLICENSEPACK found_keypack;

    memset(&search_license, 0, sizeof(search_license));
    memset(pFoundLicense, 0, sizeof(LICENSEDCLIENT));

    search_license.dwSystemBiosChkSum = pLicProduct->Hwid.dwPlatformID;
    search_license.dwVideoBiosChkSum = pLicProduct->Hwid.Data1;
    search_license.dwFloppyBiosChkSum = pLicProduct->Hwid.Data2;
    search_license.dwHardDiskSize = pLicProduct->Hwid.Data3; 
    search_license.dwRamSize = pLicProduct->Hwid.Data4;

    //
    // lock both tables - 
    //   Other threads might be in the process of allocating a temp. license
    //   while this thread is searching
    //
    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    dwStatus = TLSDBLicenseEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LICENSE_COLUMN_SEARCH_HWID,
                                &search_license
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while(bFound == FALSE)
    {
        dwStatus = TLSDBLicenseEnumNext(
                                    pDbWkSpace,
                                    pFoundLicense
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Verify against client HWID
        //
        dwMatchHwidCount = 0;

        dwMatchHwidCount += (pFoundLicense->dwSystemBiosChkSum == pLicProduct->Hwid.dwPlatformID);
        dwMatchHwidCount += (pFoundLicense->dwVideoBiosChkSum == pLicProduct->Hwid.Data1);
        dwMatchHwidCount += (pFoundLicense->dwFloppyBiosChkSum == pLicProduct->Hwid.Data2);
        dwMatchHwidCount += (pFoundLicense->dwHardDiskSize == pLicProduct->Hwid.Data3);
        dwMatchHwidCount += (pFoundLicense->dwRamSize == pLicProduct->Hwid.Data4);

        if(dwMatchHwidCount != 5)
        {
            break;
        }

        //
        // See if this match our license pack
        //
        search_keypack.dwKeyPackId = pFoundLicense->dwKeyPackId;
        
        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_EXSEARCH_DWINTERNAL,
                                &search_keypack,
                                &found_keypack
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            continue;
        }

        //
        // No actual license is issued for concurrent KeyPack.
        //
        if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT && 
           found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_TEMPORARY &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE )
        {
            continue;
        }

        UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        //
        // No license for pending activation key pack, use temporary license scheme.
        //                
        if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE &&
           ucKeyPackStatus != LSKEYPACKSTATUS_TEMPORARY)
        {
            continue;
        }

        if(found_keypack.wMajorVersion != pLicProduct->pLicensedVersion->wMajorVersion ||
           found_keypack.wMinorVersion != pLicProduct->pLicensedVersion->wMinorVersion)
        {
            continue;
        }

        if(found_keypack.dwPlatformType != pLicProduct->LicensedProduct.dwPlatformID)
        {
            continue;
        }

        if(_tcsnicmp(found_keypack.szProductId,
                     (LPTSTR)(pLicProduct->pbOrgProductID),
                     ((pLicProduct->cbOrgProductID)/sizeof(TCHAR)) - 1)
           != 0)
        {
            continue;
        }


        //
        // Found our lost license.
        //
        bFound = TRUE;
    }

    TLSDBLicenseEnumEnd(pDbWkSpace);

cleanup:
    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();

    return dwStatus;

}

//++-------------------------------------------------------------------
DWORD
DBFindLostLicenseExact(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBAllocateRequest pRequest,    // ucKeyPackType not use
    // IN BOOL bMatchHwid,
    IN PHWID pHwid,
    IN OUT PTLSLICENSEPACK lpKeyPack,
    IN OUT PLICENSEDCLIENT lpLicense
    )
/*++

Abstract:

    Find lost license base on exact/closest match of client HWID

Parameter:

    pDbWkSpace : workspace handle.
    pRequest : product to request license.
    bMatchHwid : TRUE if match HWID, FALSE otherwise.
    lpKeyPack : keyPack that license was issued from.
    lpLicense : Founded license record.

Returns:

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL  bFound=FALSE;

    DWORD dwMatchHwidCount;
    LICENSEDCLIENT search_license;
    LICENSEDCLIENT found_license;

    TLSLICENSEPACK search_keypack;
    TLSLICENSEPACK found_keypack;



    //
    // Ignore ucKeyPackType
    //
    pRequest->ucAgreementType = LSKEYPACKTYPE_FIRST;
    dwStatus = VerifyTLSDBAllocateRequest(pRequest);
    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    memset(&search_license, 0, sizeof(search_license));
    memset(&found_license, 0, sizeof(found_license));

    search_license.dwSystemBiosChkSum = pHwid->dwPlatformID;
    search_license.dwVideoBiosChkSum = pHwid->Data1;
    search_license.dwFloppyBiosChkSum = pHwid->Data2;
    search_license.dwHardDiskSize = pHwid->Data3; 
    search_license.dwRamSize = pHwid->Data4;

    //
    // lock both table - 
    //   Other thread might be in the process of allocating a temp. license while this 
    //   thread try to delete the temp. key pack.
    //
    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    dwStatus = TLSDBLicenseEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LICENSE_COLUMN_SEARCH_HWID,
                                &search_license
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while(bFound == FALSE)
    {
        dwStatus = TLSDBLicenseEnumNext(
                                    pDbWkSpace,
                                    &found_license
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Verify against client HWID
        //
        dwMatchHwidCount = 0;

        dwMatchHwidCount += (found_license.dwSystemBiosChkSum == pHwid->dwPlatformID);
        dwMatchHwidCount += (found_license.dwVideoBiosChkSum == pHwid->Data1);
        dwMatchHwidCount += (found_license.dwFloppyBiosChkSum == pHwid->Data2);
        dwMatchHwidCount += (found_license.dwHardDiskSize == pHwid->Data3);
        dwMatchHwidCount += (found_license.dwRamSize == pHwid->Data4);

        if(dwMatchHwidCount != 5)
        {
            break;
        }

        //
        // consider only valid license 
        //
        if( found_license.ucLicenseStatus != LSLICENSE_STATUS_ACTIVE && 
            found_license.ucLicenseStatus != LSLICENSE_STATUS_PENDING &&
            found_license.ucLicenseStatus != LSLICENSE_STATUS_TEMPORARY)
        {
            continue;
        }

        //
        // See if this match our license pack
        //
        search_keypack.dwKeyPackId = found_license.dwKeyPackId;
        
        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_EXSEARCH_DWINTERNAL,
                                &search_keypack,
                                &found_keypack
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            continue;
        }

        //
        // No actual license is issued for concurrent KeyPack.
        //
        if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT && 
           found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_TEMPORARY &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE )
        {
            continue;
        }

        UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        //
        // No license for pending activation key pack, use temporary license scheme.
        //                
        if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE &&
           ucKeyPackStatus != LSKEYPACKSTATUS_TEMPORARY)
        {
            continue;
        }

        if(found_keypack.wMajorVersion != HIWORD(pRequest->dwVersion) ||
           found_keypack.wMinorVersion != LOWORD(pRequest->dwVersion)  )
        {
            continue;
        }

        if(found_keypack.dwPlatformType != pRequest->dwPlatformId)
        {
            continue;
        }

        if(_tcscmp(found_keypack.szCompanyName, pRequest->szCompanyName) != 0)
        {
            continue;
        }

        if(_tcscmp(found_keypack.szProductId, pRequest->szProductId) != 0)
        {
            continue;
        }


        //
        // Found our lost license.
        //
        bFound = TRUE;
        *lpLicense = found_license;
        *lpKeyPack = found_keypack;
    }

    TLSDBLicenseEnumEnd(pDbWkSpace);

cleanup:
    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();

    return dwStatus;
}


//++-------------------------------------------------------------------
DWORD
DBFindLostLicenseMatch(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBAllocateRequest pRequest,    // ucKeyPackType not use
    IN BOOL bMatchHwid,
    IN PHWID pHwid,
    IN OUT PTLSLICENSEPACK lpKeyPack,
    IN OUT PLICENSEDCLIENT lpLicense
    )
/*++

Abstract:

    Find lost license base on exact/closest match of client HWID

Parameter:

    pDbWkSpace : workspace handle.
    pRequest : product to request license.
    bMatchHwid : TRUE if match HWID, FALSE otherwise.
    lpKeyPack : keyPack that license was issued from.
    lpLicense : Founded license record.

Returns:

++*/
{
    DWORD status=ERROR_SUCCESS;
    BOOL  bFound=FALSE;

    TLSLICENSEPACK search_keypack;
    TLSLICENSEPACK found_keypack;
    DWORD dwMatchHwidCount;

    found_keypack.pbDomainSid = NULL;

    //
    // Ignore ucKeyPackType
    //
    pRequest->ucAgreementType = LSKEYPACKTYPE_FIRST;
    status = VerifyTLSDBAllocateRequest(pRequest);
    if(status != ERROR_SUCCESS)
        return status;

    
    LICENSEDCLIENT search_license;
    LICENSEDCLIENT found_license;


    //---------------------------------------------------------------------------
    // Set up search parameter
    //
    memset(&search_keypack, 0, sizeof(search_keypack));

    _tcscpy(search_keypack.szCompanyName, pRequest->szCompanyName);
    _tcscpy(search_keypack.szProductId, pRequest->szProductId);
    search_keypack.wMajorVersion = HIWORD(pRequest->dwVersion);
    search_keypack.wMinorVersion = LOWORD(pRequest->dwVersion);
    search_keypack.dwPlatformType = pRequest->dwPlatformId;

    //
    // lock both table - 
    //   Other thread might be in the process of allocating a temp. license while this 
    //   thread try to delete the temp. key pack.
    //
    TLSDBLockKeyPackTable();
    TLSDBLockLicenseTable();

    //
    // KeyPack table index is based on keypack type
    //
    status=TLSDBKeyPackEnumBegin(
                            pDbWkSpace, 
                            TRUE, 
                            LSKEYPACK_SEARCH_PRODUCTID,
                            &search_keypack
                        );
    if(status != ERROR_SUCCESS)
        goto cleanup;

   
    while( !bFound )
    {
        status = TLSDBKeyPackEnumNext(
                                pDbWkSpace,
                                &found_keypack
                            );
        if(status != ERROR_SUCCESS)
            break;

        //
        // No actual license is issued for concurrent KeyPack.
        //
        if(found_keypack.ucAgreementType != LSKEYPACKTYPE_RETAIL &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_SELECT && 
           found_keypack.ucAgreementType != LSKEYPACKTYPE_OPEN &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_TEMPORARY &&
           found_keypack.ucAgreementType != LSKEYPACKTYPE_FREE )
        {
            continue;
        }

        UCHAR ucKeyPackStatus = found_keypack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        //
        // No license for pending activation key pack, use temporary license scheme.
        //                
        if(ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE &&
           ucKeyPackStatus != LSKEYPACKSTATUS_TEMPORARY)
        {
            continue;
        }

        if(found_keypack.wMajorVersion != search_keypack.wMajorVersion ||
           found_keypack.wMinorVersion != search_keypack.wMinorVersion  )
        {
            continue;
        }

        if(found_keypack.dwPlatformType != search_keypack.dwPlatformType)
        {
            continue;
        }

        if(_tcscmp(found_keypack.szCompanyName, search_keypack.szCompanyName) != 0)
        {
            continue;
        }

        if(_tcscmp(found_keypack.szProductId, search_keypack.szProductId) != 0)
        {
            continue;
        }

        // we found a candidate keypack, look into license table

        memset(&search_license, 0, sizeof(search_license));
        memset(&found_license, 0, sizeof(found_license));

        search_license.dwKeyPackId = found_keypack.dwKeyPackId;

        status = TLSDBLicenseEnumBegin(
                            pDbWkSpace,
                            TRUE,
                            LICENSE_PROCESS_KEYPACKID,
                            &search_license
                        );

        if(status != ERROR_SUCCESS)
            break;

        while( bFound == FALSE )
        {
            status = TLSDBLicenseEnumNext(
                                pDbWkSpace,
                                &found_license
                            );

            if(status != ERROR_SUCCESS)
                break;

            //
            // consider only valid license 
            //
            if( found_license.ucLicenseStatus != LSLICENSE_STATUS_ACTIVE && 
                found_license.ucLicenseStatus != LSLICENSE_STATUS_PENDING &&
                found_license.ucLicenseStatus != LSLICENSE_STATUS_TEMPORARY)
            {
                continue;
            }

            //
            // Verify against client HWID
            //
            dwMatchHwidCount = 0;

            dwMatchHwidCount += (found_license.dwSystemBiosChkSum == pHwid->dwPlatformID);
            dwMatchHwidCount += (found_license.dwVideoBiosChkSum == pHwid->Data1);
            dwMatchHwidCount += (found_license.dwFloppyBiosChkSum == pHwid->Data2);
            dwMatchHwidCount += (found_license.dwHardDiskSize == pHwid->Data3);
            dwMatchHwidCount += (found_license.dwRamSize == pHwid->Data4);

            if(dwMatchHwidCount == 5 || (bMatchHwid == FALSE && dwMatchHwidCount >= LICENSE_MIN_MATCH))
            {
                bFound = TRUE;
                *lpLicense = found_license;
                *lpKeyPack = found_keypack;
            }
        }

        TLSDBLicenseEnumEnd(pDbWkSpace);
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);

cleanup:
    //FreeTlsLicensePack(&found_keypack);

    if(status == TLS_I_NO_MORE_DATA)
    {
        SetLastError(status = TLS_E_RECORD_NOTFOUND);
    }

    TLSDBUnlockLicenseTable();
    TLSDBUnlockKeyPackTable();

    return status;
}
                  
//++--------------------------------------------------------------------
DWORD
TLSFindLicense(
    IN PLICENSEDPRODUCT pLicProduct,
    OUT PLICENSEDCLIENT pLicClient
    )
{
    PTLSDbWorkSpace pDbWkSpace = NULL;
    DWORD status = ERROR_SUCCESS;

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);

    if(pDbWkSpace == NULL)
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    status = DBFindLicenseExact(pDbWkSpace,pLicProduct,pLicClient);

    ReleaseWorkSpace(&pDbWkSpace);

cleanup:

    return status;
}

//++--------------------------------------------------------------------
DWORD
TLSFindDbLicensedProduct(
    IN PTLSDBLICENSEDPRODUCT pDbLicProduct,
    OUT PLICENSEDCLIENT pLicClient
    )
{
    PTLSDbWorkSpace pDbWkSpace = NULL;
    DWORD status = ERROR_SUCCESS;
    LICENSEDPRODUCT LicProduct;
    LICENSED_VERSION_INFO LicVerInfo;

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);

    if(pDbWkSpace == NULL)
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    memcpy(&(LicProduct.Hwid), &(pDbLicProduct->ClientHwid), sizeof(HWID));
    LicVerInfo.wMajorVersion = HIWORD(pDbLicProduct->dwProductVersion);
    LicVerInfo.wMinorVersion = LOWORD(pDbLicProduct->dwProductVersion);
    LicProduct.pLicensedVersion = &LicVerInfo;
    LicProduct.LicensedProduct.dwPlatformID = pDbLicProduct->dwPlatformID;
    LicProduct.pbOrgProductID = (PBYTE)(pDbLicProduct->szLicensedProductId);
    LicProduct.cbOrgProductID = _tcslen(pDbLicProduct->szLicensedProductId) * sizeof(TCHAR);

    status = DBFindLicenseExact(pDbWkSpace,&LicProduct,pLicClient);

    ReleaseWorkSpace(&pDbWkSpace);

cleanup:

    return status;
}

//++--------------------------------------------------------------------
DWORD
TLSDBFindLostLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pLicenseRequest,
    IN PHWID pHwid,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    OUT PUCHAR pucMarked
    )
/*++

Abstract:

    Wrapper to DBFindLostLicense().

    See DBFindLostLicense.


++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    TLSLICENSEPACK keypack;
    LICENSEDCLIENT License;

    ULARGE_INTEGER ulSerialNumber;

    FILETIME notBefore;
    FILETIME notAfter;
    PMGENERATELICENSE PolModGenLicense;
    PPMCERTEXTENSION pPolModCertExtension=NULL;
    PMLICENSEREQUEST PolRequest;
    TLSDBAllocateRequest AllocateRequest;

    DWORD dwRetCode=ERROR_SUCCESS;

    keypack.pbDomainSid = NULL;
    AllocateRequest.szCompanyName = (LPTSTR)pLicenseRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pLicenseRequest->pszProductId;
    AllocateRequest.dwVersion = pLicenseRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pLicenseRequest->dwPlatformID;
    AllocateRequest.dwLangId = pLicenseRequest->dwLanguageID;
    AllocateRequest.dwNumLicenses = 1;

    dwStatus = DBFindLostLicenseExact(
                            pDbWkSpace,
                            &AllocateRequest,
                            //TRUE,
                            pHwid,
                            &keypack,
                            &License
                        ); 

#if 0
    //
    // TermSrv does not support matching, comment out for now
    //
    if(dwStatus == TLS_E_RECORD_NOTFOUND)
    {
        //
        // find by matching, very expensive operation
        //
        dwStatus = DBFindLostLicenseMatch(
                                pDbWkSpace,
                                &AllocateRequest,
                                FALSE,
                                pHwid,
                                &keypack,
                                &License
                            ); 

        if(dwStatus == ERROR_SUCCESS)
        {
            dwRetCode = TLS_W_LICENSE_PROXIMATE;
        }
    }
#endif

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    UnixTimeToFileTime(License.ftIssueDate, &notBefore);
    UnixTimeToFileTime(License.ftExpireDate, &notAfter);

    ulSerialNumber.LowPart = License.dwLicenseId;
    ulSerialNumber.HighPart = keypack.dwKeyPackId;

    PolRequest.dwProductVersion = MAKELONG(keypack.wMinorVersion, keypack.wMajorVersion);
    PolRequest.pszProductId = (LPTSTR)keypack.szProductId;
    PolRequest.pszCompanyName = (LPTSTR)keypack.szCompanyName;
    PolRequest.dwLanguageId = pLicenseRequest->dwLanguageID; 
    PolRequest.dwPlatformId = keypack.dwPlatformType;
    PolRequest.pszMachineName = License.szMachineName;
    PolRequest.pszUserName = License.szUserName;

    //
    // Inform Policy Module of license generation.
    // 
    PolModGenLicense.pLicenseRequest = &PolRequest;
    PolModGenLicense.dwKeyPackType = keypack.ucAgreementType;
    PolModGenLicense.dwKeyPackId = keypack.dwKeyPackId;
    PolModGenLicense.dwKeyPackLicenseId = License.dwKeyPackLicenseId;
    PolModGenLicense.ClientLicenseSerialNumber = ulSerialNumber;
    PolModGenLicense.ftNotBefore = notBefore;
    PolModGenLicense.ftNotAfter = notAfter;

    dwStatus = pLicenseRequest->pPolicy->PMLicenseRequest( 
                                pLicenseRequest->hClient,
                                REQUEST_GENLICENSE,
                                (PVOID)&PolModGenLicense,
                                (PVOID *)&pPolModCertExtension
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Error in policy module
        //
        goto cleanup;
    }

    //  
    // Check error return from policy module
    //
    if(pPolModCertExtension != NULL)
    {
        if(pPolModCertExtension->pbData != NULL && pPolModCertExtension->cbData == 0 ||
           pPolModCertExtension->pbData == NULL && pPolModCertExtension->cbData != 0  )
        {
            // assuming no extension data
            pPolModCertExtension->cbData = 0;
            pPolModCertExtension->pbData = NULL;
        }

        if(CompareFileTime(&(pPolModCertExtension->ftNotBefore), &(pPolModCertExtension->ftNotAfter)) > 0)
        {
            //
            // invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pLicenseRequest->pPolicy->GetCompanyName(),
                    pLicenseRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }

        //
        // Ignore not before and not after
        //
    }

    if(keypack.ucAgreementType == LSKEYPACKTYPE_TEMPORARY)
    {
        //
        // we found a temporary license
        //
        dwRetCode = TLS_I_FOUND_TEMPORARY_LICENSE;
    }

    //
    // License expired
    //
    if(License.ftExpireDate < time(NULL))
    {   
        dwRetCode = TLS_E_LICENSE_EXPIRED;
    }

    //
    // Return licensed product
    //
    pLicensedProduct->pSubjectPublicKeyInfo = NULL;
    pLicensedProduct->dwQuantity = License.dwNumLicenses;
    pLicensedProduct->ulSerialNumber = ulSerialNumber;

    pLicensedProduct->dwKeyPackId = keypack.dwKeyPackId;
    pLicensedProduct->dwLicenseId = License.dwLicenseId;
    pLicensedProduct->dwKeyPackLicenseId = License.dwKeyPackLicenseId;

    pLicensedProduct->ClientHwid.dwPlatformID = License.dwSystemBiosChkSum;
    pLicensedProduct->ClientHwid.Data1 = License.dwVideoBiosChkSum;
    pLicensedProduct->ClientHwid.Data2 = License.dwFloppyBiosChkSum;
    pLicensedProduct->ClientHwid.Data3 = License.dwHardDiskSize;
    pLicensedProduct->ClientHwid.Data4 = License.dwRamSize;


    pLicensedProduct->bTemp = (keypack.ucAgreementType == LSKEYPACKTYPE_TEMPORARY);

    pLicensedProduct->NotBefore = notBefore;
    pLicensedProduct->NotAfter = notAfter;

    pLicensedProduct->dwProductVersion = MAKELONG(keypack.wMinorVersion, keypack.wMajorVersion);

    _tcscpy(pLicensedProduct->szCompanyName, keypack.szCompanyName);
    _tcscpy(pLicensedProduct->szLicensedProductId, keypack.szProductId);
    _tcscpy(pLicensedProduct->szRequestProductId, pLicenseRequest->pClientLicenseRequest->pszProductId);

    _tcscpy(pLicensedProduct->szUserName, License.szUserName);
    _tcscpy(pLicensedProduct->szMachineName, License.szMachineName);

    pLicensedProduct->dwLanguageID = pLicenseRequest->dwLanguageID;
    pLicensedProduct->dwPlatformID = pLicenseRequest->dwPlatformID;
    pLicensedProduct->pbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->pbData : NULL;
    pLicensedProduct->cbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->cbData : 0;

    if (NULL != pucMarked)
    {
        // this field is being reused for marking (e.g. user is authenticated)

        *pucMarked = License.ucEntryStatus;
    }

cleanup:
    return (dwStatus == ERROR_SUCCESS) ? dwRetCode : dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\errcode.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        errcode.cpp
//
// Contents:    Convert License Server error code to TLSAPI return code
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "messages.h"

//+------------------------------------------------------------------------
// Function:   
//      LSMapReturnCode()
//     
// Description:
//      Map license server internal code to RPC return code
//
// Arguments:
//      dwCode - license server internal code
//
// Return Value:  
//      RPC return code.
//
// Note:
//      Internal routine within this file.           
//-------------------------------------------------------------------------
DWORD
TLSMapReturnCode(DWORD dwCode)
{
    static struct _TLSMapReturnCode {
        DWORD dwErrCode;
        DWORD dwReturnCode;
    } MapReturnCode[] = {
        {ERROR_SUCCESS,                     LSERVER_S_SUCCESS},
        {TLS_I_SERVICE_STOP,                LSERVER_I_SERVICE_SHUTDOWN},
        {TLS_I_NO_MORE_DATA,                LSERVER_I_NO_MORE_DATA},
        {TLS_W_LICENSE_PROXIMATE,           LSERVER_I_PROXIMATE_LICENSE},
        {TLS_W_TEMPORARY_LICENSE_ISSUED,    LSERVER_I_TEMPORARY_LICENSE},
        {TLS_I_FOUND_TEMPORARY_LICENSE,     LSERVER_I_TEMPORARY_LICENSE},
        {TLS_E_INTERNAL,                    LSERVER_E_INTERNAL_ERROR},
        {TLS_E_ACCESS_DENIED,               LSERVER_E_ACCESS_DENIED},
        {TLS_E_DUPLICATE_RECORD,            LSERVER_E_DUPLICATE},
        {TLS_E_SPKALREADYEXIST,             LSERVER_E_DUPLICATE},
        {ERROR_INVALID_HANDLE,              LSERVER_E_INVALID_HANDLE},
        {TLS_E_INVALID_SEQUENCE,            LSERVER_E_INVALID_SEQUENCE},
        {TLS_E_ALLOCATE_HANDLE,             LSERVER_E_SERVER_BUSY},
        {ERROR_OUTOFMEMORY,                 LSERVER_E_OUTOFMEMORY},
        {TLS_E_INVALID_DATA,                LSERVER_E_INVALID_DATA},
        {ERROR_INVALID_DATA,                LSERVER_E_INVALID_DATA},
        {TLS_E_DECODE_LKP,                  LSERVER_E_INVALID_DATA},
        {TLS_E_RECORD_NOTFOUND,             LSERVER_E_DATANOTFOUND},
        {TLS_E_SERVERLOOKUP,                LSERVER_E_DATANOTFOUND}, 
        {TLS_E_NO_LICENSE,                  LSERVER_E_NO_LICENSE},
        {TLS_E_PRODUCT_NOTINSTALL,          LSERVER_E_NO_PRODUCT},
        //{TLS_E_LICENSE_REJECTED,            LSERVER_E_LICENSE_REJECTED},
        //{TLS_E_LICENSE_REVOKED,             LSERVER_E_LICENSE_REVOKED},
        {TLS_E_CORRUPT_DATABASE,            LSERVER_E_CORRUPT_DATABASE},
        {TLS_E_LICENSE_EXPIRED,             LSERVER_E_LICENSE_EXPIRED},
        {TLS_I_LICENSE_UPGRADED,            LSERVER_I_LICENSE_UPGRADED},
        {TLS_E_NOTSUPPORTED,                LSERVER_E_NOTSUPPORTED},
        {TLS_E_NO_CERTIFICATE,              LSERVER_E_NO_CERTIFICATE},
        {TLS_W_REMOVE_TOOMANY,              LSERVER_I_REMOVE_TOOMANY},
        {TLS_E_DECODE_KEYPACKBLOB,          LSERVER_E_INVALID_DATA},
        {TLS_W_SELFSIGN_CERTIFICATE,        LSERVER_I_SELFSIGN_CERTIFICATE},
        {TLS_W_TEMP_SELFSIGN_CERT,          LSERVER_I_TEMP_SELFSIGN_CERT},
        {TLS_E_CH_INSTALL_NON_LSCERTIFICATE, LSERVER_E_NOT_LSCERTIFICATE},
        {TLS_E_POLICYMODULEERROR,            LSERVER_E_POLICYMODULEERROR},
        {TLS_E_POLICYMODULEEXCEPTION,       LSERVER_E_POLICYMODULEERROR},
        {TLS_E_INCOMPATIBLEVERSION,         LSERVER_E_INCOMPATIBLE},
        {TLS_E_INVALID_SPK,                 LSERVER_E_INVALID_SPK},
        {TLS_E_INVALID_LKP,                 LSERVER_E_INVALID_LKP},
        {TLS_E_SPK_INVALID_SIGN,            LSERVER_E_INVALID_SIGN},
        {TLS_E_LKP_INVALID_SIGN,            LSERVER_E_INVALID_SIGN},
        {TLS_E_NOPOLICYMODULE,              LSERVER_E_NOPOLICYMODULE},
        {TLS_E_POLICYERROR,                 LSERVER_E_POLICYDENYREQUEST}
    };
    
    static numMapReturnCode=sizeof(MapReturnCode)/sizeof(MapReturnCode[0]);
        
    DWORD fStatus;

    for(int i=0; i < numMapReturnCode && MapReturnCode[i].dwErrCode != dwCode; i++);

    if(i >= numMapReturnCode)
    {
        fStatus = dwCode;
        // DebugBreak();
    }
    else
    {
        fStatus = MapReturnCode[i].dwReturnCode;
    }

    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\defpol.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        defpol.cpp
//
// Contents:    Default policy module
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "tlspol.h"
#include "policy.h"


//---------------------------------------------------------------
//
// Default Policy Module Function.
//
//---------------------------------------------------------------
POLICYSTATUS WINAPI
PMInitialize(
    DWORD dwLicenseServerVersion,    // HIWORD is major, LOWORD is minor
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductCode,
    PDWORD pdwNumProduct,
    PPMSUPPORTEDPRODUCT* ppszProduct,
    PDWORD pdwErrCode
    )
/*++


--*/
{
    *pdwNumProduct = 0;
    *ppszProduct = NULL;
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}
   
//-------------------------------------------------------
POLICYSTATUS WINAPI
PMReturnLicense(
	PMHANDLE hClient,
	ULARGE_INTEGER* pLicenseSerialNumber,
	PPMLICENSETOBERETURN pLicenseTobeReturn,
	PDWORD pdwLicenseStatus,
    PDWORD pdwErrCode
    )
/*++

++*/
{

    //
    // default return license is always delete old license
    // and return license to license pack
    //

    *pdwLicenseStatus = LICENSE_RETURN_DELETE;
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------
POLICYSTATUS WINAPI
PMInitializeProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHCode,
    LPCTSTR pszTLSCode,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    //
    // Initialize internal data here
    //
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------
POLICYSTATUS WINAPI
PMUnloadProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHCode,
    LPCTSTR pszTLSCode,
    PDWORD pdwErrCode
    )
/*++

++*/
{

    //
    // Free all internal data here
    //
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------
void WINAPI
PMTerminate()
/*++

++*/
{

    //
    // Free internal data here
    //

    return;
}

//--------------------------------------------------------------

POLICYSTATUS
ProcessLicenseRequest(
    PMHANDLE client,
    PPMLICENSEREQUEST pbRequest,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    *pbAdjustedRequest = pbRequest;

    if(pbRequest->dwLicenseType != LICENSETYPE_LICENSE)
    {
        dwStatus = POLICY_NOT_SUPPORTED;
        *pdwErrCode = TLS_E_NOCONCURRENT;
    }

    return dwStatus;
}


//--------------------------------------------------------------

POLICYSTATUS
ProcessAllocateRequest(
    PMHANDLE client,
    DWORD dwSuggestType,
    PDWORD pdwKeyPackType,
    PDWORD pdwErrCode
    )    
/*++

    Default sequence is always FREE/RETAIL/OPEN/SELECT/TEMPORARY

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwSuggestType)
    {
        case LSKEYPACKTYPE_UNKNOWN:
            *pdwKeyPackType = LSKEYPACKTYPE_FREE;
            break;

        case LSKEYPACKTYPE_FREE:
            *pdwKeyPackType = LSKEYPACKTYPE_RETAIL;
            break;

        case LSKEYPACKTYPE_RETAIL:
            *pdwKeyPackType = LSKEYPACKTYPE_OPEN;
            break;

        case LSKEYPACKTYPE_OPEN:
            *pdwKeyPackType = LSKEYPACKTYPE_SELECT;
            break;

        case LSKEYPACKTYPE_SELECT:
            //
            // No more keypack to look for, instruct license
            // server to terminate.
            //
            *pdwKeyPackType = LSKEYPACKTYPE_UNKNOWN;
            break;

        default:

            //
            // Instruct License Server to terminate request
            //
            *pdwKeyPackType = LSKEYPACKTYPE_UNKNOWN;
    }        

    *pdwErrCode = ERROR_SUCCESS;
    return dwStatus;
}

//-------------------------------------------------------------

POLICYSTATUS
ProcessGenLicenses(
    PMHANDLE client,
    PPMGENERATELICENSE pGenLicense,
    PPMCERTEXTENSION *pCertExtension,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    // No policy extension to return.
    *pCertExtension = NULL;
    *pdwErrCode = ERROR_SUCCESS;

    return POLICY_SUCCESS;
}

//--------------------------------------------------------------

POLICYSTATUS
ProcessComplete(
    PMHANDLE client,
    DWORD dwErrCode,
    PDWORD pdwRetCode
    )
/*++

++*/
{
    *pdwRetCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}
    

//--------------------------------------------------------------

POLICYSTATUS WINAPI
PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID* pbNewProgressData,
    PDWORD pdwErrCode
    )
/*++


++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch( dwProgressCode )
    {
        case REQUEST_NEW:
            //
            // License Server ask to fine tune the request.
            //
            dwStatus = ProcessLicenseRequest(
                                    client,
                                    (PPMLICENSEREQUEST) pbProgressData,
                                    (PPMLICENSEREQUEST *) pbNewProgressData,
                                    pdwErrCode
                                );
            break;

        case REQUEST_KEYPACKTYPE:
            //
            // License Server ask for the license pack type
            //
            dwStatus = ProcessAllocateRequest(
                                    client,
                                    #ifdef _WIN64
                                    PtrToUlong(pbProgressData),
                                    #else
                                    (DWORD) pbProgressData,
                                    #endif
                                    (PDWORD) pbNewProgressData,
                                    pdwErrCode
        
                                );
            break;

        case REQUEST_TEMPORARY:
            //
            // License Server ask if temporary license should be issued
            //
            *(BOOL *)pbNewProgressData = TRUE;
            *pdwErrCode = ERROR_SUCCESS;
            break;

        case REQUEST_GENLICENSE:
            //
            // License Server ask for certificate extension
            //
            dwStatus = ProcessGenLicenses(
                                    client,
                                    (PPMGENERATELICENSE) pbProgressData,
                                    (PPMCERTEXTENSION *) pbNewProgressData,
                                    pdwErrCode
                                );

            break;


        case REQUEST_COMPLETE:
            //
            // Request complete
            //
            dwStatus = ProcessComplete(
                                    client,
                                    #ifdef _WIN64
                                    PtrToUlong(pbNewProgressData),
                                    #else
                                    (DWORD) pbNewProgressData,
                                    #endif
                                    pdwErrCode
                                );
            break;

        case REQUEST_KEYPACKDESC:
            if(pbNewProgressData != NULL)
            {
                *pbNewProgressData = NULL;
            }

            // FALL THRU

        default:
            *pdwErrCode = ERROR_SUCCESS;
            dwStatus = POLICY_SUCCESS;
    }

    return dwStatus;
}

//------------------------------------------------------------------------
POLICYSTATUS 
ProcessUpgradeRequest(
    PMHANDLE hClient,
    PPMUPGRADEREQUEST pUpgrade,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwRetCode
    )
/*++

++*/
{
    *pdwRetCode = ERROR_SUCCESS;
    *pbAdjustedRequest = pUpgrade->pUpgradeRequest;
    return POLICY_SUCCESS;
}

//------------------------------------------------------------------------

POLICYSTATUS WINAPI
PMLicenseUpgrade(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID *ppbReturnData,
    PDWORD pdwRetCode
    )
/*++

++*/
{   
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwProgressCode)
    {
        case REQUEST_UPGRADE:
                dwStatus = ProcessUpgradeRequest(
                                        hClient,
                                        (PPMUPGRADEREQUEST) pbProgressData,
                                        (PPMLICENSEREQUEST *) ppbReturnData,
                                        pdwRetCode
                                    );

                break;

        case REQUEST_COMPLETE:
                dwStatus = ProcessComplete(
                                        hClient,
                                        #ifdef _WIN64
                                        PtrToUlong(pbProgressData),
                                        #else
                                        (DWORD) (pbProgressData),
                                        #endif
                                        pdwRetCode
                                    );

                break;

        default:
            //assert(FALSE);

            *pdwRetCode = ERROR_SUCCESS;
            dwStatus = POLICY_SUCCESS;
    }
        
    return dwStatus;
}

//------------------------------------------------------------------------

POLICYSTATUS WINAPI
PMRegisterLicensePack(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID pbProgressReturnData,
    PDWORD pdwRetCode
    )
/*++

    Not supported.

--*/
{
    *pdwRetCode = ERROR_INVALID_FUNCTION;
    return POLICY_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\forward.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        forward.cpp
//
// Contents:    Forward license request.
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "srvlist.h"
#include "forward.h"
#include "keypack.h"
#include "postjob.h"


//-----------------------------------------------------------------------

CopyRpcTLSRequestToRequest(
    TLSLICENSEREQUEST* lpRpcRequest ,
    LICENSEREQUEST* lpRequest
    )
/*++

--*/
{
    lpRequest->cbEncryptedHwid = lpRpcRequest->cbEncryptedHwid;
    lpRequest->pbEncryptedHwid = lpRpcRequest->pbEncryptedHwid;
    lpRequest->dwLanguageID = lpRpcRequest->dwLanguageID;
    lpRequest->dwPlatformID = lpRpcRequest->dwPlatformID;
    lpRequest->pProductInfo->dwVersion = lpRpcRequest->ProductInfo.dwVersion;
    lpRequest->pProductInfo->cbCompanyName = lpRpcRequest->ProductInfo.cbCompanyName;
    lpRequest->pProductInfo->pbCompanyName = lpRpcRequest->ProductInfo.pbCompanyName;
    lpRequest->pProductInfo->cbProductID = lpRpcRequest->ProductInfo.cbProductID;
    lpRequest->pProductInfo->pbProductID = lpRpcRequest->ProductInfo.pbProductID;
    return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------
DWORD
ForwardUpgradeLicenseRequest( 
    IN LPTSTR pszServerSetupId,
    IN OUT DWORD *pdwSupportFlags,
    IN TLSLICENSEREQUEST* pRequest,
    IN CHALLENGE_CONTEXT ChallengeContext,
    IN DWORD cbChallengeResponse,
    IN PBYTE pbChallengeResponse,
    IN DWORD cbOldLicense,
    IN PBYTE pbOldLicense,
    OUT PDWORD pcbNewLicense,
    OUT PBYTE* ppbNewLicense,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    TLS_HANDLE hHandle = NULL;
    DWORD dwStatus;
    LICENSEREQUEST LicenseRequest;

    BYTE pbEncryptedHwid[1024];        // encrypted HWID can't be more than 1024
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+2];
    Product_Info ProductInfo;

    TLServerInfo ServerInfo;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardUpgradeLicenseRequest() ...\n")
        );

    dwStatus = TLSLookupRegisteredServer(
                                    pszServerSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(TLSCanForwardRequest(
                        TLS_CURRENT_VERSION,
                        ServerInfo.GetServerVersion()
                    ) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardUpgradeLicenseRequest() to %s %s\n"),
            pszServerSetupId,
            ServerInfo.GetServerName()
        );


    hHandle = TLSConnectToServerWithServerId(pszServerSetupId);
    if(hHandle == NULL)
    {
        //
        // server not available
        //
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // RPC AC if pass in the original address
    // TlsRequestToRequest(pTlsRequest, &LicenseRequest);
    if(pRequest->cbEncryptedHwid >= sizeof(pbEncryptedHwid))
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->ProductInfo.cbCompanyName >= sizeof(szCompanyName) ||
       pRequest->ProductInfo.cbProductID >= sizeof(szProductId)  )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    memset(&LicenseRequest, 0, sizeof(LicenseRequest));

    memcpy(
            pbEncryptedHwid, 
            pRequest->pbEncryptedHwid, 
            pRequest->cbEncryptedHwid
        );

    LicenseRequest.pbEncryptedHwid = pbEncryptedHwid;
    LicenseRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    LicenseRequest.dwLanguageID = pRequest->dwLanguageID;
    LicenseRequest.dwPlatformID = pRequest->dwPlatformID;
    LicenseRequest.pProductInfo = &ProductInfo;

    ProductInfo.dwVersion = pRequest->ProductInfo.dwVersion;
    ProductInfo.pbCompanyName = (PBYTE)szCompanyName;
    ProductInfo.pbProductID = (PBYTE)szProductId;
    ProductInfo.cbCompanyName = pRequest->ProductInfo.cbCompanyName;
    ProductInfo.cbProductID = pRequest->ProductInfo.cbProductID;

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName, 
            pRequest->ProductInfo.pbCompanyName, 
            pRequest->ProductInfo.cbCompanyName
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            pRequest->ProductInfo.cbProductID
        );
    if(IsServiceShuttingdown() == TRUE)
    {
        dwStatus = TLS_I_SERVICE_STOP;
    }
    else
    {
        dwStatus = TLSUpgradeLicenseEx(
                            hHandle,
                            pdwSupportFlags,
                            &LicenseRequest,
                            ChallengeContext,
                            cbChallengeResponse,
                            pbChallengeResponse,
                            cbOldLicense,
                            pbOldLicense,
                            1,  // dwQuantity
                            pcbNewLicense,
                            ppbNewLicense,
                            pdwErrCode
                        );
    }

cleanup:

    if(hHandle)
    {
        TLSDisconnectFromServer(hHandle);           
    }

    return dwStatus;
}

//-----------------------------------------------------------------------

DWORD
ForwardNewLicenseRequest(
    IN LPTSTR pszServerSetupId,
    IN OUT DWORD *pdwSupportFlags,
    IN CHALLENGE_CONTEXT ChallengeContext,
    IN PTLSLICENSEREQUEST pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN DWORD cbChallengeResponse,
    IN PBYTE pbChallengeResponse,
    IN BOOL bAcceptTemporaryLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PDWORD pcbLicense,
    OUT PBYTE *ppbLicense,
    IN OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    TLS_HANDLE hHandle = NULL;
    DWORD dwStatus;
    LICENSEREQUEST LicenseRequest;
    BYTE pbEncryptedHwid[1024];       // encrypted HWID can't be more than 1024
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+2];
    Product_Info ProductInfo;
    TLServerInfo ServerInfo;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardNewLicenseRequest() ...\n")
        );


    dwStatus = TLSLookupRegisteredServer(
                                    pszServerSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(TLSCanForwardRequest(
                        TLS_CURRENT_VERSION,
                        ServerInfo.GetServerVersion()
                    ) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("ForwardNewLicenseRequest() to %s %s\n"),
            pszServerSetupId,
            ServerInfo.GetServerName()
        );

   
    hHandle = TLSConnectToServerWithServerId(pszServerSetupId);
    if(hHandle == NULL)
    {
        //
        // server not available
        //
        dwStatus = GetLastError();
        goto cleanup;
    }

    //TlsRequestToRequest(pRequest, &LicenseRequest);

    if(pRequest->cbEncryptedHwid >= sizeof(pbEncryptedHwid))
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(pRequest->ProductInfo.cbCompanyName >= sizeof(szCompanyName) ||
       pRequest->ProductInfo.cbProductID >= sizeof(szProductId)  )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    memset(&LicenseRequest, 0, sizeof(LicenseRequest));

    memcpy(
            pbEncryptedHwid, 
            pRequest->pbEncryptedHwid, 
            pRequest->cbEncryptedHwid
        );

    LicenseRequest.pbEncryptedHwid = pbEncryptedHwid;
    LicenseRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    LicenseRequest.dwLanguageID = pRequest->dwLanguageID;
    LicenseRequest.dwPlatformID = pRequest->dwPlatformID;
    LicenseRequest.pProductInfo = &ProductInfo;

    ProductInfo.dwVersion = pRequest->ProductInfo.dwVersion;
    ProductInfo.pbCompanyName = (PBYTE)szCompanyName;
    ProductInfo.pbProductID = (PBYTE)szProductId;
    ProductInfo.cbCompanyName = pRequest->ProductInfo.cbCompanyName;
    ProductInfo.cbProductID = pRequest->ProductInfo.cbProductID;

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName, 
            pRequest->ProductInfo.pbCompanyName, 
            pRequest->ProductInfo.cbCompanyName
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            pRequest->ProductInfo.cbProductID
        );

    if(IsServiceShuttingdown() == TRUE)
    {
        dwStatus = TLS_I_SERVICE_STOP;
    }
    else
    {
        dwStatus = TLSIssueNewLicenseExEx(
                            hHandle,
                            pdwSupportFlags,
                            ChallengeContext,
                            &LicenseRequest,
                            pszMachineName,
                            pszUserName,
                            cbChallengeResponse,
                            pbChallengeResponse,
                            bAcceptTemporaryLicense,
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            pcbLicense,
                            ppbLicense,
                            pdwErrCode
                        );
    }

cleanup:

    if(hHandle)
    {
        TLSDisconnectFromServer(hHandle);           
    }

    return dwStatus;
}

//---------------------------------------------------------
DWORD
TLSForwardUpgradeRequest( 
    IN PTLSForwardUpgradeLicenseRequest pForward,
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSDBLICENSEREQUEST pRequest,
    OUT PDWORD pcbLicense,
    OUT PBYTE* ppbLicense
    )
/*++

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLServerInfo ServerInfo;
    TLSLICENSEPACK search;
    TLSLICENSEPACK found;
    DWORD dwSupportFlagsTemp;

    SAFESTRCPY(search.szProductId,pRequest->pszProductId);

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);
    if(pDbWkSpace == NULL)
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    try {
        dwStatus = TLSDBKeyPackEnumBegin(
                                    pDbWkSpace,
                                    TRUE,
                                    LSKEYPACK_SEARCH_PRODUCTID,
                                    &search
                                );

    
        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        while( (dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &found)) == ERROR_SUCCESS  )
        {
            if(IsServiceShuttingdown() == TRUE)
            {
                SetLastError(dwStatus = TLS_I_SERVICE_STOP);
                break;
            }

            #if 0
            if(!(found.ucAgreementType & LSKEYPACK_REMOTE_TYPE))
            {
                continue;
            }
            #endif

            if(!(found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE))
            {
                continue;
            }

            if(found.wMajorVersion < HIWORD(pRequest->dwProductVersion))
            {
                continue;
            }

            if(found.wMinorVersion < LOWORD(pRequest->dwProductVersion))
            {
                continue;
            }

            if((found.dwPlatformType & ~LSKEYPACK_PLATFORM_REMOTE) != pRequest->dwPlatformID)
            {
                continue;
            }

            if(_tcsicmp(found.szCompanyName, pRequest->pszCompanyName) != 0)
            {
                continue;
            }

            //
            // Save the original Support flags; they can be changed
            //

            dwSupportFlagsTemp = *pdwSupportFlags;

            //
            // make call to remote server
            //
            dwStatus = ForwardUpgradeLicenseRequest(
                                            found.szInstallId,
                                            &dwSupportFlagsTemp,
                                            pForward->m_pRequest,
                                            pForward->m_ChallengeContext,
                                            pForward->m_cbChallengeResponse,
                                            pForward->m_pbChallengeResponse,
                                            pForward->m_cbOldLicense,
                                            pForward->m_pbOldLicense,
                                            pcbLicense,
                                            ppbLicense,
                                            &dwErrCode
                                        );

            if (dwStatus == ERROR_SUCCESS &&
                dwErrCode == LSERVER_S_SUCCESS)
            {
                *pdwSupportFlags = dwSupportFlagsTemp;

                break;
            }

            if (dwStatus == TLS_I_SERVICE_STOP)
            {
                break;
            }

            // try next server
            dwStatus = ERROR_SUCCESS;
        }

        TLSDBKeyPackEnumEnd(pDbWkSpace);
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch( ... ) {
        dwStatus = TLS_E_INTERNAL;
    }
   
    
cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}

    
//-----------------------------------------------------------------------

DWORD
TLSForwardLicenseRequest(
    IN PTLSForwardNewLicenseRequest pForward,
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PDWORD pcbLicense,
    OUT PBYTE* ppbLicense
    )
/*++


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLServerInfo ServerInfo;
    TLSLICENSEPACK search;
    TLSLICENSEPACK found;
    DWORD dwSupportFlagsTemp;
    DWORD dwQuantityTemp;

    SAFESTRCPY(search.szProductId,pRequest->pszProductId);

    pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);
    if(pDbWkSpace == NULL)
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    try {
        dwStatus = TLSDBKeyPackEnumBegin(
                                    pDbWkSpace,
                                    TRUE,
                                    LSKEYPACK_SEARCH_PRODUCTID,
                                    &search
                                );

    
        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        while( (dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &found)) == ERROR_SUCCESS  )
        {
            if(IsServiceShuttingdown() == TRUE)
            {
                SetLastError(dwStatus = TLS_I_SERVICE_STOP);
                break;
            }

            #if 0
            if(!(found.ucAgreementType & LSKEYPACK_REMOTE_TYPE))
            {
                continue;
            }
            #endif

            if(!(found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE))
            {
                continue;
            }

            if(found.wMajorVersion < HIWORD(pRequest->dwProductVersion))
            {
                continue;
            }

            if(found.wMinorVersion < LOWORD(pRequest->dwProductVersion))
            {
                continue;
            }

            if((found.dwPlatformType & ~LSKEYPACK_PLATFORM_REMOTE) != pRequest->dwPlatformID)
            {
                continue;
            }

            if(_tcsicmp(found.szCompanyName, pRequest->pszCompanyName) != 0)
            {
                continue;
            }

            //
            // Save the original support flags and quantity;
            // they can be changed
            //

            dwSupportFlagsTemp = *pdwSupportFlags;
            dwQuantityTemp = *pdwQuantity;

            //
            // make call to remote server
            //
            dwStatus = ForwardNewLicenseRequest(
                                            found.szInstallId,
                                            &dwSupportFlagsTemp,
                                            pForward->m_ChallengeContext,
                                            pForward->m_pRequest,
                                            pForward->m_szMachineName,
                                            pForward->m_szUserName,
                                            pForward->m_cbChallengeResponse,
                                            pForward->m_pbChallengeResponse,
                                            FALSE,      // bAcceptTemporaryLicense
                                            bAcceptFewerLicenses,
                                            &dwQuantityTemp,
                                            pcbLicense,
                                            ppbLicense,
                                            &dwErrCode
                                        );

            if (dwStatus == ERROR_SUCCESS &&
                dwErrCode == LSERVER_S_SUCCESS)
            {
                *pdwSupportFlags = dwSupportFlagsTemp;
                *pdwQuantity = dwQuantityTemp;

                break;
            }

            if (dwStatus == TLS_I_SERVICE_STOP)
            {
                break;
            }

            // try next server
            dwStatus = ERROR_SUCCESS;
        }

        TLSDBKeyPackEnumEnd(pDbWkSpace);
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch( ... ) {
        dwStatus = TLS_E_INTERNAL;
    }

cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\forward.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        forward.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLS_FORWARD_H__
#define __TLS_FORWARD_H__

#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSForwardUpgradeRequest( 
        IN PTLSForwardUpgradeLicenseRequest pForward,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSDBLICENSEREQUEST pRequest,
        OUT PDWORD pcbLicense,
        OUT PBYTE* ppbLicense
    );

    DWORD
    TLSForwardLicenseRequest(
        IN PTLSForwardNewLicenseRequest pForward,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSDBLICENSEREQUEST pRequest,
        IN BOOL bAcceptFewerLicenses,
        IN OUT DWORD *pdwQuantity,
        OUT PDWORD pcbLicense,
        OUT PBYTE* ppbLicense
    );

    DWORD
    ForwardUpgradeLicenseRequest( 
        IN LPTSTR pszServerSetupId,
        IN OUT DWORD *pdwSupportFlags,
        IN TLSLICENSEREQUEST* pRequest,
        IN CHALLENGE_CONTEXT ChallengeContext,
        IN DWORD cbChallengeResponse,
        IN PBYTE pbChallengeResponse,
        IN DWORD cbOldLicense,
        IN PBYTE pbOldLicense,
        OUT PDWORD pcbNewLicense,
        OUT PBYTE* ppbNewLicense,
        OUT PDWORD pdwErrCode
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\gencert.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        gencert.cpp
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "misc.h"
#include "utils.h"
#include "gencert.h"
#include "globals.h"

#ifndef UNICODE

    const DWORD dwCertRdnValueType = CERT_RDN_PRINTABLE_STRING;
    
#else

    const DWORD dwCertRdnValueType = CERT_RDN_UNICODE_STRING;

#endif


#ifndef CertStrToName

//
// Function prototype not found in wincrypt.h or anywhere but
// is in crypt32.lib
//

#ifdef __cplusplus
extern "C" {
#endif

    BOOL WINAPI 
    CertStrToNameA(  
        DWORD dwCertEncodingType,   // in
        LPCSTR pszX500,            // in  
        DWORD dwStrType,            // in
        void* pvReserved,           // in, optional
        BYTE* pbEncoded,            // out  
        DWORD* pcbEncoded,         // in/out
        LPCSTR* ppszError          // out, optional
    );

    CertStrToNameW(  
        DWORD dwCertEncodingType,   // in
        LPCWSTR pszX500,            // in  
        DWORD dwStrType,            // in
        void* pvReserved,           // in, optional
        BYTE* pbEncoded,            // out  
        DWORD* pcbEncoded,         // in/out
        LPCWSTR* ppszError          // out, optional
    );

    #ifdef UNICODE
    #define CertStrToName CertStrToNameW
    #else
    #define CertStrToName CertStrToNameA
    #endif

#ifdef __cplusplus
}
#endif

#endif


/*******************************************************************************************
Function:
    LSEncryptBase64EncodeHWID()

Description:
    Encrypt using license server private key then base64 encode the hardware ID

Arguments:
    IN PHWID - pointer to HWID to be encrypt/encoded
    OUT DWORD* cbBase64EncodeHwid - size of pointer to encrypted/encoded string
    OUT PBYTE* szBase64EncodeHwid - Pointer to encrypted/encoded string.

Returns:
    TRUE if successful, FALSE otherwise, call GetLastError() for detail.
*******************************************************************************************/
BOOL 
TLSEncryptBase64EncodeHWID(
    PHWID pHwid, 
    DWORD* cbBase64EncodeHwid, 
    PBYTE* szBase64EncodeHwid
    )
{
    DWORD status=ERROR_SUCCESS;

    //
    // Encrypt HWID
    //
    BYTE tmp_pbEncryptedHwid[sizeof(HWID)*2+2];
    DWORD tmp_cbEncryptedHwid=sizeof(tmp_pbEncryptedHwid);

    do {
        memset(tmp_pbEncryptedHwid, 0, sizeof(tmp_pbEncryptedHwid));
        if((status=LicenseEncryptHwid(
                        pHwid,
                        &tmp_cbEncryptedHwid, 
                        tmp_pbEncryptedHwid, 
                        g_cbSecretKey,
                        g_pbSecretKey) != LICENSE_STATUS_OK))
        {
            break;
        }


        //
        // BASE64 Encode Encrypted HWID - printable char. string
        //
        if((status=LSBase64Encode(
                        tmp_pbEncryptedHwid, 
                        tmp_cbEncryptedHwid, 
                        NULL, 
                        cbBase64EncodeHwid)) != ERROR_SUCCESS)
        {
            break;
        }

        *szBase64EncodeHwid=(PBYTE)AllocateMemory(*cbBase64EncodeHwid*(sizeof(TCHAR)+1));
        if(*szBase64EncodeHwid == NULL)
        {
            SetLastError(status = ERROR_OUTOFMEMORY);
            break;
        }

        // base64 encoding
        status=LSBase64Encode(
                    tmp_pbEncryptedHwid, 
                    tmp_cbEncryptedHwid, 
                    (TCHAR *)*szBase64EncodeHwid, 
                    cbBase64EncodeHwid);
    } while(FALSE);

    return status == ERROR_SUCCESS;
}

/*******************************************************************************************/

DWORD
TLSAddCertAuthorityInfoAccess(
    LPTSTR szIssuerDnsName, 
    PCERT_EXTENSION pExtension
    )
/*
*/
{
    LSCERT_AUTHORITY_INFO_ACCESS certInfoAccess;
    LSCERT_ACCESS_DESCRIPTION certAcccessDesc;

    certAcccessDesc.pszAccessMethod=szOID_X509_ACCESS_PKIX_OCSP;
    certAcccessDesc.AccessLocation.dwAltNameChoice = LSCERT_ALT_NAME_DNS_NAME;
    certAcccessDesc.AccessLocation.pwszDNSName = szIssuerDnsName;

    certInfoAccess.cAccDescr = 1;
    certInfoAccess.rgAccDescr = &certAcccessDesc;

    pExtension->pszObjId = szOID_X509_AUTHORITY_ACCESS_INFO;
    pExtension->fCritical = TRUE;

    return TLSCryptEncodeObject(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    szOID_X509_AUTHORITY_ACCESS_INFO, 
                    &certInfoAccess, 
                    &pExtension->Value.pbData,
                    &pExtension->Value.cbData
                );
}

///////////////////////////////////////////////////////////////////////////////

DWORD
TLSAddCertAuthorityKeyIdExtension(
    LPTSTR           szIssuer,
    ULARGE_INTEGER*  CertSerialNumber, 
    PCERT_EXTENSION  pExtension
    )
/*
*/
{
    //
    // Use CERT_AUTHORITY_KEY_ID2_INFO
    // some structure not defined in SP3's wincrypt.h
    //
    LSCERT_ALT_NAME_ENTRY certAltNameEntry;
    LSCERT_AUTHORITY_KEY_ID2_INFO authKeyId2Info;

    memset(&authKeyId2Info, 0, sizeof(authKeyId2Info));
    authKeyId2Info.AuthorityCertSerialNumber.cbData = sizeof(ULARGE_INTEGER);
    authKeyId2Info.AuthorityCertSerialNumber.pbData = (PBYTE)CertSerialNumber;


    memset(&certAltNameEntry, 0, sizeof(certAltNameEntry));
    certAltNameEntry.dwAltNameChoice=CERT_ALT_NAME_DIRECTORY_NAME; //LSCERT_ALT_NAME_RFC822_NAME;
    certAltNameEntry.DirectoryName.cbData = (_tcslen(szIssuer) + 1) * sizeof(TCHAR);
    certAltNameEntry.DirectoryName.pbData = (PBYTE)szIssuer;

    authKeyId2Info.AuthorityCertIssuer.cAltEntry=1;
    authKeyId2Info.AuthorityCertIssuer.rgAltEntry=&certAltNameEntry; 
  
    pExtension->pszObjId = szOID_X509_AUTHORITY_KEY_ID2;
    pExtension->fCritical = TRUE;
    
    return TLSCryptEncodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        szOID_X509_AUTHORITY_KEY_ID2, 
                        &authKeyId2Info, 
                        &pExtension->Value.pbData,
                        &pExtension->Value.cbData
                    );
}

///////////////////////////////////////////////////////////////////////////////

DWORD
TLSExportPublicKey(
    IN HCRYPTPROV hCryptProv,
    IN DWORD      dwKeyType,
    IN OUT PDWORD pcbByte,
    IN OUT PCERT_PUBLIC_KEY_INFO  *ppbByte
    )
/*

*/
{
    BOOL bRetCode=TRUE;

    *pcbByte=0;
    *ppbByte=NULL;

    bRetCode = CryptExportPublicKeyInfo(
                    hCryptProv, 
                    dwKeyType, 
                    X509_ASN_ENCODING, 
                    NULL, 
                    pcbByte);
    if(bRetCode == FALSE)
        goto cleanup;
    
    if((*ppbByte=(PCERT_PUBLIC_KEY_INFO)AllocateMemory(*pcbByte)) == NULL)
    {   
        bRetCode = FALSE;
        goto cleanup;
    }

    bRetCode = CryptExportPublicKeyInfo(
                    hCryptProv, 
                    dwKeyType,
                    X509_ASN_ENCODING, 
                    *ppbByte, 
                    pcbByte);
    if(bRetCode == FALSE)
    {
        FreeMemory(*ppbByte);
        *pcbByte = 0;
    }

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

///////////////////////////////////////////////////////////////////////////////

DWORD 
TLSCryptEncodeObject(  
    IN  DWORD   dwEncodingType,
    IN  LPCSTR  lpszStructType,
    IN  const void * pvStructInfo,
    OUT PBYTE*  ppbEncoded,
    OUT DWORD*  pcbEncoded
    )
/*

Description:
    
    Allocate memory and encode object, wrapper for CryptEncodeObject()

*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(!CryptEncodeObject(dwEncodingType, lpszStructType, pvStructInfo, NULL, pcbEncoded) ||
       (*ppbEncoded=(PBYTE)AllocateMemory(*pcbEncoded)) == NULL ||
       !CryptEncodeObject(dwEncodingType, lpszStructType, pvStructInfo, *ppbEncoded, pcbEncoded))
    {
        dwStatus=GetLastError();
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////////

DWORD
TLSCryptSignAndEncodeCertificate(
    IN HCRYPTPROV  hCryptProv,
    IN DWORD dwKeySpec,
    IN PCERT_INFO pCertInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OUT PBYTE* ppbEncodedCert,
    IN OUT PDWORD pcbEncodedCert
    )
/*

*/
{
    BOOL bRetCode;

    bRetCode = CryptSignAndEncodeCertificate(  
                    hCryptProv,
                    dwKeySpec,
                    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
                    pCertInfo,
                    pSignatureAlgorithm,
                    NULL,
                    NULL,
                    pcbEncodedCert);

    if(bRetCode == FALSE && GetLastError() != ERROR_MORE_DATA)
        goto cleanup;

    *ppbEncodedCert=(PBYTE)AllocateMemory(*pcbEncodedCert);
    if(*ppbEncodedCert == FALSE)
        goto cleanup;

    bRetCode = CryptSignAndEncodeCertificate(  
                    hCryptProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
                    pCertInfo,
                    pSignatureAlgorithm,
                    NULL,
                    *ppbEncodedCert,
                    pcbEncodedCert);

    if(bRetCode == FALSE)
    {
        FreeMemory(*ppbEncodedCert);
        *pcbEncodedCert = 0;
    }

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

////////////////////////////////////////////////////////////////////////

#define MAX_NUM_CERT_BLOBS 200  // actually, we can't go over 10.


DWORD
TLSVerifyProprietyChainedCertificate(
    HCRYPTPROV  hCryptProv, 
    PBYTE       pbCert, 
    DWORD       cbCert
    )
/*++

--*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    PCert_Chain pCertChain = (PCert_Chain)pbCert;
    UNALIGNED Cert_Blob *pCertificate = NULL;
    PCCERT_CONTEXT pIssuerCert = NULL;
    PCCERT_CONTEXT pSubjectCert = NULL;   


    DWORD dwVerifyFlag = CERT_DATE_DONT_VALIDATE;
    int i;

    if( pCertChain == NULL || cbCert <= 0 ||
        MAX_CERT_CHAIN_VERSION < GET_CERTIFICATE_VERSION(pCertChain->dwVersion) ||
        pCertChain->dwNumCertBlobs > MAX_NUM_CERT_BLOBS ||
        pCertChain->dwNumCertBlobs <= 1 )   // must have at least two certificates
    {
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        return dwStatus;
    }

    //
    // Verify input data before actually allocate memory
    //
    pCertificate = (PCert_Blob)&(pCertChain->CertBlob[0]);
    for(i=0; i < pCertChain->dwNumCertBlobs; i++)
    {
        if (((PBYTE)pCertificate > (cbCert + pbCert - sizeof(Cert_Blob))) || 
            (pCertificate->cbCert == 0) ||
            (pCertificate->cbCert > (DWORD)((pbCert + cbCert) - pCertificate->abCert)))
        {
            return (LICENSE_STATUS_INVALID_INPUT);
        }

        pCertificate = (PCert_Blob)(pCertificate->abCert + pCertificate->cbCert);
    }

    //
    // First certificate is root certificate
    //
    pCertificate = (PCert_Blob)&(pCertChain->CertBlob[0]);
    pIssuerCert = CertCreateCertificateContext(
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        &(pCertificate->abCert[0]),
                                        pCertificate->cbCert
                                    );
    if(pIssuerCert == NULL)
    {
        dwStatus = GetLastError();  // just for debugging.
        goto cleanup;
    }

    dwStatus = ERROR_SUCCESS;
    pSubjectCert = CertDuplicateCertificateContext(pIssuerCert);

    for(i=0; i < pCertChain->dwNumCertBlobs; i++)
    {
        if(pSubjectCert == NULL)
        {
            dwStatus = GetLastError();
            break;
        }

        //
        // verify subject's certificate
        dwVerifyFlag = CERT_STORE_SIGNATURE_FLAG;
        if(CertVerifySubjectCertificateContext(
                                        pSubjectCert,
                                        pIssuerCert,
                                        &dwVerifyFlag
                                    ) == FALSE)
        {
            dwStatus = GetLastError();
            break;
        }            

        if(dwVerifyFlag != 0)
        {
            // signature verification failed.
            dwStatus = TLS_E_INVALID_DATA;
            break;
        }

        if(CertFreeCertificateContext(pIssuerCert) == FALSE)
        {
            dwStatus = GetLastError();
            break;
        }

        pIssuerCert = pSubjectCert;

        pCertificate = (PCert_Blob)(pCertificate->abCert + pCertificate->cbCert);

        pSubjectCert = CertCreateCertificateContext(
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        &(pCertificate->abCert[0]),
                                        pCertificate->cbCert
                                    );
    }
            
cleanup:

    if(pSubjectCert != NULL)
    {
        CertFreeCertificateContext(pSubjectCert);
    }

    if(pIssuerCert != NULL)
    {
        CertFreeCertificateContext(pIssuerCert);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////////

BOOL IsHydraClientCertficate( PCERT_INFO pCertInfo )
{
    CERT_EXTENSION UNALIGNED * pCertExtension=pCertInfo->rgExtension;
    DWORD dwVersion = TERMSERV_CERT_VERSION_UNKNOWN;
    DWORD UNALIGNED * pdwVersion;

    for(DWORD i=0; i < pCertInfo->cExtension; i++, pCertExtension++)
    {
        if(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_VERSION) == 0)
        {
            pdwVersion = (DWORD UNALIGNED *) pCertExtension->Value.pbData;

            if(pCertExtension->Value.cbData == sizeof(DWORD) &&
               *pdwVersion <= TERMSERV_CERT_VERSION_CURRENT)
            {
                dwVersion = *pdwVersion;
                break;
            }
        }
    }

    return (dwVersion == TERMSERV_CERT_VERSION_UNKNOWN) ? FALSE : TRUE;
}

////////////////////////////////////////////////////////////////////////

DWORD
ChainProprietyCert(
        HCRYPTPROV      hCryptProv,
        HCERTSTORE      hCertStore, 
        PCCERT_CONTEXT  pCertContext, 
        PCert_Chain     pCertChain,
        DWORD*          dwCertOffset,
        DWORD           dwBufSize)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    DWORD       dwFlags;
    PCCERT_CONTEXT pCertIssuer=NULL;

    pCertIssuer=NULL;
    dwFlags = CERT_STORE_SIGNATURE_FLAG;


    //
    // Get the issuer's certificate from store
    //
    pCertIssuer = CertGetIssuerCertificateFromStore(
                                                hCertStore,
                                                pCertContext,
                                                pCertIssuer,
                                                &dwFlags
                                            );

    if(pCertIssuer != NULL)
    {
        if(dwFlags & CERT_STORE_SIGNATURE_FLAG)
        {
            // invalid signature
            dwStatus = TLS_E_INVALID_DATA;
        }
        else
        {
            //
            // Recursively find the issuer of the issuer's certificate
            //
            dwStatus = ChainProprietyCert(
                                    hCryptProv, 
                                    hCertStore, 
                                    pCertIssuer, 
                                    pCertChain, 
                                    dwCertOffset, 
                                    dwBufSize
                                );
        }
    }
    else 
    {
        dwStatus = GetLastError();
        if(dwStatus != CRYPT_E_SELF_SIGNED)
        {
            goto cleanup;
        }

        //
        // Verify issuer's certificate
        //
        if(CryptVerifyCertificateSignature(
                                   hCryptProv,
                                   X509_ASN_ENCODING,
                                   pCertContext->pbCertEncoded,
                                   pCertContext->cbCertEncoded,
                                   &pCertContext->pCertInfo->SubjectPublicKeyInfo))
        {
            dwStatus=ERROR_SUCCESS;
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // Push certificate into propriety certificate chain
        //
        if((*dwCertOffset + pCertContext->cbCertEncoded) >= dwBufSize)
        {
            dwStatus = ERROR_MORE_DATA;
            goto cleanup;
        }

        (pCertChain->dwNumCertBlobs)++;

        UNALIGNED Cert_Blob *pCertBlob = (PCert_Blob)((PBYTE)&(pCertChain->CertBlob) + *dwCertOffset);
        pCertBlob->cbCert = pCertContext->cbCertEncoded;
        memcpy( &(pCertBlob->abCert),
                pCertContext->pbCertEncoded,
                pCertContext->cbCertEncoded);

        *dwCertOffset += (sizeof(pCertBlob->cbCert) + pCertContext->cbCertEncoded);
    }

cleanup:

    if(pCertIssuer != NULL)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////////


DWORD 
TLSChainProprietyCertificate(
    HCRYPTPROV  hCryptProv,
    BOOL        bTemp,
    PBYTE       pbLicense, 
    DWORD       cbLicense, 
    PBYTE*      pbChained, 
    DWORD*      cbChained
    )
{
    HCERTSTORE      hCertStore=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;
    CRYPT_DATA_BLOB Serialized;
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pPrevCertContext=NULL;
    PCERT_INFO      pCertInfo;
    BOOL            bFound=FALSE;
    
    Serialized.pbData = pbLicense;
    Serialized.cbData = cbLicense;

    DWORD dwCertOffset = 0;
    PCert_Chain pCertChain;

    DWORD numCerts=0;
    DWORD cbSize=0;

    if(hCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    hCertStore=CertOpenStore(
                        sz_CERT_STORE_PROV_PKCS7,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        &Serialized
                    );

    if(!hCertStore)
    {
        dwStatus=GetLastError();
        goto cleanup;
    }

    //
    // Get number of certificate and estimated size first - save memory
    //
    do {
        pCertContext = CertEnumCertificatesInStore(
                                                hCertStore, 
                                                pPrevCertContext
                                            );
        if(pCertContext == NULL)
        {
            dwStatus = GetLastError();
            if(dwStatus != CRYPT_E_NOT_FOUND)
                goto cleanup;

            dwStatus = ERROR_SUCCESS;
            break;
        }

        numCerts++;
        cbSize += pCertContext->cbCertEncoded;
        pPrevCertContext = pCertContext;

    } while(TRUE);


    *cbChained = cbSize + numCerts * sizeof(Cert_Blob) + sizeof(Cert_Chain);

    //
    // Allocate memory for our propriety certificate chain
    //
    pCertChain=(PCert_Chain)LocalAlloc(LPTR, *cbChained);
    if(pCertChain == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    pCertChain->dwVersion = CERT_CHAIN_VERSION_2 | ((bTemp) ? 0x80000000 : 0);

    //
    // Enumerate license in certificate to find actual client license.
    //
    pPrevCertContext = NULL;
    do {
        pCertContext=CertEnumCertificatesInStore(hCertStore, pPrevCertContext);
        if(pCertContext == NULL)
        {
            // end certificate in store or error
            if((dwStatus=GetLastError()) != CRYPT_E_NOT_FOUND)
                goto cleanup;

            dwStatus = ERROR_SUCCESS;
            break;
        }

        pPrevCertContext = pCertContext;

        if(IsHydraClientCertficate(pCertContext->pCertInfo))     
        {       
            bFound = TRUE;
        }
    } while(bFound == FALSE);

    if(bFound == FALSE)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
   
    //
    // Recusively chain certificate in backward.
    //    
    dwStatus = ChainProprietyCert(
                        hCryptProv, 
                        hCertStore, 
                        pCertContext, 
                        pCertChain, 
                        &dwCertOffset,
                        *cbChained);
    
    *pbChained = (PBYTE)pCertChain;

cleanup:

    if(hCertStore)
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
       
    return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////

DWORD
TLSCertSetCertRdnStr(
    IN OUT CERT_NAME_BLOB* pCertNameBlob,
    IN LPTSTR          szRdn
    )
/*

Abstract:

    Add RDN into certificate

Parameter:

    pCertNameBlob -
    szRdn - RDN to be added, see CertStrToName() for help

Returns:

    ERROR_INVALID_PARAMETER
    Memory allocation failed.
    Error returns from CertStrToName()
    
*/
{
    if(pCertNameBlob == NULL)
        return ERROR_INVALID_PARAMETER;

    BOOL bRetCode=TRUE;

    bRetCode = CertStrToName(
                    X509_ASN_ENCODING,
                    szRdn,
                    CERT_X500_NAME_STR | CERT_SIMPLE_NAME_STR,
                    NULL,
                    pCertNameBlob->pbData,
                    &pCertNameBlob->cbData,
                    NULL
                );

    if(bRetCode != TRUE)
        goto cleanup;

    pCertNameBlob->pbData = (PBYTE)AllocateMemory(pCertNameBlob->cbData);
    if(pCertNameBlob->pbData == NULL)
        goto cleanup;

    bRetCode = CertStrToName(
                    X509_ASN_ENCODING,
                    szRdn,
                    CERT_X500_NAME_STR | CERT_SIMPLE_NAME_STR,
                    NULL,
                    pCertNameBlob->pbData,
                    &pCertNameBlob->cbData,
                    NULL
                );

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

///////////////////////////////////////////////////////////////////////////////

DWORD 
TLSCertSetCertRdnName(
    IN OUT CERT_NAME_BLOB* pCertNameBlob, 
    IN CERT_NAME_INFO* pRdn
    )
/*

Abstract:

    Add RDN into certificate

Parameters:

    pCertNameBlob -
    pRdn -

Returns

    ERROR_INVALID_PARAMETER
    Error code from CryptEncodeObject()
    Memory allocation fail.    

*/
{
    if(pCertNameBlob == NULL || pRdn == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // CertStrToName() not defined in SP3 build environment
    //
    return TLSCryptEncodeObject( 
                    CRYPT_ASN_ENCODING, 
                    X509_NAME, 
                    pRdn, 
                    &pCertNameBlob->pbData, 
                    &pCertNameBlob->cbData
                );
}

//////////////////////////////////////////////////////////////////////////
DWORD
TLSSetCertRdn(
    PCERT_NAME_BLOB pCertNameBlob,
    PTLSClientCertRDN pLsCertRdn
    )
/*
*/
{  
    DWORD dwStatus=ERROR_SUCCESS;

    switch(pLsCertRdn->type)
    {
        case LSCERT_RDN_STRING_TYPE:
            dwStatus = TLSCertSetCertRdnStr(
                                pCertNameBlob,
                                pLsCertRdn->szRdn
                            );
            break;

        case LSCERT_RDN_NAME_INFO_TYPE:
            dwStatus = TLSCertSetCertRdnName(
                                pCertNameBlob,
                                pLsCertRdn->pCertNameInfo
                            );

            break;

        case LSCERT_RDN_NAME_BLOB_TYPE:
            *pCertNameBlob = *pLsCertRdn->pNameBlob;
            break;

        case LSCERT_CLIENT_INFO_TYPE:
            {
                PBYTE szBase64EncodeHwid=NULL;
                DWORD cbBase64EncodeHwid=0;
    
                if(!TLSEncryptBase64EncodeHWID(
                                pLsCertRdn->ClientInfo.pClientID, 
                                &cbBase64EncodeHwid, 
                                &szBase64EncodeHwid))
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE, 
                            TLS_E_GENERATECLIENTELICENSE,
                            dwStatus=TLS_E_ENCRYPTHWID, 
                            GetLastError()
                        );

                    break;
                }

                CERT_RDN_ATTR rgNameAttr[] = { 
                    {   
                        OID_SUBJECT_CLIENT_COMPUTERNAME, 
                        dwCertRdnValueType, 
                        _tcslen(pLsCertRdn->ClientInfo.szMachineName) * sizeof(TCHAR), 
                        (UCHAR *)pLsCertRdn->ClientInfo.szMachineName
                    },
                    {
                        OID_SUBJECT_CLIENT_USERNAME, 
                        dwCertRdnValueType, 
                        _tcslen(pLsCertRdn->ClientInfo.szUserName) * sizeof(TCHAR), 
                        (UCHAR *)pLsCertRdn->ClientInfo.szUserName
                    },
                    {
                        OID_SUBJECT_CLIENT_HWID, 
                        dwCertRdnValueType, 
                        cbBase64EncodeHwid*sizeof(TCHAR), 
                        (UCHAR *)szBase64EncodeHwid
                    }
                };
                                
                CERT_RDN rgRDN[] = { 
                    sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), 
                    &rgNameAttr[0] 
                };

                CERT_NAME_INFO Name = {1, rgRDN};

                dwStatus = TLSCertSetCertRdnName(
                                        pCertNameBlob,
                                        &Name
                                    );

                FreeMemory(szBase64EncodeHwid);
            }
            break;

        default:

            dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
                      

//////////////////////////////////////////////////////////////////////////

DWORD 
TLSGenerateCertificate(
    HCRYPTPROV         hCryptProv,
    DWORD              dwKeySpec,
    ULARGE_INTEGER*    pCertSerialNumber,
    PTLSClientCertRDN   pCertIssuer,
    PTLSClientCertRDN   pCertSubject, 
    FILETIME*          ftNotBefore,
    FILETIME*          ftNotAfter,
    PCERT_PUBLIC_KEY_INFO pSubjectPublicKey,
    DWORD              dwNumExtensions,
    PCERT_EXTENSION    pCertExtensions,
    PDWORD             pcbEncodedCert,
    PBYTE*             ppbEncodedCert
    )
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm={ szOID_OIWSEC_sha1RSASign, 0, 0 };
    CERT_INFO CertInfo;
    PCERT_PUBLIC_KEY_INFO pbPublicKeyInfo=NULL;
    DWORD cbPublicKeyInfo=0;


    memset(&CertInfo, 0, sizeof(CERT_INFO));
    
    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.cbData = sizeof(*pCertSerialNumber);
    CertInfo.SerialNumber.pbData = (PBYTE)pCertSerialNumber;
    
    CertInfo.SignatureAlgorithm = SignatureAlgorithm;

    dwStatus = TLSSetCertRdn(
                        &CertInfo.Issuer,
                        pCertIssuer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE, 
                TLS_E_SETCERTISSUER, 
                dwStatus
            );
        goto cleanup;
    }

    CertInfo.NotBefore = *ftNotBefore;
    CertInfo.NotAfter = *ftNotAfter;

    dwStatus = TLSSetCertRdn(
                        &CertInfo.Subject,
                        pCertSubject
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE, 
                TLS_E_SETCERTSUBJECT, 
                dwStatus
            );
        goto cleanup;
    }

    if(pSubjectPublicKey)
    {
        CertInfo.SubjectPublicKeyInfo = *pSubjectPublicKey;
    }
    else
    {
        dwStatus = TLSExportPublicKey(
                            hCryptProv,
                            dwKeySpec,
                            &cbPublicKeyInfo,
                            &pbPublicKeyInfo
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE, 
                    TLS_E_EXPORT_KEY, 
                    dwStatus
                );
            goto cleanup;
        }

        CertInfo.SubjectPublicKeyInfo = *pbPublicKeyInfo;
    }
    
    CertInfo.cExtension = dwNumExtensions;
    CertInfo.rgExtension = pCertExtensions;

    dwStatus = TLSCryptSignAndEncodeCertificate(
                            hCryptProv,
                            dwKeySpec,
                            &CertInfo,
                            &SignatureAlgorithm,
                            ppbEncodedCert,
                            pcbEncodedCert
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE, 
                TLS_E_SIGNENCODECERT, 
                dwStatus
            );
    }

cleanup:

    if(pbPublicKeyInfo)
    {
        FreeMemory(pbPublicKeyInfo);
    }       

    if(pCertIssuer->type != LSCERT_RDN_NAME_BLOB_TYPE)
    {
        FreeMemory(CertInfo.Issuer.pbData);
    }

    if(pCertSubject->type != LSCERT_RDN_NAME_BLOB_TYPE)
    {
        FreeMemory(CertInfo.Subject.pbData);
    } 
    return dwStatus;
}

//////////////////////////////////////////////////////////////////////

DWORD 
TLSCreateSelfSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec, 
    IN PBYTE pbSPK,
    IN DWORD cbSPK,
    IN DWORD dwNumExtensions,
    IN PCERT_EXTENSION pCertExtension,
    OUT PDWORD cbEncoded, 
    OUT PBYTE* pbEncoded
)
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD index;

#define MAX_EXTENSIONS_IN_SELFSIGN 40

    SYSTEMTIME      sysTime;
    FILETIME        ftTime;
    CERT_EXTENSION  rgExtension[MAX_EXTENSIONS_IN_SELFSIGN];
    int             iExtCount=0, iExtNotFreeCount=0;
    FILETIME        ftNotBefore;
    FILETIME        ftNotAfter;
    ULARGE_INTEGER  ulSerialNumber;
    TLSClientCertRDN certRdn;
    
    CERT_BASIC_CONSTRAINTS2_INFO basicConstraint;

    // modify here is we want to set to different issuer name
    LPTSTR szIssuerName;
    szIssuerName = g_szComputerName;

    //static LPTSTR pszEnforce=L"Enforce";


    CERT_RDN_ATTR rgNameAttr[] = { 
        {   
            szOID_COMMON_NAME, 
            dwCertRdnValueType, 
            _tcslen(szIssuerName) * sizeof(TCHAR), 
            (UCHAR *)szIssuerName 
        },

//#if ENFORCE_LICENSING
//        {
//            szOID_BUSINESS_CATEGORY,
//            dwCertRdnValueType,
//            _tcslen(pszEnforce) * sizeof(TCHAR),
//            (UCHAR *)pszEnforce
//        },
//#endif       

        {
            szOID_LOCALITY_NAME, 
            dwCertRdnValueType, 
            _tcslen(g_pszScope) * sizeof(TCHAR), 
            (UCHAR *)g_pszScope
        }

    };
                                    
    CERT_RDN rgRDN[] = { sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), &rgNameAttr[0] };
    CERT_NAME_INFO Name = {1, rgRDN};

    certRdn.type = LSCERT_RDN_NAME_INFO_TYPE;
    certRdn.pCertNameInfo = &Name;

    memset(rgExtension, 0, sizeof(rgExtension));

    //
    // Set validity of self sign certificate
    //

    //
    // If system time is not in sync, this will cause server
    // can't request cert. from license server
    //

    memset(&sysTime, 0, sizeof(sysTime));
    GetSystemTime(&sysTime);
    sysTime.wYear = 1970;
    if(TLSSystemTimeToFileTime(&sysTime, &ftNotBefore) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // draft-ietf-pkix-ipki-part1-06.txt section 4.1.2.5.1
    //  where year is greater or equal to 50, the year shall be interpreted as 19YY; and
    //  where year is less than 50, the year shall be interpreted as 20YY
    //
    sysTime.wYear = PERMANENT_CERT_EXPIRE_DATE; 
    if(TLSSystemTimeToFileTime(&sysTime, &ftNotAfter) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    ulSerialNumber.LowPart = ftNotBefore.dwLowDateTime;
    ulSerialNumber.HighPart = ftNotBefore.dwHighDateTime;

    //
    // Add basic constrains extension to indicate this is a CA certificate
    //
    rgExtension[iExtCount].pszObjId = szOID_BASIC_CONSTRAINTS2;
    rgExtension[iExtCount].fCritical = FALSE;

    basicConstraint.fCA = TRUE;     // act as CA
    basicConstraint.fPathLenConstraint = TRUE;
    basicConstraint.dwPathLenConstraint = 0; // can only issue certificates 
                                             // to end-entities and not to further CAs
    dwStatus=TLSCryptEncodeObject( 
                        X509_ASN_ENCODING,
                        szOID_BASIC_CONSTRAINTS2,
                        &basicConstraint,
                        &(rgExtension[iExtCount].Value.pbData),
                        &(rgExtension[iExtCount].Value.cbData)
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_GENERATECLIENTELICENSE,
                TLS_E_SIGNENCODECERT, 
                dwStatus
            );
        goto cleanup;
    }

    iExtCount++;


    //
    // From here - extension memory should not be free
    //
    if(pbSPK != NULL && cbSPK != 0)
    {
        rgExtension[iExtCount].pszObjId = szOID_PKIS_TLSERVER_SPK_OID;
        rgExtension[iExtCount].fCritical = FALSE;
        rgExtension[iExtCount].Value.pbData = pbSPK;
        rgExtension[iExtCount].Value.cbData = cbSPK;

        iExtNotFreeCount++;
        iExtCount++;
    }

    for(index = 0; 
        index < dwNumExtensions; 
        index ++, iExtCount++, iExtNotFreeCount++ )
    {
        rgExtension[iExtCount] = pCertExtension[index];
    }        
        
    dwStatus = TLSGenerateCertificate(
                        hCryptProv,
                        dwKeySpec,
                        &ulSerialNumber,
                        &certRdn,
                        &certRdn,
                        &ftNotBefore,
                        &ftNotAfter,
                        NULL,
                        iExtCount,
                        rgExtension,
                        cbEncoded,
                        pbEncoded
                    );                      
cleanup:

    //
    // Don't free memory for SPK and extensions...
    //
    for(int i=0; i < iExtCount - iExtNotFreeCount; i++)
    {
        FreeMemory(rgExtension[i].Value.pbData);
    }

    return (dwStatus != ERROR_SUCCESS) ? TLS_E_CREATE_SELFSIGN_CERT : ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////
DWORD
TLSGenerateSingleCertificate(
    IN HCRYPTPROV hCryptProv,
    IN PCERT_NAME_BLOB pIssuerRdn,
    IN PTLSClientCertRDN pSubjectRdn,
    IN PCERT_PUBLIC_KEY_INFO pSubjectPublicKeyInfo,
    IN PTLSDBLICENSEDPRODUCT pLicProduct,
    OUT PBYTE* ppbEncodedCert,
    IN PDWORD pcbEncodedCert
    )
/*

*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    #define MAX_CLIENT_EXTENSION 10

    CERT_EXTENSION CertExtension[MAX_CLIENT_EXTENSION];
    DWORD dwNumExtensions=0;
    DWORD currentCertVersion=TERMSERV_CERT_VERSION_CURRENT;

    TLSClientCertRDN IssuerRdn;
    

#if ENFORCE_LICENSING

    //
    // Use certificate that CH gets for us
    //
    IssuerRdn.type = LSCERT_RDN_NAME_BLOB_TYPE;
    //IssuerRdn.pNameBlob = &g_LicenseCertContext->pCertInfo->Subject;
    IssuerRdn.pNameBlob = pIssuerRdn;

#else

    LPTSTR szIssuerName;

    // modify here if we want to set to different issuer name
    szIssuerName = g_szComputerName;

    CERT_RDN_ATTR rgNameAttr[] = { 
        {
            OID_ISSUER_LICENSE_SERVER_NAME, 
            dwCertRdnValueType, 
            _tcslen(szIssuerName) * sizeof(TCHAR), 
            (UCHAR *)szIssuerName 
        },
        {
            OID_ISSUER_LICENSE_SERVER_SCOPE, 
            dwCertRdnValueType, 
            _tcslen(g_pszScope) * sizeof(TCHAR), 
            (UCHAR *)g_pszScope
        }
    };
                                
    CERT_RDN rgRDN[] = { 
        sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), 
        &rgNameAttr[0] 
    };
    CERT_NAME_INFO Name = {1, rgRDN};

    IssuerRdn.type = LSCERT_RDN_NAME_INFO_TYPE;
    IssuerRdn.pCertNameInfo = &Name;

#endif

    //------------------------------------------------------------------------------------------
    // add extension to certificate
    // WARNING : End of routine free memory allocated for extension's pbData, skip those
    //           that can't be free, for example, version stamp extension. all these is just 
    //           to keep memory fragmentaion low
    //------------------------------------------------------------------------------------------

    //
    // DO NOT FREE pbData on first two extensions
    //

    // Hydra Certificate version stamp - DO NOT FREE
    memset(&CertExtension, 0, sizeof(CertExtension));
    dwNumExtensions = 0;

    //
    // Add License Server Info
    //
    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_HYDRA_CERT_VERSION;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    CertExtension[dwNumExtensions].Value.cbData = sizeof(DWORD);
    CertExtension[dwNumExtensions].Value.pbData = (PBYTE)&currentCertVersion;
    dwNumExtensions++;

    // manufacturer's name, no encoding - DO NOT FREE
    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_MANUFACTURER;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    CertExtension[dwNumExtensions].Value.cbData = (_tcslen(pLicProduct->szCompanyName)+1) * sizeof(TCHAR);
    CertExtension[dwNumExtensions].Value.pbData = (PBYTE)pLicProduct->szCompanyName;
    dwNumExtensions++;

    //
    // MS Licensed Product Info, no encoding
    //
    LICENSED_VERSION_INFO LicensedInfo;

    memset(&LicensedInfo, 0, sizeof(LicensedInfo));
    LicensedInfo.wMajorVersion = HIWORD(pLicProduct->dwProductVersion);
    LicensedInfo.wMinorVersion = LOWORD(pLicProduct->dwProductVersion);
    LicensedInfo.dwFlags = (pLicProduct->bTemp) ? LICENSED_VERSION_TEMPORARY : 0;

    DWORD dwLSVersionMajor;
    DWORD dwLSVersionMinor;

    dwLSVersionMajor = GET_SERVER_MAJOR_VERSION(TLS_CURRENT_VERSION);
    dwLSVersionMinor = GET_SERVER_MINOR_VERSION(TLS_CURRENT_VERSION);
    LicensedInfo.dwFlags |= ((dwLSVersionMajor << 4 | dwLSVersionMinor) << 16);

    if(TLSIsBetaNTServer() == FALSE)
    {
        LicensedInfo.dwFlags |= LICENSED_VERSION_RTM;
    }

#if ENFORCE_LICENSING
    LicensedInfo.dwFlags |= LICENSE_ISSUER_ENFORCE_TYPE;
#endif


    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_LICENSED_PRODUCT_INFO;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    dwStatus=LSLicensedProductInfoToExtension(
                            1, 
                            pLicProduct->dwPlatformID,
                            pLicProduct->dwLanguageID,
                            (PBYTE)pLicProduct->szRequestProductId,
                            (_tcslen(pLicProduct->szRequestProductId) + 1) * sizeof(TCHAR),
                            (PBYTE)pLicProduct->szLicensedProductId,
                            (_tcslen(pLicProduct->szLicensedProductId) + 1) * sizeof(TCHAR),
                            &LicensedInfo, 
                            1,
                            &(CertExtension[dwNumExtensions].Value.pbData),
                            &(CertExtension[dwNumExtensions].Value.cbData)
                        );

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    dwNumExtensions++;        

    //
    // Add license server info into extension
    //
    CertExtension[dwNumExtensions].pszObjId = szOID_PKIX_MS_LICENSE_SERVER_INFO;
    CertExtension[dwNumExtensions].fCritical = TRUE;
    dwStatus=LSMsLicenseServerInfoToExtension(
                            g_szComputerName, 
                            (LPTSTR)g_pszServerPid,
                            g_pszScope,
                            &(CertExtension[dwNumExtensions].Value.pbData),
                            &(CertExtension[dwNumExtensions].Value.cbData)
                        ); 

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    dwNumExtensions++;

    //
    // Add policy module specific extension
    if( pLicProduct->pbPolicyData != NULL && pLicProduct->cbPolicyData != 0 )
    {
        CertExtension[dwNumExtensions].pszObjId = szOID_PKIS_PRODUCT_SPECIFIC_OID;
        CertExtension[dwNumExtensions].fCritical = TRUE;
        CertExtension[dwNumExtensions].Value.pbData = pLicProduct->pbPolicyData;
        CertExtension[dwNumExtensions].Value.cbData = pLicProduct->cbPolicyData;

        dwNumExtensions++;
    }

    //
    // Add CertAuthorityKeyId2Info for certificate chain
    dwStatus=TLSAddCertAuthorityKeyIdExtension(
                        g_szComputerName,
                        &pLicProduct->ulSerialNumber, 
                        CertExtension + dwNumExtensions
                    );
    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    dwNumExtensions++;

    // Add Access info

    dwStatus = TLSGenerateCertificate(
                        hCryptProv,
                        AT_SIGNATURE,
                        &pLicProduct->ulSerialNumber,
                        &IssuerRdn,
                        pSubjectRdn,
                        &pLicProduct->NotBefore,
                        &pLicProduct->NotAfter,
                        pLicProduct->pSubjectPublicKeyInfo,
                        dwNumExtensions,
                        CertExtension,
                        pcbEncodedCert,
                        ppbEncodedCert
                    );                      

cleanup:

    // Extensions. DO NOT FREE first two extensions
    for(int i=2; i < dwNumExtensions; i++)
    {
        FreeMemory(CertExtension[i].Value.pbData);
    }
    
    return (dwStatus != ERROR_SUCCESS) ? TLS_E_CREATE_CERT : ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////

DWORD
TLSGenerateClientCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwNumLicensedProduct,
    IN PTLSDBLICENSEDPRODUCT pLicProduct,
    IN WORD wLicenseChainDetail,
    OUT PBYTE* ppbEncodedCert,
    OUT PDWORD pcbEncodedCert
    )
/*++


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    PBYTE pbCert=NULL;
    DWORD cbCert=NULL;
    DWORD index;
    TLSClientCertRDN clientCertRdn;
    PCERT_NAME_BLOB pIssuerNameBlob = NULL;


    //
    // Create a in-memory store
    //
    hStore=CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    hCryptProv,
                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                    NULL
                );

    if(!hStore)
    {
        TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_OPEN_CERT_STORE, 
                    dwStatus=GetLastError()
                );

        goto cleanup;
    }
    
#ifndef ENFORCE_LICENSING
    
    pIssuerNameBlob = &g_SelfSignCertContext->pCertInfo->Subject;

#else

    if( g_SelfSignCertContext == NULL )
    {
        TLSASSERT(FALSE);
        dwStatus = TLS_E_INTERNAL;
        goto cleanup;
    }

    if(g_bHasHydraCert && g_hCaStore && wLicenseChainDetail == LICENSE_DETAIL_DETAIL)
    {
        pIssuerNameBlob = &g_LicenseCertContext->pCertInfo->Subject;
    }
    else
    {
        pIssuerNameBlob = &g_SelfSignCertContext->pCertInfo->Subject;
    }

#endif


    //
    // Generate client certificate and add to certstore
    //
    for(index = 0; index < dwNumLicensedProduct; index++)
    {
        if(pCertContext != NULL)
        {
            //
            // Need to keep one pCertContext for later use
            //
            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }

        clientCertRdn.type = LSCERT_CLIENT_INFO_TYPE;
        clientCertRdn.ClientInfo.szUserName = pLicProduct[index].szUserName;
        clientCertRdn.ClientInfo.szMachineName = pLicProduct[index].szMachineName;
        clientCertRdn.ClientInfo.pClientID = &pLicProduct[index].ClientHwid;

        dwStatus = TLSGenerateSingleCertificate(
                                    hCryptProv,
                                    pIssuerNameBlob,
                                    &clientCertRdn,
                                    pLicProduct[index].pSubjectPublicKeyInfo,
                                    pLicProduct+index,
                                    &pbCert,
                                    &cbCert
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Add certificate to store
        //
        pCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbCert,
                                        cbCert
                                    );

        if(pCertContext == NULL)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_CREATE_CERTCONTEXT, 
                    dwStatus=GetLastError()
                );  
            break;
        }

        //
        // always start from empty so CERT_STORE_ADD_ALWAYS
        //
        if(!CertAddCertificateContextToStore(hStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_ADD_CERT_TO_STORE, 
                    dwStatus=GetLastError()
                );
  
            break;
        }

        FreeMemory(pbCert);
        pbCert = NULL;
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        
#ifndef ENFORCE_LICENSING
        //
        // Add license server's certificate
        if(!CertAddCertificateContextToStore(hStore, g_LicenseCertContext, CERT_STORE_ADD_ALWAYS, NULL))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_ADD_CERT_TO_STORE, 
                    dwStatus=GetLastError()
                );  
            goto cleanup;
        }
#else

        //
        // we don't support LICENSE_DETAIL_MODERATE at this time, treat it as LICENSE_DETAIL_SIMPLE
        //
        if(g_bHasHydraCert && g_hCaStore && wLicenseChainDetail == LICENSE_DETAIL_DETAIL)
        {
            //
            // Chain issuer certificate with client certificate
            //
            if(!TLSChainIssuerCertificate(hCryptProv, g_hCaStore, hStore, pCertContext))
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_GENERATECLIENTELICENSE,
                        TLS_E_ADD_CERT_TO_STORE, 
                        dwStatus=GetLastError()
                    );  
                goto cleanup;
            }
        }
        else
        {
            //
            // Add license server's certificate
            if(!CertAddCertificateContextToStore(hStore, g_SelfSignCertContext, CERT_STORE_ADD_ALWAYS, NULL))
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_GENERATECLIENTELICENSE,
                        TLS_E_ADD_CERT_TO_STORE, 
                        dwStatus=GetLastError()
                    );  
                goto cleanup;
            }
        }
#endif             
        
        CRYPT_DATA_BLOB saveBlob;
        memset(&saveBlob, 0, sizeof(saveBlob));

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0) && (dwStatus=GetLastError()) != ERROR_MORE_DATA)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            goto cleanup;
        }

        if(!(saveBlob.pbData = (PBYTE)AllocateMemory(saveBlob.cbData)))
        {
            dwStatus=TLS_E_ALLOCATE_MEMORY;
            goto cleanup;
        }

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          LICENSE_BLOB_SAVEAS_TYPE,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_GENERATECLIENTELICENSE,
                    TLS_E_SAVE_STORE, 
                    dwStatus=GetLastError()
                );  
            goto cleanup;
        }
        
        *ppbEncodedCert = saveBlob.pbData;
        *pcbEncodedCert = saveBlob.cbData;
    }

cleanup:

    FreeMemory(pbCert);

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\hydrals-s.c ===
#include <hydrals_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\globals.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        globals.h
//
// Contents:    All global variable used in Hydra License Server
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __LS_GLOBALS_H
#define __LS_GLOBALS_H
#include "server.h"

#include "vss.h"
#include "vswriter.h"
#include "jetwriter.h"

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

//---------------------------------------------------------------------------
// All globals variable are declared in globals.cpp
//
#ifndef _NO_ODBC_JET
extern TLSDbWorkSpace* g_DbWorkSpace;
#endif



// Defaule server scope

extern CVssJetWriter *g_pWriter;
extern GUID idWriter;

extern TCHAR g_szScope[LSERVER_MAX_STRING_SIZE+1];
extern LPTSTR g_pszScope;

extern TCHAR g_szDatabaseFile[MAX_PATH+1];
extern TCHAR g_szDatabaseDir[MAX_PATH+1];
extern TCHAR g_szDatabaseFname[MAX_PATH+1];
extern TCHAR g_szDbUser[MAXUSERNAMELENGTH+1];
extern TCHAR g_szDbPwd[MAXUSERNAMELENGTH+1];

extern LPCTSTR szManufactureMS;

extern LONG g_NextKeyPackId;
extern LONG g_NextLicenseId;

extern PBYTE g_pbSecretKey;
extern DWORD g_cbSecretKey;


extern LPTSTR  g_pszServerUniqueId;
extern DWORD   g_cbServerUniqueId;

extern LPTSTR  g_pszServerPid;
extern DWORD   g_cbServerPid;

extern PBYTE  g_pbServerSPK;
extern DWORD  g_cbServerSPK;

extern DWORD g_GracePeriod;
extern BOOL  g_IssueTemporayLicense;

extern BOOL  g_bHasHydraCert;
extern PBYTE g_pbSignatureEncodedCert;
extern DWORD g_cbSignatureEncodedCert;

extern PBYTE g_pbExchangeEncodedCert;
extern DWORD g_cbExchangeEncodedCert;

extern TCHAR g_szHostName[MAXTCPNAME+1];
extern DWORD g_cbHostName;

extern TCHAR g_szComputerName[MAX_COMPUTERNAME_LENGTH+2];
extern DWORD g_cbComputerName;

extern PCCERT_CONTEXT  g_LicenseCertContext;
extern HCRYPTPROV g_hCryptProv;

extern PCCERT_CONTEXT g_SelfSignCertContext;

extern DWORD g_GeneralDbTimeout;
extern DWORD g_EnumDbTimeout;
extern DWORD g_dwMaxDbHandles;

#if ENFORCE_LICENSING
extern HCERTSTORE  g_hCaStore;
extern HKEY  g_hCaRegKey;
#endif

extern HCRYPTKEY g_SignKey;
extern HCRYPTKEY g_ExchKey;
//extern PBYTE g_pbDomainSid;
//extern DWORD g_cbDomainSid;
extern DWORD g_SrvRole;

extern LPTSTR g_szDomainGuid;

extern PCERT_EXTENSIONS g_pCertExtensions;
extern DWORD            g_cbCertExtensions;

extern FILETIME        g_ftCertExpiredTime;
extern FILETIME        g_ftLastShutdownTime;

extern DWORD           g_dwTlsJobInterval;
extern DWORD           g_dwTlsJobRetryTimes;
extern DWORD           g_dwTlsJobRestartTime;

extern SERVER_ROLE_IN_DOMAIN g_ServerRoleInDomain;

extern DWORD            g_LowLicenseCountWarning;

extern DWORD g_EsentMaxCacheSize;
extern DWORD g_EsentStartFlushThreshold;
extern DWORD g_EsentStopFlushThreadhold;

//
//  Reissuance Parameters
//

extern DWORD g_dwReissueLeaseMinimum;
extern DWORD g_dwReissueLeaseRange;
extern DWORD g_dwReissueLeaseLeeway;
extern DWORD g_dwReissueExpireThreadSleep;

//
// Counters
//

extern LONG g_lTemporaryLicensesIssued;
extern LONG g_lPermanentLicensesIssued;
extern LONG g_lPermanentLicensesReissued;
extern LONG g_lPermanentLicensesReturned;
extern LONG g_lLicensesMarked;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\gencert.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        gencert.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __GEN_CERT_H__
#define __GEN_CERT_H__
#include "server.h"
   

#ifdef __cplusplus
extern "C" {
#endif

    BOOL 
    TLSEncryptBase64EncodeHWID(
        PHWID pHwid, 
        DWORD* cbBase64EncodeHwid, 
        PBYTE* szBase64EncodeHwid
    );

    DWORD
    TLSExportPublicKey(
        IN HCRYPTPROV hCryptProv,
        IN DWORD      dwKeyType,
        IN OUT PDWORD pcbByte,
        IN OUT PCERT_PUBLIC_KEY_INFO  *ppbByte
    );

    DWORD 
    TLSCryptEncodeObject(  
        IN  DWORD   dwEncodingType,
        IN  LPCSTR  lpszStructType,
        IN  const void * pvStructInfo,
        OUT PBYTE*  ppbEncoded,
        OUT DWORD*  pcbEncoded
    );

    DWORD
    TLSChainProprietyCertificate(
        HCRYPTPROV  hCryptProv,
        BOOL        bTemp,
        PBYTE       pbLicense, 
        DWORD       cbLicense, 
        PBYTE*      pbChained, 
        DWORD*      cbChained
    );


    DWORD
    TLSVerifyProprietyChainedCertificate(
        HCRYPTPROV  hCryptProv, 
        PBYTE       pbData, 
        DWORD       cbData
    );

    DWORD
    TLSGenerateClientCertificate(
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwNumLicensedProduct,
        IN PTLSDBLICENSEDPRODUCT pLicProduct,
        IN WORD wLicenseChainDetail,
        OUT PBYTE* ppbEncodedCert,
        OUT PDWORD pcbEncodedCert
    );

    DWORD 
    TLSCreateSelfSignCertificate(
        HCRYPTPROV,
        DWORD,
        PBYTE,
        DWORD,
        DWORD,
        PCERT_EXTENSION,
        PDWORD,
        PBYTE*
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\globals.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        globals.cpp 
//
// Contents:    Global varaiables
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "windows.h"
#include "winsock2.h"

#include "tlsjob.h"
#include "wkspace.h"
#include "srvdef.h"


#ifndef _NO_ODBC_JET
TLSDbWorkSpace* g_DbWorkSpace;
#endif

// Defaule server scope
TCHAR g_szScope[LSERVER_MAX_STRING_SIZE+1];
LPTSTR g_pszScope;

// Full Path to database file name.
TCHAR g_szDatabaseFile[MAX_PATH+1];

// database file directory.
// JetBlue require last character be '\'
TCHAR g_szDatabaseDir[MAX_PATH+1];
TCHAR g_szDatabaseFname[MAX_PATH+1];

TCHAR g_szDbUser[MAXUSERNAMELENGTH+1];
TCHAR g_szDbPwd[MAXUSERNAMELENGTH+1];


LPCTSTR szManufactureMS=_TEXT("Microsoft");

LONG g_NextKeyPackId=0;
LONG g_NextLicenseId=0;

PBYTE g_pbSecretKey=NULL;
DWORD g_cbSecretKey=0;


LPTSTR  g_pszServerUniqueId = NULL;
DWORD   g_cbServerUniqueId = 0;

LPTSTR  g_pszServerPid = NULL;
DWORD   g_cbServerPid = 0;

PBYTE  g_pbServerSPK = NULL;
DWORD  g_cbServerSPK = 0;

DWORD g_GracePeriod=GRACE_PERIOD;     // in days.
BOOL  g_IssueTemporayLicense=TRUE;

BOOL  g_bHasHydraCert=FALSE;
PBYTE g_pbSignatureEncodedCert=NULL;
DWORD g_cbSignatureEncodedCert=0;

PBYTE g_pbExchangeEncodedCert=NULL;
DWORD g_cbExchangeEncodedCert=0;

TCHAR g_szHostName[MAXTCPNAME+1];
DWORD g_cbHostName=sizeof(g_szHostName)/sizeof(g_szHostName[0]);

TCHAR g_szComputerName[MAX_COMPUTERNAME_LENGTH+2];
DWORD g_cbComputerName=MAX_COMPUTERNAME_LENGTH+1;

PCCERT_CONTEXT  g_LicenseCertContext=NULL;

//
// Self-signed certificates...
//
PCCERT_CONTEXT g_SelfSignCertContext = NULL;

HCRYPTPROV g_hCryptProv=NULL;

DWORD g_GeneralDbTimeout = DEFAULT_CONNECTION_TIMEOUT;  // Time out for acquiring DB handle
DWORD g_EnumDbTimeout = DB_ENUM_WAITTIMEOUT;            // Time out for acquiring enumeration DB handle
DWORD g_dwMaxDbHandles = DEFAULT_DB_CONNECTIONS;        // number of connection to DB

#if ENFORCE_LICENSING
HCERTSTORE  g_hCaStore=NULL;
HKEY  g_hCaRegKey=NULL;
#endif

HCRYPTKEY g_SignKey=NULL;
HCRYPTKEY g_ExchKey=NULL;
//PBYTE g_pbDomainSid=NULL;
//DWORD g_cbDomainSid=0;
DWORD g_SrvRole=0;

LPTSTR g_szDomainGuid = NULL;

PCERT_EXTENSIONS g_pCertExtensions;
DWORD            g_cbCertExtensions;

FILETIME         g_ftCertExpiredTime;
FILETIME        g_ftLastShutdownTime={0, 0};

DWORD           g_dwTlsJobInterval=DEFAULT_JOB_INTERVAL;
DWORD           g_dwTlsJobRetryTimes=DEFAULT_JOB_RETRYTIMES;
DWORD           g_dwTlsJobRestartTime=DEFAULT_JOB_INTERVAL;

SERVER_ROLE_IN_DOMAIN g_ServerRoleInDomain;

DWORD           g_LowLicenseCountWarning=0;

DWORD           g_EsentMaxCacheSize=0;
DWORD           g_EsentStartFlushThreshold=0;
DWORD           g_EsentStopFlushThreadhold=0;

//
//  Reissuance Parameters
//

DWORD g_dwReissueLeaseMinimum;
DWORD g_dwReissueLeaseRange;
DWORD g_dwReissueLeaseLeeway;
DWORD g_dwReissueExpireThreadSleep;

//
// Counters
//

LONG g_lTemporaryLicensesIssued = 0;
LONG g_lPermanentLicensesIssued = 0;
LONG g_lPermanentLicensesReissued = 0;
LONG g_lPermanentLicensesReturned = 0;
LONG g_lLicensesMarked = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\init.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        init.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __INIT_H__
#define __INIT_H__



#ifdef __cplusplus
extern "C" {
#endif
    DWORD
    TLSPrepareForBackupRestore();

    DWORD
    TLSRestartAfterBackupRestore(BOOL);

    void 
    ServerShutdown();

    DWORD
    GetLicenseServerRole();

    void
    GetJobObjectDefaults(
        PDWORD pdwInterval,
        PDWORD pdwRetries,
        PDWORD pdwRestartTime
    );

    void
    SetServiceLastShutdownTime();


    void
    GetServiceLastShutdownTime(
        OUT FILETIME* ft
    );

    DWORD 
    StartServerInitThread( 
        void* p 
    );

    HANDLE 
    ServerInit(
        BOOL bDebug
    );

    BOOL 
    TLSLoadServerCertificate();

    DWORD
    ServiceInitCrypto(
        IN BOOL bCreateNewKeys,
        IN LPCTSTR pszKeyContainer,
        OUT HCRYPTPROV* phCryptProv,
        OUT HCRYPTKEY* phSignKey,
        OUT HCRYPTKEY* phExchKey
    );

    DWORD 
    InitCryptoAndCertificate();

    DWORD
    TLSReGenerateKeys(
        BOOL bReGenKeyOnly
    );

    DWORD
    TLSReGenKeysAndReloadServerCert(
        BOOL bReGenKeyOnly
    );

    DWORD
    TLSReGenSelfSignCert(
        IN HCRYPTPROV hCryptProv,
        IN PBYTE pbSPK,
        IN DWORD cbSPK,
        IN DWORD dwNumExtensions,
        IN PCERT_EXTENSION pCertExtensions
    );

    void
    CleanSetupLicenseServer();

    DWORD
    TLSLoadVerifyLicenseServerCertificates();

    DWORD
    TLSRestoreLicenseServerCertificate(
        LPCTSTR pszSourceRegKey,
        LPCTSTR pszTargetRegKey
    );

    BOOL
    CanIssuePermLicense();

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\keypack.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        keypack.cpp
//
// Contents:    
//              KeyPack Table related function.
//
// History:     
//          Feb. 4, 98      HueiWang        Created.
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "keypack.h"
#include "misc.h"

//++--------------------------------------------------------------------
static BOOL
ValidKeyPackParameter(
    IN PTLSLICENSEPACK lpKeyPack, 
    IN BOOL bAdd
    )
/*++

Abstract:

    Validate Licese KeyPack value

Parameter:


Returns:

++*/
{
    BOOL bValid=FALSE;
    UCHAR ucAgreementType = (lpKeyPack->ucAgreementType & ~LSKEYPACK_RESERVED_TYPE);
    UCHAR ucKeyPackStatus = (lpKeyPack->ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED);
    do {
        // verify input parameter
        if(ucAgreementType < LSKEYPACKTYPE_FIRST || 
           ucAgreementType > LSKEYPACKTYPE_LAST)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucKeyPackType - %d\n"),
                    lpKeyPack->ucAgreementType
                );
                   
            break;
        }

        if((ucKeyPackStatus < LSKEYPACKSTATUS_FIRST || 
            ucKeyPackStatus > LSKEYPACKSTATUS_LAST) &&
            ucKeyPackStatus != LSKEYPACKSTATUS_DELETE)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucKeyPackStatus - %d\n"),
                    lpKeyPack->ucKeyPackStatus
                );
                
            break;
        }

        if(lpKeyPack->ucLicenseType < LSKEYPACKLICENSETYPE_FIRST || 
           lpKeyPack->ucLicenseType > LSKEYPACKLICENSETYPE_LAST)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucLicenseType - %d\n"),
                    lpKeyPack->ucLicenseType
                );
       
            break;
        }

        if(!bAdd)
        {
            bValid = TRUE;
            break;
        }

        //
        // Following value is required for adding entry into keypack
        //
        if(lpKeyPack->ucChannelOfPurchase < LSKEYPACKCHANNELOFPURCHASE_FIRST ||
           lpKeyPack->ucChannelOfPurchase > LSKEYPACKCHANNELOFPURCHASE_LAST)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Invalid ucChannelOfPurchase - %d\n"),
                    lpKeyPack->ucChannelOfPurchase
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szCompanyName))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szCompanyName\n")
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szKeyPackId))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szKeyPackId\n")
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szProductId))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szProductId\n")
                );
       
            break;
        }

        if(!_tcslen(lpKeyPack->szBeginSerialNumber))
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_KEYPACK,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Null szBeginSerialNumber\n")
                );
       
            break;
        }

        bValid=TRUE;
    } while(FALSE);
 
    return bValid;
}

//++-----------------------------------------------------------
void
TLSDBLockKeyPackTable()
/*++

Abstract:

    Lock both LicPack and LicPackStatus table.


Parameter:

    None.

++*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Locking table KeyPackTable\n")
        );
            
    LicPackTable::LockTable();
}

//++-----------------------------------------------------------
void
TLSDBUnlockKeyPackTable()
/*++

Abstract:

    Unlock both LicPack and LicPackStatus table.

Parameter:

    None:

++*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Unlocking table KeyPackTable\n")
        );

    LicPackTable::UnlockTable();
}

//++--------------------------------------------------------------
DWORD
TLSDBKeyPackFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bMatchAllParm,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpKeyPack,
    IN OUT PTLSLICENSEPACK lpFound
    )
/*++

Abstract:

    Find a license pack based on search parameter.

Parameter:

    pDbWkSpace : workspace handle.
    bMatchAllParm : TRUE if match all parameter, FALSE otherwise.
    dwSearchParm : search parameter.
    lpKeyPack : value to search for.
    lpFound : record found.

Return:


++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    //
    // Find the record in LicPack table
    //        
    bSuccess = licpackTable.FindRecord(
                                bMatchAllParm,
                                dwSearchParm,
                                *lpKeyPack,
                                *lpFound
                            );

    if(bSuccess != TRUE)
    {
        if(licpackTable.GetLastJetError() == JET_errRecordNotFound)
        {
            SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        }
        else
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(licpackTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licpackTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(
                    dwStatus = (SET_JB_ERROR(licpackTable.GetLastJetError()))
                );

            TLSASSERT(licpackTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }
   

    return dwStatus;                        
}

//++-------------------------------------------------------------------
DWORD
TLSDBKeyPackAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Add an entry into LicPack and LicPackStatus table.

Parameter:

    pDbWkSpace :
    lpKeyPack ;

Returns:
    
++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSLICENSEPACK found;
    BOOL bSuccess;

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    found.pbDomainSid = NULL;
    found.cbDomainSid = 0;

    //
    //
    //
    TLSDBLockKeyPackTable();

    TLSASSERT(pDbWkSpace != NULL && lpKeyPack != NULL);
    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    // lpKeyPack->pbDomainSid == NULL || lpKeyPack->cbDomainSid == 0 ||
    if( _tcslen(lpKeyPack->szInstallId) == 0 || _tcslen(lpKeyPack->szTlsServerName) == 0 )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // make sure no duplicate entry via primary index
    dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_PROCESS_DWINTERNAL,
                            lpKeyPack,
                            &found
                        );
    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLS_E_DUPLICATE_RECORD;
        goto cleanup;
    }

    dwStatus = ERROR_SUCCESS;

    //
    // Mark internal field - 
    // 
    switch( (lpKeyPack->ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) )
    {
        case LSKEYPACKTYPE_SELECT:
        case LSKEYPACKTYPE_RETAIL:
        case LSKEYPACKTYPE_CONCURRENT:
        case LSKEYPACKTYPE_OPEN:
            // number of license available to client
            lpKeyPack->dwNumberOfLicenses = lpKeyPack->dwTotalLicenseInKeyPack;
            break;

        default:
            // number of licenses issued.
            lpKeyPack->dwNumberOfLicenses = 0;
            break;
    }

    //
    // Begin serial number in this keypack
    //
    lpKeyPack->dwNextSerialNumber = 1;
    GetSystemTimeAsFileTime(&(lpKeyPack->ftLastModifyTime));

    //
    // Mark beta keypack.
    //
    if(TLSIsBetaNTServer() == TRUE)
    {
        lpKeyPack->ucKeyPackStatus |= LSKEYPACKSTATUS_BETA;
    }

    //
    // insert the record
    //
    bSuccess = licpackTable.InsertRecord(
                                *lpKeyPack
                            );

    if(bSuccess == FALSE)
    {
        if(licpackTable.GetLastJetError() == JET_errKeyDuplicate)
        {
            SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
        }
        else
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(licpackTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licpackTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    }
    
cleanup:

    TLSDBUnlockKeyPackTable();
    SetLastError(dwStatus);
    return dwStatus;
}

//-----------------------------------------------------

DWORD
TLSDBKeyPackDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bDeleteAllRecord,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Delete an entry from both LicPack and LicPackStatus table.

Parameter:

    pDbWkSpace : workspace handle.
    bDeleteAllRecord : Delete all record with same ID.
    lpKeyPack : record to be delete.

Returns:

Note:

    If not deleting same record, current record must be point
    to the record that going to be deleted.

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;

    LicPackTable& licpackTable = pDbWkSpace->m_LicPackTable;

    GetSystemTimeAsFileTime(&(lpKeyPack->ftLastModifyTime));

    //
    // BACKUP - Need to update this record to deleted state instead of delete it.
    //

    if(bDeleteAllRecord == TRUE)
    {
        //
        // Delete record from LicPack Table.
        //
        bSuccess = licpackTable.DeleteAllRecord(
                                    TRUE,
                                    LICENSEDPACK_PROCESS_DWINTERNAL,
                                    *lpKeyPack
                                );
    }
    else
    {
        bSuccess = licpackTable.DeleteRecord();
    }
                                    
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
        if(licpackTable.GetLastJetError() != JET_errRecordNotFound)
        {

            LPTSTR pString = NULL;
            
            TLSGetESEError(licpackTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licpackTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(FALSE);
        }
    }



    return dwStatus;
}

//-----------------------------------------------------

DWORD
TLSDBKeyPackUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bPointerOnRecord,
    IN DWORD dwUpdateParm,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    TLSLICENSEPACK found;

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    if(bPointerOnRecord == FALSE)
    {
        found.pbDomainSid = NULL;

        dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_PROCESS_DWINTERNAL,
                            lpKeyPack,
                            &found
                        );


        lpKeyPack->dwKeyPackId = found.dwKeyPackId;

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }


#if DBG
    {
        //
        // try to cache some bug...
        //
        TLSLICENSEPACK found1;

        found.pbDomainSid = NULL;

        bSuccess = licpackTable.FetchRecord( found1, 0xFFFFFFFF );

        //
        // Make sure we update right record
        if( found1.dwKeyPackId != lpKeyPack->dwKeyPackId )
        {
            TLSASSERT(FALSE);
        }

        //
        // check input parameter
        if( ValidKeyPackParameter( lpKeyPack, FALSE ) == FALSE )
        {
            TLSASSERT(FALSE);
        }
    }

#endif

    //
    // Update the timestamp for this record.
    //
    GetSystemTimeAsFileTime(&(lpKeyPack->ftLastModifyTime));
    bSuccess = licpackTable.UpdateRecord(
                                *lpKeyPack,
                                (dwUpdateParm & ~LICENSEDPACK_PROCESS_DWINTERNAL) | LICENSEDPACK_PROCESS_MODIFYTIME
                            );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
        
        TLSGetESEError(licpackTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licpackTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

cleanup:

    return dwStatus;
}    

//-----------------------------------------------------

DWORD
TLSDBKeyPackUpdateNumOfAvailableLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bAdd, 
    IN PTLSLICENSEPACK lpKeyPack 
    )
/*++

Abstract:

    Update number of license available .

Parameter:

    pDbWkSpace : workspace handle.
    bAdd : TRUE if add license 
    lpKeyPack : 

Returns:

++*/
{
    DWORD   dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(pDbWkSpace != NULL);
        return dwStatus;
    }
    
    TLSLICENSEPACK found;
    DWORD   dwNumberLicenseToAddRemove;
    BOOL    bRemoveMoreThanAvailable=FALSE;

    found.pbDomainSid = NULL;

    TLSDBLockKeyPackTable();
    dwStatus = TLSDBKeyPackFind(
                        pDbWkSpace,
                        TRUE,
                        LICENSEDPACK_PROCESS_DWINTERNAL,
                        lpKeyPack,
                        &found
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwNumberLicenseToAddRemove = lpKeyPack->dwTotalLicenseInKeyPack;

    *lpKeyPack = found;

    if(dwNumberLicenseToAddRemove == 0)
    {
        // query only, a hook so that test program can get actual
        // numbers - Jet not re-reading MDB file problem
        goto cleanup;
    }

    //
    // Only allow add/remove license on retail
    //
    if( (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) != LSKEYPACKTYPE_RETAIL &&
        (found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) != LSKEYPACKTYPE_CONCURRENT)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_KEYPACK,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("LSDBKeyPackUpdate : Invalid parameter...\n")
            );

        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(bAdd)
    {
        // increase both total and number available
        found.dwNumberOfLicenses += dwNumberLicenseToAddRemove;
        found.dwTotalLicenseInKeyPack += dwNumberLicenseToAddRemove;
    }
    else
    {
        //
        // if number of licenses to remove is greater that what's available, 
        // remove all available license and set the return code to invalid data.
        //
        if(found.dwNumberOfLicenses < dwNumberLicenseToAddRemove)
        {
            bRemoveMoreThanAvailable = TRUE;
        }

        dwNumberLicenseToAddRemove = min(dwNumberLicenseToAddRemove, found.dwNumberOfLicenses);
        found.dwNumberOfLicenses -= dwNumberLicenseToAddRemove;
        found.dwTotalLicenseInKeyPack -= dwNumberLicenseToAddRemove;
    }

    dwStatus = TLSDBKeyPackSetValues(
                            pDbWkSpace,
                            TRUE, 
                            LSKEYPACK_SEARCH_TOTALLICENSES | LSKEYPACK_EXSEARCH_AVAILABLE, 
                            &found
                        );

    *lpKeyPack = found;

cleanup:

    TLSDBUnlockKeyPackTable();
    if(dwStatus == ERROR_SUCCESS && bRemoveMoreThanAvailable)
        SetLastError(dwStatus = TLS_W_REMOVE_TOOMANY);

    return dwStatus;
}

//+-----------------------------------------------------------------
DWORD
TLSDBKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack  // return internal tracking ID
    )
/*++

Abstract:

    Install a product keypack into keypack table, routine only set 
    keypack status to pending, must call corresponding set status
    routine to activate key pack.

Parameters:

    pDbWkSpace : Workspace handle.
    lpKeyPack : value to be inserted.

Returns:

++*/
{
    DWORD lNextKeyPackId;
    DWORD dwStatus;

    if(!ValidKeyPackParameter(lpKeyPack, TRUE))
    {
        SetLastError(TLS_E_INVALID_DATA);
        return TLS_E_INVALID_DATA;
    }

    TLSLICENSEPACK found;
    TLSDBLockKeyPackTable();

    found.pbDomainSid = NULL;

    //
    // No duplicate entry for product installed
    //
    dwStatus = TLSDBKeyPackFind(
                            pDbWkSpace,
                            TRUE,
                            LICENSEDPACK_FIND_PRODUCT,
                            lpKeyPack,
                            &found
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        // Product already installed
        switch( (found.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED) )
        {
            case LSKEYPACKSTATUS_TEMPORARY:
                // case 1 : keypack is installed by temporary license
                if(found.ucAgreementType == lpKeyPack->ucAgreementType)
                {
                    dwStatus = TLS_E_DUPLICATE_RECORD;
                }
                break;

            case LSKEYPACKSTATUS_ACTIVE:
            case LSKEYPACKSTATUS_PENDING:
                // case 2 : duplicate entry
                dwStatus = TLS_E_DUPLICATE_RECORD;
                break;
            
            case LSKEYPACKSTATUS_RETURNED:
            case LSKEYPACKSTATUS_REVOKED:
            case LSKEYPACKSTATUS_OTHERS:
                // de-activated license key pack.
                // keep it.
                break;

            default:
                dwStatus = TLS_E_CORRUPT_DATABASE;

                #if DBG
                TLSASSERT(FALSE);
                #endif
        }

        if(dwStatus != ERROR_SUCCESS)
            goto cleanup;
    }
    else if(dwStatus == TLS_E_RECORD_NOTFOUND)
    {
        //
        // Always use new keypack ID 
        // temporary license will be deleted after all license
        // has been returned.
        //
        lpKeyPack->dwKeyPackId = TLSDBGetNextKeyPackId();

        dwStatus = TLSDBKeyPackAddEntry(
                                pDbWkSpace,
                                lpKeyPack
                            );
    }

cleanup:

    TLSDBUnlockKeyPackTable();
    return dwStatus;
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL  bMatchAll,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpSearch
    )
/*

Abstract:

    Begin enumeration of licensepack table.

Parameter:

    pDbWkSpace : workspace handle.
    bMatchAll : match all search value.
    dwSearchParm : value to search.
    lpSearch : search value

Return:


*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }      

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

    bSuccess = licpackTable.EnumerateBegin(
                                bMatchAll,
                                dwSearchParm,
                                lpSearch
                            );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
        
        TLSGetESEError(licpackTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licpackTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }
    
    return dwStatus;
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Fetch next row of record that match search condition.

Parameters:

    pDbWkSpace : workspace handle.
    lpKeyPack : return founded keypack.

Return:


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    //FreeTlsLicensePack(lpKeyPack);

    LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;
    
    switch(licpackTable.EnumerateNext(*lpKeyPack))
    {
        case RECORD_ENUM_ERROR:
            {
                LPTSTR pString = NULL;
        
                TLSGetESEError(licpackTable.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        licpackTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }
            }

            dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError());
            TLSASSERT(FALSE);
            break;

        case RECORD_ENUM_MORE_DATA:
            dwStatus = ERROR_SUCCESS;
            break;

        case RECORD_ENUM_END:
            dwStatus = TLS_I_NO_MORE_DATA;
    }

    return dwStatus;
}

//+-------------------------------------------------------------------
void
TLSDBKeyPackEnumEnd( 
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*++

Abstract:

    End enumeration of licensepack.

Parameter:

    pDbWkSpace : workspace handle.
++*/
{
    TLSASSERT(pDbWkSpace != NULL);
    pDbWkSpace->m_LicPackTable.EnumerateEnd();
    return;
}


//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackSetValues(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL         bPointerOnRecord,
    IN DWORD        dwSetParm,
    IN PTLSLICENSEPACK lpKeyPack
    )
/*++

Abstract:

    Set column value of a license pack record.

Parameter;

    pDbWkSpace : workspace handle.
    bInternal : call is from internal routine, no error checking.
    dwSetParm : Columns to be set.
    lpKeyPack : value to be set.

Returns.

++*/
{

    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(bPointerOnRecord == FALSE)
    {
        TLSLICENSEPACK found;

        // Find this keypack's internal keypack id
        dwStatus = TLSDBKeyPackFind(
                                pDbWkSpace,
                                TRUE,
                                LICENSEDPACK_FIND_PRODUCT,
                                lpKeyPack,
                                &found
                            );

        //FreeTlsLicensePack(&found);

        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        lpKeyPack->dwKeyPackId = found.dwKeyPackId;
    }

    if(lpKeyPack->ucKeyPackStatus == LSKEYPACKSTATUS_DELETE)
    {
        dwStatus = TLSDBKeyPackDeleteEntry(
                                    pDbWkSpace,
                                    TRUE,       // delete all records with same ID
                                    lpKeyPack
                                );
    }
    else
    {
        dwStatus = TLSDBKeyPackUpdateEntry(
                                    pDbWkSpace,
                                    TRUE,
                                    dwSetParm,
                                    lpKeyPack
                                );
    }

cleanup:
    return dwStatus;
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackSetStatus( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD      dwSetStatus,
    IN PTLSLICENSEPACK  lpKeyPack
    )
/*++

Abstract:

    Stub routine for RPC to set status of a keypack


++*/
{
    return TLSDBKeyPackSetValues(
                        pDbWkSpace, 
                        FALSE, 
                        dwSetStatus, 
                        lpKeyPack
                    );
}

//+-------------------------------------------------------------------
DWORD
TLSDBKeyPackGetAvailableLicenses( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lplsKeyPack,
    IN OUT LPDWORD lpdwAvail
    )
/*++

Abstract:

    retrieve number of available licenses for the key pack.

Parameter:

    pDbWkSpace : workspace handle.
    dwSearchParm : search parameters.
    lpLsKeyPack : search value.
    lpdwAvail : return number of available licenses.

Return:

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSLICENSEPACK found;

    dwStatus = TLSDBKeyPackFind(
                        pDbWkSpace,
                        TRUE,
                        dwSearchParm,
                        lplsKeyPack,
                        &found
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        switch(found.ucAgreementType)
        {
            case LSKEYPACKTYPE_SELECT:
            case LSKEYPACKTYPE_RETAIL:
            case LSKEYPACKTYPE_CONCURRENT:
            case LSKEYPACKTYPE_OPEN:
                *lpdwAvail = found.dwNumberOfLicenses;
                break;

            default:
                *lpdwAvail = LONG_MAX;
        }
    }

    //FreeTlsLicensePack(&found);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\init.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        init.cpp
//
// Contents:    
//              All hydra license server initialization code.
//
// History:     
//          Feb. 4, 98      HueiWang    Created
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "init.h"
#include "misc.h"
#include "tlscert.h"
#include "pid.h"
#include "upgdb.h"
#include "lkplite.h"
#include "gencert.h"
    

//
// file scope define
//
#define DEFAULT_CSP     MS_DEF_PROV
#define PROVIDER_TYPE   PROV_RSA_FULL

DWORD
TLSStartupLSDB(
    IN BOOL bCheckDBStatus,
    IN DWORD dwMaxDbHandles,
    IN BOOL bStartEmptyIfError,
    IN LPTSTR pszChkPointDirPath,
    IN LPTSTR pszTempDirPath,
    IN LPTSTR pszLogDirPath,
    IN LPTSTR pszDbFile,
    IN LPTSTR pszUserName,
    IN LPTSTR pszPassword
);

DWORD
TLSLoadRuntimeParameters();

DWORD
TLSStartLSDbWorkspaceEngine(
    BOOL,
    BOOL,
    BOOL,
    BOOL
);

////////////////////////////////////////////////////////////////////////////
//
//
// Global Variables
//
//
////////////////////////////////////////////////////////////////////////////
static BOOL g_ValidDatabase=FALSE;

#if DBG
void
EnsureExclusiveAccessToDbFile( 
    LPTSTR szDatabaseFile 
    )
/*++

--*/
{
    HANDLE hFile = NULL;
    DWORD dwErrCode;

    hFile = CreateFile(
                    szDatabaseFile,
                    GENERIC_WRITE | GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        dwErrCode = GetLastError();

        if( ERROR_FILE_NOT_FOUND != dwErrCode )
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("EnsureExclusiveAccessToDbFile() failed with %d\n"),
                    dwErrCode
                );
        }
        else if( ERROR_SHARING_VIOLATION == dwErrCode )
        {
            // special attention...
            TLSASSERT( FALSE );
        }
        else
        {
            TLSASSERT( FALSE );
        }
    }
    else
    {
        CloseHandle( hFile );
    }                    

    return;
}
#endif


////////////////////////////////////////////////////////////////////////////
BOOL
TLSGenerateLSDBBackupFileName(
    IN LPCTSTR pszPath,
    IN OUT LPTSTR pszTempFile
    )
/*++

--*/
{
    DWORD dwTempRandom;

    if (lstrlen(pszPath)+13 > MAX_PATH)
    {
        // path too long
        return FALSE;
    }

    //
    // Generate a temporary file name.
    //
    dwTempRandom = GetTempFileName(
                            pszPath,
                            _TEXT("TLS"),
                            0,
                            pszTempFile
                        );

    if(dwTempRandom == 0)
    {
        //
        // GetTempFileName failed
        // Generate a backup file name based on current time,
        // possibility of collision is high
        //
        SYSTEMTIME LocalTime;

        if (lstrlen(pszPath)+25 > MAX_PATH)
        {
            // path too long
            return FALSE;
        }


        GetLocalTime(&LocalTime);

        wsprintf(
                pszTempFile,
                _TEXT("%s\\LSDBBackup.%02d%02d%02d%02d%02d%02d"),
                pszPath,
                LocalTime.wYear,
                LocalTime.wMonth,
                LocalTime.wDay,
                LocalTime.wHour,
                LocalTime.wMinute,
                LocalTime.wSecond
            );
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
BOOL
CanIssuePermLicense()
{
#ifndef ENFORCE_LICENSING
    return TRUE;
#else
    if(g_bHasHydraCert == TRUE || (g_pbServerSPK != NULL && g_cbServerSPK != 0))
    {
        return TRUE;
    }

    return FALSE;
#endif
}

/////////////////////////////////////////////////////////////////////////////
void
GetServiceLastShutdownTime(
    OUT FILETIME* ft
    )
/*++

--*/
{
    *ft = g_ftLastShutdownTime;
    return;
}

//---------------------------------------------------------------------
void
SetServiceLastShutdownTime()
{
    GetSystemTimeAsFileTime(&g_ftLastShutdownTime);
}
    
//---------------------------------------------------------------------
void
GetJobObjectDefaults(
    PDWORD pdwInterval,
    PDWORD pdwRetries,
    PDWORD pdwRestartTime
    )
/*++

--*/
{
    *pdwInterval = g_dwTlsJobInterval;
    *pdwRetries = g_dwTlsJobRetryTimes;
    *pdwRestartTime = g_dwTlsJobRestartTime;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
GetLicenseServerRole()
{
    return g_SrvRole;
}

/////////////////////////////////////////////////////////////////////////////

void 
FirstTimeSetTotalLicenses()
{  
    HKEY hBase=NULL;
    DWORD dwStatus;
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+1];
    DWORD cbProductId;
    DWORD index=0;
    FILETIME ft;
    DWORD dwKeyType;
    DWORD dwValue;
    DWORD cbValue;

    PTLSDbWorkSpace pDbWkSpace=NULL;

    //
    // verify key exist, if not, not first time startup
    dwStatus=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, 
                    FIRSTTIME_STARTUP_REGBASE,
                    0,
                    KEY_ALL_ACCESS,
                    &hBase
                );
    if(dwStatus != ERROR_SUCCESS)
        return;

    pDbWkSpace = AllocateWorkSpace( g_GeneralDbTimeout );
    if(pDbWkSpace == FALSE)
    {
        //
        // BUG BUG - should be initialization error but ignore for now
        //
        return;
    }

    do {
        cbProductId=sizeof(szProductId)/sizeof(szProductId[0]) - 1;
        cbValue = sizeof(dwValue);
        dwStatus=RegEnumValue(
                        hBase, 
                        index++, 
                        szProductId, 
                        &cbProductId, 
                        NULL, 
                        &dwKeyType, 
                        (LPBYTE)&dwValue, 
                        &cbValue);

        if(dwStatus != ERROR_SUCCESS)
            break;

        if(dwKeyType == REG_DWORD && dwStatus == ERROR_SUCCESS)
        {
            DWORD total, numAvail;

            if(!_tcsicmp(szProductId, HYDRAPRODUCT_EXISTING_SKU))
            {
                total = dwValue;
                numAvail = 0;
            }
            else 
            {
                total = dwValue;
                numAvail = dwValue;
            }

            //
            // TODO - find the key pack and set the available license
            //
            assert(FALSE);
        }
    } while(TRUE);

    RegCloseKey(hBase);
    RegDeleteKey(
            HKEY_LOCAL_MACHINE, 
            FIRSTTIME_STARTUP_REGBASE
        );

    if(pDbWkSpace)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }
    return;        
}

/////////////////////////////////////////////////////////////////////////////

void 
ServerShutdown()
{
#if ENFORCE_LICENSING
    if(g_hCaStore)
    {
        CertCloseStore(
                    g_hCaStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    if(g_hCaRegKey)
    {
        RegCloseKey(g_hCaRegKey);
    }
#endif

    if(g_SignKey)
    {
        CryptDestroyKey(g_SignKey);
    }

    if(g_ExchKey)
    {
        CryptDestroyKey(g_ExchKey);
    }

    TLServerLastRun lastRun;

    memset(&lastRun, 0, sizeof(TLServerLastRun));
    lastRun.dwVersion = LSERVER_LSA_LASTRUN_VER_CURRENT;
    lastRun.ftLastShutdownTime = g_ftLastShutdownTime;

    // if unclean shutdown or can't get next ID, set to 0
    if( g_ValidDatabase == FALSE ||
        TLSDBGetMaxKeyPackId(g_DbWorkSpace, (DWORD *)&g_NextKeyPackId) == FALSE ||
        TLSDBGetMaxLicenseId(g_DbWorkSpace, (DWORD *)&g_NextLicenseId) == FALSE )
    {
        g_NextKeyPackId = 0;
        g_NextLicenseId = 0;
    }

    lastRun.dwMaxKeyPackId = g_NextKeyPackId;
    lastRun.dwMaxLicenseId = g_NextLicenseId;

    StoreKey(
            LSERVER_LSA_LASTRUN, 
            (PBYTE)&lastRun, 
            sizeof(TLServerLastRun)
        );

    LSShutdownCertutilLib();

    if( g_SelfSignCertContext != NULL )
    {
        CertFreeCertificateContext(g_SelfSignCertContext);
    }

    if(g_LicenseCertContext)
    {
        CertFreeCertificateContext(g_LicenseCertContext);
    }

    TLSDestroyCryptContext(g_hCryptProv);
    g_hCryptProv=NULL;

    //
    // shutdown Work manager
    //  
    TLSWorkManagerShutdown();
    

#ifndef _NO_ODBC_JET
    if(g_DbWorkSpace != NULL)
    {
        ReleaseWorkSpace(&g_DbWorkSpace);
    }
#endif

    CloseWorkSpacePool();

    FreeMemory(g_pbSecretKey);
    FreeMemory(g_pbSignatureEncodedCert);
    FreeMemory(g_pbExchangeEncodedCert);
    //FreeMemory(g_pbDomainSid);
    FreeMemory(g_pCertExtensions);

    FreeMemory(g_pszServerUniqueId);
    FreeMemory(g_pszServerPid);
    FreeMemory(g_pbServerSPK);

    if(g_szDomainGuid != NULL)
    {
        RpcStringFree(&g_szDomainGuid);
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////

DWORD 
StartServerInitThread( 
    void* p 
    )
/*
*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bDebug = (p) ? TRUE : FALSE;
    HKEY hKey = NULL;
    PTLSLSASERVERID pTlsLsaServerIds=NULL;
    DWORD cbTlsLsaServerIds=0;
    EXCEPTION_RECORD ExceptionCode;


    _set_se_translator( trans_se_func );

    __try {

        do {

            TLSInit();

            //
            // Load various run time parameters
            //
            dwStatus = TLSLoadRuntimeParameters();

            if(dwStatus != ERROR_SUCCESS)
            {
                break;
            }       

            //
            // Retrive License Server's IDs
            //
            dwStatus = RetrieveKey(
                                LSERVER_LSA_LSERVERID, 
                                (PBYTE *)&pTlsLsaServerIds,
                                &cbTlsLsaServerIds
                            );

            if(dwStatus != ERROR_SUCCESS)
            {
                //
                // First time, generate various license server ID
                //
                dwStatus = TLSGeneratePid(
                                    &g_pszServerPid,
                                    &g_cbServerPid,
                                    &g_pszServerUniqueId,
                                    &g_cbServerUniqueId
                                );

                if(dwStatus != ERROR_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_SERVICEINIT,
                            TLS_E_GENERATE_IDS
                        );

                    break;
                }

                //
                // Store this into LSA
                //
                dwStatus = ServerIdsToLsaServerId(
                                            (PBYTE)g_pszServerUniqueId,
                                            g_cbServerUniqueId,
                                            (PBYTE)g_pszServerPid,
                                            g_cbServerPid,
                                            g_pbServerSPK,
                                            g_cbServerSPK,
                                            NULL,
                                            0,
                                            &pTlsLsaServerIds,
                                            &cbTlsLsaServerIds
                                        );
                if(dwStatus != ERROR_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_SERVICEINIT,
                            dwStatus = TLS_E_STORE_IDS
                        );

                    break;
                }

                dwStatus = StoreKey(
                                LSERVER_LSA_LSERVERID,
                                (PBYTE)pTlsLsaServerIds,
                                cbTlsLsaServerIds
                            );

                if(dwStatus != ERROR_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_SERVICEINIT,
                            dwStatus = TLS_E_STORE_IDS
                        );

                    break;
                }
            }
            else
            {
                dwStatus = LsaServerIdToServerIds(
                                            pTlsLsaServerIds,
                                            cbTlsLsaServerIds,
                                            (PBYTE *)&g_pszServerUniqueId,
                                            &g_cbServerUniqueId,
                                            (PBYTE *)&g_pszServerPid,
                                            &g_cbServerPid,
                                            &g_pbServerSPK,
                                            &g_cbServerSPK,
                                            &g_pCertExtensions,
                                            &g_cbCertExtensions
                                        );

                if(dwStatus != ERROR_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_SERVICEINIT,
                            dwStatus = TLS_E_RETRIEVE_IDS
                        );

                    break;
                }

                if( g_pszServerUniqueId == NULL || 
                    g_cbServerUniqueId == 0 ||
                    g_pszServerPid == NULL ||
                    g_cbServerPid == 0 )
                {
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_SERVICEINIT,
                            dwStatus = TLS_E_INTERNAL
                        );

                    break;
                }
            }

            //
            // License Server common secret key for encoding/decoding
            // client HWID
            //
            LicenseGetSecretKey(&g_cbSecretKey, NULL);
            if((g_pbSecretKey = (PBYTE)AllocateMemory(g_cbSecretKey)) == NULL)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        dwStatus = TLS_E_ALLOCATE_MEMORY
                    );

                break;
            }
        
            if(LicenseGetSecretKey( &g_cbSecretKey, g_pbSecretKey ) != LICENSE_STATUS_OK)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVICEINIT,
                        dwStatus = TLS_E_RETRIEVE_KEY
                    );

                break;
            }


            //--------------------------------------------------------------
            //
            // Check if our database file is in import directory
            //
            //--------------------------------------------------------------
            dwStatus = TLSStartLSDbWorkspaceEngine(
                                            bDebug == FALSE, 
                                            FALSE,              // check DB file on export directory
                                            FALSE,              // check file time on DB file
                                            TRUE                // log low license count warning.
                                        );
            if(dwStatus != ERROR_SUCCESS)
            {
                break;
            }

            dwStatus = ERROR_SUCCESS;
            g_ValidDatabase = TRUE;

            //
            // load all policy module, ignore error
            //
            ServiceLoadAllPolicyModule(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_POLICY_REGBASE
                        ); 

            //
            // Upgrade - make two copies of certificate
            //
            dwStatus = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                LSERVER_SERVER_CERTIFICATE_REGKEY,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey
                            );

            if(hKey != NULL)
            {
                RegCloseKey(hKey);
            }

            if(dwStatus != ERROR_SUCCESS)
            {
                dwStatus = ERROR_SUCCESS;

                // we are not register yet...
                break;
            }


            //
            // Verify first backup copy of certificate exists
            //
            hKey = NULL;
            dwStatus = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey
                            );
            if(hKey != NULL)
            {
                RegCloseKey(hKey);
            }

            if(dwStatus == ERROR_FILE_NOT_FOUND)
            {
                dwStatus = TLSRestoreLicenseServerCertificate(
                                                LSERVER_SERVER_CERTIFICATE_REGKEY,
                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                            );

                if(dwStatus != ERROR_SUCCESS)
                {
                    TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                    TLSRegDeleteKey(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                        );
                }
            }

            //
            // Verify second backup copy of certificate exists
            //
            hKey = NULL;
            dwStatus = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey
                            );
            if(hKey != NULL)
            {
                RegCloseKey(hKey);
            }

            if(dwStatus == ERROR_FILE_NOT_FOUND)
            {
                dwStatus = TLSRestoreLicenseServerCertificate(
                                                LSERVER_SERVER_CERTIFICATE_REGKEY,
                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                            );

                if(dwStatus != ERROR_SUCCESS)
                {
                    TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                    TLSRegDeleteKey(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                        );
                }
            }

            dwStatus = ERROR_SUCCESS;
        } while(FALSE);
    }
    __except(
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = ExceptionCode.ExceptionCode;
        if(dwStatus == ERROR_OUTOFMEMORY)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_SERVICEINIT,
                    dwStatus
                );
        }

    }

    if(pTlsLsaServerIds != NULL)
    {
        LocalFree(pTlsLsaServerIds);
    }

    ExitThread(dwStatus); 

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

HANDLE 
ServerInit(
    BOOL bDebug
    )
{
    HANDLE hThread;
    DWORD  dump;

    hThread=(HANDLE)CreateThread(
                            NULL, 
                            0, 
                            StartServerInitThread, 
                            LongToPtr(bDebug), 
                            0, 
                            &dump
                        );
    return hThread;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSRestoreLicenseServerCertificate(
    LPCTSTR pszSourceRegKey,
    LPCTSTR pszTargetRegKey
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    // first delete the certificate key, ignore error 
    TLSRegDeleteKey(
                HKEY_LOCAL_MACHINE,
                pszTargetRegKey
            );

    // copy from backup
    dwStatus = TLSTreeCopyRegKey(
                            HKEY_LOCAL_MACHINE,
                            pszSourceRegKey,
                            HKEY_LOCAL_MACHINE,
                            pszTargetRegKey
                        );

    if(dwStatus == ERROR_FILE_NOT_FOUND)
    {
        // source registry key does not exist
        dwStatus = TLS_E_NO_CERTIFICATE;
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////////////////

DWORD
TLSLoadVerifyLicenseServerCertificates()
/*++

--*/
{
    DWORD dwStatus;

#if ENFORCE_LICENSING

    // load certificate from normal place
    dwStatus = TLSLoadCHEndosedCertificate(
                                &g_cbSignatureEncodedCert, 
                                &g_pbSignatureEncodedCert,
                                &g_cbExchangeEncodedCert,
                                &g_pbExchangeEncodedCert
                            );
    
    if(dwStatus == ERROR_SUCCESS)
    {
        if(g_hCaStore != NULL)
        {
            CertCloseStore(
                    g_hCaStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
        }

        if(g_hCaRegKey != NULL)
        {
            RegCloseKey(g_hCaRegKey);
        }

        //
        // license server is registered, verify certificate
        //
        g_hCaStore = CertOpenRegistryStore(
                                HKEY_LOCAL_MACHINE, 
                                LSERVER_CERTIFICATE_REG_CA_SIGNATURE, 
                                g_hCryptProv, 
                                &g_hCaRegKey
                            );
        if(g_hCaStore != NULL)
        {
            //
            // Go thru license server's certficiate to validate 
            //
            dwStatus = TLSValidateServerCertficates(
                                            g_hCryptProv,
                                            g_hCaStore,
                                            g_pbSignatureEncodedCert,
                                            g_cbSignatureEncodedCert,
                                            g_pbExchangeEncodedCert,
                                            g_cbExchangeEncodedCert,
                                            &g_ftCertExpiredTime
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                //
                // Invalid certificate in registry
                //
                dwStatus = TLS_E_INVALID_CERTIFICATE;
            }
        }
        else
        {
            //
            // Can't open registry key, startup as non-register
            // server.
            //
            //TLSLogEvent(
            //            EVENTLOG_ERROR_TYPE, 
            //            TLS_E_SERVICEINIT,
            //            TLS_E_OPEN_CERTSTORE, 
            //            dwStatus = GetLastError()
            //        );  

            dwStatus = TLS_E_NO_CERTIFICATE;
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        if(g_LicenseCertContext != NULL)
        {
            CertFreeCertificateContext(g_LicenseCertContext);
        }

        g_LicenseCertContext = CertCreateCertificateContext(
                                            X509_ASN_ENCODING,
                                            g_pbSignatureEncodedCert,
                                            g_cbSignatureEncodedCert
                                        );

        //if(!g_LicenseCertContext)
        //{
        //    TLSLogEvent(
        //                EVENTLOG_ERROR_TYPE, 
        //                TLS_E_SERVICEINIT,
        //                TLS_E_CREATE_CERTCONTEXT, 
        //                GetLastError()
        //            );  
        //}
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        g_bHasHydraCert = FALSE;
    }
    else
    {
        g_bHasHydraCert = TRUE;
    }                
   
#else

    dwStatus = TLS_E_NO_CERTIFICATE;

#endif

    return dwStatus;
}
    
///////////////////////////////////////////////////////////////////////

BOOL 
TLSLoadServerCertificate()
/*++

Abstract:

    Load license server certificate     

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwStatus;
    PBYTE pbSelfSignedCert = NULL;
    DWORD cbSelfSignedCert = 0;
    BOOL bSelfSignedCreated = FALSE;
    
    g_ftCertExpiredTime.dwLowDateTime = 0xFFFFFFFF;
    g_ftCertExpiredTime.dwHighDateTime = 0xFFFFFFFF;

#if ENFORCE_LICENSING

    dwStatus = TLSLoadVerifyLicenseServerCertificates();
    
    //
    // failed to load server certificate, try backup copy,
    // if either one success, make sure we have all three copy up
    // to date.
    //
    if(dwStatus == TLS_E_INVALID_CERTIFICATE || dwStatus == TLS_E_NO_CERTIFICATE)
    {
        dwStatus = TLSRestoreLicenseServerCertificate(
                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1,
                                                LSERVER_SERVER_CERTIFICATE_REGKEY
                                            );
        
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSLoadVerifyLicenseServerCertificates();
            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // Log event indicate we are using backup certificate
                //
                LPCTSTR pString[1];
                pString[0]= g_szComputerName;

                TLSLogEventString(
                        EVENTLOG_WARNING_TYPE,
                        TLS_W_CORRUPTTRYBACKUPCERTIFICATE,
                        1,
                        pString
                    );

                //
                // make sure second copy is same as first copy.
                //
                TLSRestoreLicenseServerCertificate(
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1,
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                        );
            }
        }
    }

    if(dwStatus == TLS_E_INVALID_CERTIFICATE || dwStatus == TLS_E_NO_CERTIFICATE)
    {
        dwStatus = TLSRestoreLicenseServerCertificate(
                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2,
                                                LSERVER_SERVER_CERTIFICATE_REGKEY
                                            );
        
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSLoadVerifyLicenseServerCertificates();
            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // Log event indicate we are using backup certificate
                //
                LPCTSTR pString[1];
                pString[0]= g_szComputerName;

                TLSLogEventString(
                        EVENTLOG_WARNING_TYPE,
                        TLS_W_CORRUPTTRYBACKUPCERTIFICATE,
                        1,
                        pString
                    );

                //
                // make sure our first copy is up to date
                //
                TLSRestoreLicenseServerCertificate(
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2,
                                            LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                        );
            }
        }
    }

    //
    // Everything failed, log an event state that license server 
    // will startup in un-registered mode
    //
    if(dwStatus == TLS_E_INVALID_CERTIFICATE)
    {
        LPCTSTR pString[1];

        pString[0] = g_szComputerName;

        TLSLogEventString(
                EVENTLOG_WARNING_TYPE,
                TLS_W_STARTUPCORRUPTEDCERT,
                1,
                pString
            );
    }
    else if(CanIssuePermLicense() == FALSE)
    {
        // we are not registered yet
        LPCTSTR pString[1];
        pString[0] = g_szComputerName;

        TLSLogEventString(
                    EVENTLOG_WARNING_TYPE, 
                    TLS_W_STARTUPNOCERT, 
                    1,
                    pString
                );
    }

    if( dwStatus != ERROR_SUCCESS )
    {
        //
        // if all failed, re-generate and start up as un-register 
        // license server
        //
        bSuccess = FALSE;

        //
        // wipe out all certificates and re-generate everything,
        // don't re-generate key if we are not registered yet.
        //
        if(g_pbServerSPK == NULL || g_cbServerSPK == 0)
        {
            TLSReGenerateKeys(FALSE);
        }
    }
    else
    {
        bSuccess = TRUE;
    }

#endif

	if(bSuccess == FALSE)
	{
        bSuccess = (TLSLoadSelfSignCertificates(
                                g_hCryptProv,
#if ENFORCE_LICENSING
                                g_pbServerSPK,
                                g_cbServerSPK,
#else
                                NULL,
                                0,
#endif
                                &g_cbSignatureEncodedCert, 
                                &g_pbSignatureEncodedCert,
                                &g_cbExchangeEncodedCert,
                                &g_pbExchangeEncodedCert
                            ) == ERROR_SUCCESS);

        #ifndef ENFORCE_LICENSING
        //
        // non enforce license version
        g_bHasHydraCert = TRUE;
        #endif        

        if(bSuccess == TRUE)
        {
            if(g_LicenseCertContext != NULL)
            {
                CertFreeCertificateContext(g_LicenseCertContext);
            }

            g_LicenseCertContext = CertCreateCertificateContext(
                                                X509_ASN_ENCODING,
                                                g_pbSignatureEncodedCert,
                                                g_cbSignatureEncodedCert
                                            );

            if(!g_LicenseCertContext)
            {
                bSuccess = FALSE;

                //
                // For self-signed cert, this is critical error, for 
                // cert. in registry store, it must have been thru validation
                // so still critical error.
                //
                TLSLogEvent(
                            EVENTLOG_ERROR_TYPE, 
                            TLS_E_SERVICEINIT,
                            TLS_E_CREATE_CERTCONTEXT, 
                            GetLastError()
                        );  
            }
            else
            {
                // we have created a self-signed certificate.
                bSelfSignedCreated = TRUE;
            }
        }
    }


    //
    // Create a self-signed certificate for old client, 
    //
    if( bSuccess == TRUE )
    {
        if( g_SelfSignCertContext != NULL )
        {
            CertFreeCertificateContext( g_SelfSignCertContext );
            g_SelfSignCertContext = NULL;
        }

        if( bSelfSignedCreated == FALSE )
        { 
            //
            // Create a self-signed certificate just for old client
            //
            dwStatus = TLSCreateSelfSignCertificate(
                                            g_hCryptProv,
                                            AT_SIGNATURE,
                                        #if ENFORCE_LICENSING
                                            g_pbServerSPK,
                                            g_cbServerSPK,
                                        #else
                                            NULL,
                                            0,
                                        #endif
                                            0,          
                                            NULL,
                                            &cbSelfSignedCert,
                                            &pbSelfSignedCert
                                        );

            if( dwStatus == ERROR_SUCCESS )
            {
                g_SelfSignCertContext = CertCreateCertificateContext(
                                                        X509_ASN_ENCODING,
                                                        pbSelfSignedCert,
                                                        cbSelfSignedCert
                                                    );
    
                if( g_SelfSignCertContext == NULL )
                {
                    bSuccess = FALSE;
                    TLSLogEvent(
                                EVENTLOG_ERROR_TYPE, 
                                TLS_E_SERVICEINIT,
                                TLS_E_CREATE_CERTCONTEXT, 
                                GetLastError()
                            );  
                }
            }
        }
        else
        {
            // we already have self-signed certificate created.
            g_SelfSignCertContext = CertDuplicateCertificateContext( g_LicenseCertContext );
            if( g_SelfSignCertContext == NULL )
            {
                TLSASSERT(FALSE);
                //
                // impossible, CertDuplicateCertificateContext() simply increase 
                // reference count
                //
                bSuccess = FALSE;
                TLSLogEvent(
                            EVENTLOG_ERROR_TYPE, 
                            TLS_E_SERVICEINIT,
                            TLS_E_CREATE_CERTCONTEXT, 
                            GetLastError()
                        );  
            }
        }
    }

    FreeMemory(pbSelfSignedCert);
    return bSuccess;
}

//---------------------------------------------------------------------

DWORD
ServiceInitCrypto(
    IN BOOL bCreateNewKeys,
    IN LPCTSTR pszKeyContainer,
    OUT HCRYPTPROV* phCryptProv,
    OUT HCRYPTKEY* phSignKey,
    OUT HCRYPTKEY* phExchKey
    )
/*

*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    PBYTE pbSignKey=NULL;
    DWORD cbSignKey=0;
    PBYTE pbExchKey=NULL;
    DWORD cbExchKey=0;

    if(bCreateNewKeys == FALSE)
    {
        //
        // Load key from LSA
        //
        dwStatus = TLSLoadSavedCryptKeyFromLsa(
                                        &pbSignKey,
                                        &cbSignKey,
                                        &pbExchKey,
                                        &cbExchKey
                                    );
    } 

    if(bCreateNewKeys == TRUE || dwStatus == ERROR_FILE_NOT_FOUND)
    {
        dwStatus = TLSCryptGenerateNewKeys(
                                    &pbSignKey,
                                    &cbSignKey,
                                    &pbExchKey,
                                    &cbExchKey
                                );

        if(dwStatus == ERROR_SUCCESS)
        {
            // Save Key to LSA
            dwStatus = TLSSaveCryptKeyToLsa(
                                        pbSignKey,
                                        cbSignKey,
                                        pbExchKey,
                                        cbExchKey
                                    );
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // Initialize a clean crypto.
        //
        dwStatus = TLSInitCryptoProv(
                            pszKeyContainer,
                            pbSignKey,
                            cbSignKey,
                            pbExchKey,
                            cbExchKey,
                            phCryptProv,
                            phSignKey,
                            phExchKey
                        );
    }


    if(pbSignKey)
    {
        LocalFree(pbSignKey);
    }

    if(pbExchKey)
    {
        LocalFree(pbExchKey);
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

DWORD 
InitCryptoAndCertificate()
{
    DWORD status=ERROR_SUCCESS;
    DWORD dwServiceState;
    DWORD dwCryptoState;

    //
    // Initialize single global Cryptographic Provider
    //
    status = ServiceInitCrypto(
                            FALSE,
                            NULL,
                            &g_hCryptProv,
                            &g_SignKey,
                            &g_ExchKey
                        );
    if(status != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_SERVICEINIT,
                TLS_E_INIT_CRYPTO, 
                status
            );

        status = TLS_E_SERVICE_STARTUP;
        goto cleanup;
    }

    LSInitCertutilLib( NULL );

    if(!TLSLoadServerCertificate())
    {
        status = TLS_E_SERVICE_STARTUP;
        TLSLogErrorEvent(TLS_E_LOAD_CERTIFICATE);
        goto cleanup;
    }

    // 
    if(!g_pbExchangeEncodedCert || !g_pbSignatureEncodedCert)
    {
        TLSLogErrorEvent(status = TLS_E_INTERNAL);
    }

cleanup:

    return status;
}

//////////////////////////////////////////////////////////////////

DWORD
TLSReGenKeysAndReloadServerCert(
    BOOL bReGenKey
    )
/*++

--*/
{
    DWORD dwStatus;

    dwStatus = TLSReGenerateKeys(bReGenKey);
    
    //
    // always try reload certificate since TLSReGenerateKeys() 
    // will wipe out our keys.
    // 
    if(TLSLoadServerCertificate() == TRUE)
    {
        if(!g_pbExchangeEncodedCert || !g_pbSignatureEncodedCert)
        {
            TLSLogErrorEvent(dwStatus = TLS_E_INTERNAL);
        }
    }
    else
    {
        TLSLogErrorEvent(dwStatus = TLS_E_LOAD_CERTIFICATE);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////////

DWORD
TLSReGenerateKeys(
    BOOL bReGenKey
    )

/*++

    Always restore state back to clean install, bReGenKeyOnly 
    not supported.

--*/
{
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY hSignKey = NULL;
    HCRYPTKEY hExchKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    PTLSLSASERVERID pTlsLsaServerIds=NULL;
    DWORD cbTlsLsaServerIds=0;

    //
    // Create a new clean crypto. 
    //
    dwStatus = ServiceInitCrypto(
                            bReGenKey,
                            NULL,
                            &hCryptProv,
                            &hSignKey,
                            &hExchKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    //
    // Cleanup our certificate registry.
    //
    TLSUninstallLsCertificate();

    //
    // Cleanup in-memory certificates, keys...
    //
    if(g_SignKey)
    {
        CryptDestroyKey(g_SignKey);
        g_SignKey = NULL;
    }

    if(g_ExchKey)
    {
        CryptDestroyKey(g_ExchKey);
        g_ExchKey = NULL;
    }

    if( g_SelfSignCertContext != NULL )
    {
        CertFreeCertificateContext( g_SelfSignCertContext );
        g_SelfSignCertContext = NULL;
    }

    if( g_LicenseCertContext != NULL )
    {
        CertFreeCertificateContext(g_LicenseCertContext);
        g_LicenseCertContext = NULL;
    }

    if(g_hCryptProv != NULL)
    {
        TLSDestroyCryptContext(g_hCryptProv);
    }

    g_hCryptProv=NULL;

    FreeMemory(g_pbSignatureEncodedCert);
    g_pbSignatureEncodedCert = NULL;
    g_cbSignatureEncodedCert = 0;

    FreeMemory(g_pbExchangeEncodedCert);
    g_pbExchangeEncodedCert = NULL;
    g_cbExchangeEncodedCert = 0;

    //
    // Always back to clean state.
    //
    FreeMemory(g_pCertExtensions);
    g_pCertExtensions = NULL;
    g_cbCertExtensions = 0;

    FreeMemory(g_pbServerSPK);
    g_pbServerSPK = NULL;
    g_cbServerSPK = 0;

    //
    // Store this into LSA
    //
    dwStatus = ServerIdsToLsaServerId(
                                (PBYTE)g_pszServerUniqueId,
                                g_cbServerUniqueId,
                                (PBYTE)g_pszServerPid,
                                g_cbServerPid,
                                NULL,
                                0,
                                NULL,
                                0,
                                &pTlsLsaServerIds,
                                &cbTlsLsaServerIds
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        assert(FALSE);
        goto cleanup;
    }

    dwStatus = StoreKey(
                    LSERVER_LSA_LSERVERID,
                    (PBYTE)pTlsLsaServerIds,
                    cbTlsLsaServerIds
                );

    if(dwStatus != ERROR_SUCCESS)
    {
        assert(FALSE);
        goto cleanup;
    }

    //
    // Re-generate in-memory certificates...
    //
    g_hCryptProv = hCryptProv;
    g_SignKey = hSignKey;
    g_ExchKey = hExchKey;

cleanup:

    FreeMemory(pTlsLsaServerIds);
    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
TLSReGenSelfSignCert(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE pbSPK,
    IN DWORD cbSPK,
    IN DWORD dwNumExtensions,
    IN PCERT_EXTENSION pCertExtensions
    )
/*++


--*/
{
    DWORD dwStatus;
    PTLSLSASERVERID pbLsaServerId = NULL;
    DWORD cbLsaServerId = 0;

    PBYTE pbSignCert = NULL;    
    DWORD cbSignCert = 0;
    PBYTE pbExchCert = NULL;
    DWORD cbExchCert = 0;
    DWORD dwVerifyResult;
    PCCERT_CONTEXT hLicenseCertContext = NULL;
    LPTSTR pszSPK = NULL;

    if(hCryptProv == NULL || pbSPK == NULL || cbSPK == 0)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    //
    // Verify SPK, current SPK is base 24 encoded string
    //
    pszSPK = (LPTSTR)AllocateMemory(cbSPK + sizeof(TCHAR));
    if(pszSPK == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }
     
    memcpy(
            pszSPK,
            pbSPK,
            cbSPK
        );

    //
    // Verify SPK
    //
    dwVerifyResult = LKPLITE_SPK_VALID;
    dwStatus = LKPLiteVerifySPK(
                            g_pszServerPid,
                            pszSPK,
                            &dwVerifyResult
                        );

    if(dwStatus != ERROR_SUCCESS || dwVerifyResult != LKPLITE_SPK_VALID)
    {
        if(dwVerifyResult == LKPLITE_SPK_INVALID)
        {
            dwStatus = TLS_E_INVALID_SPK;
        }
        else if(dwVerifyResult == LKPLITE_SPK_INVALID_SIGN)
        {
            dwStatus = TLS_E_SPK_INVALID_SIGN;
        }

        goto cleanup;
    }

    //
    // Write SPK to LSA
    //
    dwStatus = ServerIdsToLsaServerId(
                            (PBYTE)g_pszServerUniqueId,
                            g_cbServerUniqueId,
                            (PBYTE)g_pszServerPid,
                            g_cbServerPid,
                            pbSPK,
                            cbSPK,
                            pCertExtensions,
                            dwNumExtensions,
                            &pbLsaServerId,
                            &cbLsaServerId
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Save data to LSA
    //
    dwStatus = StoreKey(
                        LSERVER_LSA_LSERVERID,
                        (PBYTE) pbLsaServerId,
                        cbLsaServerId
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Re-generate our certificatge
    //
    dwStatus = TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_SIGNATURE, 
                                pbSPK,
                                cbSPK,
                                dwNumExtensions,
                                pCertExtensions,
                                &cbSignCert, 
                                &pbSignCert
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    hLicenseCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbSignCert,
                                        cbSignCert
                                    );

    if( hLicenseCertContext == NULL )
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    dwStatus = TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_KEYEXCHANGE, 
                                pbSPK,
                                cbSPK,
                                dwNumExtensions,
                                pCertExtensions,
                                &cbExchCert, 
                                &pbExchCert
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Certificate generated is Perm. self-signed certificate,
    // don't store in registry.
    //

    //
    // Make a copy of SPK
    //
    g_pbServerSPK = (PBYTE)AllocateMemory(cbSPK);
    if(g_pbServerSPK == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    memcpy(
            g_pbServerSPK,
            pbSPK,
            cbSPK
        );

    g_cbServerSPK = cbSPK;


    if( g_SelfSignCertContext != NULL )
    {
        CertFreeCertificateContext(g_SelfSignCertContext);
    }

    g_SelfSignCertContext = CertDuplicateCertificateContext(hLicenseCertContext);
    if( g_SelfSignCertContext == NULL )
    {
        TLSASSERT( g_SelfSignCertContext != NULL ); 
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Everything is OK, switch to new certificate
    //
    FreeMemory(g_pbSignatureEncodedCert);
    g_pbSignatureEncodedCert = pbSignCert;
    g_cbSignatureEncodedCert = cbSignCert;

    if(g_LicenseCertContext != NULL)
    {
        CertFreeCertificateContext(g_LicenseCertContext);
    }

    //
    // use duplicate instead of direct assign
    //
    g_LicenseCertContext = CertDuplicateCertificateContext(hLicenseCertContext);
    TLSASSERT(g_LicenseCertContext != NULL);                                                   

    FreeMemory(g_pbExchangeEncodedCert);
    g_pbExchangeEncodedCert = pbExchCert;
    g_cbExchangeEncodedCert = cbExchCert;

    pbSignCert = NULL;
    pbExchCert = NULL;

    //
    // Mark we have Perm. self-signed cert.
    //
    g_bHasHydraCert = FALSE;

cleanup:

    if( hLicenseCertContext != NULL )
    {
        CertFreeCertificateContext( hLicenseCertContext );
    }

    FreeMemory(pszSPK);
    FreeMemory(pbLsaServerId);
    FreeMemory(pbSignCert);
    FreeMemory(pbExchCert);

    return dwStatus;
}

//------------------------------------------------
void
CleanSetupLicenseServer()
/*++

--*/
{
    DWORD dwStatus;
    
    //
    // Wipe out SPK in LSA
    //
    dwStatus = StoreKey(
                    LSERVER_LSA_LSERVERID,
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_LASTRUN, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                    (PBYTE) NULL,
                    0
                );


    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus = TLSUninstallLsCertificate();

    return;
}




//-----------------------------------------------
//
//
DWORD
TLSStartupLSDB(
    IN BOOL bCheckDBStatus,
    IN DWORD dwMaxDbHandles,
    IN BOOL bStartEmptyIfError,
    IN BOOL bLogWarning,
    IN LPTSTR pszChkPointDirPath,
    IN LPTSTR pszTempDirPath,
    IN LPTSTR pszLogDirPath,
    IN LPTSTR pszDbFile,
    IN LPTSTR pszUserName,
    IN LPTSTR pszPassword
    )
/*++

Abstract:

    Initialize License Server's DB workspace handle list.


Parameters:

    pszChkPointDirPath : ESE check point directory.
    pszTempDirPath : ESE temp. directory.
    pszLogDirPath : ESE log file directory.
    pszDbPath : License Server database file path.
    pszDbFile : License Server database file name (no path).
    pszUserName : Database file user name.
    pszPassword : Database file password.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD status = ERROR_SUCCESS;
    BOOL bEmptyDatabase = FALSE;
    BOOL bRemoveAvailableLicense = FALSE;
      
    if( __TlsDbWorkSpace::g_JbInstance.IsValid() == FALSE )
    { 
        //
        // Initialize Jet Instance
        //
        bSuccess = TLSJbInstanceInit(
                                __TlsDbWorkSpace::g_JbInstance,
                                pszChkPointDirPath, 
                                pszTempDirPath,
                                pszLogDirPath
                            );
        if(bSuccess == FALSE)
        {
            status = GetLastError();
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }

    //
    // Upgrade the database
    //
    status = TLSUpgradeDatabase(
                            __TlsDbWorkSpace::g_JbInstance,
                            pszDbFile, 
                            pszUserName, 
                            pszPassword
                        );

    
    if( status == TLS_E_BETADATABSE ||
        status == TLS_E_INCOMPATIBLEDATABSE ||
        (TLS_ERROR(status) == TRUE && bStartEmptyIfError == TRUE) )
    {
        if(status == TLS_E_BETADATABSE)
        {
            CleanSetupLicenseServer();
        }

        //
        // bad database, try to save a copy of it and 
        // restart from scratch
        //
        TLSLogInfoEvent(status);

        TCHAR szTmpFileName[2*MAX_PATH+1];

        bSuccess = TLSGenerateLSDBBackupFileName(
                                    pszTempDirPath,
                                    szTmpFileName
                                    );

        if (bSuccess)
        {
            bSuccess = MoveFileEx(
                                  pszDbFile, 
                                  szTmpFileName, 
                                  MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED
                                  );
        }

        if(bSuccess == TRUE)
        {
            LPCTSTR pString[1];

            pString[0] = szTmpFileName;
            TLSLogEventString(
                    EVENTLOG_INFORMATION_TYPE,
                    TLS_I_RENAME_DBFILE,
                    sizeof(pString)/sizeof(pString[0]),
                    pString
                );

            status = TLSUpgradeDatabase(
                                    __TlsDbWorkSpace::g_JbInstance,
                                    pszDbFile, 
                                    pszUserName, 
                                    pszPassword
                                );
        }
        else
        {
            //
            // Can't rename this file, log an error and exit.
            //
            LPCTSTR pString[1];

            pString[0] = pszDbFile;
            TLSLogEventString(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_RENAME_DBFILE,
                    sizeof(pString)/sizeof(pString[0]),
                    pString
                );

            status = TLS_E_RENAME_DBFILE;
        }                                    
    }

    if(TLS_ERROR(status) == TRUE)
    {
        goto cleanup;
    }

    if(status == TLS_I_CREATE_EMPTYDATABASE)
    {
        // we startup from scratch, ignore ID checking
        bEmptyDatabase = TRUE;
    }
    else if(status == TLS_W_NOTOWNER_DATABASE)
    {
        #if ENFORCE_LICENSING
        // not owner of database or database version mismatch, we need to kill all the 
        // available licenses
        bRemoveAvailableLicense = TRUE;
        #endif
    }

    status = ERROR_SUCCESS;

    //
    // Allocate one handle to verify database
    //
    bSuccess = InitializeWorkSpacePool(
                                    1, 
                                    pszDbFile, 
                                    pszUserName, 
                                    pszPassword, 
                                    pszChkPointDirPath, 
                                    pszTempDirPath,
                                    pszLogDirPath,
                                    TRUE
                                );
    if(bSuccess == FALSE)
    {
        status = GetLastError();
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if((g_DbWorkSpace = AllocateWorkSpace(g_GeneralDbTimeout)) == NULL)
    {

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                status = TLS_E_ALLOCATE_HANDLE
            );

        goto cleanup;
    }

    //
    // Initialize next keypack id and license id
    //
    if(TLSDBGetMaxKeyPackId(g_DbWorkSpace, (DWORD *)&g_NextKeyPackId) == FALSE)
    {
        status=GetLastError();

        if(IS_JB_ERROR(status))
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(
                        GET_JB_ERROR_CODE(status), 
                        &pString
                    );

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_JB_BASE,
                    GET_JB_ERROR_CODE(status),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
        }
        else
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    status
                );
        }

        goto cleanup;
    }

    if(!TLSDBGetMaxLicenseId(g_DbWorkSpace, (DWORD *)&g_NextLicenseId))
    {
        status=GetLastError();

        if(IS_JB_ERROR(status))
        {
            LPTSTR pString = NULL;
            
            TLSGetESEError(
                        GET_JB_ERROR_CODE(status), 
                        &pString
                    );

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_JB_BASE,
                    GET_JB_ERROR_CODE(status),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
        }
        else
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    status
                );
        }

        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("Next KeyPack ID - %d, Next License ID - %d\n"),
            g_NextKeyPackId,
            g_NextLicenseId
        );

    //
    // Verify database status with last run status
    //
    {
        LPTLServerLastRun lpLastRun = NULL;
        DWORD   cbByte=0;
        PBYTE   pbByte=NULL;

        status = RetrieveKey(
                        LSERVER_LSA_LASTRUN, 
                        &pbByte, 
                        &cbByte
                    );

        lpLastRun = (LPTLServerLastRun)pbByte;

        if( status == ERROR_SUCCESS && lpLastRun != NULL )
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Last run status : Next KeyPack ID - %d, Next License ID - %d\n"),
                    lpLastRun->dwMaxKeyPackId,
                    lpLastRun->dwMaxLicenseId
                );

            //
            // Verify no 'copy' database
            //
            if( bCheckDBStatus == TRUE && 
                bEmptyDatabase == FALSE &&
                bRemoveAvailableLicense == FALSE &&
                lpLastRun->dwMaxKeyPackId != 0 &&
                lpLastRun->dwMaxLicenseId != 0 )
            {
                // enforce version will remove all available licenses
                #if ENFORCE_LICENSING 

                if( lpLastRun->dwMaxKeyPackId != g_NextKeyPackId || 
                    lpLastRun->dwMaxLicenseId != g_NextLicenseId)
                {
                    TLSLogWarningEvent(TLS_W_INCONSISTENT_STATUS);
                    bRemoveAvailableLicense = TRUE;
                }

                #endif                            
            }
            else
            {
                g_ftLastShutdownTime = lpLastRun->ftLastShutdownTime;
            }
        }

        if(pbByte)
        {
            LocalFree(pbByte);
        }

        //
        // overwrite last run status to 0 so if we crash, 
        // check won't get kick it
        //
        TLServerLastRun LastRun;

        memset(&LastRun, 0, sizeof(LastRun));
        LastRun.ftLastShutdownTime = g_ftLastShutdownTime;
        StoreKey(
                LSERVER_LSA_LASTRUN, 
                (PBYTE)&LastRun, 
                sizeof(TLServerLastRun)
            );
    }

    g_NextKeyPackId++;
    g_NextLicenseId++;

    // 
    // remove available licenses
    if(bRemoveAvailableLicense == TRUE)
    {
        status = TLSRemoveLicensesFromInvalidDatabase(
                                        g_DbWorkSpace
                                    );

        if(status != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
        
    // 
    // Insert a keypack for Terminal Service Certificate.
    //
    status = TLSAddTermServCertificatePack(g_DbWorkSpace, bLogWarning);
    if(status != ERROR_SUCCESS && status != TLS_E_DUPLICATE_RECORD)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                status = TLS_E_UPGRADE_DATABASE
            );

        goto cleanup;
    }


    //
    // Allocate rest of the workspace handle
    //
    bSuccess = InitializeWorkSpacePool(
                                    dwMaxDbHandles, 
                                    pszDbFile, 
                                    pszUserName, 
                                    pszPassword, 
                                    NULL,
                                    NULL,
                                    NULL,
                                    FALSE
                                );

    //
    if(bSuccess == FALSE && GetNumberOfWorkSpaceHandle() < DB_MIN_HANDLE_NEEDED)
    {
        status = GetLastError();
    }

cleanup:

    return status;
}

///////////////////////////////////////////////////////////////
DWORD
TLSStartLSDbWorkspaceEngine(
    BOOL bChkDbStatus,
    BOOL bIgnoreRestoreFile,
    BOOL bIgnoreFileTimeChk,
    BOOL bLogWarning
    )
/*++

bChkDbStatus : Match next LKP ID and License ID with LSA
bIgnoreRestoreFile : FALSE if try to open DB file under EXPORT, TRUE otherwise
bLogWarning : TRUE if log low license count warning, FALSE otherwise.
              note, this parameter is ignore in enforce build.

--*/
{
    TCHAR szDbRestoreFile[MAX_PATH+1];
    WIN32_FIND_DATA RestoreFileAttr;
    WIN32_FIND_DATA LsDbFileAttr;
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    TCHAR szDbBackupFile[MAX_PATH+1];
    TCHAR szDbRestoreTmpFile[MAX_PATH+1];

    if(bIgnoreRestoreFile == TRUE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Ignore restore file\n")
            );
        
        goto open_existing;
    }


    //----------------------------------------------------------
    //
    // Check database file in the export directory.
    //
    //----------------------------------------------------------
    _tcscpy(szDbRestoreFile, g_szDatabaseDir);
    _tcscat(szDbRestoreFile, TLSBACKUP_EXPORT_DIR);
    _tcscat(szDbRestoreFile, _TEXT("\\"));
    _tcscat(szDbRestoreFile, g_szDatabaseFname);

    bSuccess = FileExists(
                        szDbRestoreFile, 
                        &RestoreFileAttr
                    );

    if(bSuccess == FALSE)
    {
        goto open_existing;
    }

    bSuccess = FileExists(
                        g_szDatabaseFile, 
                        &LsDbFileAttr
                    );

    if(bSuccess == FALSE)
    {

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("No existing database file, use restored file...\n")
            );

        //
        // Database file does not exist, move the restored file over and open it.
        //
        bSuccess = MoveFileEx(
                            szDbRestoreFile, 
                            g_szDatabaseFile, 
                            MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                        );

        if(bSuccess == FALSE)
        {

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Failed to move restore to existing db file - %d\n"),
                    GetLastError()
                );

            // can't move restore file, don't use the restore file, 
            // startup with empty database
            dwStatus = GetLastError();

            LPCTSTR pString[1];
            pString[0] = szDbRestoreFile;

            TLSLogEventString(
                    EVENTLOG_WARNING_TYPE,
                    TLS_E_DBRESTORE_MOVEFILE,
                    1,
                    pString
                );
        }
        else
        {
            TLSLogInfoEvent(TLS_I_USE_DBRESTOREFILE);
        }

        #if DBG
        EnsureExclusiveAccessToDbFile( g_szDatabaseFile );
        #endif

        goto open_existing;
    }

    //
    // Compare file's last modification time, if existing database file is newer 
    // than restore one, log event and continue opening existing file
    //
    if( bIgnoreFileTimeChk == FALSE )
    {
        if(CompareFileTime(&(RestoreFileAttr.ftLastWriteTime), &(LsDbFileAttr.ftLastWriteTime)) <= 0 )
        {
            DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Restore file is too old...\n"),
                GetLastError()
            );

            //TLSLogInfoEvent(TLS_I_DBRESTORE_OLD);
            goto open_existing;
        }
    }

    //
    // make a backup copy of existing database file.
    //
    bSuccess = TLSGenerateLSDBBackupFileName(
                            g_szDatabaseDir,
                            szDbBackupFile
                        );

    if (bSuccess)
    {
        DBGPrintf(
                  DBG_INFORMATION,
                  DBG_FACILITY_INIT,
                  DBGLEVEL_FUNCTION_DETAILSIMPLE,
                  _TEXT("Existing database file has been backup to %s\n"),
                  szDbBackupFile
                  );
    
        bSuccess = MoveFileEx(
                              g_szDatabaseFile, 
                              szDbBackupFile,
                              MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                              );
    }

    if(bSuccess == FALSE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Failed to backup existing database file - %d\n"),
                GetLastError()
            );


        //
        // Can't save a copy of existing database file
        // Log an error and continue to open using existing database
        //
        LPCTSTR pString[1];

        pString[0] = g_szDatabaseFile;
        
        TLSLogEventString(
                    EVENTLOG_WARNING_TYPE,
                    TLS_W_DBRESTORE_SAVEEXISTING,
                    1,
                    pString
                );

        goto open_existing;
    }

    //
    // Rename restore file and then try to open the restore file.
    //
    bSuccess = MoveFileEx(
                        szDbRestoreFile,
                        g_szDatabaseFile,
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                    );

    if(bSuccess == TRUE)
    {
        #if DBG
        EnsureExclusiveAccessToDbFile( g_szDatabaseFile );
        #endif

        //
        // Open the restore database file
        //
        dwStatus = TLSStartupLSDB(
                            bChkDbStatus,
                            g_dwMaxDbHandles,
                            FALSE,
                            bLogWarning,
                            g_szDatabaseDir,
                            g_szDatabaseDir,
                            g_szDatabaseDir,
                            g_szDatabaseFile,
                            g_szDbUser,
                            g_szDbPwd
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // Log event indicating we open the restore file, existing 
            // database file has been saved as ...
            //
            LPCTSTR pString[1];

            pString[0] = szDbBackupFile;
            
            TLSLogEventString(
                            EVENTLOG_INFORMATION_TYPE,
                            TLS_I_OPENRESTOREDBFILE,
                            1,
                            pString
                        );

            return dwStatus;
        }
    }
            
    //
    // Can't open the restore db file or MoveFileEx() failed
    //
    bSuccess = TLSGenerateLSDBBackupFileName(
                        g_szDatabaseDir,
                        szDbRestoreTmpFile
                        );

    if (bSuccess)
    {
        DBGPrintf(
                  DBG_INFORMATION,
                  DBG_FACILITY_INIT,
                  DBGLEVEL_FUNCTION_DETAILSIMPLE,
                  _TEXT("Backup restore file to %s\n"),
                  szDbRestoreTmpFile
                  );

        bSuccess = MoveFileEx(
                        g_szDatabaseFile,
                        szDbRestoreTmpFile,
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                        );
    }

    if(bSuccess == FALSE)
    {
        // failed to backup restore db file, delete it
        bSuccess = DeleteFile(g_szDatabaseFile);
        TLSLogErrorEvent(TLS_E_RESTOREDBFILE_OPENFAIL);
    }
    else
    {
        LPCTSTR pString[1];
        
        pString[0] = szDbRestoreTmpFile;
        TLSLogEventString(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_RESTOREDBFILE_OPENFAIL_SAVED,
                        1,
                        pString
                    );
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("Restore original database file %s to %s\n"),
            szDbBackupFile,
            g_szDatabaseFile
        );

    //
    // Restore the existing database file
    //
    bSuccess = MoveFileEx(
                        szDbBackupFile,
                        g_szDatabaseFile,
                        MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH
                    );

    if(bSuccess == FALSE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("failed to restore original DB file - %d\n"),
                GetLastError()
            );

        TLSASSERT(FALSE);
        // this is really bad, continue with empty database file.
    }

    #if DBG
    EnsureExclusiveAccessToDbFile( g_szDatabaseFile );
    #endif

open_existing:

    return TLSStartupLSDB(
                    bChkDbStatus,
                    g_dwMaxDbHandles,
                    TRUE,
                    bLogWarning,    
                    g_szDatabaseDir,
                    g_szDatabaseDir,
                    g_szDatabaseDir,
                    g_szDatabaseFile,
                    g_szDbUser,
                    g_szDbPwd
                );
}

///////////////////////////////////////////////////////////////
DWORD
TLSLoadRuntimeParameters()
/*++


--*/
{
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwKeyType;
    TCHAR szDbPath[MAX_PATH+1];;
    TCHAR szDbFileName[MAX_PATH+1];
    DWORD dwBuffer;

    DWORD cbByte = 0;
    PBYTE pbByte = NULL;


    //-------------------------------------------------------------------
    //
    // Open HKLM\system\currentcontrolset\sevices\termservlicensing\parameters
    //
    //-------------------------------------------------------------------
    dwStatus =RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_PARAMETERS,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                TLS_E_ACCESS_REGISTRY,
                dwStatus
            );

        dwStatus = TLS_E_INIT_GENERAL;
        goto cleanup;
    }

    
    //-------------------------------------------------------------------
    //
    // Get database file location and file name
    //
    //-------------------------------------------------------------------
    dwBuffer = sizeof(szDbPath) / sizeof(szDbPath[0]);

    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBPATH,
                        NULL,
                        NULL,
                        (LPBYTE)szDbPath,
                        &dwBuffer
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // need to startup so use default value, 
        //
        _tcscpy(
                szDbPath,
                LSERVER_DEFAULT_DBPATH
            );
    }

    //
    // Get database file name
    //
    dwBuffer = sizeof(szDbFileName) / sizeof(szDbFileName[0]);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBFILE,
                        NULL,
                        NULL,
                        (LPBYTE)szDbFileName,
                        &dwBuffer
                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Use default value.
        //
        _tcscpy(
                szDbFileName,
                LSERVER_DEFAULT_EDB
            );
    }

    _tcscpy(g_szDatabaseFname, szDbFileName);


    //
    // Always expand DB Path.
    //
    
    dwStatus = ExpandEnvironmentStrings(
                        szDbPath,
                        g_szDatabaseDir,
                        sizeof(g_szDatabaseDir) / sizeof(g_szDatabaseDir[0])
                    );

    if(dwStatus == 0)
    {
        // can't expand environment variable, error out.

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                TLS_E_LOCALDATABASEFILE,
                dwStatus = GetLastError()
            );

        goto cleanup;
    }        

    if(g_szDatabaseDir[_tcslen(g_szDatabaseDir) - 1] != _TEXT('\\'))
    {
        // JetBlue needs this.
        _tcscat(g_szDatabaseDir, _TEXT("\\"));
    } 

    //
    // Full path to database file
    //
    _tcscpy(g_szDatabaseFile, g_szDatabaseDir);
    _tcscat(g_szDatabaseFile, szDbFileName);


    //
    // Database file user and password
    //
    dwBuffer = sizeof(g_szDbUser) / sizeof(g_szDbUser[0]);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_USER,
                        NULL,
                        NULL,
                        (LPBYTE)g_szDbUser,
                        &dwBuffer
                    );

    // password is rendomly generated
    dwStatus = RetrieveKey(
                    LSERVER_LSA_PASSWORD_KEYNAME, 
                    &pbByte, 
                    &cbByte
                );

    // backward compatibilty
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Load password from registry or default to 'default' password
        //
        dwBuffer = sizeof(g_szDbPwd) / sizeof(g_szDbPwd[0]);
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_PWD,
                            NULL,
                            NULL,
                            (LPBYTE)g_szDbPwd,
                            &dwBuffer
                        );
    }
    else
    {
        //
        // save info into global variable
        //
        memset(g_szDbPwd, 0, sizeof(g_szDbPwd));
        memcpy((PBYTE)g_szDbPwd, pbByte, min(cbByte, sizeof(g_szDbPwd)));

    }

    if(pbByte != NULL)
    {
        LocalFree(pbByte);
    }

    //--------------------------------------------------------------------
    //
    // Work Object Parameters
    //
    //--------------------------------------------------------------------

    dwBuffer = sizeof(g_dwTlsJobInterval);

    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_WORKINTERVAL,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwTlsJobInterval,
                        &dwBuffer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        g_dwTlsJobInterval = DEFAULT_JOB_INTERVAL;
    }                

    dwBuffer = sizeof(g_dwTlsJobRetryTimes);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_RETRYTIMES,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwTlsJobRetryTimes,
                        &dwBuffer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        g_dwTlsJobRetryTimes = DEFAULT_JOB_RETRYTIMES;
    }                


    dwBuffer=sizeof(g_dwTlsJobRestartTime);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_WORKRESTART,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwTlsJobRestartTime,
                        &dwBuffer
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        g_dwTlsJobRestartTime = DEFAULT_JOB_INTERVAL;
    }                


    //---------------------------------------------------
    //
    // load low license warning count
    //
    //---------------------------------------------------
    dwBuffer = sizeof(g_LowLicenseCountWarning);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_LOWLICENSEWARNING,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_LOWLICENSEWARNING,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_LowLicenseCountWarning,
                            &dwBuffer
                        );
    }
                      
    //---------------------------------------------------
    //
    // Temp. license grace period
    //
    //---------------------------------------------------
    dwBuffer = sizeof(g_GracePeriod);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_GRACEPERIOD,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );
    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_GRACEPERIOD,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_GracePeriod,
                            &dwBuffer
                        );
    }

    if(g_GracePeriod > GRACE_PERIOD)
    {
        // grace period can be greated than this.
        g_GracePeriod = GRACE_PERIOD;
    }

    //
    // Are we allow to issue temp. license
    //
    dwBuffer = sizeof(g_IssueTemporayLicense);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_ISSUETEMPLICENSE,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_ISSUETEMPLICENSE,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_IssueTemporayLicense,
                            &dwBuffer
                        );
    }

    //------------------------------------------------------
    //
    // Timeout value if can't allocate a DB handle
    //
    //------------------------------------------------------

    //
    // Timeout for allocating a write handle
    //
    dwBuffer = sizeof(g_GeneralDbTimeout);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_DBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_DBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_GeneralDbTimeout,
                            &dwBuffer
                        );
    }

    //
    // Timeout for read handle
    //
    dwBuffer = sizeof(g_EnumDbTimeout);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_EDBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_EDBTIMEOUT,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_EnumDbTimeout,
                            &dwBuffer
                        );
    }

    //------------------------------------------------------
    //
    // Number of database handles
    //
    //------------------------------------------------------
    dwBuffer = sizeof(g_dwMaxDbHandles);
    dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_MAXDBHANDLES,
                            NULL,
                            &dwKeyType,
                            NULL,
                            &dwBuffer
                        );

    if(dwStatus == ERROR_SUCCESS && dwKeyType == REG_DWORD)
    {
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_MAXDBHANDLES,
                            NULL,
                            &dwKeyType,
                            (LPBYTE)&g_dwMaxDbHandles,
                            &dwBuffer
                        );

        if(g_dwMaxDbHandles > DB_MAX_CONNECTIONS-1)
        {
            g_dwMaxDbHandles = DEFAULT_DB_CONNECTIONS;
        }
    }

    //------------------------------------------------------
    // 
    // Load parameters for ESENT, all parameter must be set
    // and confirm to ESENT document, any error, we just 
    // revert back to some value we know it works.
    //
    //------------------------------------------------------
    dwBuffer = sizeof(g_EsentMaxCacheSize);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_ESENTMAXCACHESIZE,
                        NULL,
                        NULL,
                        (LPBYTE)&g_EsentMaxCacheSize,
                        &dwBuffer
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwBuffer = sizeof(g_EsentStartFlushThreshold);
        dwStatus = RegQueryValueEx(
                            hKey,
                            LSERVER_PARAMETERS_ESENTSTARTFLUSH,
                            NULL,
                            NULL,
                            (LPBYTE)&g_EsentStartFlushThreshold,
                            &dwBuffer
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwBuffer = sizeof(g_EsentStopFlushThreadhold);
            dwStatus = RegQueryValueEx(
                                hKey,
                                LSERVER_PARAMETERS_ESENTSTOPFLUSH,
                                NULL,
                                NULL,
                                (LPBYTE)&g_EsentStopFlushThreadhold,
                                &dwBuffer
                            );
        }
    }
    
    if( dwStatus != ERROR_SUCCESS || 
        g_EsentStartFlushThreshold > g_EsentStopFlushThreadhold ||
        g_EsentStopFlushThreadhold > g_EsentMaxCacheSize ||
        g_EsentMaxCacheSize < LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MIN ||
        g_EsentStartFlushThreshold < LSERVER_PARAMETERS_ESENTSTARTFLUSH_MIN ||
        g_EsentStopFlushThreadhold < LSERVER_PARAMETERS_ESENTSTOPFLUSH_MIN ||
        g_EsentMaxCacheSize > LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MAX ||
        g_EsentStartFlushThreshold > LSERVER_PARAMETERS_ESENTSTARTFLUSH_MAX ||
        g_EsentStopFlushThreadhold > LSERVER_PARAMETERS_ESENTSTOPFLUSH_MAX )
    {
        // pre-define number to let ESENT picks its number
        if( g_EsentMaxCacheSize != LSERVER_PARAMETERS_USE_ESENTDEFAULT )
        {
            g_EsentMaxCacheSize = LSERVER_PARAMETERS_ESENTMAXCACHESIZE_DEFAULT;
            g_EsentStartFlushThreshold = LSERVER_PARAMETERS_ESENTSTARTFLUSH_DEFAULT;
            g_EsentStopFlushThreadhold = LSERVER_PARAMETERS_ESENTSTOPFLUSH_DEFAULT;
        }
    }

    //------------------------------------------------------
    //
    // Determine role of server in enterprise
    //
    //------------------------------------------------------
    dwBuffer = sizeof(g_SrvRole);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_ROLE,
                        NULL,
                        NULL,
                        (LPBYTE)&g_SrvRole,
                        &dwBuffer
                    );


    if(g_SrvRole & TLSERVER_ENTERPRISE_SERVER)
    {
        dwBuffer = sizeof(g_szScope)/sizeof(g_szScope[0]);
        memset(g_szScope, 0, sizeof(g_szScope));

        dwStatus = RegQueryValueEx(
                                hKey,
                                LSERVER_PARAMETERS_SCOPE,
                                NULL,
                                &dwKeyType,
                                (LPBYTE)g_szScope,
                                &dwBuffer
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            // no scope is set, default to local machine name
            // consider using domain name ???
            LoadResourceString(
                            IDS_SCOPE_ENTERPRISE, 
                            g_szScope, 
                            sizeof(g_szScope)/sizeof(g_szScope[0])
                        );
        }

        g_pszScope = g_szScope;
    }
    else
    {
        //
        // Use the workgroup or domain name as scope
        //
        LPWSTR pszScope;

        if(GetMachineGroup(NULL, &pszScope) == FALSE)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_RETRIEVEGROUPNAME
                );

            goto cleanup;
        }

        g_pszScope = pszScope;
    }

    //------------------------------------------------------
    //
    // Reissuance Parameters
    //
    //------------------------------------------------------

    dwBuffer = sizeof(g_dwReissueLeaseMinimum);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LEASE_MIN,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueLeaseMinimum,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueLeaseMinimum = min(g_dwReissueLeaseMinimum,
                PERMANENT_LICENSE_LEASE_EXPIRE_MIN);
    }
    else
    {
        g_dwReissueLeaseMinimum = PERMANENT_LICENSE_LEASE_EXPIRE_MIN;
    }

    dwBuffer = sizeof(g_dwReissueLeaseRange);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LEASE_RANGE,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueLeaseRange,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueLeaseRange = min(g_dwReissueLeaseRange,
                PERMANENT_LICENSE_LEASE_EXPIRE_RANGE);

        g_dwReissueLeaseRange = max(g_dwReissueLeaseRange, 1);
    }
    else
    {
        g_dwReissueLeaseRange = PERMANENT_LICENSE_LEASE_EXPIRE_RANGE;
    }

    dwBuffer = sizeof(g_dwReissueLeaseLeeway);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LEASE_LEEWAY,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueLeaseLeeway,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueLeaseLeeway = min(g_dwReissueLeaseLeeway,
                PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY);
    }
    else
    {
        g_dwReissueLeaseLeeway = PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY;
    }

    dwBuffer = sizeof(g_dwReissueExpireThreadSleep);
    dwStatus = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_EXPIRE_THREAD_SLEEP,
                        NULL,
                        NULL,
                        (LPBYTE)&g_dwReissueExpireThreadSleep,
                        &dwBuffer
                    );

    if (dwStatus == ERROR_SUCCESS)
    {
        g_dwReissueExpireThreadSleep = min(g_dwReissueExpireThreadSleep,
                EXPIRE_THREAD_SLEEP_TIME);
    }
    else
    {
        g_dwReissueExpireThreadSleep = EXPIRE_THREAD_SLEEP_TIME;
    }

    dwStatus = ERROR_SUCCESS;

cleanup:
    
    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }
    

    return dwStatus;
}


///////////////////////////////////////////////////////////////
DWORD
TLSPrepareForBackupRestore()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("TLSPrepareForBackupRestore...\n")
        );

    //
    // Pretend we are shutting down.
    //
    // ServiceSignalShutdown();

    //
    // first stop workmanager thread
    //
    TLSWorkManagerShutdown();

    //
    // Close all workspace and DB handle
    //
#ifndef _NO_ODBC_JET
    if(g_DbWorkSpace != NULL)
    {
        ReleaseWorkSpace(&g_DbWorkSpace);
    }
#endif

    CloseWorkSpacePool();

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////
DWORD
TLSRestartAfterBackupRestore(
    BOOL bRestartAfterbackup
    )
/*++

bRestartAfterbackup : TRUE if restart after backup, FALSE if restart after restore.

--*/
{
    DWORD dwStatus;
    BOOL bIgnoreRestoreFile;
    BOOL bIgnoreFileTimeChecking;
    BOOL bLogWarning;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("TLSRestartAfterBackupRestore...\n")
        );


    //
    // Reset shutdown event
    //
    // ServiceResetShutdownEvent();

    //
    // Startup DB engine.
    //
    bIgnoreRestoreFile = bRestartAfterbackup;
    bIgnoreFileTimeChecking = (bRestartAfterbackup == FALSE);   // on restore, we need to ignore file time checking
    bLogWarning = bIgnoreFileTimeChecking;  // log warning after restart from restore

    dwStatus = TLSStartLSDbWorkspaceEngine(
                                    TRUE, 
                                    bIgnoreRestoreFile,             
                                    bIgnoreFileTimeChecking,
                                    bLogWarning
                                );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSWorkManagerInit();
    }

    // backup/restore always shutdown namedpipe thread
    InitNamedPipeThread();

    TLSASSERT(dwStatus == ERROR_SUCCESS);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("\tTLSRestartAfterBackupRestore() returns %d\n"),
            dwStatus
        );

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\keypack.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        keypack.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __KEYPACK_H__
#define __KEYPACK_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

void
TLSDBLockKeyPackTable();

void
TLSDBUnlockKeyPackTable();

DWORD
TLSDBKeyPackFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bMatchAllParm,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpKeyPack,
    IN OUT PTLSLICENSEPACK lpFound
);

DWORD
TLSDBKeyPackAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bDeleteAllRecord,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bPointerOnRecord,
    IN DWORD dwUpdateParm,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackUpdateNumOfAvailableLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bAdd, 
    IN PTLSLICENSEPACK lpKeyPack 
);

DWORD
TLSDBKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack  // return internal tracking ID
);

DWORD
TLSDBKeyPackEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL  bMatchAll,
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lpSearch
);

DWORD
TLSDBKeyPackEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PTLSLICENSEPACK lpKeyPack
);

void
TLSDBKeyPackEnumEnd( 
    IN PTLSDbWorkSpace pDbWkSpace
);

DWORD
TLSDBKeyPackSetValues(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bPointerOnRecord,
    IN DWORD        dwSetParm,
    IN PTLSLICENSEPACK lpKeyPack
);

DWORD
TLSDBKeyPackGetAvailableLicenses( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD dwSearchParm,
    IN PTLSLICENSEPACK lplsKeyPack,
    IN OUT LPDWORD lpdwAvail
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\jobmgr.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        jobmgr.cpp
//
// Contents:    Job scheduler    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <process.h>
#include "server.h"
#include "jobmgr.h"
#include "debug.h"


//------------------------------------------------------------
//
//
CLASS_PRIVATE BOOL
CWorkManager::SignalJobRunning(
    IN CWorkObject *ptr
    )
/*++

Abstract:

    Class private routine for work object to 'signal' 
    work manger it has started processing.

Parameter:

    ptr : Pointer to CWorkObject that is ready to run.

Returns:

    TRUE/FALSE 

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    INPROCESSINGJOBLIST::iterator it;

    if(ptr != NULL)
    {
        m_InProcessingListLock.Lock();

        try {

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_WORKMGR,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("WorkManager : SignalJobRunning() Job %p ...\n"),
                    ptr
                );
 
            //
            // find our pointer in processing list
            //
            it = m_InProcessingList.find(ptr);

            if(it != m_InProcessingList.end())
            {
                // TODO - make processing thread handle a list.
                if((*it).second.m_hThread == NULL)
                {
                    HANDLE hHandle;
                    DWORD dwStatus;
                    BOOL bSuccess;

                    bSuccess = DuplicateHandle(
                                            GetCurrentProcess(), 
                                            GetCurrentThread(), 
                                            GetCurrentProcess(), 
                                            &hHandle, 
                                            DUPLICATE_SAME_ACCESS, 
                                            FALSE, 
                                            0
                                        );

                    if(bSuccess == FALSE)
                    {
                        //
                        // non-critical error, if we fail, we won't be able to 
                        // cancel our rpc call.
                        //
                        SetLastError(dwStatus = GetLastError());

                        DBGPrintf(
                                DBG_INFORMATION,
                                DBG_FACILITY_WORKMGR,
                                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                                _TEXT("WorkManager : SignalJobRunning() duplicate handle return %d...\n"),
                                dwStatus
                            );
                    }
                    else
                    {
                        //
                        // set processing thread handle of job.
                        //
                        (*it).second.m_hThread = hHandle;
                    }
                }
            }
            else
            {
                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_TRACE,
                        _TEXT("WorkManager : SignalJobRunning can't find job %p in processing list...\n"),
                        ptr
                    );

                //
                // timing problem, job might be re-scheduled and actually execute before we have 
                // time to remove from our in-processing list.
                //
                //TLSASSERT(FALSE);
            }
        }
        catch( SE_Exception e ) {
            SetLastError(dwStatus = e.getSeNumber());
            TLSASSERT(FALSE);
        }
        catch(...) {
            SetLastError(dwStatus = TLS_E_WORKMANAGER_INTERNAL);
            TLSASSERT(FALSE);
        }   

        m_InProcessingListLock.UnLock();
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
    }

    return dwStatus;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE void
CWorkManager::CancelInProcessingJob()
/*++

Abstract:

    Class private : cancel job currently in processing state, 
    only invoked at the time of service shutdown.

Parameter:

    None.

Return:

    None.

--*/
{
    INPROCESSINGJOBLIST::iterator it;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("WorkManager : CancelInProcessingJob...\n")
        );
        
    m_InProcessingListLock.Lock();

    try {
        for(it = m_InProcessingList.begin(); 
            it != m_InProcessingList.end(); 
            it++ )
        {
            if((*it).second.m_hThread != NULL)
            {
                // cancel everything and ignore error.
                (VOID)RpcCancelThread((*it).second.m_hThread);
            }
        }
    }
    catch( SE_Exception e ) {
        SetLastError(e.getSeNumber());
    }
    catch(...) {
        SetLastError(TLS_E_WORKMANAGER_INTERNAL);
    }   

    m_InProcessingListLock.UnLock();
    return;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::AddJobToProcessingList(
    IN CWorkObject *ptr
    )
/*++

Abstract:

    Class private, move job from wait queue to in-process queue.

Parameter:

    ptr : Pointer to job.

Parameter:

    ERROR_SUCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    INPROCESSINGJOBLIST::iterator it;
    WorkMangerInProcessJob job;

    if(ptr == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
    }
    else
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("WorkManager : Add Job <%s> to processing list...\n"),
                ptr->GetJobDescription()
            );
            

        m_InProcessingListLock.Lock();

        try {
            it = m_InProcessingList.find(ptr);
            if(it != m_InProcessingList.end())
            {
                // increase the reference counter.
                InterlockedIncrement(&((*it).second.m_refCounter));
            }
            else
            {
                job.m_refCounter = 1;
                job.m_hThread = NULL;   // job not run yet.

                m_InProcessingList[ptr] = job;
            }

            ResetEvent(m_hJobInProcessing);
        }
        catch( SE_Exception e ) {
            SetLastError(dwStatus = e.getSeNumber());
        }
        catch(...) {
            SetLastError(dwStatus = TLS_E_WORKMANAGER_INTERNAL);
        }   

        m_InProcessingListLock.UnLock();
    }

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::RemoveJobFromProcessingList(
    IN CWorkObject *ptr
    )
/*++

Abstract:

    Class private, remove a job from in-processing list.

Parameter:

    ptr : Pointer to job to be removed from list.

Returns:

    ERROR_SUCCESS or error code.
 
--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    INPROCESSINGJOBLIST::iterator it;

    if(ptr != NULL)
    {
        m_InProcessingListLock.Lock();

        try {

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_WORKMGR,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("WorkManager : RemoveJobFromProcessingList Job %p from processing list...\n"),
                    ptr
                );
 
            it = m_InProcessingList.find(ptr);

            if(it != m_InProcessingList.end())
            {
                // decrease the reference counter
                InterlockedDecrement(&((*it).second.m_refCounter));

                if((*it).second.m_refCounter <= 0)
                {
                    // close thread handle.
                    if((*it).second.m_hThread != NULL)
                    {
                        CloseHandle((*it).second.m_hThread);
                    }

                    m_InProcessingList.erase(it);
                }
                else
                {
                    DBGPrintf(
                            DBG_INFORMATION,
                            DBG_FACILITY_WORKMGR,
                            DBGLEVEL_FUNCTION_TRACE,
                            _TEXT("WorkManager : RemoveJobFromProcessingList job %p reference counter = %d...\n"),
                            ptr,
                            (*it).second
                        );
                }
            }
            else
            {
                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_TRACE,
                        _TEXT("WorkManager : RemoveJobFromProcessingList can't find job %p in processing list...\n"),
                        ptr
                    );

                //
                // timing problem, job might be re-scheduled and actually execute before we have 
                // time to remove from our in-processing list.
                //
                //TLSASSERT(FALSE);
            }

            if(m_InProcessingList.empty() == TRUE)
            {
                //
                // Inform Work Manager that no job is in processing.
                //
                SetEvent(m_hJobInProcessing);
            }
        }
        catch( SE_Exception e ) {
            SetLastError(dwStatus = e.getSeNumber());
            TLSASSERT(FALSE);
        }
        catch(...) {
            SetLastError(dwStatus = TLS_E_WORKMANAGER_INTERNAL);
            TLSASSERT(FALSE);
        }   

        m_InProcessingListLock.UnLock();
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
    }

    return dwStatus;
}
    
//------------------------------------------------------------
//
//
CLASS_PRIVATE BOOL
CWorkManager::WaitForObjectOrShutdown(
    IN HANDLE hHandle
    )
/*++

Abstract:

    Class private, Wait for a sync. handle or service shutdown
    event.

Parameter:

    hHandle : handle to wait for,

Returns:

    TRUE if sucessful, FALSE if service shutdown or error.
    
--*/
{
    HANDLE handles[] = {hHandle, m_hShutdown};
    DWORD dwStatus;

    dwStatus = WaitForMultipleObjects(
                                sizeof(handles)/sizeof(handles[0]),
                                handles,
                                FALSE,
                                INFINITE
                            );

    return (dwStatus == WAIT_OBJECT_0);
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::RunJob(
    IN CWorkObject* ptr,
    IN BOOL bImmediate
    )
/*++

Abstract:

    Process a job object via QueueUserWorkItem() Win32 API subject 
    to our max. concurrent job limitation.

Parameter:

    ptr : Pointer to CWorkObject.
    bImmediate : TRUE if job must be process immediately, 
                 FALSE otherwise.

Returns:

    ERROR_SUCCESS or Error code.

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    if(ptr != NULL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("WorkManager : RunJob <%s>...\n"),
                ptr->GetJobDescription()
            );

        //
        // Wait if we exceed max. concurrent job
        //
        bSuccess = (bImmediate) ? bImmediate : m_hMaxJobLock.AcquireEx(m_hShutdown);

        if(bSuccess == TRUE)
        {
            DWORD dwFlag;
            DWORD dwJobRunningAttribute;

            dwJobRunningAttribute = ptr->GetJobRunningAttribute();
            dwFlag = TranslateJobRunningAttributeToThreadPoolFlag(
                                                        dwJobRunningAttribute
                                                    );

            dwStatus = AddJobToProcessingList(ptr);
            if(dwStatus == ERROR_SUCCESS)
            {
                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("RunJob() : queuing user work item %p...\n"),
                        ptr
                    );

                // need immediate attention.
                bSuccess = QueueUserWorkItem(
                                        CWorkManager::ExecuteWorkObject,
                                        ptr,
                                        dwFlag
                                    );

                if(bSuccess == FALSE)
                {
                    dwStatus = GetLastError();

                    DBGPrintf(
                            DBG_ERROR,
                            DBG_FACILITY_WORKMGR,
                            DBGLEVEL_FUNCTION_DETAILSIMPLE,
                            _TEXT("RunJob() : queuing user work item %p failed with 0x%08x...\n"),
                            ptr,
                            dwStatus
                        );

                    //TLSASSERT(dwStatus == ERROR_SUCCESS);
                    dwStatus = RemoveJobFromProcessingList(ptr);
                }
            }
            else
            {
                bSuccess = FALSE;
            }
            
            if(bSuccess == FALSE)
            {
                dwStatus = GetLastError();
                //TLSASSERT(FALSE);
            }

            //
            // release max. concurrent job lock
            //
            if(bImmediate == FALSE)
            {
                m_hMaxJobLock.Release();
            }
        }
        else
        {
            dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
        }
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE DWORD
CWorkManager::ProcessScheduledJob()
/*++

Abstract:

    Class private, process a scheduled job.

Parameter:

    None.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
  

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ProcessScheduledJob(), %d %d\n"),
            GetNumberJobInStorageQueue(),
            GetNumberJobInMemoryQueue()
        );

    if(GetNumberJobInStorageQueue() != 0 && IsShuttingDown() == FALSE)
    {
        //
        // Could have use work item to process both
        // queue but this uses one extra handle, and
        // work manager thread will just doing nothing
        // 
        ResetEvent(m_hInStorageWait);

        //
        // Queue a user work item to thread pool to process
        // in storage job
        //
        bSuccess = QueueUserWorkItem(
                                    CWorkManager::ProcessInStorageScheduledJob,
                                    this,
                                    WT_EXECUTELONGFUNCTION
                                );
        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_WORKMGR,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("CWorkManager::ProcessScheduledJob() queue user work iterm returns 0x%08x\n"),
                    dwStatus
                );

            TLSASSERT(dwStatus == ERROR_SUCCESS);
        }
    }

    if(bSuccess == TRUE)
    {
        dwStatus = ProcessInMemoryScheduledJob(this);
        if(WaitForObjectOrShutdown(m_hInStorageWait) == FALSE)
        {
            dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
        }
    }

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC DWORD WINAPI
CWorkManager::ProcessInMemoryScheduledJob(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, process in-memory scheduled jobs.  
    WorkManagerThread kick off two threads, one to process 
    in-memory job and the other to process persistent job.

Parameter:

    pContext : Pointer to work manager object.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD ulCurrentTime;
    DWORD dwJobTime;
    CWorkObject* pInMemoryWorkObject = NULL;
    BOOL bSuccess = TRUE;
    BOOL dwStatus = ERROR_SUCCESS;
    
    CWorkManager* pWkMgr = (CWorkManager *)pContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ProcessInMemoryScheduledJob()\n")
        );


    if(pWkMgr == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TLSASSERT(pWkMgr != NULL);
        return ERROR_INVALID_PARAMETER;
    }

    do {    
        if(pWkMgr->IsShuttingDown() == TRUE)
        {
            dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
            break;
        }

        ulCurrentTime = time(NULL);
        dwJobTime = ulCurrentTime;
        pInMemoryWorkObject = pWkMgr->GetNextJobInMemoryQueue(&dwJobTime);

        if(pInMemoryWorkObject != NULL)
        {
            // TLSASSERT(dwJobTime <= ulCurrentTime);
            if(dwJobTime <= ulCurrentTime)
            {
                dwStatus = pWkMgr->RunJob(
                                    pInMemoryWorkObject,
                                    FALSE
                                );

                if(dwStatus != ERROR_SUCCESS)
                {
                    //
                    // consider to re-schedule job again.
                    //
                    pInMemoryWorkObject->EndJob();

                    if(pInMemoryWorkObject->CanBeDelete() == TRUE)
                    {
                        pInMemoryWorkObject->SelfDestruct();
                    }
                }
            }
            else
            {
                //
                // Very expansive operation, GetNextJobInMemoryQueue() must be
                // wrong.
                //
                dwStatus = pWkMgr->AddJobIntoMemoryQueue(
                                            dwJobTime, 
                                            pInMemoryWorkObject
                                        );

                if(dwStatus != ERROR_SUCCESS)
                {
                    //
                    // delete the job
                    //
                    pInMemoryWorkObject->EndJob();

                    if(pInMemoryWorkObject->CanBeDelete() == TRUE)
                    {
                        pInMemoryWorkObject->SelfDestruct();
                    }
                }
            }
        }
    } while(dwStatus == ERROR_SUCCESS && (pInMemoryWorkObject != NULL && dwJobTime <= ulCurrentTime));

    return dwStatus;
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC DWORD WINAPI
CWorkManager::ProcessInStorageScheduledJob(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, process scheduled persistent jobs.  
    WorkManagerThread kick off two threads, one to process 
    in-memory job and the other to process persistent job.

Parameter:

    pContext : Pointer to work manager object.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD ulCurrentTime = 0;
    DWORD dwJobScheduledTime = 0;
    CWorkObject* pInStorageWorkObject = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    CWorkManager* pWkMgr = (CWorkManager *)pContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ProcessInStorageScheduledJob()\n")
        );

    if(pWkMgr == NULL)
    {
        TLSASSERT(pWkMgr != NULL);
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
            
    TLSASSERT(pWkMgr->m_pPersistentWorkStorage != NULL);

    if(pWkMgr->m_pPersistentWorkStorage->GetNumJobs() > 0)
    {
        do
        {
            if(pWkMgr->IsShuttingDown() == TRUE)
            {
                dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
                break;
            }

            ulCurrentTime = time(NULL);
            pInStorageWorkObject = pWkMgr->m_pPersistentWorkStorage->GetNextJob(&dwJobScheduledTime);

            if(pInStorageWorkObject == NULL)
            {
                //
                // Something wrong in persistent storage???
                //
                DBGPrintf(
                        DBG_WARNING,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::ProcessInStorageScheduledJob() : Persistent work storage return NULL job\n")
                    );

                break;
            }
            else if(dwJobScheduledTime > ulCurrentTime)
            {
                DBGPrintf(
                        DBG_WARNING,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::ProcessInStorageScheduledJob() : return job back to persistent storage\n")
                    );

                pWkMgr->m_pPersistentWorkStorage->EndProcessingJob( 
                                                            ENDPROCESSINGJOB_RETURN,
                                                            dwJobScheduledTime,
                                                            pInStorageWorkObject
                                                        );
            }
            else
            {
                pInStorageWorkObject->SetScheduledTime(dwJobScheduledTime);
                pWkMgr->m_pPersistentWorkStorage->BeginProcessingJob(pInStorageWorkObject);

                dwStatus = pWkMgr->RunJob(
                                            pInStorageWorkObject, 
                                            FALSE
                                        );

                if(dwStatus != ERROR_SUCCESS)
                {
                    DBGPrintf(
                            DBG_WARNING,
                            DBG_FACILITY_WORKMGR,
                            DBGLEVEL_FUNCTION_DETAILSIMPLE,
                            _TEXT("CWorkManager::ProcessInStorageScheduledJob() : unable to queue job, return job back ") \
                            _TEXT("to persistent storage\n")
                        );

                    pWkMgr->m_pPersistentWorkStorage->EndProcessingJob( 
                                                                ENDPROCESSINGJOB_RETURN,
                                                                pInStorageWorkObject->GetScheduledTime(),
                                                                pInStorageWorkObject
                                                            );
                }
            }
        } while(dwStatus == ERROR_SUCCESS && ulCurrentTime >= dwJobScheduledTime);
    }

    //
    // Signal we are done
    //
    SetEvent(pWkMgr->m_hInStorageWait);
    return dwStatus;     
}

//------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC
unsigned int __stdcall
CWorkManager::WorkManagerThread(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, this is the work manager thread to handle
    job scheduling and process scheduled job.  WorkManagerThread() 
    will not terminate until m_hShutdown event is signal.

Parameter:
    
    pContext : Pointer to work manager object.

Returns:

    ERROR_SUCCESS

--*/
{
    DWORD dwTimeToNextJob = INFINITE;
    CWorkManager* pWkMgr = (CWorkManager *)pContext;
    DWORD dwHandleFlag;
    
    TLSASSERT(pWkMgr != NULL);
    TLSASSERT(GetHandleInformation(pWkMgr->m_hNewJobArrive, &dwHandleFlag) == TRUE);
    TLSASSERT(GetHandleInformation(pWkMgr->m_hShutdown, &dwHandleFlag) == TRUE);

    HANDLE m_hWaitHandles[] = {pWkMgr->m_hShutdown, pWkMgr->m_hNewJobArrive};
    DWORD dwWaitStatus = WAIT_TIMEOUT;
    DWORD dwStatus = ERROR_SUCCESS;
    
    //
    // Get the time to next job
    // 
    while(dwWaitStatus != WAIT_OBJECT_0 && dwStatus == ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("CWorkManager::WorkManagerThread() : Time to next job %d\n"),
                dwTimeToNextJob
            );
        
        dwWaitStatus = WaitForMultipleObjectsEx(
                                            sizeof(m_hWaitHandles) / sizeof(m_hWaitHandles[0]),
                                            m_hWaitHandles,
                                            FALSE,
                                            dwTimeToNextJob * 1000,
                                            TRUE        // we might need this thread to do some work 
                                        );

        switch( dwWaitStatus )
        {
            case WAIT_OBJECT_0:
                dwStatus = ERROR_SUCCESS;

                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::WorkManagerThread() : shutdown ...\n")
                    );

                break;

            case WAIT_OBJECT_0 + 1:
                // still a possibility that we might not catch a new job
                ResetEvent(pWkMgr->m_hNewJobArrive);
    
                // New Job arrived
                dwTimeToNextJob = pWkMgr->GetTimeToNextJob();
                break;
        
            case WAIT_TIMEOUT:
                // Time to process job.
                dwStatus = pWkMgr->ProcessScheduledJob();
                dwTimeToNextJob = pWkMgr->GetTimeToNextJob();
                break;

            default:
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_WORKMGR,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("CWorkManager::WorkManagerThread() : unexpected return %d\n"),
                        dwStatus
                    );

                dwStatus = TLS_E_WORKMANAGER_INTERNAL;
                TLSASSERT(FALSE);
        }
    }

    if(dwStatus != ERROR_SUCCESS && dwStatus != TLS_I_WORKMANAGER_SHUTDOWN)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CWorkManager::WorkManagerThread() : unexpected return %d, generate console event\n"),
                dwStatus
            );

        // immediately shut down server
        GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
    }
            
    _endthreadex(dwStatus);
    return dwStatus;
}

//----------------------------------------------------------------
//
//
CLASS_PRIVATE CLASS_STATIC 
DWORD WINAPI
CWorkManager::ExecuteWorkObject(
    IN PVOID pContext
    )
/*++

Abstract:

    Static class private, execute a work object.

Parameter:

    pContext : Pointer to work object to be process.

Returns:

    ERROR_SUCCESS or error code.
    
--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    CWorkObject* pWorkObject = (CWorkObject *)pContext;
    DWORD dwJobRescheduleTime;
    BOOL bStorageJobCompleted;
    CWorkManager* pWkMgr = NULL;
    BOOL bPersistentJob = FALSE;


    if(pContext == NULL)
    {
        TLSASSERT(FALSE);
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ExecuteWorkObject() : executing %p <%s>\n"),
            pWorkObject,
            pWorkObject->GetJobDescription()
        );

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    //
    // Set RPC cancel timeout, thread dependent.
    (VOID)RpcMgmtSetCancelTimeout(DEFAULT_RPCCANCEL_TIMEOUT);

    bPersistentJob = pWorkObject->IsWorkPersistent();

    try {

        pWkMgr = pWorkObject->GetWorkManager();

        if(pWkMgr != NULL)
        {
            pWkMgr->SignalJobRunning(pWorkObject);   // tell work manager that we are running

            pWorkObject->ExecuteWorkObject();

            if(bPersistentJob == TRUE)
            {
                //
                // Persistent work object, let work storage handle
                // its re-scheduling
                //
                bStorageJobCompleted = pWorkObject->IsJobCompleted();
            
                pWorkObject->GetWorkManager()->m_pPersistentWorkStorage->EndProcessingJob(
                                                                                    ENDPROCESSINGJOB_SUCCESS,
                                                                                    pWorkObject->GetScheduledTime(),
                                                                                    pWorkObject
                                                                                );

                if(bStorageJobCompleted == FALSE)
                {
                    //
                    // This job might be re-scheduled 
                    // before our work manager thread wakes up, 
                    // so signal job is ready 
                    //
                    pWkMgr->SignalJobArrive();
                }
            }
            else
            {
                //
                // Reschedule job if necessary
                //
                dwJobRescheduleTime = pWorkObject->GetSuggestedScheduledTime();
                if(dwJobRescheduleTime != INFINITE)
                {
                    dwStatus = pWorkObject->ScheduleJob(dwJobRescheduleTime);
                }

                if(dwJobRescheduleTime == INFINITE || dwStatus != ERROR_SUCCESS)
                {
                    //
                    // if can't schedule job again, go ahead and delete it.
                    //
                    pWorkObject->EndJob();
                    if(pWorkObject->CanBeDelete() == TRUE)
                    {
                        pWorkObject->SelfDestruct();
                    }
                }                
            }
        }

    }
    catch( SE_Exception e ) 
    {

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CWorkManager::ExecuteWorkObject() : Job %p has cause exception %d\n"),
                pWorkObject,
                e.getSeNumber()
            );

        dwStatus = e.getSeNumber();
        if(pWkMgr != NULL && bPersistentJob == TRUE)
        {
            pWkMgr->m_pPersistentWorkStorage->EndProcessingJob(
                                                            ENDPROCESSINGJOB_ERROR,
                                                            0,
                                                            pWorkObject
                                                        );
        }
    }
    catch(...) 
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CWorkManager::ExecuteWorkObject() : Job %p has cause unknown exception\n"),
                pWorkObject
            );

        if(pWkMgr != NULL && bPersistentJob == TRUE)
        {
            pWkMgr->m_pPersistentWorkStorage->EndProcessingJob(
                                                            ENDPROCESSINGJOB_ERROR,
                                                            0,
                                                            pWorkObject
                                                        );
        }
    }   

    try {
        if(pWkMgr)
        {
            // Delete this job from in-processing list.
            pWkMgr->EndProcessingScheduledJob(pWorkObject);
        }
    }
    catch(...) {
    }
    
    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return dwStatus;
}

//----------------------------------------------------------------
//
//
CWorkManager::CWorkManager() :
m_hWorkMgrThread(NULL),
m_hNewJobArrive(NULL),
m_hShutdown(NULL),
m_hInStorageWait(NULL),
m_hJobInProcessing(NULL),
m_dwNextInMemoryJobTime(WORKMANAGER_WAIT_FOREVER),
m_dwNextInStorageJobTime(WORKMANAGER_WAIT_FOREVER),
m_dwMaxCurrentJob(DEFAULT_NUM_CONCURRENTJOB),
m_dwDefaultInterval(DEFAULT_WORK_INTERVAL)
{
}


//----------------------------------------------------------------
//
CWorkManager::~CWorkManager()
{
    Shutdown();

    if(m_hNewJobArrive != NULL)
    {
        CloseHandle(m_hNewJobArrive);
    }

    if(m_hWorkMgrThread != NULL)
    {
        CloseHandle(m_hWorkMgrThread);
    }

    if(m_hShutdown != NULL)
    {
        CloseHandle(m_hShutdown);
    }

    if(m_hInStorageWait != NULL)
    {
        CloseHandle(m_hInStorageWait);
    }

    if(m_hJobInProcessing != NULL)
    {
        CloseHandle(m_hJobInProcessing);
    }
}

//----------------------------------------------------------------
//
DWORD
CWorkManager::Startup(
    IN CWorkStorage* pPersistentWorkStorage,
    IN DWORD dwWorkInterval,            // DEFAULT_WORK_INTERVAL
    IN DWORD dwNumConcurrentJob         // DEFAULT_NUM_CONCURRENTJOB
    )

/*++

Abstract:

    Initialize work manager

Parameters:

    pPersistentWorkStorage : A C++ object that derived from CPersistentWorkStorage class
    dwWorkInterval : Default schedule job interval
    dwNumConcurrentJob : Max. number of concurrent job to be fired at the same time

Return:

    ERROR_SUCCESS or Erro Code.

--*/

{
    DWORD index;
    DWORD dwStatus = ERROR_SUCCESS;
    unsigned dump;
    BOOL bSuccess;
    unsigned threadid;

    #ifdef __TEST_WORKMGR__
    _set_new_handler(handle_new_failed);
    #endif


    if(dwNumConcurrentJob == 0 || dwWorkInterval == 0 || pPersistentWorkStorage == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(m_hMaxJobLock.IsGood() == FALSE)
    {
        if(m_hMaxJobLock.Init(dwNumConcurrentJob, dwNumConcurrentJob) == FALSE)
        {
            //
            // out of resource
            //
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    m_dwDefaultInterval = dwWorkInterval;
    m_dwMaxCurrentJob = dwNumConcurrentJob;
    m_pPersistentWorkStorage = pPersistentWorkStorage;


    if(m_hJobInProcessing == NULL)
    {
        //
        // initial state is signal, no job in processing
        //
        m_hJobInProcessing = CreateEvent(
                                        NULL,
                                        TRUE,
                                        TRUE,
                                        NULL
                                    );
        if(m_hJobInProcessing == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }


    if(m_hShutdown == NULL)
    {
        //
        // Create a handle for signaling shutdown
        //
        m_hShutdown = CreateEvent(
                                NULL,
                                TRUE,
                                FALSE,
                                NULL
                            );

        if(m_hShutdown == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(m_hNewJobArrive == NULL)
    {
        //
        // initial state is signal so work manager thread can
        // update wait time
        //
        m_hNewJobArrive = CreateEvent(
                                    NULL,
                                    TRUE,
                                    TRUE,
                                    NULL
                                );

        if(m_hNewJobArrive == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(m_hInStorageWait == NULL)
    {
        m_hInStorageWait = CreateEvent(
                                    NULL,
                                    TRUE,
                                    TRUE, // signal state
                                    NULL
                                );

        if(m_hInStorageWait == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    //
    // Startup Work Storage first.
    //
    if(m_pPersistentWorkStorage->Startup(this) == FALSE)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CWorkManager::Startup() : Persistent storage has failed to startup - 0x%08x\n"),
                GetLastError()
            );
        
        dwStatus = TLS_E_WORKMANAGER_PERSISTENJOB;
        goto cleanup;
    }

    //
    // Get time to next persistent job.
    //
    if(UpdateTimeToNextPersistentJob() == FALSE)
    {
        dwStatus = TLS_E_WORKMANAGER_PERSISTENJOB;
        goto cleanup;
    }

    if(m_hWorkMgrThread == NULL)
    {
        //
        // Create work manager thread, suspended first
        //
        m_hWorkMgrThread = (HANDLE)_beginthreadex(
                                            NULL,
                                            0,
                                            CWorkManager::WorkManagerThread,
                                            this,
                                            0,
                                            &threadid
                                        );

        if(m_hWorkMgrThread == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

cleanup:

    return dwStatus;
}    

//----------------------------------------------------------------
void
CWorkManager::Shutdown()
/*++

Abstract:

    Shutdown work manager.

Parameter:

    None.

Return:

    None.

--*/
{
    HANDLE handles[] = {m_hInStorageWait, m_hJobInProcessing};
    DWORD dwStatus;

    //
    // Signal we are shuting down
    //
    if(m_hShutdown != NULL)
    {
        SetEvent(m_hShutdown);
    }


    //
    // Wait for dispatch thread to terminate so no job can be
    // dispatched.
    //
    if(m_hWorkMgrThread != NULL)
    {
        dwStatus = WaitForSingleObject( 
                                    m_hWorkMgrThread,
                                    INFINITE
                                );

        TLSASSERT(dwStatus != WAIT_FAILED);
        CloseHandle(m_hWorkMgrThread);
        m_hWorkMgrThread = NULL;
    }

    //
    // Cancel all in progress job
    //
    CancelInProcessingJob();

    //
    // Inform all existing job to shutdown.
    //
    DeleteAllJobsInMemoryQueue();

    //
    // Wait for all processing job to terminate
    //
    if(m_hInStorageWait != NULL && m_hJobInProcessing != NULL)
    {
        dwStatus = WaitForMultipleObjects(
                                sizeof(handles)/sizeof(handles[0]),
                                handles,
                                TRUE,
                                INFINITE
                            );

        TLSASSERT(dwStatus != WAIT_FAILED);

        CloseHandle(m_hInStorageWait);
        m_hInStorageWait = NULL;

        CloseHandle(m_hJobInProcessing);
        m_hJobInProcessing = NULL;
    }

    if(m_pPersistentWorkStorage != NULL)
    {
        //
        // Signal we are shutting down, no job is in
        // processing and we are not taking any
        // new job
        //
        m_pPersistentWorkStorage->Shutdown();
        m_pPersistentWorkStorage = NULL;
    }
   
    TLSASSERT( GetNumberJobInProcessing() == 0 );
    // TLSASSERT( GetNumberJobInMemoryQueue() == 0 );

    if(m_hNewJobArrive != NULL)
    {
        CloseHandle(m_hNewJobArrive);
        m_hNewJobArrive = NULL;
    }

    if(m_hWorkMgrThread != NULL)
    {
        CloseHandle(m_hWorkMgrThread);
        m_hWorkMgrThread = NULL;   
    }

    if(m_hShutdown != NULL)
    {
        CloseHandle(m_hShutdown);
        m_hShutdown = NULL;
    }

    if(m_hInStorageWait != NULL)
    {
        CloseHandle(m_hInStorageWait);
        m_hInStorageWait = NULL;
    }

    if(m_hJobInProcessing != NULL)
    {
        CloseHandle(m_hJobInProcessing);
        m_hJobInProcessing = NULL;
    }

    return;
}

//----------------------------------------------------------------
CLASS_PRIVATE DWORD
CWorkManager::GetTimeToNextJob()
/*++

Abstract:

    Class private, return time to next scheduled job.

Parameter:

    None.

Return:

    Time to next job in second.

--*/
{
    DWORD dwNextJobTime = WORKMANAGER_WAIT_FOREVER;
    DWORD dwNumPersistentJob = GetNumberJobInStorageQueue();
    DWORD dwNumInMemoryJob = GetNumberJobInMemoryQueue();
    DWORD dwCurrentTime = time(NULL);

    if( dwNumPersistentJob == 0 && dwNumInMemoryJob == 0 )
    {
        // DO NOTHING

        // dwTimeToNextJob = WORKMANAGER_WAIT_FOREVER;
    }
    else
    {
        UpdateTimeToNextInMemoryJob();
        UpdateTimeToNextPersistentJob();

        dwNextJobTime = min((DWORD)m_dwNextInMemoryJobTime, (DWORD)m_dwNextInStorageJobTime);

        if((DWORD)dwNextJobTime < (DWORD)dwCurrentTime)
        {
            dwNextJobTime = 0;
        }
        else
        {
            dwNextJobTime -= dwCurrentTime;
        }
    }

    return dwNextJobTime;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE CWorkObject* 
CWorkManager::GetNextJobInMemoryQueue(
    PDWORD pdwTime
    )
/*++

Abstract:

    Class private, return pointer to next scheduled 
    in memory job.

Parameter:

    pdwTime : Pointer to DWORD to receive time to the 
              scheduled job.

Returns:

    Pointer to CWorkObject.

Note:

    Remove the job from queue if job is <= time.

--*/
{
    SCHEDULEJOBMAP::iterator it;
    DWORD dwWantedJobTime;
    CWorkObject* ptr = NULL;

    SetLastError(ERROR_SUCCESS);

    if(pdwTime != NULL)
    {
        dwWantedJobTime = *pdwTime;
        m_JobLock.Acquire(READER_LOCK);

        it = m_Jobs.begin();
        if(it != m_Jobs.end())
        {
            *pdwTime = (*it).first;

            if(dwWantedJobTime >= *pdwTime)
            {
                ptr = (*it).second;

                // remove job from queue
                m_Jobs.erase(it);
            }
        }
        m_JobLock.Release(READER_LOCK);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return ptr;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE void
CWorkManager::DeleteAllJobsInMemoryQueue()
/*++

Abstract:

    Class private, unconditionally delete all in-memory job.

Parameter:

    None.

Return:

    None.

--*/
{
    m_JobLock.Acquire(WRITER_LOCK);

    SCHEDULEJOBMAP::iterator it;

    for(it = m_Jobs.begin(); it != m_Jobs.end(); it++)
    {
        try {
            //
            // let calling routine to delete it
            //
            (*it).second->EndJob();
            if((*it).second->CanBeDelete() == TRUE)
            {
                (*it).second->SelfDestruct();
            }
            (*it).second = NULL;
        }
        catch(...) {
        }
    }

    m_Jobs.erase(m_Jobs.begin(), m_Jobs.end());
    m_JobLock.Release(WRITER_LOCK);
    return;
}

//----------------------------------------------------------------
//
CLASS_PRIVATE BOOL
CWorkManager::RemoveJobFromInMemoryQueue(
    IN DWORD ulTime,
    IN CWorkObject* ptr
    )
/*++

Abstract:

    Class private, remove a scheduled job.

Parameters:

    ulTime : Job scheduled time.
    ptr : Pointer to Job to be deleted.

Returns:

    TRUE/FALSE.

Note:

    A job might be scheduled multiple time so we
    need to pass in the time.

--*/
{
    BOOL bSuccess = FALSE;

    m_JobLock.Acquire(WRITER_LOCK);

    SCHEDULEJOBMAP::iterator low = m_Jobs.lower_bound(ulTime);
    SCHEDULEJOBMAP::iterator high = m_Jobs.upper_bound(ulTime);

    for(;low != m_Jobs.end() && low != high; low++)
    {
        if( (*low).second == ptr )
        {
            //
            // let calling routine to delete it
            //
            (*low).second = NULL;
            m_Jobs.erase(low);
            bSuccess = TRUE;
            break;
        }
    }

    if(bSuccess == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
    }

    m_JobLock.Release(WRITER_LOCK);
         
    return bSuccess;
}
//----------------------------------------------------------------
//
CLASS_PRIVATE DWORD
CWorkManager::AddJobIntoMemoryQueue(
    IN DWORD dwTime,            // suggested scheduled time
    IN CWorkObject* pJob        // Job to be scheduled
    )
/*++

Abstract:

    Class private, add a job into in-memory list.

Parameters:

    dwTime : suggested scheduled time.
    pJob : Pointer to job to be added.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = FALSE;
    DWORD dwJobScheduleTime = time(NULL) + dwTime;

    if(IsShuttingDown() == TRUE)
    {
        dwStatus = TLS_I_WORKMANAGER_SHUTDOWN;
        return dwStatus;
    }

    m_JobLock.Acquire(WRITER_LOCK);

    try {
        //
        // insert a job into our queue
        //
        m_Jobs.insert( SCHEDULEJOBMAP::value_type( dwJobScheduleTime, pJob ) );
        AddJobUpdateInMemoryJobWaitTimer(dwJobScheduleTime);
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();
    }
    catch(...)
    {
        // need to reset to tlserver error code
        dwStatus = TLS_E_WORKMANAGER_INTERNAL;
    }
    
    m_JobLock.Release(WRITER_LOCK);
    return dwStatus;
}   
        
//----------------------------------------------------------------
//
DWORD
CWorkManager::ScheduleJob(
    IN DWORD ulTime,            // suggested scheduled time
    IN CWorkObject* pJob        // Job to be scheduled
    )

/*++

Abstract:

    Schedule a job at time relative to current time

Parameters:
    
    ulTime : suggested scheduled time.
    pJob : Pointer to job to be scheduled

Returns:

    ERROR_SUCCESS or error code.

--*/

{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pJob == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(IsShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CWorkManager::ScheduleJob() : schedule job <%s> to queue at time %d\n"),
            pJob->GetJobDescription(),
            ulTime
        );

    pJob->SetProcessingWorkManager(this);

    if(ulTime == INFINITE && pJob->IsWorkPersistent() == FALSE)
    {
        //
        // Only in-memory job can be executed at once.
        //
        dwStatus = RunJob(pJob, TRUE);
    }
    else 
    {
        if(pJob->IsWorkPersistent() == TRUE)
        {
            if(m_pPersistentWorkStorage->AddJob(ulTime, pJob) == FALSE)
            {
                dwStatus = TLS_E_WORKMANAGER_PERSISTENJOB;
            }                
        }
        else
        {
            //
            // insert a workobject into job queue, reason not to
            // use RegisterWaitForSingleObject() or threadpool's timer
            // is that we don't need to track handle nor wait for 
            // DeleteTimerXXX to finish
            //
            dwStatus = AddJobIntoMemoryQueue(
                                        ulTime, // Memory queue is absolute time
                                        pJob
                                    );
        }

        if(dwStatus == ERROR_SUCCESS)
        {
            if(SignalJobArrive() == FALSE)
            {
                dwStatus = GetLastError();
                TLSASSERT(FALSE);
            }
        }
    }

cleanup:

    return dwStatus;
}


///////////////////////////////////////////////////////////////
//
// CWorkObject base class
//
CWorkObject::CWorkObject(
    IN BOOL bDestructorDelete /* = FALSE */
    ) : 
m_dwLastRunStatus(ERROR_SUCCESS),
m_refCount(0),
m_pWkMgr(NULL),
m_bCanBeFree(bDestructorDelete)
{
}

//----------------------------------------------------------
DWORD
CWorkObject::Init(
    IN BOOL bDestructorDelete  /* = FALSE */
    )
/*++

Abstract:

    Initialize a work object.

Parameter:

    bDestructorDelete : TRUE if destructor should delete the memory,
                        FALSE otherwise.

Returns:

    ERROR_SUCCESS or error code.

Note:

    if bDestructorDelete is FALSE, memory will not be free.

--*/
{
    m_dwLastRunStatus = ERROR_SUCCESS;
    m_refCount = 0;
    m_bCanBeFree = bDestructorDelete;
    return ERROR_SUCCESS;
} 

//----------------------------------------------------------
CLASS_PRIVATE long
CWorkObject::GetReferenceCount() 
/*++

Abstract:

    Return reference count of work object.

Parameter:

    None.

Return:

    Reference count.

--*/
{
    return m_refCount;
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::IncrementRefCount()
/*++

Abstract:

    Increment object's reference counter.

Parameter:

    None.

Return:

    None.

--*/
{
    InterlockedIncrement(&m_refCount); 
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::DecrementRefCount() 
/*++

Abstract:

    Decrement object's reference counter.

Parameter:

    None.

Return:

    None.

--*/
{ 
    InterlockedDecrement(&m_refCount); 
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::ExecuteWorkObject() 
/*++

Abstract:

    Execute a work object.  Work manager invoke work object's
    ExecuteWorkObject so that base class can set its reference 
    counter.

Parameter:

    None.

Return:

    None.

--*/
{
    if(IsValid() == TRUE)
    {
        IncrementRefCount();
        m_dwLastRunStatus = Execute();
        DecrementRefCount(); 
    }
    else
    {
        m_dwLastRunStatus = ERROR_INVALID_DATA;
        TLSASSERT(FALSE);
    }
}

//----------------------------------------------------------
CLASS_PRIVATE void
CWorkObject::EndExecuteWorkObject() 
/*++

Abstract:

    End a job, this does not terminate job currently in 
    processing, it remove the job from work manager's in-processing
    list

Parameter:

    None.

Return:

    None.    

--*/
{
    TLSASSERT(IsValid() == TRUE);
    m_pWkMgr->EndProcessingScheduledJob(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\kp.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kp.cpp
//
// Contents:    
//              Contains wrapper call to deal with concepture 
//              license key pack table, this includes LicPack, LicPackStatus,
//              and LicPackDesc table.
//
// History:     
//          04/16/98      HueiWang        Created.
//---------------------------------------------------------------------------

#include "pch.cpp"
#include "kp.h"
#include "globals.h"
#include "server.h"
#include "lkplite.h"
#include "keypack.h"
#include "lkpdesc.h"
#include "misc.h"
#include "permlic.h"


//++-------------------------------------------------------------------------------
BOOL 
ValidLicenseKeyPackParameter(
    IN LPLSKeyPack lpKeyPack, 
    IN BOOL bAdd
    )
/*++

Abtract:

    Validate a LSKeyPack value.

Parameter:

    lpKeyPack - keypack value to be validated,
    bAdd - TRUE if this value is to be inserted into table, FALSE otherwise, note
           if value is to be inserted into table, it require more parameters.

Return:

    TRUE if valid LSKeyPack value, FALSE otherwise.

++*/
{
    BOOL bValid=FALSE;

    do {
        // verify input parameter
        if((lpKeyPack->ucKeyPackType & ~LSKEYPACK_RESERVED_TYPE) < LSKEYPACKTYPE_FIRST || 
           (lpKeyPack->ucKeyPackType & ~LSKEYPACK_RESERVED_TYPE) > LSKEYPACKTYPE_LAST)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid key pack type - %d\n"), 
                    lpKeyPack->ucKeyPackType
                );
            break;
        }

        UCHAR ucKeyPackStatus = lpKeyPack->ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED;

        if((ucKeyPackStatus < LSKEYPACKSTATUS_FIRST || 
            ucKeyPackStatus > LSKEYPACKSTATUS_LAST) &&
            ucKeyPackStatus != LSKEYPACKSTATUS_DELETE)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid key pack status - %d\n"), 
                    lpKeyPack->ucKeyPackStatus
                );
            break;
        }

        if(lpKeyPack->ucLicenseType < LSKEYPACKLICENSETYPE_FIRST || 
           lpKeyPack->ucLicenseType > LSKEYPACKLICENSETYPE_LAST)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid license type - %d\n"), 
                    lpKeyPack->ucLicenseType
                );
            break;
        }

        if(!bAdd)
        {
            bValid = TRUE;
            break;
        }

        if(lpKeyPack->ucChannelOfPurchase < LSKEYPACKCHANNELOFPURCHASE_FIRST ||
           lpKeyPack->ucChannelOfPurchase > LSKEYPACKCHANNELOFPURCHASE_LAST)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid channel of purchase - %d\n"), 
                    lpKeyPack->ucChannelOfPurchase
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szCompanyName))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid company name\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szKeyPackId))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid key pack id\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szProductName))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid product name\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szProductId))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid product id\n")
                );
            break;
        }

        if(!_tcslen(lpKeyPack->szProductDesc))
        {
            // set product desc = product name
            _tcscpy(lpKeyPack->szProductDesc, lpKeyPack->szProductName);
        }

        if(!_tcslen(lpKeyPack->szBeginSerialNumber))
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("ValidLicenseKeyPackParameter : invalid serial number\n")
                );
            break;
        }

        bValid=TRUE;
    } while(FALSE);
 
    return bValid;
}


//++----------------------------------------------------------------------
DWORD
TLSDBLicenseKeyPackAdd( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPLSKeyPack lpLsKeyPack 
    )
/*++

Abstract:

    Add an entry into concepture keypack table, this includes LicPack, 
    LicPackStatus, and LicPackDesc table.

Parameter:

    pDbWkSpace : workspace handle.
    lpLsKeyPack : license key pack to be added into table.

Returns: 

++*/
{
    DWORD   dwStatus;
    TLSLICENSEPACK LicPack;
    LICPACKDESC LicPackDesc;

    if(!ValidLicenseKeyPackParameter(lpLsKeyPack, TRUE))
        return TLS_E_INVALID_DATA;

    TLSDBLockKeyPackTable();
    TLSDBLockKeyPackDescTable();

    do {
        if(ConvertLsKeyPackToKeyPack(
                            lpLsKeyPack,    
                            &LicPack, 
                            &LicPackDesc
                        ) == FALSE)
        {
            dwStatus = GetLastError();
            break;
        }

        //
        // Add license server info into TLSLICENSEPACK
        //
        //LicPack.pbDomainSid = g_pbDomainSid;
        //LicPack.cbDomainSid = g_cbDomainSid;

        _tcscpy(LicPack.szInstallId, (LPTSTR)g_pszServerPid);
        _tcscpy(LicPack.szTlsServerName, g_szComputerName);

        //
        // No domain name at this time
        //
        memset(LicPack.szDomainName, 0, sizeof(LicPack.szDomainName));


        if(lpLsKeyPack->ucKeyPackStatus != LSKEYPACKSTATUS_ADD_DESC)
        {
            dwStatus = TLSDBKeyPackAdd(pDbWkSpace, &LicPack);
            if(dwStatus != ERROR_SUCCESS)
            {
                // this is global memory, destructor will try to free it.
                LicPack.pbDomainSid = NULL;
                LicPack.cbDomainSid = 0;
                break;
            }
        }

        LicPack.pbDomainSid = NULL;
        LicPack.cbDomainSid = 0;

        //
        // Make sure keypack got inserted
        //
        dwStatus = TLSDBKeyPackEnumBegin( 
                                    pDbWkSpace, 
                                    TRUE, 
                                    LSKEYPACK_EXSEARCH_DWINTERNAL, 
                                    &LicPack 
                                );
        if(dwStatus != ERROR_SUCCESS)
            break;

        dwStatus = TLSDBKeyPackEnumNext(
                                pDbWkSpace, 
                                &LicPack
                            );

        TLSDBKeyPackEnumEnd(pDbWkSpace);

        if(dwStatus != ERROR_SUCCESS)
            break;

        LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;

        //
        // Add keypack description into keypack desc
        //
        dwStatus = TLSDBKeyPackDescAddEntry(
                                    pDbWkSpace, 
                                    &LicPackDesc
                                );

        ConvertKeyPackToLsKeyPack(
                            &LicPack, 
                            &LicPackDesc, 
                            lpLsKeyPack
                        );
    } while(FALSE);

    TLSDBUnlockKeyPackDescTable();
    TLSDBUnlockKeyPackTable();
    return dwStatus;
}

//++-----------------------------------------------------------------------
DWORD
TLSDBLicenseKeyPackSetStatus( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD       dwSetStatus,
    IN LPLSKeyPack  lpLsKeyPack
    )
/*++

Abstract:

    Set the status of Licensed KeyPack.

Parameter:

    pDbWkSpace - workspace handle.
    dwSetStatus - type of status to be set.
    lpLsKeyPack - record/value to be set.

Returns:

++*/
{
    TLSLICENSEPACK LicPack;
    
    //
    // Status of keypack is in KeyPack table
    //
    if(ConvertLsKeyPackToKeyPack(
                        lpLsKeyPack, 
                        &LicPack, 
                        NULL
                    ) == FALSE)
    {
        return GetLastError();
    }

    return TLSDBKeyPackSetValues(pDbWkSpace, FALSE, dwSetStatus, &LicPack);
}

//++---------------------------------------------------------------------
DWORD
TLSDBLicenseKeyPackUpdateLicenses( 
    PTLSDbWorkSpace pDbWkSpace, 
    BOOL bAdd, 
    IN LPLSKeyPack lpLsKeyPack 
    )
/*++
    
Abstract:

    Add/Remove license from a keypack.

Parameter:

    pDbWkSpace - workspace handle.
    bAdd - TRUE if add entry into table, FALSE otherwise.
    lpLsKeyPack - 

Returns:

++*/
{
    DWORD dwStatus;
    TLSLICENSEPACK LicPack;

    //
    // Redirect call to KeyPack Table, not thing in KeyPackDesc can be updated.
    //
    if(ConvertLsKeyPackToKeyPack(
                        lpLsKeyPack, 
                        &LicPack, 
                        NULL
                    ) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    dwStatus=TLSDBKeyPackUpdateNumOfAvailableLicense(
                            pDbWkSpace, 
                            bAdd, 
                            &LicPack
                        );

    //
    // return new value back to caller
    //
    ConvertKeyPackToLsKeyPack( 
                        &LicPack, 
                        NULL, 
                        lpLsKeyPack 
                    );

cleanup:
    return dwStatus;
}

//++---------------------------------------------------------------------
LPENUMHANDLE 
TLSDBLicenseKeyPackEnumBegin(
    BOOL bMatchAll, 
    DWORD dwSearchParm, 
    LPLSKeyPack lpLsKeyPack
    )
/*++

Abstract:

    Begin enumeration of concepture License Key Pack table.

Parameter:

    bMatchAll - TRUE if match all search value, FALSE otherwise.
    dwSearchParm - Field to be included in search.
    lpLsKeyPack - KeyPack value to search.
    
Returns:


++*/
{
    DWORD dwStatus;
    LPENUMHANDLE hEnum=NULL;
    TLSLICENSEPACK licpack;

    licpack.pbDomainSid = NULL;

    hEnum = new ENUMHANDLE;
    if(hEnum == NULL)
        return NULL;

    hEnum->pbWorkSpace=AllocateWorkSpace(g_EnumDbTimeout);
    if(hEnum->pbWorkSpace == NULL)
    {
        SetLastError(TLS_E_ALLOCATE_HANDLE);
        TLSDBLicenseKeyPackEnumEnd(hEnum);
        return NULL;
    }

    memset(&hEnum->CurrentKeyPack, 0, sizeof(hEnum->CurrentKeyPack));
    memset(&hEnum->KPDescSearchValue, 0, sizeof(hEnum->KPDescSearchValue));
    hEnum->dwKPDescSearchParm = 0;

    if(ConvertLsKeyPackToKeyPack(
                        lpLsKeyPack, 
                        &licpack, 
                        &hEnum->KPDescSearchValue
                    ) == FALSE)
    {
        TLSDBLicenseKeyPackEnumEnd(hEnum);
        return NULL;
    }

    //
    // establish KeyPack enumeration
    dwStatus = TLSDBKeyPackEnumBegin(
                                hEnum->pbWorkSpace, 
                                bMatchAll, 
                                dwSearchParm, 
                                &licpack
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        SetLastError(dwStatus);
        TLSDBLicenseKeyPackEnumEnd(hEnum);
        return NULL;
    }


    //
    // Store keypack desc search value
    //
    if(dwSearchParm & LSKEYPACK_SEARCH_LANGID)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_LANGID;
    
    if(dwSearchParm & LSKEYPACK_SEARCH_COMPANYNAME)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_COMPANYNAME;

    if(dwSearchParm & LSKEYPACK_SEARCH_PRODUCTNAME)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTNAME;

    if(dwSearchParm & LSKEYPACK_SEARCH_PRODUCTDESC)
        hEnum->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTDESC;

    hEnum->bKPDescMatchAll=bMatchAll;
    hEnum->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACK;
    return hEnum;
}

//++----------------------------------------------------------------------
DWORD 
TLSDBLicenseKeyPackEnumNext(
    LPENUMHANDLE lpEnumHandle, 
    LPLSKeyPack lpLsKeyPack,
    BOOL bShowAll
    )
/*++

Abstract:

    Fetch next combined LicPack, LicPackStatus, and LicPackDesc record that
    match search condiftion.

Parameter:

    lpEnumHandle - enumeration handle return by TLSDBLicenseKeyPackEnumBegin().
    lpLsKeyPack - return value found.
    bShowAll - return all keypack

Returns:


Note:
    Caller need to discard return value and call TLSDBLicenseKeyPackEnumNext() 
    again when this function return TLS_I_MORE_DATA, this is to prevent 
    stack overflow in recursive call.

++*/
{
    //
    // No recursive call to prevent stack overflow
    // 

    DWORD dwStatus;

    switch(lpEnumHandle->chFetchState)
    {
        case ENUMHANDLE::FETCH_NEXT_KEYPACK:

            //
            // Retrieve next row in keypack
            dwStatus=TLSDBKeyPackEnumNext(
                                lpEnumHandle->pbWorkSpace, 
                                &lpEnumHandle->CurrentKeyPack
                            );
            if(dwStatus != ERROR_SUCCESS)
                break;

            if(bShowAll == FALSE)
            {

                //
                // Never return keypack that is solely for issuing certificate to 
                // Hydra Server
                if(_tcsicmp(lpEnumHandle->CurrentKeyPack.szKeyPackId, 
                            HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID) == 0 &&
                   _tcsicmp(lpEnumHandle->CurrentKeyPack.szProductId, 
                            HYDRAPRODUCT_HS_CERTIFICATE_SKU) == 0)
                {
                    //
                    // Prevent infinite recursive call, let calling routine handle this
                    return TLS_I_MORE_DATA;
                }

                //
                // Do not show remote key pack
                //
                if( lpEnumHandle->CurrentKeyPack.ucAgreementType & LSKEYPACK_REMOTE_TYPE)
                {
                    return TLS_I_MORE_DATA;
                }

                if( lpEnumHandle->CurrentKeyPack.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
                {
                    return TLS_I_MORE_DATA;
                }

                lpEnumHandle->CurrentKeyPack.ucAgreementType &= ~LSKEYPACK_RESERVED_TYPE;
                lpEnumHandle->CurrentKeyPack.ucKeyPackStatus &= ~LSKEYPACKSTATUS_RESERVED;
            }

            //
            // Fetch KeyPackDesc table
            //
            lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEW_KEYPACKDESC;
           
            // 
            // FALL THRU.
            //

        case ENUMHANDLE::FETCH_NEW_KEYPACKDESC:
            //
            // retrieve new keypackdesc that match up with keypack
            lpEnumHandle->KPDescSearchValue.dwKeyPackId = lpEnumHandle->CurrentKeyPack.dwKeyPackId;
            lpEnumHandle->dwKPDescSearchParm |= LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID;
            // lpEnumHandle->pbWorkSpace->Cleanup();

            //
            // First issue a query to see if product has matching language ID
            LICPACKDESC kpDesc;

            memset(&kpDesc, 0, sizeof(LICPACKDESC));
            kpDesc = lpEnumHandle->KPDescSearchValue;
            dwStatus = TLSDBKeyPackDescFind(
                                        lpEnumHandle->pbWorkSpace, 
                                        TRUE,
                                        lpEnumHandle->dwKPDescSearchParm, 
                                        &kpDesc,
                                        NULL
                                    );

            if(dwStatus == TLS_E_RECORD_NOTFOUND)
            {
                //
                // Show description in English
                kpDesc.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

                dwStatus = TLSDBKeyPackDescFind(
                                            lpEnumHandle->pbWorkSpace, 
                                            TRUE,
                                            lpEnumHandle->dwKPDescSearchParm, 
                                            &kpDesc,
                                            NULL
                                        );

                if(dwStatus == TLS_E_RECORD_NOTFOUND)
                {
                    //
                    // No product description for this lanuage ID and english
                    //
                    _tcscpy(kpDesc.szCompanyName, lpEnumHandle->CurrentKeyPack.szCompanyName);
                    _tcscpy(kpDesc.szProductName, lpEnumHandle->CurrentKeyPack.szProductId);
                    _tcscpy(kpDesc.szProductDesc, lpEnumHandle->CurrentKeyPack.szProductId);
        
                    ConvertKeyPackToLsKeyPack(
                                        &lpEnumHandle->CurrentKeyPack, 
                                        &kpDesc, 
                                        lpLsKeyPack
                                    );

                    dwStatus = ERROR_SUCCESS;
                    lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACK;
                    break;
                }
            }

            dwStatus = TLSDBKeyPackDescEnumBegin(
                                        lpEnumHandle->pbWorkSpace, 
                                        lpEnumHandle->bKPDescMatchAll,
                                        lpEnumHandle->dwKPDescSearchParm,
                                        &kpDesc
                                    );

                
            if(dwStatus != ERROR_SUCCESS)
                break;

            lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACKDESC;

            //
            // FALL THRU
            //

        case ENUMHANDLE::FETCH_NEXT_KEYPACKDESC:
            {
                LICPACKDESC licpackdesc;
                dwStatus = TLSDBKeyPackDescEnumNext(
                                            lpEnumHandle->pbWorkSpace, 
                                            &licpackdesc
                                        );
                if(dwStatus == ERROR_SUCCESS)
                {
                    ConvertKeyPackToLsKeyPack(
                                        &lpEnumHandle->CurrentKeyPack, 
                                        &licpackdesc, 
                                        lpLsKeyPack
                                    );
                }
                else if(dwStatus == TLS_I_NO_MORE_DATA)
                {
                    lpEnumHandle->chFetchState=ENUMHANDLE::FETCH_NEXT_KEYPACK;
                    
                    //
                    // Set the status to MORE DATA 
                    //
                    dwStatus = TLS_I_MORE_DATA;
                    
                    // terminate enumeration for keypack description table
                    TLSDBKeyPackDescEnumEnd(lpEnumHandle->pbWorkSpace);                    
                } 
            }
            break;
    }

    return dwStatus;
}

//++------------------------------------------------------------------
DWORD 
TLSDBLicenseKeyPackEnumEnd(
    LPENUMHANDLE lpEnumHandle
    )
/*++

Abstract:

    End enumeration of concepture license key pack table.

Parameter;

    lpEnumHandle - enumeration handle return by TLSDBLicenseKeyPackEnumBegin().

Returns:

++*/
{
    if(lpEnumHandle)
    {
        if(lpEnumHandle->pbWorkSpace)
        {
            TLSDBKeyPackDescEnumEnd(lpEnumHandle->pbWorkSpace);
            TLSDBKeyPackEnumEnd(lpEnumHandle->pbWorkSpace);

            //FreeTlsLicensePack(&(lpEnumHandle->CurrentKeyPack));
            ReleaseWorkSpace(&(lpEnumHandle->pbWorkSpace));
        }
        delete lpEnumHandle;
    }

    return ERROR_SUCCESS;
}



//+--------------------------------------------------------------------

#define CH_PLATFORMID_OTHERS    3
#define CH_PLATFORMID_UPGRADE   2

BOOL
VerifyInternetLicensePack(
    License_KeyPack* pLicensePack
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;

    switch(pLicensePack->dwKeypackType)
    {
        case LICENSE_KEYPACK_TYPE_SELECT:
        case LICENSE_KEYPACK_TYPE_MOLP:
        case LICENSE_KEYPACK_TYPE_RETAIL:
            break;           
            
        default:
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_RPC,
                    DBG_FACILITY_KEYPACK,
                    _TEXT("LSDBRegisterLicenseKeyPack : invalid keypack type - %d\n"), 
                    pLicensePack->dwKeypackType
                );
            bSuccess = FALSE;
    }

    if(bSuccess == FALSE)
    {
        goto cleanup;
    }
    
    if(bSuccess == FALSE)
    {
        goto cleanup;
    }

    if(CompareFileTime(&pLicensePack->ActiveDate, &pLicensePack->ExpireDate) > 0)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : invalid activate date and expiration date\n")
            );
        bSuccess = FALSE;
        goto cleanup;
    }

    if(pLicensePack->pbProductId == NULL || pLicensePack->cbProductId == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : No product ID\n")
            );
        bSuccess = FALSE;
        goto cleanup;
    }

    if(pLicensePack->dwDescriptionCount == 0 || pLicensePack->pDescription == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : No product description\n")
            );
        bSuccess = FALSE;
        goto cleanup;
    }

    if(pLicensePack->cbManufacturer == 0 || pLicensePack->pbManufacturer == NULL)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBG_FACILITY_KEYPACK,
                _TEXT("LSDBRegisterLicenseKeyPack : No product manufacturer\n")
            );
        bSuccess = FALSE;
    }

cleanup:
    return bSuccess;
}

//----------------------------------------------------------------------
        
DWORD
ConvertInternetLicensePackToPMLicensePack(
    License_KeyPack* pLicensePack,
    PPMREGISTERLICENSEPACK ppmLicensePack
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    memset(ppmLicensePack, 0, sizeof(PMREGISTERLICENSEPACK));

    if(VerifyInternetLicensePack(pLicensePack) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    ppmLicensePack->SourceType = REGISTER_SOURCE_INTERNET;
    ppmLicensePack->dwKeyPackType = pLicensePack->dwKeypackType;

    ppmLicensePack->dwDistChannel = pLicensePack->dwDistChannel;
    ppmLicensePack->KeypackSerialNum = pLicensePack->KeypackSerialNum;
    ppmLicensePack->IssueDate = pLicensePack->IssueDate;
    ppmLicensePack->ActiveDate = pLicensePack->ActiveDate;
    ppmLicensePack->ExpireDate = pLicensePack->ExpireDate;
    ppmLicensePack->dwBeginSerialNum = pLicensePack->dwBeginSerialNum;
    ppmLicensePack->dwQuantity = pLicensePack->dwQuantity;
    memcpy(
            ppmLicensePack->szProductId,
            pLicensePack->pbProductId,
            min(sizeof(ppmLicensePack->szProductId) - sizeof(TCHAR), pLicensePack->cbProductId)
        );
                
    memcpy(
            ppmLicensePack->szCompanyName,
            pLicensePack->pbManufacturer,
            min(sizeof(ppmLicensePack->szCompanyName) - sizeof(TCHAR), pLicensePack->cbManufacturer)
        );

    ppmLicensePack->dwProductVersion = pLicensePack->dwProductVersion;
    ppmLicensePack->dwPlatformId = pLicensePack->dwPlatformId;
    ppmLicensePack->dwLicenseType = pLicensePack->dwLicenseType;
    ppmLicensePack->dwDescriptionCount = pLicensePack->dwDescriptionCount;

    if( pLicensePack->dwDescriptionCount != 0 )
    {
        ppmLicensePack->pDescription = (PPMREGISTERLKPDESC)AllocateMemory(sizeof(PMREGISTERLKPDESC) * ppmLicensePack->dwDescriptionCount);
        if(ppmLicensePack->pDescription != NULL)
        {
            for(DWORD dwIndex = 0; dwIndex < ppmLicensePack->dwDescriptionCount; dwIndex++)
            {
                ppmLicensePack->pDescription[dwIndex].Locale = pLicensePack->pDescription[dwIndex].Locale;

                memcpy(
                    ppmLicensePack->pDescription[dwIndex].szProductName,
                    pLicensePack->pDescription[dwIndex].pbProductName,
                    min(
                          sizeof(ppmLicensePack->pDescription[dwIndex].szProductName) - sizeof(TCHAR),
                            pLicensePack->pDescription[dwIndex].cbProductName
                        )
                );
                    
                memcpy(
                    ppmLicensePack->pDescription[dwIndex].szProductDesc,
                    pLicensePack->pDescription[dwIndex].pDescription,
                    min(
                          sizeof(ppmLicensePack->pDescription[dwIndex].szProductDesc) - sizeof(TCHAR),
                            pLicensePack->pDescription[dwIndex].cbDescription
                        )
                );
            }
        }
        else
        {
            SetLastError(dwStatus = ERROR_OUTOFMEMORY);
        }
    }

cleanup:
    return dwStatus;
}

//----------------------------------------------------------------------------
DWORD
TLSDBInstallKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN PPMLSKEYPACK ppmLsKeyPack,
    OUT LPLSKeyPack lpInstalledKeyPack
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LSKeyPack KeyPack;
    DWORD i;

    //
    // Policy module should leave product name/description in PPMREGISTERLKPDESC
    //
    memset(&KeyPack, 0, sizeof(LSKeyPack));
    KeyPack = ppmLsKeyPack->keypack;

    if (!FileTimeToLicenseDate(
            &ppmLsKeyPack->ActiveDate, 
            &KeyPack.dwActivateDate
            ))
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    if (!FileTimeToLicenseDate(
            &ppmLsKeyPack->ExpireDate, 
            &KeyPack.dwExpirationDate
            ))
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Add to KeyPack and KeyPackDesc Table.
    for(i=0; i < ppmLsKeyPack->dwDescriptionCount && dwStatus == ERROR_SUCCESS; i++)
    {
        KeyPack.ucKeyPackStatus = (i) ? LSKEYPACKSTATUS_ADD_DESC : LSKEYPACKSTATUS_ACTIVE;

        KeyPack.dwLanguageId = ppmLsKeyPack->pDescription[i].Locale;
        _tcscpy(
                KeyPack.szProductName, 
                ppmLsKeyPack->pDescription[i].szProductName
            );

        _tcscpy(
                KeyPack.szProductDesc, 
                ppmLsKeyPack->pDescription[i].szProductDesc
            );

        //  Todo:

        //
        //  This is a temporary workaround to Install Whistler CALs: If registry key is set,
        //  Keypack's minor version number is set to the data in DWORD Registry value, "Whistler".
        //

        HKEY hKey = NULL;
        DWORD dwBuffer = 0;
        DWORD cbBuffer = sizeof (DWORD);
        dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, WHISTLER_CAL, 0,
                                KEY_ALL_ACCESS, &hKey);

        if (dwStatus == ERROR_SUCCESS)
        {

            dwStatus = RegQueryValueEx(hKey, KP_VERSION_VALUE, NULL, NULL,
            (LPBYTE)&dwBuffer, &cbBuffer);

            if (dwStatus == ERROR_SUCCESS)
            {
                KeyPack.wMinorVersion = dwBuffer;

                _tcscpy(
                KeyPack.szProductName, L"MS Terminal Server 5.1");
                
                _tcscpy(
                KeyPack.szProductId, L"A02-5.01-S");

                _tcsncpy(
                KeyPack.szKeyPackId, L"1", 1);
               
                _tcscpy(
                KeyPack.szProductDesc, L"Windows Whistler Terminal Services Client Access License Token");
            }
            RegCloseKey(hKey);
        }


        dwStatus = TLSDBLicenseKeyPackAdd(pDbWkSpace, &KeyPack);
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        KeyPack.dwNumberOfLicenses = KeyPack.dwTotalLicenseInKeyPack;

        KeyPack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;

        if (!FileTimeToLicenseDate(
                &ppmLsKeyPack->ActiveDate, 
                &KeyPack.dwActivateDate
                ))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        if (!FileTimeToLicenseDate(
                &ppmLsKeyPack->ExpireDate, 
                &KeyPack.dwExpirationDate
                ))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        dwStatus=TLSDBLicenseKeyPackSetStatus(
                                    pDbWkSpace, 
                                    LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_EXPIREDATE | LSKEYPACK_EXSEARCH_AVAILABLE, 
                                    &KeyPack
                                );
    }        

    //
    // Post a ssync work object to all known server.
    //
    if(dwStatus == ERROR_SUCCESS)
    {
        *lpInstalledKeyPack = KeyPack;
    }

cleanup:

    return dwStatus;
}


DWORD
TLSDBRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN License_KeyPack* pLicenseKeyPack,
    OUT LPLSKeyPack lpInstalledKeyPack
    )
/*++

Abstract:

    Add a license keypack into database.

Parameter:

    pDbWkSpace : workspace handle.
    pLicenseKeyPack : Licensed key pack to be added.

Returns:
    
*/
{
    LSKeyPack KeyPack;
    long activeDate;
    long expireDate;
    DWORD dwStatus=ERROR_SUCCESS;
    PMREGISTERLICENSEPACK pmLicensePack;
    PMLSKEYPACK pmLsKeyPack;

    CTLSPolicy* pPolicy = NULL;
    PMHANDLE hClient = NULL;

    TCHAR szTlsProductCode[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szCHProductCode[LSERVER_MAX_STRING_SIZE+1];
    DWORD dwBufSize = LSERVER_MAX_STRING_SIZE + 1;

    DWORD i;

    dwStatus = ConvertInternetLicensePackToPMLicensePack(
                                        pLicenseKeyPack,
                                        &pmLicensePack
                                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }    

    lstrcpyn(
            szCHProductCode,
            pmLicensePack.szProductId,
            LSERVER_MAX_STRING_SIZE+1
        );

    if(TranslateCHCodeToTlsCode(
                            pmLicensePack.szCompanyName,
                            szCHProductCode,
                            szTlsProductCode,
                            &dwBufSize) == TRUE )
    {
        // if can't find a policy module to handle, use default.
        lstrcpyn(
                pmLicensePack.szProductId,
                szTlsProductCode,
                sizeof(pmLicensePack.szProductId)/sizeof(pmLicensePack.szProductId[0])
            );
    }
     
    // use default if necessary                       
    pPolicy = AcquirePolicyModule(
                            pmLicensePack.szCompanyName,
                            pmLicensePack.szProductId,
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    dwStatus = pPolicy->PMRegisterLicensePack(
                                        hClient,
                                        REGISTER_PROGRESS_NEW,
                                        (PVOID)&pmLicensePack,
                                        (PVOID)&pmLsKeyPack
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwStatus = TLSDBInstallKeyPack(
                            pDbWkSpace, 
                            &pmLsKeyPack,
                            lpInstalledKeyPack
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        TLSResetLogLowLicenseWarning(
                            pmLicensePack.szCompanyName,
                            pmLicensePack.szProductId,
                            pmLicensePack.dwProductVersion,
                            FALSE
                        );
    }

                            
cleanup:

    if(pPolicy != NULL && hClient != NULL)
    {
        pPolicy->PMRegisterLicensePack(
                                hClient,
                                REGISTER_PROGRESS_END,
                                UlongToPtr(dwStatus),
                                NULL
                            );

        ReleasePolicyModule(pPolicy);
    }

    if(pmLicensePack.pDescription != NULL)
    {
        FreeMemory(pmLicensePack.pDescription);
    }

    return dwStatus;
}

//+--------------------------------------------------------------------
//
// TermSrv specific code...
//
// PRODUCT_INFO_COMPANY_NAME is defined in license.h
//
#define LKP_VERSION_BASE            1
#define WINDOWS_VERSION_NT5         5
#define WINDOWS_VERSION_BASE        2000

DWORD
TLSDBTelephoneRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPTSTR pszPID,
    IN PBYTE pbLKP,
    IN DWORD cbLKP,
    OUT LPLSKeyPack lpInstalledKeyPack
    )
/*++

Abstract:

    Add a license keypack into database.

Parameter:

    pDbWkSpace : workspace handle.
    pLicenseKeyPack : Licensed key pack to be added.

Returns:
    
*/
{
    DWORD dwStatus;
    DWORD dwVerifyResult;
    DWORD dwQuantity;
    DWORD dwSerialNumber;
    DWORD dwExpirationMos;
    DWORD dwVersion;
    DWORD dwUpgrade;
    LSKeyPack keypack;
    DWORD dwProductVersion;

    PMKEYPACKDESCREQ kpDescReq;
    PPMKEYPACKDESC pKpDesc = NULL;
    CTLSPolicy* pPolicy=NULL;
    PMHANDLE hClient = NULL;
    DWORD dwProgramType;

    struct tm expire;
    time_t currentDate;
    time_t ExpirationDate;

    PMREGISTERLICENSEPACK pmLicensePack;
    PMLSKEYPACK pmLsKeyPack;
    LPTSTR pszLKP = NULL;

    TCHAR szTlsProductCode[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szCHProductCode[LSERVER_MAX_STRING_SIZE+1];
    DWORD dwBufSize = LSERVER_MAX_STRING_SIZE + 1;

    if(pDbWkSpace == NULL || pszPID == NULL || pbLKP == NULL || cbLKP == 0)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Make sure data passed in is NULL terminated, current LKP
    // is base 24 encoded string.
    //
    pszLKP = (LPTSTR)AllocateMemory( cbLKP + sizeof(TCHAR) );
    if(pszLKP == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    memcpy(
            pszLKP,
            pbLKP,
            cbLKP
        );
    //
    // Verify LKP
    //
    dwVerifyResult = LKPLITE_LKP_VALID;
    dwStatus = LKPLiteVerifyLKP(
                            pszPID,
                            pszLKP,
                            &dwVerifyResult
                        );

    if(dwStatus != ERROR_SUCCESS || dwVerifyResult != LKPLITE_LKP_VALID)
    {
        if(dwVerifyResult == LKPLITE_LKP_INVALID)
        {
            dwStatus = TLS_E_INVALID_LKP;
        }
        else if(dwVerifyResult == LKPLITE_LKP_INVALID_SIGN)
        {
            dwStatus = TLS_E_LKP_INVALID_SIGN;
        }

        goto cleanup;
    }

    //
    // Decode LKP
    //
    dwStatus = LKPLiteCrackLKP(
                            pszPID,
                            pszLKP,
                            szCHProductCode,
                            &dwQuantity,
                            &dwSerialNumber,
                            &dwExpirationMos,
                            &dwVersion,
                            &dwUpgrade,
                            &dwProgramType
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        dwStatus = TLS_E_DECODE_LKP;
        goto cleanup;
    }

    if(TranslateCHCodeToTlsCode(
                            PRODUCT_INFO_COMPANY_NAME,
                            szCHProductCode,
                            szTlsProductCode,
                            &dwBufSize) == FALSE )
    {
        // if can't find a policy module to handle, use default.
        lstrcpyn(
                szTlsProductCode,
                szCHProductCode,
                sizeof(szTlsProductCode)/sizeof(szTlsProductCode)
            );
    }

    //
    // Current LKP does not support 1) other company, 2)
    // only register with NT5 or later
    //
    pPolicy = AcquirePolicyModule(
                                PRODUCT_INFO_COMPANY_NAME,
                                szTlsProductCode,
                                TRUE
                            );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    memset(&keypack, 0, sizeof(keypack));


    memset(&pmLicensePack, 0, sizeof(pmLicensePack));
    pmLicensePack.SourceType = REGISTER_SOURCE_PHONE;

    switch(dwProgramType)
    {
        case LKPLITE_PROGRAM_SELECT:
            pmLicensePack.dwKeyPackType = LICENSE_KEYPACK_TYPE_SELECT;
            break;

        case LKPLITE_PROGRAM_MOLP:
            pmLicensePack.dwKeyPackType = LICENSE_KEYPACK_TYPE_MOLP;
            break;
        
        case LKPLITE_PROGRAM_RETAIL:
            pmLicensePack.dwKeyPackType = LICENSE_KEYPACK_TYPE_RETAIL;
            break;

        default:
            SetLastError(dwStatus = TLS_E_INVALID_DATA);
            goto cleanup;
    }

    pmLicensePack.dwDistChannel = LSKEYPACKCHANNELOFPURCHASE_RETAIL;
    GetSystemTimeAsFileTime(&pmLicensePack.IssueDate);
    pmLicensePack.ActiveDate = pmLicensePack.IssueDate;

    currentDate = time(NULL);
    expire = *gmtime( (time_t *)&currentDate );
    expire.tm_mon += dwExpirationMos;
    ExpirationDate = mktime(&expire);

    if(ExpirationDate == (time_t) -1)
    {
        //
        // expiration month is too big, 
        // set it to 2038/1/1
        //
        memset(&expire, 0, sizeof(expire));

        expire.tm_year = 2038 - 1900;
        expire.tm_mon = 0;
        expire.tm_mday = 1;

        ExpirationDate = mktime(&expire);
    }

    if(ExpirationDate == (time_t) -1)
    {
        //
        // invalid time
        //
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    UnixTimeToFileTime(ExpirationDate, &pmLicensePack.ExpireDate);   

    //
    // dwSerialNumber is license pack serial number not begin 
    // serial number in license pack.
    //
    pmLicensePack.KeypackSerialNum.Data1 = dwSerialNumber;

    //
    // Tel. registration does not have any info regarding
    // begin serial number in license pack.
    //
    pmLicensePack.dwBeginSerialNum = 0;
    pmLicensePack.dwQuantity = dwQuantity;
    _tcscpy(pmLicensePack.szProductId, szTlsProductCode);
    _tcscpy(pmLicensePack.szCompanyName, PRODUCT_INFO_COMPANY_NAME);
    if(dwVersion == 1)
    {
        pmLicensePack.dwProductVersion = MAKELONG(0, WINDOWS_VERSION_NT5);
    }
    else
    {           
        DWORD dwMajorVer = (dwVersion >> 3); 
        
        // Right most 3 bits represent Minor version and stored in LOBYTE(LOWORD)
        pmLicensePack.dwProductVersion = (DWORD)(dwVersion & 07);

        // 4 bits starting at 6th position represent Major version and stored in LOBYTE(HIWORD)
        pmLicensePack.dwProductVersion |= (DWORD)(dwMajorVer << 16);
    }

    pmLicensePack.dwPlatformId = dwUpgrade;
    pmLicensePack.dwLicenseType = LSKEYPACKLICENSETYPE_UNKNOWN;
    pmLicensePack.pbLKP = pbLKP;
    pmLicensePack.cbLKP = cbLKP;

    hClient = GenerateClientId();
    dwStatus = pPolicy->PMRegisterLicensePack(
                                        hClient,
                                        REGISTER_PROGRESS_NEW,
                                        (PVOID)&pmLicensePack,
                                        (PVOID)&pmLsKeyPack
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    dwStatus = TLSDBInstallKeyPack(
                            pDbWkSpace, 
                            &pmLsKeyPack,
                            lpInstalledKeyPack
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        TLSResetLogLowLicenseWarning(
                            pmLicensePack.szCompanyName,
                            pmLicensePack.szProductId,
                            pmLicensePack.dwProductVersion,
                            FALSE
                        );
    }

cleanup:

    FreeMemory(pszLKP);

    //
    // Close policy module
    //
    if(pPolicy != NULL && hClient != NULL)
    {
        pPolicy->PMRegisterLicensePack(
                                hClient,
                                REGISTER_PROGRESS_END,
                                UlongToPtr(dwStatus),
                                NULL
                            );

        ReleasePolicyModule(pPolicy);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\kp.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        kp.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __KP_H__
#define __KP_H__
#include "server.h"

#define WHISTLER_CAL                    L"SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters"
#define KP_VERSION_VALUE                L"Whistler"


#ifdef __cplusplus
extern "C" {
#endif

BOOL 
ValidLicenseKeyPackParameter(
    IN LPLSKeyPack lpKeyPack, 
    IN BOOL bAdd
);

DWORD
TLSDBLicenseKeyPackAdd( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPLSKeyPack lpLsKeyPack 
);

DWORD
TLSDBLicenseKeyPackSetStatus( 
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN DWORD       dwSetStatus,
    IN LPLSKeyPack  lpLsKeyPack
);

DWORD
TLSDBLicenseKeyPackUpdateLicenses( 
    PTLSDbWorkSpace pDbWkSpace, 
    BOOL bAdd, 
    IN LPLSKeyPack lpLsKeyPack 
);

LPENUMHANDLE 
TLSDBLicenseKeyPackEnumBegin(
    BOOL bMatchAll, 
    DWORD dwSearchParm, 
    LPLSKeyPack lpLsKeyPack
);

DWORD 
TLSDBLicenseKeyPackEnumNext(
    LPENUMHANDLE lpEnumHandle, 
    LPLSKeyPack lpLsKeyPack,
    BOOL bShowAll
);

DWORD 
TLSDBLicenseKeyPackEnumEnd(
    LPENUMHANDLE lpEnumHandle
);

BOOL
VerifyInternetLicensePack(
    License_KeyPack* pLicensePack
);

DWORD
TLSDBRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN License_KeyPack* pLicenseKeyPack,
    OUT LPLSKeyPack lpInstalledKeyPack
);

DWORD
TLSDBTelephoneRegisterLicenseKeyPack(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN LPTSTR pszPID,
    IN PBYTE pbLKP,
    IN DWORD cbLKP,
    OUT LPLSKeyPack lpInstalledKeyPack
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\jobmgr.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        jobmgr.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __WORKMANAGER_H__
#define __WORKMANAGER_H__
#include <new.h>
#include <eh.h>

#include "tlsstl.h"
#include "dbgout.h"
#include "locks.h"
#include "tlsassrt.h"
#include "license.h"
#include "tlsapip.h"
#include "tlspol.h"

//
// Default cancel timeout is 5 seconds
//
#define DEFAULT_RPCCANCEL_TIMEOUT       5


//
// Default interval time is 15 mins.
//
#define DEFAULT_WORK_INTERVAL       15*60*1000

//
// Default shutdown wait time
//   
#define DEFAULT_SHUTDOWN_TIME       60*2*1000

//
// Max. Number of concurrent Jobs
//
#define DEFAULT_NUM_CONCURRENTJOB   50

//
// 
//
#define WORKMANAGER_TIMER_PERIOD_TIMER  0xFFFFFFFF  // see RtlUpdateTimer()
#define WORKMANAGER_WAIT_FOREVER        INFINITE

#define CLASS_PRIVATE
#define CLASS_STATIC

class CWorkManager;
class CWorkObject;


#ifdef __TEST_WORKMGR__
#define DBGCONSOLE          GetStdHandle(STD_OUTPUT_HANDLE)
#else
#define DBGCONSOLE          NULL        
#endif
     

//--------------------------------------------------------------
//
// Work Object initialization function, each work object 
// must supply its own initialization routine to work 
// manager.
//
typedef enum {
    JOBDURATION_UNKNOWN=0,
    JOBDURATION_RUNONCE,        // Run Once Work
    JOBDURATION_SESSION,        // Session Job
    JOBDURATION_PERSISTENT      // Persistent Job
} JOBDURATION;

#define JOB_SHORT_LIVE          0x00000001
#define JOB_INCLUDES_IO         0x00000002
#define JOB_LONG_RUNNING        0x00000004

#define WORK_TYPE_UNKNOWN    0x00000000

#ifndef AllocateMemory

    #define AllocateMemory(size) \
        LocalAlloc(LPTR, size)
#endif

#ifndef FreeMemory

    #define FreeMemory(ptr) \
        if(ptr)             \
        {                   \
            LocalFree(ptr); \
            ptr=NULL;       \
        }

#endif

#ifndef ReallocateMemory

    #define ReallocateMemory(ptr, size)                 \
                LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

//------------------------------------------------------
//
class MyCSemaphore {
private:

    HANDLE  m_semaphore;
    long   m_TryEntry;
    long   m_Acquired;
    long   m_Max;

public:
    MyCSemaphore() : m_semaphore(NULL), m_TryEntry(0), m_Acquired(0), m_Max(0) {}

    //--------------------------------------------------
    const long
    GetTryEntryCount() { return m_TryEntry; }

    //--------------------------------------------------
    const long
    GetAcquiredCount() { return m_Acquired; }

    //--------------------------------------------------
    const long
    GetMaxCount() { return m_Max; }

    
    //--------------------------------------------------
    BOOL
    Init(
        LONG lInitCount, 
        LONG lMaxCount 
        )
    /*++

    --*/
    {
        m_semaphore=CreateSemaphore(
                                NULL, 
                                lInitCount, 
                                lMaxCount, 
                                NULL
                            );

        m_Max = lMaxCount;
        m_TryEntry = 0;
        m_Acquired = 0;
        TLSASSERT(m_semaphore != NULL);
        return m_semaphore != NULL;
    }

    //--------------------------------------------------
    ~MyCSemaphore()
    {
        TLSASSERT(m_Acquired == 0);
        TLSASSERT(m_TryEntry == 0);

        if(m_semaphore)
        {
            CloseHandle(m_semaphore);
        }
    }

    //--------------------------------------------------
    BOOL
    AcquireEx(
        HANDLE hHandle,
        DWORD dwWaitTime=INFINITE,
        BOOL bAlertable=FALSE
        )
    /*++

    --*/
    {
        BOOL bSuccess = TRUE;
        DWORD dwStatus;
        HANDLE hHandles[] = {m_semaphore, hHandle};

        TLSASSERT(IsGood() == TRUE);

        if(hHandle == NULL || hHandle == INVALID_HANDLE_VALUE)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            bSuccess = FALSE;
        }
        else
        {
            InterlockedIncrement(&m_TryEntry);

            dwStatus = WaitForMultipleObjectsEx(
                                        sizeof(hHandles)/sizeof(hHandles[0]),
                                        hHandles,
                                        FALSE,
                                        dwWaitTime,
                                        bAlertable
                                    );

            if(dwStatus == WAIT_OBJECT_0)
            {
                InterlockedIncrement(&m_Acquired);
            }
            else
            {
                bSuccess = FALSE;
            }

            InterlockedDecrement(&m_TryEntry);
        }

        return bSuccess;
    }

    //--------------------------------------------------
    DWORD 
    Acquire(
        DWORD dwWaitTime=INFINITE, 
        BOOL bAlertable=FALSE
    )
    /*++

    --*/
    {
        DWORD dwStatus;

        TLSASSERT(IsGood() == TRUE);

        InterlockedIncrement(&m_TryEntry);

        dwStatus = WaitForSingleObjectEx(
                                m_semaphore, 
                                dwWaitTime, 
                                bAlertable
                            );

        if(dwStatus == WAIT_OBJECT_0)
        {
            InterlockedIncrement(&m_Acquired);
        }

        InterlockedDecrement(&m_TryEntry);
        return dwStatus;
    }

    //--------------------------------------------------
    BOOL 
    Release(
        long count=1
    )
    /*++

    --*/
    {
        BOOL bSuccess;

        TLSASSERT(IsGood() == TRUE);
        
        bSuccess = ReleaseSemaphore(
                                m_semaphore, 
                                count, 
                                NULL
                            );

        if(bSuccess == TRUE)
        {
            InterlockedDecrement(&m_Acquired);
        }

        return bSuccess;
    }

    //--------------------------------------------------
    BOOL 
    IsGood()
    /*++

    --*/
    {
        return m_semaphore != NULL;
    }

    //--------------------------------------------------
    const HANDLE 
    GetHandle() 
    {
        return m_semaphore;
    }
};


//-------------------------------------------------------------
// 
// Pure virtual base class for CWorkManager to store persistent
// work object.
//

typedef enum {
    ENDPROCESSINGJOB_RETURN=0,      // unable to process job, wait for next term.
    ENDPROCESSINGJOB_SUCCESS,       // job completed.
    ENDPROCESSINGJOB_ERROR          // error in processing this job
} ENDPROCESSINGJOB_CODE;


class CWorkStorage {
    friend class CWorkManager;

protected:
    CWorkManager* m_pWkMgr;

public:
    
    CWorkStorage(
        CWorkManager* pWkMgr=NULL
        ) : 
        m_pWkMgr(pWkMgr) {}

    ~CWorkStorage()   {}

    //---------------------------------------------------    
    CWorkManager*
    GetWorkManager() { 
        return m_pWkMgr; 
    }


    //---------------------------------------------------
    virtual BOOL
    Startup(
        IN CWorkManager* pWkMgr
        )
    /*++

    --*/
    {
        if(pWkMgr != NULL)
        {
            m_pWkMgr = pWkMgr;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        return pWkMgr != NULL;
    }

    //---------------------------------------------------
    virtual BOOL
    Shutdown() = 0;

    virtual BOOL
    AddJob(
        IN DWORD dwTime,        // relative to current time
        IN CWorkObject* ptr     // Pointer to work object
    ) = 0;

    //virtual BOOL
    //JobEnumBegin(
    //    DWORD dwLowScheduleTime=0,
    //    DWORD dwHighScheduleTime=0
    //) = 0;

    //
    // Return time to next job
    virtual DWORD
    GetNextJobTime() = 0;

    // 
    // return job to be processed next
    virtual CWorkObject*
    GetNextJob(PDWORD pdwTime) = 0;

    //
    // Inform storage that we are processing this job
    virtual BOOL
    BeginProcessingJob(
        IN CWorkObject* pJob
    ) = 0;

    // Inform storage that this job has completed
    virtual BOOL
    EndProcessingJob(
        IN ENDPROCESSINGJOB_CODE opCode,
        IN DWORD dwOriginalScheduledTime,
        IN CWorkObject* pJob
    ) = 0;

    //virtual BOOL
    //JobEnumEnd() = 0;

    virtual DWORD
    GetNumJobs() = 0;
};

//-------------------------------------------------------------
//
typedef struct _ScheduleJob {
    DWORD        m_ulScheduleTime;      // absolute time
    CWorkObject* m_pWorkObject;
} SCHEDULEJOB, *PSCHEDULEJOB, *LPSCHEDULEJOB;

inline bool 
operator<(
    const struct _ScheduleJob& a,
    const struct _ScheduleJob& b
    ) 
/*++

--*/
{
    return a.m_ulScheduleTime < b.m_ulScheduleTime; 
}

//-------------------------------------------------------------
//
// TODO : Re-design our in-memory job as a plugin like persistent
// Job.
//
//-------------------------------------------------------------

class CWorkManager {
    friend class CWorkObject;

private:

    typedef struct {
        BOOL bProcessInMemory;
        CWorkManager* pWorkMgr;
    } WorkManagerProcessContext, *PWorkManagerProcessContext;

    //
    // Schedule job might be at the same time, so use multimap
    // TODO : Need to move this into template.
    //
    // All in memory job schedule time are in absolute time
    //
    typedef multimap<DWORD, CWorkObject* > SCHEDULEJOBMAP;
    SCHEDULEJOBMAP  m_Jobs;                 // schedule jobs.
    CRWLock         m_JobLock;              // Schedule Job Lock

    typedef struct {
        long m_refCounter;
        HANDLE m_hThread;
    } WorkMangerInProcessJob;

    typedef map<PVOID, WorkMangerInProcessJob > INPROCESSINGJOBLIST;
    CCriticalSection     m_InProcessingListLock;
    INPROCESSINGJOBLIST m_InProcessingList;
    HANDLE          m_hJobInProcessing;     // signal if no job, non-signal
                                            // if job currently in process

    HANDLE          m_hWorkMgrThread;
    HANDLE          m_hNewJobArrive;
    HANDLE          m_hShutdown;            // shutdown timer.

    HANDLE          m_hInStorageWait;

    // relative time to next schedule job
    //CCriticalSection m_JobTimeLock;

    //CMyCounter      m_dwNextInStorageJobTime;
    //CMyCounter      m_dwNextInMemoryJobTime;

    CSafeCounter    m_dwNextInStorageJobTime;
    CSafeCounter    m_dwNextInMemoryJobTime;



    //DWORD           m_dwNextInMemoryJobTime;    // Absolute time.
    //DWORD           m_dwNextInStorageJobTime;   // Absolute time.

    long            m_NumJobInProcess;

    // 
    // Default interval to process job
    DWORD           m_dwDefaultInterval;    

    // Max. concurrent job, not use 
    DWORD           m_dwMaxCurrentJob;      
    MyCSemaphore    m_hMaxJobLock;

    CWorkStorage* m_pPersistentWorkStorage;

private:
    //-------------------------------------------------------------
    DWORD
    AddJobToProcessingList(
        CWorkObject* ptr
    );

    //-------------------------------------------------------------
    DWORD
    RemoveJobFromProcessingList(
        CWorkObject* ptr
    );
    
    //-------------------------------------------------------------
    DWORD
    ProcessScheduledJob();

    //-------------------------------------------------------------
    BOOL
    SignalJobArrive() { return SetEvent(m_hNewJobArrive); }

    //-------------------------------------------------------------
    BOOL
    WaitForObjectOrShutdown(
        HANDLE hHandle
    );

    //-------------------------------------------------------------
    DWORD
    RunJob(
        IN CWorkObject* ptr,
        IN BOOL bImmediate
    );

    //-------------------------------------------------------------
    void
    EndProcessingScheduledJob(
        IN CWorkObject* ptr
        )
    /*++


    --*/
    {
        RemoveJobFromProcessingList(ptr);
        return;
    }

    //-------------------------------------------------------------
    void
    DeleteAllJobsInMemoryQueue();

    //-------------------------------------------------------------
    void
    CancelInProcessingJob();

    //-------------------------------------------------------------
    BOOL
    SignalJobRunning(
        CWorkObject* ptr
    );

    //-------------------------------------------------------------
    CWorkObject*
    GetNextJobInMemoryQueue(
        PDWORD pulTime
    );

    //-------------------------------------------------------------
    BOOL
    RemoveJobFromInMemoryQueue(
        IN DWORD ulJobTime, 
        IN CWorkObject* ptr
    );

    //-------------------------------------------------------------
    DWORD
    AddJobIntoMemoryQueue(
        DWORD ulTime,
        CWorkObject* pWork
    );

    //-------------------------------------------------------------
    BOOL
    IsShuttingDown() 
    {
        if(m_hShutdown == NULL)
        {
            return TRUE;
        }

        return (WaitForSingleObject( m_hShutdown, 0 ) == WAIT_OBJECT_0);
    }

    //-------------------------------------------------------------
    static DWORD WINAPI
    ProcessInMemoryScheduledJob(PVOID);

    //-------------------------------------------------------------
    static DWORD WINAPI
    ProcessInStorageScheduledJob(PVOID);

    //-------------------------------------------------------------
    static unsigned int __stdcall
    WorkManagerThread(PVOID);

    //-------------------------------------------------------------
    static DWORD WINAPI
    ExecuteWorkObject(PVOID);

    //-------------------------------------------------------------
    DWORD
    GetTimeToNextJob();

    //-------------------------------------------------------------
    void
    AddJobUpdateInMemoryJobWaitTimer(
        DWORD dwJobTime
        )
    /*++

    --*/
    {
        //m_JobTimeLock.Lock();

        if((DWORD)m_dwNextInMemoryJobTime > dwJobTime)
        {
            m_dwNextInMemoryJobTime = dwJobTime;
        }

        //m_JobTimeLock.UnLock();
        return;
    }
            
    //-------------------------------------------------------------
    void
    AddJobUpdateInStorageJobWaitTimer(
        DWORD dwJobTime
        )
    /*++

    --*/
    {
        //m_JobTimeLock.Lock();

        if((DWORD)m_dwNextInStorageJobTime > dwJobTime)
        {
            m_dwNextInStorageJobTime = dwJobTime;
        }

        //m_JobTimeLock.UnLock();
        return;
    }

    //-------------------------------------------------------------
    BOOL
    UpdateTimeToNextPersistentJob() 
    /*++

    --*/
    {
        BOOL bSuccess = TRUE;

        //
        // Work Manager thread are processing storage job, don't
        // Update the storage job timer.
        //
        TLSASSERT(m_pPersistentWorkStorage != NULL);

        if(m_pPersistentWorkStorage->GetNumJobs() > 0)
        {
            m_dwNextInStorageJobTime = m_pPersistentWorkStorage->GetNextJobTime();
        }

        return bSuccess;
    }

    //------------------------------------------------------------
    BOOL
    UpdateTimeToNextInMemoryJob() 
    /*++

        Must have called m_JobTimeLock.Lock();
    
    --*/
    {
        BOOL bSuccess = TRUE;
        SCHEDULEJOBMAP::iterator it;

        m_JobLock.Acquire(READER_LOCK);

        it = m_Jobs.begin();
        if(it != m_Jobs.end())
        {
            m_dwNextInMemoryJobTime = (*it).first;
        }
        else
        {
            m_dwNextInMemoryJobTime = WORKMANAGER_WAIT_FOREVER;
        }

        m_JobLock.Release(READER_LOCK);
        return bSuccess;
    }

    //-------------------------------------------------------------
    DWORD
    TranslateJobRunningAttributeToThreadPoolFlag(
        DWORD dwJobAttribute
        )
    /*++

    --*/
    {
        DWORD dwThreadPoolFlag = 0;

        if(dwJobAttribute & JOB_LONG_RUNNING)
        {
            dwThreadPoolFlag |= WT_EXECUTELONGFUNCTION;
        }
        else if(dwJobAttribute & JOB_INCLUDES_IO)
        {
            dwThreadPoolFlag |= WT_EXECUTEINIOTHREAD;
        }
        else
        {
            dwThreadPoolFlag = WT_EXECUTEDEFAULT; // = 0
        }

        return dwThreadPoolFlag;
    }

public:

    //------------------------------------------------
    // 
    // Constructor, only initialize member variable, must
    // invokd Init()
    //
    CWorkManager();

    //------------------------------------------------
    // Destructor.
    ~CWorkManager();


    //------------------------------------------------
    //
    // Startup Work Manager.
    //
    DWORD
    Startup(
        IN CWorkStorage* pPersistentWorkStorage,
        IN DWORD dwInterval = DEFAULT_WORK_INTERVAL,
        IN DWORD dwMaxConcurrentJob=DEFAULT_NUM_CONCURRENTJOB
    );

    //------------------------------------------------
    //
    // Schedule a Job
    //
    DWORD
    ScheduleJob(
        IN DWORD dwTime,        // relative to current time.
        IN CWorkObject* pJob
    );

    //------------------------------------------------
    //
    // Shutdown WorkManager
    //
    void
    Shutdown();

    //------------------------------------------------
    //
    //
    inline DWORD
    GetNumberJobInMemoryQueue() {
        DWORD dwNumJob = 0;

        m_JobLock.Acquire(READER_LOCK);
        dwNumJob = m_Jobs.size();
        m_JobLock.Release(READER_LOCK);

        return dwNumJob;
    }

    //-------------------------------------------------------------
    inline DWORD
    GetNumberJobInStorageQueue() {
        return m_pPersistentWorkStorage->GetNumJobs();
    }

    //-------------------------------------------------------------
    DWORD
    GetNumberJobInProcessing()
    {
        DWORD dwNumJobs;

        m_InProcessingListLock.Lock();
        dwNumJobs = m_InProcessingList.size();
        m_InProcessingListLock.UnLock();

        return dwNumJobs;
    }

    //-------------------------------------------------------------
    DWORD
    GetTotalNumberJobInQueue()
    {
        return GetNumberJobInMemoryQueue() + GetNumberJobInStorageQueue();
    }

    //-------------------------------------------------------------
    #ifdef DBG
    void
    SuspendWorkManagerThread() {
        SuspendThread(m_hWorkMgrThread);
    };

    void
    ResumeWorkManagerThread() {
        ResumeThread(m_hWorkMgrThread);
    };
    #endif
};


//-------------------------------------------------------------

class CWorkObject {
    friend class CWorkManager;

private:
    CWorkManager* m_pWkMgr;
    long    m_refCount;             // reference counter
    DWORD   m_dwLastRunStatus;      // status from last Execute().
    BOOL    m_bCanBeFree;           // TRUE if work manager should call
                                    // SelfDestruct().

    DWORD   m_dwScheduledTime;      // time schedule to be processed by
                                    // work manager

    //
    // Private function invoke only by CWorkManager
    //
    long
    GetReferenceCount();

    void
    IncrementRefCount();

    void
    DecrementRefCount();

    void
    ExecuteWorkObject();

    void
    EndExecuteWorkObject();

    //------------------------------------------------------------
    // 
    virtual void
    SetScheduledTime(
        IN DWORD dwTime
        ) 
    /*++
    
    Abstract:

        Set original scheduled processing time, this is call by work manager

    Parameter:

        dwTime : absolute scheduled time in second

    Returns:

        None.

    --*/
    {
        m_dwScheduledTime = dwTime;
        return;
    }
        
protected:


    CWorkManager* 
    GetWorkManager() {
        return m_pWkMgr;
    }

    BOOL
    CanBeDelete() { 
        return m_bCanBeFree; 
    }

public:

    //------------------------------------------------------------
    //
    // Constructor
    //
    CWorkObject(
        IN BOOL bDestructorDelete = TRUE
    );

    //------------------------------------------------------------
    // 
    // Destructor
    //
    ~CWorkObject() 
    {
        Cleanup();
    }

    //------------------------------------------------------------
    // 
    BOOL
    IsWorkManagerShuttingDown()
    {
        return (m_pWkMgr != NULL) ? m_pWkMgr->IsShuttingDown() : TRUE;
    }

    //------------------------------------------------------------
    // TODO - quick fix, persistent storage can't assign this.
    void
    SetProcessingWorkManager(
        IN CWorkManager* pWkMgr
        )
    /*++

    --*/
    {
        m_pWkMgr = pWkMgr;
    }

    //------------------------------------------------------------
    // 
    virtual DWORD
    GetJobRestartTime() 
    /*
    Abstract:

        Return suggested re-start time after server has been 
        shutdown/restart, this is used by work storage class only.

    Parameter:

        None.

    Returns:

        Time in second relative to current time.

    --*/
    {
        return INFINITE;
    }

    //------------------------------------------------------------
    // 
    virtual DWORD
    GetScheduledTime() 
    /*++

    Abstract:

        Get Job's scheduled time.

    Parameter:

        None:

    Returns:

        Absolute scheduled time in seconds.

    --*/
    { 
        return m_dwScheduledTime; 
    }
    
    //------------------------------------------------------------
    // 
    // Abstract:
    //
    //      Initialize work object, similar to constructor.
    //
    virtual DWORD
    Init(
        IN BOOL bDestructorDelete = TRUE
    );

    //------------------------------------------------------------
    // 
    virtual BOOL
    IsWorkPersistent()
    /*++
    Abstract:

        Return if this is persistent job - across session.

    Parameter:

        None.

    Returns:

        TRUE/FALSE.

    --*/
    {
        return FALSE;
    }
        
    //------------------------------------------------------------
    // 
    virtual BOOL
    IsValid() 
    /*++

    Abstract:

        Return if this object has been properly initialized.

    Parameter:

        None:

    Returns:
        
        TRUE/FALSE

    --*/
    {
        return m_pWkMgr != NULL;
    }

    //------------------------------------------------------------
    // 
    virtual void
    Cleanup()
    /*++

    Abstract:

        Cleanup internal data in this object.

    Parameter:

        None.

    Returns:

        None.

    --*/
    {
        InterlockedExchange(&m_refCount, 0);
        return;
    }

    //------------------------------------------------------------
    //
    // Abstract:
    //
    //      Pure virtual function to return type of work
    //
    // Parameter:
    //  
    //      None.
    //
    // Returns:
    //  
    //      Derived class dependent.
    //
    virtual DWORD 
    GetWorkType() = 0;

    //------------------------------------------------------------
    //
    virtual BOOL
    SetWorkType(
        IN DWORD dwType
        )
    /*++

    Abstract:

        Set the type of work for this object, not call by any of work
        manager function.

    Parameter:

        dwType : Type of work.        

    return:
    
        TRUE/FALSE.

    --*/
    {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    //-----------------------------------------------------------
    //
    // Abstract:
    //
    //      pure virtual function to return work object specific data.
    // 
    // Parameters:
    //
    //      ppbData : Pointer to pointer to buffer to receive object
    //                specific work data.
    //      pcbData : Pointer to DWORD to receive size of object specific
    //                work data.
    //
    //  Returns:
    //
    //      TRUE/FALSE, all derived class specific.
    virtual BOOL
    GetWorkObjectData(
        OUT PBYTE* ppbData,
        OUT PDWORD pcbData
    ) = 0;

    //-----------------------------------------------------------
    //
    // Abstract:
    //
    //      Pure virtual function for work storage class to assign
    //      storage ID.
    //
    // Parameters:
    //
    //      pbData : Work Storage assigned storage ID.
    //      cbData : size of storage ID.
    //
    // Returns:
    //
    //      TRUE/FALSE, derived class specific.
    //
    virtual BOOL
    SetJobId(
        IN PBYTE pbData, 
        IN DWORD cbData
    ) = 0;

    //-----------------------------------------------------------
    //
    // Abstract:
    //
    //      Pure virtual function to return storage ID assigned by
    //      storage class.
    //
    // parameter:
    //  
    //      ppbData : Pointer to pointer to buffer to receive storage ID.
    //      pcbData : size of storage ID.
    //
    // Returns:
    //  
    //      TRUE/FALSE, derived class specific.
    //
    virtual BOOL
    GetJobId(
        OUT PBYTE* ppbData, 
        OUT PDWORD pcbData
    ) = 0;

    //-------------------------------------------------------------
    // 
    //  Abstract:
    //      
    //      Virtual function, execute a job.
    //
    //  Parameters:
    //  
    //      None.
    //
    //  Returns:
    //
    //      None
    //
    virtual DWORD
    Execute() = 0;
    

    //-------------------------------------------------------------
    //
    // Abstract :
    // 
    //      Schedule a job at relative time
    //
    // Parameters:
    //
    //      pftStartTime : Time relative to current system time, if NULL,
    //                     Job will be placed infront of job queue
    //
    //  Return:
    //
    //      TRUE if successful, FALSE otherwise
    //
    //  Note:
    //
    //      Could cause job stavation if set to NULL
    //
    virtual DWORD
    ScheduleJob(
        IN DWORD StartTime 
        ) 
    /*++

    --*/
    {
        TLSASSERT(m_pWkMgr != NULL);
        return (m_pWkMgr == NULL) ? ERROR_INVALID_DATA : m_pWkMgr->ScheduleJob(StartTime, this);
    }
    
    //----------------------------------------------------------
    //
    // For threadpool function, see thread pool doc.
    //
    virtual DWORD
    GetJobRunningAttribute() 
    { 
        return JOB_INCLUDES_IO | JOB_LONG_RUNNING; 
    }

    //---------------------------------------------------------------
    //
    // Return suggested schedule time relative to current time
    //
    virtual DWORD
    GetSuggestedScheduledTime() = 0;

    //--------------------------------------------------------------
    //
    // Get last status return from Execute().
    //
    virtual BOOL
    GetLastRunStatus() {
        return m_dwLastRunStatus;
    }

    //--------------------------------------------------------------
    //
    // Return TRUE if job can be deleted from queue
    //
    virtual BOOL
    IsJobCompleted() = 0;

    //-------------------------------------------------------------
    //
    // End Job, work manager, after invoke Execute(), calls EndJob() 
    // to inform. work object that job has completed, derived class
    // should perform internal data cleanup.
    //
    virtual void
    EndJob() = 0;

    //-------------------------------------------------------------
    //
    // Pure virtual function, work manager operates on CWorkObject
    // so it has no idea the actual class it is running, derive class
    // should cast the pointer back to its class and delete the pointer
    // to free up memory associated with object.
    //
    virtual BOOL
    SelfDestruct() = 0;

    //-------------------------------------------------------------
    //
    // Pure virtual, for debugging purpose only.
    //
    virtual LPCTSTR
    GetJobDescription() = 0;

    //--------------------------------------------------------
    virtual void 
    SetJobRetryTimes(
        IN DWORD dwRetries
    ) = 0;

    //--------------------------------------------------------
    virtual DWORD
    GetJobRetryTimes() = 0;

    //---------------------------------------------------------
    virtual void
    SetJobInterval(
        IN DWORD dwInterval
    ) = 0;

    //---------------------------------------------------------
    virtual DWORD
    GetJobInterval() = 0;

    //---------------------------------------------------------
    virtual void
    SetJobRestartTime(
        IN DWORD dwRestartTime
        )
    /*++

    --*/
    {
        return;
    }

};


#ifndef __TEST_WORKMGR__
#define TLSDebugOutput
#endif

//-----------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif




#ifdef __cplusplus
}
#endif
   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\licreq.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        licreq.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __LICREQ_H__
#define __LICREQ_H__
#include "server.h"



#ifdef __cplusplus
extern "C" {
#endif

    DWORD 
    TLSDBUpgradeClientLicense(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PTLSDBLICENSEREQUEST pRequest,
        IN PTLSDBLICENSEDPRODUCT pLicensedProduct,
        IN BOOL bAcceptFewerLicenses,
        IN OUT DWORD *pdwQuantity,
        IN OUT PTLSDBLICENSEDPRODUCT pUpgradedProduct,
        IN DWORD dwSupportFlags
    );


    DWORD
    TLSNewLicenseRequest(   
        IN BOOL bForwardRequest,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSForwardNewLicenseRequest pForward,
        IN PTLSDBLICENSEREQUEST lpLsLicenseRequest,
        IN BOOL bAcceptTemporaryLicense,
        IN BOOL bRequireTemporaryLicense,
        IN BOOL bFindLostLicense,
        IN BOOL bAcceptFewerLicenses,
        IN OUT DWORD *pdwQuantity,
        OUT PDWORD pcbEncodedCert, 
        OUT PBYTE* ppbEncodedCert
    );

    DWORD
    TLSUpgradeLicenseRequest(
        IN BOOL bForwardRequest,
        IN PTLSForwardUpgradeLicenseRequest pForward,
        IN OUT DWORD *pdwSupportFlags,
        IN PTLSDBLICENSEREQUEST pRequest,
        IN PBYTE pbOldLicense,
        IN DWORD cbOldLicense,
        IN DWORD dwNumLicProduct,
        IN PLICENSEDPRODUCT pLicProduct,
        IN BOOL bRequireTemporaryLicense,
        IN OUT PDWORD pcbEncodedCert,
        OUT PBYTE* ppbEncodedCert
    );

    DWORD
    TLSReturnClientLicensedProduct(
        IN PTLSDbWorkSpace pDbWkSpace,
        IN PMHANDLE hClient,
        IN CTLSPolicy* pPolicy,
        IN PTLSLicenseToBeReturn pClientLicense
    );

    DWORD
    TLSCheckLicenseMarkRequest(
        IN BOOL bForwardRequest,
        IN PLICENSEDPRODUCT pLicProduct,
        IN DWORD cbLicense,
        IN PBYTE pLicense,
        OUT PUCHAR pucMarkFlags
    );

    DWORD
    TLSMarkLicenseRequest(
        IN BOOL bForwardRequest,
        IN UCHAR ucMarkFlags,
        IN PLICENSEDPRODUCT pLicProduct,
        IN DWORD cbLicense,
        IN PBYTE pLicense
        );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\licreq.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        licreq.cpp
//
// Contents:    
//              New license request
//
// History:     
//              09/13/98 HueiWang   Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "licreq.h"
#include "db.h"
#include "findlost.h"
#include "permlic.h"
#include "templic.h"
#include "gencert.h"
#include "globals.h"
#include "forward.h"
#include "postjob.h"
#include "cryptkey.h"
#include "init.h"
#include "clilic.h"

DWORD
TLSDBIssueNewLicenseFromLocal(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bFindLostLicense,
    IN BOOL bRequireTempLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
);

//
// State of issuing function - used for counters
//

#define NONE_TRIED              0
#define PERMANENT_ISSUE_TRIED   1
#define TEMPORARY_ISSUE_TRIED   2
#define PERMANENT_REISSUE_TRIED 3

////////////////////////////////////////////////////////////////////

void
TLSLicenseTobeReturnToPMLicenseToBeReturn(
    PTLSLicenseToBeReturn pTlsLicense,
    BOOL bTempLicense,
    PPMLICENSETOBERETURN  pPmLicense
    )
/*++

--*/
{
    pPmLicense->dwQuantity = pTlsLicense->dwQuantity;
    pPmLicense->dwProductVersion = pTlsLicense->dwProductVersion;
    pPmLicense->pszOrgProductId = pTlsLicense->pszOrgProductId;
    pPmLicense->pszCompanyName = pTlsLicense->pszCompanyName;
    pPmLicense->pszProductId = pTlsLicense->pszProductId;
    pPmLicense->pszUserName = pTlsLicense->pszUserName;
    pPmLicense->pszMachineName = pTlsLicense->pszMachineName;
    pPmLicense->dwPlatformID = pTlsLicense->dwPlatformID;
    pPmLicense->bTemp = bTempLicense;

    return;
}

////////////////////////////////////////////////////////////////////

DWORD
TLSReturnClientLicensedProduct(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PMHANDLE hClient,
    IN CTLSPolicy* pPolicy,
    IN PTLSLicenseToBeReturn pClientLicense
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwPolicyLicenseStatus;
    ULARGE_INTEGER serialNumber;
    HWID hwid;
    LICENSEREQUEST LicensedProduct;
    Product_Info ProductInfo;
    TLSLICENSEPACK  LicensePack;
    LICENSEDCLIENT  LicenseClient;
    PMLICENSETOBERETURN pmLicToBeReturn;
    DWORD dwLicenseStatus;


    dwStatus = LicenseDecryptHwid(
                            &hwid,
                            pClientLicense->cbEncryptedHwid,
                            pClientLicense->pbEncryptedHwid,
                            g_cbSecretKey,
                            g_pbSecretKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        SetLastError(dwStatus = TLS_E_INVALID_LICENSE);
        goto cleanup;
    }


    LicensedProduct.pbEncryptedHwid = pClientLicense->pbEncryptedHwid;
    LicensedProduct.cbEncryptedHwid = pClientLicense->cbEncryptedHwid;
    LicensedProduct.dwLanguageID = 0;
    LicensedProduct.dwPlatformID = pClientLicense->dwPlatformID;
    LicensedProduct.pProductInfo = &ProductInfo;

    ProductInfo.cbCompanyName = (lstrlen(pClientLicense->pszCompanyName) + 1) * sizeof(TCHAR);
    ProductInfo.pbCompanyName = (PBYTE)pClientLicense->pszCompanyName;

    ProductInfo.cbProductID = (lstrlen(pClientLicense->pszProductId) + 1) * sizeof(TCHAR);
    ProductInfo.pbProductID = (PBYTE)pClientLicense->pszProductId;

    //
    // Verify with local database
    //
    dwStatus = TLSDBValidateLicense(
                                    pDbWkSpace,
                                    &hwid,
                                    &LicensedProduct,
                                    pClientLicense->dwKeyPackId,
                                    pClientLicense->dwLicenseId,
                                    &LicensePack,
                                    &LicenseClient
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        // tell caller this record is wrong.
        SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        goto cleanup;
    }

    if( LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_UPGRADED ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_REVOKE ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_UNKNOWN )
    {
        // License already been return/revoke
        dwStatus = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    //
    // only inform policy module if license status is 
    // active, temporary, active_pending, concurrent
    // TODO - pass all status to policy module
    //
    if( LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_TEMPORARY ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_ACTIVE ||
        //LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_PENDING_ACTIVE ||
        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_CONCURRENT )
    {
        serialNumber.HighPart = pClientLicense->dwKeyPackId;
        serialNumber.LowPart = pClientLicense->dwLicenseId;

        TLSLicenseTobeReturnToPMLicenseToBeReturn(
                                        pClientLicense,
                                        LicenseClient.ucLicenseStatus == LSLICENSE_STATUS_TEMPORARY,
                                        &pmLicToBeReturn
                                    );

        dwStatus = pPolicy->PMReturnLicense(
                                        hClient,
                                        &serialNumber,                                    
                                        &pmLicToBeReturn,
                                        &dwPolicyLicenseStatus
                                    );
    
        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        //
        // delete license on request.
        //
        dwLicenseStatus = (dwPolicyLicenseStatus == LICENSE_RETURN_KEEP) ? 
                                    LSLICENSE_STATUS_UPGRADED : LSLICENSESTATUS_DELETE;
    }

    if (LicenseClient.dwNumLicenses == pClientLicense->dwQuantity)
    {
        // delete the whole license

        dwStatus = TLSDBReturnLicense(
                        pDbWkSpace, 
                        pClientLicense->dwKeyPackId, 
                        pClientLicense->dwLicenseId, 
                        dwLicenseStatus
                        );
    }
    else
    {
        dwStatus = TLSDBReturnLicenseToKeyPack(
                        pDbWkSpace, 
                        pClientLicense->dwKeyPackId, 
                        pClientLicense->dwQuantity
                        );

        if (dwStatus == ERROR_SUCCESS)
        {
            // Set number of CALs in license
            
            LICENSEDCLIENT license;

            license.dwLicenseId = pClientLicense->dwLicenseId;
            license.dwNumLicenses = LicenseClient.dwNumLicenses - pClientLicense->dwQuantity;
            license.ucLicenseStatus = LSLICENSE_STATUS_UPGRADED;

            dwStatus = TLSDBLicenseSetValue(pDbWkSpace,
                                            LSLICENSE_SEARCH_NUMLICENSES,
                                            &license,
                                            FALSE     // bPointerOnRecord
                                            );
        }
    }

cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////////////////
DWORD
TLSDBMarkClientLicenseUpgraded(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN PTLSDBLICENSEDPRODUCT pLicensedProduct
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLicenseStatus;
    PMLICENSETOBERETURN pmLicense;


    if(pRequest == NULL || pRequest->pPolicy == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    pmLicense.dwQuantity = pLicensedProduct->dwQuantity;
    pmLicense.dwProductVersion = pLicensedProduct->dwProductVersion;
    pmLicense.pszOrgProductId = pLicensedProduct->szRequestProductId;
    pmLicense.pszCompanyName = pLicensedProduct->szCompanyName;
    pmLicense.pszProductId = pLicensedProduct->szLicensedProductId;
    pmLicense.pszUserName = pLicensedProduct->szUserName;
    pmLicense.pszMachineName = pLicensedProduct->szMachineName;
    pmLicense.dwPlatformID = pLicensedProduct->dwPlatformID;
    pmLicense.bTemp = pLicensedProduct->bTemp;

    //
    // Ask if we can delete the old license
    //
    dwStatus = pRequest->pPolicy->PMReturnLicense(
                                        pRequest->hClient,
                                        &pLicensedProduct->ulSerialNumber,
                                        &pmLicense, 
                                        &dwLicenseStatus
                                    );


    //
    // MarkClientLicenseUpgrade() can only be called by FindLostLicense() which will only
    // return valid licenses.
    // TODO - Check license status.
    //
    if(dwStatus == ERROR_SUCCESS)
    {
        // Temporary license - delete license and don't bother about 
        // Permenant license - keep license and DO NOT return license to keypack
        dwStatus = TLSDBReturnLicense(
                            pDbWkSpace, 
                            pLicensedProduct->dwKeyPackId, 
                            pLicensedProduct->dwLicenseId, 
                            (dwLicenseStatus == LICENSE_RETURN_KEEP) ? LSLICENSE_STATUS_UPGRADED : LSLICENSESTATUS_DELETE
                        );
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////

DWORD 
TLSDBUpgradeClientLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pUpgradedProduct,
    IN DWORD dwSupportFlags
    )
/*

Abstract:

    Upgrade a license - issue a new license and return old license

Parameters:


Returns

*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    dwStatus=TLSDBIssuePermanentLicense( 
                            pDbWkSpace,
                            pRequest,
                            TRUE,       // bLatestVersion
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            pUpgradedProduct,
                            dwSupportFlags
                        );

    if (dwStatus == ERROR_SUCCESS)
    {
        //
        // Return license to keypack
        //

        dwStatus = TLSDBMarkClientLicenseUpgraded(
                                            pDbWkSpace,
                                            pRequest,
                                            pLicensedProduct
                                            );
    }

    return dwStatus;
}


//--------------------------------------------------------------------
void
LicensedProductToDbLicensedProduct(
    PLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    )
/*++

++*/
{    

    pDest->dwQuantity = pSrc->dwQuantity;
    pDest->ulSerialNumber = pSrc->ulSerialNumber;
    pDest->dwKeyPackId = pSrc->ulSerialNumber.HighPart;
    pDest->dwLicenseId = pSrc->ulSerialNumber.LowPart;
    pDest->ClientHwid = pSrc->Hwid;
    pDest->NotBefore = pSrc->NotBefore;
    pDest->NotAfter = pSrc->NotAfter;
    pDest->bTemp = ((pSrc->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) != 0);
    pDest->dwProductVersion = pSrc->LicensedProduct.pProductInfo->dwVersion;

    SAFESTRCPY(
            pDest->szCompanyName, 
            (LPTSTR)(pSrc->LicensedProduct.pProductInfo->pbCompanyName)
        );

    SAFESTRCPY(
            pDest->szLicensedProductId,
            (LPTSTR)(pSrc->LicensedProduct.pProductInfo->pbProductID)
        );

    SAFESTRCPY(
            pDest->szRequestProductId,
            (LPTSTR)(pSrc->pbOrgProductID)
        );

    SAFESTRCPY(
            pDest->szUserName,
            pSrc->szLicensedUser
        );

    SAFESTRCPY(
            pDest->szMachineName,
            pSrc->szLicensedClient
        );

    pDest->dwLanguageID = pSrc->LicensedProduct.dwLanguageID;
    pDest->dwPlatformID = pSrc->LicensedProduct.dwPlatformID;
    pDest->pbPolicyData = pSrc->pbPolicyData;
    pDest->cbPolicyData = pSrc->cbPolicyData;
}

//--------------------------------------------------------------------
void
CopyDbLicensedProduct(
    PTLSDBLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    )
/*++

++*/
{    

    pDest->dwQuantity = pSrc->dwQuantity;
    pDest->ulSerialNumber = pSrc->ulSerialNumber;
    pDest->dwKeyPackId = pSrc->dwKeyPackId;
    pDest->dwLicenseId = pSrc->dwLicenseId;
    pDest->ClientHwid = pSrc->ClientHwid;
    pDest->NotBefore = pSrc->NotBefore;
    pDest->NotAfter = pSrc->NotAfter;
    pDest->bTemp = pSrc->bTemp;
    pDest->dwProductVersion = pSrc->dwProductVersion;

    SAFESTRCPY(
            pDest->szCompanyName, 
            pSrc->szCompanyName
        );

    SAFESTRCPY(
            pDest->szLicensedProductId,
            pSrc->szLicensedProductId
        );

    SAFESTRCPY(
            pDest->szRequestProductId,
            pSrc->szRequestProductId
        );

    SAFESTRCPY(
            pDest->szUserName,
            pSrc->szUserName
        );

    SAFESTRCPY(
            pDest->szMachineName,
            pSrc->szMachineName
        );

    pDest->dwLanguageID = pSrc->dwLanguageID;
    pDest->dwPlatformID = pSrc->dwPlatformID;
    pDest->pbPolicyData = pSrc->pbPolicyData;
    pDest->cbPolicyData = pSrc->cbPolicyData;
}


//------------------------------------------------------------------
DWORD
TLSDBIssueNewLicenseFromLocal(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bFindLostLicense,
    IN BOOL bRequireTempLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
    )
/*++

Abstract:

    Allocate a license from locally installed license pack.

Parameters:

    pDbWkSpace - workspace handle
    lpLsLicenseRequest - license request
    bAcceptTemporaryLicense - accept temporary license
    bFindLostLicense - TRUE if find lost license before issuing a new one
    bRequireTempLicense -TRUE if permanent license can't be issued (DoS fix)
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses requested
                  on output, number of licenses actually allocated
    pLicensedProduct - return licensed product

Returns:


++*/
{
    DWORD status=TLS_E_RECORD_NOTFOUND;
    UCHAR ucMarked;

    if(bFindLostLicense == TRUE)
    {       
        //
        // Try to find the lost license
        //
        status=TLSDBFindLostLicense( 
                        pDbWkSpace,
                        pRequest,
                        &pRequest->hWid,
                        pLicensedProduct,
                        &ucMarked
                    );

        if( status != TLS_E_RECORD_NOTFOUND && 
            status != TLS_E_LICENSE_EXPIRED && 
            status != TLS_I_FOUND_TEMPORARY_LICENSE &&
            status != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        //
        // If license has been expired or it is a temporary license, 
        // try to allocate a new permanent one.
        //

        if ( status == TLS_E_LICENSE_EXPIRED
             || status == TLS_I_FOUND_TEMPORARY_LICENSE)
        {
            if ((!pLicensedProduct->bTemp) && CanIssuePermLicense())
            {
                TLSDBLICENSEDPRODUCT upgradeProduct;

                //
                // expired permanent
                //

                status = TLSDBReissueFoundPermanentLicense(
                                              USEHANDLE(pDbWkSpace),
                                              pLicensedProduct,
                                              &upgradeProduct
                                              );

                if (ERROR_SUCCESS == status)
                {
                    *pLicensedProduct = upgradeProduct;
                    status = TLS_I_LICENSE_UPGRADED;
                }
                else
                {
                    //
                    // reissuance failed, try to issue a new permanent
                    //
                    status = TLS_E_RECORD_NOTFOUND;
                }
            }

            //
            // no upgrade if license server hasn't been registered
            // or if DoS fix required and license isn't marked
            //

            else if (((!bRequireTempLicense)
                      || (ucMarked & MARK_FLAG_USER_AUTHENTICATED))
                     && CanIssuePermLicense())
                
            {
                DWORD upgrade_status;
                TLSDBLICENSEDPRODUCT upgradeProduct;

                upgrade_status = TLSDBUpgradeClientLicense(
                                        pDbWkSpace,
                                        pRequest,
                                        pLicensedProduct,
                                        bAcceptFewerLicenses,
                                        pdwQuantity,
                                        &upgradeProduct,
                                        dwSupportFlags
                                    );

                if(upgrade_status == ERROR_SUCCESS)
                {
                    *pLicensedProduct = upgradeProduct;
                    status = TLS_I_LICENSE_UPGRADED;
                } 
                else if(upgrade_status != TLS_E_NO_LICENSE && 
                        upgrade_status != TLS_E_PRODUCT_NOTINSTALL)
                {
                    //
                    // Error in upgrade license.
                    //
                    status = upgrade_status;
                }    

                goto cleanup;
            }

            //
            // Temporary license has expired and can't allocate permanent 
            // license, refuse connection
            //

            if( status == TLS_E_LICENSE_EXPIRED )
            {
                goto cleanup;
            }
        }
        else if ((status == ERROR_SUCCESS)
                 && (pLicensedProduct->dwQuantity != *pdwQuantity))
        {
            // user has wrong number of licenses

            if (*pdwQuantity > pLicensedProduct->dwQuantity)
            {

                if (bRequireTempLicense || !CanIssuePermLicense())
                {
                    goto try_next;
                }

#define NUM_KEYPACKS 5

                DWORD                       upgrade_status;
                TLSDBLicenseAllocation      allocation;
                DWORD                       dwAllocation[NUM_KEYPACKS];
                TLSLICENSEPACK              keypack[NUM_KEYPACKS];
                TLSDBAllocateRequest        AllocateRequest;

                for (int i=0; i < NUM_KEYPACKS; i++)
                {
                    keypack[i].pbDomainSid = NULL;
                }

                memset(&allocation,0,sizeof(allocation));
                    
                allocation.dwBufSize = NUM_KEYPACKS;
                allocation.pdwAllocationVector = dwAllocation;
                allocation.lpAllocateKeyPack = keypack;


                AllocateRequest.szCompanyName
                    = (LPTSTR)pRequest->pszCompanyName;
                AllocateRequest.szProductId
                    = (LPTSTR)pRequest->pszProductId;
                AllocateRequest.dwVersion
                    = pRequest->dwProductVersion;
                AllocateRequest.dwPlatformId
                    = pRequest->dwPlatformID;
                AllocateRequest.dwLangId
                    = pRequest->dwLanguageID;
                AllocateRequest.dwNumLicenses
                    = *pdwQuantity - pLicensedProduct->dwQuantity;
                AllocateRequest.dwScheme
                    = ALLOCATE_ANY_GREATER_VERSION;
                AllocateRequest.ucAgreementType
                    = LSKEYPACKTYPE_UNKNOWN;
                    
                upgrade_status = AllocateLicensesFromDB(
                                          pDbWkSpace,
                                          &AllocateRequest,
                                          FALSE,        // fCheckAgreementType
                                          &allocation
                                          );

                if ((upgrade_status == ERROR_SUCCESS)
                    && ((allocation.dwTotalAllocated == 0)
                        || (!bAcceptFewerLicenses
                            && (allocation.dwTotalAllocated != *pdwQuantity-pLicensedProduct->dwQuantity))))
                    
                {
                    status = TLS_E_NO_LICENSE;
                    goto cleanup;
                }
                else
                {
                    *pdwQuantity = pLicensedProduct->dwQuantity + allocation.dwTotalAllocated;
                }

                if (TLS_I_NO_MORE_DATA == upgrade_status)
                {
                    status = TLS_E_NO_LICENSE;
                    goto cleanup;
                }
                
                if(upgrade_status == ERROR_SUCCESS)
                {
                    status = TLS_I_LICENSE_UPGRADED;
                } 
                else
                {
                    //
                    // Error in upgrade license.
                    //
                    status = upgrade_status;
                    goto cleanup;
                }
            }
            else
            {
                // return unwanted licenses to keypack

                status = TLSDBReturnLicenseToKeyPack(
                                        pDbWkSpace, 
                                        pLicensedProduct->dwKeyPackId, 
                                        pLicensedProduct->dwQuantity - *pdwQuantity
                                        );

                if (status != ERROR_SUCCESS)
                {
                    goto cleanup;
                }
            }

            {
                // Set number of CALs in license
                
                LICENSEDCLIENT license;

                license.dwLicenseId = pLicensedProduct->dwLicenseId;
                license.dwNumLicenses = *pdwQuantity;
                license.ucLicenseStatus = LSLICENSE_STATUS_UPGRADED;

                status = TLSDBLicenseSetValue(pDbWkSpace,
                                              LSLICENSE_SEARCH_NUMLICENSES,
                                              &license,
                                              FALSE     // bPointerOnRecord
                                              );
            }

            goto cleanup;
        }
    }

try_next:
    //
    // Issue permanent license only if license server has been registered
    // and user is allowed to have one
    //
    if((status == TLS_E_RECORD_NOTFOUND) && (!bRequireTempLicense))
    {
		if(CanIssuePermLicense() == FALSE)
        {
            SetLastError(status = TLS_E_NO_CERTIFICATE);
        }
        else
        {
            status=TLSDBIssuePermanentLicense( 
                                pDbWkSpace,
                                pRequest,
                                FALSE,
                                bAcceptFewerLicenses,
                                pdwQuantity,
                                pLicensedProduct,
                                dwSupportFlags
                            );
        }
    }

cleanup:

    return status;
}


//////////////////////////////////////////////////////////////////////

DWORD
TLSUpgradeLicenseRequest(
    IN BOOL bForwardRequest,
    IN PTLSForwardUpgradeLicenseRequest pForward,        
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN PBYTE pbOldLicense,
    IN DWORD cbOldLicense,
    IN DWORD dwNumLicProduct,
    IN PLICENSEDPRODUCT pLicProduct,
    IN BOOL bRequireTempLicense,
    IN OUT PDWORD pcbEncodedCert,
    OUT PBYTE* ppbEncodedCert
    )
/*++



++*/
{
    DWORD dwStatus = TLS_E_NO_LICENSE;
    BOOL bAcceptTempLicense = FALSE;
    DWORD index;
    DWORD dwNumNewLicProduct;
    TLSDBLICENSEDPRODUCT NewLicProduct;
    PTLSDbWorkSpace pDbWkSpace=NULL;

    PTLSDBLICENSEDPRODUCT pGenCertProduct=NULL;
    FILETIME* pNotBefore=NULL;
    FILETIME* pNotAfter=NULL;
    DWORD dwNumChars;
    DWORD dwLicGenStatus;
    BOOL bDbHandleAcquired = FALSE;
    BOOL fReissue = FALSE;
    DWORD dwTried = NONE_TRIED;

    //
    // check to see if we can take temp. license
    //
    // The only case that we need to set temp. license's expiration date is
    // latest licensed product is temporary and client is requesting for version
    // greater than lastest license.
    // 
    if(CompareTLSVersions(pRequest->dwProductVersion, pLicProduct->LicensedProduct.pProductInfo->dwVersion) > 0)
    {
        bAcceptTempLicense = TRUE;
        if(pLicProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY)
        {
            //
            // client holding 5.0 temp. and request 6.0 licenses.
            // we need to issue 6.0 license but the license expiration 
            // date stay the same.
            //
            pNotBefore = &(pLicProduct->NotBefore);
            pNotAfter = &(pLicProduct->NotAfter);
        }
    }
    else if(CompareTLSVersions(pRequest->dwProductVersion, pLicProduct->LicensedProduct.pProductInfo->dwVersion) == 0)
    {
        if( IS_LICENSE_ISSUER_RTM(pLicProduct->pLicensedVersion->dwFlags) == FALSE && 
            TLSIsBetaNTServer() == FALSE )
        {
            // issuer is beta/eval, we are a RTM, accept temp. license
            bAcceptTempLicense = TRUE;
        }
    }

    if(ALLOCATEDBHANDLE(pDbWorkSpace, g_EnumDbTimeout) == FALSE)
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);
    bDbHandleAcquired = TRUE;

    if (!bRequireTempLicense)
    {

        //
        // Check for reissuance first, if a) reissuance is supported, b)
        // the license is permanent, c) the license is the current version,
        // and d) the license is expired.
        //

        if ((*pdwSupportFlags & SUPPORT_PER_SEAT_REISSUANCE) &&
            ((_tcsnicmp((TCHAR *)pLicProduct->LicensedProduct.pProductInfo->pbProductID,
                        TERMSERV_PRODUCTID_SKU,
                        _tcslen(TERMSERV_PRODUCTID_SKU)) == 0) ||
             (_tcsnicmp((TCHAR *)pLicProduct->LicensedProduct.pProductInfo->pbProductID,
                        TERMSERV_PRODUCTID_CONCURRENT_SKU,
                        _tcslen(TERMSERV_PRODUCTID_CONCURRENT_SKU)) == 0)) &&
            (!(pLicProduct->pLicensedVersion->dwFlags &
                LICENSED_VERSION_TEMPORARY)) &&
            (CompareTLSVersions(pLicProduct->LicensedProduct.pProductInfo->dwVersion,
               pRequest->dwProductVersion)) == 0)
        {
            DWORD t;

            //
            // Checking expiration with filetimes is a pain; convert.
            //

            FileTimeToLicenseDate(&(pLicProduct->NotAfter), &t);

            if (t-g_dwReissueLeaseLeeway < time(NULL))
            {
                // do reissue

                fReissue = TRUE;

                if (CanIssuePermLicense())
                {
                    dwStatus = TLSDBReissuePermanentLicense(
                                 USEHANDLE(pDbWkSpace),
                                 pLicProduct,
                                 &NewLicProduct
                                 );

                    if (dwStatus == ERROR_SUCCESS)
                    {
                        dwTried = PERMANENT_REISSUE_TRIED;

                        // skip past the next stuff if all goes well
                        goto licenseReissued;
                    }
                }
                else
                {                    
                    dwStatus = TLS_E_RECORD_NOTFOUND;
                }

                if ((dwStatus == TLS_E_RECORD_NOTFOUND)
                    && bForwardRequest
                    && (_tcsicmp(pLicProduct->szIssuerId,
                                 (LPTSTR)g_pszServerPid) != 0))
                {
                    // couldn't find the license, forward the request to issuer
                    DWORD dwSupportFlagsTemp = *pdwSupportFlags;
                    DWORD dwErrCode;

                    dwStatus = ForwardUpgradeLicenseRequest(
                                       pLicProduct->szIssuerId,
                                       &dwSupportFlagsTemp,
                                       pForward->m_pRequest,
                                       pForward->m_ChallengeContext,
                                       pForward->m_cbChallengeResponse,
                                       pForward->m_pbChallengeResponse,
                                       pForward->m_cbOldLicense,
                                       pForward->m_pbOldLicense,
                                       pcbEncodedCert,
                                       ppbEncodedCert,
                                       &dwErrCode
                                       );

                    if (ERROR_SUCCESS == dwStatus
                        && LSERVER_S_SUCCESS == dwErrCode)
                    {
                        *pdwSupportFlags = dwSupportFlagsTemp;
                        goto licenseReissued;
                    }
                }

                // other failure cases just follow the existing codepath
                dwStatus = ERROR_SUCCESS;
            }
        }

        if(CanIssuePermLicense())
        {
            DWORD dwQuantity = 1;

            //
            // Try to issue a new license from local 
            // if this server is registered
            //
            dwStatus = TLSDBIssueNewLicenseFromLocal( 
                                 USEHANDLE(pDbWkSpace),
                                 pRequest,
                                 TRUE,  // bFindLostLicense
                                 FALSE, // bRequireTempLicense
                                 FALSE, // bAcceptFewerLicenses
                                 &dwQuantity,
                                 &NewLicProduct,
                                 *pdwSupportFlags
                                 );

            if (TLS_I_FOUND_TEMPORARY_LICENSE == dwStatus)
            {
                // Found a temporary license; not what we want

                dwStatus = TLS_E_RECORD_NOTFOUND;
            }
            else
            {
                dwTried = PERMANENT_ISSUE_TRIED;
            }
        }
        else
        {
            dwStatus = TLS_E_NO_CERTIFICATE;
        }

        if(dwStatus != ERROR_SUCCESS && bForwardRequest == FALSE)
        {
            //
            // If remote server can't handle upgrade, we don't do anything but 
            // return the license back to client, don't try to issue a temp.
            // license for this client if we are not the original contact
            // of client
            //
            goto cleanup;
        }


        if((dwStatus == TLS_E_PRODUCT_NOTINSTALL ||
            dwStatus == TLS_E_NO_CERTIFICATE ||
            dwStatus == TLS_E_NO_LICENSE || 
            dwStatus == TLS_E_RECORD_NOTFOUND) && bForwardRequest)
        {
            //
            // release our DB handle and forward request to other server
            //
            ROLLBACK_TRANSACTION(pDbWorkSpace);
            FREEDBHANDLE(pDbWorkSpace);
            bDbHandleAcquired = FALSE;
            DWORD dwForwardStatus;
            DWORD dwSupportFlagsTemp = *pdwSupportFlags;
            
            dwForwardStatus = TLSForwardUpgradeRequest(
                                        pForward,
                                        &dwSupportFlagsTemp,
                                        pRequest,
                                        pcbEncodedCert,
                                        ppbEncodedCert
                                        );

            if(dwForwardStatus == TLS_I_SERVICE_STOP || dwForwardStatus == ERROR_SUCCESS)
            {
                if (dwForwardStatus == ERROR_SUCCESS)
                {
                    *pdwSupportFlags = dwSupportFlagsTemp;
                }

                dwStatus = dwForwardStatus;

                goto cleanup;
            }
        }

        if(bDbHandleAcquired == FALSE)
        {
            if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
            {
                dwStatus = TLS_E_ALLOCATE_HANDLE;
                goto cleanup;
            }
            
            CLEANUPSTMT;
            BEGIN_TRANSACTION(pDbWorkSpace);
            bDbHandleAcquired = TRUE;
        }
    }

    //
    // if can't get license from remote, try temporary
    //
    // always issue a temporary license
    if((dwStatus == TLS_E_PRODUCT_NOTINSTALL ||
        dwStatus == TLS_E_NO_CERTIFICATE ||
        dwStatus == TLS_E_NO_LICENSE || 
        dwStatus == TLS_E_RECORD_NOTFOUND) && bAcceptTempLicense)
    {
        // Issue a temporary license if can't allocate a permenent license
        if( TLSDBIssueTemporaryLicense( 
                                USEHANDLE(pDbWkSpace),
                                pRequest,
                                pNotBefore,
                                pNotAfter,
                                &NewLicProduct
                            ) == ERROR_SUCCESS )
        {
            dwStatus = TLS_W_TEMPORARY_LICENSE_ISSUED;

            dwTried = TEMPORARY_ISSUE_TRIED;
        }
    }

    //
    // If we can find a server to upgrade or we can't issue temp
    // license, get out.
    //
    if(TLS_ERROR(dwStatus) == TRUE)
    {
        goto cleanup;
    }

licenseReissued:

    //
    // Determine which licensed product should be in the license blob
    //
    pGenCertProduct = (PTLSDBLICENSEDPRODUCT)AllocateMemory(
                                            sizeof(TLSDBLICENSEDPRODUCT)*(dwNumLicProduct+1)
                                        );
    if(pGenCertProduct == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    dwNumNewLicProduct = 0;

    //
    // Copy all licensed product with version greated than requested 
    //
    for( index = 0;  
        index < dwNumLicProduct && CompareTLSVersions((pLicProduct+index)->LicensedProduct.pProductInfo->dwVersion, NewLicProduct.dwProductVersion) > 0;
        index++, dwNumNewLicProduct++)
    {
        LicensedProductToDbLicensedProduct( pLicProduct+index, pGenCertProduct+dwNumNewLicProduct );
    }

    //
    // Append new license
    //
    *(pGenCertProduct+index) = NewLicProduct;
    dwNumNewLicProduct++;

    //
    // Append licensed product older than request
    //
    for(;index < dwNumLicProduct;index++)
    {
        BOOL bTemp;
        BOOL bDifferentProduct;
        BOOL bNotNewerVersion = (CompareTLSVersions(NewLicProduct.dwProductVersion, (pLicProduct+index)->LicensedProduct.pProductInfo->dwVersion) <= 0);

        bTemp = (((pLicProduct+index)->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) != 0);

        // if we are running on RTM server, treat license issued from beta server as temporary license
        if(bTemp == FALSE && TLSIsBetaNTServer() == FALSE)
        {
            bTemp = (IS_LICENSE_ISSUER_RTM((pLicProduct+index)->pLicensedVersion->dwFlags) == FALSE);
        }

        bDifferentProduct = (_tcscmp(NewLicProduct.szLicensedProductId, (LPTSTR)(pLicProduct+index)->LicensedProduct.pProductInfo->pbProductID) != 0);
        if (bNotNewerVersion && !bDifferentProduct && !(bTemp || fReissue))
        {
            //
            // we can't issue same version for the same product unless the old
            // one was a temp or it is being re-issued
            //
            SetLastError(dwStatus = TLS_E_INTERNAL);
            goto cleanup;
        }

        if(NewLicProduct.bTemp == FALSE || bTemp == TRUE)
        {
            if( IS_LICENSE_ISSUER_RTM((pLicProduct+index)->pLicensedVersion->dwFlags) == FALSE && 
                TLSIsBetaNTServer() == FALSE )
            {
                // we wipe out beta database so ignore return.
                continue;
            }

            if(_tcsicmp(pLicProduct->szIssuerId, (LPTSTR)g_pszServerPid) == 0)  
            {
                //
                // Convert LicensedProduct to TLSLicenseToBeReturn
                // TODO - have its own version.
                //
                TLSLicenseToBeReturn tobeReturn;

                tobeReturn.dwQuantity = (pLicProduct+index)->dwQuantity;
                tobeReturn.dwKeyPackId = (pLicProduct+index)->ulSerialNumber.HighPart;
                tobeReturn.dwLicenseId = (pLicProduct+index)->ulSerialNumber.LowPart;
                tobeReturn.dwPlatformID = (pLicProduct+index)->LicensedProduct.dwPlatformID;
                tobeReturn.cbEncryptedHwid = (pLicProduct+index)->LicensedProduct.cbEncryptedHwid;
                tobeReturn.pbEncryptedHwid = (pLicProduct+index)->LicensedProduct.pbEncryptedHwid;
                tobeReturn.dwProductVersion = MAKELONG(
                                            (pLicProduct+index)->pLicensedVersion->wMinorVersion,
                                            (pLicProduct+index)->pLicensedVersion->wMajorVersion
                                        );

                tobeReturn.pszOrgProductId = (LPTSTR)(pLicProduct+index)->pbOrgProductID;
                tobeReturn.pszCompanyName = (LPTSTR) (pLicProduct+index)->LicensedProduct.pProductInfo->pbCompanyName;
                tobeReturn.pszProductId = (LPTSTR) (pLicProduct+index)->LicensedProduct.pProductInfo->pbProductID;
                tobeReturn.pszUserName = (LPTSTR) (pLicProduct+index)->szLicensedUser;
                tobeReturn.pszMachineName = (pLicProduct+index)->szLicensedClient;

                dwStatus = TLSReturnClientLicensedProduct(
                                                USEHANDLE(pDbWkSpace),
                                                pRequest->hClient,
                                                pRequest->pPolicy,
                                                &tobeReturn
                                            );

            }
            else
            {
                dwStatus = TLSPostReturnClientLicenseJob( pLicProduct+index );
            }

            //
            // Ignore can't find the record in database
            //
            dwStatus = ERROR_SUCCESS;
        }
        else 
        {
            LicensedProductToDbLicensedProduct( pLicProduct + index, pGenCertProduct + dwNumNewLicProduct);
            dwNumNewLicProduct++;
        }
    }

    dwLicGenStatus = TLSGenerateClientCertificate(
                                    g_hCryptProv,
                                    dwNumNewLicProduct,
                                    pGenCertProduct,
                                    pRequest->wLicenseDetail,
                                    ppbEncodedCert,
                                    pcbEncodedCert
                                );
    if(dwLicGenStatus != ERROR_SUCCESS)
    {
        dwStatus = dwLicGenStatus;
    }

cleanup:


    if(bDbHandleAcquired == TRUE)
    {
        if(TLS_ERROR(dwStatus))
        {
            ROLLBACK_TRANSACTION(pDbWorkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWorkSpace);

            switch (dwTried)
            {

            case PERMANENT_ISSUE_TRIED:
                InterlockedIncrement(&g_lPermanentLicensesIssued);
                break;

            case TEMPORARY_ISSUE_TRIED:
                InterlockedIncrement(&g_lTemporaryLicensesIssued);
                break;

            case PERMANENT_REISSUE_TRIED:
                InterlockedIncrement(&g_lPermanentLicensesReissued);
                break;
            }
        }

        FREEDBHANDLE(pDbWorkSpace);
    }

    if(TLS_ERROR(dwStatus) == FALSE)
    {
        if(NewLicProduct.dwNumLicenseLeft == 0 && NewLicProduct.bTemp == FALSE)
        {
            // ignore error if we can't get it out to
            // other server
            TLSAnnounceLKPToAllRemoteServer(NewLicProduct.dwKeyPackId, 0);
        }
    }

    FreeMemory(pGenCertProduct);
    return dwStatus;
}

//----------------------------------------------------------
DWORD
TLSNewLicenseRequest(
    IN BOOL bForwardRequest,
    IN OUT DWORD *pdwSupportFlags,
    IN PTLSForwardNewLicenseRequest pForward,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptTempLicense,
    IN BOOL bRequireTempLicense,
    IN BOOL bFindLostLicense,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    OUT PDWORD pcbEncodedCert,
    OUT PBYTE* ppbEncodedCert
    )
/*++

Abstract:

Parameter:

Returns:


++*/
{
    DWORD dwStatus = TLS_E_NO_LICENSE;
    TLSDBLICENSEDPRODUCT LicensedProduct;
    PTLSDbWorkSpace pDbWorkSpace=NULL;
    BOOL bDbHandleAcquired = FALSE;
    DWORD dwSupportFlagsTemp = *pdwSupportFlags;
    DWORD dwTried = NONE_TRIED;

    if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);
    bDbHandleAcquired = TRUE;

    try {
        dwStatus = TLSDBIssueNewLicenseFromLocal(
                             USEHANDLE(pDbWorkSpace),
                             pRequest,
                             bFindLostLicense,
                             bRequireTempLicense,
                             bAcceptFewerLicenses,
                             pdwQuantity,
                             &LicensedProduct,
                             *pdwSupportFlags
                             );

        dwTried = PERMANENT_ISSUE_TRIED;
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_INTERNAL);
    }

    if (!bRequireTempLicense)
    {
        if( (dwStatus == TLS_E_PRODUCT_NOTINSTALL || dwStatus == TLS_I_FOUND_TEMPORARY_LICENSE ||
             dwStatus == TLS_E_NO_LICENSE || dwStatus == TLS_E_NO_CERTIFICATE ||
             dwStatus == TLS_E_RECORD_NOTFOUND) && bForwardRequest == TRUE )
        {
            //
            // release our DB handle so others can proceed
            //
            ROLLBACK_TRANSACTION(pDbWorkSpace);
            FREEDBHANDLE(pDbWorkSpace);
            bDbHandleAcquired = FALSE;
            DWORD dwForwardStatus;
            DWORD dwQuantityTemp = *pdwQuantity;
            
            //
            // forward call here
            //
            dwForwardStatus = TLSForwardLicenseRequest(
                                    pForward,
                                    &dwSupportFlagsTemp,
                                    pRequest,
                                    bAcceptFewerLicenses,
                                    &dwQuantityTemp,
                                    pcbEncodedCert,
                                    ppbEncodedCert
                                    );

            if(dwForwardStatus == TLS_I_SERVICE_STOP)
            {
                dwStatus = dwForwardStatus;
                goto cleanup;
            }

            if(dwForwardStatus == ERROR_SUCCESS)
            {
                //
                // remote server is able to issue perm. license, 
                // delete the license we are holding
                //

                *pdwSupportFlags = dwSupportFlagsTemp;

                *pdwQuantity = dwQuantityTemp;

                if(dwStatus == TLS_E_LICENSE_EXPIRED || dwStatus == TLS_I_FOUND_TEMPORARY_LICENSE)
                {
                    //
                    // re-acquire DB handle only if we going to issue
                    // a temporary license
                    //
                    if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
                    {
                        dwStatus = TLS_E_ALLOCATE_HANDLE;
                        goto cleanup;
                    }

                    CLEANUPSTMT;
                    BEGIN_TRANSACTION(pDbWorkSpace);
                    bDbHandleAcquired = TRUE;
                    
                    //
                    // need to mark this license has been upgraded
                    //
                    dwStatus = TLSDBMarkClientLicenseUpgraded(
                                                              USEHANDLE(pDbWorkSpace),
                                                              pRequest,
                                                              &LicensedProduct
                                                              );

                    if(TLS_ERROR(dwStatus))
                    {
                        ROLLBACK_TRANSACTION(pDbWorkSpace);
                    }
                    else
                    {
                        COMMIT_TRANSACTION(pDbWorkSpace);
                    }

                    bDbHandleAcquired = FALSE;
                    FREEDBHANDLE(pDbWorkSpace);
                }

                dwStatus = ERROR_SUCCESS;
                
                // exit right here so we don't re-generate 
                // certificate
                goto cleanup;
            }
        }
    }

    //
    // if can't get license from remote, try temporary
    //
    // always issue a temporary license
    if((dwStatus == TLS_E_PRODUCT_NOTINSTALL ||
        dwStatus == TLS_E_NO_CERTIFICATE ||
        dwStatus == TLS_E_NO_LICENSE || 
        dwStatus == TLS_E_RECORD_NOTFOUND) && bAcceptTempLicense)
    {
        if(bDbHandleAcquired == FALSE)
        {
            //
            // re-acquire DB handle only if we going to issue
            // a temporary license
            //
            if(ALLOCATEDBHANDLE(pDbWorkSpace, g_GeneralDbTimeout) == FALSE)
            {
                dwStatus = TLS_E_ALLOCATE_HANDLE;
                goto cleanup;
            }

            CLEANUPSTMT;
            BEGIN_TRANSACTION(pDbWorkSpace);
            bDbHandleAcquired = TRUE;
        }

        try {
            // Issue a temporary license if can't allocate a permenent license
            dwStatus=TLSDBIssueTemporaryLicense( 
                                USEHANDLE(pDbWorkSpace),
                                pRequest,
                                NULL,
                                NULL,
                                &LicensedProduct
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwTried = TEMPORARY_ISSUE_TRIED;

                dwStatus = TLS_W_TEMPORARY_LICENSE_ISSUED;
            }
        }
        catch( SE_Exception e ) {
            dwStatus = e.getSeNumber();
        }
        catch(...) {
            SetLastError(dwStatus = TLS_E_INTERNAL);
        }
    }

    if(bDbHandleAcquired == TRUE)
    {
        if(TLS_ERROR(dwStatus))
        {
            ROLLBACK_TRANSACTION(pDbWorkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWorkSpace);

            switch (dwTried)
            {

            case PERMANENT_ISSUE_TRIED:
                InterlockedExchangeAdd(&g_lPermanentLicensesIssued,
                                       *pdwQuantity);
                break;

            case TEMPORARY_ISSUE_TRIED:
                InterlockedIncrement(&g_lTemporaryLicensesIssued);
                break;
            }
        }

        FREEDBHANDLE(pDbWorkSpace);
    }

    //
    // actually generate client certificate.
    //
    if(TLS_ERROR(dwStatus) == FALSE)
    {
        DWORD dwLicGenStatus;


        //
        // Post ssync job to inform other machine to delete this
        // entry
        //
        if(LicensedProduct.dwNumLicenseLeft == 0 && LicensedProduct.bTemp == FALSE)
        {
            // ignore error if we can't get it out to
            // other server
            TLSAnnounceLKPToAllRemoteServer(LicensedProduct.dwKeyPackId, 0);
        }

        dwLicGenStatus = TLSGenerateClientCertificate(
                                        g_hCryptProv,
                                        1,      // dwNumLicensedProduct
                                        &LicensedProduct,
                                        pRequest->wLicenseDetail,
                                        ppbEncodedCert,
                                        pcbEncodedCert
                                    );
        if(dwLicGenStatus != ERROR_SUCCESS)
        {
            dwStatus = dwLicGenStatus;
        }
    };


cleanup:
    return dwStatus;        
}

//----------------------------------------------------------
DWORD
TLSCheckLicenseMarkRequest(
    IN BOOL bForwardRequest,
    IN PLICENSEDPRODUCT pLicProduct,
    IN DWORD cbLicense,
    IN PBYTE pLicense,
    OUT PUCHAR pucMarkFlags
    )
{
    DWORD dwStatus = TLS_E_RECORD_NOTFOUND;
    DWORD dwErrCode = ERROR_SUCCESS;
    LICENSEDCLIENT licClient;

    // NB: licenses are in descending order, so use the first one

    if ((bForwardRequest) &&
        (_tcsicmp(pLicProduct->szIssuerId, (LPTSTR)g_pszServerPid) != 0))
    {
        // Check remote license server

        TCHAR szServer[LSERVER_MAX_STRING_SIZE+2];
        TCHAR *pszServer = szServer;
        TLS_HANDLE hHandle;

        dwStatus = TLSResolveServerIdToServer(pLicProduct->szIssuerId,
                                              szServer);

        if (dwStatus != ERROR_SUCCESS)
        {
            // id not registered; use name
            pszServer = pLicProduct->szIssuer;
        }

        hHandle = TLSConnectAndEstablishTrust(pszServer, NULL);
        if(hHandle == NULL)
        {
            dwStatus = GetLastError();
        }

        // RPC to remote license server
        dwStatus = TLSCheckLicenseMark(
                           hHandle,
                           cbLicense,
                           pLicense,
                           pucMarkFlags,
                           &dwErrCode
                           );

        TLSDisconnectFromServer(hHandle);

        if ((dwStatus == ERROR_SUCCESS) && (dwErrCode == LSERVER_S_SUCCESS))
        {
            goto cleanup;
        }
    }

    // we're issuing server, or issuing server not found; try looking up HWID

    dwStatus = TLSFindLicense(pLicProduct,&licClient);

    if (ERROR_SUCCESS == dwStatus)
    {
        // this field is being reused for marking (e.g. user is authenticated)

        *pucMarkFlags = licClient.ucEntryStatus;
    }

cleanup:

    return dwStatus;
}

//----------------------------------------------------------
DWORD
TLSMarkLicenseRequest(
    IN BOOL bForwardRequest,
    IN UCHAR ucMarkFlags,
    IN PLICENSEDPRODUCT pLicProduct,
    IN DWORD cbLicense,
    IN PBYTE pLicense
    )
{
    DWORD dwStatus = TLS_E_RECORD_NOTFOUND;
    DWORD dwErrCode = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace=NULL;
    LICENSEDCLIENT license;

    // NB: licenses are in descending order, so use the first one

    if ((bForwardRequest) &&
        (_tcsicmp(pLicProduct->szIssuerId, (LPTSTR)g_pszServerPid) != 0))
    {
        // Check remote license server

        TCHAR szServer[LSERVER_MAX_STRING_SIZE+2];
        TCHAR *pszServer = szServer;
        TLS_HANDLE hHandle;

        dwStatus = TLSResolveServerIdToServer(pLicProduct->szIssuerId,
                                              szServer);

        if (dwStatus != ERROR_SUCCESS)
        {
            // id not registered; use name
            pszServer = pLicProduct->szIssuer;
        }

        hHandle = TLSConnectAndEstablishTrust(pszServer, NULL);
        if(hHandle == NULL)
        {
            dwStatus = GetLastError();
        }

        // RPC to remote license server
        dwStatus = TLSMarkLicense(
                           hHandle,
                           ucMarkFlags,
                           cbLicense,
                           pLicense,
                           &dwErrCode
                           );

        TLSDisconnectFromServer(hHandle);

        if ((dwStatus == ERROR_SUCCESS) && (dwErrCode == LSERVER_S_SUCCESS))
        {
            goto cleanup;
        }
    }

    // we're issuing server, or issuing server not found; try looking up HWID

    dwStatus = TLSFindLicense(pLicProduct,&license);

    if((ERROR_SUCCESS == dwStatus) &&
       (ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout)))
    {
        CLEANUPSTMT;

        BEGIN_TRANSACTION(pDbWkSpace);

        TLSDBLockLicenseTable();

        try {
            license.ucEntryStatus |= ucMarkFlags;

            dwStatus=TLSDBLicenseUpdateEntry( 
                             USEHANDLE(pDbWkSpace), 
                             LSLICENSE_SEARCH_MARK_FLAGS,
                             &license,
                             FALSE
                             );

        }
        catch(...) {
            dwStatus = TLS_E_INTERNAL;
        }

        TLSDBUnlockLicenseTable();

        if(TLS_ERROR(dwStatus))
        {
            ROLLBACK_TRANSACTION(pDbWkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWkSpace);

            InterlockedIncrement(&g_lLicensesMarked);
        }

        FREEDBHANDLE(pDbWkSpace);
    }
    else   
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
    }

cleanup:

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\license.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        license.c
//
// Contents:    
//          Routine related to License Table
//
// History:     12-09-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "clilic.h"
#include "globals.h"


void 
TLSDBLockLicenseTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Locking table LicenseTable\n")
        );

    LicensedTable::LockTable();
}

void 
TLSDBUnlockLicenseTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Unlocking table LicenseTable\n")
        );
            

    LicensedTable::UnlockTable();
}
    
/*************************************************************************
Function:
    LSDBLicenseEnumBegin()

Description:
    Begin a enumeration through license table based on search criterial

Arguments:
    IN CSQLStmt* - SQL handle to bind input parameter
    IN bMatchAll - TRUE if match all search criterial, FALSE otherwise.
    IN dwSearchParm - which column in License table to bind
    IN LPLSLicenseSearchParm - search value

Returns:
    ERROR_SUCCESS
    SQL error code.
*************************************************************************/
DWORD
TLSDBLicenseFind(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAllParm,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT lpSearch,
    IN OUT LPLICENSEDCLIENT lpFound
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(pDbWkSpace != NULL);
        return dwStatus;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;
    LICENSEDCLIENT found;

    bSuccess = licenseTable.FindRecord(
                        bMatchAllParm,
                        dwSearchParm,
                        *lpSearch,
                        (lpFound) ? *lpFound : found
                    );

    if(bSuccess == FALSE)
    {
        if(licenseTable.GetLastJetError() == JET_errRecordNotFound)
        {
            SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        }
        else
        {
            LPTSTR pString = NULL;
        
            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(
                    dwStatus = (SET_JB_ERROR(licenseTable.GetLastJetError()))
                );

            TLSASSERT(FALSE);
        }
    }

    return dwStatus;
}
    

//-----------------------------------------------------------------------
DWORD
TLSDBLicenseEnumBegin( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch
    )
/*++

--*/
{
    return TLSDBLicenseEnumBeginEx(
                pDbWkSpace,
                bMatchAll,
                dwSearchParm,
                lpSearch,
                JET_bitSeekGE
                );
}

//-----------------------------------------------------------------------
DWORD
TLSDBLicenseEnumBeginEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL   bMatchAll,
    IN DWORD  dwSearchParm,
    IN LPLICENSEDCLIENT  lpSearch,
    IN JET_GRBIT jet_seek_grbit
    )
/*++

--*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;
    
    bSuccess = licenseTable.EnumerateBegin(
                            bMatchAll,
                            dwSearchParm,
                            lpSearch,
                            jet_seek_grbit
                        );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(licenseTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licenseTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(
                dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError())
            );

        TLSASSERT(FALSE);
    }

    return dwStatus;
}        

/*************************************************************************
Function:
    LSDBLicenseEnumNext()

Description:
    Retrieve next record that match search criterial, must have
    call LSDBLicenseEnumBegin() to establish search criterial.

Arguments:
    IN CSQLStmt* - SQL handle to bind input parameter
    IN LPLSLicense - return record.
    IN LPLSHARDWARECHECKSUM - return hardware checksum value, see note

Returns:
    ERROR_SUCCESS
    SQL error code.
    HLS_I_NO_MORE_DATA      End of recordset.

Note:
    Hardware checksum column is consider internal and not exposed across
    RPC layer.
*************************************************************************/
DWORD
TLSDBLicenseEnumNext( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT LPLICENSEDCLIENT lplsLicense
    )
/*
*/
{
    return TLSDBLicenseEnumNextEx(
                pDbWkSpace,
                FALSE,
                FALSE,
                lplsLicense
                );
}

/*************************************************************************
Function:
    LSDBLicenseEnumNext()

Description:
    Retrieve next record that match search criterial, must have
    call LSDBLicenseEnumBegin() to establish search criterial.

Arguments:
    IN pDbWkSpace - Workspace to search in
    IN bReverse - search in reverse order
    IN bAnyRecord - don't do equality comparison if true
    IN LPLSLicense - return record.

Returns:
    ERROR_SUCCESS
    SQL error code.
    HLS_I_NO_MORE_DATA      End of recordset.

Note:
    Hardware checksum column is consider internal and not exposed across
    RPC layer.
*************************************************************************/
DWORD
TLSDBLicenseEnumNextEx( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bReverse,
    IN BOOL bAnyRecord,
    IN OUT LPLICENSEDCLIENT lplsLicense
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    if(pDbWkSpace == NULL || lplsLicense == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    try {
        LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
        BOOL bSuccess;

        switch(licenseTable.EnumerateNext(*lplsLicense,bReverse,bAnyRecord))
        {
            case RECORD_ENUM_ERROR:
                {
                    LPTSTR pString = NULL;
        
                    TLSGetESEError(licenseTable.GetLastJetError(), &pString);

                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_DBGENERAL,
                            TLS_E_JB_BASE,
                            licenseTable.GetLastJetError(),
                            (pString != NULL) ? pString : _TEXT("")
                        );

                    if(pString != NULL)
                    {
                        LocalFree(pString);
                    }
                }

                dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError());

                TLSASSERT(FALSE);
                break;

            case RECORD_ENUM_MORE_DATA:
                dwStatus = ERROR_SUCCESS;
                break;

            case RECORD_ENUM_END:
                dwStatus = TLS_I_NO_MORE_DATA;
                break;
        }
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch(...) {
        dwStatus = TLS_E_INTERNAL;
        TLSASSERT(FALSE);
    }

    return dwStatus;
}    

/*************************************************************************
Function:
    LSDBLicenseEnumEnd()

Description:
    Terminate a license table enumeration 

Arguments:
    IN CSQLStmt* - SQL handle

Returns:
    None
*************************************************************************/
void
TLSDBLicenseEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    licenseTable.EnumerateEnd();
    return;
}

//---------------------------------------------------------------------

DWORD
TLSDBLicenseAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense
    )
/*
*/
{
    TLSASSERT(pDbWkSpace != NULL && pLicense != NULL);

    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;
    TLSLicensedIndexMatchHwid dump(*pLicense);

    //
    // Check for duplicate entry - license ID
    //
    dwStatus = TLSDBLicenseFind(
                        pDbWkSpace,
                        TRUE,
                        LSLICENSE_SEARCH_LICENSEID,
                        pLicense,
                        NULL
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        SetLastError(dwStatus = TLS_E_DUPLICATE_RECORD);
        goto cleanup;
    }
    else if(dwStatus != TLS_E_RECORD_NOTFOUND)
    {
        goto cleanup;
    }

    dwStatus = ERROR_SUCCESS;    

    pLicense->dbLowerBound = dump.dbLowerBound;
    GetSystemTimeAsFileTime(&(pLicense->ftLastModifyTime));
    bSuccess = licenseTable.InsertRecord(*pLicense);

    if(bSuccess = FALSE)
    {
        if(licenseTable.GetLastJetError() == JET_errKeyDuplicate)
        {
            SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
        }
        else
        {
            LPTSTR pString = NULL;
        
            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }


            SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    };

cleanup:
    return dwStatus;
}

//---------------------------------------------------------------

DWORD
TLSDBLicenseDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bPointerOnRecord
    )
/*
*/
{
    TLSASSERT(pDbWkSpace != NULL && pLicense != NULL);

    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;


    bSuccess = licenseTable.DeleteAllRecord(
                            TRUE,
                            LSLICENSE_SEARCH_LICENSEID,
                            *pLicense
                        );

    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
        if(licenseTable.GetLastJetError() != JET_errRecordNotFound)
        {
            LPTSTR pString = NULL;
        
            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(licenseTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }

    return dwStatus;
}

DWORD
TLSDBDeleteEnumeratedLicense(
    IN PTLSDbWorkSpace pDbWkSpace
    )
{
    TLSASSERT(pDbWkSpace != NULL);

    DWORD dwStatus = ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL fSuccess;

    fSuccess = licenseTable.DeleteRecord();

    if (!fSuccess)
    {
        SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
        if(licenseTable.GetLastJetError() != JET_errRecordNotFound)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(licenseTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    licenseTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(licenseTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }

    return dwStatus;
}

//----------------------------------------------------------------

DWORD
TLSDBLicenseUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN LPLICENSEDCLIENT pLicense,
    IN BOOL bPointerOnRecord
    )
/*
*/
{
    TLSASSERT(pDbWkSpace != NULL && pLicense != NULL);

    DWORD dwStatus=ERROR_SUCCESS;
    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;
    BOOL bSuccess;


    if(bPointerOnRecord == FALSE)
    {
        //
        // Check for duplicate entry - license ID, position pointer
        // to record and prepare for update.
        //
        dwStatus = TLSDBLicenseFind(
                            pDbWkSpace,
                            TRUE,
                            LSLICENSE_SEARCH_LICENSEID,
                            pLicense,
                            NULL
                        );

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSASSERT(dwStatus == ERROR_SUCCESS);
            goto cleanup;
        }
    }
   
    GetSystemTimeAsFileTime(&(pLicense->ftLastModifyTime));
    bSuccess = licenseTable.UpdateRecord(
                            *pLicense, 
                            (dwUpdateParm & ~LSLICENSE_SEARCH_LICENSEID) | LICENSE_PROCESS_LASTMODIFYTIME
                        );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(licenseTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                licenseTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }


        SetLastError(dwStatus = SET_JB_ERROR(licenseTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

cleanup:
    
    return dwStatus;
}

//-----------------------------------------------------------------

DWORD
TLSDBLicenseSetValue( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwSetParm,
    IN LPLICENSEDCLIENT lpLicense,
    IN BOOL bPointerOnRecord
    )
/*
*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;

    if(pDbWkSpace == NULL || lpLicense == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    LicensedTable& licenseTable = pDbWkSpace->m_LicensedTable;

    TLSDBLockLicenseTable();

    if(lpLicense->ucLicenseStatus == LSLICENSESTATUS_DELETE)
    {
        dwStatus = TLSDBLicenseDeleteEntry(
                                    pDbWkSpace,
                                    lpLicense,
                                    bPointerOnRecord
                                );
    }
    else 
    {
        dwStatus = TLSDBLicenseUpdateEntry(
                                    pDbWkSpace,
                                    dwSetParm,
                                    lpLicense,
                                    bPointerOnRecord
                                );
    }

    TLSDBUnlockLicenseTable();
    return  dwStatus;                 
}

/*************************************************************************
Function:
    LSDBLicenseGetCert()

Description:
    Retrieve certificate issued to specific client

Arguments:
    IN CSQLStmt* - SQL handle
    IN dwLicenseId - License Id
    OUT cbCert - size of certificate
    OUT pbCert - certificate issued to client

Returns:
    ERROR_SUCCESS
    HLS_E_RECORD_NOTFOUND
    HLS_E_CORRUPT_DATABASE
    SQL error

Note:
    Must have valid LicenseId.
*************************************************************************/
DWORD
TLSDBLicenseGetCert( 
    IN PTLSDbWorkSpace pDbWorkSpace,
    IN DWORD dwLicenseId, 
    IN OUT PDWORD cbCert, 
    IN OUT PBYTE pbCert 
    )
/*
*/
{
    // unsupport function.
    TLSASSERT(FALSE);
    return TLS_E_INTERNAL;
}

/*************************************************************************
Function:
    LSDBLicenseAdd()

Description:
    Add an entry into license table

Arguments:
    IN CSQLStmt* - SQL handle
    IN LSLicense* - value to be inserted
    IN PHWID - hardware ID.
    IN cbLicense - size of certificate
    IN pbLicense - Pointer to certificate

Returns:
    ERROR_SUCCESS
    SQL error
*************************************************************************/
DWORD
TLSDBLicenseAdd(
    IN PTLSDbWorkSpace pDbWorkSpace,
    LPLICENSEDCLIENT pLicense, 
    DWORD cbLicense, 
    PBYTE pbLicense
    )
/*
*/
{
    if(pDbWorkSpace == NULL || pLicense == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    return TLSDBLicenseAddEntry(
                        pDbWorkSpace,
                        pLicense
                    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\lkpdesc.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        lkpdesc.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __LKPDESC_H__
#define __LKPDESC_H__
#include "server.h"

#ifdef __cplusplus
extern "C" {
#endif

void
TLSDBLockKeyPackDescTable();

void
TLSDBUnlockKeyPackDescTable();

DWORD 
TLSDBKeyPackDescEnumBegin(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAll, 
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD 
TLSDBKeyPackDescEnumNext(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PLICPACKDESC lpKeyPackDesc
);

DWORD 
TLSDBKeyPackDescEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
);

DWORD
TLSDBKeyPackDescAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescSetValue(
    PTLSDbWorkSpace pDbWkSpace, 
    DWORD dwSetParm, 
    PLICPACKDESC lpKeyPackDesc
);

DWORD
TLSDBKeyPackDescFind(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAllParam,        
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc,
    IN OUT PLICPACKDESC lpKeyPackDescFound
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\misc.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        misc.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __MISC_H__
#define __MISC_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

PMHANDLE
GenerateClientId();

void
TlsLicenseRequestToPMLicenseRequest(
    DWORD dwLicenseType,
    PTLSLICENSEREQUEST pTlsRequest,
    LPTSTR pszMachineName,
    LPTSTR pszUserName,
    DWORD dwSupportFlags,
    PPMLICENSEREQUEST pPmRequest
);

BOOL
TLSDBGetMaxKeyPackId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwKeyPackId
);

BOOL
TLSDBGetMaxLicenseId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwLicenseId
);

DWORD 
TLSDBGetNextKeyPackId();

DWORD
TLSDBGetNextLicenseId();

DWORD
TLSFormDBRequest(
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    DWORD dwProductVersion,
    LPTSTR pszCompanyName,
    LPTSTR pszProductId,
    DWORD dwLanguageId,
    DWORD dwPlatformId,
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
);

DWORD
TLSConvertRpcLicenseRequestToDbRequest( 
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    TLSLICENSEREQUEST* pRequest, 
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
);

BOOL
ConvertLsKeyPackToKeyPack(
    IN LPLSKeyPack lpLsKeyPack, 
    IN OUT PTLSLICENSEPACK lpLicPack,
    IN OUT PLICPACKDESC lpLicPackDesc
);

void
ConvertKeyPackToLsKeyPack(  
    IN PTLSLICENSEPACK lpLicPack,
    IN PLICPACKDESC lpLicPackDesc,
    IN OUT LPLSKeyPack lpLsKeyPack
);

void
ConvertLSLicenseToLicense(
    LPLSLicense lplsLicense, 
    LPLICENSEDCLIENT lpLicense
);

void
ConvertLicenseToLSLicense(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicense lplsLicense
);

void
ConvertLicenseToLSLicenseEx(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicenseEx lplsLicense
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\misc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        misc.cpp 
//
// Contents:    Misc. routines
//
// History:     
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#include "globals.h"
#include "misc.h"


//------------------------------------------------------------
PMHANDLE
GenerateClientId()
{
    return (PMHANDLE)ULongToPtr(GetCurrentThreadId());
}

//---------------------------------------------------------------------------

void
TlsLicenseRequestToPMLicenseRequest(
    DWORD dwLicenseType,
    PTLSLICENSEREQUEST pTlsRequest,
    LPTSTR pszMachineName,
    LPTSTR pszUserName,
    DWORD dwSupportFlags,
    PPMLICENSEREQUEST pPmRequest
    )
/*++

    Private routine.

++*/
{
    pPmRequest->dwLicenseType = dwLicenseType;
    pPmRequest->dwProductVersion = pTlsRequest->ProductInfo.dwVersion;
    pPmRequest->pszProductId = (LPTSTR)pTlsRequest->ProductInfo.pbProductID;
    pPmRequest->pszCompanyName = (LPTSTR) pTlsRequest->ProductInfo.pbCompanyName;
    pPmRequest->dwLanguageId = pTlsRequest->dwLanguageID;
    pPmRequest->dwPlatformId = pTlsRequest->dwPlatformID;
    pPmRequest->pszMachineName = pszMachineName;
    pPmRequest->pszUserName = pszUserName;
    pPmRequest->fTemporary = FALSE;
    pPmRequest->dwSupportFlags = dwSupportFlags;

    return;
}
    
//---------------------------------------------------------------------------
BOOL
TLSDBGetMaxKeyPackId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwKeyPackId
    )
/*
*/
{
    TLSLICENSEPACK keypack;

    SetLastError(ERROR_SUCCESS);

    // 
    if(pDbWkSpace == NULL || pdwKeyPackId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return GetLastError();
    }

    LicPackTable& licpackTable = pDbWkSpace->m_LicPackTable;

    // use primary index - internal keypack id
    if( licpackTable.EnumBegin() == FALSE ||
        licpackTable.MoveToRecord(JET_MoveLast) == FALSE)
    {
        if(licpackTable.GetLastJetError() == JET_errNoCurrentRecord)
        {
            *pdwKeyPackId = 0;
            goto cleanup;
        }
        else
        {
            SetLastError(SET_JB_ERROR(licpackTable.GetLastJetError()));
            goto cleanup;
        }
    }

    
    if(licpackTable.FetchRecord(keypack) == FALSE)
    {
        SetLastError(SET_JB_ERROR(licpackTable.GetLastJetError()));
        goto cleanup;
    }

    //FreeTlsLicensePack(&keypack);

    *pdwKeyPackId = keypack.dwKeyPackId;        

cleanup:
    return GetLastError() == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------

BOOL
TLSDBGetMaxLicenseId(
    PTLSDbWorkSpace pDbWkSpace,
    DWORD* pdwLicenseId
    )
/*
*/
{
    LICENSEDCLIENT licensed;

    SetLastError(ERROR_SUCCESS);

    // 
    if(pDbWkSpace == NULL || pdwLicenseId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return GetLastError();
    }

    LicensedTable& licensedTable = pDbWkSpace->m_LicensedTable;

    // use primary index - internal keypack id
    if( licensedTable.EnumBegin() == FALSE ||
        licensedTable.MoveToRecord(JET_MoveLast) == FALSE)
    {
        if(licensedTable.GetLastJetError() == JET_errNoCurrentRecord)
        {
            *pdwLicenseId = 0;
            goto cleanup;
        }
        else
        {
            SetLastError(SET_JB_ERROR(licensedTable.GetLastJetError()));
            goto cleanup;
        }
    }

    
    if(licensedTable.FetchRecord(licensed) == FALSE)
    {
        SetLastError(SET_JB_ERROR(licensedTable.GetLastJetError()));
        goto cleanup;
    }

    *pdwLicenseId = licensed.dwLicenseId;        

cleanup:
    return GetLastError() == ERROR_SUCCESS;
}



//+------------------------------------------------------------------------
//  Function: 
//      LSDBGetNextKeyPackId()
//
//  Description:
//      Return next available KeyPackId to be used in KeyPack table
//
//  Arguments:
//      None
//
//  Returns:
//      Key Pack Id
//
//  Notes:
//      Could use AUTO NUMBER column type but returning the value would be
//      more toublesome.
//
//  History:
//-------------------------------------------------------------------------
DWORD
TLSDBGetNextKeyPackId()
{
    LONG nextkeypack = InterlockedExchangeAdd(&g_NextKeyPackId, 1);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_ALLOCATELICENSE, 
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("GetNextKeyPack returns %d\n"), 
            nextkeypack
        );

    return nextkeypack;
}

//+------------------------------------------------------------------------
//  Function: 
//      LSDBGetNextLicenseId()
//
//  Abstract:
//      Return next available LicenseId to be used in License Table
//
//  Arguments:
//      None.
//
//  Returns:
//      Next available License Id
//
//  Notes:
//
//  History:
//-------------------------------------------------------------------------
DWORD 
TLSDBGetNextLicenseId()
{
    LONG nextlicenseid = InterlockedExchangeAdd(&g_NextLicenseId, 1);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_ALLOCATELICENSE, 
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("GetNextLicenseId returns %d\n"), 
            nextlicenseid
        );

    return nextlicenseid;
}  

//---------------------------------------------------------------------------
DWORD
TLSFormDBRequest(
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    DWORD dwProductVersion,
    LPTSTR pszCompanyName,
    LPTSTR pszProductId,
    DWORD dwLanguageId,
    DWORD dwPlatformId,
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
    )
/*++

++*/
{
    DWORD status;

    memset(pDbRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    // Decrypt HWID
    if(pbEncryptedHwid)
    {
        status=LicenseDecryptHwid(
                    &pDbRequest->hWid, 
                    cbEncryptedHwid,
                    pbEncryptedHwid,
                    g_cbSecretKey,
                    g_pbSecretKey);

        if(status != LICENSE_STATUS_OK)
        {
            return status;
        }
    }

    //
    // NOTE : No allocation of memory here...
    //
    pDbRequest->dwProductVersion = dwProductVersion;
    pDbRequest->pszCompanyName = pszCompanyName;
    pDbRequest->pszProductId = pszProductId;
    pDbRequest->dwLanguageID = dwLanguageId;
    pDbRequest->dwPlatformID = dwPlatformId;
    pDbRequest->pbEncryptedHwid = pbEncryptedHwid;
    pDbRequest->cbEncryptedHwid = cbEncryptedHwid;

    if(szClientMachine)
        _tcscpy(pDbRequest->szMachineName, szClientMachine);

    if(szUserName)
        _tcscpy(pDbRequest->szUserName, szUserName);

    pDbRequest->clientCertRdn.type = LSCERT_CLIENT_INFO_TYPE;
    pDbRequest->clientCertRdn.ClientInfo.szUserName = pDbRequest->szUserName;
    pDbRequest->clientCertRdn.ClientInfo.szMachineName = pDbRequest->szMachineName;
    pDbRequest->clientCertRdn.ClientInfo.pClientID = &pDbRequest->hWid;

    return ERROR_SUCCESS;
}

//---------------------------------------------------------------------------

DWORD
TLSConvertRpcLicenseRequestToDbRequest( 
    PBYTE pbEncryptedHwid,
    DWORD cbEncryptedHwid,
    TLSLICENSEREQUEST* pRequest, 
    LPTSTR szClientMachine, 
    LPTSTR szUserName, 
    LPTLSDBLICENSEREQUEST pDbRequest 
    )
/*++

++*/
{
    DWORD status;

    memset(pDbRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    // Decrypt HWID
    if(pbEncryptedHwid)
    {
        status=LicenseDecryptHwid(
                    &pDbRequest->hWid, 
                    cbEncryptedHwid,
                    pbEncryptedHwid,
                    g_cbSecretKey,
                    g_pbSecretKey);

        if(status != LICENSE_STATUS_OK)
        {
            return status;
        }
    }

    //
    // NOTE : No allocation of memory here...
    //

    // pDbRequest->pProductInfo = &(pRequest->ProductInfo);
    pDbRequest->dwProductVersion = pRequest->ProductInfo.dwVersion;
    pDbRequest->pszCompanyName = (LPTSTR)pRequest->ProductInfo.pbCompanyName;
    pDbRequest->pszProductId = (LPTSTR)pRequest->ProductInfo.pbProductID;


    pDbRequest->dwLanguageID = pRequest->dwLanguageID;
    pDbRequest->dwPlatformID = pRequest->dwPlatformID;
    pDbRequest->pbEncryptedHwid = pRequest->pbEncryptedHwid;
    pDbRequest->cbEncryptedHwid = pRequest->cbEncryptedHwid;

    if(szClientMachine)
        _tcscpy(pDbRequest->szMachineName, szClientMachine);

    if(szUserName)
        _tcscpy(pDbRequest->szUserName, szUserName);

    pDbRequest->clientCertRdn.type = LSCERT_CLIENT_INFO_TYPE;
    pDbRequest->clientCertRdn.ClientInfo.szUserName = pDbRequest->szUserName;
    pDbRequest->clientCertRdn.ClientInfo.szMachineName = pDbRequest->szMachineName;
    pDbRequest->clientCertRdn.ClientInfo.pClientID = &pDbRequest->hWid;

    return ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
ConvertLsKeyPackToKeyPack(
    IN LPLSKeyPack lpLsKeyPack, 
    IN OUT PTLSLICENSEPACK lpLicPack,
    IN OUT PLICPACKDESC lpLicPackDesc
    )
/*
Abstract:

    Convert LSKeyPack from client to internally use structure


Parameter:
    
    lpLsKeyPack - source value.
    lpLicPack - Target license pack.
    lpLicPackDesc - target license pack description
    
Return:

    None.    
*/
{
    if(lpLsKeyPack == NULL)
    {
        SetLastError(TLS_E_INVALID_DATA);
        return FALSE;
    }

    //
    // BUG 226875
    //
    DWORD dwBufSize;

    dwBufSize = sizeof(lpLsKeyPack->szCompanyName)/sizeof(lpLsKeyPack->szCompanyName[0]);
    lpLsKeyPack->szCompanyName[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szKeyPackId)/sizeof(lpLsKeyPack->szKeyPackId[0]);
    lpLsKeyPack->szKeyPackId[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szProductId)/sizeof(lpLsKeyPack->szProductId[0]);
    lpLsKeyPack->szProductId[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szProductDesc)/sizeof(lpLsKeyPack->szProductDesc[0]);
    lpLsKeyPack->szProductDesc[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szBeginSerialNumber)/sizeof(lpLsKeyPack->szBeginSerialNumber[0]);
    lpLsKeyPack->szBeginSerialNumber[dwBufSize - 1] = _TEXT('\0');

    dwBufSize = sizeof(lpLsKeyPack->szProductName)/sizeof(lpLsKeyPack->szProductName[0]);
    lpLsKeyPack->szProductName[dwBufSize - 1] = _TEXT('\0');

    if(lpLicPack)
    {
        memset(lpLicPack, 0, sizeof(TLSLICENSEPACK));
        lpLicPack->ucAgreementType = lpLsKeyPack->ucKeyPackType;
        SAFESTRCPY(lpLicPack->szCompanyName, lpLsKeyPack->szCompanyName);
        SAFESTRCPY(lpLicPack->szKeyPackId, lpLsKeyPack->szKeyPackId);
        SAFESTRCPY(lpLicPack->szProductId, lpLsKeyPack->szProductId);
        lpLicPack->wMajorVersion = lpLsKeyPack->wMajorVersion;
        lpLicPack->wMinorVersion = lpLsKeyPack->wMinorVersion;
        lpLicPack->dwPlatformType = lpLsKeyPack->dwPlatformType;
        lpLicPack->ucLicenseType = lpLsKeyPack->ucLicenseType;
        lpLicPack->ucChannelOfPurchase = lpLsKeyPack->ucChannelOfPurchase;
        SAFESTRCPY(lpLicPack->szBeginSerialNumber, lpLsKeyPack->szBeginSerialNumber);
        lpLicPack->dwTotalLicenseInKeyPack = lpLsKeyPack->dwTotalLicenseInKeyPack;
        lpLicPack->dwProductFlags = lpLsKeyPack->dwProductFlags;
        lpLicPack->dwKeyPackId = lpLsKeyPack->dwKeyPackId;
        lpLicPack->dwExpirationDate = lpLsKeyPack->dwExpirationDate;

        lpLicPack->dwKeyPackId = lpLsKeyPack->dwKeyPackId;
        lpLicPack->dwActivateDate = lpLsKeyPack->dwActivateDate;
        lpLicPack->dwExpirationDate = lpLsKeyPack->dwExpirationDate;
        lpLicPack->dwNumberOfLicenses = lpLsKeyPack->dwNumberOfLicenses;
        lpLicPack->ucKeyPackStatus = lpLsKeyPack->ucKeyPackStatus;
    }

    if(lpLicPackDesc)
    {
        lpLicPackDesc->dwKeyPackId = lpLsKeyPack->dwKeyPackId;
        lpLicPackDesc->dwLanguageId = lpLsKeyPack->dwLanguageId;
        SAFESTRCPY(lpLicPackDesc->szCompanyName, lpLsKeyPack->szCompanyName);
        SAFESTRCPY(lpLicPackDesc->szProductName, lpLsKeyPack->szProductName);
        SAFESTRCPY(lpLicPackDesc->szProductDesc, lpLsKeyPack->szProductDesc);
    }        

    return TRUE;
}

//-----------------------------------------------------------
void
ConvertKeyPackToLsKeyPack(  
    IN PTLSLICENSEPACK lpLicPack,
    IN PLICPACKDESC lpLicPackDesc,
    IN OUT LPLSKeyPack lpLsKeyPack
    )
/*
Abstract:

    Combine internally used license pack structure into one for 
    return back to RPC client

Parameter:

    lpLicPack  - source
    lpLicPackStatus - source
    lpLicPackDesc - source
    lpLsKeyPack - target 
    
Return:

    None.

*/
{
    if(lpLicPack)
    {
        lpLsKeyPack->ucKeyPackType = lpLicPack->ucAgreementType;
        SAFESTRCPY(lpLsKeyPack->szCompanyName, lpLicPack->szCompanyName);
        SAFESTRCPY(lpLsKeyPack->szKeyPackId, lpLicPack->szKeyPackId);
        SAFESTRCPY(lpLsKeyPack->szProductId, lpLicPack->szProductId);
        lpLsKeyPack->wMajorVersion = lpLicPack->wMajorVersion;
        lpLsKeyPack->wMinorVersion = lpLicPack->wMinorVersion;
        lpLsKeyPack->dwPlatformType = lpLicPack->dwPlatformType;
        lpLsKeyPack->ucLicenseType = lpLicPack->ucLicenseType;
        lpLsKeyPack->ucChannelOfPurchase = lpLicPack->ucChannelOfPurchase;
        SAFESTRCPY(lpLsKeyPack->szBeginSerialNumber, lpLicPack->szBeginSerialNumber);
        lpLsKeyPack->dwTotalLicenseInKeyPack = lpLicPack->dwTotalLicenseInKeyPack;
        lpLsKeyPack->dwProductFlags = lpLicPack->dwProductFlags;
        lpLsKeyPack->dwKeyPackId = lpLicPack->dwKeyPackId;

        lpLsKeyPack->ucKeyPackStatus = lpLicPack->ucKeyPackStatus;
        lpLsKeyPack->dwActivateDate = lpLicPack->dwActivateDate;
        lpLsKeyPack->dwExpirationDate = lpLicPack->dwExpirationDate;
        lpLsKeyPack->dwNumberOfLicenses = lpLicPack->dwNumberOfLicenses;
    }

    if(lpLicPackDesc)
    {
        lpLsKeyPack->dwKeyPackId = lpLicPackDesc->dwKeyPackId;
        lpLsKeyPack->dwLanguageId = lpLicPackDesc->dwLanguageId;
        SAFESTRCPY(lpLsKeyPack->szCompanyName, lpLicPackDesc->szCompanyName);
        SAFESTRCPY(lpLsKeyPack->szProductName, lpLicPackDesc->szProductName);
        SAFESTRCPY(lpLsKeyPack->szProductDesc, lpLicPackDesc->szProductDesc);
    }        

    return;
}

//-----------------------------------------------------------------------
void
ConvertLSLicenseToLicense(
    LPLSLicense lplsLicense, 
    LPLICENSEDCLIENT lpLicense
)
/*
*/
{
    lpLicense->dwLicenseId = lplsLicense->dwLicenseId;
    lpLicense->dwKeyPackId = lplsLicense->dwKeyPackId;

    memset(lpLicense->szMachineName, 0, sizeof(lpLicense->szMachineName));
    memset(lpLicense->szUserName, 0, sizeof(lpLicense->szUserName));

    //SAFESTRCPY(lpLicense->szMachineName, lplsLicense->szMachineName);

    _tcsncpy(
            lpLicense->szMachineName, 
            lplsLicense->szMachineName, 
            sizeof(lpLicense->szMachineName)/sizeof(lpLicense->szMachineName[0]) - 1
        );


    //SAFESTRCPY(lpLicense->szUserName, lplsLicense->szUserName);
    _tcsncpy(
            lpLicense->szUserName, 
            lplsLicense->szUserName, 
            sizeof(lpLicense->szUserName)/sizeof(lpLicense->szUserName[0]) - 1
        );

    lpLicense->ftIssueDate = lplsLicense->ftIssueDate;
    lpLicense->ftExpireDate = lplsLicense->ftExpireDate;
    lpLicense->ucLicenseStatus = lplsLicense->ucLicenseStatus;

    //
    // not expose to client
    //
    lpLicense->dwNumLicenses = 0;
    return;
}

//-----------------------------------------------------------------------
void
ConvertLicenseToLSLicense(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicense lplsLicense
)
/*
*/
{
    lplsLicense->dwLicenseId = lpLicense->dwLicenseId;
    lplsLicense->dwKeyPackId = lpLicense->dwKeyPackId;
    SAFESTRCPY(lplsLicense->szMachineName, lpLicense->szMachineName);
    SAFESTRCPY(lplsLicense->szUserName, lpLicense->szUserName);
    lplsLicense->ftIssueDate = lpLicense->ftIssueDate;
    lplsLicense->ftExpireDate = lpLicense->ftExpireDate;
    lplsLicense->ucLicenseStatus = lpLicense->ucLicenseStatus;
   
    return;
}

//-----------------------------------------------------------------------
void
ConvertLicenseToLSLicenseEx(
    LPLICENSEDCLIENT lpLicense, 
    LPLSLicenseEx lplsLicense
)
/*
*/
{
    lplsLicense->dwLicenseId = lpLicense->dwLicenseId;
    lplsLicense->dwKeyPackId = lpLicense->dwKeyPackId;
    SAFESTRCPY(lplsLicense->szMachineName, lpLicense->szMachineName);
    SAFESTRCPY(lplsLicense->szUserName, lpLicense->szUserName);
    lplsLicense->ftIssueDate = lpLicense->ftIssueDate;
    lplsLicense->ftExpireDate = lpLicense->ftExpireDate;
    lplsLicense->ucLicenseStatus = lpLicense->ucLicenseStatus;
    lplsLicense->dwQuantity = lpLicense->dwNumLicenses;
   
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\lkpdesc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kpDesc.cpp
//
// Contents:    
//              KeyPackDesc Table related function.
//
// History:     
//          Feb. 4, 98      HueiWang        Created.
//
// Note :
//      Bind Parameter and Bind Column need to to in sync with select column
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "lkpdesc.h"
#include "globals.h"


//---------------------------------------------------------------------------
//  Functions : LSDBLockKeyPackDescTable()
//              LSDBUnlockKeyPackDescTable()
//
//  Abstract : Lock and Unlock single access to key pack desc. table.
//---------------------------------------------------------------------------
void
TLSDBLockKeyPackDescTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Locking table KeyPackDescTable\n")
        );
            

    LicPackDescTable::LockTable();
    return;
}

void
TLSDBUnlockKeyPackDescTable()
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_LOCK,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Unlocking table KeyPackDescTable\n")
        );

    LicPackDescTable::UnlockTable();
    return;
}

//++--------------------------------------------------------------------
DWORD 
TLSDBKeyPackDescEnumBegin(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAll, 
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Begin enumeration of license pack description table.

Parameters:

    pDbWkSpace : Workspace handle.
    bMatchAll : TRUE if matching all license pack 
                description search value, FALSE otherwise
    dwSearchParam : Field that will be search on.
    lpKeyPackDesc : value to be search, subject to bMatchAll criteral

Returns:

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL  bSuccess=TRUE;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    bSuccess = pDbWkSpace->m_LicPackDescTable.EnumerateBegin(
                                                    bMatchAll, 
                                                    dwSearchParm, 
                                                    lpKeyPackDesc
                                                );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(
                    pDbWkSpace->m_LicPackDescTable.GetLastJetError(), 
                    &pString
                );

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                pDbWkSpace->m_LicPackDescTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackDescTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

    return dwStatus;
}

//++----------------------------------------------------------------------
DWORD 
TLSDBKeyPackDescEnumNext(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN OUT PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:    

    Fetch next record in LicPackDesc table that match search condition.

Parameter:

    pDbWkSpace : Workspace handle.
    lpKeyPackDesc : return record that match search condition.

Returns:

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    switch(pDbWkSpace->m_LicPackDescTable.EnumerateNext(*lpKeyPackDesc))
    {
        case RECORD_ENUM_ERROR:
            {
                LPTSTR pString = NULL;
    
                TLSGetESEError(
                            pDbWkSpace->m_LicPackDescTable.GetLastJetError(), 
                            &pString
                        );

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        pDbWkSpace->m_LicPackDescTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }
            }

            dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackDescTable.GetLastJetError());
            TLSASSERT(FALSE);
            break;

        case RECORD_ENUM_MORE_DATA:
            dwStatus = ERROR_SUCCESS;
            break;

        case RECORD_ENUM_END:
            dwStatus = TLS_I_NO_MORE_DATA;
    }
            
    return dwStatus;
}

//++-----------------------------------------------------------------------
DWORD 
TLSDBKeyPackDescEnumEnd(
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*++
Abstract:

    End enumeration of LicPackDesc. table

Parameter:

    pdbWkSpace : Workspace handle.

Returns:

++*/
{
    pDbWkSpace->m_LicPackDescTable.EnumerateEnd();
    return ERROR_SUCCESS;
}

//++-----------------------------------------------------------------------
DWORD
TLSDBKeyPackDescAddEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Add a record into licensepackdesc table.

Parameter:

    pDbWkSpace : workspace handle.
    lpKeyPackDesc : record to be added into table.

Returns:
   

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;

    //
    // Check for duplicate entry
    //
    dwStatus = TLSDBKeyPackDescFind(
                            pDbWkSpace,
                            TRUE,
                            LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID | LICPACKDESCRECORD_TABLE_SEARCH_LANGID, 
                            lpKeyPackDesc,
                            NULL
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        SetLastError(dwStatus = TLS_E_DUPLICATE_RECORD);
        goto cleanup;
    }
    else if(dwStatus != TLS_E_RECORD_NOTFOUND)
    {
        goto cleanup;
    }
    SetLastError(dwStatus = ERROR_SUCCESS);
    if(kpDescTable.InsertRecord(*lpKeyPackDesc) == FALSE)
    {
        if(kpDescTable.GetLastJetError() == JET_errKeyDuplicate)
        {
            SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
        }
        else
        {
            LPTSTR pString = NULL;
    
            TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    kpDescTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(dwStatus = SET_JB_ERROR(kpDescTable.GetLastJetError()));
            TLSASSERT(FALSE);
        }
    }

cleanup:
    
    return dwStatus;
}

//++------------------------------------------------------------------------
DWORD
TLSDBKeyPackDescDeleteEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Delete all record from LicPackDesc table that match the keypack id

Parameter:

    pDbWkSpace : workspace handle.
    lpKeyPackDesc : keypack Id to be deleted

Returns:

*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;
    BOOL bSuccess;

    bSuccess = kpDescTable.DeleteAllRecord(
                                    TRUE, 
                                    LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID, 
                                    *lpKeyPackDesc
                                );

    if( bSuccess == FALSE )
    {
        SetLastError(dwStatus = SET_JB_ERROR(kpDescTable.GetLastJetError()));

        // ignore record not found error
        if(kpDescTable.GetLastJetError() != JET_errRecordNotFound)
        {
            LPTSTR pString = NULL;
    
            TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    kpDescTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            TLSASSERT(kpDescTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }

    return dwStatus;
}

//++------------------------------------------------------------------------
DWORD
TLSDBKeyPackDescUpdateEntry(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN DWORD dwUpdateParm,
    IN PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Update column value of record in LicPackDescTable that match 
    the keypackid

Parameter:

    pDbWkSpace : Work space handle.
    dwUpdateParm : Fields that will be updated, note, keypack ID and language ID
                   can't be update.
    lpKeyPackDesc : Record/value to be update

Returns:


Note:

    dwKeyPackId and dwLangId can't be update.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;
    BOOL bSuccess;

    //
    // Check for duplicate entry
    //
    dwStatus = TLSDBKeyPackDescFind(
                            pDbWkSpace,
                            TRUE,
                            LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID | LICPACKDESCRECORD_TABLE_SEARCH_LANGID, 
                            lpKeyPackDesc,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSASSERT(dwStatus == ERROR_SUCCESS);
        goto cleanup;
    }

    
    bSuccess = kpDescTable.UpdateRecord(
                            *lpKeyPackDesc, 
                            dwUpdateParm & ~(LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID | LICPACKDESCRECORD_TABLE_SEARCH_LANGID)
                        );

    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;
    
        TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BASE,
                kpDescTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        SetLastError(dwStatus = SET_JB_ERROR(kpDescTable.GetLastJetError()));
        TLSASSERT(FALSE);
    }

cleanup:
    
    return dwStatus;
}

//++----------------------------------------------------------------------
DWORD
TLSDBKeyPackDescSetValue(
    PTLSDbWorkSpace pDbWkSpace, 
    DWORD dwSetParm, 
    PLICPACKDESC lpKeyPackDesc
    )
/*++
Abstract:

    Add/Delete/Update a record in LicPackDescTable.

Parameter:

    pDbWkSpace : workspace handle.
    dwSetParm : Columns to be update.
    lpKeyPackDesc : record/value to be update/delete/add.

Return:


Note:
    Wrapper around TLSDBKeyPackDescDeleteEntry(),
    TLSDBKeyPackDescAddEntry(), TLSDBKeyPackDescUpdateEntry()
    base on dwSetParm value.
++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(pDbWkSpace == NULL || lpKeyPackDesc == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    TLSDBLockKeyPackDescTable();

    if(dwSetParm & KEYPACKDESC_SET_DELETE_ENTRY)
    {
        dwStatus = TLSDBKeyPackDescDeleteEntry(
                                        pDbWkSpace,
                                        lpKeyPackDesc
                                    );
    }
    else if(dwSetParm & KEYPACKDESC_SET_ADD_ENTRY)
    {
        dwStatus = TLSDBKeyPackDescAddEntry(
                                        pDbWkSpace,
                                        lpKeyPackDesc
                                    );
    }
    else
    {
        dwStatus = TLSDBKeyPackDescUpdateEntry(
                                        pDbWkSpace,
                                        dwSetParm,
                                        lpKeyPackDesc
                                    );
    }

    TLSDBUnlockKeyPackDescTable();

cleanup:
    return dwStatus;
}

//++---------------------------------------------------------------------
DWORD
TLSDBKeyPackDescFind(
    IN PTLSDbWorkSpace pDbWkSpace, 
    IN BOOL bMatchAllParam,        
    IN DWORD dwSearchParm, 
    IN PLICPACKDESC lpKeyPackDesc,
    IN OUT PLICPACKDESC lpKeyPackDescFound
    )
/*
Abstract:

    Find a LicPackDesc record based on search parameters.

Parameter:

    pDbWkSpace - workspace handle.
    bMatchAllParam - TRUE match all search parameters, FALSE otherwise.
    dwSearchParam - Fields that will participate in search.
    lpKeyPackDesc - value to be search.
    lpKeyPackDescFound - return found record.

Returns:


Note:

*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;
    LICPACKDESC kpDescFound;

    if(pDbWkSpace == NULL || lpKeyPackDesc == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(pDbWkSpace != NULL);
        return dwStatus;
    }

    LicPackDescTable& kpDescTable = pDbWkSpace->m_LicPackDescTable;

    bSuccess = kpDescTable.FindRecord(
                                bMatchAllParam,
                                dwSearchParm,
                                *lpKeyPackDesc,
                                kpDescFound
                            );

    if(bSuccess != TRUE)
    {
        if(kpDescTable.GetLastJetError() == JET_errRecordNotFound)
        {
            SetLastError(dwStatus = TLS_E_RECORD_NOTFOUND);
        }
        else
        {
            LPTSTR pString = NULL;
    
            TLSGetESEError(kpDescTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BASE,
                    kpDescTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            SetLastError(
                    dwStatus = (SET_JB_ERROR(kpDescTable.GetLastJetError()))
                );

            TLSASSERT(kpDescTable.GetLastJetError() == JET_errRecordNotFound);
        }
    }
    else
    {
        if(lpKeyPackDescFound != NULL) 
        {
            *lpKeyPackDescFound = kpDescFound;
        }
    }
            
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\mailslot.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        mailslot.cpp
//
// Contents:    
//
// History:     
//
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <tchar.h>
#include <process.h>
#include "lscommon.h"
#include "debug.h"
#include "globals.h"



typedef DWORD (* LSPROTOCOLHANDLER)(DWORD cbData, PBYTE pbData);

typedef struct _ProtocolFuncMapper {
    LPTSTR szProtocol;
    LSPROTOCOLHANDLER func;
} ProtocolFuncMapper;

DWORD HandleDiscovery( DWORD cbData, PBYTE pbData );
DWORD HandleChallenge( DWORD cbData, PBYTE pbData );   

ProtocolFuncMapper pfm[] = { 
    {_TEXT(LSERVER_DISCOVERY), HandleDiscovery}, 
    {_TEXT(LSERVER_CHALLENGE), HandleChallenge}
};

DWORD dwNumProtocol=sizeof(pfm) / sizeof(pfm[0]);


//--------------------------------------------------------------------

DWORD 
HandleDiscovery( 
    DWORD cbData, 
    PBYTE pbData 
    )
/*++


++*/
{
    TCHAR szDiscMsg[MAX_MAILSLOT_MSG_SIZE+1];
    TCHAR szPipeName[MAX_MAILSLOT_MSG_SIZE+20];
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH+1;
    
    DWORD byteWritten = 0;
    LPTSTR pClientName;
    LPTSTR pMailSlot;
    LPTSTR ePtr;
    DWORD dwStatus=ERROR_SUCCESS;
    HANDLE hSlot = INVALID_HANDLE_VALUE;

    if(cbData >= sizeof(szDiscMsg)-sizeof(TCHAR))
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    //
    // Prevent no NULL terminated input
    //
    memset(szDiscMsg, 0, sizeof(szDiscMsg));
    memcpy(szDiscMsg, pbData, cbData);

    GetComputerName(szComputerName, &cbComputerName);
    do {
        //
        // Extract client machine name
        //
        pClientName=_tcschr(szDiscMsg, _TEXT(LSERVER_OPEN_BLK));
        if(pClientName == NULL)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find beginning client name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        pClientName = _tcsinc(pClientName);

        ePtr=_tcschr(pClientName, _TEXT(LSERVER_CLOSE_BLK));
        if(ePtr == NULL)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find ending client name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        *ePtr = _TEXT('\0');

        //
        // Extract Mailslot name
        //
        ePtr = _tcsinc(ePtr);
        
        pMailSlot = _tcschr(ePtr, _TEXT(LSERVER_OPEN_BLK));
        if(pMailSlot == NULL)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find beginning mailslot name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        pMailSlot = _tcsinc(pMailSlot);

        ePtr=_tcschr(pMailSlot, _TEXT(LSERVER_CLOSE_BLK));
        if(ePtr == NULL)
        {

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Can't find ending mailslot name\n")
                );                

            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        *ePtr = _TEXT('\0');
        

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("response to client %s, %s\n"),
                pClientName,
                pMailSlot
            );                

        //
        // Do not response to "*"
        //
        if(_tcsicmp(pClientName, _TEXT("*")) == 0)
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        if (lstrlen(pClientName) + lstrlen(pMailSlot) + 13 > sizeof(szPipeName) / sizeof(TCHAR))
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Open client side mailslot
        //
        wsprintf(
                szPipeName, 
                _TEXT("\\\\%s\\mailslot\\%s"), 
                pClientName, 
                pMailSlot
            );

        hSlot = CreateFile(
                        szPipeName,
                        GENERIC_WRITE,             // only need write
                        FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                    );
        if(hSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("CreateFile %s failed with %d\n"),
                    szPipeName,
                    dwStatus
                );                
            break;
        }

        //
        // Write our computername to client side mailslot
        //  
        if(!WriteFile(hSlot, szComputerName, (_tcslen(szComputerName)+1)*sizeof(TCHAR), &byteWritten, NULL) || 
           byteWritten != (_tcslen(szComputerName)+1)*sizeof(TCHAR) )
        {
            dwStatus = GetLastError();

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Write to %s failed with %d\n"),
                    szPipeName,
                    dwStatus
                );                
        }
    } while(FALSE);

    if(hSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hSlot);
    }

    return dwStatus;
}    
    
//--------------------------------------------------------------------            
               
DWORD 
HandleChallenge( 
    DWORD cbData, 
    PBYTE pbData 
    )    
/*++

++*/
{
    return ERROR_SUCCESS;
}

//---------------------------------------------------------------------
unsigned int WINAPI
MailSlotThread(void* ptr)
{
    HANDLE hEvent=(HANDLE) ptr;
    DWORD dwStatus=ERROR_SUCCESS;
    HANDLE hSlot=INVALID_HANDLE_VALUE;
    DWORD cbToRead;
    TCHAR szMailSlotName[MAX_PATH+1];
    TCHAR szMessage[MAX_MAILSLOT_MSG_SIZE+1];
    BOOL fResult=TRUE;

    do {
        //
        // Create the mail slot
        //
        wsprintf(
                szMailSlotName, 
                _TEXT("\\\\.\\mailslot\\%s"), 
                _TEXT(SERVERMAILSLOTNAME)
            );

        hSlot=CreateMailslot( 
                            szMailSlotName, 
                            MAX_MAILSLOT_MSG_SIZE,
                            MAILSLOT_WAIT_FOREVER,
                            NULL //&SecurityAttributes
                        );
        if(hSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus=GetLastError();
            break;
        }

        //
        // Signal mail thread we are ready
        //
        SetEvent(hEvent);

        DBGPrintf(
                DBG_INFORMATION,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                DBG_ALL_LEVEL,
                _TEXT("Mailslot : ready...\n")
            );                


        //
        // Forever loop
        //
        while(dwStatus == ERROR_SUCCESS)
        {
            memset(szMessage, 0, sizeof(szMessage));

            //
            // Wait on the Slot - TODO consider using IO completion port.
            // 
            fResult=ReadFile( 
                            hSlot, 
                            szMessage, 
                            sizeof(szMessage) - sizeof(TCHAR), 
                            &cbToRead, 
                            NULL
                        );

            if(!fResult)
            {
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_RPC,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Mailslot : read failed %d\n"),
                        GetLastError()
                    );                

                continue;
            }

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Mailslot : receive message %s\n"),
                    szMessage
                );                

            //
            // Process Message
            //
            for(int i=0; i < dwNumProtocol; i++)
            {
                if(!_tcsnicmp(szMessage, pfm[i].szProtocol, _tcslen(pfm[i].szProtocol)))
                {
                    (pfm[i].func)( ((DWORD)_tcslen(szMessage) - (DWORD)_tcslen(pfm[i].szProtocol))*sizeof(TCHAR), 
                                   (PBYTE)(szMessage + _tcslen(pfm[i].szProtocol)) );
                }
            }
        }
            
    } while (FALSE);
    

    if(hSlot != INVALID_HANDLE_VALUE)
        CloseHandle(hSlot);
    
    //
    // Mail thread will close the event handle
    //

    ExitThread(dwStatus);
    return dwStatus;
}


//---------------------------------------------------------------------
DWORD
InitMailSlotThread()
/*++

++*/
{
    HANDLE hThread = NULL;
    unsigned int  dwThreadId;
    HANDLE hEvent = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE waithandles[2];


    //
    // Create a event for namedpipe thread to signal it is ready.
    //
    hEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,  // non-signal
                        NULL
                    );
        
    if(hEvent == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hThread = (HANDLE)_beginthreadex(
                                NULL,
                                0,
                                MailSlotThread,
                                hEvent,
                                0,
                                &dwThreadId
                            );

    if(hThread == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    waithandles[0] = hEvent;
    waithandles[1] = hThread;
    
    //
    // Wait 30 second for thread to complet initialization
    //
    dwStatus = WaitForMultipleObjects(
                                sizeof(waithandles)/sizeof(waithandles[0]), 
                                waithandles, 
                                FALSE,
                                30*1000
                            );

    if(dwStatus == WAIT_OBJECT_0)
    {    
        //
        // thread is ready
        //
        dwStatus = ERROR_SUCCESS;
    }
    else 
    {
        if(dwStatus == (WAIT_OBJECT_0 + 1))
        {
            //
            // Thread terminate abnormally
            //
            GetExitCodeThread(
                        hThread,
                        &dwStatus
                    );
        }
        else
        {
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        }
    }
    

cleanup:

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hThread != NULL)
    {
        CloseHandle(hThread);
    }


    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\permlic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        permlic.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __PERMLIC_H__
#define __PERMLIC_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD
TLSDBIssuePermanentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bLatestVersion,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
);

DWORD
TLSDBReissuePermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
);

DWORD
TLSDBReissueFoundPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
);

DWORD
TLSDBGetPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN BOOL bLatestVersion,
    IN OUT PTLSLICENSEPACK pLicensePack
);

void
TLSResetLogLowLicenseWarning(
    IN LPTSTR pszCompanyName,
    IN LPTSTR pszProductId,
    IN DWORD dwProductVersion,
    IN BOOL bLogged
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1997
//
// File:        pch.cpp
//
// Contents:    Hydra License Server Precompiled Header
//
//---------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <process.h>
#include <rpc.h>
#include <shellapi.h>
#include <wincrypt.h>
#include <new.h>
#include <eh.h>
#include "resource.h"

//
// include for all license project
//
#include "license.h"
#include "certutil.h"



//
// Backward compatible
//
#include "hydrals.h"

#include "utils.h"
#include "locks.h"
#include "hpool.h"


//
// TLSDb
//
#include "JBDef.h"
#include "JetBlue.h"
#include "TLSDb.h"

#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"

// 
// Current RPC interface
//
#include "tlsrpc.h"
#include "tlsdef.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "tlspol.h"

//
//
#include "messages.h"

#include "tlsassrt.h"
#include "trust.h"
#include "svcrole.h"
#include "secstore.h"
#include "common.h"
#include "lscommon.h"

#include "Cryptkey.h"
#include "licekpak.h"
#include "base64.h"
#include "licecert.h"



#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\permlic.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        permlic.cpp
//
// Contents:    
//              Issue perm. license to client
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "permlic.h"
#include "misc.h"
#include "db.h"
#include "clilic.h"
#include "findlost.h"
#include <winsta.h>

DWORD
GenerateRandomNumber(
    IN  DWORD   Seed
    );

void
LicensedProductToDbLicensedProduct(
    PLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    );

void
CopyDbLicensedProduct(
    PTLSDBLICENSEDPRODUCT pSrc,
    PTLSDBLICENSEDPRODUCT pDest
    );

//-------------------------------------------------------------------------

//
// Memory leak at service shutdown time
//
typedef struct __LoggedLowLicenseProduct {
    LPTSTR pszCompanyName;
    LPTSTR pszProductId;
    DWORD dwProductVersion;

    __LoggedLowLicenseProduct() : pszProductId(NULL), pszCompanyName(NULL) {};

    friend bool 
    operator<(
            const __LoggedLowLicenseProduct&, 
            const __LoggedLowLicenseProduct&
    );

} LoggedLowLicenseProduct;

//-------------------------------------------------------------------------
inline bool
operator<(
    const __LoggedLowLicenseProduct& a, 
    const __LoggedLowLicenseProduct& b
    )
/*++

--*/
{
    bool bStatus;

    TLSASSERT(a.pszCompanyName != NULL && b.pszCompanyName != NULL);
    TLSASSERT(a.pszProductId != NULL && b.pszProductId != NULL);

    // in case we mess up...
    if(a.pszProductId == NULL || a.pszCompanyName == NULL)
    {
        bStatus = TRUE;
    }
    else if(b.pszProductId == NULL || b.pszCompanyName == NULL)
    {
        bStatus = FALSE;
    }
    else
    {
        bStatus = (_tcsicmp(a.pszCompanyName, b.pszCompanyName) < 0);

        if(bStatus == TRUE)
        {
            bStatus = (_tcsicmp(a.pszProductId, b.pszProductId) < 0);
        }

        if(bStatus == TRUE)
        {
            bStatus = (CompareTLSVersions(a.dwProductVersion, b.dwProductVersion) < 0);
        }
    }

    return bStatus;
}

//-------------------------------------------------------------------------
typedef map<
            LoggedLowLicenseProduct, 
            BOOL, 
            less<LoggedLowLicenseProduct> 
    > LOGLOWLICENSEMAP;

static CCriticalSection LogLock;
static LOGLOWLICENSEMAP LowLicenseLog;


//---------------------------------------------------------------
void
TLSResetLogLowLicenseWarning(
    IN LPTSTR pszCompanyName,
    IN LPTSTR pszProductId,
    IN DWORD dwProductVersion,
    IN BOOL bLogged
    )
/*++

--*/
{
    LOGLOWLICENSEMAP::iterator it;
    LoggedLowLicenseProduct product;

    product.pszCompanyName = pszCompanyName;
    product.pszProductId = pszProductId;
    product.dwProductVersion = dwProductVersion;

    LogLock.Lock();

    try {
        it = LowLicenseLog.find(product);
        if(it != LowLicenseLog.end())
        {
            // reset to not logged warning yet.
            (*it).second = bLogged;
        }
        else if(bLogged == TRUE)
        {
            memset(&product, 0, sizeof(product));

            // memory leak here at service stop.
            product.pszProductId = _tcsdup(pszProductId);
            product.pszCompanyName = _tcsdup(pszCompanyName);
            product.dwProductVersion = dwProductVersion;

            if(product.pszProductId != NULL && product.pszCompanyName != NULL)
            {
                LowLicenseLog[product] = TRUE;
            }
            else
            {
                // if unable to allocate any more memory, log message every time
                if(product.pszProductId != NULL)
                {
                    free(product.pszProductId);
                }

                if(product.pszCompanyName != NULL)
                {
                    free(product.pszCompanyName);
                }
            }
        }
    } 
    catch(...) {
    }
        
    LogLock.UnLock();

    return;
}

//---------------------------------------------------------------

void
TLSLogLowLicenseWarning(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bNoLicense
    )
/*++

Abstract:

    Log an low license count warning.

Parameter:

    pDbWkSpace - Workspace handle.
    pRequest - License Request.
    Workspace - No license available.
    LicensePack - License pack that is out of license

return:

    None
    
--*/
{
    LOGLOWLICENSEMAP::iterator it;
    BOOL bWarningLogged = FALSE;
    DWORD dwStatus;


    if( pRequest == NULL || pRequest->pClientLicenseRequest == NULL || 
        pRequest->pClientLicenseRequest->pszProductId == NULL )
    {
        TLSASSERT(FALSE);
        return;
    }

    LoggedLowLicenseProduct product;

    product.pszProductId = pRequest->pClientLicenseRequest->pszProductId;
    product.pszCompanyName = pRequest->pClientLicenseRequest->pszCompanyName;
    product.dwProductVersion = pRequest->pClientLicenseRequest->dwProductVersion;

    LogLock.Lock();

    try {
        // see if we already log this warning message
        it = LowLicenseLog.find(product);
        if(it == LowLicenseLog.end())
        {
            memset(&product, 0, sizeof(product));

            // memory leak here at service stop.
            product.pszProductId = _tcsdup(pRequest->pClientLicenseRequest->pszProductId);
            product.pszCompanyName = _tcsdup(pRequest->pClientLicenseRequest->pszCompanyName);
            product.dwProductVersion = pRequest->pClientLicenseRequest->dwProductVersion;

            if(product.pszProductId != NULL && product.pszCompanyName != NULL)
            {
                LowLicenseLog[product] = TRUE;
            }
            else
            {
                // if unable to allocate any more memory, log message every time
                if(product.pszProductId != NULL)
                {
                    free(product.pszProductId);
                }

                if(product.pszCompanyName != NULL)
                {
                    free(product.pszCompanyName);
                }
            }
        }
        else
        {
            bWarningLogged = (*it).second;
            (*it).second = TRUE;
        }
    } 
    catch(...) {
        // assuming no message has been logged.
        bWarningLogged = FALSE;
    }
        
    LogLock.UnLock();

    if(bWarningLogged == TRUE)
    {
        return;
    }

    //
    // ask policy module if they have description
    //
    PMKEYPACKDESCREQ kpDescReq;
    PPMKEYPACKDESC pKpDesc;

    //
    // Ask for default system language ID
    //
    kpDescReq.pszProductId = pRequest->pszProductId;
    kpDescReq.dwLangId = GetSystemDefaultLangID();
    kpDescReq.dwVersion = pRequest->dwProductVersion;
    pKpDesc = NULL;

    dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                            pRequest->hClient,
                                            REQUEST_KEYPACKDESC,
                                            (PVOID)&kpDescReq,
                                            (PVOID *)&pKpDesc
                                        );

    if(dwStatus != ERROR_SUCCESS || pKpDesc == NULL)
    {
        if(GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
        {
            // see if we have any US desc.
            kpDescReq.dwLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            pKpDesc = NULL;

            dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                            pRequest->hClient,
                                            REQUEST_KEYPACKDESC,
                                            (PVOID)&kpDescReq,
                                            (PVOID *)&pKpDesc
                                        );
        }
    }

    LPCTSTR pString[2];

    pString[0] = g_szComputerName;
    pString[1] = (dwStatus == ERROR_SUCCESS && pKpDesc != NULL) ? pKpDesc->szProductDesc : 
                       pRequest->pClientLicenseRequest->pszProductId;
 
    TLSLogEventString(
            EVENTLOG_WARNING_TYPE,
            (bNoLicense == TRUE) ? TLS_W_NOPERMLICENSE : TLS_W_PRODUCTNOTINSTALL,
            sizeof(pString)/sizeof(pString[0]),
            pString
        );

    return;
}

//--------------------------------------------------------------------------------
DWORD
TLSDBIssuePermanentLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bLatestVersion,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct,
    IN DWORD dwSupportFlags
    )
/*
Abstract:

    Routine to allocate a perm. license.

Parameters:

    pDbWkSpace - Workspace handle.
    pRequest - license request.
    bLatestVersion - Request latest version (unused)
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses to allocate.  on output,
                  number of licenses actually allocated
    IN OUT pLicensedProduct - licensed product
    dwSupportFlags - abilities supported by TS and LS.

Returns:

*/
{
    DWORD status=ERROR_SUCCESS;
    ULARGE_INTEGER  ulSerialNumber;
    DWORD  dwLicenseId;
    TLSLICENSEPACK LicensePack;
    UCHAR ucKeyPackStatus;
    LICENSEDCLIENT issuedLicense;
    DWORD CertSerialNumber;

    PMGENERATELICENSE PolModGenLicense;
    PPMCERTEXTENSION pPolModCertExtension=NULL;

    FILETIME notBefore, notAfter;
    UCHAR ucAgreementType;

    memset(&ulSerialNumber, 0, sizeof(ulSerialNumber));

    //----------------------------------------------------------------------
    //
    // this step require reduce available license by dwQuantity
    //
    status=TLSDBGetPermanentLicense(
                            pDbWkSpace,
                            pRequest,
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            bLatestVersion,
                            &LicensePack
                        );

    if(status != ERROR_SUCCESS)
    {
        if(status == TLS_E_NO_LICENSE || status == TLS_E_PRODUCT_NOTINSTALL)
        {
            TLSLogLowLicenseWarning(
                                pDbWkSpace,
                                pRequest,
                                (status == TLS_E_NO_LICENSE)
                            );
        }

        goto cleanup;
    }

    ucKeyPackStatus = (LicensePack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED);

    if( ucKeyPackStatus != LSKEYPACKSTATUS_PENDING && 
        ucKeyPackStatus != LSKEYPACKSTATUS_ACTIVE )
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }

    ucAgreementType = (LicensePack.ucAgreementType & ~ LSKEYPACK_RESERVED_TYPE);

    if( ucAgreementType != LSKEYPACKTYPE_SELECT && 
        ucAgreementType != LSKEYPACKTYPE_RETAIL && 
        ucAgreementType != LSKEYPACKTYPE_FREE && 
        ucAgreementType != LSKEYPACKTYPE_OPEN )
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }

     
    //
    // for pending activation keypack, we still 
    // issue permanent license and rely 
    // on revoke key pack list to invalidate licenses.
    //
    dwLicenseId=TLSDBGetNextLicenseId();

    //
    // Reset status
    //
    status = ERROR_SUCCESS;

    //
    // Formuate license serial number 
    //
    ulSerialNumber.LowPart = dwLicenseId;
    ulSerialNumber.HighPart = LicensePack.dwKeyPackId;

    // Update License Table Here
    memset(&issuedLicense, 0, sizeof(LICENSEDCLIENT));
    issuedLicense.dwLicenseId = dwLicenseId;
    issuedLicense.dwKeyPackId = LicensePack.dwKeyPackId;
    issuedLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    issuedLicense.dwSystemBiosChkSum = pRequest->hWid.dwPlatformID;
    issuedLicense.dwVideoBiosChkSum = pRequest->hWid.Data1;
    issuedLicense.dwFloppyBiosChkSum = pRequest->hWid.Data2;
    issuedLicense.dwHardDiskSize = pRequest->hWid.Data3;
    issuedLicense.dwRamSize = pRequest->hWid.Data4;
    issuedLicense.dwNumLicenses = *pdwQuantity;
    issuedLicense.ftIssueDate = time(NULL);

    _tcscpy(issuedLicense.szMachineName, pRequest->szMachineName);
    _tcscpy(issuedLicense.szUserName, pRequest->szUserName);

    if ((dwSupportFlags & SUPPORT_PER_SEAT_REISSUANCE) &&
        ((_tcsnicmp(LicensePack.szProductId, TERMSERV_PRODUCTID_SKU,
            _tcslen(TERMSERV_PRODUCTID_SKU)) == 0) ||
         (_tcsnicmp(LicensePack.szProductId, TERMSERV_PRODUCTID_CONCURRENT_SKU,
            _tcslen(TERMSERV_PRODUCTID_CONCURRENT_SKU)) == 0)) &&
        ((LicensePack.ucAgreementType == LSKEYPACKTYPE_SELECT) ||
         (LicensePack.ucAgreementType == LSKEYPACKTYPE_RETAIL) ||
         (LicensePack.ucAgreementType == LSKEYPACKTYPE_OPEN)))
    {
        DWORD dwRange;

        dwRange = GenerateRandomNumber(GetCurrentThreadId()) %
                g_dwReissueLeaseRange;

        issuedLicense.ftExpireDate = ((DWORD)time(NULL)) +
                g_dwReissueLeaseMinimum + dwRange;
    }
    else
    {
        issuedLicense.ftExpireDate = PERMANENT_LICENSE_EXPIRE_DATE;
    }

    issuedLicense.ucLicenseStatus =
        (LicensePack.ucKeyPackStatus == LSKEYPACKSTATUS_PENDING) ?  
            LSLICENSE_STATUS_PENDING : LSLICENSE_STATUS_ACTIVE;   

    UnixTimeToFileTime(LicensePack.dwActivateDate, &notBefore);
    UnixTimeToFileTime(issuedLicense.ftExpireDate, &notAfter);

    //
    // Inform Policy Module of license issued.
    // 
    if(pRequest->pPolicy)
    {
        PolModGenLicense.dwKeyPackType = LicensePack.ucAgreementType;
        PolModGenLicense.pLicenseRequest = pRequest->pPolicyLicenseRequest;
        PolModGenLicense.dwKeyPackId = LicensePack.dwKeyPackId;;
        PolModGenLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
        PolModGenLicense.ClientLicenseSerialNumber = ulSerialNumber;
        PolModGenLicense.ftNotBefore = notBefore;
        PolModGenLicense.ftNotAfter = notAfter;

        status = pRequest->pPolicy->PMLicenseRequest( 
                                        pRequest->hClient,
                                        REQUEST_GENLICENSE,
                                        (PVOID)&PolModGenLicense,
                                        (PVOID *)&pPolModCertExtension
                                    );

        if(status != ERROR_SUCCESS)
        {
            //
            // Error in policy module
            //
            goto cleanup;
        }
    }

    //  
    // Check error return from policy module
    //
    if(pPolModCertExtension != NULL)
    {
        if(pPolModCertExtension->pbData != NULL &&
           pPolModCertExtension->cbData == 0 ||
           pPolModCertExtension->pbData == NULL &&
           pPolModCertExtension->cbData != 0  )
        {
            // assuming no extension data
            pPolModCertExtension->cbData = 0;
            pPolModCertExtension->pbData = NULL;
        }

        if(CompareFileTime( &(pPolModCertExtension->ftNotBefore), 
                            &(pPolModCertExtension->ftNotAfter)) > 0)
        {
            //
            // invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    status = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }


        if( FileTimeToLicenseDate(&(pPolModCertExtension->ftNotBefore), &issuedLicense.ftIssueDate) == FALSE ||
            FileTimeToLicenseDate(&(pPolModCertExtension->ftNotAfter), &issuedLicense.ftExpireDate) == FALSE )
        {
            //
            // Invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    status = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }

        notBefore = pPolModCertExtension->ftNotBefore;
        notAfter = pPolModCertExtension->ftNotAfter;
    }

    //
    // Add license into license table
    //
    status=TLSDBLicenseAdd(
                    pDbWkSpace, 
                    &issuedLicense, 
                    0,          
                    NULL
                );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Return licensed product
    //
    pLicensedProduct->pSubjectPublicKeyInfo = NULL;
    pLicensedProduct->dwQuantity = *pdwQuantity;
    pLicensedProduct->ulSerialNumber = ulSerialNumber;

    pLicensedProduct->dwKeyPackId = LicensePack.dwKeyPackId;
    pLicensedProduct->dwLicenseId = dwLicenseId;
    pLicensedProduct->dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    pLicensedProduct->dwNumLicenseLeft = LicensePack.dwNumberOfLicenses;
    pLicensedProduct->ClientHwid = pRequest->hWid;
    pLicensedProduct->bTemp = FALSE;

    pLicensedProduct->NotBefore = notBefore;
    pLicensedProduct->NotAfter = notAfter;

    pLicensedProduct->dwProductVersion = MAKELONG(LicensePack.wMinorVersion, LicensePack.wMajorVersion);

    _tcscpy(pLicensedProduct->szUserName, pRequest->szUserName);
    _tcscpy(pLicensedProduct->szMachineName, pRequest->szMachineName);

    _tcscpy(pLicensedProduct->szCompanyName, LicensePack.szCompanyName);
    _tcscpy(pLicensedProduct->szLicensedProductId, LicensePack.szProductId);
    _tcscpy(pLicensedProduct->szRequestProductId, pRequest->pClientLicenseRequest->pszProductId);

    pLicensedProduct->dwLanguageID = pRequest->dwLanguageID;
    pLicensedProduct->dwPlatformID = pRequest->dwPlatformID;
    pLicensedProduct->pbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->pbData : NULL;
    pLicensedProduct->cbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->cbData : 0;

cleanup:

    return status;
}

DWORD
TLSDBReissuePermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
    )
/*++
Abstract:

    Searches for the expired license in the database and, if found, resets
    the expiration and returns the modified license.

Parameters:

Returns:

--*/
{
    TLSDBLICENSEDPRODUCT LicensedProduct;

    LicensedProductToDbLicensedProduct(pExpiredLicense,&LicensedProduct);

    return TLSDBReissueFoundPermanentLicense(pDbWkSpace,
                                             &LicensedProduct,
                                             pReissuedLicense);
}

DWORD
TLSDBReissueFoundPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEDPRODUCT pExpiredLicense,
    IN OUT PTLSDBLICENSEDPRODUCT pReissuedLicense
    )
/*++
Abstract:

    Searches for the expired license in the database and, if found, resets
    the expiration and returns the modified license.

Parameters:

Returns:

--*/
{
    DWORD dwStatus;
    LICENSEDCLIENT License;

    ASSERT(pDbWkSpace != NULL);
    ASSERT(pExpiredLicense != NULL);
    ASSERT(pReissuedLicense != NULL);

    dwStatus = TLSFindDbLicensedProduct(pExpiredLicense, &License);

    if (dwStatus == ERROR_SUCCESS)
    {
        DWORD dwRange;

        dwRange = GenerateRandomNumber(GetCurrentThreadId()) %
                g_dwReissueLeaseRange;

        License.ftExpireDate = ((DWORD)time(NULL)) +
                g_dwReissueLeaseMinimum + dwRange;

        TLSDBLockLicenseTable();

        try
        {
            dwStatus = TLSDBLicenseUpdateEntry(
                            USEHANDLE(pDbWkSpace),
                            LSLICENSE_SEARCH_EXPIREDATE,
                            &License,
                            FALSE
                            );
        }
        catch(...)
        {
            dwStatus = TLS_E_INTERNAL;
        }

        TLSDBUnlockLicenseTable();
    }

    if (dwStatus == ERROR_SUCCESS)
    {
        CopyDbLicensedProduct(pExpiredLicense, pReissuedLicense);
        UnixTimeToFileTime(License.ftExpireDate, &(pReissuedLicense->NotAfter));
        pReissuedLicense->pSubjectPublicKeyInfo = NULL;
    }

    return(dwStatus);
}

//+------------------------------------------------------------------------
DWORD
TLSDBGetPermanentLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN BOOL bAcceptFewerLicenses,
    IN OUT DWORD *pdwQuantity,
    IN BOOL bLatestVersion,
    IN OUT PTLSLICENSEPACK pLicensePack
    )
/*++
Abstract:

    Allocate a permanent license from database.

Parameters:

    pDbWkSpace : workspace handle.
    pRequest : product to be request.
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses to allocate.  on output,
                  number of licenses actually allocated
    bLatestversion : latest version (unused).
    pLicensePack : license pack where license is allocated.

Returns:


++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSDBLicenseAllocation allocated;
    TLSDBAllocateRequest AllocateRequest;
    TLSLICENSEPACK LicenseKeyPack;
    DWORD dwTotalAllocated = 0;


    DWORD dwSearchedType = 0;
    DWORD dwSuggestType;
    DWORD dwPMAdjustedType = LSKEYPACKTYPE_UNKNOWN;
    DWORD dwLocalType = LSKEYPACKTYPE_UNKNOWN;

    POLICY_TS_MACHINE groupPolicy;
    RegGetMachinePolicy(&groupPolicy);

#define NUM_KEYPACKS 5

    DWORD                       dwAllocation[NUM_KEYPACKS];
    TLSLICENSEPACK              keypack[NUM_KEYPACKS];

    for (int i=0; i < NUM_KEYPACKS; i++)
    {
        keypack[i].pbDomainSid = NULL;
    }

    AllocateRequest.szCompanyName = (LPTSTR)pRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pRequest->pszProductId;
    AllocateRequest.dwVersion = pRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pRequest->dwPlatformID;
    AllocateRequest.dwLangId = pRequest->dwLanguageID;
    AllocateRequest.dwNumLicenses = *pdwQuantity;
    if( groupPolicy.fPolicyPreventLicenseUpgrade == 1 && groupPolicy.fPreventLicenseUpgrade == 1)
    {
        AllocateRequest.dwScheme = ALLOCATE_EXACT_VERSION;
    }
    else
    {
        AllocateRequest.dwScheme = ALLOCATE_ANY_GREATER_VERSION;
    }
    memset(&allocated, 0, sizeof(allocated));


    do {

        allocated.dwBufSize = NUM_KEYPACKS;
        allocated.pdwAllocationVector = dwAllocation;
        allocated.lpAllocateKeyPack = keypack;

        dwSuggestType = dwLocalType;

        dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                pRequest->hClient,
                                                REQUEST_KEYPACKTYPE,
                                                UlongToPtr(dwSuggestType),
                                                (PVOID *)&dwPMAdjustedType
                                            );

        if(dwStatus != ERROR_SUCCESS)
            break;

        dwLocalType = (dwPMAdjustedType & ~LSKEYPACK_RESERVED_TYPE);
        if(dwLocalType > LSKEYPACKTYPE_LAST)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );
            
            break;
        }

        if(dwSearchedType & (0x1 << dwLocalType))
        {
            //
            // we already went thru this license pack, policy module error
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULERECURSIVE,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );
            break;
        }

        dwSearchedType |= (0x1 << dwLocalType);
        AllocateRequest.ucAgreementType = dwPMAdjustedType;

        dwStatus = AllocateLicensesFromDB(
                                    pDbWkSpace,
                                    &AllocateRequest,
                                    TRUE,       // fCheckAgreementType
                                    &allocated
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // successfully allocate a license
            //
            dwTotalAllocated += allocated.dwTotalAllocated;

            if (dwTotalAllocated >= *pdwQuantity)
            {
                break;
            }
            else
            {
                AllocateRequest.dwNumLicenses -= allocated.dwTotalAllocated;
                continue;
            }
        }

        if(dwStatus != TLS_I_NO_MORE_DATA && dwStatus != TLS_E_PRODUCT_NOTINSTALL)
        {
            //
            // error occurred in AllocateLicenseFromDB()
            //
            break;
        }
    } while(dwLocalType != LSKEYPACKTYPE_UNKNOWN);

    if ((dwTotalAllocated == 0)
        || (!bAcceptFewerLicenses && 
            ((dwTotalAllocated < *pdwQuantity))))
    {
        // Failing to commit will return all licenses allocated so far

        SetLastError(dwStatus = TLS_E_NO_LICENSE);
    }
    else if ((dwTotalAllocated != 0) && bAcceptFewerLicenses)
    {
        dwStatus = ERROR_SUCCESS;
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // LicenseKeyPack return via TLSDBLicenseAllocation structure
        //
        *pLicensePack = keypack[0];
        *pdwQuantity = dwTotalAllocated;
    } 

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\pid.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       pid.cpp 
//
// Contents:   Generate/save/retrieve license server ID to LSA 
//
// History:     
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#include "pid.h"
#include "gencert.h"
#include "certutil.h"

//////////////////////////////////////////////////////////////////

DWORD
ServerIdsToLsaServerId(
    IN PBYTE pbServerUniqueId,
    IN DWORD cbServerUniqueId,
    IN PBYTE pbServerPid,
    IN DWORD cbServerPid,
    IN PBYTE pbServerSPK,
    IN DWORD cbServerSPK,
    IN PCERT_EXTENSION pCertExtensions,
    IN DWORD dwNumCertExtensions,
    OUT PTLSLSASERVERID* ppLsaServerId,
    OUT DWORD* pdwLsaServerId
    )

/*++

Abstract:

    Combine list of License Server ID to TLSLSASERVERID structure 
    suitable to be saved with LSA.

Parameters:


    pbServerUniqueId : License Server Unique ID.
    cbServerUniqueId : size of License Server Unique Id in bytes.
    pbServerPid : License Server's PID
    cbServerPid : size of License Server's PID in bytes
    pbServerSPK : License Server's SPK.
    cbServerSPK : size of License Server's SPK in bytes.
    pdwLsaServerId : Pointer to DWORD to receive size of TLSLSASERVERID.
    pLsaServerId : PPointer to TLSLSASERVERID

Returns:


Note:

    Internal Routine.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwOffset = offsetof(TLSLSASERVERID, pbVariableStart);

    PBYTE pbEncodedExt = NULL;
    DWORD cbEncodedExt = 0;

    CERT_EXTENSIONS cert_extensions;

    if( pbServerSPK != NULL && 
        cbServerSPK != 0 && 
        pCertExtensions != NULL &&
        dwNumCertExtensions != 0 )
    {
        cert_extensions.cExtension = dwNumCertExtensions;
        cert_extensions.rgExtension = pCertExtensions;
    
        //
        // encode cert. extension
        //
        dwStatus = TLSCryptEncodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    szOID_CERT_EXTENSIONS,
                                    &cert_extensions,
                                    &pbEncodedExt,
                                    &cbEncodedExt
                                );
                    
        if(dwStatus != ERROR_SUCCESS)
        {
            return dwStatus;
        }
    }

    *pdwLsaServerId = sizeof(TLSLSASERVERID) + 
                      cbServerUniqueId + 
                      cbServerPid + 
                      cbServerSPK +
                      cbEncodedExt;
 
    *ppLsaServerId = (PTLSLSASERVERID)AllocateMemory(*pdwLsaServerId);
    if(*ppLsaServerId != NULL)
    {
        (*ppLsaServerId)->dwVersion = TLSERVER_SERVER_ID_VERSION;
        (*ppLsaServerId)->dwUniqueId = 0;
        (*ppLsaServerId)->dwServerPid = 0;
        (*ppLsaServerId)->dwServerSPK = 0;
        (*ppLsaServerId)->dwExtensions = 0;

        if(pbServerUniqueId && cbServerUniqueId)
        {
            (*ppLsaServerId)->dwUniqueId = cbServerUniqueId;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset,
                    pbServerUniqueId,
                    cbServerUniqueId
                );
        }

        if(pbServerPid && cbServerPid)
        {
            (*ppLsaServerId)->dwServerPid = cbServerPid;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset + cbServerUniqueId,
                    pbServerPid,
                    cbServerPid
                );
        }

        if(pbServerSPK && cbServerSPK)
        {
            (*ppLsaServerId)->dwServerSPK = cbServerSPK;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset + cbServerUniqueId + cbServerPid,
                    pbServerSPK,
                    cbServerSPK
                );
        }

        if(pbEncodedExt && cbEncodedExt)
        {
            (*ppLsaServerId)->dwExtensions = cbEncodedExt;

            memcpy(
                    (PBYTE)(*ppLsaServerId) + dwOffset + cbServerUniqueId + cbServerPid + cbServerSPK,
                    pbEncodedExt,
                    cbEncodedExt
                );
        }
            
    }
    else
    {
        dwStatus = GetLastError();
    }

    FreeMemory(pbEncodedExt);
  
    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
LsaServerIdToServerIds(
    IN PTLSLSASERVERID pLsaServerId,
    IN DWORD dwLsaServerId,
    OUT PBYTE* ppbServerUniqueId,
    OUT PDWORD pcbServerUniqueId,
    OUT PBYTE* ppbServerPid,
    OUT PDWORD pcbServerPid,
    OUT PBYTE* ppbServerSPK,
    OUT PDWORD pcbServerSPK,
    OUT PCERT_EXTENSIONS* pCertExtensions,
    OUT PDWORD pcbCertExtensions
    )

/*++

Abstract:

    Reverse of ServerIdsToLsaServerId()

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize = 0;
    PBYTE pbUniqueId = NULL;
    PBYTE pbPid = NULL;
    PBYTE pbSPK = NULL;
    DWORD dwOffset = offsetof(TLSLSASERVERID, pbVariableStart);

    DWORD cbCertExt = 0;
    PCERT_EXTENSIONS pCertExt = NULL;


    //
    // verify input.
    //
    if(dwLsaServerId == 0 || pLsaServerId == NULL)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(pLsaServerId->dwVersion != TLSERVER_SERVER_ID_VERSION)
    {
        TLSLogErrorEvent(TLS_E_INCOMPATIBLELSAVERSION);
        goto cleanup;
    }

    dwSize = sizeof(TLSLSASERVERID) + 
             pLsaServerId->dwUniqueId + 
             pLsaServerId->dwServerPid + 
             pLsaServerId->dwServerSPK +
             pLsaServerId->dwExtensions;

    if(dwSize != dwLsaServerId)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(pLsaServerId->dwVersion != TLSERVER_SERVER_ID_VERSION)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    *pcbServerUniqueId = pLsaServerId->dwUniqueId;
    *pcbServerPid = pLsaServerId->dwServerPid;
    *pcbServerSPK = pLsaServerId->dwServerSPK;

    if(pLsaServerId->dwUniqueId != 0)
    {
        pbUniqueId = (PBYTE)AllocateMemory(pLsaServerId->dwUniqueId);
        if(pbUniqueId == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(pLsaServerId->dwServerPid != 0)
    {
        pbPid = (PBYTE)AllocateMemory(pLsaServerId->dwServerPid);
        if(pbPid == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(pLsaServerId->dwServerSPK != 0)
    {
        pbSPK = (PBYTE)AllocateMemory(pLsaServerId->dwServerSPK);
        if(pbSPK == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    if(pLsaServerId->dwUniqueId)
    {
        memcpy(
                pbUniqueId,
                (PBYTE)pLsaServerId + dwOffset,
                pLsaServerId->dwUniqueId
            );
    }

    if(pLsaServerId->dwServerPid)
    {
        memcpy(
                pbPid,
                (PBYTE)pLsaServerId + dwOffset + pLsaServerId->dwUniqueId,
                pLsaServerId->dwServerPid
            );
    }

    if(pLsaServerId->dwServerSPK)
    {
        memcpy(
                pbSPK,
                (PBYTE)pLsaServerId + dwOffset + pLsaServerId->dwUniqueId + pLsaServerId->dwServerPid,
                pLsaServerId->dwServerSPK
            );
    }

    if(pLsaServerId->dwExtensions)
    {
        PBYTE pbEncodedCert;
        DWORD cbEncodedCert;

        pbEncodedCert = (PBYTE)pLsaServerId + 
                        dwOffset + 
                        pLsaServerId->dwUniqueId + 
                        pLsaServerId->dwServerPid +
                        pLsaServerId->dwServerSPK;

        cbEncodedCert = pLsaServerId->dwExtensions;

        dwStatus = LSCryptDecodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    szOID_CERT_EXTENSIONS,
                                    pbEncodedCert,
                                    cbEncodedCert,
                                    0,
                                    (VOID **)&pCertExt,
                                    &cbCertExt
                                );
    }


cleanup:

    if(dwStatus != ERROR_SUCCESS)    
    {
        FreeMemory(pCertExt);
        FreeMemory(pbUniqueId);
        FreeMemory(pbPid);
        FreeMemory(pbSPK);
    }
    else
    {
        *pCertExtensions = pCertExt;
        *pcbCertExtensions = cbCertExt;
        *ppbServerUniqueId = pbUniqueId;
        *ppbServerPid = pbPid;
        *ppbServerSPK = pbSPK;
    }

    return dwStatus;
}
 
//////////////////////////////////////////////////////////////////

DWORD
LoadNtPidFromRegistry(
    OUT LPTSTR* ppszNtPid
    )

/*++

Abstract:

    Load the NT Product ID from registry key.


Parameters:

    pdwNtPidSize : Pointer to DWORD to receive size of data return.
    ppbNtPid : Pointer to PBYTE to receive return data pointer.

Return:


Note:

    use AllocateMemory() macro to allocate memory.
--*/

{
    DWORD dwPidSize=0;
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppszNtPid == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    *ppszNtPid = NULL;

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        NTPID_REGISTRY,
                        0,
                        KEY_READ,   // read only
                        &hKey
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // If this registry key does not exist, 
        // invalid NT installation, if we can't access it, 
        // we are in big trouble.
        //
        goto cleanup;
    }

    dwStatus = RegQueryValueEx(
                        hKey,
                        NTPID_VALUE,
                        NULL,
                        NULL,
                        NULL,
                        &dwPidSize
                    );

    if(dwStatus != ERROR_MORE_DATA && dwStatus != ERROR_SUCCESS)
    {
        // Big trouble.
        goto cleanup;
    }

    *ppszNtPid = (LPTSTR)AllocateMemory(dwPidSize + sizeof(TCHAR));
    if(*ppszNtPid == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    dwStatus = RegQueryValueEx(
                            hKey,
                            NTPID_VALUE,
                            NULL,
                            NULL,
                            (PBYTE)*ppszNtPid,
                            &dwPidSize
                        );

cleanup:

    if(hKey != NULL)
    {
        RegCloseKey(hKey);    
    }

    if(dwStatus != NULL)
    {
        FreeMemory(*ppszNtPid);
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
GenerateRandomNumber(
    IN  DWORD  Seed
    )

/*++

Routine Description:

    Generate a random number.

Arguments:

    Seed - Seed for random-number generator.

Return Value:

    Returns a random number.

--*/
{
    ULONG ulSeed = Seed;

    // Randomize the seed some more

    ulSeed = RtlRandomEx(&ulSeed);

    return RtlRandomEx(&ulSeed);
}

//////////////////////////////////////////////////////////////////

DWORD
TLSGeneratePid(
    OUT LPTSTR* pszTlsPid,
    OUT PDWORD  pcbTlsPid,
    OUT LPTSTR* pszTlsUniqueId,
    OUT PDWORD  pcbTlsUniqueId
    )

/*++

Abstract:

    Generate a PID for License Server, License Server PID is composed of 
    NT PID (from registry) with last 5 digit being randomly generated number.

Parameter:

    ppbTlsPid : Pointer to PBYTE that receive the License Server PID.
    pcbTlsPid : Pointer to DWORD to receive size of License Server PID.
    ppbTlsUniqueId : Pointer to PBYTE to receive the License Server Unique Id.
    pcbTlsUniqueId : Pointer to DWORD to receive size of License Server's unique ID.

Returns:

    Error code if can't access NT system PID.

Note:

    refer to PID20 format for detail, License Server treat PID as binary data.

--*/

{
    DWORD dwStatus;
    DWORD dwRandomNumber;
    DWORD dwNtPid;
    LPTSTR pszNtPid = NULL;
    LPTSTR pszPid20Random = NULL;
    int index;
    DWORD dwMod = 1;

    if( pszTlsPid == NULL || pcbTlsPid == NULL ||
        pszTlsUniqueId == NULL || pcbTlsUniqueId == NULL )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Load NT system PID
    //
    dwStatus = LoadNtPidFromRegistry(
                            &pszNtPid
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    pszPid20Random = (LPTSTR)AllocateMemory(
                                        (TLSUNIQUEID_SIZE + 1) * sizeof(TCHAR)
                                    );
    if(pszPid20Random == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }
    
    for(index = 0; index < TLSUNIQUEID_SIZE; index++)
    {
        dwMod *= 10;
    }

    dwRandomNumber = GenerateRandomNumber( GetCurrentThreadId() + GetTickCount() );

    swprintf( 
            pszPid20Random, 
            _TEXT("%0*u"), 
            TLSUNIQUEID_SIZE,
            dwRandomNumber % dwMod
        );
        
    //
    // overwrite last 5 digit
    //
    lstrcpy(
            pszNtPid + (lstrlen(pszNtPid) - TLSUNIQUEID_SIZE),
            pszPid20Random
        );
        
    *pszTlsPid = pszNtPid;
    *pcbTlsPid = (lstrlen(pszNtPid) + 1) * sizeof(TCHAR);
    *pszTlsUniqueId = pszPid20Random;
    *pcbTlsUniqueId = (lstrlen(pszPid20Random) + 1) * sizeof(TCHAR);

cleanup:

    if(dwStatus != ERROR_SUCCESS)
    {
        FreeMemory(pszNtPid);
        FreeMemory(pszPid20Random);
    }
        
    return dwStatus;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\npipe.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        npipe.c
//
// Contents:    
//
// History:     12-09-98    HueiWang    Created
//
// Note:        
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <tchar.h>
#include <process.h>
#include "server.h"
#include "lscommon.h"
#include "globals.h"
#include "debug.h"


#define NAMEPIPE_BUFFER_SIZE    512
#define NAMEPIPE_INSTANCE       2


unsigned int WINAPI
NamedPipeThread(
    void* ptr
);

//---------------------------------------------------------------------
DWORD
InitNamedPipeThread()
/*++

++*/
{
    HANDLE hThread = NULL;
    unsigned int  dwThreadId;
    HANDLE hEvent = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    HANDLE waithandles[2];


    //
    // Create a event for namedpipe thread to signal it is ready.
    //
    hEvent = CreateEvent(
                        NULL,
                        FALSE,
                        FALSE,  // non-signal
                        NULL
                    );
        
    if(hEvent == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hThread = (HANDLE)_beginthreadex(
                                NULL,
                                0,
                                NamedPipeThread,
                                hEvent,
                                0,
                                &dwThreadId
                            );

    if(hThread == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    waithandles[0] = hEvent;
    waithandles[1] = hThread;
    
    //
    // Wait 30 second for thread to complet initialization
    //
    dwStatus = WaitForMultipleObjects(
                                sizeof(waithandles)/sizeof(waithandles[0]), 
                                waithandles, 
                                FALSE,
                                30*1000
                            );

    if(dwStatus == WAIT_OBJECT_0)
    {    
        //
        // thread is ready
        //
        dwStatus = ERROR_SUCCESS;
    }
    else 
    {
        if(dwStatus == (WAIT_OBJECT_0 + 1))
        {
            //
            // Thread terminate abnormally
            //
            GetExitCodeThread(
                        hThread,
                        &dwStatus
                    );
        }
        else
        {
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        }
    }
    

cleanup:

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hThread != NULL)
    {
        CloseHandle(hThread);
    }


    return dwStatus;
}

//------------------------------------------------------------------------

typedef struct {    
    OVERLAPPED ol;    
    HANDLE hPipeInst; 
} PIPEINST, *LPPIPEINST;

//------------------------------------------------------------------------

BOOL 
ConnectToNewClient(
    HANDLE hPipe, 
    LPOVERLAPPED lpo
    ) 
/*++

++*/
{ 
    BOOL bSuccess = FALSE;  

    // Start an overlapped connection for this pipe instance. 
    bSuccess = ConnectNamedPipe(hPipe, lpo);  

    //
    // Overlapped ConnectNamedPipe should return zero.
    //
    if(bSuccess == TRUE) 
    {
        return FALSE;
    }

    switch (GetLastError())    
    { 
        // The overlapped connection in progress.       
        case ERROR_IO_PENDING: 
            bSuccess = TRUE;
            break;  

        // Client is already connected, so signal an event. 
        case ERROR_PIPE_CONNECTED:
            bSuccess = TRUE;

            // If an error occurs during the connect operation... 
            if(SetEvent(lpo->hEvent)) 
                break;     

        default:          
            bSuccess = FALSE;
    }

    return bSuccess; 
} 

//------------------------------------------------------------------------

unsigned int WINAPI
NamedPipeThread(
    void* ptr
    )
/*++


++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwIndex;

    HANDLE hReady = (HANDLE)ptr;
    TCHAR szPipeName[MAX_PATH+1];

    PIPEINST Pipe[NAMEPIPE_INSTANCE];
    HANDLE hOlEvent[NAMEPIPE_INSTANCE];

    DWORD cbMessage, cbRead, cbToRead, cMessages;
    BYTE pbMessage[NAMEPIPE_BUFFER_SIZE+1];

    HANDLE waitHandles[NAMEPIPE_INSTANCE+1];

    BOOL bResult=TRUE;

    //SECURITY_ATTRIBUTES SecurityAttributes;
    //SECURITY_DESCRIPTOR SecurityDescriptor;

    int i;

    //------------------------------------------------

    ZeroMemory(Pipe, sizeof(Pipe));
    ZeroMemory(hOlEvent, sizeof(hOlEvent));

    //
    // Create a inbound name pipe, server only listen.
    //
    wsprintf(
            szPipeName, 
            _TEXT("\\\\.\\pipe\\%s"), 
            _TEXT(SZSERVICENAME)
        );

    //
    // init values
    //
    for(i = 0; i < NAMEPIPE_INSTANCE; i++)
    {
        Pipe[i].hPipeInst = INVALID_HANDLE_VALUE;
    }

    //
    // Create namedpipe
    //
    for(i=0; i < NAMEPIPE_INSTANCE; i++)
    {
        hOlEvent[i] = CreateEvent(
                            NULL,
                            TRUE,
                            TRUE,
                            NULL
                        );
    
        if(hOlEvent[i] == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    
        Pipe[i].ol.hEvent = hOlEvent[i];
        Pipe[i].hPipeInst = CreateNamedPipe(
                                        szPipeName,
                                        PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
                                        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
                                        NAMEPIPE_INSTANCE,
                                        0,
                                        NAMEPIPE_BUFFER_SIZE,
                                        NMPWAIT_USE_DEFAULT_WAIT,
                                        NULL // &SecurityAttributes
                                    );

        if(Pipe[i].hPipeInst == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Initiate connect
        //
        bResult = ConnectToNewClient(
                                Pipe[i].hPipeInst, 
                                &(Pipe[i].ol)
                            );

        if(bResult == FALSE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }
    }

    //
    // Signal we are ready
    //
    SetEvent(hReady);

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("NamedPipe : Ready...\n")
        );


    waitHandles[0] = GetServiceShutdownHandle();

    for(i=1; i <= NAMEPIPE_INSTANCE; i++)
    {
        waitHandles[i] = hOlEvent[i-1];
    }

    //
    // Forever loop
    //
    while(TRUE)
    {
        //
        // Wait for pipe or shutdown messages
        //
        dwStatus = WaitForMultipleObjects(
                                    sizeof(waitHandles)/sizeof(waitHandles[0]),
                                    waitHandles,
                                    FALSE,
                                    INFINITE
                                );

        if(dwStatus == WAIT_FAILED)
        {
            SetLastError(dwStatus = TLS_E_INTERNAL);
            break;
        }

        if(dwStatus == WAIT_OBJECT_0)
        {
            //
            // shutdown
            //
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("NamedPipe : System Shutdown...\n")
                );

            dwStatus = ERROR_SUCCESS;
            break;
        }

        dwIndex = (dwStatus - 1) - WAIT_OBJECT_0;
        if(dwIndex > (NAMEPIPE_INSTANCE-1))
        {
            //
            // some internal error
            //
            SetLastError(dwStatus = TLS_E_INTERNAL);

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("NamedPipe : Internal Error...\n")
                );

            break;
        }
            
        //
        // Read everything and discard it.
        //
        bResult = GetOverlappedResult(
                                    Pipe[dwIndex].hPipeInst,
                                    &(Pipe[dwIndex].ol),
                                    &cbToRead,  // can't count on this value
                                    TRUE
                                );
                                  
        if(bResult == TRUE)
        {
            //
            // Junk messages...
            //
            bResult = ReadFile(
                            Pipe[dwIndex].hPipeInst,
                            pbMessage,
                            sizeof(pbMessage),
                            &cbRead,
                            &(Pipe[dwIndex].ol)
                        );

            if(bResult == TRUE && cbRead != 0) 
                continue;                    

            dwStatus = GetLastError();
            if(dwStatus == ERROR_IO_PENDING)
                continue;
        }

        //
        // Any error, just disconnect named pipe
        //
        DisconnectNamedPipe(Pipe[dwIndex].hPipeInst);

        ConnectToNewClient(
                        Pipe[dwIndex].hPipeInst, 
                        &(Pipe[dwIndex].ol)
                    );
    }

cleanup:

    for(i = 0; i < NAMEPIPE_INSTANCE; i++)
    {
        if(Pipe[i].hPipeInst != INVALID_HANDLE_VALUE)
        {
            CloseHandle(Pipe[i].hPipeInst);
        }

        if(hOlEvent[i] != NULL)
        {
            CloseHandle(hOlEvent[i]);
        }
    }

    _endthreadex(dwStatus);   
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       policy.cpp 
//
// Contents:   Loading product policy module 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "utils.h"
#include <windows.h>
#include <wincrypt.h>
#include <assert.h>
#include "srvdef.h"
#include "server.h"
#include "policy.h"

CTLSPolicyMgr PolicyMgr;
TCHAR g_szDefPolCompanyName[LSERVER_MAX_STRING_SIZE+1];
TCHAR g_szDefProductId[LSERVER_MAX_STRING_SIZE+1];


//-------------------------------------------------------------
//
// Internal routine
//

HINSTANCE
LoadPolicyModule(
    IN LPCTSTR pszDllName,
    OUT PDWORD pdwBufferSize,
    OUT LPTSTR pszBuffer
    )
/*++

Abstract:

    Load Policy module

Parameters:

    pszDll : Name of the DLL.
    pdwBufferSize : 
    pszBuffer

Returns:    

--*/
{
    TCHAR szDllFullPath[MAX_PATH+1];
    DWORD dwErrCode = ERROR_SUCCESS;
    HINSTANCE hPolicyModule = NULL;

    //
    // expand the environment string
    //
    memset(szDllFullPath, 0, sizeof(szDllFullPath));
    dwErrCode = ExpandEnvironmentStrings(
                        pszDllName,
                        szDllFullPath,
                        sizeof(szDllFullPath)/sizeof(szDllFullPath[0])
                    );

    if(dwErrCode == 0 && pszBuffer && pdwBufferSize && *pdwBufferSize)
    {
        _tcsncpy(pszBuffer, szDllFullPath, *pdwBufferSize);
        *pdwBufferSize = _tcslen(szDllFullPath);
    }

    dwErrCode = ERROR_SUCCESS;

    hPolicyModule = LoadLibrary(szDllFullPath);
    if(hPolicyModule == NULL) 
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE,
                pszDllName,
                dwErrCode
            );
    }

    return hPolicyModule;
}


//-------------------------------------------------------------
typedef struct _RegEnumHandle {
    DWORD dwKeyIndex;
    HKEY hKey;
} RegEnumHandle;

//-------------------------------------------------------------
DWORD
RegEnumBegin(
    IN HKEY hRoot,
    IN LPCTSTR pszSubKey,
    OUT RegEnumHandle* phEnum
    )
/*++

++*/
{
    DWORD dwStatus;
    dwStatus = RegOpenKeyEx(
                        hRoot,
                        pszSubKey,
                        0,
                        KEY_ALL_ACCESS,
                        &(phEnum->hKey)
                    );

    phEnum->dwKeyIndex = 0;
    return dwStatus;
}

//-------------------------------------------------------------
DWORD
RegEnumNext(
    RegEnumHandle* phEnum,
    LPTSTR lpName,
    LPDWORD lpcbName
    )
/*++

++*/
{
    DWORD dwStatus;
    FILETIME ftLastWriteTiem;

    dwStatus = RegEnumKeyEx(
                        phEnum->hKey,
                        phEnum->dwKeyIndex,
                        lpName,
                        lpcbName,
                        0,
                        NULL,
                        NULL,
                        &ftLastWriteTiem
                    );

    (phEnum->dwKeyIndex)++;
    return dwStatus;
}

//-------------------------------------------------------------
DWORD
RegEnumEnd(
    RegEnumHandle* phEnum
    )
/*++

++*/
{
    if(phEnum->hKey != NULL)
        RegCloseKey(phEnum->hKey);

    phEnum->dwKeyIndex = 0;

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------
DWORD
ServiceInitPolicyModule(
    void
    )
/*++

++*/
{
    return PolicyMgr.InitProductPolicyModule();
}   

//------------------------------------------------------------
DWORD
ServiceLoadPolicyModule(
    IN HKEY hKey,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductId,
    IN LPCTSTR pszDllRegValue,
    IN LPCTSTR pszDllFlagValue
    )
/*++

++*/
{
    DWORD dwStatus;
    DWORD dwSize;
    TCHAR szDllName[MAX_PATH+1];
    DWORD dwDllFlag;

    dwSize = sizeof(dwDllFlag);
    dwStatus = RegQueryValueEx(
                        hKey,
                        pszDllFlagValue,
                        NULL,
                        NULL,
                        (PBYTE)&dwDllFlag,
                        &dwSize
                    );
    if(dwStatus != ERROR_SUCCESS)
        dwDllFlag = POLICY_DENY_ALL_REQUEST; // (pszProductId == NULL) ? POLICY_DENY_ALL_REQUEST : POLICY_USE_DEFAULT;

    dwSize = MAX_PATH * sizeof(TCHAR);
    dwStatus = RegQueryValueEx(
                        hKey,
                        pszDllRegValue,
                        NULL,
                        NULL,
                        (PBYTE)szDllName,
                        &dwSize
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = PolicyMgr.AddPolicyModule(
                                        FALSE,
                                        pszCompanyName,
                                        pszProductId,
                                        szDllName,
                                        dwDllFlag
                                    );
        if(dwStatus != ERROR_SUCCESS)
        {
            LPCTSTR pString[1];

            pString[0] = szDllName;

            //
            // log event - use default or deny all request.
            //
            TLSLogEventString(
                    EVENTLOG_WARNING_TYPE, 
                    (dwDllFlag == POLICY_DENY_ALL_REQUEST) ? TLS_W_LOADPOLICYMODULEDENYALLREQUEST : TLS_W_LOADPOLICYMODULEUSEDEFAULT,
                    1,
                    pString
                );
        }
    }
    else if(pszProductId != NULL)
    {
        //
        // Load error indicate missing registry value
        //
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_NOPOLICYMODULE, 
                pszProductId,
                pszCompanyName
            );  
    }                 
    
    return dwStatus;
}

//-------------------------------------------------------------
DWORD
ServiceLoadAllPolicyModule(
    IN HKEY hRoot,
    IN LPCTSTR pszSubkey
    )
/*++


++*/
{
    DWORD dwStatus;
    RegEnumHandle hCompany;
    RegEnumHandle hProductId;
    PolicyModule PolModule;
    DWORD dwSize;

    _set_se_translator( trans_se_func );

    //
    // Open registry key 
    // Software\microsoft\termsrvlicensing\policy
    //
    dwStatus = RegEnumBegin(
                        hRoot,
                        pszSubkey,
                        &hCompany
                    );


    while(dwStatus == ERROR_SUCCESS)
    {
        //
        // Enumerater all key (company name) under 
        // Software\microsoft\termsrvlicensing\policy
        //
        dwSize = sizeof(PolModule.m_szCompanyName)/sizeof(PolModule.m_szCompanyName[0]);
        dwStatus = RegEnumNext(
                            &hCompany,
                            PolModule.m_szCompanyName,
                            &dwSize
                        );

        if(dwStatus != ERROR_SUCCESS)
            break;

        //
        // ignore error here
        //

        //
        // Enumerate all product under company
        //
        dwStatus = RegEnumBegin(
                            hCompany.hKey,
                            PolModule.m_szCompanyName,
                            &hProductId
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // Load company wide policy module
            //
            ServiceLoadPolicyModule(
                                hProductId.hKey,
                                PolModule.m_szCompanyName,
                                NULL,
                                LSERVER_POLICY_DLLPATH,
                                LSERVER_POLICY_DLLFLAG
                            );
        }

        while(dwStatus == ERROR_SUCCESS)
        {
            dwSize = sizeof(PolModule.m_szProductId)/sizeof(PolModule.m_szProductId[0]);
            dwStatus = RegEnumNext(
                                &hProductId,
                                PolModule.m_szProductId,
                                &dwSize
                            );


            if(dwStatus == ERROR_SUCCESS)
            {
                HKEY hKey;

                dwStatus = RegOpenKeyEx(
                                    hProductId.hKey,
                                    PolModule.m_szProductId,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKey
                                );

                if(dwStatus != ERROR_SUCCESS)
                    continue;

                //
                // Open product registry key
                //
                ServiceLoadPolicyModule(
                                hKey,
                                PolModule.m_szCompanyName,
                                PolModule.m_szProductId,
                                LSERVER_POLICY_DLLPATH,
                                LSERVER_POLICY_DLLFLAG
                            );

                //
                // ignore any error code here
                //

                RegCloseKey(hKey);
            }
        }

        dwStatus = RegEnumEnd(&hProductId);
    }

    dwStatus = RegEnumEnd(&hCompany);
 

    return dwStatus;   
}    


//-------------------------------------------------------

void
ReleasePolicyModule(
    CTLSPolicy* ptr
    )
/*++

++*/
{
    PolicyMgr.ReleaseProductPolicyModule(ptr);
}    


//-------------------------------------------------------
BOOL
TranslateCHCodeToTlsCode(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductId,
    IN LPTSTR pszTlsProductId,
    IN OUT PDWORD pdwBufferSize
    )
/*++


--*/
{
    return PolicyMgr.TranslateCHCodeToTlsCode(
                                        pszCompanyName,
                                        pszCHProductId,
                                        pszTlsProductId,
                                        pdwBufferSize
                                    );
}
    
//-------------------------------------------------------
CTLSPolicy*
AcquirePolicyModule(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductId,
    IN BOOL bUseProductPolicy
    )
/*++

Abstract:

    Acquire a policy module base on company name and product code.

Parameter:

    pszCompanyName : Company Name.
    pszProductId : Product Code.
    bUseProductPolicy : TRUE if only exact product policy module, FALSE uses
                        default policy module if can't find a policy module for 
                        product.

Return:

    Pointer to CTLSPolicy or NULL if not found.


Remark:

    Default behavior.

++*/
{
    CTLSPolicy* ptr;


    ptr = PolicyMgr.AcquireProductPolicyModule(
                            pszCompanyName,
                            pszProductId
                        );

    if(ptr == NULL && bUseProductPolicy == FALSE)
    {
        ptr = PolicyMgr.AcquireProductPolicyModule(
                                pszCompanyName,
                                NULL
                            );
    }

    if(ptr == NULL && bUseProductPolicy == FALSE)
    {
        ptr = PolicyMgr.AcquireProductPolicyModule(
                                g_szDefPolCompanyName,
                                g_szDefProductId
                            );
    }


    if(ptr == NULL)
    {
        TLSLogEvent(
                EVENTLOG_WARNING_TYPE,
                TLS_E_LOADPOLICY,
                TLS_E_NOPOLICYMODULE,
                pszCompanyName,
                pszProductId
            );
        
        SetLastError(TLS_E_NOPOLICYMODULE);
    }

    return ptr;
}


/////////////////////////////////////////////////////////
//
// Class CTLSPolicyMgr 
//
/////////////////////////////////////////////////////////
CTLSPolicyMgr::CTLSPolicyMgr()
/*++

++*/
{
    CTLSPolicy* ptr;
    PolicyModule pm;

    //
    // Load default name for default policy module
    //
    LoadResourceString(
                IDS_DEFAULT_POLICY,
                g_szDefPolCompanyName,
                sizeof(g_szDefPolCompanyName) / sizeof(g_szDefPolCompanyName[0]) - 1
            );

    LoadResourceString(
                IDS_DEFAULT_POLICY,
                g_szDefProductId,
                sizeof(g_szDefProductId) / sizeof(g_szDefProductId[0]) - 1
            );


    lstrcpy(pm.m_szCompanyName, g_szDefPolCompanyName);
    lstrcpy(pm.m_szProductId, g_szDefProductId);
                
    //
    // Create a default policy module to handle all cases...
    //
    ptr = new CTLSPolicy;
    ptr->CreatePolicy(
                (HMODULE) INVALID_HANDLE_VALUE,
                g_szDefPolCompanyName,
                g_szDefProductId,
                PMReturnLicense,
                PMLicenseUpgrade,
                PMLicenseRequest,
                PMUnloadProduct,
                PMInitializeProduct,
                PMRegisterLicensePack
            );

    //m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);

    m_ProductPolicyModule[pm] = ptr;

    //m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);
    //m_Handles.insert( 
    //        pair<PolicyModule, CTLSPolicy*>(pm, ptr) 
    //    );
}    

//-------------------------------------------------------
CTLSPolicyMgr::~CTLSPolicyMgr()
/*++

++*/
{
    m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);

    for( PMProductPolicyMapType::iterator it = m_ProductPolicyModule.begin(); 
         it != m_ProductPolicyModule.end(); 
         it++ )   
    {
        CTLSPolicy* ptr = (CTLSPolicy*) (*it).second;
        delete ptr;
    }

    m_ProductPolicyModule.erase(m_ProductPolicyModule.begin(), m_ProductPolicyModule.end());
    m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);


    m_LoadedPolicyRWLock.Acquire(WRITER_LOCK);
    for(PMLoadedModuleMapType::iterator loadedit = m_LoadedPolicy.begin();
        loadedit != m_LoadedPolicy.end();
        loadedit++ )
    {
        HMODULE hModule = (HMODULE) (*loadedit).second;
        if(hModule != NULL)
        {
            UnloadPolicyModule(hModule);
            FreeLibrary(hModule);
        }
    }

    m_LoadedPolicy.erase(m_LoadedPolicy.begin(), m_LoadedPolicy.end());
    m_LoadedPolicyRWLock.Release(WRITER_LOCK);

    m_ProductTranslationRWLock.Acquire(WRITER_LOCK);
    m_ProductTranslation.erase(m_ProductTranslation.begin(), m_ProductTranslation.end());
    m_ProductTranslationRWLock.Release(WRITER_LOCK);
}

//-------------------------------------------------------
HMODULE
CTLSPolicyMgr::LoadPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductCode,
    LPCTSTR pszDllName
    )
/*++

--*/
{
    HMODULE hModule;
    PMLoadedModuleMapType::iterator it;
    PolicyModule pm;
    
    memset(&pm, 0, sizeof(pm));

    if(pszCompanyName)
    {
        _tcscpy(pm.m_szCompanyName, pszCompanyName);
    }

    if(pszProductCode)
    {
        _tcscpy(pm.m_szProductId, pszProductCode);
    }

    m_LoadedPolicyRWLock.Acquire(WRITER_LOCK);

    it = m_LoadedPolicy.find( pm );

    if(it != m_LoadedPolicy.end())
    {
        hModule = (HMODULE) (*it).second;
    }
    else
    {
        hModule = ::LoadPolicyModule(
                                pszDllName,
                                NULL,
                                NULL
                            );

        if(hModule != NULL)
        {
            m_LoadedPolicy[pm] = hModule;
        }
    }

    m_LoadedPolicyRWLock.Release(WRITER_LOCK);

    return hModule;
}

//-------------------------------------------------------
DWORD
CTLSPolicyMgr::UnloadPolicyModule(
    HMODULE hModule
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSPMTerminate pfnTerminate;


    if(hModule != NULL)
    {
        pfnTerminate = (TLSPMTerminate) GetProcAddress(
                                    hModule,
                                    TEMINATEPROCNAME
                                );

        if(pfnTerminate != NULL)
        {
            pfnTerminate();
        }
        else
        {
            dwStatus = GetLastError();
        }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
    


//-------------------------------------------------------

DWORD
CTLSPolicyMgr::UnloadPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductCode
    )
/*++

    Not supported yet, need to remove all product policy in m_ProductPolicyModule()
    then unload DLL

--*/
{
    return ERROR_SUCCESS;
}

//-------------------------------------------------------
DWORD
CTLSPolicyMgr::InitProductPolicyModule()
/*++

++*/
{
    DWORD dwCount = 0;

    m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);

    for( PMProductPolicyMapType::iterator it = m_ProductPolicyModule.begin(); 
         it != m_ProductPolicyModule.end(); 
         it++ )   
    {
        CTLSPolicy* ptr = (CTLSPolicy*) (*it).second;
        if(ptr->InitializePolicyModule() == ERROR_SUCCESS)
        {
            dwCount++;
        }
    }

    m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);

    return dwCount;
}

//-------------------------------------------------------
CTLSPolicyMgr::PMProductTransationMapType::iterator
CTLSPolicyMgr::FindProductTransation(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode
    )
/*++

--*/
{
    PolicyModule pm;
    PMProductTransationMapType::iterator it;

    memset(&pm, 0, sizeof(pm));
    if(pszCompanyName)
    {
        lstrcpyn(   
                pm.m_szCompanyName, 
                pszCompanyName, 
                sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0])
            );
    }

    if(pszCHProductCode)
    {
        lstrcpyn(
                pm.m_szProductId,
                pszCHProductCode,
                sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0])
            );
    }

    it = m_ProductTranslation.find( pm );
    return it;
}

//-------------------------------------------------------
BOOL
CTLSPolicyMgr::TranslateCHCodeToTlsCode(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHCode,
    LPTSTR pszTlsProductCode,
    PDWORD pdwBufferSize
    )
/*++


--*/
{
    PMProductTransationMapType::iterator it;
    DWORD dwBufSize = *pdwBufferSize;

    SetLastError(ERROR_SUCCESS);

    m_ProductTranslationRWLock.Acquire(READER_LOCK);

    it = FindProductTransation(
                        pszCompanyName, 
                        pszCHCode
                    );

    if(it == m_ProductTranslation.end())
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        lstrcpyn(
                pszTlsProductCode,
                (*it).second.m_szProductId,
                dwBufSize
            );

        *pdwBufferSize = lstrlen((*it).second.m_szProductId);
        if(*pdwBufferSize >= dwBufSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    m_ProductTranslationRWLock.Release(READER_LOCK);

    return GetLastError() == ERROR_SUCCESS;
}

//-------------------------------------------------------
void
CTLSPolicyMgr::InsertProductTransation(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode,
    LPCTSTR pszTLSProductCode
    )
/*++

    List must be locked before entering this routine.

--*/
{
    PolicyModule key;
    PolicyModule value;

    memset(&key, 0, sizeof(key));
    memset(&value, 0, sizeof(value));

    if(pszCompanyName)
    {
        lstrcpyn(
                key.m_szCompanyName,
                pszCompanyName,
                sizeof(key.m_szCompanyName)/sizeof(key.m_szCompanyName[0])
            );

        lstrcpyn(
                value.m_szCompanyName,
                pszCompanyName,
                sizeof(value.m_szCompanyName)/sizeof(value.m_szCompanyName[0])
            );
    }

    if(pszCHProductCode)
    {
        lstrcpyn(
                key.m_szProductId,
                pszCHProductCode,
                sizeof(key.m_szProductId)/sizeof(key.m_szProductId[0])
            );
    }

    if(pszTLSProductCode)
    {
        lstrcpyn(
                value.m_szProductId,
                pszTLSProductCode,
                sizeof(key.m_szProductId)/sizeof(key.m_szProductId[0])
            );
    }

    //
    // Replace if already exists.
    //
    m_ProductTranslation[key] = value;
    
    return;
}


//-------------------------------------------------------
CTLSPolicyMgr::PMProductPolicyMapType::iterator 
CTLSPolicyMgr::FindProductPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductId
    )
/*++

    Must acquire reader/writer lock before 
    calling this routine

++*/
{
    PolicyModule pm;
    PMProductPolicyMapType::iterator it;
    CTLSPolicy* ptr=NULL;

    memset(&pm, 0, sizeof(pm));

    if(pszCompanyName)
    {
        lstrcpyn(
                pm.m_szCompanyName, 
                pszCompanyName,
                sizeof(pm.m_szCompanyName)/sizeof(pm.m_szCompanyName[0])
                );
    }

    if(pszProductId)
    {
        lstrcpyn(
                pm.m_szProductId, 
                pszProductId,
                sizeof(pm.m_szProductId)/sizeof(pm.m_szProductId[0])
            );
    }

    it = m_ProductPolicyModule.find( pm );
    return it;
}

//-------------------------------------------------------
DWORD
CTLSPolicyMgr::GetSupportedProduct(
    IN HINSTANCE hPolicyModule,
    IN LPCTSTR pszDllName,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductId,
    IN OUT PDWORD pdwNumProducts,
    OUT PPMSUPPORTEDPRODUCT* pSupportedProduct
    )
/*++

Abstract:

    Get list of supported product from policy module

Parameters:

    pszCompanyName : Name of the company in registry
    pszProductId : Name of the product in registry
    pdwNumProducts : Pointer to DWORD, return number of product supported by policy module
    ppszSupportedProduct : Pointer to string array, return number of product supported by policy module.

Return:
     
--*/
{
    TLSPMInitialize pfnPMInitialize = NULL;
    POLICYSTATUS dwPolStatus = POLICY_SUCCESS;
    DWORD dwPolRetCode = ERROR_SUCCESS;

    DWORD dwStatus = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;
    PPMSUPPORTEDPRODUCT pProductList = NULL;
    DWORD dwIndex;

    *pSupportedProduct = NULL;
    *pdwNumProducts = 0;

    if(hPolicyModule != NULL && pszCompanyName != NULL && pdwNumProducts != NULL && pSupportedProduct != NULL)
    {
        pfnPMInitialize = (TLSPMInitialize) GetProcAddress(
                                            hPolicyModule,
                                            INITIALIZEPROCNAME
                                        );

        if(pfnPMInitialize != NULL)
        {
            __try {                                

                dwPolStatus = pfnPMInitialize(
                                            TLS_CURRENT_VERSION,
                                            pszCompanyName,
                                            pszProductId,
                                            pdwNumProducts,
                                            &pProductList,
                                            &dwPolRetCode
                                        );

                if(dwPolStatus != POLICY_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_WARNING_TYPE,
                            TLS_E_LOADPOLICY,
                            TLS_E_POLICYMODULEPMINITALIZZE,
                            pszCompanyName,
                            pszProductId,
                            dwPolRetCode
                        );

                    dwStatus = TLS_E_REQUESTDENYPOLICYERROR;
                }
                else if(*pdwNumProducts != 0 && pProductList != NULL)
                {
                    *pSupportedProduct = (PPMSUPPORTEDPRODUCT)AllocateMemory(sizeof(PMSUPPORTEDPRODUCT) * (*pdwNumProducts));
                    if(*pSupportedProduct != NULL)
                    {
                        for(dwIndex = 0; dwIndex < *pdwNumProducts && dwStatus == ERROR_SUCCESS; dwIndex ++)
                        {
                            (*pSupportedProduct)[dwIndex] = pProductList[dwIndex];
                        }
                    }
                    else
                    {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                }
            }
            
            __except (
                ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
                EXCEPTION_EXECUTE_HANDLER )
            {
                dwStatus = ExceptionCode.ExceptionCode;

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE, 
                        TLS_E_LOADPOLICY,
                        TLS_E_POLICYMODULEEXCEPTION, 
                        pszCompanyName,
                        pszProductId,
                        dwStatus
                    );

                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_POLICY,
                        DBG_ALL_LEVEL,
                        _TEXT("<%s - %s> : PMInitialize() caused exception 0x%08x\n"),
                        pszCompanyName,
                        pszProductId,
                        dwStatus
                    );

            }
        }
        else
        {
            //
            // Policy module must support PMInitialize
            //
            dwStatus = TLS_E_LOADPOLICYMODULE_API;
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE, 
                    TLS_E_LOADPOLICY,
                    TLS_E_LOADPOLICYMODULE_API,
                    INITIALIZEPROCNAME
                );
        }
    }
    else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(pSupportedProduct != NULL)
        {
            FreeMemory(pSupportedProduct);
        }
    }

    return dwStatus;
}

//-----------------------------------------------------------
DWORD
CTLSPolicyMgr::InsertProductPolicyModule(
    IN HMODULE hModule,
    IN BOOL bReplace,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    IN LPCTSTR pszDllName,
    IN DWORD dwFlag
    )
/*++

Abstract:

    Insert or replace an existing policy module

Parameters:

    bReplace : TRUE if replace existing policy module, FALSE otherwise.
    pszCompanyName : Name of the company.
    pszProductId : Name of the product.
    pszDllName : Full path to the policy DLL.
    
returns:


++*/
{
    CTLSPolicy* ptr;
    DWORD dwErrCode = ERROR_SUCCESS;

    PMProductPolicyMapType::iterator it;
    PMProductTransationMapType::iterator translation_it;
    

    //
    // Lock module array
    //
    m_ProductPolicyModuleRWLock.Acquire(WRITER_LOCK);
    m_ProductTranslationRWLock.Acquire(WRITER_LOCK);

    it = FindProductPolicyModule(
                        pszCompanyName,
                        pszTLSProductCode
                    );

    translation_it = FindProductTransation(
                                    pszCompanyName,
                                    pszCHProductCode
                                );

    if( translation_it != m_ProductTranslation.end() && it == m_ProductPolicyModule.end() )
    {
        dwErrCode = TLS_E_INTERNAL;
        goto cleanup;
    }
       
    //
    // insert transation
    //
    InsertProductTransation(
                        pszCompanyName,
                        pszCHProductCode,
                        pszTLSProductCode
                    );

    // 
    // Replace policy module - 
    //  
    
    ptr = new CTLSPolicy;
    
    if(ptr != NULL)
    {
        dwErrCode = ptr->Initialize(
                                hModule,
                                pszCompanyName, 
                                pszCHProductCode,
                                pszTLSProductCode, 
                                pszDllName,
                                dwFlag
                            );

        if(dwErrCode == ERROR_SUCCESS || dwFlag == POLICY_DENY_ALL_REQUEST)
        {
            
            PolicyModule pm;

            if(pszCompanyName)
            {
                _tcscpy(pm.m_szCompanyName, pszCompanyName);
            }

            if(pszTLSProductCode)
            {
                _tcscpy(pm.m_szProductId, pszTLSProductCode);
            }

            // m_Handles.insert( pair<PolicyModule, CTLSPolicy*>(pm, ptr) );
            m_ProductPolicyModule[pm] = ptr;        
        }
    }
    else
    {
            dwErrCode = ERROR_OUTOFMEMORY;

    }

cleanup:
    m_ProductTranslationRWLock.Release(WRITER_LOCK);
    m_ProductPolicyModuleRWLock.Release(WRITER_LOCK);
    return dwErrCode;
}

//----------------------------------------------------------------------
DWORD
CTLSPolicyMgr::AddPolicyModule(
    IN BOOL bReplace,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductCode,
    IN LPCTSTR pszDllName,
    IN DWORD dwFlag
    )
/*++

Abstract:

    Insert or replace an existing policy module

Parameters:

    bReplace : TRUE if replace existing policy module, FALSE otherwise.
    pszCompanyName : Name of the company.
    pszProductId : Name of the product.
    pszDllName : Full path to the policy DLL.
    
returns:


++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    DWORD dwNumProduct;
    DWORD dwIndex; 
    DWORD dwUnloadIndex;
    HINSTANCE hInstance = NULL;    
    PMProductPolicyMapType::iterator it;
    PPMSUPPORTEDPRODUCT pSupportedProduct = NULL;

    //
    // Load policy module.
    //    
    hInstance = LoadPolicyModule(
                            pszCompanyName,
                            pszProductCode,
                            pszDllName
                        );

    if(hInstance != NULL)
    {
        //
        // Insert all support product
        //
        dwErrCode = GetSupportedProduct(
                                hInstance,
                                pszDllName,
                                pszCompanyName,
                                pszProductCode,
                                &dwNumProduct,
                                &pSupportedProduct
                            );

        if(dwNumProduct != 0 && pSupportedProduct != NULL)
        {
            for(dwIndex=0; 
                dwIndex < dwNumProduct && dwErrCode == ERROR_SUCCESS; 
                dwIndex++)
            {
                dwErrCode = InsertProductPolicyModule(
                                            hInstance,
                                            bReplace,
                                            pszCompanyName,
                                            pSupportedProduct[dwIndex].szCHSetupCode,
                                            pSupportedProduct[dwIndex].szTLSProductCode,
                                            pszDllName,
                                            dwFlag
                                        );
            }
        }
        else
        {
            dwErrCode = InsertProductPolicyModule(
                                        hInstance,
                                        bReplace,
                                        pszCompanyName,
                                        pszProductCode,
                                        pszProductCode,
                                        pszDllName,
                                        dwFlag
                                    );
        }
    }
    else
    {
        dwErrCode = GetLastError();
    }

    if(dwErrCode != ERROR_SUCCESS)
    {
        //
        // unload this policy module
        //
        for(dwUnloadIndex = 0; dwUnloadIndex < dwIndex; dwUnloadIndex++)
        {
            it = FindProductPolicyModule(
                                pszCompanyName,
                                pSupportedProduct[dwIndex].szTLSProductCode
                            );

            if(it != m_ProductPolicyModule.end())
            {
                CTLSPolicy *ptr;

                ptr = (CTLSPolicy *)(*it).second;
                delete ptr;
                m_ProductPolicyModule.erase(it);
            }
        }

        //
        // Let destructor to unload DLL
        //
    }
                
    if(pSupportedProduct != NULL)
    {
        FreeMemory(pSupportedProduct);
    }


    return dwErrCode;
}

//-------------------------------------------------------
CTLSPolicy*
CTLSPolicyMgr::AcquireProductPolicyModule(
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductId
    )
/*++

++*/
{
    m_ProductPolicyModuleRWLock.Acquire(READER_LOCK);

    PMProductPolicyMapType::iterator it;
    CTLSPolicy* ptr=NULL;

    it = FindProductPolicyModule(
                    pszCompanyName,
                    pszProductId
                );

    if(it != m_ProductPolicyModule.end())
    {
        ptr = (*it).second;
        ptr->Acquire();
    }
    
    m_ProductPolicyModuleRWLock.Release(READER_LOCK);
    return ptr;
}

//-------------------------------------------------------
void
CTLSPolicyMgr::ReleaseProductPolicyModule(
    CTLSPolicy* p 
    )
/*++

++*/
{
    assert(p != NULL);

    p->Release();
    return;
}


/////////////////////////////////////////////////////////
//
// CTLSPolicy Implementation
//
/////////////////////////////////////////////////////////
//-------------------------------------------------------
  

DWORD
CTLSPolicy::InitializePolicyModule()
{
    DWORD dwStatus=ERROR_SUCCESS;

    if(m_dwModuleState == MODULE_LOADED)
    {
        //
        // Initialize Policy Module
        //
        dwStatus = PMInitProduct();
    }
    else if(m_dwModuleState == MODULE_ERROR)
    {
        dwStatus = TLS_E_POLICYERROR;
    }
    else if(m_dwModuleState != MODULE_PMINITALIZED)
    {
        dwStatus = TLS_E_POLICYNOTINITIALIZE;
    }

    return dwStatus;
}
   

//-------------------------------------------------------

DWORD
CTLSPolicy::Initialize(
    IN HINSTANCE hInstance,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    IN LPCTSTR pszDllName,
    IN DWORD dwDllFlags     // deny all request if failed to load
    )
/*++

Abstract:

    This routine load the policy module's DLL.

Parameters:

    pszCompanyName : Name of the company.
    pszProductId : Product Id.
    pszDllName : Full path to policy module's DLL.

Returns:

    ERROR_SUCCESS or error code from LoadLibrary() or 
    GetProAddress().

++*/
{
    m_dwFlags = dwDllFlags;
    DWORD dwErrCode=ERROR_SUCCESS;
    TCHAR  szDllFullPath[MAX_PATH+1];
    DWORD  dwBuffSize = MAX_PATH;

    if(hInstance == NULL)
    {
        dwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // Set the module state to unknown
    //
    SetModuleState(MODULE_UNKNOWN);
    SetLastError(ERROR_SUCCESS);

    //
    // Load policy module
    //
    m_hPolicyModule = hInstance;

    // make sure all require API is exported.
    m_pfnReturnLicense = (TLSPMReturnLicense) GetProcAddress(
                                                    m_hPolicyModule,
                                                    RETURNLICENSEPROCNAME
                                                );

    if(m_pfnReturnLicense == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                RETURNLICENSEPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnLicenseUpgrade = (TLSPMLicenseUpgrade) GetProcAddress(
                                                    m_hPolicyModule,
                                                    LICENSEUPGRADEPROCNAME
                                                );
    if(m_pfnLicenseUpgrade == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                LICENSEUPGRADEPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnLicenseRequest = (TLSPMLicenseRequest) GetProcAddress(
                                                    m_hPolicyModule,
                                                    LICENSEREQUESTPROCNAME
                                                );
    if(m_pfnLicenseRequest == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                LICENSEREQUESTPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnUnloadProduct = (TLSPMUnloadProduct) GetProcAddress(
                                            m_hPolicyModule,
                                            ULOADPRODUCTPROCNAME
                                        );
    if(m_pfnUnloadProduct == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                ULOADPRODUCTPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnInitProduct = (TLSPMInitializeProduct) GetProcAddress(
                                            m_hPolicyModule,
                                            SUPPORTEDPRODUCTPROCNAME
                                        );

    if(m_pfnInitProduct == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                INITIALIZEPROCNAME
            );
       
        goto cleanup;
    }

    m_pfnRegisterLkp = (TLSPMRegisterLicensePack) GetProcAddress(
                                            m_hPolicyModule,
                                            REGISTERLKPPROCNAME
                                        );

    if(m_pfnRegisterLkp == NULL)
    {
        dwErrCode = GetLastError();
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_LOADPOLICY,
                TLS_E_LOADPOLICYMODULE_API,
                REGISTERLKPPROCNAME
            );
       
        goto cleanup;
    }
    
    //
    // Everything is OK, advance module state
    //
    SetModuleState(MODULE_LOADED);

    if(pszCompanyName)
    {
        _tcsncpy(
                m_szCompanyName, 
                pszCompanyName,
                sizeof(m_szCompanyName) / sizeof(m_szCompanyName[0])
            );
    }

    if(pszTLSProductCode)
    {
        _tcsncpy(
                m_szProductId, 
                pszTLSProductCode,
                sizeof(m_szProductId)/sizeof(m_szProductId[0])
            );
    }
    else
    {
        LoadResourceString(
                    IDS_UNKNOWN_STRING,
                    m_szProductId,
                    sizeof(m_szProductId) / sizeof(m_szProductId[0])
                ); 
    }

    if(pszCHProductCode)
    {
        _tcsncpy(
                m_szCHProductId, 
                pszCHProductCode,
                sizeof(m_szCHProductId)/sizeof(m_szCHProductId[0])
            );
    }
    else
    {
        LoadResourceString(
                    IDS_UNKNOWN_STRING,
                    m_szCHProductId,
                    sizeof(m_szCHProductId) / sizeof(m_szCHProductId[0])
                ); 
    }


       
cleanup:

    if(IsValid() == FALSE)
    {
        TLSLogEvent(
                EVENTLOG_WARNING_TYPE,
                TLS_E_LOADPOLICY,
                (m_dwFlags == POLICY_DENY_ALL_REQUEST) ?
                                TLS_W_LOADPOLICYMODULEDENYALLREQUEST : TLS_W_LOADPOLICYMODULEUSEDEFAULT,
                pszDllName
            );

        //
        // don't report error again.
        //
        m_bAlreadyLogError = TRUE;
    }

    return dwErrCode;
}

//---------------------------------------------------------------------------

BOOL
CTLSPolicy::IsValid()
/*++

Abstract:

    This routine determine if the CTLSPolicy object is valid or not.

Parameters:

    None.

Returns:

    TRUE if valid, FALSE otherwise.

++*/
{
    return (m_hPolicyModule != NULL &&
            m_pfnReturnLicense != NULL &&
            m_pfnLicenseUpgrade != NULL &&
            m_pfnLicenseRequest != NULL &&
            m_pfnUnloadProduct != NULL &&
            m_pfnInitProduct != NULL &&
            m_pfnRegisterLkp != NULL);
}

//---------------------------------------------------------------------------
void
CTLSPolicy::LogPolicyRequestStatus(
    DWORD dwMsgId
    )
/*++

--*/
{
    if(m_dwLastCallStatus != POLICY_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_WARNING_TYPE,
                TLS_E_POLICYERROR,
                dwMsgId,
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );
        
        if(m_dwLastCallStatus == POLICY_CRITICAL_ERROR)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    TLS_E_CRITICALPOLICYMODULEERROR,
                    GetCompanyName(),
                    GetProductId,
                    m_dwPolicyErrCode
                );

            SetModuleState(MODULE_ERROR);
        }
    }

    return;
}

//----------------------------------------------------------

DWORD
CTLSPolicy::PMReturnLicense(
	PMHANDLE hClient,
	ULARGE_INTEGER* pLicenseSerialNumber,
	PPMLICENSETOBERETURN pLicenseTobeReturn,
	PDWORD pdwLicenseStatus
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    _set_se_translator( trans_se_func );
    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    __try {

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMReturnLicense()\n"),
                GetCompanyName(),
                GetProductId()
            );

        m_dwLastCallStatus = m_pfnReturnLicense(
                                    hClient,
                                    pLicenseSerialNumber,
                                    pLicenseTobeReturn,
                                    pdwLicenseStatus,
                                    &m_dwPolicyErrCode
                                );

        if(m_dwLastCallStatus != POLICY_SUCCESS)
        {
            LogPolicyRequestStatus(TLS_E_POLICYDENYRETURNLICENSE);
            dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
        }
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        m_dwPolicyErrCode = ExceptionCode.ExceptionCode;
        dwErrCode = TLS_E_POLICYMODULEEXCEPTION;
        m_dwLastCallStatus = POLICY_CRITICAL_ERROR;

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_POLICYERROR,
                TLS_E_POLICYMODULEEXCEPTION, 
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMReturnLicense() caused exception 0x%08x\n"),
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        SetModuleState(MODULE_ERROR);
        TLSASSERT(FALSE);
    }

    return dwErrCode;
}

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMLicenseUpgrade(
	PMHANDLE hClient,
	DWORD dwProgressCode,
	PVOID pbProgressData,
	PVOID* ppbReturnData
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    _set_se_translator( trans_se_func );
    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    __try {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMLicenseUpgrade()\n"),
                GetCompanyName(),
                GetProductId()
            );

        m_dwLastCallStatus = m_pfnLicenseUpgrade(
	                            hClient,
	                            dwProgressCode,
	                            pbProgressData,
	                            ppbReturnData,
                                &m_dwPolicyErrCode
                            );

        if(m_dwLastCallStatus != ERROR_SUCCESS)
        {
            dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
            LogPolicyRequestStatus(TLS_E_POLICYDENYUPGRADELICENSE);
        }
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        m_dwPolicyErrCode = ExceptionCode.ExceptionCode;
        dwErrCode = TLS_E_POLICYMODULEEXCEPTION;
        m_dwLastCallStatus = POLICY_CRITICAL_ERROR;

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_POLICYERROR,
                TLS_E_POLICYMODULEEXCEPTION, 
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMLicenseUpgrade() caused exception 0x%08x\n"),
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        SetModuleState(MODULE_ERROR);
        TLSASSERT(FALSE);
    }

    return dwErrCode;
}

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    const PVOID pbProgressData, 
    PVOID* pbNewProgressData
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    _set_se_translator( trans_se_func );
    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    __try {

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMLicenseRequest()\n"),
                GetCompanyName(),
                GetProductId()
            );

        m_dwLastCallStatus = m_pfnLicenseRequest(
                                client,
                                dwProgressCode, 
                                pbProgressData, 
                                pbNewProgressData,
                                &m_dwPolicyErrCode
                            );

        if(m_dwLastCallStatus != ERROR_SUCCESS)
        {
            LogPolicyRequestStatus(TLS_E_POLICYDENYNEWLICENSE);
            dwErrCode =  TLS_E_REQUESTDENYPOLICYERROR;
        }
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        m_dwPolicyErrCode = ExceptionCode.ExceptionCode;
        dwErrCode = TLS_E_POLICYMODULEEXCEPTION;
        m_dwLastCallStatus = POLICY_CRITICAL_ERROR;

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_POLICYERROR,
                TLS_E_POLICYMODULEEXCEPTION, 
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMLicenseRequest() caused exception 0x%08x\n"),
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        SetModuleState(MODULE_ERROR);
        TLSASSERT(FALSE);
    }

    return dwErrCode;
}

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMUnload()
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    _set_se_translator( trans_se_func );

    //
    // Don't call PMUnloadProduct if policy module
    // already in error state.
    //
    if(m_dwModuleState == MODULE_ERROR)
    {
        return ERROR_SUCCESS;
    }

    __try {
        m_dwLastCallStatus = m_pfnUnloadProduct(
                                        GetCompanyName(), 
                                        GetCHProductId(),
                                        GetProductId(),
                                        &m_dwPolicyErrCode
                                    );

        if(m_dwLastCallStatus != POLICY_SUCCESS)
        {
            LogPolicyRequestStatus(TLS_E_POLICYUNLOADPRODUCT);
            dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
        }
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        m_dwPolicyErrCode = ExceptionCode.ExceptionCode;
        dwErrCode = TLS_E_POLICYMODULEEXCEPTION;
        m_dwLastCallStatus = POLICY_CRITICAL_ERROR;

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_POLICYERROR,
                TLS_E_POLICYMODULEEXCEPTION, 
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        SetModuleState(MODULE_ERROR);
        TLSASSERT(FALSE);
    }

    //
    // Always terminate module even error occurred
    //
    SetModuleState(MODULE_PMTERMINATED);
    return dwErrCode;
}
    

//--------------------------------------------------------------

DWORD
CTLSPolicy::PMInitProduct()
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    _set_se_translator( trans_se_func );

    if(IsValid() == FALSE)
    {
        return TLS_E_POLICYNOTINITIALIZE;
    }

    __try {

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMInitialize()\n"),
                GetCompanyName(),
                GetProductId()
            );

        m_dwLastCallStatus = m_pfnInitProduct(
                                    GetCompanyName(),
                                    GetCHProductId(),
                                    GetProductId(),
                                    &m_dwPolicyErrCode
                                );        


        if(m_dwLastCallStatus != POLICY_SUCCESS)
        {
            LogPolicyRequestStatus(TLS_E_POLICYINITPRODUCT);
            dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
        }
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        m_dwPolicyErrCode = ExceptionCode.ExceptionCode;
        dwErrCode = TLS_E_POLICYMODULEEXCEPTION;
        m_dwLastCallStatus = POLICY_CRITICAL_ERROR;

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_POLICYERROR,
                TLS_E_POLICYMODULEEXCEPTION, 
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        SetModuleState(MODULE_ERROR);
        TLSASSERT(FALSE);
    }

    SetModuleState(
            (dwErrCode == ERROR_SUCCESS) ? MODULE_PMINITALIZED : MODULE_ERROR
        );

    return dwErrCode;
}

//--------------------------------------------------------------

void
CTLSPolicy::Unload() 
/*++

++*/
{
    if(m_hPolicyModule == NULL || m_hPolicyModule == INVALID_HANDLE_VALUE)
        return;

    assert(GetRefCount() == 0);

    m_pfnReturnLicense = NULL;
    m_pfnLicenseUpgrade = NULL;
    m_pfnLicenseRequest = NULL;
    m_pfnUnloadProduct = NULL;
    m_pfnInitProduct = NULL;
    m_pfnRegisterLkp = NULL;
    m_hPolicyModule = NULL;
    m_RefCount  = 0;
    m_bAlreadyLogError = FALSE;
    SetModuleState(MODULE_UNKNOWN);
}

//-------------------------------------------------------------------

DWORD
CTLSPolicy::PMRegisterLicensePack(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    const PVOID pbProgessData,
    PVOID pbProgressRetData
    )
/*++

++*/
{
    DWORD dwErrCode = ERROR_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    _set_se_translator( trans_se_func );

    dwErrCode = InitializePolicyModule();
    if(dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }

    __try {

        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_POLICY,
                DBG_ALL_LEVEL,
                _TEXT("<%s - %s> : PMRegisterLicensePack()\n"),
                GetCompanyName(),
                GetProductId()
            );

        m_dwLastCallStatus = m_pfnRegisterLkp(
                                    hClient,
                                    dwProgressCode,
                                    pbProgessData,
                                    pbProgressRetData,
                                    &m_dwPolicyErrCode
                                );

        if(m_dwLastCallStatus != POLICY_SUCCESS)
        {
            LogPolicyRequestStatus(TLS_E_POLICYMODULEREGISTERLKP);
            dwErrCode = TLS_E_REQUESTDENYPOLICYERROR;
        }
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        m_dwPolicyErrCode = ExceptionCode.ExceptionCode;
        dwErrCode = TLS_E_POLICYMODULEEXCEPTION;
        m_dwLastCallStatus = POLICY_CRITICAL_ERROR;

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_POLICYERROR,
                TLS_E_POLICYMODULEEXCEPTION, 
                GetCompanyName(),
                GetProductId(),
                m_dwPolicyErrCode
            );

        SetModuleState(MODULE_ERROR);
        TLSASSERT(FALSE);
    }

    return dwErrCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\pid.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        pid.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __PID_H__
#define __PID_H__

#include "srvdef.h"

#define NTPID_REGISTRY  _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define NTPID_VALUE     _TEXT("ProductId")

#define TLSUNIQUEID_SIZE        5
#define MAX_PID20_LENGTH        25


#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSGeneratePid(
        OUT LPTSTR* pszTlsPid,
        OUT PDWORD  pcbTlsPid,
        OUT LPTSTR* pszTlsUniqueId,
        OUT PDWORD  pcbTlsUniqueId
    );


    DWORD
    LoadNtPidFromRegistry(
        OUT LPTSTR* ppbNtPid
    );


    DWORD
    ServerIdsToLsaServerId(
        IN PBYTE pbServerUniqueId,
        IN DWORD cbServerUniqueId,
        IN PBYTE pbServerPid,
        IN DWORD cbServerPid,
        IN PBYTE pbServerSPK,
        IN DWORD cbServerSPK,
        IN PCERT_EXTENSION pCertExtensions,
        IN DWORD dwNumCertExtensions,
        OUT PTLSLSASERVERID* ppLsaServerId,
        OUT DWORD* pdwLsaServerId
    );

    DWORD
    LsaServerIdToServerIds(
        IN PTLSLSASERVERID pLsaServerId,
        IN DWORD dwLsaServerId,
        OUT PBYTE* ppbServerUniqueId,
        OUT PDWORD pcbServerUniqueId,
        OUT PBYTE* ppbServerPid,
        OUT PDWORD pcbServerPid,
        OUT PBYTE* ppbServerSPK,
        OUT PDWORD pcbServerSPK,
        OUT PCERT_EXTENSIONS* pCertExtensions,
        OUT PDWORD pdwNumCertExtensions
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\policy.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        policy.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __POLICY_MODULE_MGR__
#define __POLICY_MODULE_MGR__

#include "tlsstl.h"    // STL.

#include <stdio.h>
#include <tchar.h>
#include "tlsdef.h"
#include "tlspol.h"
#include "locks.h"

#define RETURNLICENSEPROCNAME       "PMReturnLicense"
#define LICENSEUPGRADEPROCNAME      "PMLicenseUpgrade"
#define LICENSEREQUESTPROCNAME      "PMLicenseRequest"
#define TEMINATEPROCNAME            "PMTerminate"
#define INITIALIZEPROCNAME          "PMInitialize"
#define SUPPORTEDPRODUCTPROCNAME    "PMInitializeProduct"
#define ULOADPRODUCTPROCNAME        "PMUnloadProduct"
#define REGISTERLKPPROCNAME         "PMRegisterLicensePack"

#define POLICY_DENY_ALL_REQUEST     0x00000000
#define POLICY_USE_DEFAULT          0x00000001

typedef POLICYSTATUS (WINAPI *TLSPMReturnLicense)(
	                        PMHANDLE hClient,
	                        ULARGE_INTEGER* pLicenseSerialNumber,
                            PPMLICENSETOBERETURN pLicenseToBeReturn,
	                        PDWORD pdwLicenseStatus,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI *TLSPMLicenseUpgrade)(
	                        PMHANDLE hClient,
	                        DWORD dwProgressCode,
	                        PVOID pbProgressData,
	                        PVOID* ppbReturnData,
                            PDWORD pdwRetCode
                        );	

typedef POLICYSTATUS (WINAPI *TLSPMLicenseRequest)(
                            PMHANDLE client,
                            DWORD dwProgressCode, 
                            PVOID pbProgressData, 
                            PVOID* pbNewProgressData,
                            PDWORD pdwRetCode
                        );

typedef void (WINAPI *TLSPMTerminate)();

typedef POLICYSTATUS (WINAPI* TLSPMInitialize)(
                            DWORD dwLicenseServerVersion,
                            LPCTSTR pszCompanyName,
                            LPCTSTR pszProductCode,
                            PDWORD pdwNumProduct,
                            PPMSUPPORTEDPRODUCT* ppProduct,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI* TLSPMInitializeProduct)(
                            LPCTSTR pszCompanyName,
                            LPCTSTR pszCHProductId,
                            LPCTSTR pszTLSProductId,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI* TLSPMUnloadProduct)(
                            LPCTSTR pszCompanyName,
                            LPCTSTR pszCHProductId,
                            LPCTSTR pszTLSProductCode,
                            PDWORD pdwRetCode
                        );

typedef POLICYSTATUS (WINAPI* TLSPMRegisterLicensePack)(
                            PMHANDLE hClient,
                            DWORD dwProgressCode,
                            PVOID pbProgressData,
                            PVOID pbProgressRetData,
                            PDWORD pdwRetCode
                        );
    
                             
class CTLSPolicyMgr;

////////////////////////////////////////////////////////////////////////////

class CTLSPolicy {

    friend class CTLSPolicyMgr;
    
private:
    typedef enum { 
        MODULE_UNKNOWN,             // object has been initialized.
        MODULE_LOADED,              // module has been loaded.
        MODULE_PMINITALIZED,        // module has been initialized.
        MODULE_PMTERMINATED,        // module has been terminated.
        MODULE_ERROR,               // module initialization error or 
                                    // cause an exeption
        MODULE_UNLOADED             // module has been unloaded.
    } MODULE_STATE;

    long m_RefCount;
    DWORD m_dwFlags;
    BOOL  m_bAlreadyLogError;

    POLICYSTATUS m_dwLastCallStatus;    // Policy Module last call status
    DWORD m_dwPolicyErrCode;            // Policy specific error code.

    MODULE_STATE m_dwModuleState;

    //
    // Policy module must be multi-thread safe.
    //    
    TLSPMReturnLicense  m_pfnReturnLicense;
    TLSPMLicenseUpgrade m_pfnLicenseUpgrade;
    TLSPMLicenseRequest m_pfnLicenseRequest;
    TLSPMUnloadProduct m_pfnUnloadProduct;
    TLSPMInitializeProduct m_pfnInitProduct;
    TLSPMRegisterLicensePack m_pfnRegisterLkp;


    HMODULE m_hPolicyModule;
    TCHAR   m_szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR   m_szProductId[LSERVER_MAX_STRING_SIZE+1];
    TCHAR   m_szCHProductId[LSERVER_MAX_STRING_SIZE+1];

    //--------------------------------------------------------------
    void
    SetDllFlags(DWORD dllFlags) 
    {
        m_dwFlags = dllFlags;
    }
       
    //--------------------------------------------------------------

    long
    Acquire()
    {
        return InterlockedIncrement(&m_RefCount);
    }

    //--------------------------------------------------------------

    long
    Release()
    {
        return InterlockedDecrement(&m_RefCount);
    }

    //--------------------------------------------------------------

    DWORD
    InitializePolicyModule();

    //--------------------------------------------------------------

    void
    SetModuleState(
        MODULE_STATE state
        )
    /*++
    
    ++*/
    {
        m_dwModuleState = state;
        return;
    }
    
    //-------------------------------------------------------------

    MODULE_STATE
    GetModuleState() 
    { 
        return m_dwModuleState; 
    }

    //-------------------------------------------------------------

    void
    CreatePolicy(
        HMODULE hModule,
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId,
        TLSPMReturnLicense pfnReturnLicense,
        TLSPMLicenseUpgrade pfnLicenseUpgrade,
        TLSPMLicenseRequest pfnLicenseRequest,
        TLSPMUnloadProduct pfnUnloadProduct,
        TLSPMInitializeProduct pfnInitProduct,
        TLSPMRegisterLicensePack pfnRegisterLkp
        )
    /*++
    
    ++*/
    {
        m_hPolicyModule = hModule;
        m_pfnReturnLicense = pfnReturnLicense;
        m_pfnLicenseUpgrade = pfnLicenseUpgrade;
        m_pfnLicenseRequest = pfnLicenseRequest;
        m_pfnUnloadProduct = pfnUnloadProduct;
        m_pfnInitProduct = pfnInitProduct;
        m_pfnRegisterLkp = pfnRegisterLkp;
        SetModuleState(MODULE_PMINITALIZED);

        lstrcpyn(
                m_szCompanyName, 
                pszCompanyName, 
                sizeof(m_szCompanyName) / sizeof(m_szCompanyName[0])
            );
        lstrcpyn(
                m_szProductId, 
                pszProductId, 
                sizeof(m_szProductId) / sizeof(m_szProductId[0])
            );
    }


    void
    LogPolicyRequestStatus(
        DWORD dwMsgId
    );

public:
    CTLSPolicy() : 
        m_pfnReturnLicense(NULL),
        m_pfnLicenseUpgrade(NULL),
        m_pfnLicenseRequest(NULL),
        m_pfnUnloadProduct(NULL),
        m_pfnInitProduct(NULL),
        m_pfnRegisterLkp(NULL),
        m_hPolicyModule(NULL),
        m_RefCount(0),
        m_bAlreadyLogError(FALSE),
        m_dwModuleState(MODULE_UNKNOWN),
        m_dwFlags(0),
        m_dwLastCallStatus(POLICY_SUCCESS),
        m_dwPolicyErrCode(ERROR_SUCCESS)
    /*++
        Constructor
    ++*/
    {
        #ifdef DBG
        memset(m_szCompanyName, 0, sizeof(m_szCompanyName));
        memset(m_szProductId, 0, sizeof(m_szProductId));
        memset(m_szCHProductId, 0, sizeof(m_szCHProductId));
        #endif
    }

    //--------------------------------------------------------------
        
    ~CTLSPolicy()
    /*++
        Destructor
    ++*/
    {
        Unload();
    }

    //--------------------------------------------------------------

    DWORD
    GetProductFlags()
    {
        return m_dwFlags;
    }

    //--------------------------------------------------------------

    long
    GetRefCount()
    {
        return InterlockedExchange(&m_RefCount, m_RefCount);
    }

    //--------------------------------------------------------------

    void
    Unload();

    //--------------------------------------------------------------
    DWORD
    Initialize(
        HINSTANCE hInstance,
        LPCTSTR pszCompanyName, 
        LPCTSTR pszCHProductId,
        LPCTSTR pszProductId,
        LPCTSTR pszDllName,
        DWORD dwDllFlag = POLICY_DENY_ALL_REQUEST
    );

    //--------------------------------------------------------------
    LPCTSTR
    GetCompanyName() 
    { 
        return m_szCompanyName; 
    }

    //--------------------------------------------------------------

    LPCTSTR
    GetProductId() 
    { 
        return m_szProductId; 
    }

    //--------------------------------------------------------------
    LPCTSTR
    GetCHProductId()
    {
        return m_szCHProductId;
    }
    
    //--------------------------------------------------------------

    DWORD
    GetPolicyRetCode() { return m_dwPolicyErrCode; }

    //--------------------------------------------------------------

    DWORD
    GetPolicyLastCallStatus() { return m_dwLastCallStatus; }

    //--------------------------------------------------------------

    BOOL
    IsValid();

    //--------------------------------------------------------------

    DWORD
    PMReturnLicense(
	    PMHANDLE hClient,
	    ULARGE_INTEGER* pLicenseSerialNumber,
	    PPMLICENSETOBERETURN pLicenseTobeReturn,
	    PDWORD pdwLicenseStatus
    );

    //--------------------------------------------------------------

    DWORD
    PMLicenseUpgrade(
	    PMHANDLE hClient,
	    DWORD dwProgressCode,
	    PVOID pbProgressData,
	    PVOID* ppbReturnData
    );

    //--------------------------------------------------------------

    DWORD
    PMLicenseRequest(
        PMHANDLE client,
        DWORD dwProgressCode, 
        const PVOID pbProgressData, 
        PVOID* pbNewProgressData
    );

    //--------------------------------------------------------------
    
    DWORD
    PMRegisterLicensePack(
        PMHANDLE hClient,
        DWORD dwProgressCode,
        const PVOID pbProgessData,
        PVOID pbProgressRetData
    );

    //--------------------------------------------------------------

    DWORD
    PMUnload();

    //--------------------------------------------------------------

    DWORD
    PMInitProduct();
};

/////////////////////////////////////////////////////////////////////

typedef struct __PolicyModule {
    
    TCHAR   m_szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR   m_szProductId[LSERVER_MAX_STRING_SIZE+1];

    friend bool operator<(const __PolicyModule&, const __PolicyModule&);

    __PolicyModule() 
    {
        memset(m_szCompanyName, 0, sizeof(m_szCompanyName));
        memset(m_szProductId, 0, sizeof(m_szProductId));
    }

} PolicyModule;


inline bool
operator<( 
    const PolicyModule& a, 
    const PolicyModule& b 
    )
/*++

++*/
{
    int iComp;

    iComp = _tcsicmp(a.m_szCompanyName, b.m_szCompanyName);
    if(iComp == 0)
    {
        iComp = _tcsicmp(a.m_szProductId, b.m_szProductId);
    }

    return iComp < 0;
}

//////////////////////////////////////////////////////////
//
// CTLSPolicyMgr must be a global object so destructor is 
// invoked at the end.
//
class CTLSPolicyMgr {

private:
    typedef map<PolicyModule, HMODULE, less<PolicyModule> > PMLoadedModuleMapType;
    typedef map<PolicyModule, CTLSPolicy*, less<PolicyModule> > PMProductPolicyMapType;
    typedef map<PolicyModule, PolicyModule, less<PolicyModule> > PMProductTransationMapType;

    //
    // Policy module per product
    //
    CRWLock     m_ProductPolicyModuleRWLock;
    PMProductPolicyMapType   m_ProductPolicyModule;

    //
    // List of loaded policy module
    //
    CRWLock     m_LoadedPolicyRWLock;
    PMLoadedModuleMapType m_LoadedPolicy; 

    //
    // List of Product transation
    //
    CRWLock     m_ProductTranslationRWLock;
    PMProductTransationMapType  m_ProductTranslation;


    HMODULE 
    LoadPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductCode,
        LPCTSTR pszDllName
    );
        
    //
    // Find policy module handle for a particular product
    //
    PMProductPolicyMapType::iterator 
    FindProductPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId
    );

    //
    // Find policy module handle for a particular product
    //
    PMProductTransationMapType::iterator
    FindProductTransation(
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductCode
    );
    
    void
    InsertProductTransation(
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductCode,
        LPCTSTR pszTLSProductCode
    );

    DWORD
    GetSupportedProduct(
        HMODULE hModule,
        LPCTSTR pszDllName,
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId,
        PDWORD pdwNumProducts,
        PPMSUPPORTEDPRODUCT* pSupportedProduct
    );

    DWORD
    InsertProductPolicyModule(
        HMODULE hModule,
        BOOL bReplace,
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductId,
        LPCTSTR pszTLSProductId,
        LPCTSTR pszDllName,
        DWORD dwFlag
    );

    DWORD
    UnloadPolicyModule(
        HINSTANCE hModule
    );
        
   
public:
    CTLSPolicyMgr();

    ~CTLSPolicyMgr();

    // 
    // Insert a policy module handle into Handle arrays.
    //
    DWORD
    AddPolicyModule( 
        BOOL bReplace,
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId,
        LPCTSTR pszDllName,
        DWORD dwFlag
    );

    DWORD
    UnloadPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductCode
    );

    //
    // Find a policy module for specific product
    //
    CTLSPolicy*
    AcquireProductPolicyModule(
        LPCTSTR pszCompanyName,
        LPCTSTR pszProductId
    );

    //
    // Find a translation for CH.
    //
    BOOL
    TranslateCHCodeToTlsCode(
        LPCTSTR pszCompanyName,
        LPCTSTR pszCHProductCode,
        LPTSTR pszTlsProductCode,
        PDWORD pdwBufferSize
    );

    //
    // Release a product policy module
    //
    void
    ReleaseProductPolicyModule( CTLSPolicy* p );

    //
    // Initialize All Product Policy Module
    //
    DWORD
    InitProductPolicyModule();
};

#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    ServiceInitPolicyModule(void);

    DWORD
    ServiceLoadAllPolicyModule(
        IN HKEY hRoot,
        IN LPCTSTR pszSubkey
    );

    CTLSPolicy*
    AcquirePolicyModule(
        IN LPCTSTR pszCompanyName,
        IN LPCTSTR pszProductId,
        IN BOOL bUseProductPolicy
    );

    BOOL
    TranslateCHCodeToTlsCode(
        IN LPCTSTR pszCompanyName,
        IN LPCTSTR pszCHProductId,
        IN LPTSTR pszTLSProductId,
        IN OUT PDWORD pdwBufferSize
    );

    void
    ReleasePolicyModule(
        CTLSPolicy* ptr
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\postjob.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        postjob.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __POSTSJOB_H__
#define __POSTSJOB_H__
#include "server.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL
TLSCanForwardRequest(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
);

BOOL
IsLicensePackRepl(
    TLSLICENSEPACK* pLicensePack
);

BOOL
TLSIsServerCompatible(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
);

BOOL
TLSCanPushReplicateData(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
);

DWORD
PostSsyncLkpJob(
    PSSYNCLICENSEPACK syncLkp
);

DWORD
TLSAnnounceLKPToAllRemoteServer(
    IN DWORD dwKeyPackId,
    IN DWORD dwDelayTime
);

DWORD
TLSPushSyncLocalLkpToServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszLserverName,
    IN FILETIME* pSyncTime
);

DWORD
TLSStartAnnounceResponseJob(
    IN LPTSTR pszTargetServerId,
    IN LPTSTR pszTargetServerDomain,
    IN LPTSTR pszTargetServerName,
    IN FILETIME* pftTime
);

DWORD
TLSStartAnnounceToEServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
);

DWORD
TLSStartAnnounceLicenseServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
);

DWORD
TLSPostReturnClientLicenseJob(
    PLICENSEDPRODUCT pLicProduct
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\postsrv.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        postsrv.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __POSTSERVICE_H__
#define __POSTSERVICE_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD
PostServiceInit();


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\postsrv.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       postsrv.cpp
//
// Contents:   Post service initialize routine 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "postsrv.h"
#include "tlsjob.h"
#include "globals.h"
#include "init.h"


extern BOOL g_bReportToSCM;

DWORD
PostServiceInit()
{
    DWORD dwStatus = ERROR_SUCCESS;
    FILETIME ftTime;
    HRESULT hrStatus = NULL;


    //
    // Initialize work manager
    //
    dwStatus = TLSWorkManagerInit();


	hrStatus =  g_pWriter->Initialize (idWriter,		// id of writer
					L"TermServLicensing",	// name of writer
					true,		// system service
					false,		// bootable state
					L"",	// files to include
					L"");	// files to exclude

	if (FAILED (hrStatus))
	{
		
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CVssJetWriter::Initialize failed with error code %08x...\n"), 
                hrStatus
            );
	}


    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_STARTUP,
                dwStatus
            );

        dwStatus = TLS_E_SERVICE_STARTUP_WORKMANAGER;
        return dwStatus;
    }

    //
    // Initialize namedpipe for client to test connect
    //
    dwStatus = InitNamedPipeThread();
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
        dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        return dwStatus;
    }

    //
    // Initialize mailslot thread to receive broadcast
    //
    dwStatus = InitMailSlotThread();
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
        dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        return dwStatus;
    }

    //
    // Initialize thread to put expired permanent licenses back in pool
    //
    dwStatus = InitExpirePermanentThread();
    if(dwStatus != ERROR_SUCCESS)
    {
        TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
        dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
        return dwStatus;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_INIT,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Server is %s (0x%08x)\n"),
            (IS_ENFORCE_SERVER(TLS_CURRENT_VERSION)) ? _TEXT("Enforce") : _TEXT("Non-Enforce"),
            IS_ENFORCE_SERVER(TLS_CURRENT_VERSION)
        );
      
    // must be running as service and not in debug mode      
    if(g_bReportToSCM == TRUE)
    {
        if(!(GetLicenseServerRole() & TLSERVER_ENTERPRISE_SERVER))
        {
            GetServiceLastShutdownTime(&ftTime);
            dwStatus = TLSStartAnnounceLicenseServerJob(
                                                g_pszServerPid,
                                                g_szScope,
                                                g_szComputerName,
                                                &ftTime
                                            );
            if(dwStatus != ERROR_SUCCESS)
            {
                return dwStatus;
            }
        }

        GetServiceLastShutdownTime(&ftTime);
        dwStatus = TLSStartAnnounceToEServerJob(
                                            g_pszServerPid,
                                            g_szScope,
                                            g_szComputerName,
                                            &ftTime
                                        );
    }

    ServiceInitPolicyModule();
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\remotedb.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:            remotedb.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __REMOTEDB_H__
#define __REMOTEDB_H__
#include "server.h"



#ifdef __cplusplus
extern "C" {
#endif

DWORD
TLSDBRemoteKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\remotedb.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        remotedb.cpp
//
// Contents:    
//              all routine deal with cross table query
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "remotedb.h"
#include "kp.h"
#include "lkpdesc.h"
#include "keypack.h"
#include "misc.h"

////////////////////////////////////////////////////////////////////////////
DWORD
TLSDBRemoteKeyPackAdd(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN OUT PTLSLICENSEPACK lpKeyPack
    )
/*++


--*/
{

    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    TLSLICENSEPACK found;

    if(pDbWkSpace == NULL || lpKeyPack == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        return dwStatus;
    }

    //
    // Lock table for update
    //
    TLSDBLockKeyPackTable();


    //
    // Quick fix so that find keypack will work.

    lpKeyPack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
    //lpKeyPack->ucAgreementType |= (LSKEYPACK_REMOTE_TYPE | LSKEYPACK_HIDDEN_TYPE);
    lpKeyPack->ucKeyPackStatus |= (LSKEYPACKSTATUS_REMOTE | LSKEYPACKSTATUS_HIDDEN);


    LicPackTable& licpackTable = pDbWkSpace->m_LicPackTable;

    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LICENSEDPACK_FIND_PRODUCT,
                                lpKeyPack   
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    while(TRUE)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    &found
                                );

        if(dwStatus == TLS_I_NO_MORE_DATA)
        {
            break;
        }

        if(_tcsicmp(found.szInstallId, lpKeyPack->szInstallId) == 0)
        {
            // find product is based on company name, 
            // keypack id, product id, platform type, so
            // this is duplicate
            //
            dwStatus = TLS_E_DUPLICATE_RECORD;

            if( lpKeyPack->dwNumberOfLicenses == 0 ||
                (lpKeyPack->ucKeyPackStatus & ~LSKEYPACK_RESERVED_TYPE) == LSKEYPACKSTATUS_REVOKED )
            { 
                //  
                // Try to be as fast as possible
                //
                licpackTable.DeleteRecord();
            }
            else
            {
                licpackTable.UpdateRecord(*lpKeyPack);
            }
            break;
        }
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);

    if(dwStatus == TLS_I_NO_MORE_DATA && lpKeyPack->dwNumberOfLicenses > 0)
    {
        lpKeyPack->dwKeyPackId = TLSDBGetNextKeyPackId();
        bSuccess = licpackTable.InsertRecord(*lpKeyPack);

        if(bSuccess == FALSE)
        {
            if(licpackTable.GetLastJetError() == JET_errKeyDuplicate)
            {
                TLSASSERT(FALSE);   // this should no happen
                SetLastError(dwStatus=TLS_E_DUPLICATE_RECORD);
            }
            else
            {
                LPTSTR pString = NULL;
    
                TLSGetESEError(licpackTable.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_BASE,
                        licpackTable.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }

                SetLastError(dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError()));
                TLSASSERT(FALSE);
            }
        }
        else
        {
            dwStatus = ERROR_SUCCESS;
        }
    }


cleanup:

    TLSDBUnlockKeyPackTable();
    SetLastError(dwStatus);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\resource.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#ifndef __RESOURCE_H__

#define IDS_TEMPORARY_KEYPACKID         101
#define IDS_TEMPORARY_PRODUCTNAME       102
#define IDS_TEMPORARY_PRODUCTDESC       103
#define IDS_TEMPORARY_BSERIALNUMBER     104
#define IDS_UNKNOWN_STRING              105
#define IDS_DEFAULT_SCOPE               106


#define IDS_VU_COMPANYNAME              107
#define IDS_VU_PRODUCTNAME              108
#define IDS_VU_PRODUCTDESC              109
#define IDS_VU_PRODUCTID                110
#define IDS_S_PRODUCTDESC               111
#define IDS_EX_PRODUCTDESC              112

#define IDS_HS_COMPANYNAME              113
#define IDS_HS_PRODUCTNAME              114 
#define IDS_HS_PRODUCTDESC              115

#define IDS_HS_MACHINENAME              116
#define IDS_HS_USERNAME                 117

#define IDS_SCOPE_ENTERPRISE            118
#define IDS_UNKNOWN_PRODUCTDESC         119
#define IDS_DEFAULT_POLICY              120

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\postjob.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       postjob.cpp 
//
// Contents:   Post various job to job manager 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "postjob.h"
#include "tlsjob.h"
#include "globals.h"

////////////////////////////////////////////////////////////////
BOOL
IsLicensePackRepl(
    IN TLSLICENSEPACK* pLicensePack
    )
/*++

Abstract:

    Determine if license pack is replicable.

Parameter:

    pLicensePack - License Pack.

Returns:

    TRUE if license pack can be replicated to other serve
    FALSE otherwise.

Remark:

    Do not replicate FREE or special license pack.

--*/
{
    BOOL bYes = TRUE;

    if( 
        (pLicensePack->ucAgreementType == LSKEYPACKTYPE_FREE) || 
        (pLicensePack->ucAgreementType & (LSKEYPACK_REMOTE_TYPE | LSKEYPACK_HIDDEN_TYPE | LSKEYPACK_LOCAL_TYPE)) ||
        (pLicensePack->ucKeyPackStatus & (LSKEYPACKSTATUS_HIDDEN | LSKEYPACKSTATUS_REMOTE | LSKEYPACKSTATUS_LOCAL))
      )
    {
        bYes = FALSE;
    }

    if( bYes == TRUE )
    {
        UCHAR ucKeyPackStatus = (pLicensePack->ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED);

        // don't replicate temp. license pack.
        if( ucKeyPackStatus == LSKEYPACKSTATUS_TEMPORARY )
        {
            bYes = FALSE;
        }
    }

    return bYes;
}


////////////////////////////////////////////////////////////////
BOOL
TLSCanForwardRequest(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
    )
/*++

Abstract:

    Determine if version of server is compatible.

Parameter:

    dwLocalServerVersion : Local server version.
    dwTargetServerVersion : Targer server version.

Returns:

    TRUE/FALSE.

Remark:

    Rules

    1) No forward to server version older than 5.1.
    2) Enforce to enforce, non-enforce to non-enforce only.
    3) Enterprise to enterprise only.
    4) domain/workgroup server to enterprise no enterprise
       to domain/workgroup.

--*/
{
    BOOL bCanForward;
    BOOL bLocalEnforce;
    BOOL bRemoteEnforce;

    bCanForward = TLSIsServerCompatible(
                                    dwLocalServerVersion,
                                    dwTargetServerVersion
                                );

    //bLocalEnforce = IS_ENFORCE_SERVER(dwLocalServerVersion);
    //bRemoteEnforce = IS_ENFORCE_SERVER(dwTargetServerVersion);

    //
    // No enforce to non-enforce replication
    //
    //if( bLocalEnforce != bRemoteEnforce )
    //{
    //    bCanForward = FALSE;
    //}

    if(bCanForward == TRUE)
    {
        BOOL bEnterpriseLocal = IS_ENTERPRISE_SERVER(dwLocalServerVersion);
        BOOL bEnterpriseRemote = IS_ENTERPRISE_SERVER(dwTargetServerVersion);

        if( g_SrvRole & TLSERVER_ENTERPRISE_SERVER )
        {
            bEnterpriseLocal = TRUE;
        }

        if(bEnterpriseLocal == TRUE && bEnterpriseRemote == FALSE)
        {
            bCanForward = FALSE;
        }
    }

    return bCanForward;
}

////////////////////////////////////////////////////////////////

BOOL
TLSIsServerCompatible(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
    )
/*++

Abstract:

    Determine if two server is compatible.

Parameters:

    dwLocalServerVersion : Local server version.
    dwTargetServerVersion : Target server version.

Return:

    TRUE/FALSE.

Remark:

    1) No server older than 5.1
    2) Enforce to enforce and non-enforce to non-enforce only

--*/
{
    DWORD dwTargetMajor = GET_SERVER_MAJOR_VERSION(dwTargetServerVersion);
    DWORD dwTargetMinor = GET_SERVER_MINOR_VERSION(dwTargetServerVersion);

    //
    // This version of License Server is not compatible with anyother
    if(dwTargetMajor == 5 && dwTargetMinor == 0)
    {
        return FALSE;
    }

    return (IS_ENFORCE_SERVER(dwLocalServerVersion) == IS_ENFORCE_SERVER(dwTargetServerVersion));
}

////////////////////////////////////////////////////////////////

BOOL
TLSCanPushReplicateData(
    IN DWORD dwLocalServerVersion,
    IN DWORD dwTargetServerVersion
    )
/*++

Abstract:

    Determine if local server can 'push' replicate
    data to remote server.

Parameters:

    dwLocalServerVersion : Local server version.
    dwTargetServerVersion : Target server version.

Returns:

    TRUE/FALSE.

Remark:
    
    1) See TLSIsServerCompatible().
    2) only one-way from enterprise to 
       domain/workgroup server.

--*/
{
    BOOL bCanReplicate;
    BOOL bLocalEnforce;
    BOOL bRemoteEnforce;

    bCanReplicate = TLSIsServerCompatible(
                                    dwLocalServerVersion,
                                    dwTargetServerVersion
                                );

    bLocalEnforce = IS_ENFORCE_SERVER(dwLocalServerVersion);
    bRemoteEnforce = IS_ENFORCE_SERVER(dwTargetServerVersion);
    //
    // No enforce to non-enforce replication
    //
    if( bLocalEnforce != bRemoteEnforce )
    {
        bCanReplicate = FALSE;
    }

    if(bCanReplicate == TRUE)
    {
        BOOL bEnterpriseLocal = IS_ENTERPRISE_SERVER(dwLocalServerVersion);
        BOOL bEnterpriseRemote = IS_ENTERPRISE_SERVER(dwTargetServerVersion);

        if( g_SrvRole & TLSERVER_ENTERPRISE_SERVER )
        {
            bEnterpriseLocal = TRUE;
        }

        if(bEnterpriseLocal == FALSE && bEnterpriseRemote == TRUE)
        {
            bCanReplicate = FALSE;
        }
    }

    return bCanReplicate;
}

        
////////////////////////////////////////////////////////////////

DWORD
PostSsyncLkpJob(
    IN PSSYNCLICENSEPACK syncLkp
    )
/*++

Abstract:

    Wrapper to post a sync. license pack job to work manager.

Parameter:

    syncLkp : License pack and other info to be sync.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    CSsyncLicensePack* pSyncLicensePack;

    try {
        pSyncLicensePack = new CSsyncLicensePack(
                                            TRUE,
                                            syncLkp,
                                            sizeof(SSYNCLICENSEPACK)
                                        );

        //
        // Set work default interval/retry times
        //
        TLSWorkManagerSetJobDefaults(pSyncLicensePack);
        dwStatus = TLSWorkManagerSchedule(0, pSyncLicensePack);

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_SCHEDULEJOB,
                dwStatus
            );

            delete pSyncLicensePack;
        }
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_CREATEJOB,
                dwStatus
            );
    }
    catch( ... )
    {
        dwStatus = TLS_E_INTERNAL;
        TLSLogErrorEvent(TLS_E_INTERNAL);
    }

    return dwStatus;
}

//--------------------------------------------------------------------

DWORD
TLSAnnounceLKPToAllRemoteServer(
    IN DWORD dwKeyPackId,
    IN DWORD dwDelayTime
    )
/*++

Abstract:

    Announce a license pack by its internal ID to all 
    known server.

Parameter:

    dwKeyPackId : License keypack's internal tracking Id.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    PTLServerInfo pServerInfo = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwCount;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Announce %d LKP to servers...\n"),
            dwKeyPackId
        );

    SSYNCLICENSEPACK SsyncLkp;
    memset(
            &SsyncLkp,
            0, 
            sizeof(SSYNCLICENSEPACK)
        );

    SsyncLkp.dwStructVersion = CURRENT_SSYNCLICENSEKEYPACK_STRUCT_VER;
    SsyncLkp.dwStructSize = sizeof(SSYNCLICENSEPACK);

    SsyncLkp.dwSyncType = SSYNC_ONE_LKP;
    SsyncLkp.dwKeyPackId = dwKeyPackId;
    SsyncLkp.dwNumServer = 0;

    SAFESTRCPY(SsyncLkp.m_szServerId, g_pszServerPid);
    SAFESTRCPY(SsyncLkp.m_szServerName, g_szComputerName);

    //
    // Lock known server list
    //
    TLSBeginEnumKnownServerList();

    while((pServerInfo = TLSGetNextKnownServer()) != NULL)
    {
        if(TLSCanPushReplicateData(
                            TLS_CURRENT_VERSION,
                            pServerInfo->GetServerVersion()
                        ) == FALSE)
        {
            continue;
        }

        if(pServerInfo->IsServerSupportReplication() == FALSE)
        {
            continue;
        }

        if(SsyncLkp.dwNumServer >= SSYNCLKP_MAX_TARGET)
        {
            dwStatus = PostSsyncLkpJob(&SsyncLkp);

            if(dwStatus != ERROR_SUCCESS)
            {
                break;
            }

            SsyncLkp.dwNumServer = 0;
        }

        SAFESTRCPY(
                SsyncLkp.m_szTargetServer[SsyncLkp.dwNumServer],
                pServerInfo->GetServerName()
            );
        
        SsyncLkp.dwNumServer++;
    }

    TLSEndEnumKnownServerList();

    if(dwStatus == ERROR_SUCCESS && SsyncLkp.dwNumServer != 0)
    {
        dwStatus = PostSsyncLkpJob(&SsyncLkp);
    }

    return dwStatus;
}    


/////////////////////////////////////////////////////////////////////////

DWORD
TLSPushSyncLocalLkpToServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszLserverName,
    IN FILETIME* pSyncTime
    )
/*++

Abstract:

    'Push' sync registered license pack to other server.

Parameters:

    pszSetupId : Remote server's setup ID.
    pszDomainName : Remote server's domain name.
    pszLserverName : Remote server name.
    pSyncTime : Pointer to FILETIME, sync. all license pack with the time stamp 
                greater or equal to this time will be 'push' sync.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLServerInfo ServerInfo;
    SSYNCLICENSEPACK SsyncLkp;

    //
    // resolve ServerId to server name
    // 
    dwStatus = TLSLookupRegisteredServer(
                                    pszSetupId,
                                    pszDomainName,
                                    pszLserverName,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Make sure local server can push replicate
    // data to remote server.
    //
    if(TLSCanPushReplicateData(
                        TLS_CURRENT_VERSION,
                        ServerInfo.GetServerVersion()
                    ) == FALSE)
    {
        goto cleanup;
    }

    //
    // Form a sync work object and post it to work manager.
    //        
    memset(
            &SsyncLkp,
            0, 
            sizeof(SSYNCLICENSEPACK)
        );

    SsyncLkp.dwStructVersion = CURRENT_SSYNCLICENSEKEYPACK_STRUCT_VER;
    SsyncLkp.dwStructSize = sizeof(SSYNCLICENSEPACK);
    SAFESTRCPY(SsyncLkp.m_szServerId, g_pszServerPid);
    SAFESTRCPY(SsyncLkp.m_szServerName, g_szComputerName);

    SsyncLkp.dwSyncType = SSYNC_ALL_LKP;
    SsyncLkp.dwNumServer = 1;
    SAFESTRCPY(
            SsyncLkp.m_szTargetServer[0],
            ServerInfo.GetServerName()
        );

    SsyncLkp.m_ftStartSyncTime = *pSyncTime;

    dwStatus = PostSsyncLkpJob(&SsyncLkp);

cleanup:
    return dwStatus;
}    

////////////////////////////////////////////////////////////////
DWORD
TLSStartAnnounceResponseJob(
    IN LPTSTR pszTargetServerId,
    IN LPTSTR pszTargetServerDomain,
    IN LPTSTR pszTargetServerName,
    IN FILETIME* pftTime
    )
/*++

Abstract:

    Create a License Server Announcement response work object and post it
    to work manager.

Parameter:

    pszTargetServerId : Target server Id.
    pszTargetServerDomain : Target server's domain.
    pszTargetServerName : Target server name.
    pftTime : Pointer to FILE, local server's last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    ANNOUNCERESPONSEWO response;
    TLServerInfo ServerInfo;
    CAnnounceResponse* pAnnounceResponse = NULL;


    //
    // Perform lookup on server to determine its eligibility 
    //
    dwStatus = TLSLookupRegisteredServer(
                                    pszTargetServerId,
                                    pszTargetServerDomain,
                                    pszTargetServerName,
                                    &ServerInfo
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        // can't find server, no response
        goto cleanup;
    }

    memset(&response, 0, sizeof(response));
    response.dwStructVersion = CURRENT_ANNOUNCERESPONSEWO_STRUCT_VER;
    response.dwStructSize = sizeof(response);
    response.bCompleted = FALSE;
    SAFESTRCPY(response.m_szTargetServerId, pszTargetServerId);
    SAFESTRCPY(response.m_szLocalServerId, g_pszServerPid);
    SAFESTRCPY(response.m_szLocalServerName, g_szComputerName);
    SAFESTRCPY(response.m_szLocalScope, g_szScope);
    response.m_ftLastShutdownTime = *pftTime;

    try {
        pAnnounceResponse = new CAnnounceResponse(
                                            TRUE, 
                                            &response, 
                                            sizeof(response)
                                        );

        //
        // Set work default interval/retry times
        //
        TLSWorkManagerSetJobDefaults(pAnnounceResponse);
        dwStatus = TLSWorkManagerSchedule(0, pAnnounceResponse);

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_WORKMANAGERGENERAL,
                    TLS_E_WORKMANAGER_SCHEDULEJOB,
                    dwStatus
                );

            delete pAnnounceResponse;
        }
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_CREATEJOB,
                dwStatus
            );
    }
    catch( ... )
    {
        dwStatus = TLS_E_INTERNAL;
        TLSLogErrorEvent(TLS_E_INTERNAL);
    }

cleanup:
    return dwStatus;
}
    

/////////////////////////////////////////////////////////////////////

DWORD
TLSStartAnnounceToEServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
    )
/*++

Abstract:

    Create a Enterprise server discovery job and post it to work 
    manager.

Parameters:
    
    pszServerId : Local server's ID.
    pszServerDomain : Local server's domain.
    pszServerName : Local server name.
    pftFileTime : Pointer to FILETIME, local server's last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    ANNOUNCETOESERVERWO AnnounceToES;

    memset(&AnnounceToES, 0, sizeof(AnnounceToES));

    AnnounceToES.dwStructVersion = CURRENT_ANNOUNCETOESERVEWO_STRUCT_VER;
    AnnounceToES.dwStructSize = sizeof(ANNOUNCETOESERVERWO);
    AnnounceToES.bCompleted = FALSE;

    SAFESTRCPY(AnnounceToES.m_szServerId, pszServerId);
    SAFESTRCPY(AnnounceToES.m_szServerName, pszServerName);
    SAFESTRCPY(AnnounceToES.m_szScope, pszServerDomain);
    AnnounceToES.m_ftLastShutdownTime = *pftFileTime;

    CAnnounceToEServer* pAnnounceESWO = NULL;

    try {
        pAnnounceESWO = new CAnnounceToEServer(
                                            TRUE, 
                                            &AnnounceToES, 
                                            sizeof(ANNOUNCETOESERVERWO)
                                        );

        //
        // Set work default interval/retry times
        //
        TLSWorkManagerSetJobDefaults(pAnnounceESWO);
        dwStatus = TLSWorkManagerSchedule(0, pAnnounceESWO);

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_SCHEDULEJOB,
                dwStatus
            );

            delete pAnnounceESWO;
        }
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_CREATEJOB,
                dwStatus
            );
    }
    catch( ... )
    {
        dwStatus = TLS_E_INTERNAL;
        TLSLogErrorEvent(TLS_E_INTERNAL);
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////

DWORD
TLSStartAnnounceLicenseServerJob(
    IN LPCTSTR pszServerId,
    IN LPCTSTR pszServerDomain,
    IN LPCTSTR pszServerName,
    IN FILETIME* pftFileTime
    )
/*++

Abstract:

    Create a license server announcement job and post it to work
    manager.

Parameters:

    pszServerId : Local server's ID.
    pszServerDomain : Local server domain.
    pszServerName : Local server name.
    pftFileTime : Pointer to FILETIME, local server's last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a CAnnounce Server work.
    //
    ANNOUNCESERVERWO AnnounceLs;

    memset(&AnnounceLs, 0, sizeof(AnnounceLs));

    AnnounceLs.dwStructVersion = CURRENT_ANNOUNCETOESERVEWO_STRUCT_VER;
    AnnounceLs.dwStructSize = sizeof(ANNOUNCETOESERVERWO);
    AnnounceLs.dwRetryTimes = 0;

    SAFESTRCPY(AnnounceLs.m_szServerId, pszServerId);
    SAFESTRCPY(AnnounceLs.m_szServerName, pszServerName);
    SAFESTRCPY(AnnounceLs.m_szScope, pszServerDomain);
    AnnounceLs.m_ftLastShutdownTime = *pftFileTime;

    CAnnounceLserver* pAnnounceWO = NULL;

    try {
        pAnnounceWO = new CAnnounceLserver(
                                        TRUE, 
                                        &AnnounceLs, 
                                        sizeof(ANNOUNCETOESERVERWO)
                                    );

        //
        // Set work default interval/retry times
        //
        
        // Don't take other parameter for Announce Server
        // TLSWorkManagerSetJobDefaults(pAnnounceWO);

        dwStatus = TLSWorkManagerSchedule(0, pAnnounceWO);

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_SCHEDULEJOB,
                dwStatus
            );

            delete pAnnounceWO;
        }
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_CREATEJOB,
                dwStatus
            );
    }
    catch( ... )
    {
        dwStatus = TLS_E_INTERNAL;
        TLSLogErrorEvent(TLS_E_INTERNAL);
    }

    return dwStatus;
}

////////////////////////////////////////////////////////////////
DWORD
TLSPostReturnClientLicenseJob(
    IN PLICENSEDPRODUCT pLicProduct
    )
/*++

Abstract:

    Create a return license work object and post it to work manager.

Parameters:

    pLicProduct : Licensed product to be return/revoke...

Returns:

    ERROR_SUCCESS or error success.

Remark:

    Return license is a persistent job.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    RETURNLICENSEWO retlic;
    CReturnLicense* pReturnLicenseWO = NULL;


    //---------------------------------------------------------------

    if( pLicProduct == NULL || pLicProduct->pLicensedVersion == NULL ||
        pLicProduct->LicensedProduct.cbEncryptedHwid >= sizeof(retlic.pbEncryptedHwid) )
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    memset(&retlic, 0, sizeof(retlic));

    retlic.dwStructVersion = CURRENT_RETURNLICENSEWO_STRUCT_VER;
    retlic.dwStructSize = sizeof(retlic);

    retlic.dwNumRetry = 0;
    SAFESTRCPY(retlic.szTargetServerId, pLicProduct->szIssuerId);
    SAFESTRCPY(retlic.szTargetServerName, pLicProduct->szIssuer);

    retlic.dwQuantity = pLicProduct->dwQuantity;
    retlic.dwKeyPackId = pLicProduct->ulSerialNumber.HighPart;
    retlic.dwLicenseId = pLicProduct->ulSerialNumber.LowPart;
    retlic.dwReturnReason = LICENSERETURN_UPGRADE;
    retlic.dwPlatformId = pLicProduct->LicensedProduct.dwPlatformID;

    retlic.cbEncryptedHwid = pLicProduct->LicensedProduct.cbEncryptedHwid;
    memcpy(
            retlic.pbEncryptedHwid,
            pLicProduct->LicensedProduct.pbEncryptedHwid,
            pLicProduct->LicensedProduct.cbEncryptedHwid
        );

    retlic.dwProductVersion = MAKELONG( 
                                    pLicProduct->pLicensedVersion->wMinorVersion, 
                                    pLicProduct->pLicensedVersion->wMajorVersion
                                );

    memcpy(
            retlic.szOrgProductID,
            pLicProduct->pbOrgProductID,
            min(sizeof(retlic.szOrgProductID) - sizeof(TCHAR), pLicProduct->cbOrgProductID)
        );

    memcpy(
            retlic.szCompanyName,
            pLicProduct->LicensedProduct.pProductInfo->pbCompanyName,
            min(sizeof(retlic.szCompanyName)-sizeof(TCHAR), pLicProduct->LicensedProduct.pProductInfo->cbCompanyName)
        );

    memcpy(
            retlic.szProductId,
            pLicProduct->LicensedProduct.pProductInfo->pbProductID,
            min(sizeof(retlic.szProductId)-sizeof(TCHAR), pLicProduct->LicensedProduct.pProductInfo->cbProductID)
        );

    lstrcpy(
            retlic.szUserName,
            pLicProduct->szLicensedUser
        );

    lstrcpy(
            retlic.szMachineName,
            pLicProduct->szLicensedClient
        );

    try {

        pReturnLicenseWO = new CReturnLicense(
                                            TRUE,
                                            &retlic,
                                            sizeof(retlic)
                                        );

        //
        // Set work default interval/retry times
        //
        
        // Don't take other parameter for Announce Server
        // TLSWorkManagerSetJobDefaults(pAnnounceWO);

        dwStatus = TLSWorkManagerSchedule(0, pReturnLicenseWO);

        if(dwStatus != ERROR_SUCCESS)
        {
            TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKMANAGER_SCHEDULEJOB,
                dwStatus
            );
        }

        //
        // Work storage will make a copy of this job so we need
        // to delete it.
        //
        delete pReturnLicenseWO;
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_CREATEJOB,
                dwStatus
            );
    }
    catch( ... )
    {
        dwStatus = TLS_E_INTERNAL;
        TLSLogErrorEvent(TLS_E_INTERNAL);
    }

cleanup:

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\server.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        server.h
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//              07-27-98    HueiWang    Port to JetBlue
//
//---------------------------------------------------------------------------
#ifndef __SERVER_H_
#define __SERVER_H_
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>

#include "license.h"

//
// TLSDb
//
#include "JBDef.h"
#include "JetBlue.h"
#include "TLSDb.h"

#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"

//
// Current RPC interface
//
#include "tlsrpc.h"
#include "tlsdef.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "tlspol.h"

//
//
#include "messages.h"

#include "tlsassrt.h"
#include "trust.h"
#include "svcrole.h"
#include "common.h"
#include "lscommon.h"

#include "Cryptkey.h"
#include "licekpak.h"

#include "clrhouse.h"
#include "dblevel.h"
#include "SrvDef.h"
#include "policy.h"
#include "wkspace.h"
#include "tlsjob.h"
#include "srvlist.h"
#include "debug.h"


#if DBG
typedef enum {
    RPC_CALL_CONNECT,
    RPC_CALL_SEND_CERTIFICATE,
    RPC_CALL_GET_SERVERNAME,
    RPC_CALL_GET_SERVERSCOPE,
    RPC_CALL_GETINFO,
    RPC_CALL_GET_LASTERROR,
    RPC_CALL_ISSUEPLATFORMCHLLENGE,
    RPC_CALL_ALLOCATECONCURRENT,
    RPC_CALL_ISSUENEWLICENSE,
    RPC_CALL_UPGRADELICENSE,
    RPC_CALL_KEYPACKENUMBEGIN,
    RPC_CALL_KEYPACKENUMNEXT,
    RPC_CALL_KEYPACKENUMEND,
    RPC_CALL_KEYPACKADD,
    RPC_CALL_KEYPACKSETSTATUS,
    RPC_CALL_LICENSEENUMBEGIN,
    RPC_CALL_LICENSEENUMNEXT,
    RPC_CALL_LICENSEENUMEND,
    RPC_CALL_LICENSESETSTATUS,
    RPC_CALL_INSTALL_SERV_CERT,
    RPC_CALL_GETSERV_CERT,
    RPC_CALL_REGISTER_LICENSE_PACK,
    RPC_CALL_REQUEST_TERMSRV_CERT,
    RPC_CALL_RETRIEVE_TERMSRV_CERT,
    RPC_CALL_GETPKCS10CERT_REQUEST,
    RPC_CALL_ANNOUNCE_SERVER,
    RPC_CALL_SERVERLOOKUP,
    RPC_CALL_ANNOUNCELICENSEPACK,
    RPC_CALL_RETURNLICENSE,
    RPC_CALL_RETURNKEYPACK,
    RPC_CALL_GETPRIVATEDATA,
    RPC_CALL_SETPRIVATEDATA,
    RPC_CALL_CHALLENGESERVER,
    RPC_CALL_RESPONSESERVERCHALLENGE,
    RPC_CALL_TRIGGERREGENKEY,
    RPC_CALL_TELEPHONEREGISTERLKP,
    RPC_CALL_ALLOCATEINTERNETLICNESEEX,
    RPC_CALL_RETURNINTERNETLICENSEEX,
    RPC_CALL_RETURNINTERNETLICENSE
} DBG_RPC_CALL;
#endif

//---------------------------------------------------------------------------
typedef enum {
    LSCERT_RDN_STRING_TYPE,
    LSCERT_RDN_NAME_INFO_TYPE,
    LSCERT_RDN_NAME_BLOB_TYPE,
    LSCERT_CLIENT_INFO_TYPE
} TLSCLIENTCERTRDNTYPE;

typedef struct __LSClientInfo {
    LPTSTR szUserName;
    LPTSTR szMachineName;
    PHWID  pClientID;
} TLSClientInfo, *PTLSClientInfo, *LPTLSClientInfo;

typedef struct __LSClientCertRDN {
    TLSCLIENTCERTRDNTYPE  type;

    union {
        LPTSTR szRdn;
        PCERT_NAME_INFO pCertNameInfo;
        TLSClientInfo ClientInfo;
        PCERT_NAME_BLOB pNameBlob;
    };
} TLSClientCertRDN, *PTLSClientCertRDN, *LPTLSClientCertRDN;



//---------------------------------------------------------------------------
typedef struct _DbLicensedProduct {
    DWORD dwQuantity;

    ULARGE_INTEGER ulSerialNumber;

    DWORD dwKeyPackId;
    DWORD dwLicenseId;
    DWORD dwKeyPackLicenseId;
    DWORD dwNumLicenseLeft;

    HWID  ClientHwid;

    FILETIME NotBefore;
    FILETIME NotAfter;

    BOOL bTemp; // temporary license


    // licensed product version
    DWORD dwProductVersion;

    // manufaturer name
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];

    // licensed product Id
    TCHAR szLicensedProductId[LSERVER_MAX_STRING_SIZE+1];

    // original license request product ID
    TCHAR szRequestProductId[LSERVER_MAX_STRING_SIZE+1];

    TCHAR szUserName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szMachineName[LSERVER_MAX_STRING_SIZE+1];

    //
    DWORD dwLanguageID;
    DWORD dwPlatformID;

    PBYTE pbPolicyData;
    DWORD cbPolicyData;

    PCERT_PUBLIC_KEY_INFO   pSubjectPublicKeyInfo;
} TLSDBLICENSEDPRODUCT, *PTLSDBLICENSEDPRODUCT, *LPTLSDBLICENSEDPRODUCT;


//---------------------------------------------------------------------------
typedef struct __TLSDbLicenseRequest {
    CTLSPolicy*         pPolicy;
    PMHANDLE            hClient;

    //
    // Product request
    //
    DWORD               dwProductVersion;

    LPTSTR              pszCompanyName;
    LPTSTR              pszProductId;

    DWORD               dwLanguageID;
    DWORD               dwPlatformID;

    //
    // Client information
    //
    HWID                hWid;
    PBYTE               pbEncryptedHwid;
    DWORD               cbEncryptedHwid;

    TCHAR               szMachineName[MAX_COMPUTERNAME_LENGTH + 2];
    TCHAR               szUserName[MAXUSERNAMELENGTH+1];

    //
    // detail of licensing chain
    WORD                wLicenseDetail;


    //
    // special things to be put into certificate
    //
    PCERT_PUBLIC_KEY_INFO pClientPublicKey;
    TLSClientCertRDN     clientCertRdn;

    DWORD               dwNumExtensions;
    PCERT_EXTENSION     pExtensions;

    //
    // Policy Extension Data
    //
    //PBYTE               pbPolicyExtensionData;
    //DWORD               cbPolicyExtensionData;

    PPMLICENSEREQUEST   pClientLicenseRequest;      // original client license request
    PPMLICENSEREQUEST   pPolicyLicenseRequest;      // policy adjusted license request

    //
    // To do ?
    //  consider a callback routine but are we getting
    //  into issuing certificate business.
    //
} TLSDBLICENSEREQUEST, *PTLSDBLICENSEREQUEST, *LPTLSDBLICENSEREQUEST;


typedef struct __ForwardNewLicenseRequest {
    CHALLENGE_CONTEXT m_ChallengeContext;
    TLSLICENSEREQUEST* m_pRequest;
    LPTSTR m_szMachineName;
    LPTSTR m_szUserName;
    DWORD m_cbChallengeResponse;
    PBYTE m_pbChallengeResponse;

    // no forward on request.
} TLSForwardNewLicenseRequest, *PTLSForwardNewLicenseRequest, *LPTLSForwardNewLicenseRequest;

typedef struct __ForwardUpgradeRequest {
    TLSLICENSEREQUEST* m_pRequest;
    CHALLENGE_CONTEXT m_ChallengeContext;
    DWORD m_cbChallengeResponse;
    PBYTE m_pbChallengeResponse;
    DWORD m_cbOldLicense;
    PBYTE m_pbOldLicense;
} TLSForwardUpgradeLicenseRequest, *PTLSForwardUpgradeLicenseRequest, *LPTLSForwardUpgradeLicenseRequest;


//---------------------------------------------------------------------------
//
#define CLIENT_INFO_HYDRA_SERVER                0xFFFFFFFF

typedef enum {
    CONTEXTHANDLE_EMPTY_TYPE=0,
    CONTEXTHANDLE_KEYPACK_ENUM_TYPE,
    CONTEXTHANDLE_LICENSE_ENUM_TYPE,
    CONTEXTHANDLE_CLIENTINFO_TYPE,
    CONTEXTHANDLE_CLIENTCHALLENGE_TYPE,
    CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE,
    CONTEXTHANDLE_CHALLENGE_SERVER_TYPE,
    CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE,
    CONTEXTHANDLE_CHALLENGE_TERMSRV_TYPE
} CONTEXTHANDLE_TYPE;

// No access
#define CLIENT_ACCESS_NONE      0x00000000

// only keypack/license enumeration
#define CLIENT_ACCESS_USER      0x00000001

// Administrator, can update value but can't
// request license
#define CLIENT_ACCESS_ADMIN     0x00000002

// Client can request license no update
// database value
#define CLIENT_ACCESS_REQUEST   0x00000004

// client is registration wizard
// only install certificate
#define CLIENT_ACCESS_LRWIZ     0x00000008

// client is license server, allow
// full access
#define CLIENT_ACCESS_LSERVER   0xFFFFFFFF

#define CLIENT_ACCESS_DEFAULT   CLIENT_ACCESS_USER


typedef struct __ClientContext {
    #if DBG
    DWORD   m_PreDbg[2];            // debug signature
    DBG_RPC_CALL   m_LastCall;             // last call
    #endif

    LPTSTR  m_Client;
    long    m_RefCount;
    DWORD   m_ClientFlags;

    DWORD   m_LastError;
    CONTEXTHANDLE_TYPE m_ContextType;
    HANDLE  m_ContextHandle;

    // NEEDED - A list to store all memory/handle
    //          allocated for the client

    #if DBG
    DWORD   m_PostDbg[2];               // debug signature
    #endif

} CLIENTCONTEXT, *LPCLIENTCONTEXT;

//---------------------------------------------------------------

typedef struct __ENUMHANDLE {
    typedef enum {
        FETCH_NEXT_KEYPACK=1,
        FETCH_NEXT_KEYPACKDESC,
        FETCH_NEW_KEYPACKDESC
    } ENUM_FETCH_CODE;

    PTLSDbWorkSpace pbWorkSpace;
    TLSLICENSEPACK  CurrentKeyPack;         // current fetched keypack record

    LICPACKDESC     KPDescSearchValue;      // licensepack search value
    DWORD           dwKPDescSearchParm;     // licensepackdesc search parameter
    BOOL            bKPDescMatchAll;        // match all condition for keypackdesc
    CHAR            chFetchState;
} ENUMHANDLE, *LPENUMHANDLE;

typedef struct __TERMSERVCERTREQHANDLE {
    PTLSHYDRACERTREQUEST    pCertRequest;
    DWORD                   cbChallengeData;
    PBYTE                   pbChallengeData;
} TERMSERVCERTREQHANDLE, *LPTERMSERVCERTREQHANDLE;

typedef struct __ClientChallengeContext {
    DWORD       m_ClientInfo;
    HANDLE      m_ChallengeContext;
} CLIENTCHALLENGECONTEXT, *LPCLIENTCHALLENGECONTEXT;

typedef enum {
    ALLOCATE_EXACT_VERSION=0,
    ALLOCATE_ANY_GREATER_VERSION,
    ALLOCATE_LATEST_VERSION             // not supported
} LICENSE_ALLOCATION_SCHEME;

typedef struct __AllocateRequest {
    UCHAR       ucAgreementType;  // keypack type
    LPTSTR      szCompanyName;  // company name
    LPTSTR      szProductId;    // product
    DWORD       dwVersion;      // version wanted
    DWORD       dwPlatformId;   // license platform
    DWORD       dwLangId;       // unused

    DWORD       dwNumLicenses;  // number of license wanted/returned

    LICENSE_ALLOCATION_SCHEME dwScheme;

    // TODO - CallBack function to let calling
    // function decide

} TLSDBAllocateRequest, *PTLSDBAllocateRequest, *LPTLSDBAllocateRequest;

typedef struct __LicenseAllocation {
    // array size for dwAllocationVector
    DWORD       dwBufSize;

    //
    // Total license allocated
    DWORD       dwTotalAllocated;

    // number of license allocate from
    // each keypack
    DWORD*      pdwAllocationVector;

    // keypack that license allocate from
    PLICENSEPACK   lpAllocateKeyPack;
} TLSDBLicenseAllocation, *PTLSDBLicenseAllocation, *LPTLSDBLicenseAllocation;

//---------------------------------------------------------------------
//----------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    WaitForMyTurnOrShutdown(
        HANDLE hHandle,
        DWORD dwWaitTime
    );

    HANDLE
    GetServiceShutdownHandle();

    void
    ServiceSignalShutdown();

    void
    ServiceResetShutdownEvent();

    BOOL
    AcquireRPCExclusiveLock(
        IN DWORD dwWaitTime
    );

    void
    ReleaseRPCExclusiveLock();

    BOOL
    AcquireAdministrativeLock(
        IN DWORD dwWaitTime
    );

    void
    ReleaseAdministrativeLock();

    DWORD
    TLSMapReturnCode(DWORD);

    unsigned int WINAPI
    MailSlotThread(
        void* ptr
    );

    HANDLE
    ServerInit(
        BOOL bDebug
    );

    DWORD
    InitNamedPipeThread();

    DWORD
    InitMailSlotThread();

    DWORD
    InitExpirePermanentThread();

    BOOL
    IsServiceShuttingdown();

#ifdef __cplusplus
}
#endif

    void __cdecl
    trans_se_func(
        unsigned int u,
        _EXCEPTION_POINTERS* pExp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\service.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        service.c
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <winsock2.h>
#include <ws2tcpip.h>
#include "server.h"
#include "globals.h"
#include "init.h"
#include "postsrv.h"
#include "tlsbkup.h"


#define SERVICE_WAITHINT 60*1000                // WaitHint 1 mins.
#define SERVICE_SHUTDOWN_WAITTIME   15*60*1000  // must have shutdown already.


//---------------------------------------------------------------------------
//
// internal function prototypes
//
BOOL 
ReportStatusToSCMgr(
    DWORD, 
    DWORD, 
    DWORD
);

DWORD 
ServiceStart(
    DWORD, 
    LPTSTR *, 
    BOOL bDebug=FALSE
);

VOID WINAPI 
ServiceCtrl(
    DWORD
);

VOID WINAPI 
ServiceMain(
    DWORD, 
    LPTSTR *
);

VOID 
CmdDebugService(
    int, 
    char **, 
    BOOL
);

BOOL WINAPI 
ControlHandler( 
    DWORD 
);

extern "C" VOID 
ServiceStop();

VOID 
ServicePause();

VOID 
ServiceContinue();

HANDLE hRpcPause=NULL;


///////////////////////////////////////////////////////////
//
// internal variables
//
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   ssCurrentStatus;       // current status of the service
BOOL g_bReportToSCM = TRUE;

HANDLE gSafeToTerminate=NULL;

HRESULT hrStatus = NULL;

DEFINE_GUID(TLS_WRITER_GUID, 0x5382579c, 0x98df, 0x47a7, 0xac, 0x6c, 0x98, 0xa6, 0xd7, 0x10, 0x6e, 0x9);
GUID idWriter = TLS_WRITER_GUID;

CVssJetWriter *g_pWriter = NULL;



SERVICE_TABLE_ENTRY dispatchTable[] =
{
    { _TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)ServiceMain },
    { NULL, NULL }
};


//-----------------------------------------------------------------
// Internal routine
//-----------------------------------------------------------------
void print_usage()
{
  _ftprintf(
        stdout, 
        _TEXT("Usage : %s can't be run as a console app\n"), 
        _TEXT(SZAPPNAME)
    );
  return;
}



//-----------------------------------------------------------------

DWORD
AddNullSessionPipe(
    IN LPTSTR szPipeName
    )
/*++

Abstract:

    Add our RPC namedpipe into registry to allow unrestricted access.

Parameter:

    szPipeName : name of the pipe to append.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    LPTSTR lpszKey=L"SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
    LPTSTR lpszValue=L"NullSessionPipes";

    HKEY hKey;
    DWORD dwStatus;
    LPTSTR pbData=NULL, pbOrg=NULL;
    DWORD  cbData = 0;

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        lpszKey,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                    );
    if(dwStatus != ERROR_SUCCESS)
        return dwStatus;

                                                       
    dwStatus = RegQueryValueEx(
                        hKey,
                        lpszValue,
                        NULL,
                        NULL,
                        NULL,
                        &cbData
                    );

    if(dwStatus != ERROR_MORE_DATA && dwStatus != ERROR_SUCCESS)
        return dwStatus;

    // pre-allocate our pipe name
    if(!(pbData = (LPTSTR)AllocateMemory(cbData + (_tcslen(szPipeName) + 1) * sizeof(TCHAR))))
        return GetLastError();

    dwStatus = RegQueryValueEx(
                        hKey,
                        lpszValue,
                        NULL,
                        NULL,
                        (LPBYTE)pbData,
                        &cbData
                    );
    
    BOOL bAddPipe=TRUE;
    pbOrg = pbData;

    // check pipe name
    while(*pbData)
    {
        if(!_tcsicmp(pbData, szPipeName))
        {
            bAddPipe=FALSE;
            break;
        }

        pbData += _tcslen(pbData) + 1;
    }

    if(bAddPipe)
    {
        _tcscat(pbData, szPipeName);
        cbData += (_tcslen(szPipeName) + 1) * sizeof(TCHAR);
        dwStatus = RegSetValueEx( 
                            hKey, 
                            lpszValue, 
                            0, 
                            REG_MULTI_SZ, 
                            (PBYTE)pbOrg, 
                            cbData
                        );
    }

    FreeMemory(pbOrg);
    RegCloseKey(hKey);

    return dwStatus;
}
//-----------------------------------------------------------------
void __cdecl 
trans_se_func(
    unsigned int u, 
    _EXCEPTION_POINTERS* pExp 
    )
/*++

--*/
{
    #if DBG
    OutputDebugString(_TEXT("Translating SE exception...\n"));
    #endif

    throw SE_Exception( u );
}

//-----------------------------------------------------------------
int __cdecl 
handle_new_failed( 
    size_t size 
    )
/*++


--*/
{
    #if DBG
    OutputDebugString(_TEXT("handle_new_failed() invoked...\n"));
    #endif

    //
    // Raise exception here, STL does not check return pointer
    //
    RaiseException(
            ERROR_OUTOFMEMORY,
            0,
            0,
            NULL
        );

    //
    // stop memory allocation attemp.
    //
    return 0;
}                

//-----------------------------------------------------------------
void _cdecl 
main(
    int argc, 
    char **argv
    )
/*++

Abstract 

    Entry point.

++*/
{
    // LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

    _set_new_handler(handle_new_failed);    
    _set_new_mode(1);

    gSafeToTerminate = CreateEvent(
                                NULL,
                                TRUE,
                                FALSE,
                                NULL
                            );
                                
    if(gSafeToTerminate == NULL)
    {
        TLSLogErrorEvent(TLS_E_ALLOCATE_RESOURCE);
        // out of resource.
        return;
    }

    for(int i=1; i < argc; i++)
    {
        if(*argv[i] == '-' || *argv[i] == '/')
        {
            if(!_stricmp("noservice", argv[i]+1))
            {
                g_bReportToSCM = FALSE;
            }
            else if(!_stricmp("cleanup", argv[i]+1))
            {
                CleanSetupLicenseServer();
                exit(0);
            }
            else
            {
                print_usage();
                exit(0);
            }
        }
    }

    if(g_bReportToSCM == FALSE)
    {
        CmdDebugService(
                argc, 
                argv, 
                !g_bReportToSCM
            );
    }
    else if(!StartServiceCtrlDispatcher(dispatchTable))
    {
        TLSLogErrorEvent(TLS_E_SC_CONNECT);
    }

    WaitForSingleObject(gSafeToTerminate, INFINITE);
    CloseHandle(gSafeToTerminate);
}


//-----------------------------------------------------------------
void WINAPI 
ServiceMain(
    IN DWORD dwArgc, 
    IN LPTSTR *lpszArgv
    )
/*++

Abstract:

    To perform actual initialization of the service

Parameter:

    dwArgc   - number of command line arguments
    lpszArgv - array of command line arguments


Returns:

    none

++*/
{
    DWORD dwStatus;

    // register our service control handler:
    sshStatusHandle = RegisterServiceCtrlHandler( 
                                _TEXT(SZSERVICENAME), 
                                ServiceCtrl 
                            );

    if (sshStatusHandle)
    {
        ssCurrentStatus=SERVICE_START_PENDING;

        // report the status to the service control manager.
        //
        if(ReportStatusToSCMgr(
                        SERVICE_START_PENDING, // service state
                        NO_ERROR,              // exit code
                        SERVICE_WAITHINT))          // wait hint
        {
            dwStatus = ServiceStart(
                                    dwArgc, 
                                    lpszArgv
                                );

            if(dwStatus != ERROR_SUCCESS)
            {
                ReportStatusToSCMgr(
                                    SERVICE_STOPPED, 
                                    dwStatus, 
                                    0
                                );
            }
            else 
            {
                ReportStatusToSCMgr(
                                    SERVICE_STOPPED, 
                                    NO_ERROR, 
                                    0
                                );
            }
        }
    }
    else
    {
        dwStatus = GetLastError();
        TLSLogErrorEvent(TLS_E_SC_CONNECT);
    }

    DBGPrintf(
        DBG_INFORMATION,
        DBG_FACILITY_INIT,
        DBGLEVEL_FUNCTION_TRACE,
        _TEXT("Service terminated...\n")
    );

    return;
}

//-------------------------------------------------------------
VOID WINAPI 
ServiceCtrl(
    IN DWORD dwCtrlCode
    )
/*+++

Abstract:

    This function is called by the SCM whenever 
    ControlService() is called on this service.

Parameter:

    dwCtrlCode - type of control requested from SCM.

+++*/
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:

            ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        0
                    );
            ServiceStop();
            break;

        // We don't really accept pause and continue
        case SERVICE_CONTROL_PAUSE:
            ReportStatusToSCMgr(
                        SERVICE_PAUSED, 
                        NO_ERROR, 
                        0
                    );

            ServicePause();
            break;

        case SERVICE_CONTROL_CONTINUE:        
            ReportStatusToSCMgr(
                        SERVICE_RUNNING, 
                        NO_ERROR, 
                        0
                    );
            ServiceContinue();
            break;

        // Update the service status.
        case SERVICE_CONTROL_INTERROGATE:
            ReportStatusToSCMgr(
                        ssCurrentStatus, 
                        NO_ERROR, 
                        0
                    );
            break;

        // invalid control code
        default:
            break;

    }
}

//------------------------------------------------------------------
DWORD 
ServiceShutdownThread(
    void *p
    )
/*++

Abstract:

    Entry point into thread that shutdown server (mainly database).

Parameter:

    Ignore

++*/
{
    ServerShutdown();

    ExitThread(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}    

//------------------------------------------------------------------
DWORD 
RPCServiceStartThread(
    void *p
    )
/*++

Abstract:

    Entry point to thread that startup RPC.

Parameter:

    None.

Return:

    Thread exit code.

++*/
{
    RPC_BINDING_VECTOR *pbindingVector = NULL;
    RPC_STATUS status = RPC_S_OK;
    WCHAR *pszEntryName = _TEXT(RPC_ENTRYNAME);
    DWORD dwNumSuccessRpcPro=0;
    do {
        //
        // local procedure call
        //
        status = RpcServerUseProtseq( 
                                _TEXT(RPC_PROTOSEQLPC),
                                RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                NULL // &SecurityDescriptor
                            );
        if(status == RPC_S_OK)
        {
            dwNumSuccessRpcPro++;
        }

        //
        // NT4 backward compatible issue, let NT4 termsrv serivce
        // client connect so still set security descriptor
        //
        // 11/10/98 Tested on NT4 and NT5
        //

        //
        // Namedpipe
        //
        status = RpcServerUseProtseqEp( 
                                _TEXT(RPC_PROTOSEQNP),
                                RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                _TEXT(LSNAMEPIPE),
                                NULL //&SecurityDescriptor
                            );
        if(status == RPC_S_OK)
        {
            dwNumSuccessRpcPro++;
        }

        //
        // TCP/IP
        //
        status = RpcServerUseProtseq( 
                                _TEXT(RPC_PROTOSEQTCP),
                                RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                NULL //&SecurityDescriptor
                            );
        if(status == RPC_S_OK)
        {
            dwNumSuccessRpcPro++;
        }

        // Must have at least one protocol.
        if(dwNumSuccessRpcPro == 0)
        {
            status = TLS_E_RPC_PROTOCOL;
            break;
        }

        // Get server binding handles
        status = RpcServerInqBindings(&pbindingVector);
        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_INQ_BINDING;
            break;
        }

        // Register interface(s) and binding(s) (endpoints) with
        // the endpoint mapper.
        status = RpcEpRegister( 
                            TermServLicensing_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL, // &export_uuid,
                            L""
                        );

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_EP_REGISTER;
            break;
        }

        status = RpcServerRegisterIf(
                            TermServLicensing_v1_0_s_ifspec,
                            NULL,
                            NULL);
        if(status != RPC_S_OK)
        {
            status = TLS_E_RPC_REG_INTERFACE;
            break;
        }

        // Register interface(s) and binding(s) (endpoints) with
        // the endpoint mapper.
        status = RpcEpRegister( 
                            HydraLicenseService_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL, // &export_uuid,
                            L"");

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_EP_REGISTER;
            break;
        }

        status = RpcServerRegisterIf(
                            HydraLicenseService_v1_0_s_ifspec,
                            NULL,
                            NULL);
        if(status != RPC_S_OK)
        {
            status = TLS_E_RPC_REG_INTERFACE;
            break;
        }

        // Register interface(s) and binding(s) (endpoints) with
        // the endpoint mapper.
        status = RpcEpRegister( 
                            TermServLicensingBackup_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL, // &export_uuid,
                            L"");

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_EP_REGISTER;
            break;
        }

        status = RpcServerRegisterIf(
                            TermServLicensingBackup_v1_0_s_ifspec,
                            NULL,
                            NULL);
        if(status != RPC_S_OK)
        {
            status = TLS_E_RPC_REG_INTERFACE;
            break;
        }

        // Enable NT LM Security Support Provider (NtLmSsp service)
        status = RpcServerRegisterAuthInfo(0,
                                           RPC_C_AUTHN_WINNT,
                                           0,
                                           0);

        if (status != RPC_S_OK)
        {
            status = TLS_E_RPC_SET_AUTHINFO;
            break;
        }

    } while(FALSE);

    if(status != RPC_S_OK)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE, 
                TLS_E_SERVICEINIT,
                TLS_E_INITRPC, 
                status
            );

        status = TLS_E_SERVICE_STARTUP;
    }

    ExitThread(status);
    return status;
}

//------------------------------------------------------------------------
unsigned int __stdcall
GetLServerRoleInDomain(
    PVOID pData
    )
/*++

--*/
{
    SERVER_ROLE_IN_DOMAIN* srvRole = (SERVER_ROLE_IN_DOMAIN *)pData;

    if(pData != NULL)
    {
        *srvRole = GetServerRoleInDomain(NULL);
    }

    _endthreadex(0);
    return 0;
}

//------------------------------------------------------------------------

DWORD 
ServiceStart(
    IN DWORD dwArgc, 
    IN LPTSTR *lpszArgv, 
    IN BOOL bDebug
    )
/*
*/
{
    RPC_BINDING_VECTOR *pbindingVector = NULL;
    WCHAR *pszEntryName = _TEXT(RPC_ENTRYNAME);
    HANDLE hInitThread=NULL;
    HANDLE hRpcThread=NULL;
    HANDLE hMailslotThread=NULL;
    HANDLE hShutdownThread=NULL;

    DWORD   dump;
    HANDLE  hEvent=NULL;
    DWORD   dwStatus=ERROR_SUCCESS;
    WORD    wVersionRequested;
    WSADATA wsaData;
    int     err; 

    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

   
    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	{
	    
        DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("CoInitializeEx failed with error code %08x...\n"), 
                    hrStatus
                );
	}

    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

	if (SUCCEEDED (hrStatus))
    {
        hrStatus = CoInitializeSecurity(
	                                    NULL,
	                                    -1,
	                                    NULL,
	                                    NULL,
	                                    RPC_C_AUTHN_LEVEL_CONNECT,
	                                    RPC_C_IMP_LEVEL_IDENTIFY,
	                                    NULL,
	                                    EOAC_NONE,
	                                    NULL
	                                    );
    }

    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    if (SUCCEEDED (hrStatus))
    {

	    g_pWriter = new CVssJetWriter;

	    if (NULL == g_pWriter)
		{
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("new CVssJetWriter failed...\n")
                );
		    

		    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);
		}
	}

    // Report the status to the service control manager.
    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    {
        DWORD dwConsole;
        DWORD dwDbLevel;
        DWORD dwType;
        DWORD dwSize = sizeof(dwConsole);
        DWORD status;

        HKEY hKey=NULL;

        status = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_PARAMETERS_KEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);

        if(status == ERROR_SUCCESS)
        {

            if(RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_CONSOLE,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwConsole,
                        &dwSize
                    ) != ERROR_SUCCESS)
            {
                dwConsole = 0;
            }

            dwSize = sizeof(dwDbLevel);

            if(RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_LOGLEVEL,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwDbLevel,
                        &dwSize
                    ) == ERROR_SUCCESS)
            {
                InitDBGPrintf(
                        dwConsole != 0,
                        _TEXT(SZSERVICENAME),
                        dwDbLevel
                    );
            }

            RegCloseKey(hKey);
        }
    }

    // Report the status to the service control manager.
    if (!ReportStatusToSCMgr(
                        SERVICE_START_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT))
    {
        // resource leak but something went wrong already.
        dwStatus = TLS_E_SC_REPORT_STATUS;
        goto cleanup;
    }

    do {

        // setup should have done this but just to make sure we have our 
        // pipe in NullSessionPipe to allow service to connect
        AddNullSessionPipe(_TEXT(HLSPIPENAME));
        AddNullSessionPipe(_TEXT(SZSERVICENAME));

        wVersionRequested = MAKEWORD( 1, 1 ); 
        err = WSAStartup( 
                        wVersionRequested, 
                        &wsaData 
                    );
        if(err != 0) 
        {
            // None critical error
            TLSLogWarningEvent(
                        TLS_E_SERVICE_WSASTARTUP
                    );
        }
        else
        {
            char hostname[(MAXTCPNAME+1)*sizeof(TCHAR)];
            err=gethostname(hostname, MAXTCPNAME*sizeof(TCHAR));
            if(err == 0)
            {
                struct addrinfo *paddrinfo;
                struct addrinfo hints;

                memset(&hints,0,sizeof(hints));

                hints.ai_flags = AI_CANONNAME;
                hints.ai_family = PF_UNSPEC;

                if (0 == getaddrinfo(hostname,NULL,&hints,&paddrinfo))
                {
                    err = (MultiByteToWideChar(
                                        GetACP(), 
                                        MB_ERR_INVALID_CHARS, 
                                        paddrinfo->ai_canonname,
                                        -1, 
                                        g_szHostName, 
                                        g_cbHostName) == 0) ? -1 : 0;
                }
                else
                {
                    err = -1;
                }

                freeaddrinfo(paddrinfo);
            }
        }

        if(err != 0)
        {
            if(GetComputerName(g_szHostName, &g_cbHostName) == FALSE)
            {
                dwStatus = GetLastError();

                DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("GetComputerName() failed with %d...\n"),
                    dwStatus
                );

                // this shoule not happen...
                TLSLogErrorEvent(TLS_E_INIT_GENERAL);
                break;
            }
        }

        if(GetComputerName(g_szComputerName, &g_cbComputerName) == FALSE)
        {
            dwStatus = GetLastError();

            DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_INIT,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("GetComputerName() failed with %d...\n"),
                dwStatus
            );

            // this shoule not happen...
            TLSLogErrorEvent(TLS_E_INIT_GENERAL);
            break;
        }

        hRpcPause=CreateEvent(NULL, TRUE, TRUE, NULL);
        if(!hRpcPause)
        {
            TLSLogErrorEvent(TLS_E_ALLOCATE_RESOURCE);
            dwStatus = TLS_E_ALLOCATE_RESOURCE;
            break;
        }

        //
        // start up general server and RPC initialization thread
        //
        hInitThread=ServerInit(bDebug);
        if(hInitThread==NULL)
        {
            TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
            dwStatus = TLS_E_SERVICE_STARTUP_CREATE_THREAD;
            break;
        }

        dwStatus = ERROR_SUCCESS;

        //
        // Wait for general server init. thread to terminate
        //
        while(WaitForSingleObject( hInitThread, 100 ) == WAIT_TIMEOUT)
        {
            // Report the status to the service control manager.
            if (!ReportStatusToSCMgr(
                                SERVICE_START_PENDING,
                                NO_ERROR,
                                SERVICE_WAITHINT))
            {
                // resource leak but something went wrong already.
                dwStatus = TLS_E_SC_REPORT_STATUS;
                break;
            }
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }


        // Check thread exit code.
        GetExitCodeThread(
                    hInitThread, 
                    &dwStatus
                );
        if(dwStatus != ERROR_SUCCESS)
        {
            //
            // Server init. thread logs its own error
            //
            dwStatus = TLS_E_SERVICE_STARTUP_INIT_THREAD_ERROR;
            break;
        }

        CloseHandle(hInitThread);
        hInitThread=NULL;


        // timing, if we startup RPC init thread but database init thread 
        // can't initialize, service will be in forever stop state.
        hRpcThread=CreateThread(
                            NULL, 
                            0, 
                            RPCServiceStartThread, 
                            ULongToPtr(bDebug), 
                            0, 
                            &dump
                        );
        if(hRpcThread == NULL)
        {
            TLSLogErrorEvent(TLS_E_SERVICE_STARTUP_CREATE_THREAD);
            dwStatus=TLS_E_SERVICE_STARTUP_CREATE_THREAD;
            break;
        }

        dwStatus = ERROR_SUCCESS;

        //
        // Wait for RPC init. thread to terminate
        //
        while(WaitForSingleObject( hRpcThread, 100 ) == WAIT_TIMEOUT)
        {
            // Report the status to the service control manager.
            if (!ReportStatusToSCMgr(SERVICE_START_PENDING, // service state
                                     NO_ERROR,              // exit code
                                     SERVICE_WAITHINT))          // wait hint
            {
                dwStatus = TLS_E_SC_REPORT_STATUS;
                break;
            }
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        // Check thread exit code.
        GetExitCodeThread(hRpcThread, &dwStatus);
        if(dwStatus != ERROR_SUCCESS)
        {
            dwStatus = TLS_E_SERVICE_STARTUP_RPC_THREAD_ERROR;
            break;
        }

        CloseHandle(hRpcThread);
        hRpcThread=NULL;

        //
        // Tell server control manager that we are ready.
        //
        if (!ReportStatusToSCMgr(
                            SERVICE_RUNNING,        // service state
                            NO_ERROR,               // exit code
                            SERVICE_WAITHINT             // wait hint
                        ))
        {
            dwStatus = TLS_E_SC_REPORT_STATUS;
            break;
        }

        
        //
        // Post service init. load self-signed certificate and init. crypt.
        // this is needed after reporting service running status back to 
        // service control manager because it may need to manually call 
        // StartService() to startup protected storage service. 
        //
        if(InitCryptoAndCertificate() != ERROR_SUCCESS)
        {
            dwStatus = TLS_E_SERVICE_STARTUP_POST_INIT;
            break;
        }

        TLSLogInfoEvent(TLS_I_SERVICE_START);


        // RpcMgmtWaitServerListen() will block until the server has
        // stopped listening.  If this service had something better to
        // do with this thread, it would delay this call until
        // ServiceStop() had been called. (Set an event in ServiceStop()).
        //
        BOOL bOtherServiceStarted = FALSE;

        do {
            WaitForSingleObject(hRpcPause, INFINITE);
            if(ssCurrentStatus == SERVICE_STOP_PENDING)
            {
                break;
            }

            // Start accepting client calls.PostServiceInit
            dwStatus = RpcServerListen(
                                RPC_MINIMUMCALLTHREADS,
                                RPC_MAXIMUMCALLTHREADS,
                                TRUE
                            );

            if(dwStatus != RPC_S_OK)
            {
                TLSLogErrorEvent(TLS_E_RPC_LISTEN);
                dwStatus = TLS_E_SERVICE_RPC_LISTEN;
                break;
            }

            //
            // Initialize all policy module
            //
            if(bOtherServiceStarted == FALSE)
            {
                dwStatus = PostServiceInit();
                if(dwStatus != ERROR_SUCCESS)
                {
                    // faild to initialize.
                    break;
                }

                //ServiceInitPolicyModule();
            }

            bOtherServiceStarted = TRUE;

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("Ready to accept request...\n")
                );

            dwStatus = RpcMgmtWaitServerListen();
            assert(dwStatus == RPC_S_OK);
        } while(TRUE);

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        //
        // Terminate - ignore all error here on
        //
        dwStatus = RpcServerUnregisterIf(
                                TermServLicensingBackup_v1_0_s_ifspec,
                                NULL,
                                TRUE
                            );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING,
                        NO_ERROR,
                        SERVICE_WAITHINT
                    );

        dwStatus = RpcServerUnregisterIf(
                                HydraLicenseService_v1_0_s_ifspec,
                                NULL,
                                TRUE
                            );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        dwStatus = RpcServerUnregisterIf(
                                    TermServLicensing_v1_0_s_ifspec,   // from rpcsvc.h
                                    NULL,
                                    TRUE
                            );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );


        // Remove entries from the endpoint mapper database.
        dwStatus = RpcEpUnregister(
                            HydraLicenseService_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL
                        );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        // Remove entries from the endpoint mapper database.
        dwStatus = RpcEpUnregister(
                            TermServLicensing_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL
                        );

        // tell service control manager we are stopping
        ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );

        // Remove entries from the endpoint mapper database.
        dwStatus = RpcEpUnregister(
                            TermServLicensingBackup_v1_0_s_ifspec,   // from rpcsvc.h
                            pbindingVector,
                            NULL
                        );

        // Get server binding handles
        dwStatus = RpcServerInqBindings(
                                &pbindingVector
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = RpcBindingVectorFree(
                                    &pbindingVector
                                );
        }
        

        // Create entry name in name database first
        // Only work for NT 5.0 
        // status = RpcNsMgmtEntryDelete(RPC_C_NS_SYNTAX_DEFAULT, pszEntryName);

        // try to report the stopped status to the service control manager.
        //
        // Initialize Crypto.
    } while(FALSE);

    if(hInitThread != NULL)
    {
        CloseHandle(hInitThread);
    }

    if(hRpcThread != NULL)
    {
        CloseHandle(hRpcThread);
    }

    if(hMailslotThread != NULL)
    {
        CloseHandle(hMailslotThread);
    }

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if(hRpcPause != NULL)
    {
        CloseHandle(hRpcPause);
    }

    if(err == 0)
    {
        WSACleanup();
    }

    ReportStatusToSCMgr(
                SERVICE_STOP_PENDING, 
                dwStatus, //NO_ERROR, 
                SERVICE_WAITHINT
            );

    //
    // Create another thread to shutdown server.
    //
    hShutdownThread=CreateThread(
                            NULL, 
                            0, 
                            ServiceShutdownThread, 
                            (VOID *)NULL, 
                            0, 
                            &dump
                        );
    if(hShutdownThread == NULL)
    {
        // Report the status to the service control manager with
        // long wait hint time.
        ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING, 
                    NO_ERROR, 
                    SERVICE_SHUTDOWN_WAITTIME
                );

        //
        // can't create thread, just call shutdown directory
        //
        ServerShutdown();
    }
    else
    {
        //
        // report in 5 second interval to SC.
        //
        DWORD dwMaxWaitTime = SERVICE_SHUTDOWN_WAITTIME / 5000;  
        DWORD dwTimes=0;

        //
        // Wait for general server shutdown thread to terminate
        // Gives max 1 mins to shutdown
        //
        while(WaitForSingleObject( hShutdownThread, SC_WAITHINT ) == WAIT_TIMEOUT &&
              dwTimes++ < dwMaxWaitTime)
        {
            // Report the status to the service control manager.
            ReportStatusToSCMgr(
                        SERVICE_STOP_PENDING, 
                        NO_ERROR, 
                        SERVICE_WAITHINT
                    );
        }

        CloseHandle(hShutdownThread);
    }

cleanup:

    if (NULL != g_pWriter)
	{
	    g_pWriter->Uninitialize();
	    delete g_pWriter;
	    g_pWriter = NULL;
	}

    CoUninitialize( );

    // Signal we are safe to shutting down
    SetEvent(gSafeToTerminate);
    return dwStatus;
}

//-----------------------------------------------------------------
VOID 
ServiceStop()
/*++

++*/
{
 
    ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING,
                    NO_ERROR,
                    0
                );

    // Stop's the server, wakes the main thread.
    SetEvent(hRpcPause);

    //
    // Signal currently waiting RPC call to terminate
    //
    ServiceSignalShutdown();

    // this is the actual time we receive shutdown request.
    SetServiceLastShutdownTime();


    (VOID)RpcMgmtStopServerListening(NULL);
    TLSLogInfoEvent(TLS_I_SERVICE_STOP);
}

//-----------------------------------------------------------------
VOID 
ServicePause()
/*++

++*/
{
    ResetEvent(hRpcPause);
    (VOID)RpcMgmtStopServerListening(NULL);
    TLSLogInfoEvent(TLS_I_SERVICE_PAUSED);
}

//-----------------------------------------------------------------
VOID 
ServiceContinue()
/*++

++*/
{
    SetEvent(hRpcPause);
    TLSLogInfoEvent(TLS_I_SERVICE_CONTINUE);
}

//-----------------------------------------------------------------
BOOL 
ReportStatusToSCMgr(
    IN DWORD dwCurrentState, 
    IN DWORD dwExitCode, 
    IN DWORD dwWaitHint
    )
/*++
Abstract: 

    Sets the current status of the service and reports it 
    to the Service Control Manager

Parameter:

    dwCurrentState - the state of the service
    dwWin32ExitCode - error code to report
    dwWaitHint - worst case estimate to next checkpoint

Returns:

    TRUE if success, FALSE otherwise

*/
{
    BOOL fResult=TRUE;

    if(g_bReportToSCM == TRUE)
    {
        SERVICE_STATUS ssStatus;
        static DWORD dwCheckPoint = 1;

        ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;

        //
        // global - current status of process
        //
        ssCurrentStatus = dwCurrentState;

        if (dwCurrentState == SERVICE_START_PENDING)
        {
            ssStatus.dwControlsAccepted = 0;
        }
        else
        {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_CONTROL_SHUTDOWN;
        }

        ssStatus.dwCurrentState = dwCurrentState;
        if(dwExitCode != NO_ERROR) 
        {
            ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
            ssStatus.dwServiceSpecificExitCode = dwExitCode;
        }
        else
        {
          ssStatus.dwWin32ExitCode = dwExitCode;
        }

        ssStatus.dwWaitHint = dwWaitHint;

        if(dwCurrentState == SERVICE_RUNNING || dwCurrentState == SERVICE_STOPPED)
        {
            ssStatus.dwCheckPoint = 0;
        }
        else
        {
            ssStatus.dwCheckPoint = dwCheckPoint++;
        }

        // Report the status of the service to the service control manager.
        //
        fResult = SetServiceStatus(
                            sshStatusHandle, 
                            &ssStatus
                        );
        if(fResult == FALSE)
        {
            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_INIT,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("Failed to set service status %d...\n"),
                    GetLastError()
                );


            TLSLogErrorEvent(TLS_E_SC_REPORT_STATUS);
        }
    }

    return fResult;
}



///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//
void 
CmdDebugService(
    IN int argc, 
    IN char ** argv, 
    IN BOOL bDebug
    )
/*
*/
{
    int dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(
            _TEXT("Debugging %s.\n"), 
            _TEXT(SZSERVICEDISPLAYNAME)
        );

    SetConsoleCtrlHandler( 
            ControlHandler, 
            TRUE 
        );

    ServiceStart( 
            dwArgc, 
            lpszArgv, 
            bDebug 
        );
}

//------------------------------------------------------------------
BOOL WINAPI 
ControlHandler( 
    IN DWORD dwCtrlType 
    )
/*++

Abstract:


Parameter:

    IN dwCtrlType : control type

Return:

    
++*/
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(
                    _TEXT("Stopping %s.\n"), 
                    _TEXT(SZSERVICEDISPLAYNAME)
                );

            ssCurrentStatus = SERVICE_STOP_PENDING;
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl


!ENDIF

!include $(LSERVER_ROOT)\lserver.mk

INCLUDES = \
    $(INCLUDES); \
    $(LICENSE_ROOT)\lkplite; \
    $(DRIVERS_INC_PATH);

MINORCOMP=lserver

INCPATH0=$(INCLUDE)

TARGETNAME=$(MINORCOMP)
TARGETPATH=obj
TARGETTYPE=PROGRAM

PASS0_HEADERDIR=$(O)
MC_SOURCEDIR=$(O)

USE_MSVCRT=1
USE_NATIVE_EH=ASYNC
USE_STL=1
USE_RTTI=1

UMTYPE=console

LINKER_STACKCOMMITSIZE=16384

SOURCES= \
    ..\messages.mc \
    ..\debug.cpp \
    ..\misc.cpp \
    ..\db.cpp \
    ..\pid.cpp \
    ..\init.cpp \
    ..\utils.cpp \
    ..\remotedb.cpp \
    ..\postjob.cpp \
    ..\globals.cpp \
    ..\postsrv.cpp \
    ..\tlscert.cpp \
    ..\npipe.cpp \
    ..\licreq.cpp \
    ..\defpol.cpp \
    ..\policy.cpp \
    ..\server.rc \
    ..\conlic.cpp \
    ..\permlic.cpp \
    ..\templic.cpp \
    ..\findlost.cpp \
    ..\hydrals-s.c \
    ..\tlsrpc-s.c \
    ..\wkspace.cpp \
    ..\tlsrpc.cpp \
    ..\license.cpp \
    ..\keypack.cpp \
    ..\rpc.cpp \
    ..\service.cpp \
    ..\gencert.cpp \
    ..\upgdb.cpp \
    ..\kp.cpp \
    ..\lkpdesc.cpp \
    ..\ch.cpp \
    ..\errcode.cpp \
    ..\srvlist.cpp \
    ..\mailslot.cpp \
    ..\forward.cpp \
    ..\jobmgr.cpp \
    ..\wkstore.cpp \
    ..\tlsbkup-s.c \
    ..\tlsbkup.cpp \
    ..\expperm.cpp \
    ..\tlsjob.cpp

PRECOMPILED_INCLUDE=..\pch.cpp

UMLIBS=\
    $(LICENSE_ROOT)\pidapi\lib\*\medsig.lib \
    $(LSERVER_LIB_PATH)\$(O)\trust.lib \
    $(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(O)\tlsapip.lib \
    $(KEYPKLIB) \
    $(LKPLITELIB) \
    $(CERTUTILLIB) \
    $(COMMON_LIB) \
    $(LSCRYPTLIB) \
    $(LSERVER_LIB_PATH)\$(O)\asn1.lib \
    $(LSERVER_LIB_PATH)\$(O)\TlsDb.lib \
    $(LSERVER_LIB_PATH)\$(O)\JetBlue.lib \
    $(LSERVER_LIB_PATH)\$(O)\marshal.lib \
    $(LSERVER_LIB_PATH)\$(O)\esetup.lib \
    $(SDK_LIB_PATH)\activeds.lib   \
    $(SDK_LIB_PATH)\adsiid.lib     \
    $(DS_LIB_PATH)\randlib.lib     \
    $(DS_LIB_PATH)\bignum.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\esent.lib \
    $(SDK_LIB_PATH)\crypt32.lib \
    $(SDK_LIB_PATH)\ws2_32.lib \
    $(SDK_LIB_PATH)\ole32.lib \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\netapi32.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(SDK_LIB_PATH)\rpcns4.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\vssapi.lib \
    $(SDK_LIB_PATH)\ntdll.lib  \
    $(TERMSRV_LIB_PATH)\regapi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\rpc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        rpc.c
//
// Contents:    Various RPC function to accept client request
//
// History:     12-09-98    HueiWang    Created
//              05-26-98    HueiWang    Move all code to TLSRpcXXX
//                                      API here is only for compatible with
//                                      NT40 Hydra
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "server.h"
#include "init.h"

//+------------------------------------------------------------------------
error_status_t 
LSGetRevokeKeyPackList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfKeyPack,
    /* [size_is][out][in] */ PDWORD pRevokeKeyPackList
    )
/*

Note : For backward compatible with NT40 Hydra only

*/
{
    *pcbNumberOfKeyPack=0;
    return ERROR_SUCCESS;
}

//+------------------------------------------------------------------------
error_status_t 
LSGetRevokeLicenseList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfLicenses,
    /* [size_is][out][in] */ PDWORD pRevokeLicenseList
    )
/*

Note : For backward compatible with NT40 Hydra only

*/
{
    *pcbNumberOfLicenses=0;
    return ERROR_SUCCESS;
}

//+------------------------------------------------------------------------
error_status_t 
LSValidateLicense(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbLicense,
    /* [size_is][in] */ BYTE __RPC_FAR *pbLicense
    )
/*

Note : For backward compatible with NT40 Hydra only

*/
{
    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);
}


//+------------------------------------------------------------------------
error_status_t
LSConnect( 
    /* [in] */ handle_t hRpcBinding, 
    /* [out] */ PCONTEXT_HANDLE __RPC_FAR *pphContext
    )
{
    return TLSRpcConnect( hRpcBinding, pphContext );
}

//-----------------------------------------------------------------------
error_status_t 
LSSendServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbCert,
    /* [size_is][in] */ PBYTE pbCert
    )
{
    DWORD status = ERROR_SUCCESS;

    TLSRpcSendServerCertificate( 
                        phContext, 
                        cbCert, 
                        pbCert, 
                        &status 
                    );
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSDisconnect( 
    /* [out][in] */ PPCONTEXT_HANDLE pphContext
    )
{
    return TLSRpcDisconnect(pphContext);
}

//+------------------------------------------------------------------------

error_status_t 
LSGetServerName(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szMachineName,
    /* [out][in] */ PDWORD pcbSize
    )
/*

Description :

    Return Server's Machine Name.

Arguments:
    
    phContext - client context handle.
    szMachineName - Pointer to a buffer that receives a null-terminated 
                    string containing the computer name. The buffer size 
                    should be large enough to contain 
                    MAX_COMPUTERNAME_LENGTH + 1 characters. 
    cbSize - Pointer to a DWORD variable. On input, the variable 
             specifies the size, in bytes or characters, of the buffer. 
             On output, the variable returns the number of bytes or characters 
             copied to the destination buffer, not including the terminating 
             null character. 

Returns:

    LSERVER_S_SUCCESS    

*/
{
    DWORD dwErrCode=ERROR_SUCCESS;

    TLSRpcGetServerName(
                phContext, 
                szMachineName, 
                pcbSize, 
                &dwErrCode
            );

    return dwErrCode;
}

//+------------------------------------------------------------------------

error_status_t 
LSGetServerScope( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szScopeName,
    /* [out][in] */ PDWORD pcbSize
    )
/*

Description:
    Return License Server's scope

Arguments:
    IN phContext - Client context
    IN OUT szScopeName - return server's scope, must be at least 
                         MAX_COMPUTERNAME_LENGTH in length

Return Value:  
    LSERVER_S_SUCCESS or error code from WideCharToMultiByte()

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcGetServerScope(
                phContext, 
                szScopeName, 
                pcbSize,
                &status
            );

    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSGetInfo(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbHSCert,
    /* [size_is][ref][in] */ PBYTE pHSCert,
    /* [ref][out] */ PDWORD pcbLSCert,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSCert,
    /* [ref][out] */ PDWORD pcbLSSecretKey,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSSecretKey
    )
/*
Description:
    Routine to exchange Hydra server's certificate and License server's
    certificate/private key for signing client machine's hardware ID.

Arguments:
    IN phContext - client context handle
    IN cbHSCert - size of Hydra Server's certificate
    IN pHSCert - Hydra Server's certificate
    IN OUT pcbLSCert - return size of License Server's certificate
    OUT pLSCert - return License Server's certificate
    OUT pcbLSSecretKey - return size of License Server's private key.
    OUT pLSSecretKey - retrun License Server's private key

Return Value:  
    LSERVER_S_SUCCESS           success
    LSERVER_E_INVALID_DATA      Invalid hydra server certificate
    LSERVER_E_OUTOFMEMORY       Can't allocate required memory
    TLS_E_INTERNAL              Internal error occurred in License Server
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcGetInfo( 
                phContext,
                cbHSCert,
                pHSCert,
                pcbLSCert,
                pLSCert,
                pcbLSSecretKey,
                pLSSecretKey,
                &status
            );

    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSGetLastError(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbBufferSize,
    /* [string][out][in] */ LPTSTR szBuffer
    )
/*

Description:
    Return error description text for client's last LSXXX call

Arguments:
    IN phContext - Client context
    IN cbBufferSize - max. size of szBuffer
    IN OUT szBuffer - Pointer to a buffer to receive the 
                      null-terminated character string containing 
                      error description

Note:
    Return ANSI error string.

Returns:
    LSERVER_S_SUCCESS
    TLS_E_INTERNAL     No error or can't find corresponding error
                       description.
    Error code from WideCharToMultiByte().

*/
{
    DWORD status;

    TLSRpcGetLastError(
                phContext, 
                &cbBufferSize, 
                szBuffer, 
                &status
            );
    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSIssuePlatformChallenge(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwClientInfo,
    /* [ref][out] */ PCHALLENGE_CONTEXT pChallengeContext,
    /* [out] */ PDWORD pcbChallengeData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pChallengeData
    )
/*

Description:
    Issue a platform challenge to hydra client.

Arguments:
    IN phContext - client context handle
    IN dwClientInfo - client info.
    OUT pChallengeContext - pointer to client challenge context.
    OUT pcbChallengeData - size of challenge data.
    OUT pChallengeData - random client challenge data.

Returns:
    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_INVALID_DATA      Invalid client info.
    LSERVER_E_SERVER_BUSY

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcIssuePlatformChallenge(
                    phContext, 
                    dwClientInfo, 
                    pChallengeContext, 
                    pcbChallengeData, 
                    pChallengeData, 
                    &status
                );

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSAllocateConcurrentLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR szHydraServer,
    /* [in] */ LICENSE_REQUEST_TYPE __RPC_FAR *pRequest,
    /* [ref][out][in] */ LONG __RPC_FAR *dwQuantity
    )
/*

Description:
    Allocate concurrent licenses base on product.

Arguments:
    IN phContext - client context handle
    IN szHydraServer - name of hydra server requesting concurrent licenses
    IN pRequest - product to request for concurrent license.
    IN OUT dwQuantity - See note

Return Value:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_NO_PRODUCT        request product not installed
    LSERVER_E_NO_LICNESE        no available license for request product 
    LSERVER_E_LICENSE_REVOKED   Request license has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    dwQuantity
    Input                       Output
    -------------------------   -----------------------------------------
    0                           Total number of concurrent license 
                                issued to hydra server.
    > 0, number of license      Actual number of license allocated
         requested
    < 0, number of license      Actual number of license returned, always
         to return              positive value.

*/
{
    DWORD status=ERROR_SUCCESS;
    TLSLICENSEREQUEST RpcRequest;

    RequestToTlsRequest(pRequest, &RpcRequest);
    TLSRpcAllocateConcurrentLicense( 
                            phContext,
                            szHydraServer,
                            &RpcRequest,
                            dwQuantity,
                            &status
                        );

    return status;
}


//+------------------------------------------------------------------------

error_status_t
LSIssueNewLicense(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ LICENSE_REQUEST_TYPE __RPC_FAR *pRequest_org,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ DWORD cbChallengeResponse,
    /* [size_is][in] */ PBYTE cbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppLicense
    )
/*

Description:
    Routine to issue new license to hydra client based on product requested, 
    it returns existing license if client already has a license and the 
    license is not expired/returned/revoked, if request product has not been 
    installed, it will issue a temporary license, if license found is temporary 
    or expired, it will tried to upgrade/re-issue a new license with latest 
    version of requested product, if the existing license is temporary and 
    no license can be issued, it returns LSERVER_E_LICENSE_EXPIRED


Arguments:
    IN phContext - client context handle.
    IN ChallengeContext - client challenge context handle, return from 
                          call LSIssuePlatformChallenge()
    IN cbChallengeResponse - size of the client's response to license server's
                             platform challenge.
    IN pbChallenge - client's response to license server's platform challenge
    OUT pcbLicense - size of return license.
    OUT ppLicense - return license, could be old license

Return Value:
    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.

*/
{
    DWORD status=ERROR_SUCCESS;
    TLSLICENSEREQUEST RpcRequest;
    RequestToTlsRequest(pRequest_org, &RpcRequest);
    
    TLSRpcRequestNewLicense(
                    phContext,
                    ChallengeContext,
                    &RpcRequest,
                    szMachineName,
                    szUserName,
                    cbChallengeResponse,
                    cbChallenge,
                    bAcceptTemporaryLicense,
                    pcbLicense,
                    ppLicense,
                    &status
                );

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSUpgradeLicense(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbOldLicense,
    /* [size_is][in] */ PBYTE pbOldLicense,
    /* [in] */ DWORD dwClientInfo,
    /* [out] */ PDWORD pcbNewLicense,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbNewLicense
    )
/*

Description:

    Update an old license.

Arguments:

    IN phContext - client context handle.
    IN cbOldLicense - size of license to be upgraded.
    IN pOldLicense - license to be upgrade.
    OUT pcbNewLicense - size of upgraded license
    OUT pNewLicense - upgraded license.

Return Value:  

    LSERVER_S_SUCCESS
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR
    LSERVER_E_INVALID_DATA      old license is invalid.
    LSERVER_E_NO_LICENSE        no available license
    LSERVER_E_NO_PRODUCT        request product not install in current server.
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_LICENSE_REJECTED  License request rejected by cert. server.
    LSERVER_E_SERVER_BUSY

Note:

    Only support upgrading temporary license to permanent license.

*/
{
    DWORD status = ERROR_SUCCESS;
    PBYTE           pbEncodedCert=NULL;
    DWORD           cbEncodedCert=0;
    BOOL            bTemporaryLicense; 

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD dwNumLicensedProduct=0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : LSUpgradeLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    do {
        if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
        {
            status = TLS_E_ACCESS_DENIED;
            break;
        }

        if(CanIssuePermLicense() == FALSE)
        {
            // no upgrade if certificate not available
            status = TLS_E_NO_CERTIFICATE;
            break;
        }
    
        //
        // convert license back to product request structure.
        //
        status=LSVerifyDecodeClientLicense(
                        pbOldLicense, 
                        cbOldLicense, 
                        g_pbSecretKey, 
                        g_cbSecretKey,
                        &dwNumLicensedProduct,
                        pLicensedProduct
                    );

        if(status != LICENSE_STATUS_OK)
        {
            break;
        }


        pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                        dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                    );
        if(pLicensedProduct == NULL)
        {
            status = GetLastError();
            break;
        }

        status=LSVerifyDecodeClientLicense(
                                pbOldLicense, 
                                cbOldLicense, 
                                g_pbSecretKey, 
                                g_cbSecretKey,
                                &dwNumLicensedProduct,
                                pLicensedProduct
                            );

        if(status != LICENSE_STATUS_OK)
        {
            break;
        }

        RPC_STATUS rpcStatus;
        TLSLICENSEREQUEST request;

        RequestToTlsRequest(&pLicensedProduct->LicensedProduct, &request);

        if( (_tcsnicmp(
                _TEXT(HYDRA_PRODUCTID_SKU),
                (LPTSTR)pLicensedProduct->LicensedProduct.pProductInfo->pbProductID,
                _tcslen(_TEXT(HYDRA_PRODUCTID_SKU)) ) == 0) || 
            (_tcsnicmp(
                TERMSERV_PRODUCTID_SKU,
                (LPTSTR)pLicensedProduct->LicensedProduct.pProductInfo->pbProductID,
                _tcslen(TERMSERV_PRODUCTID_SKU) ) == 0) )
        {
            //
            // Terminal Server client specific code
            //
            request.ProductInfo.pbProductID = (PBYTE) TERMSERV_PRODUCTID_SKU;
            request.ProductInfo.cbProductID = (DWORD) (_tcslen(TERMSERV_PRODUCTID_SKU) + 1) * sizeof(TCHAR);
            request.dwPlatformID = dwClientInfo;
        }

        rpcStatus = TLSRpcUpgradeLicense(
                            phContext,
                            &request,
                            TLSERVER_CHALLENGE_CONTEXT,
                            0,
                            NULL,
                            cbOldLicense,
                            pbOldLicense,
                            pcbNewLicense,
                            ppbNewLicense,
                            &status
                        );
    } while(FALSE);

    if( (status == LSERVER_E_NO_PRODUCT || status == LSERVER_E_NO_LICENSE)
        && (pLicensedProduct != NULL) && (pLicensedProduct->pLicensedVersion != NULL)
        && !(pLicensedProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) )
    {
        //
        // backward compatible - always returns success in the case of perm. license
        //
        *ppbNewLicense = (PBYTE)midl_user_allocate(cbOldLicense);
        if(*ppbNewLicense != NULL)
        {
            memcpy(*ppbNewLicense, pbOldLicense, cbOldLicense);
            *pcbNewLicense = cbOldLicense;
            status = ERROR_SUCCESS;
        }
        else
        {
            status = TLS_E_ALLOCATE_MEMORY;
        }
    }        

    //if(pbSaveData != NULL)
    //{
    //    pLicensedProduct->pbOrgProductID = pbSaveData;
    //    pLicensedProduct->cbOrgProductID = cbSaveData;
    //}
    
    for(DWORD index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    // midl_user_free(pOldLicense);

    #if DBG
    lpContext->m_LastCall = RPC_CALL_UPGRADELICENSE;
    #endif

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSKeyPackEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSKeyPackSearchParm lpSearchParm
    )
/*

Description:

      Function to begin enumerate through all key pack installed on server
      based on search criterial.

Arguments:
    IN phContext - client context handle.
    IN dwSearchParm - search criterial.
    IN bMatchAll - match all search criterial.
    IN lpSearchParm - search parameter.

Return Value:  
    LSERVER_S_SUCCESS
    LSERVER_E_SERVER_BUSY       Server is too busy to process request
    LSERVER_E_OUTOFMEMORY
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR    
    LSERVER_E_INVALID_DATA      Invalid data in search parameter
    LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, likely, previous
                                enumeration has not ended.

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackEnumBegin(
                phContext,
                dwSearchParm,
                bMatchAll,
                lpSearchParm,
                &status
            );

    return status;
}

//+------------------------------------------------------------------------

DWORD 
LSKeyPackEnumNext(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSKeyPack lpKeyPack
    )
/*
Description:

    Return next key pack that match search criterial

Arguments:

    IN phContext - client context handle
    OUT lpKeyPack - key pack that match search criterial

Return Value:  
    LSERVER_S_SUCCESS
    LSERVER_I_NO_MORE_DATA      No more keypack match search criterial
    TLS_E_INTERNAL     General error in license server
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_E_SERVER_BUSY       License server is too busy to process request
    LSERVER_E_OUTOFMEMORY       Can't process request due to insufficient memory
    LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, must call
                                LSKeyPackEnumBegin().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackEnumNext(
                    phContext, 
                    lpKeyPack, 
                    &status
                );
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSKeyPackEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext 
    )
/*
Description:

    Routine to end an enumeration on key pack.

Arguments:

    IN phContext - client context handle.

Return Value:  
    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR    Internal error occurred in license server
    TLS_E_INTERNAL              General error occurred in license server
    LSERVER_E_INVALID_HANDLE    Has not call LSKeyPackEnumBegin()
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackEnumEnd(phContext, &status);
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSKeyPackAdd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ LPLSKeyPack lpKeypack
    )
/*
Description:

    Add a license key pack.

Arguments:

    IN phContext - client context handle.
    IN OUT lpKeyPack - key pack to be added.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DUPLICATE             Product already installed.
    LSERVER_E_INVALID_DATA
    LSERVER_E_CORRUPT_DATABASE

Note:

    Application must call LSKeyPackSetStatus() to activate keypack
*/
{
#if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)

    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackAdd(phContext, lpKeypack, &status);
    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}

//+------------------------------------------------------------------------

error_status_t
LSKeyPackSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParam,
    /* [ref][in] */ LPLSKeyPack lpKeyPack
    )
/*
Description:

    Routine to activate/deactivated a key pack.
  
Arguments:

    IN phContext - client context handle
    IN dwSetParam - type of key pack status to be set.
    IN lpKeyPack - new key pack status.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_INVALID_DATA     
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DATANOTFOUND      Key pack is not in server
    LSERVER_E_CORRUPT_DATABASE
*/
{
#if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)

    DWORD status=ERROR_SUCCESS;

    TLSRpcKeyPackSetStatus(
                    phContext, 
                    dwSetParam, 
                    lpKeyPack, 
                    &status
                );
    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}


//+------------------------------------------------------------------------

error_status_t
LSLicenseEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSLicenseSearchParm lpSearchParm
    )
/*
Description:

    Begin enumeration of license issued based on search criterial

Arguments:

    IN phContext - client context handle
    IN dwSearchParm - license search criterial.
    IN bMatchAll - match all search criterial
    IN lpSearchParm - license(s) to be enumerated.

Return Value:  

    Same as LSKeyPackEnumBegin().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseEnumBegin(
                    phContext,
                    dwSearchParm,
                    bMatchAll,
                    lpSearchParm,
                    &status
                );
    
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseEnumNext(  
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSLicense lpLicense
    )
/*

Description:

Arguments:

    IN phContext - client context handle
    OUT lpLicense - license match search criterial.

Return Value:  

    Same as LSKeyPackEnumNext().

*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseEnumNext(phContext, lpLicense, &status);
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext 
    )
/*
Description:

    End enumeration of issued licenses.

Arguments:

    IN phContext - client context handle.

Return Value:  

    Same as LSKeyPackEnumEnd().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseEnumEnd(phContext, &status);
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParam,
    /* [in] */ LPLSLicense lpLicense
    )
/*
Description:

    Routine to set status of a issued license.

Arguments:

    IN phContext - client context handle.
    IN dwSetParam - 
    IN lpLicense -

Return Value:  

    Same as LSKeyPackSetStatus().
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcLicenseSetStatus( 
                    phContext, 
                    dwSetParam, 
                    lpLicense, 
                    &status 
                );
    return status;
}

//+------------------------------------------------------------------------

error_status_t
LSLicenseGetCert( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][in] */ LPLSLicense lpLicense,
    /* [out] */ LPDWORD cbCert,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *pbCert
    )
/*
Description:

    Retrieve actual certificate issued to client.

Arguments:

    IN phContext - client context handle
    IN lpLicense - 
    OUT cbCert - size of certificate.
    OUT pbCert - actual certificate.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_INVALID_DATA
    LSERVER_E_DATANOTFOUND
    LSERVER_E_CORRUPT_DATABASE
*/
{
    return LSERVER_S_SUCCESS;
}

//+------------------------------------------------------------------------

error_status_t
LSGetAvailableLicenses( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [ref][in] */ LPLSKeyPack lplsKeyPack,
    /* [ref][out] */ LPDWORD lpdwAvail
    )
/*
Description:

    Retrieve number of available license for a product.

Arguments:

    IN phContext - client context.
    IN dwSearchParm - 
    IN lplsKeyPack -
    OUT lpdwAvail -

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_DATANOTFOUND
    LSERVER_E_INVALID_DATA
    LSERVER_E_CORRUPT_DATABASE
*/
{
    DWORD status=ERROR_SUCCESS;

    TLSRpcGetAvailableLicenses(
                    phContext,
                    dwSearchParm,
                    lplsKeyPack,
                    lpdwAvail,
                    &status
                );

    return status;
}

//+------------------------------------------------------------------------

error_status_t 
LSGetServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ BOOL bSignCert,
    /* [size_is][size_is][out] */ LPBYTE __RPC_FAR *ppCertBlob,
    /* [ref][out] */ LPDWORD lpdwCertBlobLen
    )
/*
Description:

    Get License Server's signature or exchange certificate

Arguments:

    IN phContext - client context.
    IN bSignCert - TRUE if signature certificate, FALSE if exchange certificate
    OUT ppCertBlob - pointer to pointer to receive certificate.
    OUT lpdwCertBlobLen - size of certificate returned.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_ACCESS_DENIED     Client doesn't have required privilege
    LSERVER_E_NO_CERTIFICATE    License Server hasn't register yet.
*/
{
#if ENFORCE_LICENSING

    DWORD status=ERROR_SUCCESS;

    TLSRpcGetServerCertificate( 
                    phContext,
                    bSignCert,
                    ppCertBlob,
                    lpdwCertBlobLen,
                    &status
                );

    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}


//+------------------------------------------------------------------------

error_status_t 
LSRegisterLicenseKeyPack(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][in] */ LPBYTE pbCHCertBlob,
    /* [in] */ DWORD cbCHCertBlobSize,
    /* [size_is][in] */ LPBYTE pbRootCertBlob,
    /* [in] */ DWORD cbRootCertBlob,
    /* [size_is][in] */ LPBYTE lpKeyPackBlob,
    /* [in] */ DWORD dwKeyPackBlobLen
    )
/*
Description:

    Register (Add) a license key pack into License Server.

Arguments:

    IN phContext - client context.
    IN pbCHCertBlob - CH's certificate.
    IN cbCHCertBlobSize - CH certificate size.
    IN pbRootCertBlob - Root's certificate.
    IN cbRootCertBlob - Size of Root's certificate.
    IN lpKeyPackBlob - pointer to encrypted license KeyPack blob.
    IN dwKeyPackBlobLen - size of keypack blob.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_ACCESS_DENIED     Client doesn't have required privilege
    LSERVER_E_NO_CERTIFICATE    License Server hasn't register yet.
    LSERVER_E_INVALID_DATA      Can't verify any of the certificate or 
                              can't decode license keypack blob.
    LSERVER_E_SERVER_BUSY       Server is busy.
    LSERVER_E_DUPLICATE         KeyPack already register
    LSERVER_E_ERROR_GENERAL     General ODBC error.
*/
{
#if ENFORCE_LICENSING

    DWORD status=ERROR_SUCCESS;

    TLSRpcRegisterLicenseKeyPack( 
                        phContext,
                        pbCHCertBlob,
                        cbCHCertBlobSize,
                        pbRootCertBlob,
                        cbRootCertBlob,
                        lpKeyPackBlob,
                        dwKeyPackBlobLen,
                        &status
                    );
    return status;
            
#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}

//+------------------------------------------------------------------------

error_status_t 
LSInstallCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertType,
    /* [in] */ DWORD dwCertLevel,
    /* [in] */ DWORD cbSignatureCert,
    /* [size_is][in] */ PBYTE pbSignatureCert,
    /* [in] */ DWORD cbExchangeCert,
    /* [size_is][in] */ PBYTE pbExchangeCert
    )
/*

Description:

    Install CH, CA, or License Server's certificate issued by CA into
    License Server.

Arguments:


RETURN:

    ACCESS_DENIED                       No privilege
    LSERVER_E_INVALID_DATA              Can't verify certificate
    LSERVER_E_DUPLICATE                 Certificate already installed
    LSERVER_I_CERTIFICATE_OVERWRITE     Overwrite certificate.

*/
{
#if ENFORCE_LICENSING

    DWORD status=ERROR_SUCCESS;

    TLSRpcInstallCertificate( 
                    phContext,
                    dwCertType,
                    dwCertLevel,
                    cbSignatureCert,
                    pbSignatureCert,
                    cbExchangeCert,
                    pbExchangeCert,
                    &status
                );

    return status;

#else

    return TLSMapReturnCode(TLS_E_NOTSUPPORTED);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\srvlist.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       srvlist.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSERVER_LIST__
#define __TLSERVER_LIST__

#include "srvdef.h"
#include "tlsapi.h"
#include "tlsdef.h"
#include "tlsstl.h"

class CTLServerInfo;
class CTLServerMgr;


typedef struct _MapSetupIdToInfo {
    //
    // Setup ID could never change unless
    // system crash
    //
    LPCTSTR pszSetupId;
} MapSetupIdToInfo;


#define TLSERVER_UNKNOWN                    0x00000000
#define TLSERVER_OLDVERSION                 0x80000000
#define TLSERVER_SUPPORTREPLICATION         0x00000010

typedef struct _TLServerInfo {
    TCHAR  m_szDomainName[LSERVER_MAX_STRING_SIZE + 2];
    TCHAR  m_szServerName[MAX_COMPUTERNAME_LENGTH + 2];
    TCHAR  m_szSetupId[MAX_JETBLUE_TEXT_LENGTH+2];

    DWORD  m_dwTLSVersion;                  // Server version
    DWORD m_dwCapability;
    DWORD m_dwPushAnnounceTimes;
    FILETIME m_dwLastSyncTime;              // Last Sync Time.

    
    //------------------------------------------------------------
    _TLServerInfo() :
    m_dwTLSVersion(0),
    m_dwCapability(TLSERVER_UNKNOWN),
    m_dwPushAnnounceTimes(0)
    {
        memset(m_szDomainName, 0, sizeof(m_szDomainName));
        memset(m_szServerName, 0, sizeof(m_szServerName));
        memset(m_szSetupId, 0, sizeof(m_szSetupId));
        memset(&m_dwLastSyncTime, 0, sizeof(FILETIME));
    }

    //-----------------------------------------------------------
    _TLServerInfo(
        IN LPCTSTR pszSetupId,
        IN LPCTSTR pszDomainName,
        IN LPCTSTR pszServerName 
        ) :

        m_dwTLSVersion(0),
        m_dwCapability(TLSERVER_UNKNOWN)
    /*++

    --*/
    {
        memset(&m_dwLastSyncTime, 0, sizeof(FILETIME));
        memset(m_szDomainName, 0, sizeof(m_szDomainName));
        memset(m_szServerName, 0, sizeof(m_szServerName));
        memset(m_szSetupId, 0, sizeof(m_szSetupId));

        lstrcpyn(
                m_szSetupId, 
                pszSetupId, 
                MAX_JETBLUE_TEXT_LENGTH + 1
            );

        lstrcpyn(
                m_szServerName, 
                pszServerName, 
                MAX_COMPUTERNAME_LENGTH + 1
            );

        lstrcpyn(
                m_szDomainName, 
                pszDomainName, 
                LSERVER_MAX_STRING_SIZE + 1
            );
    }
    //----------------------------------------------
    void
    UpdateServerName(
        IN LPCTSTR pszServerName
        )
    /*++

    Abstract:

        Update Server name.

    Parameter:

        pszServerName : new server name.

    Returns:

        None.

    Remark:

        Server ID can't be changed but server name can,
        license server doesn't announce its shutdown so 
        on next boot, user might have change the machine 
        name.

    --*/
    {
        memset(m_szServerName, 0, sizeof(m_szServerName));
        lstrcpyn(
                m_szServerName,
                pszServerName,
                MAX_COMPUTERNAME_LENGTH + 1
            );
    }

    //----------------------------------------------    
    BOOL
    IsAnnounced()
    /*++

        detemine if local server already announce 
        anything to this server.

    --*/
    {
        return m_dwPushAnnounceTimes > 0;
    }

    //----------------------------------------------
    void
    UpdateLastSyncTime(
        FILETIME* pftTime
        )
    /*++

        Update last push sync. time that is initiate 
        from local server to this server.

    --*/
    {
        m_dwLastSyncTime = *pftTime;
    }

    //----------------------------------------------
    void
    GetLastSyncTime(
        FILETIME* pftTime
        )
    /*++

        Retrieve last push sync. time that is initiate 
        from local server to this server.

    --*/
    {
        *pftTime = m_dwLastSyncTime;
    }

    //----------------------------------------------
    DWORD
    GetServerVersion()
    /*++

        Get this remote server's version information.

    --*/
    {
        return m_dwTLSVersion;
    }

    //----------------------------------------------
    DWORD
    GetServerMajorVersion() 
    /*++

        Get this remote server's major version.

    --*/
    {
        return GET_SERVER_MAJOR_VERSION(m_dwTLSVersion);
    }

    //----------------------------------------------
    DWORD
    GetServerMinorVersion() 
    /*++

        Get this remote server's minor version.

    --*/
    {
        return GET_SERVER_MINOR_VERSION(m_dwTLSVersion);
    }

    //----------------------------------------------
    BOOL
    IsServerEnterpriseServer() 
    /*++

        Check if this remote server is a enterprise server
    
    --*/
    {
        return IS_ENTERPRISE_SERVER(m_dwTLSVersion);
    }

    //----------------------------------------------
    BOOL
    IsEnforceServer()
    /*++

        Check if this remote server is a enforce license
        server.

    --*/
    {
        return IS_ENFORCE_SERVER(m_dwTLSVersion);
    }

    //----------------------------------------------
    LPTSTR
    GetServerName()  
    { 
        return m_szServerName; 
    }

    //----------------------------------------------
    LPTSTR 
    GetServerDomain()  
    {
        return m_szDomainName;
    }

    //----------------------------------------------
    LPTSTR
    GetServerId()  
    {
        return m_szSetupId;
    }

    //----------------------------------------------
    DWORD
    GetServerCapability()
    /*++

        For future version only

    --*/
    {
        DWORD dwCap;

        dwCap = m_dwCapability;

        return dwCap;
    }

    //----------------------------------------------
    BOOL
    IsServerSupportReplication() {
        return (BOOL)(m_dwCapability & TLSERVER_SUPPORTREPLICATION);
    }
} TLServerInfo, *PTLServerInfo, *LPTLServerInfo;


//---------------------------------------------------------

class CTLServerMgr {
private:
    typedef map<MapSetupIdToInfo, PTLServerInfo, less<MapSetupIdToInfo> > MapIdToInfo;

    CRWLock     m_ReadWriteLock;    // reader/writer lock on m_Handles.
    MapIdToInfo m_Handles;

    MapIdToInfo::iterator enumIterator;

public:

    CTLServerMgr();
    ~CTLServerMgr();

    //
    // Add server to list
    DWORD
    AddServerToList(
        IN LPCTSTR pszSetupId,
        IN LPCTSTR pszDomainName,
        IN LPCTSTR pszServerName
    );

    DWORD
    AddServerToList(
        IN PTLServerInfo pServerInfo
    );

    //
    // Lookup function
    DWORD
    LookupBySetupId(
        IN LPCTSTR pszSetupId,
        OUT PTLServerInfo pServerInfo
    );

    DWORD
    LookupByServerName(
        LPCTSTR pszServerName,
        OUT PTLServerInfo pServerInfo
    );

    void
    ServerListEnumBegin();

    const PTLServerInfo
    ServerListEnumNext();

    void
    ServerListEnumEnd();
};

//----------------------------------------------------------

inline bool
operator<(
    const MapSetupIdToInfo& a,
    const MapSetupIdToInfo& b
    )
/*++

++*/
{
    int iComp = _tcsicmp(a.pszSetupId, b.pszSetupId);
    return iComp < 0;
}        


#ifdef __cplusplus
extern "C" {
#endif

void
TLSBeginEnumKnownServerList();

const PTLServerInfo
TLSGetNextKnownServer();

void
TLSEndEnumKnownServerList();


DWORD
TLSAnnounceServerToRemoteServerWithHandle(
    IN DWORD dwAnnounceType,
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
);

DWORD
TLSAnnounceServerToRemoteServer(
    IN DWORD dwAnnounceType,
    IN LPTSTR pszRemoteSetupId,
    IN LPTSTR pszRemoteDomainName,
    IN LPTSTR pszRemoteServerName,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
);


TLS_HANDLE
TLSConnectAndEstablishTrust(
    IN LPTSTR pszServerName,
    IN HANDLE hHandle
);


DWORD
TLSRetrieveServerInfo(
    TLS_HANDLE hHandle,
    PTLServerInfo pServerInfo
);

DWORD
TLSLookupServerById(
    IN LPTSTR pszServerSetupId, 
    OUT LPTSTR pszServer
);

DWORD
TLSRegisterServerWithName(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName
);

DWORD
TLSRegisterServerWithHandle(
    IN TLS_HANDLE hHandle,
    OUT PTLServerInfo pServerInfo
);

DWORD
TLSRegisterServerWithServerInfo(
    IN PTLServerInfo pServerInfo
);

DWORD
TLSLookupRegisteredServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName,
    OUT PTLServerInfo pServerInfo
);

TLS_HANDLE
TLSConnectToServerWithServerId(
    LPTSTR pszServerSetupId
);

DWORD
TLSLookupAnyEnterpriseServer(
    OUT PTLServerInfo pServerInfo
);

DWORD
TLSResolveServerIdToServer(
    LPTSTR pszServerId,
    LPTSTR pszServerName
);

#ifdef __cplusplus
}
#endif

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\srvdef.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File :       srvdef.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSERVER_DEF_H__
#define __TLSERVER_DEF_H__

#include "ntverp.h"


//----------------------------------------------
// #define TLS_CURRENT_VERSION (MAKELONG(0, HIBYTE(VER_PRODUCTVERSION_W)))

//
// Bit 31 - 1 if enterprise server, 0 if domain/workgroup license server
// Bit 30 - 1 if enforce license server, 0 if non-enforce.
// Bit 29 - 1 if RTM version, 0 if beta
//
#if defined(ENFORCE_LICENSING)
#define TLS_ENFORCE_VERSION 0x4000
#else
#define TLS_ENFORCE_VERSION 0x0000
#endif

#define TLS_RTM_VERSION     0x2000

//-----------------------------------------------------------------
//
// License Server Version 
//
// 5.0 W2K license server version.
// 5.1 Add LKP replication.
// 5.2 Post W2K Beta 3 check in.
// 5.3 Turn on enforce build, TLSAPI enumeration will skip 5.2 non-enforce
// 5.4 Depends on platform challenge response from client, issue long or short cert cain
//     
#define TLS_MINOR_VERSION   0x04

#define TLS_CURRENT_VERSION (MAKELONG(MAKEWORD(TLS_MINOR_VERSION, HIBYTE(VER_PRODUCTVERSION_W)), TLS_ENFORCE_VERSION))

#define TLS_CURRENT_VERSION_RTM (MAKELONG(MAKEWORD(TLS_MINOR_VERSION, HIBYTE(VER_PRODUCTVERSION_W)), TLS_ENFORCE_VERSION | TLS_RTM_VERSION))

#define GET_SERVER_MAJOR_VERSION(version)   HIBYTE(LOWORD(version))
#define GET_SERVER_MINOR_VERSION(version)   LOBYTE(LOWORD(version))
#define IS_ENTERPRISE_SERVER(version)       ((version & TLS_VERSION_ENTERPRISE_BIT) > 0)
#define IS_ENFORCE_SERVER(version) \
    ((version & 0x40000000) > 0)


//----------------------------------------------
//
//  Service Manager Error  Code
//
//----------------------------------------------
//#define TLS_E_SERVICE_STARTUP_GENERAL       0x1
//#define TLS_E_SERVICE_STARTUP_CREATE_THREAD 0x2
//#define TLS_E_SERVICE_STARTUP_REPORT_SCM    0x3
//#define TLS_E_SERVICE_STARTUP_RPC_THREAD_ERROR  0x4
//#define TLS_E_SERVICE_STARTUP_INIT_THREAD_ERROR 0x5
//#define TLS_E_SERVICE_STARTUP_POST_INIT     0x6
//#define TLS_E_SERVICE_RPC_LISTEN            0x7
//#define TLS_E_SERVICE_LOAD_POLICY           0x8
//#define TLS_I_SERVICE_WARNING               0x9

#define SET_JB_ERROR(err)       (TLS_E_JB_BASE | abs(err))
#define IS_JB_ERROR(err)        ((err & (FACILITY_JETBLUE_BASE << 16)))

// JetBlue error code are in negative
#define GET_JB_ERROR_CODE(err)  (-((LONG)(err & ~(FACILITY_JETBLUE_BASE << 16))))

#ifndef USE_MULTIPLE_WORKSPACE

#define ALLOCATEDBHANDLE(stmt, timeout) \
    AcquireRPCExclusiveLock(timeout) \

#define FREEDBHANDLE(stmt) \
    g_DbWorkSpace->Cleanup(); \
    ReleaseRPCExclusiveLock()

#define BEGIN_TRANSACTION(stmt) \
    g_DbWorkSpace->BeginTransaction();

#define COMMIT_TRANSACTION(stmt) \
    g_DbWorkSpace->CommitTransaction();

#define ROLLBACK_TRANSACTION(stmt) \
    g_DbWorkSpace->RollbackTransaction();

#define CLEANUPSTMT \
    g_DbWorkSpace->Cleanup()

#define USEHANDLE(stmt) \
    g_DbWorkSpace

#define RPCCALL_LOCK(timeout) \
    AcquireRPCExclusiveLock(timeout)

#define RPCCALL_UNLOCK \
    ReleaseRPCExclusiveLock()

#else
//
// Not tested yet!!!
//
#define ALLOCATEDBHANDLE(pStmt, timeout) \
    pStmt = AllocateWorkSpace(timeout)

#define FREEDBHANDLE(pStmt) \
    pStmt->Cleanup(); \
    ReleaseWorkSpace(pStmt);

#define BEGIN_TRANSACTION(pStmt) \
    pStmt->BeginTransaction();

#define COMMIT_TRANSACTION(pStmt) \
    pStmt->CommitTransaction();

#define ROLLBACK_TRANSACTION(pStmt) \
    pStmt->RollbackTransaction();

#define CLEANUPSTMT \
    pStmt->Cleanup()

#define USEHANDLE(pStmt) \
    pStmt

#define RPCCALL_LOCK(timeout) \
    AcquireRPCExclusiveLock(timeout)

#define RPCCALL_UNLOCK \
    ReleaseRPCExclusiveLock()

#endif


//----------------------------------------------------------------------
//
//
#ifndef SPC_CERT_EXTENSIONS_OBJID
    #define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#endif

//---------------------------------------------------------------------------
// Server specified Registry Entry 
//
#define LSERVER_REGISTRY_BASE           _TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define LSERVER_PARAMETERS              _TEXT("Parameters")
#define LSERVER_PARAMETERS_SCOPE        _TEXT("Scope")
#define LSERVER_PARAMETERS_DBPATH       _TEXT("DBPath")        // database file
#define LSERVER_PARAMETERS_DBFILE       _TEXT("DBFile")        // database file
#define LSERVER_PARAMETERS_USER         _TEXT("User")
#define LSERVER_PARAMETERS_PWD          _TEXT("Pwd")
#define LSERVER_PARAMETERS_LOGLEVEL     _TEXT("Log Level")
#define LSERVER_PARAMETERS_CONSOLE      _TEXT("Console")
#define LSERVER_PARAMETERS_ROLE         _TEXT("Role")

#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE    _TEXT("MaxCacheSize")
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH      _TEXT("StartFlushThreshold")
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH       _TEXT("StopFlushThreshold")

#define LSERVER_PARAMETERS_LEASE_MIN    _TEXT("LeaseMinimum")
#define LSERVER_PARAMETERS_LEASE_RANGE  _TEXT("LeaseRange")
#define LSERVER_PARAMETERS_LEASE_LEEWAY _TEXT("LeaseLeeway")
#define LSERVER_PARAMETERS_EXPIRE_THREAD_SLEEP _TEXT("ExpireThreadSleep")

//
// JET_paramCacheSizeMax is expressed in pages, 
// default 4K per page.
//
#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE_DEFAULT    256
//#define LSERVER_PARAMETERS_ESENTMINCACHESIZE_DEFAULT    16
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH_DEFAULT      100
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH_DEFAULT       200

#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MAX        512
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH_MAX          100
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH_MAX           400

#define LSERVER_PARAMETERS_ESENTMAXCACHESIZE_MIN        64
#define LSERVER_PARAMETERS_ESENTSTARTFLUSH_MIN          16
#define LSERVER_PARAMETERS_ESENTSTOPFLUSH_MIN           32


//
// MaxCacheSize is set to 0xFFFFFFFF, we just let ESENT pick its number
//
#define LSERVER_PARAMETERS_USE_ESENTDEFAULT             0xFFFFFFFF

#define LSERVER_PARAMETERS_KEY \
    LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_PARAMETERS

#define LSERVER_SECRET                      _TEXT("Security")
#define LSERVER_SECRET_KEY                  _TEXT("Secret Key")
#define LSERVER_SIGNATURE_CERTIFICATE_KEY   _TEXT("Signature Certificate")
#define LSERVER_EXCHANGE_CERTIFICATE_KEY    _TEXT("Exchange Certificate")

#define LSERVER_LSA_PRIVATEKEY_SIGNATURE    _TEXT("TermServLiceningSignKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")
#define LSERVER_LSA_PRIVATEKEY_EXCHANGE     _TEXT("TermServLicensingExchKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_LSERVERID               _TEXT("TermServLicensingServerId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define TLSERVER_SERVER_ID_VERSION          0x00010001
typedef struct _TlsLsaServerId {
    DWORD dwVersion;        // structure version
    DWORD dwUniqueId;       // TLServer 5 digit unique ID
    DWORD dwServerPid;      // TLServer PID
    DWORD dwServerSPK;      // TLServer's SPK if any.
    DWORD dwExtensions;     // Size of encoded certificate entension.
    BYTE  pbVariableStart[1];   // UniqueId follow by ServerPid then ServerSPK.
} TLSLSASERVERID, *PTLSLSASERVERID, *LPTLSLSASERVERID;

//----------------------------------------------------------------------
//
// Registry key for License Server certificate issued by CA
//
//----------------------------------------------------------------------
#define LSERVER_SOFTWARE_REGBASE \
    _TEXT("SOFTWARE\\Microsoft\\") _TEXT(SZSERVICENAME)

#define LSERVER_CERTIFICATE_STORE           _TEXT("Certificates")
#define LSERVER_CERTIFICATE_STORE_BACKUP1   _TEXT("Certificates.000")
#define LSERVER_CERTIFICATE_STORE_BACKUP2   _TEXT("Certificates.001")


#define LSERVER_SELFSIGN_CERTIFICATE_REGKEY \
    LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_SECRET

#define LSERVER_SERVER_CERTIFICATE_REGKEY \
    LSERVER_SOFTWARE_REGBASE _TEXT("\\") LSERVER_CERTIFICATE_STORE

#define LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1 \
    LSERVER_PARAMETERS_KEY _TEXT("\\") LSERVER_CERTIFICATE_STORE_BACKUP1

#define LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2 \
    LSERVER_PARAMETERS_KEY _TEXT("\\") LSERVER_CERTIFICATE_STORE_BACKUP2


#define LSERVER_PARAMETERS_GRACEPERIOD      _TEXT("GracePeriod")
#define LSERVER_PARAMETERS_LOWLICENSEWARNING    _TEXT("Low License Warning")
#define LSERVER_PARAMETERS_ISSUETEMPLICENSE _TEXT("IssueTemporaryLicenses")
#define LSERVER_PARAMETERS_WORKINTERVAL     _TEXT("DefaultJobInterval")
#define LSERVER_PARAMETERS_RETRYTIMES       _TEXT("DefaultJobRetryTimes")
#define LSERVER_PARAMETERS_WORKRESTART      _TEXT("DefaultJobRestartTime")


#define LSERVER_CLIENT_CERTIFICATE_ISSUER   _TEXT("Parm0")
#define LSERVER_SIGNATURE_CERT_KEY          _TEXT("Parm1")
#define LSERVER_EXCHANGE_CERT_KEY           _TEXT("Parm2")
#define LSERVER_SIGNATURE_CERTCHAIN_KEY     _TEXT("Parm3")

#define LSERVER_POLICY_REGKEY               _TEXT("Policy")
#define LSERVER_POLICY_DLLPATH              _TEXT("Dll")
#define LSERVER_POLICY_DLLFLAG              _TEXT("Flags")


#define LSERVER_POLICY_REGBASE \
    LSERVER_SOFTWARE_REGBASE _TEXT("\\") LSERVER_POLICY_REGKEY


#define TLS_ERROR(dwErrCode) ((dwErrCode & 0xC0000000) == 0xC0000000)


//---------------------------------------------------------------------

#define MAXTCPNAME                 MAXGETHOSTSTRUCT
#define FIRSTTIME_STARTUP_REGBASE  _TEXT("Software\\Microsoft\\MSLicensing\\Startup")

//------------------------------------------------------------------------------------------------
// Hydra Specific Product SKU
//
//  236-4.00-S      Windows NT Workstation 4.0 Full Version         Non Windows and Non NT Client
//  236-4.00-VU     Windows NT Workstation 4.0 Version Upgrade      Windows NT 3.51 Client
//  236-4.00-EX     Existing Windows NT Workstation 4.0 License     Windows NT 4.0 and 5.0 Client
//
#define HYDRA_PRODUCTID_SKU         "236"
#define HYDRA_FULLVERSION_POSTFIX   "S"
#define HYDRA_UPGRADE_POSTFIX       "VU"
#define HYDRA_EXISTING              "EX"

#define HYDRAPRODUCT_FULLVERSION_SKU       _TEXT("236-4.00-S")
#define HYDRAPRODUCT_UPGRADE_SKU           _TEXT("236-4.00-VU")
#define HYDRAPRODUCT_EXISTING_SKU          _TEXT("236-4.00-EX")

//
// 236 Product ID
//
#define PLATFORMID_UPGRADE  1
#define PLATFORMID_FREE     2
#define PLATFORMID_OTHERS   0xFF

#define TERMSERV_PRODUCTID_SKU          _TEXT("A02")
#define TERMSERV_PRODUCTID_INTERNET_SKU _TEXT("B96")
#define TERMSERV_PRODUCTID_CONCURRENT_SKU  _TEXT("C50")

#define TERMSERV_FULLVERSION_TYPE   _TEXT("S")
#define TERMSERV_FREE_TYPE          _TEXT("EX")
#define TERMSERV_INTERNET_TYPE      _TEXT("I")
#define TERMSERV_CONCURRENT_TYPE    _TEXT("C")

#define TERMSERV_PRODUCTID_FORMAT   _TEXT("%3s-%ld.%02ld-%s")
#define MAX_TERMSRV_PRODUCTID       LSERVER_MAX_STRING_SIZE
#define MAX_SKU_PREFIX              10
#define MAX_SKU_POSTFIX             10


//
// Following two are info. for special key pack that 
// will be used for issuing certificate to hydra server.
//
#define HYDRAPRODUCT_HS_CERTIFICATE_SKU \
    _TEXT("3d267954-eeb7-11d1-b94e-00c04fa3080d")

#define HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID \
    _TEXT("3d267954-eeb7-11d1-b94e-00c04fa3080d")

#define HYDRACERT_PRODUCT_VERSION 0x0001000


// Windows NT Upgrade=1, Windows NT Free=2, Others=3

#define CLIENT_PLATFORMID_WINDOWS_NT_UPGRADE        1
#define CLIENT_PLATFORMID_WINDOWS_NT_FREE           2
#define CLIENT_PLATFORMID_OTHERS                    3


//---------------------------------------------------------------------------
//
// Common Define
//
#define LICENSE_MIN_MATCH               3
#define RPC_MINIMUMCALLTHREADS          1
#define RPC_MAXIMUMCALLTHREADS          RPC_C_LISTEN_MAX_CALLS_DEFAULT
#define SC_WAITHINT                     3000
#define ODBC_MAX_SQL_STRING             8196                    // max. sql string
#define DEFAULT_CONNECTION_TIMEOUT      5*60*1000      //  odbc.h
#define DB_ENUM_WAITTIMEOUT             10*1000                 // 10 second time out
                                                            // for enumeration handle
#define MAX_LICENSE_SIZE                4096

#define GRACE_PERIOD                    90         // default to 90 days

#define DEFAULT_DB_CONNECTIONS          4
#define LSERVER_PARAMETERS_DBTIMEOUT    _TEXT("Db ConnectionTimeout")
#define LSERVER_PARAMETERS_EDBTIMEOUT   _TEXT("Enum DbConnection Timeout")
#define LSERVER_PARAMETERS_MAXDBHANDLES _TEXT("Max DB Handles")

#define DB_MAX_CONNECTIONS              20
#define DB_MIN_HANDLE_NEEDED            3       // keypack enumeration uses two handle
                                                // need odd number to prevent deadlock

//---------------------------------------------------------------------------
//
// draft-ietf-pkix-ipki-part1-06.txt section 4.1.2.5.1
//  where year is greater or equal to 50, the year shall be interpreted as 19YY; and
//  where year is less than 50, the year shall be interpreted as 20YY
//
#define PERMANENT_CERT_EXPIRE_DATE  2049

//---------------------------------------------------------------------------
//
//  Internal specific not export to RPC 
//
#define LSKEYPACKSTATUS_DELETE              0xF
#define LSLICENSESTATUS_DELETE              0xF

#define LSKEYPACKSTATUS_BETA                0x10
#define LSKEYPACKSTATUS_HIDDEN              0x20
#define LSKEYPACKSTATUS_LOCAL               0x40
#define LSKEYPACKSTATUS_REMOTE              0x80
#define LSKEYPACKSTATUS_RESERVED            0xF0

#define LSKEYPACK_REMOTE_TYPE               0x80
#define LSKEYPACK_LOCAL_TYPE                0x40
#define LSKEYPACK_HIDDEN_TYPE               0x20
#define LSKEYPACK_RESERVED_TYPE             0xF0

#define LSKEYPACK_PLATFORM_REMOTE           0x80000000

//----------------------------------------------------------------------------
// 
// KeyPackDesc Table specific
//
#define KEYPACKDESC_SEARCH_NONE             0x00000000
#define KEYPACKDESC_SEARCH_ALL              0xFFFFFFFF

#define KEYPACKDESC_SET_ADD_ENTRY           0x00010000
#define KEYPACKDESC_SET_DELETE_ENTRY        0x00020000

//---------------------------------------------------------------------------

#ifndef AllocateMemory

    #define AllocateMemory(size) \
        LocalAlloc(LPTR, size)
#endif

#ifndef FreeMemory

    #define FreeMemory(ptr) \
        if(ptr)             \
        {                   \
            LocalFree(ptr); \
            ptr=NULL;       \
        }

#endif

#ifndef ReallocateMemory

    #define ReallocateMemory(ptr, size)                 \
                LocalReAlloc(ptr, size, LMEM_ZEROINIT)

#endif

#ifndef SAFESTRCPY

    #define SAFESTRCPY(dest, source) \
        _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest)/sizeof(TCHAR))); \
        dest[min(_tcslen(source), (sizeof(dest)/sizeof(TCHAR) -1))] = _TEXT('\0');

#endif

//---------------------------------------------------------------------------
//
// Return code from LSWaitForService()
// 
#define WAIT_SERVICE_UNKNOWN            0
#define WAIT_SERVICE_ERROR              1
#define WAIT_SERVICE_ALREADY_RUNNING    2
#define WAIT_SERVICE_MANUALLY_STARTED   3
#define WAIT_SERVICE_NOT_EXIST          4
#define WAIT_SERVICE_DISABLED           5
#define WAIT_SERVICE_READY              6

#define LICENSE_TABLE_EXTERN_SEARCH_MASK \
   (LSLICENSE_SEARCH_LICENSEID | LSLICENSE_SEARCH_KEYPACKID | \
    LSLICENSE_SEARCH_MACHINENAME | \
    LSLICENSE_SEARCH_USERNAME | \
    LSLICENSE_SEARCH_ISSUEDATE | LSLICENSE_SEARCH_NUMLICENSES | \
    LSLICENSE_SEARCH_EXPIREDATE | LSLICENSE_EXSEARCH_LICENSESTATUS)

//
//  The original style permanent license will never expire. The leased license
//  will expire in a random period between 52 and 89 days.
//

#define PERMANENT_LICENSE_EXPIRE_DATE   INT_MAX

//#define PERMANENT_LICENSE_LEASE_EXPIRE_MIN      (3*60) // testing: 3 min
//#define PERMANENT_LICENSE_LEASE_EXPIRE_RANGE    (60) // testing: 1 min
//#define EXPIRE_THREAD_SLEEP_TIME                (1000*60*5) /* five min */
#define PERMANENT_LICENSE_LEASE_EXPIRE_MIN      (52 * 24 * 60 * 60)
#define PERMANENT_LICENSE_LEASE_EXPIRE_RANGE    (37 * 24 * 60 * 60)
#define EXPIRE_THREAD_SLEEP_TIME                (1000*60*60*24)  /* one day */

#define TLSERVER_CHALLENGE_CONTEXT      0xFFFFFFFF
#define TLSERVER_ENTERPRISE_SERVER      0x00000001

#define DEFAULT_CSP     MS_DEF_PROV
#define PROVIDER_TYPE   PROV_RSA_FULL

#define CRYPTOINIT_ALREADY_EXIST        0x00000000
#define CRYPTOINIT_CREATE_CONTAINER     0x00000001
#define CRYPTOINIT_CREATE_SIGNKEY       0x00000002
#define CRYPTOINIT_CREATE_EXCHKEY       0x00000004

#define TLSBACKUP_EXPORT_DIR            _TEXT("Export")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\templic.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        templic.cpp
//
// Contents:    
//              all routine deal with temporary license
//
// History:     
//  Feb 4, 98      HueiWang    Created
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "templic.h"
#include "misc.h"
#include "db.h"
#include "clilic.h"
#include "keypack.h"
#include "kp.h"
#include "lkpdesc.h"

#define USSTRING_TEMPORARY _TEXT("Temporary Licenses for")

DWORD
TLSDBGetTemporaryLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT PTLSLICENSEPACK pLicensePack
);


//+-------------------------------------------------------------
DWORD 
TLSDBIssueTemporaryLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN FILETIME* pNotBefore,
    IN FILETIME* pNotAfter,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct
    )
/*++
Abstract:

    Issue a temporary license, insert a temporary license 
    pack if necessary

Parameters:

    pDbWkSpace - workspace handle.
    pRequest - license request.

Returns:


Note:

    Seperate routine for issuing perm license just in case 
    we decide to use our own format for temp. license
++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    ULARGE_INTEGER  ulSerialNumber;
    DWORD  dwLicenseId;
    LPTSTR lpRequest=NULL;
    LICENSEDCLIENT issuedLicense;
    TLSLICENSEPACK LicensePack;

    PMGENERATELICENSE PolModGenLicense;
    PPMCERTEXTENSION pPolModCertExtension=NULL;

    FILETIME notBefore, notAfter;

    // ----------------------------------------------------------
    // Issue license            
    memset(&ulSerialNumber, 0, sizeof(ulSerialNumber));

    //-----------------------------------------------------------------------------
    // this step require reduce available license by 1
    //
    long numLicense=1;

    dwStatus=TLSDBGetTemporaryLicense(
                                pDbWkSpace,
                                pRequest,
                                &LicensePack            
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if((LicensePack.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE) != LSKEYPACKTYPE_TEMPORARY && 
       (LicensePack.ucKeyPackStatus & ~LSKEYPACKSTATUS_RESERVED) != LSKEYPACKSTATUS_TEMPORARY )
    {
        SetLastError(dwStatus = TLS_E_INTERNAL);
        TLSASSERT(FALSE);
        goto cleanup;
    }
    
    // reset status
    dwStatus = ERROR_SUCCESS;
    dwLicenseId=TLSDBGetNextLicenseId();

    ulSerialNumber.LowPart = dwLicenseId;
    ulSerialNumber.HighPart = LicensePack.dwKeyPackId;

    //
    // Update License Table Here
    //
    memset(&issuedLicense, 0, sizeof(LICENSEDCLIENT));

    issuedLicense.dwLicenseId = dwLicenseId;
    issuedLicense.dwKeyPackId = LicensePack.dwKeyPackId;
    issuedLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    issuedLicense.dwNumLicenses = 1;

    if(pNotBefore == NULL || pNotAfter == NULL)
    {
        issuedLicense.ftIssueDate = time(NULL);
        issuedLicense.ftExpireDate = issuedLicense.ftIssueDate + g_GracePeriod * 24 * 60 * 60;
    }
    else
    {
        FileTimeToLicenseDate(pNotBefore, &(issuedLicense.ftIssueDate));
        FileTimeToLicenseDate(pNotAfter, &(issuedLicense.ftExpireDate));
    }

    issuedLicense.ucLicenseStatus = LSLICENSE_STATUS_TEMPORARY;

    _tcscpy(issuedLicense.szMachineName, pRequest->szMachineName);
    _tcscpy(issuedLicense.szUserName, pRequest->szUserName);

    issuedLicense.dwSystemBiosChkSum = pRequest->hWid.dwPlatformID;
    issuedLicense.dwVideoBiosChkSum = pRequest->hWid.Data1;
    issuedLicense.dwFloppyBiosChkSum = pRequest->hWid.Data2;
    issuedLicense.dwHardDiskSize = pRequest->hWid.Data3;
    issuedLicense.dwRamSize = pRequest->hWid.Data4;


    UnixTimeToFileTime(issuedLicense.ftIssueDate, &notBefore);
    UnixTimeToFileTime(issuedLicense.ftExpireDate, &notAfter);

    //
    // Inform Policy Module of license generation.
    // 

    PolModGenLicense.pLicenseRequest = pRequest->pPolicyLicenseRequest;
    PolModGenLicense.dwKeyPackType = LSKEYPACKTYPE_TEMPORARY;
    PolModGenLicense.dwKeyPackId = LicensePack.dwKeyPackId;
    PolModGenLicense.dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    PolModGenLicense.ClientLicenseSerialNumber = ulSerialNumber;
    PolModGenLicense.ftNotBefore = notBefore;
    PolModGenLicense.ftNotAfter = notAfter;

    dwStatus = pRequest->pPolicy->PMLicenseRequest( 
                                        pRequest->hClient,
                                        REQUEST_GENLICENSE,
                                        (PVOID)&PolModGenLicense,
                                        (PVOID *)&pPolModCertExtension
                                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Error in policy module
        //
        goto cleanup;
    }

    //  
    // Check error return from policy module
    //
    if(pPolModCertExtension != NULL)
    {
        if(pPolModCertExtension->pbData != NULL && pPolModCertExtension->cbData == 0 ||
           pPolModCertExtension->pbData == NULL && pPolModCertExtension->cbData != 0  )
        {
            // assuming no extension data
            pPolModCertExtension->cbData = 0;
            pPolModCertExtension->pbData = NULL;
        }

        if(CompareFileTime(&(pPolModCertExtension->ftNotBefore), &(pPolModCertExtension->ftNotAfter)) > 0)
        {
            //
            // invalid data return from policy module
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATECLIENTELICENSE,
                    dwStatus = TLS_E_POLICYMODULEERROR,
                    pRequest->pPolicy->GetCompanyName(),
                    pRequest->pPolicy->GetProductId()
                );

            goto cleanup;
        }

        //
        // do not accept changes to license expiration date
        //
        if(pNotBefore != NULL && pNotAfter != NULL)
        {
            if( FileTimeToLicenseDate(&(pPolModCertExtension->ftNotBefore), &issuedLicense.ftIssueDate) == FALSE ||
                FileTimeToLicenseDate(&(pPolModCertExtension->ftNotAfter), &issuedLicense.ftExpireDate) == FALSE )
            {
                //
                // Invalid data return from policy module
                //
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_GENERATECLIENTELICENSE,
                        dwStatus = TLS_E_POLICYMODULEERROR,
                        pRequest->pPolicy->GetCompanyName(),
                        pRequest->pPolicy->GetProductId()
                    );

                goto cleanup;
            }
        }

        notBefore = pPolModCertExtension->ftNotBefore;
        notAfter = pPolModCertExtension->ftNotAfter;
    }

    //
    // Add license into license table
    //
    dwStatus = TLSDBLicenseAdd(
                        pDbWkSpace, 
                        &issuedLicense, 
                        0,
                        NULL
                    );


    //
    // Return licensed product
    //
    pLicensedProduct->pSubjectPublicKeyInfo = NULL;
    pLicensedProduct->dwQuantity = 1;
    pLicensedProduct->ulSerialNumber = ulSerialNumber;

    pLicensedProduct->dwKeyPackId = LicensePack.dwKeyPackId;
    pLicensedProduct->dwLicenseId = dwLicenseId;
    pLicensedProduct->dwKeyPackLicenseId = LicensePack.dwNextSerialNumber;
    pLicensedProduct->ClientHwid = pRequest->hWid;
    pLicensedProduct->bTemp = TRUE;

    pLicensedProduct->NotBefore = notBefore;
    pLicensedProduct->NotAfter = notAfter;

    pLicensedProduct->dwProductVersion = MAKELONG(LicensePack.wMinorVersion, LicensePack.wMajorVersion);

    _tcscpy(pLicensedProduct->szCompanyName, LicensePack.szCompanyName);
    _tcscpy(pLicensedProduct->szLicensedProductId, LicensePack.szProductId);
    _tcscpy(pLicensedProduct->szRequestProductId, pRequest->pClientLicenseRequest->pszProductId);

    _tcscpy(pLicensedProduct->szUserName, pRequest->szUserName);
    _tcscpy(pLicensedProduct->szMachineName, pRequest->szMachineName);

    pLicensedProduct->dwLanguageID = pRequest->dwLanguageID;
    pLicensedProduct->dwPlatformID = pRequest->dwPlatformID;
    pLicensedProduct->pbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->pbData : NULL;
    pLicensedProduct->cbPolicyData = (pPolModCertExtension) ? pPolModCertExtension->cbData : 0;

cleanup:

    return dwStatus;
}


//-----------------------------------------------------------------
DWORD
TLSDBAddTemporaryKeyPack( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT LPTLSLICENSEPACK lpTmpKeyPackAdd
    )
/*++

Abstract:

    Add a temporary keypack into database.

Parameter:

    pDbWkSpace : workspace handle.
    szCompanyName :
    szProductId :
    dwVersion :
    dwPlatformId :
    dwLangId :
    lpTmpKeyPackAdd : added keypack.

Returns:

++*/
{
    DWORD  dwStatus;
    TLSLICENSEPACK LicPack;
    TLSLICENSEPACK existingLicPack;

    LICPACKDESC LicPackDesc;
    LICPACKDESC existingLicPackDesc;
    BOOL bAddDefDescription=FALSE;

    TCHAR szDefProductDesc[LSERVER_MAX_STRING_SIZE];
    int count=0;
    memset(&LicPack, 0, sizeof(TLSLICENSEPACK));
    memset(&existingLicPack, 0, sizeof(TLSLICENSEPACK));

    memset(&LicPackDesc, 0, sizeof(LICPACKDESC));
    memset(szDefProductDesc, 0, sizeof(szDefProductDesc));
    memset(&existingLicPackDesc, 0, sizeof(LICPACKDESC));

    //
    // Load product description prefix
    //
    LoadResourceString(
                    IDS_TEMPORARY_PRODUCTDESC,
                    szDefProductDesc,
                    sizeof(szDefProductDesc) / sizeof(szDefProductDesc[0])
                ); 

    LicPack.ucAgreementType = LSKEYPACKTYPE_TEMPORARY;

    _tcsncpy(
            LicPack.szCompanyName, 
            pRequest->pszCompanyName, 
            min(_tcslen(pRequest->pszCompanyName), LSERVER_MAX_STRING_SIZE)
        );

    _tcsncpy(
            LicPack.szProductId, 
            pRequest->pszProductId, 
            min(_tcslen(pRequest->pszProductId), LSERVER_MAX_STRING_SIZE)
        );

    _tcsncpy(
            LicPack.szInstallId,
            (LPTSTR)g_pszServerPid,
            min(_tcslen((LPTSTR)g_pszServerPid), LSERVER_MAX_STRING_SIZE)
        );

    _tcsncpy(
            LicPack.szTlsServerName,
            g_szComputerName,
            min(_tcslen(g_szComputerName), LSERVER_MAX_STRING_SIZE)
        );

    LicPack.wMajorVersion = HIWORD(pRequest->dwProductVersion);
    LicPack.wMinorVersion = LOWORD(pRequest->dwProductVersion);
    LicPack.dwPlatformType = pRequest->dwPlatformID;

    LicPack.ucChannelOfPurchase = LSKEYPACKCHANNELOFPURCHASE_UNKNOWN;
    LicPack.dwTotalLicenseInKeyPack = INT_MAX;

    LoadResourceString( 
                IDS_TEMPORARY_KEYPACKID,
                LicPack.szKeyPackId,
                sizeof(LicPack.szKeyPackId)/sizeof(LicPack.szKeyPackId[0])
            );

    LoadResourceString( 
                IDS_TEMPORARY_BSERIALNUMBER,
                LicPack.szBeginSerialNumber,
                sizeof(LicPack.szBeginSerialNumber)/sizeof(LicPack.szBeginSerialNumber[0])
            );

    do {
        //
        // Add entry into keypack table.
        //
        dwStatus = TLSDBKeyPackAdd(
                                pDbWkSpace, 
                                &LicPack
                            );
        *lpTmpKeyPackAdd = LicPack;

        LicPack.pbDomainSid = NULL;
        LicPack.cbDomainSid = 0;

        if(dwStatus == TLS_E_DUPLICATE_RECORD)
        {
            //
            // temporary keypack already exist
            //
            dwStatus = ERROR_SUCCESS;
            break;
        }
        else if(dwStatus != ERROR_SUCCESS)
        {
            //
            // some other error occurred
            //
            break;
        }

        //
        // Activate KeyPack
        // 
        LicPack.ucKeyPackStatus = LSKEYPACKSTATUS_TEMPORARY;
        LicPack.dwActivateDate = (DWORD) time(NULL);
        LicPack.dwExpirationDate = INT_MAX;
        LicPack.dwNumberOfLicenses = 0;

        dwStatus=TLSDBKeyPackSetValues(
                            pDbWkSpace,
                            FALSE,
                            LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_KEYPACKSTATUS | 
                                LSKEYPACK_SET_EXPIREDATE | LSKEYPACK_EXSEARCH_AVAILABLE,
                            &LicPack
                        );

        bAddDefDescription = TRUE;

        //
        // Find existing keypack description
        //
        dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                TRUE,
                                LSKEYPACK_SEARCH_PRODUCTID | LSKEYPACK_SEARCH_COMPANYNAME | LSKEYPACK_SEARCH_PLATFORMTYPE,
                                &LicPack
                            );

        if(dwStatus != ERROR_SUCCESS)
            break;

        do {
            dwStatus = TLSDBKeyPackEnumNext(    
                                    pDbWkSpace, 
                                    &existingLicPack
                                );

            if(existingLicPack.dwKeyPackId != LicPack.dwKeyPackId)
            {
                break;
            }

        } while(dwStatus == ERROR_SUCCESS);

        TLSDBKeyPackEnumEnd(pDbWkSpace);

        if(dwStatus != ERROR_SUCCESS || existingLicPack.dwKeyPackId != LicPack.dwKeyPackId)
        {   
            break;
        }

        //
        // Copy existing keypack description into keypack description table
        //
        existingLicPackDesc.dwKeyPackId = existingLicPack.dwKeyPackId;
        dwStatus = TLSDBKeyPackDescEnumBegin(
                                    pDbWkSpace,
                                    TRUE, 
                                    LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID, 
                                    &existingLicPackDesc
                                );
        while(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSDBKeyPackDescEnumNext(
                                        pDbWkSpace, 
                                        &existingLicPackDesc
                                    );
            if(dwStatus != ERROR_SUCCESS)
                break;

            LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
            LicPackDesc.dwLanguageId = existingLicPackDesc.dwLanguageId;
            _tcscpy(LicPackDesc.szCompanyName, existingLicPackDesc.szCompanyName);
            _tcscpy(LicPackDesc.szProductName, existingLicPackDesc.szProductName);

            //
            // pretty format the description
            //
            _sntprintf(
                    LicPackDesc.szProductDesc, 
                    sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                    _TEXT("%s %s"), 
                    (existingLicPackDesc.dwLanguageId != GetSystemDefaultLangID()) ? USSTRING_TEMPORARY : szDefProductDesc, 
                    existingLicPackDesc.szProductDesc
                );

            // quick and dirty fix,
            //
            // TODO - need to do a duplicate table then use the duplicate handle to 
            // insert the record, SetValue uses enumeration to verify if record exist 
            // which fail because we are already in enumeration
            //
            if(pDbWkSpace->m_LicPackDescTable.InsertRecord(LicPackDesc) != TRUE)
            {
                SetLastError(dwStatus = SET_JB_ERROR(pDbWkSpace->m_LicPackDescTable.GetLastJetError()));
                break;
            }
                                        
            //dwStatus = TLSDBKeyPackDescSetValue(
            //                            pDbWkSpace,
            //                            KEYPACKDESC_SET_ADD_ENTRY, 
            //                            &keyPackDesc
            //                        );
            count++;
        }

        if(count != 0)
        {
            bAddDefDescription = FALSE;
        }

        if(dwStatus == TLS_I_NO_MORE_DATA)
        {
            dwStatus = ERROR_SUCCESS;
        }
    } while(FALSE);


    if(bAddDefDescription)
    {
        //
        // ask policy module if they have description
        //
        PMKEYPACKDESCREQ kpDescReq;
        PPMKEYPACKDESC pKpDesc;

        //
        // Ask for English description
        //
        kpDescReq.pszProductId = pRequest->pszProductId;
        kpDescReq.dwLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        kpDescReq.dwVersion = pRequest->dwProductVersion;
        pKpDesc = NULL;

        dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                pRequest->hClient,
                                                REQUEST_KEYPACKDESC,
                                                (PVOID)&kpDescReq,
                                                (PVOID *)&pKpDesc
                                            );

        if(dwStatus == ERROR_SUCCESS && pKpDesc != NULL)
        {
            LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
            LicPackDesc.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            _tcscpy(LicPackDesc.szCompanyName, pKpDesc->szCompanyName);
            _tcscpy(LicPackDesc.szProductName, pKpDesc->szProductName);

            //
            // pretty format the description
            //
            _sntprintf(
                    LicPackDesc.szProductDesc, 
                    sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                    _TEXT("%s %s"), 
                    USSTRING_TEMPORARY, // US langid, don't use localized one
                    pKpDesc->szProductDesc
                );

            //
            // Ignore error
            //
            dwStatus = TLSDBKeyPackDescAddEntry(
                                pDbWkSpace, 
                                &LicPackDesc
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                bAddDefDescription = FALSE;
            }
        }

        if(GetSystemDefaultLangID() != kpDescReq.dwLangId)
        {
            //
            // Get System default language id
            //
            kpDescReq.pszProductId = pRequest->pszProductId;
            kpDescReq.dwLangId = GetSystemDefaultLangID();
            kpDescReq.dwVersion = pRequest->dwProductVersion;
            pKpDesc = NULL;

            dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                                    pRequest->hClient,
                                                    REQUEST_KEYPACKDESC,
                                                    (PVOID)&kpDescReq,
                                                    (PVOID *)&pKpDesc
                                                );

            if(dwStatus == ERROR_SUCCESS && pKpDesc != NULL)
            {
                LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
                LicPackDesc.dwLanguageId = GetSystemDefaultLangID();
                _tcscpy(LicPackDesc.szCompanyName, pKpDesc->szCompanyName);
                _tcscpy(LicPackDesc.szProductName, pKpDesc->szProductName);

                //
                // pretty format the description
                //
                _sntprintf(
                        LicPackDesc.szProductDesc, 
                        sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                        _TEXT("%s %s"), 
                        szDefProductDesc, 
                        pKpDesc->szProductDesc
                    );

                //
                // Ignore error
                //
                dwStatus = TLSDBKeyPackDescAddEntry(
                                    pDbWkSpace, 
                                    &LicPackDesc
                                );

                if(dwStatus == ERROR_SUCCESS)
                {
                    bAddDefDescription = FALSE;
                }
            }
        }
    }
     
    if(bAddDefDescription)
    {
        //
        // No existing keypack description, add predefined product description
        // "temporary license for <product ID>"
        //
        LicPackDesc.dwKeyPackId = LicPack.dwKeyPackId;
        _tcscpy(LicPackDesc.szCompanyName, LicPack.szCompanyName);
        _tcscpy(LicPackDesc.szProductName, LicPackDesc.szProductDesc);
        LicPackDesc.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        _sntprintf(LicPackDesc.szProductDesc, 
                   sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                   _TEXT("%s %s"), 
                   USSTRING_TEMPORARY, 
                   pRequest->pszProductId);

        dwStatus = TLSDBKeyPackDescAddEntry(
                                        pDbWkSpace, 
                                        &LicPackDesc
                                    );

        if(GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
        {
            LicPackDesc.dwLanguageId = GetSystemDefaultLangID();
            _sntprintf(LicPackDesc.szProductDesc, 
                       sizeof(LicPackDesc.szProductDesc)/sizeof(LicPackDesc.szProductDesc[0])-1,
                       _TEXT("%s %s"), 
                       szDefProductDesc, 
                       pRequest->pszProductId);

            dwStatus = TLSDBKeyPackDescAddEntry(
                                            pDbWkSpace, 
                                            &LicPackDesc
                                        );
        }
    }                            

    return dwStatus;
}

                         
//++----------------------------------------------------------
DWORD
TLSDBGetTemporaryLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT PTLSLICENSEPACK pLicensePack
    )
/*++

Abstract:

    Allocate a temporary license from temporary license pack.

Parameter:

    pDbWkSpace : workspace handle.
    pRequest : Product to request license from.
    lpdwKeyPackId : return keypack ID that license is allocated from.
    lpdwKeyPackLicenseId : license ID for the keypack.
    lpdwExpirationDate : expiration date of license pack.
    lpucKeyPackStatus : status of keypack.
    lpucKeyPackType : type of keypack, always temporary.

Returns:

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    DWORD dump;
    TLSLICENSEPACK LicenseKeyPack;
    TLSDBLicenseAllocation allocated;
    TLSDBAllocateRequest AllocateRequest;
    BOOL bAcceptTemp=TRUE;

    LicenseKeyPack.pbDomainSid = NULL;

    //
    // Tell policy module we are about to allocate a license from temporary
    // license pack
    //
    dwStatus = pRequest->pPolicy->PMLicenseRequest(
                                            pRequest->hClient,
                                            REQUEST_TEMPORARY,
                                            NULL,
                                            (PVOID *)&bAcceptTemp
                                        );

    //
    // Policy Module error
    //
    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus; 
    }

    //
    // Policy module does not accept temporary license
    //
    if(bAcceptTemp == FALSE)
    {
        return dwStatus = TLS_I_POLICYMODULETEMPORARYLICENSE;
    }

    AllocateRequest.ucAgreementType = LSKEYPACKTYPE_TEMPORARY;
    AllocateRequest.szCompanyName = (LPTSTR)pRequest->pszCompanyName;
    AllocateRequest.szProductId = (LPTSTR)pRequest->pszProductId;
    AllocateRequest.dwVersion = pRequest->dwProductVersion;
    AllocateRequest.dwPlatformId = pRequest->dwPlatformID;
    AllocateRequest.dwLangId = pRequest->dwLanguageID;
    AllocateRequest.dwNumLicenses = 1;
    AllocateRequest.dwScheme = ALLOCATE_ANY_GREATER_VERSION;
    memset(&allocated, 0, sizeof(allocated));

    allocated.dwBufSize = 1;
    allocated.pdwAllocationVector = &dump;
    allocated.lpAllocateKeyPack = &LicenseKeyPack;

    dwStatus = TLSDBAddTemporaryKeyPack(
                            pDbWkSpace,
                            pRequest,
                            &LicenseKeyPack
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        allocated.dwBufSize = 1;
        dwStatus = AllocateLicensesFromDB(
                                pDbWkSpace,
                                &AllocateRequest,
                                TRUE,   // fCheckAgreementType
                                &allocated
                            );
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        *pLicensePack = LicenseKeyPack;
    } 
    else if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        SetLastError(dwStatus = TLS_E_INTERNAL);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\srvlist.cpp ===
//+-----------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        srvlist.cpp
//
// Contents:    List of registed server
//
// History:     09-09-98    HueiWang    Created
//
//-------------------------------------------------------------
#include "pch.cpp"
#include "srvlist.h"
#include "globals.h"
#include "srvdef.h"

CTLServerMgr g_ServerMgr;

///////////////////////////////////////////////////////////////

DWORD
TLSResolveServerIdToServer(
    LPTSTR pszServerId,
    LPTSTR pszServerName
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLS_HANDLE hEServer = NULL;
    TLServerInfo EServerInfo;
    DWORD dwErrCode;

    TCHAR pbSetupId[LSERVER_MAX_STRING_SIZE+2];
    DWORD cbSetupId = LSERVER_MAX_STRING_SIZE+1;

    TCHAR pbDomainName[LSERVER_MAX_STRING_SIZE+2];
    DWORD cbDomainName = LSERVER_MAX_STRING_SIZE+1;

    TCHAR pbServerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD cbServerName = MAX_COMPUTERNAME_LENGTH+1;



    dwStatus = TLSLookupServerById(
                                pszServerId, 
                                pszServerName
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        // try to resolve server name with enterprise server
        dwStatus = TLSLookupAnyEnterpriseServer(&EServerInfo);
        if(dwStatus == ERROR_SUCCESS)
        {
            hEServer = TLSConnectAndEstablishTrust(
                                                EServerInfo.GetServerName(), 
                                                NULL
                                            );
            if(hEServer != NULL)
            {
                dwStatus = TLSLookupServer(
                                        hEServer, 
                                        pszServerId, 
                                        pbSetupId,   
                                        &cbSetupId,
                                        pbDomainName,
                                        &cbDomainName,
                                        pbServerName,
                                        &cbServerName,
                                        &dwErrCode
                                    );

                if(dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS)
                {
                    lstrcpy(pszServerName, pbServerName);
                }
            }
        }
    }



    if(hEServer != NULL)
    {
        TLSDisconnectFromServer(hEServer);
    }

    return dwStatus;
}

///////////////////////////////////////////////////////////////
DWORD
TLSAnnounceServerToRemoteServerWithHandle(
    IN DWORD dwAnnounceType,
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
    )
/*++

Abstract:

    Announce to a license server that already connected.

Parameters:

    dwAnnounceType : Announcement type, currently define are 
                     startup, and response.
    hHandle : Connection handle to remote server.
    pszLocalSetupId : Local server's setup ID.
    pszLocalDomainName : Local server's domain name.
    pszLocalServerName : Local server name.
    pftLocalLastShutdownTime : Pointer to FILETIME, local server's 
                               last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    DWORD dwErrCode;
    TLServerInfo ServerInfo;

    if(hHandle == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }


    //
    // First, try to register to server list manager.
    //
    dwStatus = TLSRegisterServerWithHandle(
                                        hHandle, 
                                        &ServerInfo
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }

    dwErrCode = LSERVER_E_LASTERROR + 1;

    //
    // RPC call to announce server
    //
    dwStatus = TLSAnnounceServer(
                            hHandle,
                            dwAnnounceType,
                            pftLocalLastShutdownTime,
                            pszLocalSetupId,
                            (pszLocalDomainName) ? _TEXT("") : pszLocalDomainName,
                            pszLocalServerName,
                            &dwErrCode
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        ServerInfo.m_dwPushAnnounceTimes++;

        //
        // Update how many time we have announce to
        // this server.
        TLSRegisterServerWithServerInfo(&ServerInfo);
    }

    if(dwStatus == ERROR_SUCCESS && dwErrCode >= LSERVER_ERROR_BASE)
    {
        TLSLogEvent(
                EVENTLOG_INFORMATION_TYPE,
                TLS_E_SERVERTOSERVER,
                TLS_E_UNEXPECTED_RETURN,
                ServerInfo.GetServerName(),
                (dwErrCode < LSERVER_E_LASTERROR) ? dwErrCode : LSERVER_ERROR_BASE
            );

        SetLastError(dwStatus = dwErrCode);
    }

    return dwStatus;
}

///////////////////////////////////////////////////////////////

DWORD
TLSAnnounceServerToRemoteServer(
    IN DWORD dwAnnounceType,
    IN LPTSTR pszRemoteSetupId,
    IN LPTSTR pszRemoteDomainName,
    IN LPTSTR pszRemoteServerName,
    IN LPTSTR pszLocalSetupId,
    IN LPTSTR pszLocalDomainName,
    IN LPTSTR pszLocalServerName,
    IN FILETIME* pftLocalLastShutdownTime
    )
/*++

Abstract:

    Similar to TLSAnnounceServerToRemoteServerWithHandle() except
    we haven't have make any connection to this server yet.

Parameter:

    dwAnnounceType : Announce type.
    pszRemoteSetupId : Remote server's setup ID.
    pszRemoteDomainName : Remote server's domain.
    pszRemoteServerName : Remote server's name.
    pszLocalSetupId : Local server setup ID.
    pszLocalDomainName : Local server's domain.
    pszLocalServerName : Local server's name.
    pftLocalLastShutdownTime : Local server last shutdown time.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    TLServerInfo RemoteServer;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;

    HANDLE hHandle = NULL;

    //
    // Always try to register with local list.
    //
    dwStatus = TLSRegisterServerWithName(
                            pszRemoteSetupId,
                            pszRemoteDomainName,
                            pszRemoteServerName
                        );
    if(dwStatus != ERROR_SUCCESS && dwStatus != TLS_E_DUPLICATE_RECORD )
    {
        return dwStatus;
    }

    //
    // Query again to make sure we have it in our server list.
    //
    dwStatus = TLSLookupRegisteredServer(
                            pszRemoteSetupId,
                            pszRemoteDomainName,
                            pszRemoteServerName,
                            &RemoteServer
                        );
    if(dwStatus != ERROR_SUCCESS)
    {
        dwStatus = TLS_E_INTERNAL;
        TLSASSERT(FALSE);
        return dwStatus;
    }                            

    //
    // Establish trust with remote server.
    //
    hHandle = TLSConnectAndEstablishTrust(
                                    RemoteServer.GetServerName(), 
                                    NULL
                                );

    if(hHandle != NULL)
    {                        
        dwErrCode = LSERVER_E_LASTERROR + 1;

        //
        // Announce server
        //
        dwStatus = TLSAnnounceServer(
                                hHandle,
                                dwAnnounceType,
                                pftLocalLastShutdownTime,
                                pszLocalSetupId,
                                (pszLocalDomainName) ? _TEXT("") : pszLocalDomainName,
                                pszLocalServerName,
                                &dwErrCode
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            RemoteServer.m_dwPushAnnounceTimes++;

            // update announce time.
            TLSRegisterServerWithServerInfo(&RemoteServer);
        }

        if(dwStatus == ERROR_SUCCESS && dwErrCode >= LSERVER_ERROR_BASE)
        {
            TLSLogEvent(
                    EVENTLOG_INFORMATION_TYPE,
                    TLS_E_SERVERTOSERVER,
                    TLS_E_UNEXPECTED_RETURN,
                    RemoteServer.GetServerName(),
                    (dwErrCode <= LSERVER_E_LASTERROR) ? dwErrCode : LSERVER_ERROR_BASE
                );

            SetLastError(dwStatus = dwErrCode);
        }
    }

    if(hHandle != NULL)
    {
        TLSDisconnectFromServer(hHandle);
        hHandle = NULL;
    }

    return dwStatus;
}        

///////////////////////////////////////////////////////////////

TLS_HANDLE
TLSConnectAndEstablishTrust(
    IN LPTSTR pszServerName,
    IN HANDLE hHandle
    )
/*++

Abstract:

    Connect and establish trust with remote server.

Parameter:

    pszServerName : Name of the remote server if any.
    hHandle : Connection handle to this remote server if any.

Returns:

    Connection handle to remote server or NULL if error.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode = ERROR_SUCCESS;
    BOOL bCleanupContextHandle = FALSE;

    if(hHandle == NULL && pszServerName == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Use server name to connect
    //
    if(hHandle == NULL)
    {
        hHandle = TLSConnectToLsServer(pszServerName);

        // we make connection here so we need to cleanup
        bCleanupContextHandle = TRUE;  

        if(hHandle == NULL)
        {
            dwStatus = GetLastError();
        }
    }

    if(hHandle != NULL)
    {
        //
        // establish trust with remote server
        //
        dwStatus = TLSEstablishTrustWithServer(
                                        hHandle,
                                        g_hCryptProv,       // GLOBAL crypto provider
                                        CLIENT_TYPE_TLSERVER,
                                        &dwErrCode
                                    );

        if(dwStatus == ERROR_SUCCESS && dwErrCode >= LSERVER_ERROR_BASE)
        {
            //
            // BUGBUG : We still have lots of old license server running, 
            // ignore this error code for now.
            //
            if(dwErrCode != LSERVER_E_ACCESS_DENIED)
            {
                DWORD dwbufSize;
                TCHAR szServer[MAX_COMPUTERNAME_LENGTH + 2];
                DWORD dwCode;

                if(pszServerName == NULL)
                {
                    dwbufSize = sizeof(szServer)/sizeof(szServer[0]) - 1;
        
                    dwStatus = TLSGetServerName(
                                            hHandle,
                                            szServer,
                                            &dwbufSize,
                                            &dwCode
                                        );
                    pszServerName = szServer;
                }

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_SERVERTOSERVER,
                        TLS_E_ESTABLISHTRUST,
                        pszServerName,
                        dwErrCode
                    );
            }

            SetLastError(dwStatus = dwErrCode);
        }

        if(dwStatus != ERROR_SUCCESS && hHandle != NULL && bCleanupContextHandle == TRUE)
        {
            // only cleanup if we make the connection in this routine.
            TLSDisconnectFromServer(hHandle);
            hHandle = NULL;
        }
    }

    return (dwStatus == ERROR_SUCCESS) ? hHandle : NULL;
}

///////////////////////////////////////////////////////////////

TLS_HANDLE
TLSConnectToServerWithServerId(
    LPTSTR pszServerSetupId
    )

/*++

Abstract:

    Resolve a license server's unique ID to server name, then
    connect and establish trust relationship with the server.

Parameter:

    pszServerSetupId : Server's unique ID.

Returns:

    Server connection handle or NULL if error.    

--*/

{
    TLS_HANDLE hHandle = NULL;
    TCHAR szServer[MAX_COMPUTERNAME_LENGTH+2];

    if(TLSLookupServerById(pszServerSetupId, szServer) != ERROR_SUCCESS)
    {
        //
        // server might not be available
        //
        SetLastError(TLS_E_SERVERLOOKUP);
        goto cleanup;
    }

    hHandle = TLSConnectAndEstablishTrust(szServer, NULL);

cleanup:

    return hHandle;                        
}

///////////////////////////////////////////////////////////////

DWORD
TLSRetrieveServerInfo(
    IN TLS_HANDLE hHandle,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Retrieve server information from remote server.

Parameter:

    hHandle : Connection handle to remote server.
    pServerInfo : Pointer to TLServerInfo to receive remote
                  server's information.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    DWORD dwErrCode;
    DWORD dwBufSize;
    PBYTE pbServerPid = NULL;

    if(hHandle == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    //
    // Retrieve Server name.
    //
    dwBufSize = sizeof(pServerInfo->m_szServerName) / sizeof(pServerInfo->m_szServerName[0]);
    dwStatus = TLSGetServerName(
                            hHandle,
                            pServerInfo->m_szServerName,
                            &dwBufSize,
                            &dwErrCode
                        );

    if(dwStatus != ERROR_SUCCESS || dwErrCode != ERROR_SUCCESS)
    {
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = dwErrCode;
            goto cleanup;
        }
    }

    //
    // Retrieve server's scope, currently, server scope = domain/workgroup name
    // except in the case of enterprise server.
    //
    dwBufSize = sizeof(pServerInfo->m_szDomainName) / sizeof(pServerInfo->m_szDomainName[0]);
    dwStatus = TLSGetServerScope(
                            hHandle,
                            pServerInfo->m_szDomainName,
                            &dwBufSize,
                            &dwErrCode
                        );
    
    if(dwStatus != ERROR_SUCCESS || dwErrCode != ERROR_SUCCESS)
    {
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = dwErrCode;
            goto cleanup;
        }
    }

    //
    // Get Server's ID
    //
    dwStatus = TLSGetServerPID(
                            hHandle,
                            &dwBufSize,
                            &pbServerPid,
                            &dwErrCode
                        );
    if(dwStatus != ERROR_SUCCESS || dwErrCode != ERROR_SUCCESS)
    {
        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = dwErrCode;
            goto cleanup;
        }
    }

    if(pbServerPid == NULL || dwBufSize == 0)
    {
        // invalid return...
        // TLSASSERT(FALSE);
        
        dwStatus = ERROR_INVALID_DATA;
        goto cleanup;
    }

    memcpy(
            pServerInfo->m_szSetupId,
            pbServerPid,
            min(sizeof(pServerInfo->m_szSetupId) - sizeof(TCHAR), dwBufSize)
        );

    midl_user_free(pbServerPid);


    //
    // retrieve server version information
    //
    dwStatus = TLSGetVersion(
                        hHandle,
                        &(pServerInfo->m_dwTLSVersion)
                    );    

    if(dwStatus == ERROR_SUCCESS)
    {
        DWORD dwMajorVersion;
        DWORD dwMinorVersion;

        dwMajorVersion = GET_SERVER_MAJOR_VERSION(pServerInfo->m_dwTLSVersion);
        dwMinorVersion = GET_SERVER_MINOR_VERSION(pServerInfo->m_dwTLSVersion);
    
        if(dwMajorVersion < GET_SERVER_MAJOR_VERSION(TLS_CURRENT_VERSION))
        {
            pServerInfo->m_dwCapability = TLSERVER_OLDVERSION;
        }
        else if( dwMajorVersion >= GET_SERVER_MAJOR_VERSION(TLS_CURRENT_VERSION) && 
                 dwMinorVersion < GET_SERVER_MINOR_VERSION(TLS_CURRENT_VERSION) )
        {
            pServerInfo->m_dwCapability = TLSERVER_OLDVERSION;
        }

		// version 5.1 and above
        if(dwMajorVersion >= 0x5 && dwMinorVersion > 0)
        {
            pServerInfo->m_dwCapability |= TLSERVER_SUPPORTREPLICATION;
        }
    }

cleanup:

    return dwStatus;
}

///////////////////////////////////////////////////////////////

DWORD
TLSLookupAnyEnterpriseServer(
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Find any enterprise server in the registered server list.

Parameter:

    pServerInfo - Pointer to TLServerInfo to receive enterprise server
                  info.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    TLServerInfo* pServer = NULL;
    BOOL bFound = FALSE;

    TLSBeginEnumKnownServerList();

    while(bFound == FALSE)
    {
        pServer = TLSGetNextKnownServer();
        if(pServer == NULL)
        {
            break;
        }

        if(pServer->IsServerEnterpriseServer() == TRUE)
        {
            *pServerInfo = *pServer;
            bFound = TRUE;
        }
    }

    TLSEndEnumKnownServerList();

    return (bFound == TRUE) ? ERROR_SUCCESS : TLS_E_RECORD_NOTFOUND;
}


///////////////////////////////////////////////////////////////
//
// Various interface function to CTLServerMgr
//
///////////////////////////////////////////////////////////////

//------------------------------------------------------------
//
void
TLSBeginEnumKnownServerList()
{
    g_ServerMgr.ServerListEnumBegin();
}

//------------------------------------------------------------
//
const PTLServerInfo
TLSGetNextKnownServer()
{
    return g_ServerMgr.ServerListEnumNext();
}

//------------------------------------------------------------
//
void
TLSEndEnumKnownServerList()
{
    g_ServerMgr.ServerListEnumEnd();
}


//------------------------------------------------------------
//
DWORD
TLSLookupServerById(
    IN LPTSTR pszServerSetupId, 
    OUT LPTSTR pszServer
    )
/*++

Abstract:

    Loopup server name via server ID.

Parameter:

    pszServerSetupId : remote server's setup ID.
    pszServer : name of the server, must be MAX_COMPUTERNAMELENGTH+1.

Returns:
    
    ERROR_SUCCESS or error code.

Remark:

    Internal call, no error checking on buffer side.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    TLServerInfo ServerInfo;

    dwStatus = TLSLookupRegisteredServer(
                                    pszServerSetupId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus == ERROR_SUCCESS)
    {
        _tcscpy(pszServer, ServerInfo.GetServerName());
    }

    return dwStatus;
}        

//------------------------------------------------------------
//
DWORD
TLSRegisterServerWithName(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName
    )
/*++

Abstract:

    Register a server with local server list manager.

Parameter:

    pszSetupId : Remote server setup ID.
    pszDomainName : Remote server domain.
    pszServerName : Remote server name.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    TLS_HANDLE hHandle = NULL;
    TLServerInfo ServerInfo;
    DWORD dwStatus;

    //
    // Lookup server with local server list manager.
    //
    dwStatus = TLSLookupRegisteredServer(
                                    pszSetupId,
                                    pszDomainName,
                                    pszServerName,
                                    &ServerInfo
                                );

    if( (dwStatus == ERROR_SUCCESS && ServerInfo.GetServerVersion() != 0) )
    {
        //
        // this server already registeted
        //
        return dwStatus;
    }

    if(dwStatus != ERROR_SUCCESS && dwStatus != TLS_E_RECORD_NOTFOUND)
    {
        // Error...
        return dwStatus;
    }

    dwStatus = ERROR_SUCCESS;

    //
    // retrieve remote server information
    //
    hHandle = TLSConnectAndEstablishTrust(
                                    pszServerName,
                                    NULL
                                );
    if(hHandle != NULL)
    {
        dwStatus = TLSRetrieveServerInfo(
                                    hHandle,
                                    &ServerInfo
                                );

        if(dwStatus == ERROR_SUCCESS)
        {
            dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
        }
    }

    //
    // close conection
    //
    if(hHandle != NULL)
    {
        TLSDisconnectFromServer(hHandle);
    }

    return dwStatus;
}

//-----------------------------------------------------------
//
DWORD
TLSRegisterServerWithHandle(
    IN TLS_HANDLE hHandle,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Register a remote server with local server list manager, this
    differ from TLSRegisterServerWithName() in that it already has
    make a connection to server.

Parameter:

    hHandle - Connection handle to remote server.
    pServerInfo - return remote server's information.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus;
    TLS_HANDLE hTrustHandle;
    TLServerInfo ServerInfo;

    if(hHandle == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    //
    // Establish trust with remote server.
    //
    hTrustHandle = TLSConnectAndEstablishTrust(
                                        NULL,
                                        hHandle
                                    );
    if(hTrustHandle == NULL)
    {
        dwStatus = GetLastError();
        return dwStatus;
    }

    //
    // Retrieve remote server information.
    //
    dwStatus = TLSRetrieveServerInfo(
                                hHandle,
                                &ServerInfo
                            );

    if(dwStatus == ERROR_SUCCESS)
    {
        if(pServerInfo != NULL)
        {
            *pServerInfo = ServerInfo;
        }

        dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
    }

    return dwStatus;
}

//----------------------------------------------------------
DWORD
TLSRegisterServerWithServerInfo(
    IN PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Register a server with local server list manager.

Parameter:

    pServerInfo : remote server information.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    return g_ServerMgr.AddServerToList(pServerInfo);
}


//------------------------------------------------------------
//
DWORD
TLSLookupRegisteredServer(
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszServerName,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Look up and retrieve remote server information from local
    server list manager.

Parameter:

    pszSetupId : remote server setup ID if any.
    pszDomainName : useless parameter, ignore
    pszServerName : remote server name if any.
    pServerInfo : Pointer to TLServerInfo to receive info. about
                  remote server.

Returns:

    ERROR_SUCCESS or error code.

Remark:

    Always try to resolve server with server's setup ID first
    then server name.
                    
++*/
{
    DWORD dwStatus;

    if(pszSetupId == NULL && pszServerName == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    if(pszSetupId)
    {
        dwStatus = g_ServerMgr.LookupBySetupId(
                                            pszSetupId,
                                            pServerInfo
                                        );
    }
    else if(pszServerName)
    {    
        dwStatus = g_ServerMgr.LookupByServerName(
                                                pszServerName,
                                                pServerInfo
                                        );
    }

    return dwStatus;
}
 
///////////////////////////////////////////////////////////////
//
// class CTLServerMgr
//
///////////////////////////////////////////////////////////////
CTLServerMgr::CTLServerMgr()
{
}

//-----------------------------------------------------
CTLServerMgr::~CTLServerMgr()
{
    PTLServerInfo pServer = NULL;
    m_ReadWriteLock.Acquire(WRITER_LOCK);


    try {
        //
        // Disconnect from Server
        //
        for( MapIdToInfo::iterator it = m_Handles.begin(); 
             it != m_Handles.end(); 
             it++ )   
        {
            pServer = (*it).second;

            if(pServer != NULL)
            {
                delete pServer;
            }
        }

        m_Handles.erase(m_Handles.begin(), m_Handles.end());
    }
    catch(...)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_SRVLIST,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("CTLServerMgr::~CTLServerMgr() caused exception...\n")
            );
    }

    m_ReadWriteLock.Release(WRITER_LOCK);
}

//----------------------------------------------------
DWORD
CTLServerMgr::AddServerToList(
    IN PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Add a server into our server list.

Parameters:

    pServerInfo - Information about remote server.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    MapSetupIdToInfo findMap;
    MapIdToInfo::iterator it;

    if( pServerInfo == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }

    findMap.pszSetupId = pServerInfo->GetServerId();
    m_ReadWriteLock.Acquire(WRITER_LOCK);

    try {
        it = m_Handles.find(findMap);

        if(it == m_Handles.end())
        {    
            PTLServerInfo pServer = NULL;
            MapSetupIdToInfo serverMap;

            // make a copy of input
            pServer = new TLServerInfo;
            *pServer = *pServerInfo;
            serverMap.pszSetupId = pServer->GetServerId();

            // Insert into our list
            m_Handles[serverMap] = pServer;
        }
        else
        {
            dwStatus = TLS_E_DUPLICATE_RECORD;

            // update information
            *((*it).second) = *pServerInfo;
        }
    }
    catch( SE_Exception e ) {
        SetLastError(dwStatus = e.getSeNumber());
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_INTERNAL);
        TLSASSERT(FALSE);
    }
    
    m_ReadWriteLock.Release(WRITER_LOCK);        

    return dwStatus;
}
       

//-----------------------------------------------------
DWORD
CTLServerMgr::AddServerToList(
    IN LPCTSTR pszSetupId,
    IN LPCTSTR pszDomainName,
    IN LPCTSTR pszServerName
    )
/*++

Abstract:

    Add a server into our server list.

Parameter:

    pszSetupId : remote server's ID.
    pszDomainName : remote server's domain.
    pszServerName : remote server name.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pszSetupId == NULL || pszServerName == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }


    PTLServerInfo pServerInfo = NULL;       
    MapSetupIdToInfo serverMap;
    MapIdToInfo::iterator it;

    serverMap.pszSetupId = pszSetupId;
    m_ReadWriteLock.Acquire(WRITER_LOCK);

    try {
        it = m_Handles.find(serverMap);

        if(it == m_Handles.end())
        {    
            pServerInfo = new TLServerInfo(pszSetupId, pszDomainName, pszServerName);
            serverMap.pszSetupId = pServerInfo->GetServerId();

            // Win64 compiler error
            //m_Handles.insert( pair<MapSetupIdToInfo, PTLServerInfo>(serverMap, pServerHandle) );

            // Insert into our list
            m_Handles[serverMap] = pServerInfo;
        }
        else 
        {
            if(lstrcmpi((*it).second->GetServerName(), pszServerName) != 0)
            {
                // update server name
                (*it).second->UpdateServerName(pszServerName);
            }

            SetLastError(dwStatus = TLS_E_DUPLICATE_RECORD);
        }
    } catch( SE_Exception e ) {
        dwStatus= e.getSeNumber();
    }
    catch( ... ) {
        dwStatus = TLS_E_INTERNAL;
        TLSASSERT(FALSE);
    }

    m_ReadWriteLock.Release(WRITER_LOCK);        
    return dwStatus;
}


//-----------------------------------------------------

DWORD
CTLServerMgr::LookupBySetupId(
    IN LPCTSTR pszSetupId,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Lookup a server via its ID.

Parameters:

    pszSetupId : Remote server setup ID.
    pServerInfo : Pointer to TLServerInfo to receive
                  information about remote server.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;


    MapSetupIdToInfo serverMap;
    MapIdToInfo::iterator it;

    m_ReadWriteLock.Acquire(READER_LOCK);

    serverMap.pszSetupId = pszSetupId;
    it = m_Handles.find(serverMap);

    if(it != m_Handles.end())
    {
        *pServerInfo = *((*it).second);
    }
    else
    {
        dwStatus = TLS_E_RECORD_NOTFOUND;
    }

    m_ReadWriteLock.Release(READER_LOCK);
    return dwStatus;
}

//------------------------------------------------------

DWORD
CTLServerMgr::LookupByServerName(
    IN LPCTSTR pszServerName,
    OUT PTLServerInfo pServerInfo
    )
/*++

Abstract:

    Lookup server inforation via server name.

Parameters:

    pszServerName : Name of server.
    pServerInfo : Pointer to TLServerInfo to receive
                  information about remote server.

Returns:

    ERROR_SUCCESS or error code.

Remark:

    machine name might change from one boot to another,
    it is not reliable to query by server name.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    m_ReadWriteLock.Acquire(READER_LOCK);

    for( MapIdToInfo::iterator it = m_Handles.begin(); 
         it != m_Handles.end(); 
         it++ )   
    {
        if(_tcsicmp((*it).second->GetServerName(), pszServerName) == 0)
        {
            break;
        }
    }

    if(it != m_Handles.end())
    {
        *pServerInfo = *((*it).second);
    }
    else
    {
        dwStatus = TLS_E_RECORD_NOTFOUND;
    }

    m_ReadWriteLock.Release(READER_LOCK);
    return dwStatus;
}

//------------------------------------------------------

void
CTLServerMgr::ServerListEnumBegin()
/*++

Abstract:

    Begin a enumeration on local server list.

Parameter:

    None.

Returns:

    None.

Remark:

    This locks local server list into read only mode.

--*/
{
    m_ReadWriteLock.Acquire(READER_LOCK);

    enumIterator = m_Handles.begin();
}

//------------------------------------------------------

const PTLServerInfo
CTLServerMgr::ServerListEnumNext()
/*++

Abstract:

    Retrieve next server in local server list.

Parameter:

    None.

Returns:

    Pointer to a server information.

Remark:

    Must call ServerListEnumBegin().

--*/
{
    PTLServerInfo pServerInfo = NULL;

    if(enumIterator != m_Handles.end())
    {
        pServerInfo = (*enumIterator).second;
        enumIterator++;
    }
    
    return pServerInfo;
}

//------------------------------------------------------

void
CTLServerMgr::ServerListEnumEnd()
/*++

Abstract:

    End enumeration of local server list.

Parameter:

    None.

Returns:

    Pointer to a server information.

Remark:

    Must call ServerListEnumBegin().

--*/
{
    enumIterator = m_Handles.end();
    m_ReadWriteLock.Release(READER_LOCK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlsbkup-s.c ===
#include <tlsbkup_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\templic.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       templic.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TEMPLIC_H__
#define __TEMPLIC_H__
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD 
TLSDBIssueTemporaryLicense( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN FILETIME* pNotBefore,
    IN FILETIME* pNotAfter,
    IN OUT PTLSDBLICENSEDPRODUCT pLicensedProduct
);

DWORD
TLSDBAddTemporaryKeyPack( 
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT LPTLSLICENSEPACK lpTmpKeyPackAdd
);

DWORD
TLSDBGetTemporaryLicense(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSDBLICENSEREQUEST pRequest,
    IN OUT PTLSLICENSEPACK pLicensePack
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlsbkup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        tlsbkup.cpp
//
// Contents:    
//              Backup/restore of database
//
// History:     
//  5/28/99     Created         RobLeit
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "globals.h"
#include "init.h"

extern "C" VOID ServiceStop();

static BOOL g_fDoingBackupRestore = FALSE;
static CCriticalSection g_csBackupRestore;

////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT WINAPI
ExportTlsDatabase(
    )
/*++


--*/
{
    RPC_STATUS rpcStatus;
    HRESULT hr = S_OK;
    TCHAR szExportedDb[MAX_PATH+1];

    if (g_fDoingBackupRestore)
    {
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_csBackupRestore.Lock();

    if (g_fDoingBackupRestore)
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    // ignore all call if service is shutting down
    if( IsServiceShuttingdown() == TRUE )
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_fDoingBackupRestore = TRUE;

    // Tell RPC threads to stop handling clients

    ServiceSignalShutdown();

    // Stop listening to other RPC interfaces

    (VOID)RpcServerUnregisterIf(TermServLicensing_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    
    (VOID)RpcServerUnregisterIf(HydraLicenseService_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    // Release handles to database
    TLSPrepareForBackupRestore();

    _tcscpy(szExportedDb,g_szDatabaseDir);
    _tcscat(szExportedDb,TLSBACKUP_EXPORT_DIR);

    CreateDirectoryEx(g_szDatabaseDir,
                      szExportedDb,
                      NULL);     // Ignore errors, they'll show up in CopyFile

    _tcscat(szExportedDb, _TEXT("\\"));
    _tcscat(szExportedDb,g_szDatabaseFname);

    // Copy database file
    if (!CopyFile(g_szDatabaseFile,szExportedDb,FALSE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:

    // Restart RPC and work manager
    ServiceResetShutdownEvent();

    // Restart after backup
    hr = TLSRestartAfterBackupRestore(TRUE);
    if( ERROR_SUCCESS != hr )
    {
        // force a shutdown...
        ServiceSignalShutdown();
        ServiceStop();
    }
    else
    {

        // Begin listening again

        RpcServerRegisterIf(TermServLicensing_v1_0_s_ifspec,
                        NULL,
                        NULL);

        RpcServerRegisterIf(HydraLicenseService_v1_0_s_ifspec,
                        NULL,
                        NULL);
    }

    g_fDoingBackupRestore = FALSE;

    g_csBackupRestore.UnLock();

    return hr;
}

////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT WINAPI
ImportTlsDatabase(
    )
/*++


--*/
{
    HRESULT hr = S_OK;

    if (g_fDoingBackupRestore)
    {
        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    g_csBackupRestore.Lock();

    if (g_fDoingBackupRestore)
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    // ignore all call if service is shutting down
    if( IsServiceShuttingdown() == TRUE )
    {
        g_csBackupRestore.UnLock();

        return HRESULT_FROM_WIN32(ERROR_BUSY);
    }


    g_fDoingBackupRestore = TRUE;

    // Tell RPC threads to stop handling clients

    ServiceSignalShutdown();

    // Stop listening to other RPC interfaces

    (VOID)RpcServerUnregisterIf(TermServLicensing_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    
    (VOID)RpcServerUnregisterIf(HydraLicenseService_v1_0_s_ifspec,
                          NULL,     // UUID
                          TRUE);    // Wait for calls to complete

    TLSPrepareForBackupRestore();

    // Restart RPC
    ServiceResetShutdownEvent();

    // not restart after backup
    hr = TLSRestartAfterBackupRestore(FALSE);

    if( ERROR_SUCCESS != hr )
    {
        // force a shutdown...
        ServiceSignalShutdown();
        ServiceStop();
    }
    else
    {
        // Begin listening again

        RpcServerRegisterIf(TermServLicensing_v1_0_s_ifspec,
                        NULL,
                        NULL);

        RpcServerRegisterIf(HydraLicenseService_v1_0_s_ifspec,
                        NULL,
                        NULL);
    }

    g_fDoingBackupRestore = FALSE;

    g_csBackupRestore.UnLock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlscert.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tlscert.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSCERT_H__
#define __TLSCERT_H__

#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

    DWORD
    TLSValidateServerCertficates(
        IN HCRYPTPROV hCryptProv,
        IN HCERTSTORE hCertStore,
        IN PBYTE pbSignCert,
        IN DWORD cbSignCert,
        IN PBYTE pbExchCert,
        IN DWORD cbExchCert,
        OUT FILETIME* pftExpireTime
    );

    DWORD
    TLSDestroyCryptContext(
        HCRYPTPROV hCryptProv
    );


    DWORD
    TLSLoadSavedCryptKeyFromLsa(
        OUT PBYTE* ppbSignKey,
        OUT PDWORD pcbSignKey,
        OUT PBYTE* ppbExchKey,
        OUT PDWORD pcbExchKey
    );

    DWORD
    TLSSaveCryptKeyToLsa(
        IN PBYTE pbSignKey,
        IN DWORD cbSignKey,
        IN PBYTE pbExchKey,
        IN DWORD cbExchKey
    );

    DWORD
    TLSCryptGenerateNewKeys(
        OUT PBYTE* pbSignKey, 
        OUT DWORD* cbSignKey, 
        OUT PBYTE* pbExchKey, 
        OUT DWORD* cbExchKey
    );

    DWORD
    TLSImportSavedKey(
        IN HCRYPTPROV hCryptProv, 
        IN PBYTE      pbSignKey,
        IN DWORD      cbSignKey,
        IN PBYTE      pbExchKey,
        IN DWORD      cbExchKey,
        OUT HCRYPTKEY* pSignKey, 
        OUT HCRYPTKEY* pExchKey
    );

    DWORD
    TLSLoadSelfSignCertificates(
        IN HCRYPTPROV hCryptProv,
        IN PBYTE pbSPK,
        IN DWORD cbSPK,
        OUT PDWORD pcbSignCert, 
        OUT PBYTE* ppbSignCert, 
        OUT PDWORD pcbExchCert, 
        OUT PBYTE* ppbExchCert
    );

    DWORD
    TLSLoadCHEndosedCertificate(
        PDWORD pcbSignCert, 
        PBYTE* ppbSignCert, 
        PDWORD pcbExchCert, 
        PBYTE* ppbExchCert
    );

    DWORD 
    TLSInstallLsCertificate( 
        DWORD cbLsSignCert, 
        PBYTE pbLsSignCert, 
        DWORD cbLsExchCert, 
        PBYTE pbLsExchCert
    );

    DWORD
    TLSUninstallLsCertificate();

    DWORD
    TLSServiceInitCryptoProv(
        IN BOOL bCreateNewKey,
        IN LPCTSTR pszKeyContainer,
        OUT HCRYPTPROV* phCryptProv,
        OUT HCRYPTKEY* phSignKey,
        OUT HCRYPTKEY* phExchKey
    );

    DWORD
    TLSInitCryptoProv(
        IN LPCTSTR pszKeyContainer,
        IN PBYTE pbSignKey,
        IN DWORD cbSignKey,
        IN PBYTE pbExchKey,
        IN DWORD cbExchKey,
        OUT HCRYPTPROV* phCryptProv,
        OUT HCRYPTKEY* phSignKey,
        OUT HCRYPTKEY* phExchKey
    );

    DWORD
    TLSVerifyCertChainInMomory( 
        IN HCRYPTPROV hCryptProv,
        IN PBYTE pbData, 
        IN DWORD cbData 
    );

    DWORD
    TLSRegDeleteKey(
        IN HKEY hRegKey,
        IN LPCTSTR pszSubKey
    );


    DWORD
    TLSTreeCopyRegKey(
        IN HKEY hSourceRegKey,
        IN LPCTSTR pszSourceSubKey,
        IN HKEY hDestRegKey,
        IN LPCTSTR pszDestSubKey
    );

#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlscert.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tlscert.cpp 
//
// Contents:   Certificate routines 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "globals.h"
#include "tlscert.h"
#include "gencert.h"

#define MAX_KEY_CONTAINER_LENGTH    25


//////////////////////////////////////////////////////////////////

BOOL
VerifyCertValidity(
    IN PCCERT_CONTEXT pCertContext
    )

/*++

--*/

{
    BOOL bValid;
    FILETIME ft;

    GetSystemTimeAsFileTime(&ft);

    bValid = (CompareFileTime(
                        &ft, 
                        &(pCertContext->pCertInfo->NotAfter)
                    ) < 0);

    return bValid;
}

//////////////////////////////////////////////////////////////////

void
DeleteBadIssuerCertFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext
    )

/*++

--*/

{
    PCCERT_CONTEXT pCertIssuer = NULL;
    DWORD dwFlags;
    DWORD dwStatus;
    BOOL bExpiredCert = FALSE;

    do {
        dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hCertStore,
                                            pSubjectContext,
                                            NULL,
                                            &dwFlags
                                        );

        if(pCertIssuer == NULL)
        {
            // can't find issuer certificate
            break;
        }

        bExpiredCert = (VerifyCertValidity(pCertIssuer) == FALSE);

        if(dwFlags != 0 || bExpiredCert == TRUE)
        {
            CertDeleteCertificateFromStore(pCertIssuer);
        }
        else
        {
            break;
        }

    } while(TRUE);

    return;
}

//////////////////////////////////////////////////////////////////

PCCERT_CONTEXT
GetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN BOOL bDelBadIssuerCert
    )

/*++


--*/

{
    PCCERT_CONTEXT pCertIssuer = NULL;
    DWORD dwFlags;
    BOOL bExpiredCert = FALSE;

    SetLastError(ERROR_SUCCESS);

    do {
        dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hCertStore,
                                            pSubjectContext,
                                            pCertIssuer,
                                            &dwFlags
                                        );

        if(pCertIssuer == NULL)
        {
            // can't find issuer certificate
            break;
        }

        bExpiredCert = (VerifyCertValidity(pCertIssuer) == FALSE);

        if(dwFlags == 0 && bExpiredCert == FALSE)
        {
            //
            // find a good issuer's certificate
            //
            break;
        }

        //if(pCertIssuer != NULL)
        //{
        //    CertFreeCertificateContext(pCertIssuer);
        //}

    } while(TRUE);

    if(bDelBadIssuerCert == TRUE && pCertIssuer)
    {
        //
        // Only delete bad certificate if we can't find a good one.
        //
        DeleteBadIssuerCertFromStore(
                            hCertStore,
                            pSubjectContext
                        );
    }

    if(bExpiredCert == TRUE && pCertIssuer == NULL)
    {
        SetLastError(TLS_E_EXPIRE_CERT);
    }

    return pCertIssuer;
}            

//////////////////////////////////////////////////////////////////////////

DWORD
TLSVerifyCertChain( 
    IN HCRYPTPROV hCryptProv, 
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    OUT FILETIME* pftMinExpireTime
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertIssuer = NULL;
    PCCERT_CONTEXT pCurrentSubject;

    //
    // Increase reference count on Subject context.
    pCurrentSubject = CertDuplicateCertificateContext(
                                                pSubjectContext
                                            );

    while( TRUE )
    {
        pCertIssuer = GetIssuerCertificateFromStore(
                                            hCertStore, 
                                            pCurrentSubject,
                                            FALSE
                                        );
        if(!pCertIssuer)
        {
            // Could not find issuer's certificate or 
            // a good issuer's certificate
            dwStatus = GetLastError();
            break;
        }

        if(CompareFileTime(pftMinExpireTime, &(pCertIssuer->pCertInfo->NotAfter)) > 0)
        {
            *pftMinExpireTime = pCertIssuer->pCertInfo->NotAfter;
        }

        if(pCurrentSubject != NULL)
        {
            CertFreeCertificateContext(pCurrentSubject);
        }

        pCurrentSubject = pCertIssuer;
    }

    if(dwStatus == CRYPT_E_SELF_SIGNED)
    {
        dwStatus = ERROR_SUCCESS;
    }

    if(pCertIssuer != NULL)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

    if(pCurrentSubject != NULL)
    {
        CertFreeCertificateContext(pCurrentSubject);
    }
  
    SetLastError(dwStatus);
    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
VerifyLicenseServerCertificate(
    IN HCRYPTPROV hCryptProv,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwCertType
    )

/*++

--*/

{
    BOOL bFound=FALSE;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_EXTENSION pCertExtension=pCertInfo->rgExtension;
    PCERT_PUBLIC_KEY_INFO pbPublicKey=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSize = 0;

    //
    // Must have a CH root extension.
    //
    for(DWORD i=0; 
        i < pCertInfo->cExtension && bFound == FALSE; 
        i++, pCertExtension++)
    {
        bFound=(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_ROOT) == 0);
    }

    if(bFound == TRUE)
    {
        //
        // Public Key must be the same
        //
        dwStatus = TLSExportPublicKey(
                                hCryptProv,
                                dwCertType,
                                &dwSize,
                                &pbPublicKey
                            );

        if(dwStatus == ERROR_SUCCESS)
        {
            bFound = CertComparePublicKeyInfo(
                                        X509_ASN_ENCODING, 
                                        pbPublicKey,
                                        &(pCertContext->pCertInfo->SubjectPublicKeyInfo)
                                    );

            if(bFound == FALSE)
            {
                dwStatus = TLS_E_MISMATCHPUBLICKEY;
            }
        }
    }
    else
    {
        dwStatus = TLS_E_INVALIDLSCERT;
    }
        
    FreeMemory(pbPublicKey);
    return dwStatus;
}

//////////////////////////////////////////////////////////////////////

DWORD
TLSVerifyServerCertAndChain(
    IN HCRYPTPROV hCryptProv,
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertType,
    IN PBYTE pbCert,
    IN DWORD cbCert,
    IN OUT FILETIME* pExpiredTime
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;

    //
    // Verify License Server's own certificate
    //
    pCertContext = CertCreateCertificateContext(
                                        X509_ASN_ENCODING,
                                        pbCert,
                                        cbCert
                                    );
    if(pCertContext == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Verify License Server's certificate first
    //
    dwStatus = VerifyLicenseServerCertificate(
                                    hCryptProv,
                                    pCertContext,
                                    dwCertType
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Verify Certificate Chain
    //
    dwStatus = TLSVerifyCertChain(
                            hCryptProv,
                            hCertStore,
                            pCertContext,
                            pExpiredTime
                        );
                                  
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

cleanup:

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    return dwStatus;
}

    

//////////////////////////////////////////////////////////////////
DWORD
TLSValidateServerCertficates(
    IN HCRYPTPROV hCryptProv,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbSignCert,
    IN DWORD cbSignCert,
    IN PBYTE pbExchCert,
    IN DWORD cbExchCert,
    OUT FILETIME* pftExpireTime
    )

/*++


--*/

{
#if ENFORCE_LICENSING

    DWORD dwStatus;

    pftExpireTime->dwLowDateTime = 0xFFFFFFFF;
    pftExpireTime->dwHighDateTime = 0xFFFFFFFF;

    dwStatus = TLSVerifyServerCertAndChain(
                                    hCryptProv,
                                    hCertStore,
                                    AT_SIGNATURE,
                                    pbSignCert,
                                    cbSignCert,
                                    pftExpireTime
                                );

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        goto cleanup;
    }


    dwStatus = TLSVerifyServerCertAndChain(
                                    hCryptProv,
                                    hCertStore,
                                    AT_KEYEXCHANGE,
                                    pbExchCert,
                                    cbExchCert,
                                    pftExpireTime
                                );

cleanup:

    return dwStatus;

#else

    return ERROR_SUCCESS;

#endif
}

//////////////////////////////////////////////////////////////////

DWORD
TLSDestroyCryptContext(
    HCRYPTPROV hCryptProv
    )

/*++


--*/

{
    DWORD dwStatus;
    BOOL bSuccess;
    PBYTE pbData = NULL;
    DWORD cbData = 0;

    if(hCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Get the container name.
    // 
    bSuccess = CryptGetProvParam(
                            hCryptProv,
                            PP_CONTAINER,
                            NULL,
                            &cbData,
                            0
                        );

    if(bSuccess != FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    pbData = (PBYTE)AllocateMemory(cbData + sizeof(TCHAR));
    if(pbData == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    bSuccess = CryptGetProvParam(
                            hCryptProv,
                            PP_CONTAINER,
                            pbData,
                            &cbData,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Release the context
    //
    bSuccess = CryptReleaseContext(
                            hCryptProv,
                            0
                        );
    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Delete key set
    //
    bSuccess = CryptAcquireContext(
                        &hCryptProv, 
                        (LPCTSTR)pbData,
                        DEFAULT_CSP, 
                        PROVIDER_TYPE, 
                        CRYPT_DELETEKEYSET
                    );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }
        
cleanup:

    FreeMemory(pbData);
    return dwStatus;
}
    
//////////////////////////////////////////////////////////////////

DWORD
InitCryptoProv(
    LPCTSTR pszKeyContainer,
    HCRYPTPROV* phCryptProv
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szKeyContainer[MAX_KEY_CONTAINER_LENGTH+1];
    LPCTSTR pszContainer;

    if(pszKeyContainer == NULL)
    {
        //
        // Randomly create a key container
        //
        memset(szKeyContainer, 0, sizeof(szKeyContainer));

        _sntprintf(
                    szKeyContainer,
                    MAX_KEY_CONTAINER_LENGTH,
                    _TEXT("TlsContainer%d"),
                    GetCurrentThreadId()
                );

        pszContainer = szKeyContainer;
    }
    else
    {
        pszContainer = pszKeyContainer;
    }


    //
    // Delete the key container, ignore error here
    //
    CryptAcquireContext(
                    phCryptProv, 
                    pszContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    CRYPT_DELETEKEYSET
                );


    //
    // Re-create key container
    //
    if(!CryptAcquireContext(
                    phCryptProv, 
                    pszContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    0))
    {
        // Create default key container.
        if(!CryptAcquireContext(
                        phCryptProv, 
                        pszContainer, 
                        DEFAULT_CSP, 
                        PROVIDER_TYPE, 
                        CRYPT_NEWKEYSET)) 
        {
            dwStatus = GetLastError();
        }    
    }

    return dwStatus;
}


//////////////////////////////////////////////////////////////////

DWORD
TLSLoadSavedCryptKeyFromLsa(
    OUT PBYTE* ppbSignKey,
    OUT PDWORD pcbSignKey,
    OUT PBYTE* ppbExchKey,
    OUT PDWORD pcbExchKey
    )
/*++

++*/
{
    DWORD dwStatus;
    PBYTE pbSKey = NULL;
    DWORD cbSKey = 0;
    PBYTE pbEKey = NULL;
    DWORD cbEKey = 0;
    
    
    dwStatus = RetrieveKey(
                        LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                        &pbEKey, 
                        &cbEKey
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = RetrieveKey(
                            LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                            &pbSKey, 
                            &cbSKey
                        );
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(pbEKey != NULL)
        {
            LocalFree(pbEKey);
        }
        
        if(pbSKey != NULL)
        {
            LocalFree(pbSKey);
        }
    }
    else
    {
        *ppbSignKey = pbSKey;
        *pcbSignKey = cbEKey;

        *ppbExchKey = pbEKey;
        *pcbExchKey = cbEKey;
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

DWORD
TLSSaveCryptKeyToLsa(
    IN PBYTE pbSignKey,
    IN DWORD cbSignKey,
    IN PBYTE pbExchKey,
    IN DWORD cbExchKey
    )

/*++

--*/

{
    DWORD dwStatus;

    //
    // Save the key to LSA.
    //
    dwStatus = StoreKey(
                        LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                        pbSignKey, 
                        cbSignKey
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = StoreKey(
                            LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                            pbExchKey, 
                            cbExchKey
                        );
    }

    return dwStatus;
}


/////////////////////////////////////////////////////////////////////////////

DWORD
TLSCryptGenerateNewKeys(
    OUT PBYTE* pbSignKey, 
    OUT DWORD* cbSignKey, 
    OUT PBYTE* pbExchKey, 
    OUT DWORD* cbExchKey
    )
/*++

Abstract:

    Generate a new pair of public/private key.  First randomly create 
    a key container and use it to create new keys.

Parameters:

    *pbSignKey : Pointer to PBYTE to receive new signature key.
    *cbSignKey : Pointer to DWORD to receive size of new sign. key.
    *pbExchKey : Pointer to PBYTE to receive new exchange key.
    *cbExchKey : Pointer to DWORD to receive size of new exchange key.

Return:

    ERROR_SUCCESS or CRYPTO Error Code.

--*/
{
    TCHAR       szKeyContainer[MAX_KEY_CONTAINER_LENGTH+1];
    HCRYPTPROV  hCryptProv = NULL;
    HCRYPTKEY   hSignKey = NULL;
    HCRYPTKEY   hExchKey = NULL;
    DWORD dwStatus;

    *pbSignKey = NULL;
    *pbExchKey = NULL;

    //
    // Randomly create a key container
    //
    memset(szKeyContainer, 0, sizeof(szKeyContainer));

    _sntprintf(
                szKeyContainer,
                MAX_KEY_CONTAINER_LENGTH,
                _TEXT("TlsContainer%d"),
                GetCurrentThreadId()
            );
            
    //
    // Delete this key container, ignore error.
    //
    CryptAcquireContext(
                    &hCryptProv, 
                    szKeyContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    CRYPT_DELETEKEYSET
                );

    //
    // Open a default key container
    //
    if(!CryptAcquireContext(
                        &hCryptProv, 
                        szKeyContainer, 
                        DEFAULT_CSP, 
                        PROVIDER_TYPE, 
                        CRYPT_NEWKEYSET
                    ))
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_CRYPT_ACQUIRE_CONTEXT,
                dwStatus = GetLastError()
            );

        goto cleanup;
    }    

    //
    // Generate a signature public/private key pair
    //
    if(!CryptGetUserKey(hCryptProv, AT_SIGNATURE, &hSignKey)) 
    {
        dwStatus=GetLastError();

        if( GetLastError() != NTE_NO_KEY || 
            !CryptGenKey(hCryptProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hSignKey))
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATEKEYS,
                    TLS_E_CRYPT_CREATE_KEY,
                    dwStatus=GetLastError()
                );
            goto cleanup;
        }
    }

    dwStatus = ERROR_SUCCESS;

    //
    // export the public/private key of signature key
    //
    if( !CryptExportKey(hSignKey, NULL, PRIVATEKEYBLOB, 0, *pbSignKey, cbSignKey) && 
        GetLastError() != ERROR_MORE_DATA)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );

        goto cleanup;
    }

    *pbSignKey=(PBYTE)AllocateMemory(*cbSignKey);
    if(*pbSignKey == NULL)
    {
        TLSLogErrorEvent(TLS_E_ALLOCATE_MEMORY);
        dwStatus=GetLastError();
        goto cleanup;
    }

    if(!CryptExportKey(hSignKey, NULL, PRIVATEKEYBLOB, 0, *pbSignKey, cbSignKey))
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,    
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );

        goto cleanup;
    }

    //
    // Generate a exchange public/private key pair
    if(!CryptGetUserKey(hCryptProv, AT_KEYEXCHANGE, &hExchKey)) 
    {
        dwStatus=GetLastError();

        if( GetLastError() != NTE_NO_KEY || 
            !CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hExchKey)) 
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_GENERATEKEYS,
                    TLS_E_CRYPT_CREATE_KEY,
                    dwStatus=GetLastError()
                );
            goto cleanup;
        }
    }

    dwStatus = ERROR_SUCCESS;

    //
    // export the public/private key of exchange key
    //
    if( !CryptExportKey(hExchKey, NULL, PRIVATEKEYBLOB, 0, *pbExchKey, cbExchKey) && 
        GetLastError() != ERROR_MORE_DATA)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );
        goto cleanup;
    }

    *pbExchKey=(PBYTE)AllocateMemory(*cbExchKey);
    if(*pbExchKey == NULL)
    {
        TLSLogErrorEvent(TLS_E_ALLOCATE_MEMORY);
        dwStatus = GetLastError();
        goto cleanup;
    }

    if(!CryptExportKey(hExchKey, NULL, PRIVATEKEYBLOB, 0, *pbExchKey, cbExchKey))
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_GENERATEKEYS,
                TLS_E_EXPORT_KEY,
                dwStatus=GetLastError()
            );
        goto cleanup;
    }


cleanup:

    if(hSignKey != NULL)
    {
        CryptDestroyKey(hSignKey);
    }

    if(hExchKey != NULL)
    {
        CryptDestroyKey(hExchKey);
    }

    if(hCryptProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }

    hCryptProv=NULL;

    //
    // Delete key container and ignore error
    //
    CryptAcquireContext(
                    &hCryptProv, 
                    szKeyContainer, 
                    DEFAULT_CSP, 
                    PROVIDER_TYPE, 
                    CRYPT_DELETEKEYSET
                );

    if(dwStatus != ERROR_SUCCESS)
    {
        FreeMemory(*pbSignKey);
        FreeMemory(*pbExchKey);
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSImportSavedKey(
    IN HCRYPTPROV hCryptProv, 
    IN PBYTE      pbSignKey,
    IN DWORD      cbSignKey,
    IN PBYTE      pbExchKey,
    IN DWORD      cbExchKey,
    OUT HCRYPTKEY* pSignKey, 
    OUT HCRYPTKEY* pExchKey
    )
/*

*/
{
    DWORD status=ERROR_SUCCESS;

    if(!CryptImportKey(
                    hCryptProv, 
                    pbSignKey, 
                    cbSignKey, 
                    NULL, 
                    0, 
                    pSignKey
                ))
    {
        status = GetLastError();
        goto cleanup;
    }

    if(!CryptImportKey(
                    hCryptProv, 
                    pbExchKey, 
                    cbExchKey, 
                    NULL, 
                    0, 
                    pExchKey
                ))
    {
        status = GetLastError();
    }

cleanup:

    if(status != ERROR_SUCCESS)
    {
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_SERVICEINIT,
                TLS_E_CRYPT_IMPORT_KEY,
                status
            );
    }
    return status;    
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSLoadSelfSignCertificates(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE pbSPK,
    IN DWORD cbSPK,
    OUT PDWORD pcbSignCert, 
    OUT PBYTE* ppbSignCert, 
    OUT PDWORD pcbExchCert, 
    OUT PBYTE* ppbExchCert
    )
/*

Abstract:

    Create a self-signed signature/exchange certificate.

Parameters:

    pcbSignCert : Pointer to DWORD to receive size of sign. certificate.
    ppbSignCert : Pointer to PBYTE to receive self-signed sign. certificate.
    pcbExchCert : Pointer to DWORD to receive size of exch. certificate.
    ppbExchCert : Pointer to PBYTE to receive self-signed exch. certificate.

Returns:

    
*/
{
    DWORD status;
    DWORD dwDisposition;
    DWORD cbSign=0;
    PBYTE pbSign=NULL;
    DWORD cbExch=0;
    PBYTE pbExch=NULL;

    do {
        //
        // Create Signature and Exchange certificate
        //
        status=TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_SIGNATURE, 
                                pbSPK,
                                cbSPK,
                                0,
                                NULL,
                                &cbSign, 
                                &pbSign
                            );
        if(status != ERROR_SUCCESS)
        {
            status=TLS_E_CREATE_SELFSIGN_CERT;
            break;
        }

        status=TLSCreateSelfSignCertificate(
                                hCryptProv,
                                AT_KEYEXCHANGE, 
                                pbSPK,
                                cbSPK,
                                0,
                                NULL,
                                &cbExch, 
                                &pbExch
                            );
        if(status != ERROR_SUCCESS)
        {
            status=TLS_E_CREATE_SELFSIGN_CERT;
            break;
        }

    } while(FALSE);

    if(status == ERROR_SUCCESS)
    {
        *pcbSignCert = cbSign;
        *ppbSignCert = pbSign;
        *pcbExchCert = cbExch;
        *ppbExchCert = pbExch;
    }
    else
    {
        FreeMemory(pbExch);
        FreeMemory(pbSign);
    }

    return status;
}

////////////////////////////////////////////////////////////////

DWORD
TLSLoadCHEndosedCertificate(
    PDWORD pcbSignCert, 
    PBYTE* ppbSignCert, 
    PDWORD pcbExchCert, 
    PBYTE* ppbExchCert
    )
/*

*/
{
    LONG status;

#if ENFORCE_LICENSING

    DWORD cbSign=0;
    PBYTE pbSign=NULL;
    DWORD cbExch=0;
    PBYTE pbExch=NULL;
    
    //
    // look into registry to see if our certificate is there
    //
    HKEY hKey=NULL;
    LPTSTR lpSubkey=LSERVER_SERVER_CERTIFICATE_REGKEY;

    do {
        status=RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        lpSubkey,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                    );
        if(status != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Load Signature certificate
        //
        status = RegQueryValueEx(
                            hKey,
                            LSERVER_SIGNATURE_CERT_KEY,
                            NULL,
                            NULL,
                            NULL,
                            &cbSign
                        );

        if(status != ERROR_MORE_DATA && status != ERROR_SUCCESS)
        {
            break;
        }

        if(!(pbSign=(PBYTE)AllocateMemory(cbSign)))
        {
            status = GetLastError();
            break;
        }

        status = RegQueryValueEx(
                            hKey,
                            LSERVER_SIGNATURE_CERT_KEY,
                            NULL,
                            NULL,
                            pbSign,
                            &cbSign
                        );

        if(status != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Load Exchange certificate
        //
        status = RegQueryValueEx(
                            hKey,
                            LSERVER_EXCHANGE_CERT_KEY,
                            NULL,
                            NULL,
                            NULL,
                            &cbExch
                        );
        if(status != ERROR_MORE_DATA && status != ERROR_SUCCESS)
        {
            break;
        }

        if(!(pbExch=(PBYTE)AllocateMemory(cbExch)))
        {
            status = GetLastError();
            break;
        }

        status = RegQueryValueEx(
                            hKey,
                            LSERVER_EXCHANGE_CERT_KEY,
                            NULL,
                            NULL,
                            pbExch,
                            &cbExch
                        );
        if(status != ERROR_SUCCESS)
        {
            break;
        }
    } while(FALSE);

    //
    // Must have both certificate
    //
    if(status == ERROR_SUCCESS && pbExch && pbSign)
    {
        *pcbSignCert = cbSign;
        *ppbSignCert = pbSign;

        *pcbExchCert = cbExch;
        *ppbExchCert = pbExch;
    }
    else
    {
        FreeMemory(pbExch);
        FreeMemory(pbSign);
        status = TLS_E_NO_CERTIFICATE;
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }
#else

    //
    // Non enfoce version always return no certificate
    //
    status = TLS_E_NO_CERTIFICATE;

#endif

    return status;
}

/////////////////////////////////////////////////////////////////////////////

DWORD 
TLSInstallLsCertificate( 
    DWORD cbLsSignCert, 
    PBYTE pbLsSignCert, 
    DWORD cbLsExchCert, 
    PBYTE pbLsExchCert
    )
/*

*/
{
    HKEY hKey=NULL;
    LONG status=ERROR_SUCCESS;
    DWORD dwDisposition;
    PCCERT_CONTEXT pCertContext=NULL;
    DWORD cbNameBlob=0;
    LPTSTR pbNameBlob=NULL;

#if ENFORCE_LICENSING

    do {
        status = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            LSERVER_SERVER_CERTIFICATE_REGKEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisposition
                        );
        if(status != ERROR_SUCCESS)
        {
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_STORELSCERTIFICATE,
                    TLS_E_ACCESS_REGISTRY,
                    status
                );
            break;
        }

        if(pbLsExchCert)
        {
            status = RegSetValueEx(
                                hKey, 
                                LSERVER_EXCHANGE_CERT_KEY, 
                                0, 
                                REG_BINARY, 
                                pbLsExchCert, 
                                cbLsExchCert
                            );
            if(status != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_STORELSCERTIFICATE,
                        TLS_E_ACCESS_REGISTRY,
                        status
                    );

                break;
            }
        }


        if(pbLsSignCert)
        {
            status = RegSetValueEx(
                                hKey, 
                                LSERVER_SIGNATURE_CERT_KEY, 
                                0, 
                                REG_BINARY, 
                                pbLsSignCert, 
                                cbLsSignCert
                            );
            if(status != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_STORELSCERTIFICATE,
                        TLS_E_ACCESS_REGISTRY,
                        status
                    );

                break;
            }

            //
            // extract Subject field in exchange certificate and save i registry
            // When issuing new license, we need to use this as Issuer.
            //

            pCertContext = CertCreateCertificateContext(
                                                X509_ASN_ENCODING,
                                                pbLsSignCert,
                                                cbLsSignCert
                                            );

            cbNameBlob=CertNameToStr(
                                X509_ASN_ENCODING,
                                &pCertContext->pCertInfo->Subject,
                                CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
                                NULL,
                                0
                            );
            if(cbNameBlob)
            {
                pbNameBlob=(LPTSTR)AllocateMemory((cbNameBlob+1) * sizeof(TCHAR));
                if(pbNameBlob)
                {
                    CertNameToStr(
                            X509_ASN_ENCODING,
                            &pCertContext->pCertInfo->Subject,
                            CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
                            pbNameBlob,
                            cbNameBlob
                        );
                }
            }

            status = RegSetValueEx(
                            hKey, 
                            LSERVER_CLIENT_CERTIFICATE_ISSUER, 
                            0, 
                            REG_BINARY, 
                            (PBYTE)pbNameBlob, 
                            cbNameBlob+sizeof(TCHAR)
                        );
            if(status != ERROR_SUCCESS)
            {
                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_STORELSCERTIFICATE,
                        TLS_E_ACCESS_REGISTRY,
                        status
                    );

                break;        
            }
        }

        if(hKey)
        {
            //
            // Close registry, got error while try to load it again???
            //
            RegCloseKey(hKey);
            hKey = NULL;
        }


        //
        // Only reload certificate when we have both
        //
        if(pbLsSignCert && pbLsExchCert)
        {
            //
            // All RPC calls are blocked.
            //
            FreeMemory(g_pbSignatureEncodedCert);
            FreeMemory(g_pbExchangeEncodedCert);
            g_cbSignatureEncodedCert = 0;
            g_cbExchangeEncodedCert = 0;
            //TLSLoadServerCertificate();
        }
    } while(FALSE);

    FreeMemory(pbNameBlob);

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }
        
    if(hKey)
    {
        RegCloseKey(hKey);
    }

#endif

    return status;
}

////////////////////////////////////////////////////////////////

DWORD
TLSUninstallLsCertificate()
{
    HKEY hKey=NULL;
    DWORD status;

    status=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    LSERVER_SERVER_CERTIFICATE_REGKEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                );
    if(status == ERROR_SUCCESS)
    {
        //
        // Ignore error     
        RegDeleteValue(    
                    hKey,
                    LSERVER_SIGNATURE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_EXCHANGE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_CLIENT_CERTIFICATE_ISSUER
                );
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    //
    // Delete all certificate in registry store including all backup
    // ignore error on deleting backup store.
    //
    TLSRegDeleteKey(
                HKEY_LOCAL_MACHINE,
                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
            );

    TLSRegDeleteKey(
                HKEY_LOCAL_MACHINE,
                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
            );

    status = TLSRegDeleteKey(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_SERVER_CERTIFICATE_REGKEY
                    );

    return status;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSInitCryptoProv(
    IN LPCTSTR pszKeyContainer,
    IN PBYTE pbSignKey,
    IN DWORD cbSignKey,
    IN PBYTE pbExchKey,
    IN DWORD cbExchKey,
    OUT HCRYPTPROV* phCryptProv,
    OUT HCRYPTKEY* phSignKey,
    OUT HCRYPTKEY* phExchKey
    )
/*

Abstract:

    Routine to create a clean Crypto. Prov, generate a new pair of keys and 
    import these keys into newly created Crypt. prov.

Parameters:

    pszKeyContainer : Name of the key container.
    phCryptProv : Pointer to HCRYPTPROV to receive new handle to Crypto. prov.
    
*/
{
    DWORD dwStatus;

    if( pbSignKey == NULL || cbSignKey == NULL || 
        pbExchKey == NULL || cbExchKey == NULL ||
        phCryptProv == NULL || phSignKey == NULL ||
        phExchKey == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Initialize a clean Crypt.
        //    
        dwStatus = InitCryptoProv(
                            pszKeyContainer,
                            phCryptProv
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            //
            // Import Key into Crypt.
            //
            dwStatus = TLSImportSavedKey(
                                    *phCryptProv, 
                                    pbSignKey,
                                    cbSignKey,
                                    pbExchKey,
                                    cbExchKey,
                                    phSignKey, 
                                    phExchKey
                                );
        }
    }

    return dwStatus;
}

//-----------------------------------------------------------

DWORD
TLSVerifyCertChainInMomory( 
    IN HCRYPTPROV hCryptProv,
    IN PBYTE pbData, 
    IN DWORD cbData 
    )
/*++

Abstract:

    Verify PKCS7 certificate chain in memory.

Parameters:

    pbData : Input PKCS7 ceritifcate chain.
    cbData : size of pbData

Returns:


++*/
{
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pCertPrevContext=NULL;

    HCERTSTORE      hCertStore=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;
    DWORD           dwLastVerification;
    CRYPT_DATA_BLOB Serialized;
    FILETIME        ft;

    if(hCryptProv == NULL || pbData == NULL || cbData == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }        

    Serialized.pbData = pbData;
    Serialized.cbData = cbData;

    hCertStore=CertOpenStore(
                        szLICENSE_BLOB_SAVEAS_TYPE,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        &Serialized
                    );

    if(!hCertStore)
    {
        dwStatus=GetLastError();
        goto cleanup;
    }

    //
    // Enumerate all certificates.
    //
    dwStatus = ERROR_SUCCESS;

    do {
        pCertPrevContext = pCertContext;
        pCertContext = CertEnumCertificatesInStore(
                                            hCertStore,
                                            pCertPrevContext
                                        );

        if(pCertContext == NULL)
        {
            dwStatus = GetLastError();
            if(dwStatus = CRYPT_E_NOT_FOUND)
            {
                dwStatus = ERROR_SUCCESS;
                break;
            }
        }

        dwStatus = TLSVerifyCertChain(
                                hCryptProv,
                                hCertStore,
                                pCertContext,
                                &ft
                            );
    } while (pCertContext != NULL && dwStatus == ERROR_SUCCESS);

cleanup:

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hCertStore)
    {
        CertCloseStore(
                    hCertStore, 
                    CERT_CLOSE_STORE_FORCE_FLAG
                );
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSRegDeleteKey(
    IN HKEY hRegKey,
    IN LPCTSTR pszSubKey
    )
/*++

Abstract:

    Recursively delete entire registry key.

Parameter:

    HKEY : 
    pszSubKey :

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    DWORD dwStatus;
    HKEY hSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;


    dwStatus = RegOpenKeyEx(
                            hRegKey,
                            pszSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        return dwStatus;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,
                            &dwMaxSubKeyLength,
                            NULL,
                            NULL,
                            &dwMaxValueNameLen,
                            NULL,
                            NULL,
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwMaxValueNameLen++;
    pszValueName = (LPTSTR)AllocateMemory(dwMaxValueNameLen * sizeof(TCHAR));
    if(pszValueName == NULL)
    {
        goto cleanup;
    }

    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.

        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)AllocateMemory(dwMaxSubKeyLength * sizeof(TCHAR));
        if(pszSubKeyName == NULL)
        {
            goto cleanup;
        }


        //for(index = 0; index < dwNumSubKeys; index++)
        for(;dwStatus == ERROR_SUCCESS;)
        {
            // delete this subkey.
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSubKey,
                                (DWORD)0,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = TLSRegDeleteKey( hSubKey, pszSubKeyName );
            }

            // ignore any error and continue on
        }
    }

cleanup:

    for(dwStatus = ERROR_SUCCESS; pszValueName != NULL && dwStatus == ERROR_SUCCESS;)
    {
        dwValueNameLength = dwMaxValueNameLen;
        memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

        dwStatus = RegEnumValue(
                            hSubKey,
                            0,
                            pszValueName,
                            &dwValueNameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                        );

        if(dwStatus == ERROR_SUCCESS)
        {
            RegDeleteValue(hSubKey, pszValueName);
        }
    }   
                            
    // close the key before trying to delete it.
    if(hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    // try to delete this key, will fail if any of the subkey
    // failed to delete in loop
    dwStatus = RegDeleteKey(
                            hRegKey,
                            pszSubKey
                        );



    if(pszValueName != NULL)
    {
        FreeMemory(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        FreeMemory(pszSubKeyName);
    }

    return dwStatus;   
}    

/////////////////////////////////////////////////////////////////////////////

DWORD
TLSTreeCopyRegKey(
    IN HKEY hSourceRegKey,
    IN LPCTSTR pszSourceSubKey,
    IN HKEY hDestRegKey,
    IN LPCTSTR pszDestSubKey
    )
/*++

Abstract:

    Tree copy of a registry key to another.

Parameters:

    hSourceRegKey : Source registry key.
    pszSourceSubKey : Source subkey name.
    hDestRegKey : Destination key.
    pszDestSubKey : Destination key name

Returns:

    ERROR_SUCCESS or WIN32 error code.

Note:

    This routine doesn't deal with security...

++*/
{
    DWORD dwStatus;
    HKEY hSourceSubKey = NULL;
    HKEY hDestSubKey = NULL;
    int index;

    DWORD dwNumSubKeys;
    DWORD dwMaxSubKeyLength;
    DWORD dwSubKeyLength;
    LPTSTR pszSubKeyName = NULL;

    DWORD dwMaxValueNameLen;
    LPTSTR pszValueName = NULL;
    DWORD dwValueNameLength;
    DWORD dwNumValues = 0;
    DWORD dwMaxValueLength;
    PBYTE pbValue = NULL;

    DWORD dwDisposition;

    DWORD cbSecurityDescriptor;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;


    //
    // Open source registry key, must exist
    //
    dwStatus = RegOpenKeyEx(
                            hSourceRegKey,
                            pszSourceSubKey,
                            0,
                            KEY_ALL_ACCESS,
                            &hSourceSubKey
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        // key does not exist
        goto cleanup;
    }

    //
    // Query number of subkeys
    //
    dwStatus = RegQueryInfoKey(
                            hSourceSubKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumSubKeys,  // number of subkey
                            &dwMaxSubKeyLength, // max. subkey length
                            NULL,
                            &dwNumValues,
                            &dwMaxValueNameLen, // max. value length
                            &dwMaxValueLength,  // max. value size.
                            &cbSecurityDescriptor,  // size of security descriptor
                            NULL
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    #if 0

    //
    // TODO - get this to work, currently, we don't need security
    //
    if(cbSecurityDescriptor > 0)
    {
        //
        // Retrieve security descriptor for this key.
        //
        pSecurityDescriptor = (PSECURITY_DESCRIPTOR)AllocateMemory(cbSecurityDescriptor * sizeof(BYTE));
        if(pSecurityDescriptor == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        dwStatus = RegGetKeySecurity(
                                hSourceSubKey,
                                OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                pSecurityDescriptor,
                                &cbSecurityDescriptor
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    #endif

    //
    // Create destination key
    //
    dwStatus = RegCreateKeyEx(
                            hDestRegKey,
                            pszDestSubKey,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hDestSubKey,
                            &dwDisposition
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    #if 0
    
    //
    // TODO - get this to work, currently, we don't need security.
    //

    if(pSecurityDescriptor != NULL)
    {
        dwStatus = RegSetKeySecurity(
                                hDestRegKey,
                                OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                pSecurityDescriptor
                            );
        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        if(pSecurityDescriptor != NULL)
        {
            FreeMemory(pSecurityDescriptor);
            pSecurityDescriptor = NULL;
        }
    }

    #endif

    //
    // Copy all subkeys first, we are doing recursive so copy subkey first will
    // save us some memory.
    //  
    if(dwNumSubKeys > 0)
    {
        // allocate buffer for subkeys.
        dwMaxSubKeyLength++;
        pszSubKeyName = (LPTSTR)AllocateMemory(dwMaxSubKeyLength * sizeof(TCHAR));
        if(pszSubKeyName == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        for(index = 0, dwStatus = ERROR_SUCCESS; 
            dwStatus == ERROR_SUCCESS;
            index++)
        {
            dwSubKeyLength = dwMaxSubKeyLength;
            memset(pszSubKeyName, 0, dwMaxSubKeyLength * sizeof(TCHAR));

            // retrieve subkey name
            dwStatus = RegEnumKeyEx(
                                hSourceSubKey,
                                (DWORD)index,
                                pszSubKeyName,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = TLSTreeCopyRegKey(
                                        hSourceSubKey,
                                        pszSubKeyName,
                                        hDestSubKey,
                                        pszSubKeyName
                                    );
            }
        }

        if(dwStatus == ERROR_NO_MORE_ITEMS)
        {
            dwStatus = ERROR_SUCCESS;
        }
    }

    if(pszSubKeyName != NULL)
    {
        FreeMemory(pszSubKeyName);
        pszSubKeyName = NULL;
    }

    if(dwNumValues > 0)
    {
        //
        // allocate space for value name.
        //
        dwMaxValueNameLen++;
        pszValueName = (LPTSTR)AllocateMemory(dwMaxValueNameLen * sizeof(TCHAR));
        if(pszValueName == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // allocate buffer for value
        //
        dwMaxValueLength += 2 * sizeof(TCHAR);    // in case of string
        pbValue = (PBYTE)AllocateMemory(dwMaxValueLength * sizeof(BYTE));
        if(pbValue == NULL)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }


        // 
        // Copy all value first
        //
        for(index=0, dwStatus = ERROR_SUCCESS; 
            pszValueName != NULL && dwStatus == ERROR_SUCCESS;
            index ++)
        {
            DWORD dwValueType = 0;
            DWORD cbValue = dwMaxValueLength;

            dwValueNameLength = dwMaxValueNameLen;
            memset(pszValueName, 0, dwMaxValueNameLen * sizeof(TCHAR));

            dwStatus = RegEnumValue(
                                hSourceSubKey,
                                index,
                                pszValueName,
                                &dwValueNameLength,
                                NULL,
                                &dwValueType,
                                pbValue,
                                &cbValue
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                //
                // Copy value
                //
                dwStatus = RegSetValueEx(
                                    hDestSubKey,
                                    pszValueName,
                                    0,
                                    dwValueType,
                                    pbValue,
                                    cbValue
                                );
            }
        }

        if(dwStatus == ERROR_NO_MORE_ITEMS)
        {
            dwStatus = ERROR_SUCCESS;
        }

        if(dwStatus != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }

cleanup:
                            
    // close the key before trying to delete it.
    if(hSourceSubKey != NULL)
    {
        RegCloseKey(hSourceSubKey);
    }

    if(hDestSubKey != NULL)
    {
        RegCloseKey(hDestSubKey);
    }

    if(pszValueName != NULL)
    {
        FreeMemory(pszValueName);
    }

    if(pszSubKeyName != NULL)
    {
        FreeMemory(pszSubKeyName);
    }

    if(pbValue != NULL)
    {
        FreeMemory(pbValue);
    }

    if(pSecurityDescriptor != NULL)
    {
        FreeMemory(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    }

    return dwStatus;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlsjob.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        tlsjob.cpp
//
// Contents:    Various license server job. 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "tlsjob.h"
#include "jobmgr.h"
#include "wkstore.h"
#include "srvlist.h"
#include "kp.h"
#include "clilic.h"
#include "keypack.h"
#include "init.h"


/////////////////////////////////////////////////////////////
//
//
//
//
/////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
// Various interface into global work manager 
//////////////////////////////////////////////////////////////
CWorkManager g_WorkManager;
CPersistentWorkStorage g_WorkStorage;

#define MAX_ERROR_MSG_SIZE 1024


DWORD
TLSWorkManagerInit()
/*++

Abstract:

    Initialize work manager.

Parameter:

    None.

returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    WorkItemTable* pWkStorageTable = NULL;

    //
    // Initialize Work Storage table
    //
    pWkStorageTable = GetWorkItemStorageTable();
    if(pWkStorageTable == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Init Persistent work storage table
    //
    if(g_WorkStorage.AttachTable(pWkStorageTable) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Initialize Work Manager    
    //
    dwStatus = g_WorkManager.Startup(&g_WorkStorage);

cleanup:

    return dwStatus;
}    

//-----------------------------------------------------------
                             
void
TLSWorkManagerShutdown()
/*++

Abstract:

    Shutdown work manager.

Parameter:

    None:

Return:

    None.

--*/
{
    g_WorkManager.Shutdown();
}


//-----------------------------------------------------------

DWORD
TLSWorkManagerSchedule(
    IN DWORD dwTime,
    IN CWorkObject* pJob
    )
/*++

Abstract:

    Schedule a job to work manager.

Parameter:

    dwTime : Suggested time for work manager to process this job.
    pJob : Job to be processed/scheduled.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    return g_WorkManager.ScheduleJob(dwTime, pJob);
}

//-----------------------------------------------------------

BOOL
TLSWorkManagerSetJobDefaults(
    CWorkObject* pJob
    )
/*++

Abstract:

    Set job's interval and retry time.

Parameter:

    pJob : Job to be set.

Returns:

    TRUE/FALSE.

--*/
{
    DWORD dwInterval, dwRetries, dwRestart;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pJob != NULL)
    {
        GetJobObjectDefaults(&dwInterval, &dwRetries, &dwRestart);
        pJob->SetJobInterval(dwInterval);
        pJob->SetJobRetryTimes(dwRetries);
        pJob->SetJobRestartTime(dwRestart);
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return dwStatus == ERROR_SUCCESS;
}
    


//-----------------------------------------------------------
BOOL
CopyBinaryData(
    IN OUT PBYTE* ppbDestData,
    IN OUT DWORD* pcbDestData,
    IN PBYTE pbSrcData,
    IN DWORD cbSrcData
    )
/*++

Abstract:

    Internal routine to copy a binary data from one buffer 
    to another.

Parameters:

    ppbDestData: Pointer to pointer...
    pcbDestData:
    pbSrcData:
    cbSrcData:

Return:

    TRUE if successful, FALSE otherwise.

++*/
{
    PBYTE pbTarget = NULL;

    if( ppbDestData == NULL || pcbDestData == NULL ||
        pbSrcData == NULL || cbSrcData == 0 )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pbTarget = *ppbDestData;

    //
    // would be nice to get the actual size of memory allocated
    //
    if( *ppbDestData == NULL || LocalSize(*ppbDestData) < cbSrcData )
    {
        if(*ppbDestData == NULL)
        {
            pbTarget = (PBYTE)AllocateMemory(cbSrcData);
        }
        else
        {
            pbTarget = (PBYTE)ReallocateMemory(*ppbDestData, cbSrcData);
        }
    }
        
    if(pbTarget != NULL)
    {
        memcpy(
                pbTarget, 
                pbSrcData, 
                cbSrcData
            );

        *pcbDestData = cbSrcData;
        *ppbDestData = pbTarget;
    }

    return pbTarget != NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// CAnnounceLsServer
//
//////////////////////////////////////////////////////////////////////////
BOOL
CAnnounceLserver::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PANNOUNCESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Verify Announce License Server work object Data.

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwLen;

    if(pbData == NULL || cbData == 0 || cbData != pbData->dwStructSize)
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }


    //
    // NULL terminate string...
    //
    pbData->m_szServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
    pbData->m_szServerName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');

    dwLen = _tcslen(pbData->m_szServerId);
    if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
    {
        dwLen = _tcslen(pbData->m_szServerName);
        if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
        {
            bSuccess = TRUE;
        }
    }

    if(bSuccess == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CAnnounceLserver::CopyWorkObjectData(
    OUT PANNOUNCESERVERWO* ppbDest,
    OUT PDWORD pcbDest,
    IN PANNOUNCESERVERWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy Announce license server work object's data

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceLserver::CleanupWorkObjectData(
    IN OUT PANNOUNCESERVERWO* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    Cleanup Announce license server's work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceLserver::IsJobCompleted(
    IN PANNOUNCESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Determine if Announce License Server Job has completed.

--*/
{
    return (pbData == NULL) ? TRUE : (pbData->dwRetryTimes > GetJobRetryTimes());
}


//---------------------------------------------------------------------------
BOOL 
ServerEnumCallBack(
    TLS_HANDLE hHandle,
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

    See TLSAPI on license server enumeration.

++*/
{
    CAnnounceLserver* pWkObject = (CAnnounceLserver *)dwUserData;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwErrCode;

    TCHAR szRemoteServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szRemoteServerName[LSERVER_MAX_STRING_SIZE+2];

    if(pWkObject == NULL)
    {
        SetLastError(ERROR_INVALID_DATA);
        TLSASSERT(dwUserData != NULL);
        return FALSE;
    }
        
    BOOL bCancel;

    if(pWkObject->IsWorkManagerShuttingDown() == TRUE)
    {
        return TRUE;
    }

    try {
        //
        // Enumeration call ServerEnumCallBack() twice, once before actual connection 
        // and once after it successfully connect to remote server
        //
        if( lstrcmpi(pszServerName, pWkObject->GetWorkData()->m_szServerName) != 0 && hHandle != NULL)  
        {
            //
            // throw exception if fail to allocate memory
            //
            TLServerInfo ServerInfo;
            TLServerInfo ExistingServerInfo;
            TLS_HANDLE hTrustHandle;

            hTrustHandle = TLSConnectAndEstablishTrust(
                                                NULL, 
                                                hHandle
                                            );
            if(hTrustHandle != NULL)
            {                                
                dwStatus = TLSRetrieveServerInfo( 
                                            hTrustHandle, 
                                            &ServerInfo 
                                        );

                if( dwStatus == ERROR_SUCCESS &&
                    lstrcmpi(ServerInfo.GetServerId(), pWkObject->GetWorkData()->m_szServerId) != 0 )
                    // lstrcmpi(ServerInfo.GetServerName(), pWkObject->GetWorkData()->m_szServerName) != 0
                {
                    // check to see if this server is already exists
                    dwStatus = TLSLookupRegisteredServer(
                                                    ServerInfo.GetServerId(),
                                                    ServerInfo.GetServerDomain(),
                                                    ServerInfo.GetServerName(),
                                                    &ExistingServerInfo
                                                );

                    if(dwStatus == ERROR_SUCCESS)
                    {
                        ServerInfo = ExistingServerInfo;
                    }
                    else
                    {
                        // register every server.
                        dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
                        if(dwStatus == TLS_E_DUPLICATE_RECORD)
                        {
                            dwStatus = ERROR_SUCCESS;
                        }   
                    }

                    // let enforce talk to non-enforce, replication will be block later
                    if( ServerInfo.IsAnnounced() == FALSE && dwStatus == ERROR_SUCCESS )
                    {

                        DBGPrintf(
                                DBG_INFORMATION,
                                DBG_FACILITY_JOB,
                                DBGLEVEL_FUNCTION_TRACE,
                                _TEXT("%s - Announce to %s\n"),
                                pWkObject->GetJobDescription(),
                                ServerInfo.GetServerName()
                            );

                        dwStatus = TLSAnnounceServerToRemoteServer(
                                                            TLSANNOUNCE_TYPE_STARTUP,
                                                            ServerInfo.GetServerId(),
                                                            ServerInfo.GetServerDomain(),
                                                            ServerInfo.GetServerName(),
                                                            pWkObject->GetWorkData()->m_szServerId,
                                                            pWkObject->GetWorkData()->m_szScope,
                                                            pWkObject->GetWorkData()->m_szServerName,
                                                            &(pWkObject->GetWorkData()->m_ftLastShutdownTime)
                                                        );
                    }
                }                
            }
        }
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch( ... ) {
        dwStatus = TLS_E_INTERNAL;
        TLSASSERT(FALSE);
    }
    
    return (dwStatus == ERROR_SUCCESS) ? pWkObject->IsWorkManagerShuttingDown() : TRUE;
}

//---------------------------------------------------------------------------
DWORD
CAnnounceLserver::ExecuteJob(
    IN PANNOUNCESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Execute a announce license server job.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );

    if(IsWorkManagerShuttingDown() == TRUE)
    {
        return TLS_I_WORKMANAGER_SHUTDOWN;
    }

    //
    // Enumerate all license server 
    // 
    dwStatus = EnumerateTlsServer(
                            ServerEnumCallBack,
                            this,
                            TLSERVER_ENUM_TIMEOUT,
                            FALSE
                        );  

    //
    // Discovery run twice so that if more than one server
    // start up at the same time, second loop will catch it.
    //
    pbData->dwRetryTimes++;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ended...\n"),
            GetJobDescription()
        );
    
    return dwStatus;
}

//----------------------------------------------------------------------------------------------
LPCTSTR
CAnnounceLserver::GetJobDescription()
/*++

    Get announce license server job description, this is used 
    only at debug tracing.

--*/
{
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    _tcsncpy(
            m_szJobDescription,
            ANNOUNCESERVER_DESCRIPTION,
            sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1
        );

    return m_szJobDescription;
}

    
////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
//
// CAnnounceTOEServer
//
//////////////////////////////////////////////////////////////////////////
BOOL
CAnnounceToEServer::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PANNOUNCETOESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Verify Announce license server to enterprise server work object
    data.

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwLen;

    if(pbData == NULL || cbData != pbData->dwStructSize)
    {
        TLSASSERT(FALSE);   
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // NULL terminate string...
    //
    pbData->m_szServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
    pbData->m_szServerName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');

    dwLen = _tcslen(pbData->m_szServerId);
    if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
    {
        dwLen = _tcslen(pbData->m_szServerName);
        if(dwLen != 0 && dwLen < LSERVER_MAX_STRING_SIZE + 1)
        {
            bSuccess = TRUE;
        }
    }

    if(bSuccess == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CAnnounceToEServer::CopyWorkObjectData(
    OUT PANNOUNCETOESERVERWO* ppbDest,
    OUT PDWORD pcbDest,
    IN PANNOUNCETOESERVERWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy announce license server to enterprise server work 
    object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceToEServer::CleanupWorkObjectData(
    IN OUT PANNOUNCETOESERVERWO* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    Cleanup announce license server to enterprise server work 
    object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceToEServer::IsJobCompleted(
    IN PANNOUNCETOESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Detemine if announce license server to enterprise server
    is completed.

--*/
{
    return (pbData == NULL) ? TRUE : GetWorkData()->bCompleted;
}

//---------------------------------------------------------------------------
DWORD
CAnnounceToEServer::ExecuteJob(
    IN PANNOUNCETOESERVERWO pbData,
    IN DWORD cbData
    )
/*++

    Execute an announce license server to enterprise server work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    LPWSTR* pszEServerList = NULL;
    DWORD dwCount = 0;
    DWORD dwErrCode;
    BOOL bSkipServer;
    TCHAR szRemoteServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szRemoteServerName[LSERVER_MAX_STRING_SIZE+2];

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );


    TLSASSERT(pbData != NULL && cbData != 0);

    try {
        dwStatus = GetAllEnterpriseServers(
                                        &pszEServerList,
                                        &dwCount
                                    );

        if(dwStatus == ERROR_SUCCESS && dwCount > 0 && pszEServerList != NULL)
        {

            for(DWORD index = 0; 
                index < dwCount && IsWorkManagerShuttingDown() == FALSE; 
                index++)
            {
                bSkipServer = TRUE;

                if(pszEServerList[index] == NULL)
                {
                    continue;
                }
    
                //
                // check if we already have this server in our list
                //
                TLServerInfo ServerInfo;
                dwStatus = TLSLookupRegisteredServer(
                                                    NULL,
                                                    NULL,
                                                    pszEServerList[index],
                                                    &ServerInfo
                                                );

                if(dwStatus != ERROR_SUCCESS)
                {
                    //
                    // Get the actual server name.
                    //
                    TLS_HANDLE hTrustHandle = NULL;

                    hTrustHandle = TLSConnectAndEstablishTrust(
                                                            pszEServerList[index], 
                                                            NULL
                                                        );
                    if(hTrustHandle != NULL)
                    {
                        if(IsWorkManagerShuttingDown() == TRUE)
                        {
                            // handle leak but we are shutting down
                            break;
                        }                    

                        dwStatus = TLSRetrieveServerInfo( 
                                                    hTrustHandle, 
                                                    &ServerInfo 
                                                );

                        if(dwStatus == ERROR_SUCCESS)
                        {
                            if( lstrcmpi(ServerInfo.GetServerName(), pbData->m_szServerName) != 0 )
                            {

                                if(IsWorkManagerShuttingDown() == TRUE)
                                {
                                    // handle leak but we are shutting down
                                    break;
                                }

                                dwStatus = TLSRegisterServerWithServerInfo(&ServerInfo);
                                if(dwStatus == ERROR_SUCCESS)
                                {
                                    // at this point, if we gets duplicate record, that mean
                                    // server is registered via announce and we already 
                                    // sync. local license pack so skip it.
                                    bSkipServer = FALSE;
                                }
                            }
                        }
                    }

                    if( hTrustHandle != NULL)
                    {               
                        TLSDisconnectFromServer(hTrustHandle);
                    }

                    dwStatus = ERROR_SUCCESS;
                    if(bSkipServer == TRUE)
                    {
                        continue;
                    }
                }
                else if(GetLicenseServerRole() & TLSERVER_ENTERPRISE_SERVER) 
                {
                    // for enterprise server, other server will announce itself,
                    // for domain server, we need to announce once a while
                    // so that after enterprise restart, it still have our 
                    // server
                    if(dwStatus == ERROR_SUCCESS && ServerInfo.GetServerVersion() != 0)
                    {
                        //
                        // we already 'push' sync. with this server
                        //
                        continue;
                    }
                }

                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_JOB,
                        DBGLEVEL_FUNCTION_TRACE,
                        _TEXT("%s - Announce to %s\n"),
                        GetJobDescription(),
                        pszEServerList[index]
                    );

                if(IsWorkManagerShuttingDown() == TRUE)
                {
                    // handle leak but we are shutting down
                    break;
                }

                dwStatus = TLSAnnounceServerToRemoteServer(
                                                    TLSANNOUNCE_TYPE_STARTUP,
                                                    ServerInfo.GetServerId(),
                                                    ServerInfo.GetServerDomain(),
                                                    ServerInfo.GetServerName(),
                                                    GetWorkData()->m_szServerId,
                                                    GetWorkData()->m_szScope,
                                                    GetWorkData()->m_szServerName,
                                                    &(GetWorkData()->m_ftLastShutdownTime)
                                                );
            }

            //
            // Free memory
            //
            if(pszEServerList != NULL)
            {
                for( index = 0; index < dwCount; index ++)
                {
                    if(pszEServerList[index] != NULL)
                    {
                        LocalFree(pszEServerList[index]);
                    }
                }

                LocalFree(pszEServerList);
            }                              
        }
    }
    catch( SE_Exception e ) 
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CAnnounceToEServer::ExecuteJob() : Job has cause exception %d\n"),
                e.getSeNumber()
            );

        dwStatus = e.getSeNumber();
        TLSASSERT(FALSE);
    }
    catch(...) 
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CAnnounceToEServer::ExecuteJob() : Job has cause unknown exception\n")
            );

        TLSASSERT(FALSE);
    }   

    //
    // Continue running in case user install a NT5 PDC
    //
    if(IsWorkManagerShuttingDown() == TRUE)
    {
        GetWorkData()->bCompleted = TRUE;
    }

    return dwStatus;
}

//--------------------------------------------------------------------
LPCTSTR
CAnnounceToEServer::GetJobDescription()
/*++

    Get announce license server to enterprise server
    job description, used only at debug tracing.

--*/
{
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    _tcsncpy(
            m_szJobDescription,
            ANNOUNCETOESERVER_DESCRIPTION,
            sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1
        );

    return m_szJobDescription;
}


////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
//
// CReturnLicense
//
//////////////////////////////////////////////////////////////////////////

CWorkObject* WINAPI
InitializeCReturnWorkObject(
    IN CWorkManager* pWkMgr,
    IN PBYTE pbWorkData,
    IN DWORD cbWorkData
    )
/*++

Abstract:

    Create/initialize a Return License work object.

Parameters:

    pWkMgr : Pointer work manager.
    pbWorkData : Object's work data used to initialize return license.
    cbWorkData : size of work data.

Return:

    A pointer to CWorkObject or NULL if error.

--*/
{
    CReturnLicense* pRetLicense = NULL;
    DWORD dwStatus;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("InitializeCReturnWorkObject() - initializing return license...\n")
        );

    try {
        pRetLicense = new CReturnLicense(
                                        TRUE, 
                                        (PRETURNLICENSEWO)pbWorkData, 
                                        cbWorkData
                                    );

        //
        // TODO - fix this, bad design
        //
        pRetLicense->SetProcessingWorkManager(pWkMgr);
        TLSASSERT(pRetLicense->IsValid() == TRUE);
    }
    catch( SE_Exception e ) {

        pRetLicense = NULL;
        SetLastError(dwStatus = e.getSeNumber());

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_INITJOB,
                dwStatus
            );
    }
    catch(...) {

        pRetLicense = NULL;
        SetLastError(dwStatus = TLS_E_INITJOB_UNKNOWN);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_INITJOB_UNKNOWN
            );
    }

    return pRetLicense;
}
    
//--------------------------------------------------------
BOOL
CReturnLicense::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,
    IN PRETURNLICENSEWO pbData,
    IN DWORD cbData
    )
/*++

    Verify a return license work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLen;
    DWORD dwNumLicensedProduct;

    if(pbData == NULL || cbData == 0 || pbData->cbEncryptedHwid == 0)
    {
        TLSASSERT(FALSE);
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        if( pbData->dwStructVersion < CURRENT_RETURNLICENSEWO_STRUCT_VER ||
            pbData->dwStructSize != cbData )
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
            TLSASSERT(FALSE);
        }
    }
    
    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // NULL Terminate Target Server ID
        //
        pbData->szTargetServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szTargetServerId);

        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szTargetServerName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szTargetServerName);

        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szOrgProductID[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szOrgProductID);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szCompanyName[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szCompanyName);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szProductId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szProductId);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szUserName[MAXCOMPUTERNAMELENGTH+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szUserName);
        if(dwLen == 0 || dwLen >= MAXCOMPUTERNAMELENGTH+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }
     
    if(dwStatus == ERROR_SUCCESS)
    {
        pbData->szMachineName[MAXUSERNAMELENGTH+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->szMachineName);
        if(dwLen == 0 || dwLen >= MAXUSERNAMELENGTH+1)
        {
            SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        }
    }

    return dwStatus == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------------------------

BOOL
CReturnLicense::CopyWorkObjectData(
    IN OUT PRETURNLICENSEWO* ppbDest,
    IN OUT PDWORD pcbDest,
    IN PRETURNLICENSEWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy return license work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:
    return dwStatus == ERROR_SUCCESS;
}

//-------------------------------------------------------------------------

BOOL 
CReturnLicense::CleanupWorkObjectData(
    IN OUT PRETURNLICENSEWO* ppbData,
    IN OUT PDWORD pcbData    
    )
/*++

    Cleanup return license work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------

BOOL
CReturnLicense::IsJobCompleted(
    IN PRETURNLICENSEWO pbData,
    IN DWORD cbData
    )
/*++

    Determine if return license job is completed.

--*/
{
    return (pbData != NULL) ? (pbData->dwNumRetry >= m_dwRetryTimes) : TRUE;
}

//-----------------------------------------------------------------------------
#if 0
DWORD
_ResolveServerIdToServer(
    LPTSTR pszServerId,
    LPTSTR pszServerName
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLS_HANDLE hEServer = NULL;
    TLServerInfo EServerInfo;
    DWORD dwErrCode;

    TCHAR pbSetupId[LSERVER_MAX_STRING_SIZE+2];
    DWORD cbSetupId = LSERVER_MAX_STRING_SIZE+1;

    TCHAR pbDomainName[LSERVER_MAX_STRING_SIZE+2];
    DWORD cbDomainName = LSERVER_MAX_STRING_SIZE+1;

    TCHAR pbServerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD cbServerName = MAX_COMPUTERNAME_LENGTH+1;



    dwStatus = TLSLookupServerById(
                                pszServerId, 
                                pszServerName
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        // try to resolve server name with enterprise server
        dwStatus = TLSLookupAnyEnterpriseServer(&EServerInfo);
        if(dwStatus == ERROR_SUCCESS)
        {
            hEServer = TLSConnectAndEstablishTrust(
                                                EServerInfo.GetServerName(), 
                                                NULL
                                            );
            if(hEServer != NULL)
            {
                dwStatus = TLSLookupServer(
                                        hEServer, 
                                        pszServerId, 
                                        pbSetupId,   
                                        &cbSetupId,
                                        pbDomainName,
                                        &cbDomainName,
                                        pbServerName,
                                        &cbServerName,
                                        &dwErrCode
                                    );

                if(dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS)
                {
                    lstrcpy(pszServerName, pbServerName);
                }
            }
        }
    }



    if(hEServer != NULL)
    {
        TLSDisconnectFromServer(hEServer);
    }

    return dwStatus;
}
#endif

//--------------------------------------------------------------------------------

DWORD
CReturnLicense::ExecuteJob(
    IN PRETURNLICENSEWO pbData,
    IN DWORD cbData
    )
/*++

    Execute a return license work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLServerInfo ServerInfo;
    TCHAR szServer[LSERVER_MAX_STRING_SIZE+2];
    TLSLicenseToBeReturn ToBeReturn;
    TLS_HANDLE hHandle = NULL;
    DWORD dwErrCode = ERROR_SUCCESS;

    // log an error
    TCHAR szErrMsg[MAX_ERROR_MSG_SIZE];
    DWORD dwSize = sizeof(szErrMsg) / sizeof(szErrMsg[0]);


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );
    
    //-------------------------------------------------------
    if(VerifyWorkObjectData(TRUE, pbData, cbData) == FALSE)
    {
        TLSASSERT(FALSE);
        //
        // this is invalid data, quitely abort operation
        //
        pbData->dwNumRetry = m_dwRetryTimes;
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(IsWorkManagerShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
        goto cleanup;
    }

    dwStatus = TLSResolveServerIdToServer(        
                                pbData->szTargetServerId, 
                                szServer
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        // Server not register with this server, try using
        // whatever name we have 
        lstrcpy(szServer, pbData->szTargetServerName);
        dwStatus = ERROR_SUCCESS;
    }

    ToBeReturn.dwQuantity = pbData->dwQuantity;
    ToBeReturn.dwKeyPackId = pbData->dwKeyPackId;
    ToBeReturn.dwLicenseId = pbData->dwLicenseId;

    ToBeReturn.cbEncryptedHwid = pbData->cbEncryptedHwid;
    ToBeReturn.pbEncryptedHwid = pbData->pbEncryptedHwid;

    ToBeReturn.dwProductVersion = pbData->dwProductVersion;

    ToBeReturn.pszOrgProductId = pbData->szOrgProductID;
    ToBeReturn.pszCompanyName = pbData->szCompanyName;
    ToBeReturn.pszProductId = pbData->szProductId;
    ToBeReturn.pszUserName = pbData->szUserName;
    ToBeReturn.pszMachineName = pbData->szMachineName;
    ToBeReturn.dwPlatformID = pbData->dwPlatformId;

    if(IsWorkManagerShuttingDown() == TRUE)
    {
        SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
        goto cleanup;
    }

    hHandle = TLSConnectAndEstablishTrust(szServer, NULL);
    if(hHandle == NULL)
    {
        dwStatus = GetLastError();
        // TLSLogEvent(
        //        EVENTLOG_WARNING_TYPE,
        //        TLS_W_RETURNLICENSE,
        //        TLS_I_CONTACTSERVER,
        //        szServer
        //    );
    }
    else
    {
        if(IsWorkManagerShuttingDown() == TRUE)
        {
            SetLastError(dwStatus = TLS_I_WORKMANAGER_SHUTDOWN);
            goto cleanup;
        }

        // make a RPC call to return client license
        dwStatus = TLSReturnLicensedProduct(
                                    hHandle,
                                    &ToBeReturn,
                                    &dwErrCode
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            // retry again
            // TLSLogEvent(
            //        EVENTLOG_WARNING_TYPE,
            //        TLS_W_RETURNLICENSE,
            //        TLS_I_CONTACTSERVER,
            //        szServer
            //    );
        }
        else if(dwErrCode >= LSERVER_ERROR_BASE)
        {
            if(dwErrCode != LSERVER_E_DATANOTFOUND && dwErrCode != LSERVER_E_INVALID_DATA)
            {
                DWORD status;
                DWORD errCode;

                memset(szErrMsg, 0, sizeof(szErrMsg));

                status = TLSGetLastError(
                                    hHandle,
                                    dwSize,
                                    szErrMsg,
                                    &errCode
                                );

                if(status == ERROR_SUCCESS)
                {
                    TLSLogEvent(
                            EVENTLOG_WARNING_TYPE,
                            TLS_W_RETURNLICENSE,
                            TLS_E_RETURNLICENSE,
                            ToBeReturn.pszMachineName,
                            ToBeReturn.pszUserName,
                            szErrMsg,
                            szServer
                        );
                }
                else
                {
                    // server might be done at this instance, 
                    // log an error with error code
                    TLSLogEvent(
                            EVENTLOG_WARNING_TYPE,
                            TLS_W_RETURNLICENSE,
                            TLS_E_RETURNLICENSECODE,
                            ToBeReturn.pszMachineName,
                            ToBeReturn.pszUserName,
                            dwErrCode,
                            szServer
                        );
                }
            }
        }            
    }

    if(dwStatus == ERROR_SUCCESS && dwErrCode == ERROR_SUCCESS)
    {
        // successfully return license.
        pbData->dwNumRetry = m_dwRetryTimes;
    }
    else if(dwErrCode == LSERVER_E_INVALID_DATA || dwErrCode == LSERVER_E_DATANOTFOUND)
    {
        // server might be re-installed so all database entry is gone
        // delete this return license job
        pbData->dwNumRetry = m_dwRetryTimes;
    }
    else
    {
        pbData->dwNumRetry++;

        if(pbData->dwNumRetry >= m_dwRetryTimes)
        {
            TLSLogEvent(
                    EVENTLOG_WARNING_TYPE,
                    TLS_W_RETURNLICENSE,
                    TLS_E_RETURNLICENSETOOMANY,
                    ToBeReturn.pszMachineName,
                    ToBeReturn.pszUserName,
                    pbData->dwNumRetry
                );
        }
    }

cleanup:

    if(hHandle != NULL)
    {
        TLSDisconnectFromServer(hHandle);
        hHandle = NULL;
    }

    return dwStatus;
}

//----------------------------------------------------------------------------------------------

LPCTSTR
CReturnLicense::GetJobDescription()
/*++

    Get job description, use only at debug tracing.

--*/
{
    PRETURNLICENSEWO pbData = GetWorkData();

    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    if(pbData)
    {
        _sntprintf(
                m_szJobDescription,
                sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1,
                RETURNLICENSE_DESCRIPTION,
                pbData->dwNumRetry,
                pbData->dwKeyPackId,
                pbData->dwLicenseId,
                pbData->szTargetServerName
            );
    }

    return m_szJobDescription;
}
    
//////////////////////////////////////////////////////////////////////////
//
// CSsyncLicensePack
//
//////////////////////////////////////////////////////////////////////////

BOOL
CSsyncLicensePack::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PSSYNCLICENSEPACK pbData,
    IN DWORD cbData
    )
/*++

    Verify a sync. license pack work object data.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwLen;

    if( pbData == NULL || cbData == 0 || cbData != pbData->dwStructSize ||
        (pbData->dwSyncType != SSYNC_ALL_LKP && pbData->dwSyncType != SSYNC_ONE_LKP) )
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
        bSuccess = FALSE;
    }
    else if(bCallByIsValid == FALSE)
    {
        for(DWORD index =0; 
            index < pbData->dwNumServer && bSuccess == TRUE; 
            index++)
        {
            //
            // NULL terminate string...
            //
            pbData->m_szTargetServer[index][MAX_COMPUTERNAME_LENGTH+1] = _TEXT('\0');

            dwLen = _tcslen(pbData->m_szTargetServer[index]);
            if(dwLen == 0 || dwLen >= MAX_COMPUTERNAME_LENGTH + 1)
            {
                SetLastError(ERROR_INVALID_DATA);
                bSuccess = FALSE;
            }
        }
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CSsyncLicensePack::CopyWorkObjectData(
    OUT PSSYNCLICENSEPACK* ppbDest,
    OUT PDWORD pcbDest,
    IN PSSYNCLICENSEPACK pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy a sync. license pack work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CSsyncLicensePack::CleanupWorkObjectData(
    IN OUT PSSYNCLICENSEPACK* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    Cleanup a sync. license pack work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CSsyncLicensePack::IsJobCompleted(
    IN PSSYNCLICENSEPACK pbData,
    IN DWORD cbData
    )
/*++

    Detemine if Job is completed.

--*/
{
    return (pbData == NULL) ? TRUE : pbData->bCompleted;
}

//---------------------------------------------------------------------------
void
_AnnounceLicensePackToServers(
    IN CWorkObject* ptr,
    IN PTLSLICENSEPACK pLicensePack,
    IN PDWORD pdwCount,
    IN TCHAR pszServerList[][MAX_COMPUTERNAME_LENGTH+2],
    IN BOOL* pbSsyncStatus
    )
/*++

Abstract:

    Sync. a license pack to list of remote server.

Parameter:

    ptr : pointer to work object that started this call.
    pLicensePack : Pointer to license keypack to sync. with 
                   list of remote server.
    pdwCount : On input, number of license server to push sync,
               on output, number of license server successfully sync.
    pszServerList : Pointer to list of remote server.
    pbSsyncStatus : Pointer to an array to receive push sync status.

Returns:

    None, all error are ignored.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSReplRecord record;
    DWORD dwNumServer = *pdwCount;
    DWORD dwIndex;
    TLS_HANDLE hHandle;
    RPC_STATUS rpcStatus;
    
    *pdwCount = 0;

    //
    // Setup replication record
    //
    record.dwReplCode = REPLICATIONCODE_SYNC;
    record.dwUnionType = UNION_TYPE_LICENSEPACK;
    record.w.ReplLicPack = *pLicensePack;

    //
    // Announce to all server in the list 
    //
    for( dwIndex = 0; 
         dwIndex < dwNumServer && ptr->IsWorkManagerShuttingDown() == FALSE; 
         dwIndex++ )
    {
        if(pbSsyncStatus[dwIndex] == FALSE)
        {
            hHandle = TLSConnectAndEstablishTrust(
                                                pszServerList[dwIndex],
                                                NULL
                                            );

            if(hHandle != NULL)
            {                                
                DWORD dwSupportFlags = 0;

                	dwStatus = TLSGetSupportFlags(
                        hHandle,
                        &dwSupportFlags
                );

                // License Keypack is not replicated if License server version < license Keypack version

	            if ((dwStatus == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
                {                    
                    continue;
                }
        
                // If the call fails => Windows 2000 LS
                else if(dwStatus != RPC_S_OK)
                {
                    continue;
                }                                            

                rpcStatus = TLSAnnounceLicensePack(
                                                hHandle,
                                                &record,
                                                &dwStatus
                                            );

                if(rpcStatus != RPC_S_OK)
                {
                    // this server might be down, mark it so that
                    // we don't retry again
                    pbSsyncStatus[dwIndex] = TRUE;
                } 
                else if(dwStatus == LSERVER_E_SERVER_BUSY)
                {
                    // retry only when server return busy status
                    pbSsyncStatus[dwIndex] = FALSE;
                }
                else
                {
                    // any error, just don't bother trying again
                    pbSsyncStatus[dwIndex] = TRUE;
                }
            }
            else
            {
                // server is not available, don't ssync again
                pbSsyncStatus[dwIndex] = TRUE;
            }

            if(hHandle != NULL)
            {
                TLSDisconnectFromServer(hHandle);
                hHandle = NULL;
            }
        }

        if(pbSsyncStatus[dwIndex] == TRUE)
        {
            (*pdwCount)++;
        }
    }           

    return;
}

//---------------------------------------------------------------------------
DWORD
_SsyncOneLocalLicensePack(
    IN CSsyncLicensePack* ptr,
    IN PSSYNCLICENSEPACK pSsyncLkp
    )
/*++

Abstract:

    Sync. one license pack to one remote server.

Parameter:

    Ptr : Pointer to CSsyncLicensePack work object.
    pSsyncLkp : Pinter to PSSYNCLICENSEPACK.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLSLICENSEPACK LicensePackSearch;
    TLSLICENSEPACK LicensePack;
    DWORD dwSuccessCount = 0;

    //
    // Allocate DB Work Space.
    //
    pDbWkSpace = AllocateWorkSpace(SSYNC_DBWORKSPACE_TIMEOUT);
    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = TLS_I_SSYNCLKP_SERVER_BUSY);
        TLSLogInfoEvent(TLS_I_SSYNCLKP_SERVER_BUSY);
        goto cleanup;
    }


    try {
        LicensePackSearch.dwKeyPackId = pSsyncLkp->dwKeyPackId;

        //
        // retrieve license pack
        //
        dwStatus = TLSDBKeyPackFind(   
                                pDbWkSpace,
                                TRUE,
                                LICENSEDPACK_PROCESS_DWINTERNAL,
                                &LicensePackSearch,
                                &LicensePack
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            if(dwStatus != TLS_E_RECORD_NOTFOUND)
            {
                TLSLogEvent(
                        EVENTLOG_INFORMATION_TYPE,
                        TLS_W_SSYNCLKP,
                        dwStatus
                    );
            }

            goto cleanup;
        }

        if(IsLicensePackRepl(&LicensePack) == FALSE)
        {
            goto cleanup;
        }

        if(ptr->IsWorkManagerShuttingDown() == TRUE)
        {
            SetLastError(dwStatus = TLS_I_SERVICE_STOP);
            goto cleanup;
        }

        //
        // Make sure local Server ID and Server Name is correct
        // 
        SAFESTRCPY(LicensePack.szInstallId, pSsyncLkp->m_szServerId);
        SAFESTRCPY(LicensePack.szTlsServerName, pSsyncLkp->m_szServerName);
    
        dwSuccessCount = pSsyncLkp->dwNumServer;
        _AnnounceLicensePackToServers(
                                ptr,
                                &LicensePack,
                                &dwSuccessCount,
                                pSsyncLkp->m_szTargetServer,
                                pSsyncLkp->m_bSsync
                            );

        if(dwSuccessCount != pSsyncLkp->dwNumServer)
        {
            TLSLogInfoEvent(TLS_I_SSYNCLKP_FAILED);
        }
    }
    catch( SE_Exception e ) {
        SetLastError(dwStatus = e.getSeNumber());
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_INTERNAL);
        TLSASSERT(FALSE);
    }   

cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}

//----------------------------------------------------------------------------
DWORD
_SsyncAllLocalLicensePack(
    IN CSsyncLicensePack* ptr,
    IN PSSYNCLICENSEPACK pSsyncLkp
    )
/*++

    Sync. all local license pack to a remote server.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace = NULL;
    TLSLICENSEPACK LicensePackSearch;
    TLSLICENSEPACK LicensePack;
    DWORD dwSuccessCount = 0;
    BOOL SyncStatus[SSYNCLKP_MAX_TARGET];

    //
    // Allocate DB Work Space.
    //
    pDbWkSpace = AllocateWorkSpace(SSYNC_DBWORKSPACE_TIMEOUT);
    if(pDbWkSpace == NULL)
    {
        SetLastError(dwStatus = TLS_I_SSYNCLKP_SERVER_BUSY);
        TLSLogInfoEvent(TLS_I_SSYNCLKP_SERVER_BUSY);
        goto cleanup;
    }

    try {
        dwStatus = TLSDBKeyPackEnumBegin(
                                    pDbWkSpace,
                                    FALSE,
                                    0,
                                    NULL
                                );

        if(dwStatus == ERROR_SUCCESS)
        {
            while((dwStatus = TLSDBKeyPackEnumNext(pDbWkSpace, &LicensePack)) == ERROR_SUCCESS)
            {
                // unreliable, system time between two machine might not work,
                // force sync and let remote server update its data.
                if(CompareFileTime(
                            &LicensePack.ftLastModifyTime, 
                            &ptr->GetWorkData()->m_ftStartSyncTime
                        ) < 0)
                {
                    continue;
                }

                if(ptr->IsWorkManagerShuttingDown() == TRUE)
                {
                    break;
                }

                if(IsLicensePackRepl(&LicensePack) == FALSE)
                {
                    continue;
                }

                //
                // Make sure local Server ID and Server Name is correct
                // 
                SAFESTRCPY(LicensePack.szInstallId, pSsyncLkp->m_szServerId);
                SAFESTRCPY(LicensePack.szTlsServerName, pSsyncLkp->m_szServerName);
                memset(SyncStatus, 0, sizeof(SyncStatus));

                dwSuccessCount = pSsyncLkp->dwNumServer;
                _AnnounceLicensePackToServers(
                                    ptr,
                                    &LicensePack,
                                    &dwSuccessCount,
                                    pSsyncLkp->m_szTargetServer,
                                    SyncStatus
                                );
            }

            TLSDBKeyPackEnumEnd(pDbWkSpace);
        }

        //
        // ignore all error
        //
        dwStatus = ERROR_SUCCESS;
    }
    catch( SE_Exception e ) {
        SetLastError(dwStatus = e.getSeNumber());
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_WORKMANAGER_INTERNAL);
    }   
    
cleanup:

    if(pDbWkSpace != NULL)
    {
        ReleaseWorkSpace(&pDbWkSpace);
    }

    return dwStatus;
}

//----------------------------------------------------------------------------

DWORD
CSsyncLicensePack::ExecuteJob(
    IN PSSYNCLICENSEPACK pSsyncLkp,
    IN DWORD cbSsyncLkp
    )
/*++

    Execute a CSsyncLicensePack work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );

    TLSASSERT(pSsyncLkp != NULL && cbSsyncLkp != 0);
    if(VerifyWorkObjectData(FALSE, pSsyncLkp, cbSsyncLkp) == FALSE)
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
        pSsyncLkp->bCompleted = TRUE;
        return ERROR_INVALID_DATA;
    }

    try {
        if(pSsyncLkp->dwSyncType == SSYNC_ONE_LKP)
        {
            dwStatus = _SsyncOneLocalLicensePack(this, pSsyncLkp);
        }
        else
        {
            dwStatus = _SsyncAllLocalLicensePack(this, pSsyncLkp);
        }
    }    
    catch( SE_Exception e ) 
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CSsyncLicensePack::ExecuteJob() : Job has cause exception %d\n"),
                e.getSeNumber()
            );

        dwStatus = e.getSeNumber();
        TLSASSERT(FALSE);
    }
    catch(...) 
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CSsyncLicensePack::ExecuteJob() : Job has cause unknown exception\n")
            );

        TLSASSERT(FALSE);
    }   

    if(dwStatus == TLS_I_SSYNCLKP_SERVER_BUSY || dwStatus == TLS_I_SSYNCLKP_FAILED)
    {
        // retry operation
        pSsyncLkp->bCompleted = FALSE;
    }
    else
    {
        pSsyncLkp->bCompleted = TRUE;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ended...\n"),
            GetJobDescription()
        );
    
    return dwStatus;
}

//--------------------------------------------------------------------------------------
LPCTSTR
CSsyncLicensePack::GetJobDescription()
/*++

    Get CSsyncLicensePack job description, use only
    by debug tracing.

--*/
{
    PSSYNCLICENSEPACK pbData = GetWorkData();
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));

    if(pbData != NULL)
    {
        _sntprintf(
                m_szJobDescription,
                sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1,
                SSYNCLICENSEKEYPACK_DESCRIPTION,
                (pbData->dwSyncType == SSYNC_ALL_LKP) ? _TEXT("ALL") : _TEXT("One"),
                pbData->m_szTargetServer
            );
    }

    return m_szJobDescription;
}



//////////////////////////////////////////////////////////////////////////
//
// CAnnounceResponse
//
//////////////////////////////////////////////////////////////////////////
BOOL
CAnnounceResponse::VerifyWorkObjectData(
    IN BOOL bCallByIsValid,             // invoke by IsValid() function.
    IN PANNOUNCERESPONSEWO pbData,
    IN DWORD cbData
    )
/*++

    Verify CAnnounceResponse work object data.

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwLen;

    if(pbData == NULL || cbData == 0 || cbData != pbData->dwStructSize)
    {
        bSuccess = FALSE;
    }

    if(bSuccess == TRUE)
    {
        pbData->m_szTargetServerId[LSERVER_MAX_STRING_SIZE+1] = _TEXT('\0');
        dwLen = _tcslen(pbData->m_szTargetServerId);
        if(dwLen == 0 || dwLen >= LSERVER_MAX_STRING_SIZE + 1)
        {
            bSuccess = FALSE;
        }
    }

    if(bSuccess == FALSE)
    {
        TLSASSERT(FALSE);
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}

//------------------------------------------------------------------------
BOOL
CAnnounceResponse::CopyWorkObjectData(
    OUT PANNOUNCERESPONSEWO* ppbDest,
    OUT PDWORD pcbDest,
    IN PANNOUNCERESPONSEWO pbSrc,
    IN DWORD cbSrc
    )
/*++

    Copy CAnnounceResponse work object data.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(ppbDest == NULL || pcbDest == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(CopyBinaryData(
                (PBYTE *)ppbDest,
                pcbDest,
                (PBYTE) pbSrc,
                cbSrc
            ) == FALSE)
    {           
        dwStatus = GetLastError();
    }

cleanup:

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceResponse::CleanupWorkObjectData(
    IN OUT PANNOUNCERESPONSEWO* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

    cleanup CAnnounceResponse work object data.

--*/
{
    if(ppbData != NULL && pcbData != NULL)
    {
        FreeMemory(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
BOOL
CAnnounceResponse::IsJobCompleted(
    IN PANNOUNCERESPONSEWO pbData,
    IN DWORD cbData
    )
/*++

    Detemine if job completed.

--*/
{
    return (pbData == NULL) ? TRUE : pbData->bCompleted;
}

//---------------------------------------------------------------------------
DWORD
CAnnounceResponse::ExecuteJob(
    IN PANNOUNCERESPONSEWO pbData,
    IN DWORD cbData
    )
/*++

    Execute a CAnnounceResponse work object.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLS_HANDLE hHandle = NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ...\n"),
            GetJobDescription()
        );

    TLServerInfo ServerInfo;

    dwStatus = TLSLookupRegisteredServer(
                                    pbData->m_szTargetServerId,
                                    NULL,
                                    NULL,
                                    &ServerInfo
                                );

    if(dwStatus == ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_JOB,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("Announcing server to %s...\n"),
                ServerInfo.GetServerName()
            );

        if(IsWorkManagerShuttingDown() == FALSE)
        {
            dwStatus = TLSAnnounceServerToRemoteServer(
                                            TLSANNOUNCE_TYPE_RESPONSE,
                                            ServerInfo.GetServerId(),
                                            ServerInfo.GetServerDomain(),
                                            ServerInfo.GetServerName(),
                                            pbData->m_szLocalServerId,
                                            pbData->m_szLocalScope,
                                            pbData->m_szLocalServerName,
                                            &(pbData->m_ftLastShutdownTime)
                                        );
        }
    }
    else
    {
        TLSASSERT(FALSE);
    }



    //
    // Discovery run once
    //
    pbData->bCompleted = TRUE;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_JOB,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s ended...\n"),
            GetJobDescription()
        );
    
    return dwStatus;
}

//----------------------------------------------------------------------------------------------
LPCTSTR
CAnnounceResponse::GetJobDescription()
/*++

    Retrieve CAnnounceResponse job description.

--*/
{
    memset(m_szJobDescription, 0, sizeof(m_szJobDescription));
    PANNOUNCERESPONSEWO pbData = GetWorkData();

    if(pbData != NULL)
    {
        _sntprintf(
                m_szJobDescription,
                sizeof(m_szJobDescription)/sizeof(m_szJobDescription[0]) - 1,
                ANNOUNCERESPONSE_DESCRIPTION,
                pbData->m_szTargetServerId
            );
    }

    return m_szJobDescription;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlsjob.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tlsjob.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSJOB_H__
#define __TLSJOB_H__

#include "server.h"
#include "jobmgr.h"
#include "workitem.h"
#include "locks.h"


//
// Default interval time is one hour for session and
// persistent job.
//
#ifndef __TEST_WORKMGR__

#define DEFAULT_JOB_INTERVAL        60*60       // Retry every hour
#define DEFAULT_JOB_RETRYTIMES      60*60*60    // 60 days

#define DEFAULT_PERSISTENT_JOB_INTERVAL     4*60*60 // 4 hour interval
#define DEFAULT_PERSISTENT_JOB_RETRYTIMES   6 * 60  // 60 days.

#else

#define DEFAULT_JOB_INTERVAL        2       // 10 seconds
#define DEFAULT_JOB_RETRYTIMES      6000

#endif

#define MAX_JOB_DESCRIPTION         254

//--------------------------------------------------------------
//
// currently defined type of work
//
#define WORKTYPE_PROCESSING         0x80000000
#define WORKTYPE_UNKNOWN            0x00000000

#define WORKTYPE_ANNOUNCE_SERVER    0x00000001
#define WORKTYPE_ANNOUNCETOESERVER  0x00000002
#define WORKTYPE_ANNOUNCE_RESPONSE  0x00000003
#define WORKTYPE_ANNOUNCE_LKP       0x00000004
#define WORKTYPE_SYNC_LKP           0x00000005 
#define WORKTYPE_RETURN_LKP         0x00000006
#define WORKTYPE_RETURN_LICENSE     0x00000007 

typedef enum {
    TLS_WORKOBJECT_RUNONCE=0,
    TLS_WORKOBJECT_SESSION,
    TLS_WORKOBJECT_PERSISTENT
} TLSWORKOBJECTTYPE;

//------------------------------------------------

template <  class T, 
            DWORD WORKTYPE, 
            TLSWORKOBJECTTYPE WORKOBJECTTYPE, 
            DWORD WORKINTERVAL = DEFAULT_JOB_INTERVAL, 
            DWORD WORKRESTARTTIME = INFINITE,
            DWORD RETRYTIMES = 0,
            DWORD MAXJOBDESCSIZE = MAX_JOB_DESCRIPTION >
class CTLSWorkObject : public virtual CWorkObject {

protected:

    TCHAR   m_szJobDescription[MAXJOBDESCSIZE + 1];

    T* m_pbWorkData;            // Work related data.
    DWORD m_cbWorkData;         // size of work related data.
    DWORD m_dwRetryTimes;       // number of retry times.
    DWORD m_dwWorkInterval;     // work interval
    DWORD m_dwWorkRestartTime;  // work restart time.


    //
    // Max. JetBlue bookmark - esent.h
    //
    BYTE   m_pbStorageJobId[JET_cbBookmarkMost+1];
    DWORD  m_cbStorageJobId;

    typedef CTLSWorkObject<
                    T, 
                    WORKTYPE, 
                    WORKOBJECTTYPE, 
                    WORKINTERVAL, 
                    WORKRESTARTTIME, 
                    RETRYTIMES,
                    MAXJOBDESCSIZE
    >  BASECAST;

public:

    //---------------------------------------------------------------
    static BOOL WINAPI
    DeleteWorkObject(
        IN CWorkObject* ptr
        )
    /*++

    Abstract:

        Class static function to delete a job and free its memory.

    Parameter:

        ptr : Pointer to CWorkObject.

    Return:

        TRUE/FALSE.

    Note:

        Both work manager and work storage operate on 
        CWorkObject class and its has no idea the actual derive 
        class, pointer to CWorkObject is not the actual pointer to 
        our derived class, trying to delete will cause error from
        heap manager.

    --*/
    {
        BASECAST* pJob = NULL;
        DWORD dwStatus = ERROR_SUCCESS;

        try {
            //
            // Cast it to our class to get the right
            // memory pointer, dynamic_cast will throw
            // exception if it can't cast to what we want.
            //
            pJob = dynamic_cast<BASECAST *>(ptr);
            pJob->EndJob();
            delete pJob;
        }
        catch( SE_Exception e ) {
            pJob = NULL;
            SetLastError(dwStatus = e.getSeNumber());
        }
        catch(...) {
            pJob = NULL;
            SetLastError(TLS_E_WORKMANAGER_INTERNAL);
        }

        return dwStatus == ERROR_SUCCESS;
    }

    //---------------------------------------------
    virtual T*
    GetWorkData() { return m_pbWorkData; }

    virtual DWORD
    GetWorkDataSize() { return m_cbWorkData; }
    

    //---------------------------------------------
    CTLSWorkObject(
        IN DWORD bDestructorDelete = TRUE,
        IN T* pbData = NULL,
        IN DWORD cbData = 0
        ) :
    CWorkObject(bDestructorDelete),
    m_dwWorkInterval(WORKINTERVAL),
    m_pbWorkData(NULL),
    m_cbWorkData(0),
    m_dwRetryTimes(RETRYTIMES),
    m_dwWorkRestartTime(WORKRESTARTTIME),
    m_cbStorageJobId(0)
    /*++

    Abstract:

        Class constructor

    Parameter:

        See parameter list.

    Return:

        None or exception.

    --*/
    {
        DWORD dwStatus;
        BOOL bSuccess = FALSE;

        memset(m_pbStorageJobId, 0, sizeof(m_pbStorageJobId));
        
        if(pbData != NULL && cbData != 0)
        {
            bSuccess = SetWorkObjectData(
                                        pbData,
                                        cbData
                                    );

            if(bSuccess == FALSE)
            {
                dwStatus = GetLastError();
                TLSASSERT(FALSE);
                RaiseException(
                               dwStatus,
                               0,
                               0,
                               NULL
                               );
            }
        }
    }

    //---------------------------------------------
    ~CTLSWorkObject()
    {
        Cleanup();
    }

    //------------------------------------------------------------
    // 
    virtual BOOL
    IsWorkPersistent() 
    {
        return (WORKOBJECTTYPE == TLS_WORKOBJECT_PERSISTENT);
    }
        
    //------------------------------------------------------------
    // 
    virtual BOOL
    IsValid() 
    /*++

    Abstract:

        Verify if current work object is valid.

    Parameter:

        None.

    Return:

        TRUE/FALSE.

    --*/
    {
        if(VerifyWorkObjectData(TRUE, m_pbWorkData, m_cbWorkData) == FALSE)
        {
            return FALSE;
        }

        return CWorkObject::IsValid();
    }

    //------------------------------------------------------------
    // 
    virtual void
    Cleanup()
    /*++

    Abstract:

        Clean up/free memory allocated inside of this work object.

    Parameter:

        None.

    Returns:

        None.

    --*/        
    {
        if(m_pbWorkData != NULL && m_cbWorkData != 0)
        {
            //
            // Call derive class cleanup routine.
            //
            CleanupWorkObjectData(
                                &m_pbWorkData, 
                                &m_cbWorkData
                            );
        }

        m_pbWorkData = NULL;
        m_cbWorkData = 0;

        memset(m_pbStorageJobId, 0, sizeof(m_pbStorageJobId));
        m_cbStorageJobId = 0;

        CWorkObject::Cleanup();
    }

    //------------------------------------------------------------
    //
    virtual DWORD 
    GetWorkType()
    {
        return WORKTYPE;
    }

    //-----------------------------------------------------------
    //
    virtual BOOL
    SetWorkObjectData(
        IN T* pbData,
        IN DWORD cbData
        )
    /*++

    Abstract:

        Set work object associated data.

    Parameter:

        pbData : Pointer to data.
        cbData : size of data.

    Return:

        TRUE/FALSE.

    Note:

        This routine calls derive class supplied CopyWorkObjectData()
        to copy the data, how it allocate memory is derived class specific

    --*/
    {
        BOOL bSuccess = TRUE;

        if(pbData == NULL || cbData == 0)
        {
            bSuccess = FALSE;
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        if(bSuccess == TRUE)
        {
            bSuccess = VerifyWorkObjectData(
                                        FALSE, 
                                        pbData, 
                                        cbData
                                    );
        }

        if(bSuccess == TRUE && m_pbWorkData != NULL && m_cbWorkData != 0)
        {
            bSuccess = CleanupWorkObjectData(
                                        &m_pbWorkData, 
                                        &m_cbWorkData
                                    );
        }

        if(bSuccess == TRUE)
        {
            bSuccess = CopyWorkObjectData(
                                    &m_pbWorkData, 
                                    &m_cbWorkData, 
                                    pbData,
                                    cbData
                                );
        }

        return bSuccess;
    }
    //--------------------------------------------------------------
    virtual BOOL
    SelfDestruct()
    /*++

    Abstract:

        Clean up and delete memory associated with this work object.

    Parameters:

        None.

    Return:

        TRUE/FALSE, use GetLastError() to get the error code.

    --*/
    {
        return DeleteWorkObject(this);
    }
    
    //--------------------------------------------------------------
    virtual BOOL
    SetJobId(
        IN PBYTE pbData, 
        IN DWORD cbData
        )
    /*++

    Abstract:

        Set work storage assigned Job ID to this work object, for 
        session/run once work object, this routine will never be invoked

    Parameters:

        pbData : Work storage assigned Job ID.
        cbData : size of Job ID.

    Return:

        TRUE/FALSE.

    --*/
    {
        BOOL bSuccess = TRUE;

        if(cbData >= JET_cbBookmarkMost)
        {
            TLSASSERT(cbData < JET_cbBookmarkMost);
            bSuccess = FALSE;
        }
        else
        {
            memcpy(m_pbStorageJobId, pbData, cbData);
            m_cbStorageJobId = cbData;
        }
                    
        return bSuccess;
    }

    //-----------------------------------------------------------
    virtual BOOL
    GetJobId(
        OUT PBYTE* ppbData, 
        OUT PDWORD pcbData
        )
    /*++

    Abstract:

        Get work storage assigned job ID.

    Parameter:

        ppbData : Pointer to pointer to buffer to receive the job ID.
        pcbData : Pointer to DWORD to receive size of data.

    Returns:

        TRUE/FALSE.

    Note:

        Base class simply return the pointer to object's job ID pointer,
        do not free the returned pointer.

    --*/
    {
        BOOL bSuccess = TRUE;

        if(ppbData != NULL && pcbData != NULL)
        {
            *ppbData = (m_cbStorageJobId > 0) ? m_pbStorageJobId : NULL;
            *pcbData = m_cbStorageJobId;
        }
        else
        {
            TLSASSERT(ppbData != NULL && pcbData != NULL);
            bSuccess = FALSE;
        } 

        return bSuccess;
    }


    //-----------------------------------------------------------
    //
    virtual BOOL
    GetWorkObjectData(
        IN OUT PBYTE* ppbData,
        IN OUT PDWORD pcbData
        )
    /*++

    Abstract:

        See GetWorkObjectData().

    Note:
        
        Needed by CWorkObject.

    --*/
    {
        return GetWorkObjectData(
                            (T **)ppbData,
                            pcbData
                        );
    }


    //-----------------------------------------------------------
    //
    virtual BOOL
    SetWorkObjectData(
        IN PBYTE pbData,
        IN DWORD cbData
        )
    /*++

    Abstract:

        See SetWorkObjectData().

    Note:

        Needed by CWorkObject.

    --*/
    {
        return CopyWorkObjectData(
                                &m_pbWorkData, 
                                &m_cbWorkData, 
                                (T *)pbData,
                                cbData
                            );
    }
    
    //-----------------------------------------------------------
    //
    virtual BOOL
    GetWorkObjectData(
        IN OUT T** ppbData,
        IN OUT PDWORD pcbData
        )
    /*++

    Abstract:

        Return work object related data.


    Parameter:

        ppbData :
        pcbData :

    return:
    
        Always TRUE.


    Note:

        Simply return pointer to object's work data, do not free
        the return pointer.

    --*/
    {
        if(ppbData != NULL)
        {
            *ppbData = m_pbWorkData;
        }

        if(pcbData != NULL)
        {
            *pcbData = m_cbWorkData;
        }

        return TRUE;
    }

    //----------------------------------------------------------
    virtual void
    EndJob() 
    /*++

    Abstract:

        End of job processing, work manager or storage manager will
        invoke object's EndJob() to inform it that job has completed.

    Parameter:

        None.

    Returns:

        None.

    --*/
    {
        Cleanup();
    }

    //----------------------------------------------------------
    virtual BOOL
    IsJobCompleted()
    /*++

    Abstract:

        Return whether work manager or work storage manager can delete
        this job from its queue.

    Parameter:

        None.

    Returns:

        TRUE/FALSE

    --*/
    {
        return IsJobCompleted( 
                            m_pbWorkData,
                            m_cbWorkData 
                        );
    }

    //----------------------------------------------------------
    virtual DWORD
    GetSuggestedScheduledTime()
    /*++

    Abstract:

        Return next time to invoke this job again.

    Parameter:

        None:

    Returns:

        Time relative to current time or INFINITE if no additional
        processing of this job is requred.

    --*/
    {
        return (IsJobCompleted() == TRUE) ? INFINITE : m_dwWorkInterval;
    }

    //----------------------------------------------------------
    virtual DWORD
    GetJobRestartTime() 
    { 
        return m_dwWorkRestartTime; 
    }

    //----------------------------------------------------------
    virtual void
    SetJobRestartTime(
        DWORD dwTime
        ) 
    /*++

    --*/
    { 
        m_dwWorkRestartTime = dwTime;
    }

    //----------------------------------------------------------
    virtual void
    SetJobInterval(
        IN DWORD dwInterval
    )
    /*++

    Abstract:

        Set work interval.

    Parameter:

        dwInterval : new work interval.

    Returns:

        None.

    --*/
    {
        m_dwWorkInterval = dwInterval;
        return;
    }

    //---------------------------------------------------------
    virtual DWORD
    GetJobInterval()
    /*++

    Abstract:

        Retrive work interval, in second, associated with this job.

    Parameter:

        None.

    Returns:

        Job interval associated with this job.

    --*/
    {
        return m_dwWorkInterval;
    }
    
    //--------------------------------------------------------
    virtual void 
    SetJobRetryTimes(
        IN DWORD dwRetries
        )
    /*++

    --*/
    {
        m_dwRetryTimes = dwRetries;
        return;
    }

    //--------------------------------------------------------
    virtual DWORD
    GetJobRetryTimes() { return m_dwRetryTimes; }
        
    //------------------------------------------------------------    
    //
    // General Execute() function, derived class should supply
    // its own UpdateJobNextScheduleTime() to update run interval
    //
    virtual DWORD
    Execute() 
    {
        DWORD dwStatus = ERROR_SUCCESS;

        dwStatus = ExecuteJob( m_pbWorkData, m_cbWorkData );

        return dwStatus;
    }

    //------------------------------------------------------------
    //  
    // Each Derived Class must supply following
    //
    virtual BOOL 
    VerifyWorkObjectData(
        IN BOOL bCallbyIsValid,
        IN T* pbData,
        IN DWORD cbData
    );

    virtual BOOL
    CopyWorkObjectData(
        OUT T** ppbDest,
        OUT DWORD* pcbDest,
        IN T* pbSrc,
        IN DWORD cbSrc
    );

    virtual BOOL
    CleanupWorkObjectData(
        IN OUT T** ppbData,
        IN OUT DWORD* pcbData
    );

    virtual BOOL
    IsJobCompleted(
        IN T* pbData,
        IN DWORD cbData
    );

    virtual DWORD
    ExecuteJob(
        IN T* pbData,
        IN DWORD cbData
    );

    virtual LPCTSTR
    GetJobDescription();
};


//-----------------------------------------------------------------------------
//
//
//  CWorkObject
//      |
//      +---- CTLSWorkObject <-- template class
//                  |
//                  +---- CAnnounceLserver   (Announce License Server)
//                  |
//                  +---- CAnnounceToEServer (Announe server to enterprise server)        
//                  |
//                  +---- CSsyncLicensePack (Synchronize Local License Pack)
//                  |
//                  +---- CReturnLicense (Return/Revoke Client License)
//                  |
//                  +---- CAnnounceResponse (Reponse to server announcement)
//
// CAnnounceLS, CSyncLKP, CAnnounceLKP is run once.
// CAnnounceLSToEServer is session work object
//

//-----------------------------------------------------------
//
// Announce License Server to other license server.
//
#define CURRENT_ANNOUNCESERVEWO_STRUCT_VER  0x00010000
#define ANNOUNCESERVER_DESCRIPTION          _TEXT("Announce License Server")
#define TLSERVER_ENUM_TIMEOUT               5*1000
#define TLS_ANNOUNCESERVER_INTERVAL         60  // one min. interval
#define TLS_ANNOUNCESERVER_RETRYTIMES       3

typedef struct __AnnounceServerWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    DWORD dwRetryTimes;
    TCHAR m_szServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szScope[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szServerName[LSERVER_MAX_STRING_SIZE+2];
    FILETIME m_ftLastShutdownTime;
} ANNOUNCESERVERWO, *PANNOUNCESERVERWO, *LPANNOUNCESERVERWO;

typedef CTLSWorkObject<
            ANNOUNCESERVERWO, 
            WORKTYPE_ANNOUNCE_SERVER, 
            TLS_WORKOBJECT_SESSION,
            TLS_ANNOUNCESERVER_INTERVAL,
            INFINITE,
            TLS_ANNOUNCESERVER_RETRYTIMES
    > CAnnounceLserver;

//-----------------------------------------------------------
//
// Announce License Server to Enterprise server
//
#define CURRENT_ANNOUNCETOESERVEWO_STRUCT_VER   0x00010000
#define ANNOUNCETOESERVER_DESCRIPTION           _TEXT("Announce License Server to Enterprise server")

typedef struct __AnnounceToEServerWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    BOOL bCompleted;
    TCHAR m_szServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szServerName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szScope[LSERVER_MAX_STRING_SIZE+2];
    FILETIME m_ftLastShutdownTime;
} ANNOUNCETOESERVERWO, *PANNOUNCETOESERVERWO, *LPANNOUNCETOESERVERWO;

typedef CTLSWorkObject<
            ANNOUNCETOESERVERWO, 
            WORKTYPE_ANNOUNCETOESERVER, 
            TLS_WORKOBJECT_SESSION,     // session work object
            DEFAULT_JOB_INTERVAL        // retry every hour    
    > CAnnounceToEServer;

//-----------------------------------------------------------
//
// Response To Server Announce
//
#define CURRENT_ANNOUNCERESPONSEWO_STRUCT_VER   0x00010000
#define ANNOUNCERESPONSE_DESCRIPTION            _TEXT("Response Announce to %s")

typedef struct __AnnounceResponseWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    BOOL bCompleted;
    TCHAR m_szTargetServerId[LSERVER_MAX_STRING_SIZE+2];

    TCHAR m_szLocalServerId[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szLocalServerName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR m_szLocalScope[LSERVER_MAX_STRING_SIZE+2];
    FILETIME m_ftLastShutdownTime;
} ANNOUNCERESPONSEWO, *PANNOUNCERESPONSEWO, *LPANNOUNCERESPONSEWO;

typedef CTLSWorkObject<
            ANNOUNCERESPONSEWO, 
            WORKTYPE_ANNOUNCE_RESPONSE, 
            TLS_WORKOBJECT_RUNONCE
    > CAnnounceResponse;


//---------------------------------------------------------
//
// Sync. license pack to remote server, this is used in
// announce newly registered license pack and push sync. 
// local license pack to a newly startup server.
//
//
#define CURRENT_SSYNCLICENSEKEYPACK_STRUCT_VER  0x00010000
#define SSYNCLICENSEKEYPACK_DESCRIPTION         _TEXT("Sync %s LKP with remote server %s")
#define SSYNCLKP_MAX_TARGET                     10
#define SSYNC_DBWORKSPACE_TIMEOUT               60*60*1000  // wait one hour for handle

typedef enum {
    SSYNC_ALL_LKP=1,
    SSYNC_ONE_LKP
} SSYNC_TYPE;

typedef struct __SsyncLocalLkpWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;
    
    // Has job completed.
    BOOL bCompleted;

    // local server ID
    TCHAR m_szServerId[LSERVER_MAX_STRING_SIZE+2];  

    // local server name.
    TCHAR m_szServerName[LSERVER_MAX_STRING_SIZE+2]; 

    // type of sync, single license pack or all license pack
    SSYNC_TYPE dwSyncType; 

    // number of license server to push sync.
    DWORD dwNumServer; 

    // list of remote server
    TCHAR m_szTargetServer[SSYNCLKP_MAX_TARGET][MAX_COMPUTERNAME_LENGTH+2];

    // remote server sync. status, TRUE if skip this server
    // FALSE otherwise.
    BOOL m_bSsync[SSYNCLKP_MAX_TARGET];
    union {
        // remote server's last sync (shutdown) time 
        FILETIME m_ftStartSyncTime;

        // license keypack internal tracking ID if this job is
        // to push sync. one license pack
        DWORD dwKeyPackId;
    };
} SSYNCLICENSEPACK, *PSSYNCLICENSEPACK, *LPSSYNCLICENSEPACK;

typedef CTLSWorkObject<
                SSYNCLICENSEPACK,
                WORKTYPE_SYNC_LKP,
                TLS_WORKOBJECT_SESSION,
                DEFAULT_JOB_INTERVAL    
            > CSsyncLicensePack;
                
//---------------------------------------------------------
//
// Return license work object.  This is a persistent job
//
#define CURRENT_RETURNLICENSEWO_STRUCT_VER      0x00010000
#define RETURNLICENSE_RETRY_TIMES               DEFAULT_PERSISTENT_JOB_RETRYTIMES
#define RETURNLICENSE_DESCSIZE                  512
#define RETURNLICENSE_DESCRIPTION               _TEXT("%d Return License %d %d to %s")
#define RETURNLICENSE_RESTARTTIME               60      // default restart time in 1 min.

#define LICENSERETURN_UPGRADE                   0x00000001
#define LICENSERETURN_REVOKED                   0x00000002
#define LICENSERETURN_REVOKE_LKP                0x00000003


typedef struct __ReturnLicenseWO {
    DWORD dwStructVersion;
    DWORD dwStructSize;

    // number of retry.
    DWORD dwNumRetry;

    // remote server setup ID.
    TCHAR szTargetServerId[LSERVER_MAX_STRING_SIZE+2];

    // remote server name.
    TCHAR szTargetServerName[LSERVER_MAX_STRING_SIZE+2];

    // number of licenses in client's license
    DWORD dwQuantity;

    // internal keypack ID this license is allocated from.
    DWORD dwKeyPackId;

    // license internal tracking ID.
    DWORD dwLicenseId;

    // Reason for return, currently ignored.
    DWORD dwReturnReason;

    // product version.
    DWORD dwProductVersion;

    // client platform ID
    DWORD dwPlatformId;

    // Product family code.
    TCHAR szOrgProductID[LSERVER_MAX_STRING_SIZE + 2];
    
    // client's encrypted HWID
    DWORD cbEncryptedHwid;
    BYTE  pbEncryptedHwid[1024];    // max. client HWID size

    // product company
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE + 2];

    // product ID.
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE + 2];

    // user name that license was issued to.
    TCHAR szUserName[ MAXCOMPUTERNAMELENGTH + 2 ];

    // machine that license was issued to.
    TCHAR szMachineName[ MAXUSERNAMELENGTH + 2 ];
} RETURNLICENSEWO, *PRETURNLICENSEWO, *LPRETURNLICENSEWO;


typedef CTLSWorkObject<
            RETURNLICENSEWO,
            WORKTYPE_RETURN_LICENSE,
            TLS_WORKOBJECT_PERSISTENT,
            DEFAULT_PERSISTENT_JOB_INTERVAL,
            RETURNLICENSE_RESTARTTIME,
            DEFAULT_PERSISTENT_JOB_RETRYTIMES, 
            RETURNLICENSE_DESCSIZE
        > CReturnLicense;

//----------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

    CWorkObject* WINAPI
    InitializeCReturnWorkObject(
        IN CWorkManager* pWkMgr,
        IN PBYTE pbWorkData,
        IN DWORD cbWorkData
    );

    DWORD
    TLSWorkManagerSchedule(
        IN DWORD dwTime,
        IN CWorkObject* pJob
    );

    void
    TLSWorkManagerShutdown();

    
    DWORD
    TLSWorkManagerInit();

    BOOL
    TLSWorkManagerSetJobDefaults(
        CWorkObject* pJob
    );

    DWORD
    TLSPushSyncLocalLkpToServer(
        IN LPTSTR pszSetupId,
        IN LPTSTR pszDomainName,
        IN LPTSTR pszLserverName,
        IN FILETIME* pSyncTime
    );

    DWORD
    TLSStartAnnounceToEServerJob(
        IN LPCTSTR pszServerId,
        IN LPCTSTR pszServerDomain,
        IN LPCTSTR pszServerName,
        IN FILETIME* pftFileTime
    );

    DWORD
    TLSStartAnnounceLicenseServerJob(
        IN LPCTSTR pszServerId,
        IN LPCTSTR pszServerDomain,
        IN LPCTSTR pszServerName,
        IN FILETIME* pftFileTime
    );

    DWORD
    TLSStartAnnounceResponseJob(
        IN LPTSTR pszTargetServerId,
        IN LPTSTR pszTargetServerDomain,
        IN LPTSTR pszTargetServerName,
        IN FILETIME* pftTime
    );

    BOOL
    TLSIsServerCompatible(
        IN DWORD dwLocalServerVersion,
        IN DWORD dwTargetServerVersion
    );

    BOOL
    TLSCanPushReplicateData(
        IN DWORD dwLocalServerVersion,
        IN DWORD dwTargetServerVersion
    );

    BOOL
    IsLicensePackRepl(
        TLSLICENSEPACK* pLicensePack
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlsrpc-s.c ===
#include <tlsrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\upgdb.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        upgrade.cpp
//
// Contents:    All database upgrade related.
//
// History:     12-09-97    HueiWang    
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "upgdb.h"
#include "globals.h"
#include "kp.h"
#include "keypack.h"
#include "lkpdesc.h"
#include "permlic.h"

//---------------------------------------------------------------------
DWORD
TLSCreateUpgradeDatabase(
    IN JBDatabase& jbDatabase
    )
/*++
Abstract:

    This routine create a empty license server database.

Parameters:

    jbDatabase : database handle.

Returns:

    Jet error code

++*/
{
    BOOL bSuccess;
    DWORD dwStatus=ERROR_SUCCESS;
    DWORD dwCurrentVersion=0;

    PBYTE pbSetupId = NULL;
    DWORD cbSetupId = 0;

    VersionTable verTable(jbDatabase);
    LicPackTable  LicPackTable(jbDatabase);
    LicensedTable LicensedTable(jbDatabase);
    LicPackDescTable LicPackDescTable(jbDatabase);
    BackupSourceTable BckSrcTable(jbDatabase);
    WorkItemTable WkItemTable(jbDatabase); 

    //--------------------------------------------------------    
    TLSVersion version_search;
    TLSVersion version_found;
    DWORD dwDbVersion;
    BOOL bUpdateVersionRec = FALSE;

   
    if(TLSIsBetaNTServer() == TRUE)
    {
        dwDbVersion = TLS_BETA_DBVERSION;
    }
    else
    {
        dwDbVersion = TLS_CURRENT_DBVERSION;
    }

    version_search.dwVersion = dwDbVersion;

    _tcsncpy(
            version_search.szInstallId, 
            (LPTSTR)g_pszServerPid, 
            min(sizeof(version_search.szInstallId)/sizeof(version_search.szInstallId[0]) - 1, g_cbServerPid/sizeof(TCHAR))
        );

    //version_search.pbDomainSid = g_pbDomainSid;
    //version_search.cbDomainSid = g_cbDomainSid;

    if(verTable.OpenTable(FALSE, TRUE) == FALSE)
    {
        JET_ERR jetErr = verTable.GetLastJetError();

        if( jetErr != JET_errObjectNotFound || 
            verTable.OpenTable(TRUE, TRUE) == FALSE ||
            verTable.InsertRecord(version_search) == FALSE )
        {
            SetLastError(
                    dwStatus = SET_JB_ERROR(verTable.GetLastJetError())
                );
            goto cleanup;
        }

        dwCurrentVersion = 0;
    }
    else
    {
        // load the version table
        // must have at least entry in the table.
        bSuccess = verTable.EnumerateBegin(
                                    FALSE, 
                                    ENUMERATE_COMPARE_NO_FIELDS, 
                                    NULL
                                );

        if(bSuccess == FALSE)
        {
            dwStatus = SET_JB_ERROR(verTable.GetLastJetError());
            SetLastError(dwStatus);
            goto cleanup;
        }

        if(verTable.EnumerateNext(version_found) != RECORD_ENUM_MORE_DATA)
        {
            SetLastError(dwStatus = TLS_E_INTERNAL);
            goto cleanup;
        }

        verTable.EnumerateEnd();

        if( DATABASE_VERSION(version_found.dwVersion) > DATABASE_VERSION(dwDbVersion) &&
            DATABASE_VERSION(version_found.dwVersion) != W2K_RTM_JETBLUE_DBVERSION )
        {
            //
            // Database was created by in-compatible license server.
            //
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Beta 3 database version 0x%08x, 0x%08x\n"),
                    version_found.dwVersion,
                    dwDbVersion
                );

            //
            // critical error, database version > what we can support
            //
            SetLastError(dwStatus = TLS_E_INCOMPATIBLEDATABSE);
            goto cleanup;
        }                

        if( TLSIsBetaNTServer() == FALSE && 
            DATABASE_VERSION(version_found.dwVersion) == W2K_BETA3_JETBLUE_DBVERSION )
        {
            //
            // 
            // Beta3 license database, wipe out and restart from scratch
            //
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Beta 3 database version 0x%08x, 0x%08x\n"),
                    version_found.dwVersion,
                    dwDbVersion
                );

            dwStatus = TLS_E_BETADATABSE;
            goto cleanup;
        }                

        if(IS_ENFORCE_VERSION(version_found.dwVersion) != IS_ENFORCE_VERSION(dwDbVersion))
        {
            //
            // Enforce/non-enforce in-compatible, wipe out database and restart from
            // scratch
            //
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Enforce/Non-enforce database 0x%08x, 0x%08x\n"),
                    version_found.dwVersion,
                    dwDbVersion
                );

            //#if ENFORCE_LICENSING
            //TLSLogWarningEvent(dwStatus = TLS_W_DB_ENFORCE_NONENFORCE);
            //#endif
            //bUpdateVersionRec = TRUE;
                
            dwStatus = TLS_E_INCOMPATIBLEDATABSE;
            goto cleanup;
        }

        //
        // Server ID
        // 
        if( _tcscmp(version_found.szInstallId, version_search.szInstallId) != 0 )
        {
            //
            // Check if this is pre-beta3 which uses GUID
            //
            dwStatus = RetrieveKey(
                                LSERVER_LSA_SETUPID,
                                &pbSetupId,
                                &cbSetupId
                            );

            if( dwStatus != ERROR_SUCCESS || 
                _tcscmp(version_found.szInstallId, (LPTSTR)pbSetupId) != 0 )
            {
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_UPGRADE,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Database does not belong to this machine\n")
                    );
                
                #if ENFORCE_LICENSING
                TLSLogWarningEvent(dwStatus = TLS_W_NOTOWNER_DATABASE);
                #endif

                bUpdateVersionRec = TRUE;
            }
        }

        if(bUpdateVersionRec == TRUE)
        {
            //
            // take ownership of this database, no other DB operation, current
            // record is still at version, update record.
            //
            if(verTable.UpdateRecord(version_search) == FALSE)
            {
                SetLastError(
                        dwStatus = SET_JB_ERROR(verTable.GetLastJetError())
                    );
                goto cleanup;
            }
        }

        dwCurrentVersion = DATABASE_VERSION(version_search.dwVersion);
    }

    //--------------------------------------------------------
    bSuccess = LicPackTable.UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(LicPackTable.GetLastJetError())
            );
        goto cleanup;
    }

    //--------------------------------------------------------
    bSuccess = LicensedTable.UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );
    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(LicensedTable.GetLastJetError())
            );

        goto cleanup;
    }


    //--------------------------------------------------------
    bSuccess = LicPackDescTable.UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            ) ;

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(LicPackDescTable.GetLastJetError())
            );
        goto cleanup;
    }

    //--------------------------------------------------------
    bSuccess = BckSrcTable.UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(BckSrcTable.GetLastJetError())
            );
        goto cleanup;
    }

    //--------------------------------------------------------
    bSuccess = WkItemTable.UpgradeTable(
                                dwCurrentVersion, 
                                DATABASE_VERSION(dwDbVersion)
                            );

    if(bSuccess == FALSE)
    {
        SetLastError(
                dwStatus = SET_JB_ERROR(WkItemTable.GetLastJetError())
            );
        goto cleanup;
    }


cleanup:

    if(pbSetupId != NULL)
    {
        LocalFree(pbSetupId);
    }

    //
    // We use global so don't free the memory
    //
    version_search.pbDomainSid = NULL;
    version_search.cbDomainSid = 0;
    verTable.CloseTable();

    return dwStatus;
}

//---------------------------------------------------------------------

BOOL
Upgrade236LicensePack(
    PTLSLICENSEPACK pLicensePack
    )
/*++

++*/
{
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    BOOL bRequireUpgrade=FALSE;

    TCHAR szPreFix[MAX_SKU_PREFIX];
    TCHAR szPostFix[MAX_SKU_POSTFIX];
    DWORD dwPlatformType;

    memset(szPreFix, 0, sizeof(szPreFix));
    memset(szPostFix, 0, sizeof(szPostFix));

    _stscanf(
            pLicensePack->szProductId,
            TERMSERV_PRODUCTID_FORMAT,
            szPreFix,
            &dwMajorVersion,
            &dwMinorVersion,
            szPostFix
        );

    if(_tcscmp(szPreFix, TERMSERV_PRODUCTID_SKU) != 0)
    {
        //
        // Not our license pack
        //
        goto cleanup;
    }

    if(_tcscmp(szPostFix, TERMSERV_FULLVERSION_TYPE) == 0)
    {
        dwPlatformType = PLATFORMID_OTHERS;
    }
    else if(_tcscmp(szPostFix, TERMSERV_FREE_TYPE) == 0)
    {
        dwPlatformType = PLATFORMID_FREE;
    }
    else
    {
        // ignore this error...
        goto cleanup;
    }

    // fix entries caused by bug 402870.
    // Remote license pack must have remote bit in status and platformtype 
    if( pLicensePack->ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE &&
        !(pLicensePack->dwPlatformType & LSKEYPACK_PLATFORM_REMOTE) ) 
    {
        pLicensePack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
        bRequireUpgrade = TRUE;
        goto cleanup;
    }

    //
    // If platform type is correct, no need to upgrade
    //
    if( (pLicensePack->dwPlatformType & ~LSKEYPACK_PLATFORM_REMOTE) == dwPlatformType )
    {
        goto cleanup;
    }

    //
    // Update platform Type.
    //
    pLicensePack->dwPlatformType = dwPlatformType;
    if( pLicensePack->ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE )
    {
        pLicensePack->dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
    }

    bRequireUpgrade = TRUE;

cleanup:

    return bRequireUpgrade;
}

//----------------------------------------------------------

DWORD
TLSAddTermServCertificatePack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bLogWarning
    )
/*++

Abstract:


    This routine add a sepecifc license pack to issuing/generating
    certificate for terminal server.

Parameter:
    
    pDbWkSpace : workspace handle.
    bLogWarning : Log low license count warning, ignore if enforce


Return:

    JET Error code.

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    TLSLICENSEPACK licensePack;
    DWORD dwKpDescStatus = ERROR_SUCCESS;


    struct tm convertTime;
    time_t expired_time;
    time_t activate_time;

    //
    // Set activation date to 1970 - client/server might not sync. up in time
    //
    memset(&convertTime, 0, sizeof(convertTime));
    convertTime.tm_year = 1980 - 1900;     // expire on 2036/1/1
    convertTime.tm_mday = 1;
    
    activate_time = mktime(&convertTime);
    if(activate_time == (time_t) -1)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't calculate keypack activate time\n")
            );

       return TLS_E_UPGRADE_DATABASE; 
    }


    //
    // Expiration date
    //
    memset(&convertTime, 0, sizeof(convertTime));
    convertTime.tm_year = 2036 - 1900;     // expire on 2036/1/1
    convertTime.tm_mday = 1;
    
    expired_time = mktime(&convertTime);
    if(expired_time == (time_t) -1)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't calculate keypack expiration time\n")
            );

       return TLS_E_UPGRADE_DATABASE; 
    }

    // Add a special keypack to hydra server
    LSKeyPack hsKeyPack;

    pDbWkSpace->BeginTransaction();

    memset(&hsKeyPack, 0, sizeof(LSKeyPack));
    hsKeyPack.ucKeyPackType = LSKEYPACKTYPE_FREE;
    SAFESTRCPY(hsKeyPack.szKeyPackId, HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID);

    if(!LoadResourceString(
                IDS_HS_COMPANYNAME, 
                hsKeyPack.szCompanyName, 
                sizeof(hsKeyPack.szCompanyName) / sizeof(hsKeyPack.szCompanyName[0])))
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't load resources for IDS_HS_COMPANYNAME\n")
            );

        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    if(!LoadResourceString(
               IDS_HS_PRODUCTNAME,
               hsKeyPack.szProductName,
               sizeof(hsKeyPack.szProductName) / sizeof(hsKeyPack.szProductName[0])))
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't load resources for IDS_HS_PRODUCTNAME\n")
            );
        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    if(!LoadResourceString(
                IDS_HS_PRODUCTDESC,
                hsKeyPack.szProductDesc,
                sizeof(hsKeyPack.szProductDesc) / sizeof(hsKeyPack.szProductDesc[0])))
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't load resources for IDS_HS_PRODUCTDESC\n")
            );
        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    SAFESTRCPY(hsKeyPack.szProductId, HYDRAPRODUCT_HS_CERTIFICATE_SKU);

    hsKeyPack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;
    hsKeyPack.dwActivateDate = activate_time;
    hsKeyPack.dwExpirationDate = expired_time;            

    hsKeyPack.wMajorVersion=HIWORD(HYDRACERT_PRODUCT_VERSION);
    hsKeyPack.wMinorVersion=LOWORD(HYDRACERT_PRODUCT_VERSION);
    hsKeyPack.dwPlatformType=CLIENT_PLATFORMID_WINDOWS_NT_FREE;
    hsKeyPack.ucLicenseType=LSKEYPACKLICENSETYPE_NEW;
    hsKeyPack.dwLanguageId=MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    hsKeyPack.ucChannelOfPurchase=LSKEYPACKCHANNELOFPURCHASE_RETAIL;
    SAFESTRCPY(hsKeyPack.szBeginSerialNumber, _TEXT("0"));
    hsKeyPack.dwTotalLicenseInKeyPack = 0;
    hsKeyPack.dwProductFlags = 0;

    dwStatus = TLSDBLicenseKeyPackAdd(
                                pDbWkSpace, 
                                &hsKeyPack
                            );

    if(dwStatus == ERROR_SUCCESS)
    {
        hsKeyPack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;
        hsKeyPack.dwActivateDate = activate_time;
        hsKeyPack.dwExpirationDate = expired_time;            

        dwStatus=TLSDBLicenseKeyPackSetStatus(
                                    pDbWkSpace, 
                                    LSKEYPACK_SET_ALLSTATUS, 
                                    &hsKeyPack
                                );

        #if DBG
        if(dwStatus != ERROR_SUCCESS)
        {
            TLSASSERT(FALSE);
        }

        if(hsKeyPack.dwKeyPackId != 1)
        {
            // this can only success in empty database.
            TLSASSERT(FALSE);
        }
        #endif
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't add keypack or set status - %d\n"),
                dwStatus
            );
    }

    pDbWkSpace->CommitTransaction();

    //
    // Begin another transaction for upgrading 236 product
    //
    pDbWkSpace->BeginTransaction();

    memset(&licensePack, 0, sizeof(licensePack));

    //
    // Terminal Server specific code...
    //
    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                FALSE,
                                LSKEYPACK_SEARCH_NONE,
                                &licensePack
                            );

    while(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    &licensePack
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            break;
        }

        if( Upgrade236LicensePack(&licensePack) == TRUE || 
            (licensePack.ucAgreementType & LSKEYPACK_REMOTE_TYPE) )
        {
            BOOL bSuccess;
            LicPackTable& licpackTable=pDbWkSpace->m_LicPackTable;

            if( licensePack.ucAgreementType & LSKEYPACK_REMOTE_TYPE ||
                licensePack.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE )
            {
                licensePack.dwPlatformType |= LSKEYPACK_PLATFORM_REMOTE;
                licensePack.ucKeyPackStatus |= LSKEYPACKSTATUS_REMOTE;
                licensePack.ucAgreementType &= ~LSKEYPACK_RESERVED_TYPE;
            }

            //
            // use the same timestamp for this record, tlsdb require update entry's timestamp 
            //
            bSuccess = licpackTable.UpdateRecord(
                                        licensePack,
                                        LICENSEDPACK_PROCESS_PLATFORMTYPE | LICENSEDPACK_PROCESS_MODIFYTIME | 
                                            LICENSEDPACK_PROCESS_AGREEMENTTYPE | LICENSEDPACK_PROCESS_KEYPACKSTATUS
                                    );

            if(bSuccess == FALSE)
            {
                dwStatus = SET_JB_ERROR(licpackTable.GetLastJetError());
            }
        }

#ifndef ENFORCE_LICENSING
        if(bLogWarning == FALSE)
        {
            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_UPGRADE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Ignore low license count warning...\n")
                );

            continue;
        }

        if(licensePack.ucAgreementType & LSKEYPACK_REMOTE_TYPE)
        {
            // don't log warning for remote license pack.
            continue;
        }

        if(licensePack.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE)
        {
            // don't log warning for remote license pack.
            continue;
        }

        //
        // log low license count warning message
        //
        if( licensePack.ucAgreementType == LSKEYPACKTYPE_OPEN ||
            licensePack.ucAgreementType == LSKEYPACKTYPE_RETAIL ||
            licensePack.ucAgreementType == LSKEYPACKTYPE_SELECT )
        {
            if(licensePack.dwNumberOfLicenses > g_LowLicenseCountWarning)
            {
                continue;
            }

            //
            LICPACKDESC kpDescSearch, kpDescFound;

            memset(&kpDescSearch, 0, sizeof(kpDescSearch));
            memset(&kpDescFound, 0, sizeof(kpDescFound));

            kpDescSearch.dwKeyPackId = licensePack.dwKeyPackId;
            kpDescSearch.dwLanguageId = GetSystemDefaultLangID();

            dwKpDescStatus = TLSDBKeyPackDescFind(
                                            pDbWkSpace,
                                            TRUE,
                                            LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                            &kpDescSearch,
                                            &kpDescFound
                                        );

            if( dwKpDescStatus == TLS_E_RECORD_NOTFOUND && 
                GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) )
            {
                // use english description
                kpDescSearch.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

                dwKpDescStatus = TLSDBKeyPackDescFind(
                                                pDbWkSpace,
                                                TRUE,
                                                LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                                &kpDescSearch,
                                                &kpDescFound
                                            );
            }

            if(dwKpDescStatus != ERROR_SUCCESS)
            {
                // ignore this.
                continue;
            }

            if( _tcsicmp( licensePack.szCompanyName, PRODUCT_INFO_COMPANY_NAME ) == 0 )
            {
                //
                // check with known termsrv product ID.
                //
                if( _tcsnicmp(  licensePack.szProductId, 
                                TERMSERV_PRODUCTID_SKU, 
                                _tcslen(TERMSERV_PRODUCTID_SKU)) == 0 )
                {
                    TLSResetLogLowLicenseWarning(
                                            licensePack.szCompanyName,
                                            TERMSERV_PRODUCTID_SKU, 
                                            MAKELONG(licensePack.wMinorVersion, licensePack.wMajorVersion),
                                            TRUE
                                        );
                }
                else if(_tcsnicmp(  licensePack.szProductId, 
                                    TERMSERV_PRODUCTID_INTERNET_SKU, 
                                    _tcslen(TERMSERV_PRODUCTID_INTERNET_SKU)) == 0 )
                {
                    TLSResetLogLowLicenseWarning(
                                            licensePack.szCompanyName,
                                            TERMSERV_PRODUCTID_INTERNET_SKU, 
                                            MAKELONG(licensePack.wMinorVersion, licensePack.wMajorVersion),
                                            TRUE
                                        );
                }
                else
                {
                    TLSResetLogLowLicenseWarning(
                                            licensePack.szCompanyName,
                                            licensePack.szProductId, 
                                            MAKELONG(licensePack.wMinorVersion, licensePack.wMajorVersion),
                                            TRUE
                                        );
                }
            }
            else
            {
                TLSResetLogLowLicenseWarning(
                                        licensePack.szCompanyName,
                                        licensePack.szProductId, 
                                        MAKELONG(licensePack.wMinorVersion, licensePack.wMajorVersion),
                                        TRUE
                                    );
            }


            {
                LPCTSTR pString[3];
                TCHAR szCount[25];
                
                memset(szCount, 0, sizeof(szCount));

                _sntprintf(
                        szCount, 
                        sizeof(szCount)/sizeof(szCount[0]) - 1,
                        _TEXT("%d"), 
                        licensePack.dwNumberOfLicenses
                    );
                            
                pString[0] = g_szComputerName;
                pString[1] = szCount;
                pString[2] = kpDescFound.szProductDesc;

                TLSLogEventString(
                        EVENTLOG_WARNING_TYPE,
                        TLS_W_LOWLICENSECOUNT,
                        sizeof(pString)/sizeof(pString[0]),
                        pString
                    );
            }
        }
#endif        
    }

    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        dwStatus = ERROR_SUCCESS;
    }
    
    TLSDBKeyPackEnumEnd( pDbWkSpace );

cleanup:
    
    if(dwStatus == ERROR_SUCCESS)
    {
        pDbWkSpace->CommitTransaction();
    }
    else
    {
        pDbWkSpace->RollbackTransaction();
    }

    return dwStatus;
}

//-----------------------------------------------------------------------------
// Upgrade License Server Database
//-----------------------------------------------------------------------------
DWORD 
TLSUpgradeDatabase(
    IN JBInstance& jbInstance,
    IN LPTSTR szDatabaseFile,
    IN LPTSTR szUserName,
    IN LPTSTR szPassword
    )
/*++

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    BOOL bSuccess;
    DWORD dwCurrentDbVersion;
    BOOL bCreateEmpty=FALSE;

    if(jbInstance.IsValid() == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        return dwStatus;
    }


    JBSession jbSession(jbInstance);
    JBDatabase jbDatabase(jbSession);

    //
    // open version table to determine the current database version stamp.
    //
    VersionTable verTable(jbDatabase);

    TLSVersion version_search;
    TLSVersion version_found;

    //----------------------------------------------------------
    //
    // initialize a session, then database
    //
    bSuccess = jbSession.BeginSession(szUserName, szPassword);
    if(bSuccess == FALSE)
    {
        LPTSTR pString = NULL;

        TLSGetESEError(jbSession.GetLastJetError(), &pString);
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_BEGINSESSION,
                jbSession.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_UPGRADE,
                DBG_ALL_LEVEL,
                _TEXT("Can't start a jet session - %d\n"),
                jbSession.GetLastJetError()
            );
        SetLastError(dwStatus = TLS_E_UPGRADE_DATABASE);
        goto cleanup;
    }

    //
    // Open the database
    //
    bSuccess = jbDatabase.OpenDatabase(szDatabaseFile);
    if( bSuccess == FALSE )
    {
        JET_ERR jetErr = jbDatabase.GetLastJetError();

        if(jetErr == JET_errDatabaseCorrupted)
        {
            //
            // report corrupted database
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_CORRUPT_DATABASE
                );

            SetLastError(dwStatus = TLS_E_CORRUPT_DATABASE);
            goto cleanup;
        }
        else if(jetErr != JET_errFileNotFound)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(jetErr, &pString);

            //
            // other type of error
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_OPENDATABASE,
                    szDatabaseFile,
                    jbDatabase.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
                                
            dwStatus = SET_JB_ERROR(jetErr);
            SetLastError(dwStatus);
            goto cleanup;
        }

        //
        // database does not exist, create one
        //
        bSuccess = jbDatabase.CreateDatabase(szDatabaseFile);
        if(bSuccess == FALSE)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(jbDatabase.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_CREATEDATABASE,
                    szDatabaseFile,
                    jbDatabase.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_JETBLUE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Error : can't create new database - error code %d\n"),
                    jbDatabase.GetLastJetError()
                );

            dwStatus = SET_JB_ERROR(jbDatabase.GetLastJetError());
            SetLastError(dwStatus);
            goto cleanup;
        }

        bCreateEmpty=TRUE;
    }

    jbSession.BeginTransaction();

    //
    // Create/upgrade all the tables
    //
    dwStatus = TLSCreateUpgradeDatabase(
                                    jbDatabase
                                );

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        jbSession.RollbackTransaction();
    }
    else
    {
        jbSession.CommitTransaction();
    }

cleanup:

    jbDatabase.CloseDatabase();
    jbSession.EndSession();

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        return dwStatus;
    }

    return (bCreateEmpty) ? TLS_I_CREATE_EMPTYDATABASE : dwStatus;
}

//---------------------------------------------------------------------
DWORD
TLSLogRemoveLicenseEvent(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN PTLSLICENSEPACK plicensePack,
    IN DWORD dwNumLicenses
    )
/*++

Abstract:

    Log a 'license has been removed' event.

Parameter:

    pDbWkSpace : DB work space handle.
    pLicensePack : Pointer to license pack that available licenses
                   are to be remove.
    dwNumLicenses : Number of licenses has been removed.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwKpDescStatus = ERROR_SUCCESS;

    //
    LICPACKDESC kpDescSearch, kpDescFound;

    memset(&kpDescSearch, 0, sizeof(kpDescSearch));
    memset(&kpDescFound, 0, sizeof(kpDescFound));

    kpDescSearch.dwKeyPackId = plicensePack->dwKeyPackId;
    kpDescSearch.dwLanguageId = GetSystemDefaultLangID();

    dwKpDescStatus = TLSDBKeyPackDescFind(
                                    pDbWkSpace,
                                    TRUE,
                                    LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                    &kpDescSearch,
                                    &kpDescFound
                                );

    if( dwKpDescStatus == TLS_E_RECORD_NOTFOUND && 
        GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) )
    {
        // use english description
        kpDescSearch.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        dwKpDescStatus = TLSDBKeyPackDescFind(
                                        pDbWkSpace,
                                        TRUE,
                                        LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_LANGID,
                                        &kpDescSearch,
                                        &kpDescFound
                                    );

    }

    if(dwKpDescStatus == ERROR_SUCCESS || dwKpDescStatus == TLS_E_RECORD_NOTFOUND)
    {
        //
        // Log event.
        //
        TCHAR szNumLicenses[25];
        LPCTSTR pString[3];

        wsprintf(
                szNumLicenses, 
                _TEXT("%d"), 
                dwNumLicenses
            );

        pString[0] = szNumLicenses;
        pString[1] = (dwKpDescStatus == ERROR_SUCCESS) ? 
                                        kpDescFound.szProductDesc :
                                        plicensePack->szProductId;

        pString[2] = g_szComputerName;
                                    
        TLSLogEventString(
                EVENTLOG_WARNING_TYPE,
                TLS_W_REMOVELICENSES,
                sizeof(pString)/sizeof(pString[0]),
                pString
            );

        dwKpDescStatus = ERROR_SUCCESS;
    }    

    return dwKpDescStatus;
}

//---------------------------------------------------------------------
DWORD
TLSRemoveLicensesFromInvalidDatabase(
    IN PTLSDbWorkSpace pDbWkSpace
    )
/*++

Abstract:

    Remove available licenses from all license pack.

Parameter:

    pDbWkSpace : Pointer to DB work space handle.

Return:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(pDbWkSpace == NULL)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }


    pDbWkSpace->BeginTransaction();

    // all license keypack inserted has the setup id on it.
    TLSLICENSEPACK found;    

    memset( &found, 0, sizeof(found) );

    dwStatus = TLSDBKeyPackEnumBegin(
                                pDbWkSpace,
                                FALSE,
                                LSKEYPACK_SEARCH_NONE,
                                &found
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        TLSASSERT(FALSE);
        goto cleanup;
    }

    while(dwStatus == ERROR_SUCCESS)
    {
        dwStatus = TLSDBKeyPackEnumNext(
                                    pDbWkSpace,
                                    &found
                                );

        if(dwStatus != ERROR_SUCCESS)
        {
            continue;
        }

        if( _tcsicmp(found.szKeyPackId, HYDRAPRODUCT_HS_CERTIFICATE_KEYPACKID) == 0 &&
            _tcsicmp(found.szProductId, HYDRAPRODUCT_HS_CERTIFICATE_SKU) == 0 )
        {
            // don't touch terminal server certificate keypack
            continue;
        }

        if( (found.ucAgreementType & LSKEYPACK_REMOTE_TYPE) ||
            (found.ucKeyPackStatus & LSKEYPACKSTATUS_REMOTE) )
        {
            #if 0
            // Don't bother about remote keypack
            // remote license keypack, delete it.
            dwStatus = TLSDBKeyPackDeleteEntry(
                                        pDbWkSpace,
                                        TRUE,
                                        &found
                                    );

            //
            // non-critical error if failed.
            //
            #endif

            dwStatus = ERROR_SUCCESS;
            continue;
        }

        UCHAR ucAgreementType = found.ucAgreementType & ~LSKEYPACK_RESERVED_TYPE;
        UCHAR ucKeyPackStatus = found.ucKeyPackStatus &  ~LSKEYPACKSTATUS_RESERVED;

        if(ucKeyPackStatus == LSKEYPACKSTATUS_RETURNED)
        {
            //
            // This license pack has been restored before.
            //
            continue;
        }

        // 
        // Select, retail, concurrent, open
        //
        if( ucAgreementType == LSKEYPACKTYPE_SELECT ||
            ucAgreementType == LSKEYPACKTYPE_RETAIL ||
            ucAgreementType == LSKEYPACKTYPE_CONCURRENT ||
            ucAgreementType == LSKEYPACKTYPE_OPEN )
        {
            DWORD dwNumLicenses = found.dwNumberOfLicenses;

            // 
            // Mark license pack returned so that no license can be issued
            // from this license pack.
            //
            found.ucKeyPackStatus = LSKEYPACKSTATUS_RETURNED;
            dwStatus = TLSDBKeyPackUpdateEntry(
                                            pDbWkSpace,
                                            TRUE,
                                            LSKEYPACK_EXSEARCH_KEYPACKSTATUS,
                                            &found
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_UPGRADE,
                        DBG_ALL_LEVEL,
                        _TEXT("TLSDBKeyPackUpdateEntry() failed  - %d\n"),
                        dwStatus
                    );

                TLSASSERT(FALSE);               
                continue;
            }
            
            // log an event
            dwStatus = TLSLogRemoveLicenseEvent(
                                            pDbWkSpace,
                                            &found,
                                            dwNumLicenses
                                        );

            if(dwStatus != ERROR_SUCCESS)
            {
                continue;
            }
        }
    }

    TLSDBKeyPackEnumEnd(pDbWkSpace);

    if(dwStatus == TLS_I_NO_MORE_DATA)
    {
        dwStatus = ERROR_SUCCESS;
    }
    else if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

cleanup:

    if(TLS_ERROR(dwStatus) == TRUE)
    {
        pDbWkSpace->RollbackTransaction(); 
    }
    else
    {
        pDbWkSpace->CommitTransaction();
    }    

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\upgdb.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       upgdb.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __UPGDB_H_
#define __UPGDB_H_
#include "server.h"


#ifdef __cplusplus
extern "C" {
#endif

DWORD 
TLSUpgradeDatabase(
    IN JBInstance& jbInstance,
    IN LPTSTR szDatabaseFile,
    IN LPTSTR szUserName,
    IN LPTSTR szPassword
);

DWORD
TLSAddTermServCertificatePack(
    IN PTLSDbWorkSpace pDbWkSpace,
    IN BOOL bLogWarning
);


DWORD
TLSRemoveLicensesFromInvalidDatabase(
    IN PTLSDbWorkSpace pDbWkSpace
);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\tlsrpc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        tlsrpc.c
//
// Contents:    Various RPC function to accept client request
//
// History:     12-09-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "gencert.h"
#include "kp.h"
#include "keypack.h"
#include "clilic.h"
#include "postjob.h"
#include "srvlist.h"
#include "utils.h"
#include "misc.h"
#include "licreq.h"
#include "conlic.h"
#include "globals.h"
#include "db.h"
#include "tlscert.h"
#include "permlic.h"
#include "remotedb.h"

  

CCMutex g_AdminLock;
CCMutex g_RpcLock;
CCEvent g_ServerShutDown(TRUE, FALSE);

BOOL 
VerifyLicenseRequest(
    PTLSLICENSEREQUEST pLicenseRequest
    )
/*++

--*/
{
    BOOL bValid = FALSE;

    if(pLicenseRequest == NULL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid input\n")
            );

        goto cleanup;
    }

    if( pLicenseRequest->cbEncryptedHwid == 0 || 
        pLicenseRequest->pbEncryptedHwid == NULL)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid HWID\n")
            );


        goto cleanup;
    }

    if( pLicenseRequest->ProductInfo.cbCompanyName == 0 || 
        pLicenseRequest->ProductInfo.pbCompanyName == NULL )
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid company name\n")
            );


        goto cleanup;
    }

    if( pLicenseRequest->ProductInfo.cbProductID == 0 || 
        pLicenseRequest->ProductInfo.pbProductID == NULL )
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("VerifyLicenseRequest() invalid product id\n")
            );


        goto cleanup;
    }

    bValid = TRUE;

cleanup:

    return bValid;
}


/////////////////////////////////////////////////////////////////////////////

BOOL 
WaitForMyTurnOrShutdown(
    HANDLE hHandle, 
    DWORD dwWaitTime
    )
/*


*/
{
    // 
    // Shutdown event is first one in the wait list
    // reason is when service thread signal shutdow, at the same time,
    // there might be a RPC call entering WaitForMultipleObjects() call and
    // it will return WAIT_OBJECT_0 and continue on, this is not desirable
    // since we want it to return can't get handle and exit RPC call immediately
    //
    HANDLE  waitHandles[2]={g_ServerShutDown.hEvent, hHandle};
    DWORD   dwStatus;

    //
    // Could be return shutting down...
    //
    dwStatus=WaitForMultipleObjects(
                        sizeof(waitHandles)/sizeof(waitHandles[0]), 
                        waitHandles, 
                        FALSE, 
                        dwWaitTime
                    );

    return (dwStatus == WAIT_OBJECT_0 + 1) || (dwStatus == WAIT_ABANDONED_0 + 1);
}

//////////////////////////////////////////////////////

HANDLE
GetServiceShutdownHandle()
{
    return g_ServerShutDown.hEvent;
}

void 
ServiceSignalShutdown()
{
    g_ServerShutDown.SetEvent();
}

void 
ServiceResetShutdownEvent()
{
    g_ServerShutDown.ResetEvent();
}

BOOL
IsServiceShuttingdown()
{
    return (WaitForSingleObject(g_ServerShutDown.hEvent, 0) == WAIT_OBJECT_0);
}


//////////////////////////////////////////////////////

BOOL 
AcquireRPCExclusiveLock(
    IN DWORD dwWaitTime
    )

/*++

Abstract:

    Acquire exclusive lock for RPC interface.

Parameter:

    dwWaitTime : Wait time.

Return:

    TRUE/FALSE

--*/

{
    return WaitForMyTurnOrShutdown(
                                g_RpcLock.hMutex,
                                dwWaitTime
                            );
}

//////////////////////////////////////////////////////

void
ReleaseRPCExclusiveLock()
{
    g_RpcLock.Unlock();
}

//////////////////////////////////////////////////////

BOOL
AcquireAdministrativeLock(
    IN DWORD dwWaitTime
    )
/*++

Abstract:

    Acquire lock for administrative action.

Parameter:

    dwWaitTime : Time to wait for the lock.

Returns:

    TRUE/FALSE.

--*/

{
    return WaitForMyTurnOrShutdown(
                                g_AdminLock.hMutex, 
                                dwWaitTime
                            );
}

//////////////////////////////////////////////////////

void
ReleaseAdministrativeLock()
/*++

--*/
{
    g_AdminLock.Unlock();
}


//-----------------------------------------------------------------------

DWORD 
TLSVerifyHydraCertificate(
    PBYTE pHSCert, 
    DWORD cbHSCert
    )
/*

*/
{
    DWORD dwStatus;

    dwStatus = TLSVerifyProprietyChainedCertificate(
                                        g_hCryptProv, 
                                        pHSCert, 
                                        cbHSCert
                                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        Hydra_Server_Cert hCert;

        memset(&hCert, 0, sizeof(Hydra_Server_Cert));

        dwStatus=UnpackHydraServerCertificate(pHSCert, cbHSCert, &hCert);
        if(dwStatus == LICENSE_STATUS_OK)
        {
            dwStatus=LicenseVerifyServerCert(&hCert);

            if(hCert.PublicKeyData.pBlob)
                free(hCert.PublicKeyData.pBlob);

            if(hCert.SignatureBlob.pBlob)
                free(hCert.SignatureBlob.pBlob);
        }
    }

    return dwStatus;
}

//-------------------------------------------------------------------------
// 
//  General RPC routines
//

void * __RPC_USER 
MIDL_user_allocate(size_t size)
{
    void* ptr=AllocateMemory(size);

    // DBGPrintf(0xFFFFFFFF, _TEXT("Allocate 0x%08x, size %d\n"), ptr, size);
    return ptr;
}

void __RPC_USER 
MIDL_user_free(void *pointer)
{
    FreeMemory(pointer);
}


//-------------------------------------------------------------------------

BOOL 
ValidContextHandle(
    IN PCONTEXT_HANDLE phContext
    )
/*++
Description: 

    Verify client context handle.

Arguments:

    phContext - client context handle return from TLSRpcConnect().


Return:

    TRUE/FALSE

++*/
{
#if DBG

    BOOL bValid;
    LPCLIENTCONTEXT lpClientContext = (LPCLIENTCONTEXT)phContext;

    bValid = (lpClientContext->m_PreDbg[0] == 0xcdcdcdcd && lpClientContext->m_PreDbg[1] == 0xcdcdcdcd &&
              lpClientContext->m_PostDbg[0] == 0xcdcdcdcd && lpClientContext->m_PostDbg[1] == 0xcdcdcdcd);
    if(!bValid)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("ValidContextHandle : Bad client context\n")
            );

        TLSASSERT(FALSE);
    }

    return bValid;

#else

    return TRUE;

#endif
}

//-------------------------------------------------------------------------

void 
__RPC_USER PCONTEXT_HANDLE_rundown(
    PCONTEXT_HANDLE phContext
    )
/*++

Description:

    Client context handle cleanup, called when client disconnect normally 
    or abnormally, see context handle rundown routine help on RPC

Argument:

    phContext - client context handle.

Returns:

    None

++*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("PCONTEXT_HANDLE_rundown...\n")
        );

    TLSASSERT(phContext != NULL);

    try {
        
        //
        // If service is shutting down, exit right away without freeing up memory,
        //
        // Durning shutdown, RPC wait until all call completed but it does not wait
        // until all open connection has 'rundown' if client is still in enumeration,
        // this will cause ReleaseWorkSpace() to assert.  Instead of using one more
        // HANDLE to wait until all open connection has been rundown, we return right
        // away to speed up shutdown time
        //
        if( phContext && ValidContextHandle(phContext) )
        {
            LPCLIENTCONTEXT lpClientContext = (LPCLIENTCONTEXT)phContext;

            DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("Disconnect from %s\n"),
                    lpClientContext->m_Client
                );            

            assert(lpClientContext->m_RefCount == 0);
        
            if( IsServiceShuttingdown() == FALSE )
            {
                switch(lpClientContext->m_ContextType)
                {
                    case CONTEXTHANDLE_LICENSE_ENUM_TYPE:
                        {
                            PTLSDbWorkSpace pDbWkSpace = (PTLSDbWorkSpace)lpClientContext->m_ContextHandle;

                            if( IsValidAllocatedWorkspace(pDbWkSpace) == TRUE )
                            {
                                ReleaseWorkSpace(&pDbWkSpace);
                            }
                        }
                        break;

                    case CONTEXTHANDLE_KEYPACK_ENUM_TYPE:
                        {
                            LPENUMHANDLE hEnum=(LPENUMHANDLE)lpClientContext->m_ContextHandle;

                            if( IsValidAllocatedWorkspace(hEnum->pbWorkSpace) == TRUE )
                            {
                                TLSDBLicenseKeyPackEnumEnd(hEnum);
                            }

                            lpClientContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
                            lpClientContext->m_ContextHandle=NULL;
                        }
                        break;

                    case CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE:
                        {
                            LPTERMSERVCERTREQHANDLE lpHandle=(LPTERMSERVCERTREQHANDLE)lpClientContext->m_ContextHandle;
                            midl_user_free(lpHandle->pCertRequest);
                            midl_user_free(lpHandle->pbChallengeData);
                            FreeMemory(lpHandle);
                        }
                        break;

                    case CONTEXTHANDLE_CHALLENGE_SERVER_TYPE:
                    case CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE:
                    case CONTEXTHANDLE_CHALLENGE_TERMSRV_TYPE:
                        {
                            PTLSCHALLENGEDATA pChallengeData = (PTLSCHALLENGEDATA) lpClientContext->m_ContextHandle;
                            if(pChallengeData)
                            {
                                FreeMemory(pChallengeData->pbChallengeData);
                                FreeMemory(pChallengeData);
                            }
                        }
                }
            }
            else
            {
                DBGPrintf(
                    DBG_INFORMATION,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_TRACE,
                    _TEXT("PCONTEXT_HANDLE_rundown while shutting down...\n")
                );
            }                
 
            if( lpClientContext->m_Client )
            {
                FreeMemory(lpClientContext->m_Client);
            }

            midl_user_free(lpClientContext);
        }
    }
    catch(...) {
        SetLastError(TLS_E_INTERNAL);
    }

    return;
}


//----------------------------------------------------------------------------------
DWORD
GetClientPrivilege(
    IN handle_t hRpcBinding
    )

/*++
Description:

    Return client's privilege level

Arguments:
    
    hRpcBinding - Client's RPC binding handle.

Return:

    Client's privilege level

++*/
{
    DWORD dwStatus = CLIENT_ACCESS_USER;
    BOOL bAdmin=FALSE;
    RPC_STATUS rpc_status;

    // If a value of zero is specified, the server impersonates the client that 
    // is being served by this server thread
    rpc_status = RpcImpersonateClient(hRpcBinding);
    if(rpc_status == RPC_S_OK)
    {
        IsAdmin(&bAdmin);
        dwStatus = (bAdmin) ? CLIENT_ACCESS_ADMIN : CLIENT_ACCESS_USER;

        RpcRevertToSelfEx(hRpcBinding);
    }

    return dwStatus;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcConnect( 
    /* [in] */ handle_t binding,
    /* [out] */ PCONTEXT_HANDLE __RPC_FAR *pphContext
    )
/*++

Description:

    Connect client and allocate/return client context handle.

Arguments:

    hRPCBinding - RPC binding handle
    pphContext - client context handle.

Returns via dwErrCode.

    RPC_S_ACCESS_DENIED or LSERVER_S_SUCCESS.

++*/
{
    DWORD status=ERROR_SUCCESS;
    DWORD dwPriv;

    RPC_BINDING_HANDLE hClient=NULL;
    WCHAR * pszRpcStrBinding=NULL;
    LPTSTR pszClient=NULL;

    if(RpcBindingServerFromClient(binding, &hClient) == RPC_S_OK)
    {
        status = RpcBindingToStringBinding( hClient, &pszRpcStrBinding );
        RpcBindingFree(&hClient);

        if (status != RPC_S_OK)
        {
            goto cleanup;
        }
    }

    //
    // need to load from resource file
    //
    pszClient = (LPTSTR)AllocateMemory(
                            (_tcslen((pszRpcStrBinding) ? pszRpcStrBinding : _TEXT("Unknown")) + 1) * sizeof(TCHAR)
                        );

    if(pszClient == NULL)
    {
        status = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    _tcscpy(pszClient,
            (pszRpcStrBinding) ? pszRpcStrBinding : _TEXT("Unknown")
        );

    if(pszRpcStrBinding)
    {
        RpcStringFree(&pszRpcStrBinding);
    }
        
    DBGPrintf(
        DBG_INFORMATION,
        DBG_FACILITY_RPC,
        DBGLEVEL_FUNCTION_TRACE,
        _TEXT("Connect from client %s\n"), 
        pszClient
    );

    dwPriv=GetClientPrivilege(binding);

    LPCLIENTCONTEXT lpContext;

    lpContext=(LPCLIENTCONTEXT)midl_user_allocate(sizeof(CLIENTCONTEXT));
    if(lpContext == NULL)
    {
        status = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_CONNECT;
    lpContext->m_PreDbg[0] = 0xcdcdcdcd;
    lpContext->m_PreDbg[1] = 0xcdcdcdcd;
    lpContext->m_PostDbg[0] = 0xcdcdcdcd;
    lpContext->m_PostDbg[1] = 0xcdcdcdcd;
    #endif

    lpContext->m_Client = pszClient;

    lpContext->m_RefCount = 0;
    *pphContext=lpContext;
    lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
    lpContext->m_ClientFlags = dwPriv;

cleanup:

    if(status != ERROR_SUCCESS)
    {
        FreeMemory(pszClient);
    }

    return TLSMapReturnCode(status);
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcDisconnect( 
    /* [out][in] */ PPCONTEXT_HANDLE pphContext
    )
/*++

Description:

    Disconnect client and FreeMemory all memory allocated on the behalf of client         

Arguments:

    pphContext - pointer to client context handle

Returns:

    LSERVER_S_SUCCESS or ERROR_INVALID_HANDLE

++*/
{
    DWORD Status=ERROR_SUCCESS;

    try {

        if(!ValidContextHandle(*pphContext) || *pphContext == NULL)
        {
            Status = ERROR_INVALID_HANDLE;
        }
        else
        {
            PCONTEXT_HANDLE_rundown(*pphContext);
            *pphContext = NULL;
        }

    }
    catch(...) {
        Status = TLS_E_INTERNAL;
    }        
    
    return TLSMapReturnCode(Status);
}

//-------------------------------------------------------------------------------

error_status_t 
TLSRpcGetVersion( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD pdwVersion
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetVersion\n"),
            lpContext->m_Client
        );

    if(TLSIsBetaNTServer() == TRUE)
    {
        *pdwVersion = TLS_CURRENT_VERSION;
    }
    else
    {
        *pdwVersion = TLS_CURRENT_VERSION_RTM;
    }

    if(g_SrvRole & TLSERVER_ENTERPRISE_SERVER)
    {
        *pdwVersion |= TLS_VERSION_ENTERPRISE_BIT;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("%s : TLSRpcGetVersion return 0x%08x\n"),
            lpContext->m_Client,
            *pdwVersion
        );

    InterlockedDecrement( &lpContext->m_RefCount );
    return RPC_S_OK;
}


//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetSupportFlags( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ DWORD *pdwSupportFlags
    )
/*++

++*/
{
    error_status_t status = RPC_S_OK;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetSupportFlags\n"),
            lpContext->m_Client
        );

    if (NULL != pdwSupportFlags)
    {
        *pdwSupportFlags = ALL_KNOWN_SUPPORT_FLAGS;
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
    }

    InterlockedDecrement( &lpContext->m_RefCount );
    return status;
}

//-------------------------------------------------------------------------------

error_status_t 
TLSRpcSendServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbCert,
    /* [size_is][in] */ PBYTE pbCert,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    This routine is for License Server to identify hydra server, hydra server
    need to send its certificate in order to gain certificate request privilege.

Arguments:

    phContext - client context handle.
    cbCert - size of hydra server certificate.
    pbCert - hydra server's self-created certificate.
    dwErrCode - return code.

Returns via dwErrCode

    LSERVER_E_INVALID_DATA.

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcSendServerCertificate\n"),
            lpContext->m_Client
        );

    try {

        if(pbCert == NULL || cbCert == 0 || 
           TLSVerifyHydraCertificate(pbCert, cbCert) != LICENSE_STATUS_OK)
        {
            DBGPrintf(
                    DBG_WARNING,
                    DBG_FACILITY_RPC,
                    DBGLEVEL_FUNCTION_DETAILSIMPLE,
                    _TEXT("TLSRpcSendServerCertificate : client %s send invalid certificate\n"),
                    lpContext->m_Client
                );

            status = TLS_E_INVALID_DATA;
        }
        else
        {
            lpContext->m_ClientFlags |= CLIENT_ACCESS_REQUEST;
        }

    }
    catch(...) {
        status = TLS_E_INVALID_DATA;
    }        

    // midl_user_free(pbCert);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SEND_CERTIFICATE;
    #endif

    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerName( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szMachineName,
    /* [out][in] */ PDWORD cbSize,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return server's machine name. 

Arguments:

    phContext - Client context handle
    szMachineName - return server's machine name, must be at least
                    MAX_COMPUTERNAME_LENGTH + 1 in length

Return:

    TLS_E_INVALID_DATA - buffer size too small.

++*/
{
    // TODO: no need for this buffer - use caller's buffer instead

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD dwBufferSize=MAX_COMPUTERNAME_LENGTH+1;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;   

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerName\n"),
            lpContext->m_Client
        );

    if(lpContext->m_ContextType != CONTEXTHANDLE_CHALLENGE_SERVER_TYPE)
    {
        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);

        return RPC_S_OK;
    }

    *dwErrCode = ERROR_SUCCESS;
    if(!GetComputerName(szComputerName, &dwBufferSize))
    {
        *dwErrCode = GetLastError();
    }

    //
    // return buffer must be big enough for NULL, 
    // dwBufferSize return does not include NULL.
    //
    if(*cbSize <= dwBufferSize)
    {
        DBGPrintf(
                DBG_WARNING,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("TLSRpcGetServerName : Client %s invalid parameter\n"),
                lpContext->m_Client
            );

        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
    }
    else
    {
        _tcsncpy(szMachineName, szComputerName, min(_tcslen(szComputerName), *cbSize));
        szMachineName[min(_tcslen(szComputerName), *cbSize - 1)] = _TEXT('\0');
    }

    *cbSize = _tcslen(szComputerName) + 1; // include NULL terminate string

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERNAME;
    #endif

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerNameEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szMachineName,
    /* [out][in] */ PDWORD cbSize,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return server's machine name. 

Arguments:

    phContext - Client context handle
    szMachineName - return server's machine name, must be at least
                    MAX_COMPUTERNAME_LENGTH + 1 in length

Return:

    TLS_E_INVALID_DATA - buffer size too small.

++*/
{
    // TODO: no need for this buffer - use caller's buffer instead

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+2];
    DWORD dwBufferSize=MAX_COMPUTERNAME_LENGTH+1;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerNameEx\n"),
            lpContext->m_Client
        );

    *dwErrCode = ERROR_SUCCESS;
    if(!GetComputerName(szComputerName, &dwBufferSize))
    {
        *dwErrCode = GetLastError();
    }

    //
    // return buffer must be big enough for NULL, 
    // dwBufferSize return does not include NULL.
    //
    if(*cbSize <= dwBufferSize)
    {
        DBGPrintf(
                DBG_WARNING,
                DBG_FACILITY_RPC,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("TLSRpcGetServerNameEx : Client %s invalid parameter\n"),
                lpContext->m_Client
            );

        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
    }
    else
    {
        _tcsncpy(szMachineName, szComputerName, min(_tcslen(szComputerName), *cbSize));
        szMachineName[min(_tcslen(szComputerName), *cbSize - 1)] = _TEXT('\0');
    }

    *cbSize = _tcslen(szComputerName) + 1; // include NULL terminate string

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERNAME;
    #endif

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerScope( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][string][out][in] */ LPTSTR szScopeName,
    /* [out][in] */ PDWORD cbSize,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return License Server's scope

Arguments:

    phContext - Client context
    szScopeName - return server's scope, must be at least 
                  MAX_COMPUTERNAME_LENGTH in length

Return:

    LSERVER_S_SUCCESS or error code from WideCharToMultiByte()
    TLS_E_INVALID_DATA - buffer size too small.

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerScope\n"),
            lpContext->m_Client
        );

    *dwErrCode = ERROR_SUCCESS;
    if(*cbSize <= _tcslen(g_pszScope))
    {
        *dwErrCode = TLSMapReturnCode(TLS_E_INVALID_DATA);
    }
    else
    {
        _tcsncpy(szScopeName, g_pszScope, min(_tcslen(g_pszScope), *cbSize));
        szScopeName[min(_tcslen(g_pszScope), *cbSize-1)] = _TEXT('\0');
    }

    *cbSize = _tcslen(g_pszScope) + 1; // include NULL terminate string

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_SERVERSCOPE;
    #endif
    
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetInfo( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbHSCert,
    /* [size_is][in] */ PBYTE pHSCert,
    /* [ref][out] */ DWORD __RPC_FAR *pcbLSCert,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSCert,
    /* [ref][out] */ DWORD __RPC_FAR *pcbLSSecretKey,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pLSSecretKey,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Routine to exchange Hydra server's certificate and License server's
    certificate/private key for signing client machine's hardware ID.

Arguments:

    phContext - client context handle
    cbHSCert - size of Hydra Server's certificate
    pHSCert - Hydra Server's certificate
    pcbLSCert - return size of License Server's certificate
    pLSCert - return License Server's certificate
    pcbLSSecretKey - return size of License Server's private key.
    pLSSecretKey - retrun License Server's private key

Return Value:  

    LSERVER_S_SUCCESS           success
    LSERVER_E_INVALID_DATA      Invalid hydra server certificate
    LSERVER_E_OUTOFMEMORY       Can't allocate required memory
    TLS_E_INTERNAL              Internal error occurred in License Server

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetInfo\n"),
            lpContext->m_Client
        );
    
    try {
        do {
            if( pHSCert == NULL || cbHSCert == 0 || 
                TLSVerifyHydraCertificate(pHSCert, cbHSCert) != LICENSE_STATUS_OK)
            {
                status= TLS_E_INVALID_DATA;
                break;
            }

            *pcbLSCert = g_cbSignatureEncodedCert;
            *pLSCert = (PBYTE)midl_user_allocate(*pcbLSCert);
            if(!*pLSCert)
            {
                status = ERROR_OUTOFMEMORY;
                break;
            }
            memcpy(*pLSCert, (PBYTE)g_pbSignatureEncodedCert, *pcbLSCert);
            
            *pcbLSSecretKey=0;
            *pLSSecretKey=NULL;
        } while(FALSE);

        if(status != ERROR_SUCCESS)
        {    
            if(*pLSCert)
                midl_user_free(*pLSCert);

            if(*pLSSecretKey)
                midl_user_free(*pLSSecretKey);

            *pcbLSCert=0;
            *pcbLSSecretKey=0;
            *pLSCert=NULL;
            *pLSSecretKey=NULL;
        }

    } 
    catch(...) {
        status = TLS_E_INTERNAL;
    }        

    // midl_user_free(pHSCert);

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GETINFO;
    #endif

    lpContext->m_LastError = status;
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------

#define RANDOM_CHALLENGE_DATA   _TEXT("TEST")

DWORD
TLSGenerateChallengeData( 
    IN DWORD ClientInfo, 
    OUT PDWORD pcbChallengeData, 
    IN OUT PBYTE* pChallengeData
    )
{
    DWORD hr=ERROR_SUCCESS;

    *pcbChallengeData = (_tcslen(RANDOM_CHALLENGE_DATA) + 1) * sizeof(WCHAR);
    *pChallengeData=(PBYTE)midl_user_allocate(*pcbChallengeData);

    if(*pChallengeData)
    {
        memcpy(*pChallengeData, RANDOM_CHALLENGE_DATA, *pcbChallengeData);
    }
    else
    {
        SetLastError(hr=ERROR_OUTOFMEMORY);
    }

    return hr;
}

//++----------------------------------------------------------------------------
DWORD
TLSVerifyChallengeDataGetWantedLicenseLevel(
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const DWORD cbChallengeData,
    IN const PBYTE pbChallengeData,
    OUT WORD* pwLicenseDetail
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    DWORD dwChallengeDataSize = (_tcslen(RANDOM_CHALLENGE_DATA) + 1) * sizeof(WCHAR);
    PPlatformChallengeResponseData pChallengeResponse;

    if( cbChallengeData < dwChallengeDataSize || pbChallengeData == NULL )
    {
        //
        // Assume old client, new client always send back our challenge data
        //
        *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
    }
    else if( cbChallengeData == dwChallengeDataSize &&
        _tcsicmp( (LPCTSTR)pbChallengeData, RANDOM_CHALLENGE_DATA ) == 0 )
    {
        //
        // old client, set license chain to LICENSE_DETAIL_SIMPLE
        //
        *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
    }
    else
    {
        BOOL bValidStruct = TRUE;

        //
        // we still don't have a good challenge so ignore actual verification
        //
        pChallengeResponse = (PPlatformChallengeResponseData) pbChallengeData;

        bValidStruct = (pChallengeResponse->wVersion == CURRENT_PLATFORMCHALLENGE_VERSION);
        if( bValidStruct == TRUE )
        {
            bValidStruct = (pChallengeResponse->cbChallenge + offsetof(PlatformChallengeResponseData, pbChallenge) == cbChallengeData);
        }

        if (bValidStruct == TRUE )
        {
            if( pChallengeResponse->wClientType == WIN32_PLATFORMCHALLENGE_TYPE ||
                pChallengeResponse->wClientType == WIN16_PLATFORMCHALLENGE_TYPE ||
                pChallengeResponse->wClientType == WINCE_PLATFORMCHALLENGE_TYPE ||
                pChallengeResponse->wClientType == OTHER_PLATFORMCHALLENGE_TYPE )
            {
                bValidStruct = TRUE;
            }
            else
            {
                bValidStruct = FALSE;
            }
        }
        
        if( bValidStruct == TRUE )
        {
            if( pChallengeResponse->wLicenseDetailLevel == LICENSE_DETAIL_SIMPLE ||
                pChallengeResponse->wLicenseDetailLevel == LICENSE_DETAIL_MODERATE ||
                pChallengeResponse->wLicenseDetailLevel == LICENSE_DETAIL_DETAIL )
            {
                bValidStruct = TRUE;
            }
            else
            {
                bValidStruct = FALSE;
            }
        }

        //
        // For now, we simply let it go thru, assert or deny request once
        // we settle down of challenge
        //
        if( bValidStruct == FALSE )
        {
            // bad data, assume old client
            *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
        }
        //else if( pChallengeResponse->wClientType == WINCE_PLATFORMCHALLENGE_TYPE )
        //{
            //
            // UN-comment this to limit WINCE to get a self-signed certificate
            //
        //    *pwLicenseDetail = LICENSE_DETAIL_SIMPLE;
        //}
        else
        {
            *pwLicenseDetail = pChallengeResponse->wLicenseDetailLevel;
        }
    }

    return dwStatus;
}


//++----------------------------------------------------------------------------
error_status_t 
TLSRpcIssuePlatformChallenge( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwClientInfo,
    /* [ref][out] */ PCHALLENGE_CONTEXT pChallengeContext,
    /* [out] */ PDWORD pcbChallengeData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pChallengeData,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Issue a platform challenge to hydra client.

Arguments:

    phContext - client context handle
    dwClientInfo - client info.
    pChallengeContext - pointer to client challenge context.
    pcbChallengeData - size of challenge data.
    pChallengeData - random client challenge data.

Returns via dwErrCode:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY       Out of memory
    LSERVER_E_INVALID_DATA      Invalid client info.
    LSERVER_E_SERVER_BUSY       Server is busy

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    LPCLIENTCHALLENGECONTEXT lpChallenge=NULL;
    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcIssuePlatformChallenge\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );
    try {

        do {
            status=TLSGenerateChallengeData(
                        dwClientInfo, 
                        pcbChallengeData, 
                        pChallengeData
                        );
            if(status != ERROR_SUCCESS)
            {
                break;
            }

            *pChallengeContext = dwClientInfo;
        } while (FALSE);

        if(status != ERROR_SUCCESS)
        {
            if(*pChallengeData)
            {
                midl_user_free(*pChallengeData);
                *pChallengeData = NULL;
            }

            *pcbChallengeData=0;
        }
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }        

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ISSUEPLATFORMCHLLENGE;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcRequestNewLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Routine to issue new license to hydra client based on product requested, 
    it returns existing license if client already has a license and the 
    license is not expired/returned/revoked, if request product has not been 
    installed, it will issue a temporary license, if license found is temporary 
    or expired, it will tried to upgrade/re-issue a new license with latest 
    version of requested product, if the existing license is temporary and 
    no license can be issued, it returns LSERVER_E_LICENSE_EXPIRED


Arguments:

    phContext - client context handle.
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    pRequest - product license request.
    pMachineName - client's machine name.
    pUserName - client user name.
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    bAcceptTemporaryLicense - TRUE if client wants temp. license FALSE otherwise.
    pcbLicense - size of return license.
    ppLicense - return license, could be old license

Return Value:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.
++*/
{
    DWORD dwSupportFlags = 0;
    
    return TLSRpcRequestNewLicenseEx( 
                                     phContext,
                                     &dwSupportFlags,
                                     ChallengeContext,
                                     pRequest,
                                     szMachineName,
                                     szUserName,
                                     cbChallengeResponse,
                                     pbChallenge,
                                     bAcceptTemporaryLicense,
                                     1,         // dwQuantity
                                     pcbLicense,
                                     ppbLicense,
                                     pdwErrCode
                                     );
}

error_status_t 
TLSRpcRequestNewLicenseEx(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in, out] */ DWORD *pdwSupportFlags,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [in] */ DWORD dwQuantity,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Routine to issue new license to hydra client based on product requested
    and input support flags.

    *pdwSupportFlags == 0:
        it returns existing license if client already has a license and the 
        license is not expired/returned/revoked, if request product has not
        been installed, it will issue a temporary license, if license found is
        temporary or expired, it will tried to upgrade/re-issue a new license
        with latest version of requested product, if the existing license is
        temporary and no license can be issued, it returns
        LSERVER_E_LICENSE_EXPIRED

    *pdwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON:
        For non-per-seat licenses, it behaves as if the flag wasn't set.
        For per-seat licenses, if bAcceptTemporaryLicense is TRUE, it always
        returns a temporary license.  If bAcceptTemporaryLicense if FALSE, it
        returns LSERVER_E_NO_LICENSE.

Arguments:

    phContext - client context handle.
    pdwSupportFlags - on input, abilities supported by TS.  on output,
                      abilities supported by both TS and LS
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    pRequest - product license request.
    pMachineName - client's machine name.
    pUserName - client user name.
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    bAcceptTemporaryLicense - TRUE if client wants temp. license FALSE
                              otherwise.
    dwQuantity - number of licenses to allocate
    pcbLicense - size of return license.
    ppLicense - return license, could be old license

Return Value:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.
++*/
{
    return TLSRpcRequestNewLicenseExEx( 
                                     phContext,
                                     pdwSupportFlags,
                                     ChallengeContext,
                                     pRequest,
                                     szMachineName,
                                     szUserName,
                                     cbChallengeResponse,
                                     pbChallenge,
                                     bAcceptTemporaryLicense,
                                     FALSE,     // bAcceptFewerLicense
                                     &dwQuantity,
                                     pcbLicense,
                                     ppbLicense,
                                     pdwErrCode
                                     );
}

error_status_t 
TLSRpcRequestNewLicenseExEx(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in, out] */ DWORD *pdwSupportFlags,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [string][in] */ LPTSTR szMachineName,
    /* [string][in] */ LPTSTR szUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ BOOL bAcceptTemporaryLicense,
    /* [in] */ BOOL bAcceptFewerLicenses,
    /* [in,out] */ DWORD *pdwQuantity,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Routine to issue new license to hydra client based on product requested
    and input support flags.

    *pdwSupportFlags == 0:
        it returns existing license if client already has a license and the 
        license is not expired/returned/revoked, if request product has not
        been installed, it will issue a temporary license, if license found is
        temporary or expired, it will tried to upgrade/re-issue a new license
        with latest version of requested product, if the existing license is
        temporary and no license can be issued, it returns
        LSERVER_E_LICENSE_EXPIRED

    *pdwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON:
        For non-per-seat licenses, it behaves as if the flag wasn't set.
        For per-seat licenses, if bAcceptTemporaryLicense is TRUE, it always
        returns a temporary license.  If bAcceptTemporaryLicense if FALSE, it
        returns LSERVER_E_NO_LICENSE.

Arguments:

    phContext - client context handle.
    pdwSupportFlags - on input, abilities supported by TS.  on output,
                      abilities supported by both TS and LS
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    pRequest - product license request.
    pMachineName - client's machine name.
    pUserName - client user name.
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    bAcceptTemporaryLicense - TRUE if client wants temp. license FALSE
                              otherwise.
    bAcceptFewerLicenses - TRUE if succeeding with fewer licenses than
                           requested is acceptable
    pdwQuantity - on input, number of licenses to allocate.  on output,
                  number of licenses actually allocated
    pcbLicense - size of return license.
    ppLicense - return license, could be old license

Return Value:

    LSERVER_S_SUCCESS
    LSERVER_E_OUTOFMEMORY
    LSERVER_E_SERVER_BUSY       Server is busy to process request.
    LSERVER_E_INVALID_DATA      Invalid platform challenge response.
    LSERVER_E_NO_LICENSE        No license available.
    LSERVER_E_NO_PRODUCT        Request product is not installed on server.
    LSERVER_E_LICENSE_REJECTED  License request is rejected by cert. server
    LSERVER_E_LICENSE_REVOKED   Old license found and has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request product's license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_I_PROXIMATE_LICENSE Closest match license returned.
    LSERVER_I_TEMPORARY_LICENSE Temporary license has been issued
    LSERVER_I_LICENSE_UPGRADED  Old license has been upgraded.
++*/
{
    PMHANDLE        hClient;
    DWORD           status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    TCHAR szUnknown[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szClientMachineName[LSERVER_MAX_STRING_SIZE];
    TCHAR szClientUserName[LSERVER_MAX_STRING_SIZE];
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+1];

    TLSForwardNewLicenseRequest Forward;
    TLSDBLICENSEREQUEST LsLicenseRequest;
    CTLSPolicy* pPolicy=NULL;

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;
    BOOL bForwardRequest = TRUE;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    #ifdef DBG
    DWORD dwStartTime=GetTickCount();
    #endif

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRequestNewLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if ((NULL == pdwQuantity) || (0 == *pdwQuantity))
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(VerifyLicenseRequest(pRequest) == FALSE)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(NULL == pdwSupportFlags)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    *pdwSupportFlags &= ALL_KNOWN_SUPPORT_FLAGS;

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        //
        // do not forward any request or infinite loop might
        // occur.
        //
        bForwardRequest = FALSE;
    }

    Forward.m_ChallengeContext = ChallengeContext;
    Forward.m_pRequest = pRequest;
    Forward.m_szMachineName = szMachineName;
    Forward.m_szUserName = szUserName;
    Forward.m_cbChallengeResponse = cbChallengeResponse;
    Forward.m_pbChallengeResponse = pbChallenge;

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Acquire policy module, a default policy module will
    // be returned.
    //
    pPolicy = AcquirePolicyModule(
                            szCompanyName, //(LPCTSTR)pRequest->ProductInfo.pbCompanyName,
                            szProductId,    //(LPCTSTR)pRequest->ProductInfo.pbProductID
                            FALSE
                        );

    if(pPolicy == NULL)
    {
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    hClient = GenerateClientId();

    //
    // return error if string is too big.
    // 
    LoadResourceString(
            IDS_UNKNOWN_STRING, 
            szUnknown, 
            sizeof(szUnknown)/sizeof(szUnknown[0])
            );

    _tcsncpy(szClientMachineName, 
             (szMachineName) ? szMachineName : szUnknown,
             LSERVER_MAX_STRING_SIZE
            );

    szClientMachineName[LSERVER_MAX_STRING_SIZE-1] = 0;

    _tcsncpy(szClientUserName, 
             (szUserName) ? szUserName : szUnknown,
             LSERVER_MAX_STRING_SIZE
            );

    szClientUserName[LSERVER_MAX_STRING_SIZE-1] = 0;

    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        szClientMachineName,
                        szClientUserName,
                        *pdwSupportFlags,
                        &PMLicenseRequest
                    );

    //
    // Inform Policy module start of new license request
    //
    status = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(pAdjustedRequest != NULL)
    {
        if(_tcsicmp(PMLicenseRequest.pszCompanyName,pAdjustedRequest->pszCompanyName) != 0)
        {                               
            // try to steal license from other company???
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    status = TLS_E_POLICYMODULEERROR,
                    pPolicy->GetCompanyName(),
                    pPolicy->GetProductId()
                );

            goto cleanup;
        }
    }
    else
    {
        pAdjustedRequest = &PMLicenseRequest;
    }

    //
    // form DB request structure
    //
    status = TLSFormDBRequest(
                            pRequest->pbEncryptedHwid, 
                            pRequest->cbEncryptedHwid,
                            pAdjustedRequest->dwProductVersion,
                            pAdjustedRequest->pszCompanyName,
                            pAdjustedRequest->pszProductId,
                            pAdjustedRequest->dwLanguageId,
                            pAdjustedRequest->dwPlatformId,
                            pAdjustedRequest->pszMachineName,
                            pAdjustedRequest->pszUserName,
                            &LsLicenseRequest
                        );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    LsLicenseRequest.pPolicy = pPolicy;
    LsLicenseRequest.hClient = hClient;
    LsLicenseRequest.pPolicyLicenseRequest = pAdjustedRequest;
    LsLicenseRequest.pClientLicenseRequest = &PMLicenseRequest;

    try {
        status = TLSVerifyChallengeDataGetWantedLicenseLevel(
                                    ChallengeContext,
                                    cbChallengeResponse,
                                    pbChallenge,
                                    &LsLicenseRequest.wLicenseDetail
                                );
    
        if( status == ERROR_SUCCESS )
        {
            status = TLSNewLicenseRequest(
                            bForwardRequest,
                            pdwSupportFlags,
                            &Forward,
                            &LsLicenseRequest,
                            bAcceptTemporaryLicense,
                            pAdjustedRequest->fTemporary,
                            TRUE,       // bFindLostLicense
                            bAcceptFewerLicenses,
                            pdwQuantity,
                            pcbLicense,
                            ppbLicense
                        );
        }
    }
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }

cleanup:

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ISSUENEWLICENSE;
    #endif

    #ifdef DBG
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("\t%s : TLSRpcRequestNewLicense() takes %dms\n"),
            lpContext->m_Client,
            GetTickCount() - dwStartTime
        );
    #endif
    
    *pdwErrCode = TLSMapReturnCode(status);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr(status),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcUpgradeLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ DWORD cbOldLicense,
    /* [size_is][in] */ PBYTE pbOldLicense,
    /* [out] */ PDWORD pcbNewLicense,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbNewLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Update an old license.

Arguments:


Return Value:  

    LSERVER_S_SUCCESS
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR
    LSERVER_E_INVALID_DATA      old license is invalid.
    LSERVER_E_NO_LICENSE        no available license
    LSERVER_E_NO_PRODUCT        request product not install in current server.
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_LICENSE_REJECTED  License request rejected by cert. server.
    LSERVER_E_SERVER_BUSY

++*/
{
    DWORD dwSupportFlags = 0;

    return TLSRpcUpgradeLicenseEx( 
                                  phContext,
                                  &dwSupportFlags,
                                  pRequest,
                                  ChallengeContext,
                                  cbChallengeResponse,
                                  pbChallenge,
                                  cbOldLicense,
                                  pbOldLicense,
                                  1,    // dwQuantity
                                  pcbNewLicense,
                                  ppbNewLicense,
                                  dwErrCode
                                  );

}
//-------------------------------------------------------------------------------
error_status_t 
TLSRpcUpgradeLicenseEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in,out] */ DWORD *pdwSupportFlags,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallenge,
    /* [in] */ DWORD cbOldLicense,
    /* [size_is][in] */ PBYTE pbOldLicense,
    /* [in] */ DWORD dwQuantity,
    /* [out] */ PDWORD pcbNewLicense,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbNewLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Update an old license.  Behavior varies depending on product requested,
    the old license, and input support flags.

    *pdwSupportFlags == 0:
        it returns existing license if client already has a current-version
        license and the license is not expired/returned/revoked. if requested
        product has not been installed, it will issue a temporary license (if
        the client doesn't already have one). if old license is temporary
        or expired, it will try to upgrade/re-issue a new license
        with latest version of requested product. if the existing license is
        temporary and no license can be issued, it returns
        LSERVER_E_LICENSE_EXPIRED

    *pdwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON:
        For non-per-seat licenses, it behaves as if the flag wasn't set.
        For per-seat licenses, if the old license isn't current-version
        temporary, it also behaves as if the flag wasn't set.
        Otherwise, it checks that the temporary license was marked as having
        been authenticated.  If so, it tries to issue a permanent license.
        If a license can't be issued, or if he temporary license wasn't marked,
        it returns the old license.

Arguments:

    phContext - client context handle.
    pdwSupportFlags - on input, abilities supported by TS.  on output,
                      abilities supported by both TS and LS
    pRequest - product license request.
    ChallengeContext - client challenge context handle, return from 
                       call TLSRpcIssuePlatformChallenge()
    cbChallengeResponse - size of the client's response to license server's
                          platform challenge.
    pbChallenge - client's response to license server's platform challenge
    cbOldLicense - size of old license.
    pbOldLicense - old license
    dwQuantity - number of licenses to allocate
    pcbNewLicense - size of return license.
    ppbNewLicense - return license, could be old license

Return Value:  

    LSERVER_S_SUCCESS
    TLS_E_INTERNAL
    LSERVER_E_INTERNAL_ERROR
    LSERVER_E_INVALID_DATA      old license is invalid.
    LSERVER_E_NO_LICENSE        no available license
    LSERVER_E_NO_PRODUCT        request product not install in current server.
    LSERVER_E_CORRUPT_DATABASE  Corrupted database.
    LSERVER_E_LICENSE_REJECTED  License request rejected by cert. server.
    LSERVER_E_SERVER_BUSY

++*/
{
    DWORD status = ERROR_SUCCESS;
    BOOL bTemporaryLicense; 
    PMUPGRADEREQUEST pmRequestUpgrade;
    PMLICENSEREQUEST pmLicenseRequest;
    PPMLICENSEREQUEST pmAdjustedRequest;
    PPMLICENSEDPRODUCT ppmLicensedProduct=NULL;
    DWORD dwNumLicensedProduct=0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;
    TLSDBLICENSEREQUEST LsLicenseRequest;
    PMHANDLE hClient;
    CTLSPolicy* pPolicy=NULL;
    DWORD dwNumPermLicense;
    DWORD dwNumTempLicense;
    TLSForwardUpgradeLicenseRequest Forward;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    LICENSEDCLIENT license;
    LICENSEPACK keypack;
    DWORD index;
    BOOL bForwardRequest = TRUE;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );
    
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcUpgradeLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if (1 != dwQuantity)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(VerifyLicenseRequest(pRequest) == FALSE)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(NULL == pdwSupportFlags)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    *pdwSupportFlags &= ALL_KNOWN_SUPPORT_FLAGS;

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        //
        // do not forward any request or infinite loop might
        // occur.
        //
        bForwardRequest = FALSE;
    }

    //
    // Convert blob to licensed product structure
    //
    status = LSVerifyDecodeClientLicense(
                            pbOldLicense, 
                            cbOldLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            NULL
                        );

    if(status != LICENSE_STATUS_OK || dwNumLicensedProduct == 0)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                    dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                );
    if(pLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    status = LSVerifyDecodeClientLicense(
                            pbOldLicense, 
                            cbOldLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(status != LICENSE_STATUS_OK)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    //
    // Verify licensed product array.
    //
    for(index = 1; index < dwNumLicensedProduct; index++)
    {
        //
        // licensed product array always sorted in decending order
        //

        //
        // Product ID in original request in licensed product must 
        // be the same otherwise invalid license.
        //
        if(pLicensedProduct->cbOrgProductID != (pLicensedProduct-1)->cbOrgProductID)
        {
            status = TLS_E_INVALID_LICENSE;
            break;
        }

        if( memcmp(
                pLicensedProduct->pbOrgProductID, 
                (pLicensedProduct-1)->pbOrgProductID,
                pLicensedProduct->cbOrgProductID) != 0 )
        {
            status = TLS_E_INVALID_LICENSE;
            goto cleanup;
        }

        if( (pLicensedProduct->pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) )
        {
            //
            // only latest licensed version can be temporary
            //
            status = TLS_E_INVALID_LICENSE;
            goto cleanup;
        }
    }

    //
    // Find the policy module
    // 
    hClient = GenerateClientId();

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+1];

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Acquire policy module, a default policy module will
    // be returned.
    //
    pPolicy = AcquirePolicyModule(
                        szCompanyName,  // (LPCTSTR) pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName,
                        szProductId,     // (LPCTSTR) pLicensedProduct->pbOrgProductID
                        FALSE
                    );

    if(pPolicy == NULL)
    {
        //
        // Must have a policy module, default policy module always there
        //
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        pLicensedProduct->szLicensedClient,
                        pLicensedProduct->szLicensedUser,
                        *pdwSupportFlags,
                        &pmLicenseRequest
                    );

    //
    // generate PMUPGRADEREQUEST and pass it to Policy Module
    //
    memset(&pmRequestUpgrade, 0, sizeof(pmRequestUpgrade));

    ppmLicensedProduct = (PPMLICENSEDPRODUCT)AllocateMemory(sizeof(PMLICENSEDPRODUCT)*dwNumLicensedProduct);
    if(ppmLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    for(index=0; index < dwNumLicensedProduct; index++)
    {
        ppmLicensedProduct[index].pbData = 
                        pLicensedProduct[index].pbPolicyData;

        ppmLicensedProduct[index].cbData = 
                        pLicensedProduct[index].cbPolicyData;

        ppmLicensedProduct[index].bTemporary = 
                        ((pLicensedProduct[index].pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) != 0);

        // treat license issued from beta server as temporary
        if(ppmLicensedProduct[index].bTemporary == FALSE && TLSIsBetaNTServer() == FALSE)
        {
            if(IS_LICENSE_ISSUER_RTM(pLicensedProduct[index].pLicensedVersion->dwFlags) == FALSE)
            {
                ppmLicensedProduct[index].bTemporary = TRUE;
            }
        }

        ppmLicensedProduct[index].ucMarked = 0;

        if (0 == index)
        {
            // for first license, check markings on license
            status = TLSCheckLicenseMarkRequest(
                            TRUE,   // forward request if necessary
                            pLicensedProduct,
                            cbOldLicense,
                            pbOldLicense,
                            &(ppmLicensedProduct[index].ucMarked)
                            );
        }

        ppmLicensedProduct[index].LicensedProduct.dwProductVersion = 
                        pLicensedProduct[index].LicensedProduct.pProductInfo->dwVersion;

        ppmLicensedProduct[index].LicensedProduct.pszProductId = 
                        (LPTSTR)(pLicensedProduct[index].LicensedProduct.pProductInfo->pbProductID);

        ppmLicensedProduct[index].LicensedProduct.pszCompanyName = 
                        (LPTSTR)(pLicensedProduct[index].LicensedProduct.pProductInfo->pbCompanyName);

        ppmLicensedProduct[index].LicensedProduct.dwLanguageId = 
                        pLicensedProduct[index].LicensedProduct.dwLanguageID;

        ppmLicensedProduct[index].LicensedProduct.dwPlatformId = 
                        pLicensedProduct[index].LicensedProduct.dwPlatformID;

        ppmLicensedProduct[index].LicensedProduct.pszMachineName = 
                        pLicensedProduct[index].szLicensedClient;

        ppmLicensedProduct[index].LicensedProduct.pszUserName = 
                        pLicensedProduct[index].szLicensedUser;
    }

    pmRequestUpgrade.pbOldLicense = pbOldLicense;
    pmRequestUpgrade.cbOldLicense = cbOldLicense;
    pmRequestUpgrade.pUpgradeRequest = &pmLicenseRequest;

    pmRequestUpgrade.dwNumProduct = dwNumLicensedProduct;
    pmRequestUpgrade.pProduct = ppmLicensedProduct;
    
    status = pPolicy->PMLicenseUpgrade(
                                hClient,
                                REQUEST_UPGRADE,
                                (PVOID)&pmRequestUpgrade,
                                (PVOID *) &pmAdjustedRequest
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(pmAdjustedRequest != NULL)
    {
        if(_tcsicmp(
                    pmLicenseRequest.pszCompanyName, 
                    pmAdjustedRequest->pszCompanyName
                ) != 0)
        { 
            //                              
            // Try to steal license from other company???
            //
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    status = TLS_E_POLICYMODULEERROR,
                    pPolicy->GetCompanyName(),
                    pPolicy->GetProductId()
                );

            goto cleanup;
        }
    }
    else
    {
        pmAdjustedRequest = &pmLicenseRequest;
    }

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        DWORD tExpireDate;

        FileTimeToLicenseDate(&(pLicensedProduct[index].NotAfter),
            &tExpireDate);

        if( CompareTLSVersions(pmAdjustedRequest->dwProductVersion, pLicensedProduct[index].LicensedProduct.pProductInfo->dwVersion) <= 0 &&
            !(pLicensedProduct[index].pLicensedVersion->dwFlags & LICENSED_VERSION_TEMPORARY) &&
            _tcscmp(pmAdjustedRequest->pszProductId, (LPTSTR)(pLicensedProduct[index].LicensedProduct.pProductInfo->pbProductID)) == 0 &&
            tExpireDate-g_dwReissueLeaseLeeway >= ((DWORD)time(NULL)) )
        {
            if( TLSIsBetaNTServer() == TRUE ||
                IS_LICENSE_ISSUER_RTM(pLicensedProduct[index].pLicensedVersion->dwFlags) == TRUE )
            {
                //
                // Blob already contain perm. license that is >= version
                // requested.
                //
                *ppbNewLicense = (PBYTE)midl_user_allocate(cbOldLicense);
                if(*ppbNewLicense != NULL)
                {
                    memcpy(*ppbNewLicense, pbOldLicense, cbOldLicense);
                    *pcbNewLicense = cbOldLicense;
                    status = ERROR_SUCCESS;
                }
                else
                {
                    status = TLS_E_ALLOCATE_MEMORY;
                }

                goto cleanup;
            }
        }
    }
    
    memset(&LsLicenseRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    status = TLSFormDBRequest(
                            pRequest->pbEncryptedHwid, 
                            pRequest->cbEncryptedHwid,
                            pmAdjustedRequest->dwProductVersion,
                            pmAdjustedRequest->pszCompanyName,
                            pmAdjustedRequest->pszProductId,
                            pmAdjustedRequest->dwLanguageId,
                            pmAdjustedRequest->dwPlatformId,
                            pmAdjustedRequest->pszMachineName,
                            pmAdjustedRequest->pszUserName,
                            &LsLicenseRequest
                        );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    LsLicenseRequest.pPolicy = pPolicy;
    LsLicenseRequest.hClient = hClient;
    LsLicenseRequest.pPolicyLicenseRequest = pmAdjustedRequest;
    LsLicenseRequest.pClientLicenseRequest = &pmLicenseRequest;
    
    memset(&keypack, 0, sizeof(keypack));

    try {

        status = TLSVerifyChallengeDataGetWantedLicenseLevel(
                                    ChallengeContext,
                                    cbChallengeResponse,
                                    pbChallenge,
                                    &LsLicenseRequest.wLicenseDetail
                                );

        if( status == ERROR_SUCCESS )
        {

            //
            // if client challenge context handle is 0xFFFFFFFF,
            // cbChallenge = 0 and pbChallenge is NULL.
            // client is old version, don't verify challenge
            //            
            Forward.m_pRequest = pRequest;
            Forward.m_ChallengeContext = ChallengeContext;
            Forward.m_cbChallengeResponse = cbChallengeResponse;
            Forward.m_pbChallengeResponse = pbChallenge;
            Forward.m_cbOldLicense = cbOldLicense;
            Forward.m_pbOldLicense = pbOldLicense;

            status = TLSUpgradeLicenseRequest(
                                bForwardRequest,
                                &Forward,
                                pdwSupportFlags,
                                &LsLicenseRequest,
                                pbOldLicense,
                                cbOldLicense,
                                dwNumLicensedProduct,
                                pLicensedProduct,
                                pmAdjustedRequest->fTemporary,
                                pcbNewLicense,
                                ppbNewLicense
                            );
        }

    } // end try
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) 
    {
        status = TLS_E_INTERNAL;
    }

cleanup:

    FreeMemory(ppmLicensedProduct);

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_UPGRADELICENSE;
    #endif
    
    *dwErrCode = TLSMapReturnCode(status);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (status),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-----------------------------------------------------------------------------
error_status_t
TLSRpcCheckLicenseMark(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const DWORD  cbLicense,
    /* [in, size_is(cbLicense)] */ PBYTE   pbLicense,
    /* [out] */ UCHAR *pucMarkFlags,
    /* [in, out, ref] */ PDWORD pdwErrCode
    )
/*++

Description:

    Check markings on the passed in license

Arguments:

    phContext - client context handle
    cbLicense - size of license to be checked
    pbLicense - license to be checked
    pucMarkFlags - markings on license

Return via pdwErrCode:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_INVALID_LICENSE   License passed in is bad
    LSERVER_E_DATANOTFOUND      license not found in database
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    This function forwards the request to the issuing license server.  If
    the issuer isn't available, or doesn't have the license in the database,
    it searches in the local database for a license with the same HWID.

++*/
{
    DWORD status = ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD dwNumLicensedProduct = 0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;
    DWORD index;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );
    
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcCheckLicenseMark\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LSERVER))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if (NULL == pucMarkFlags)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Convert blob to licensed product structure
    //
    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            NULL        // find size to allocate
                        );

    if(status != LICENSE_STATUS_OK || dwNumLicensedProduct == 0)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                               dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                               );

    if(pLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(status != LICENSE_STATUS_OK)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    try {

        status = TLSCheckLicenseMarkRequest(
                           FALSE,       // don't forward the request
                           pLicensedProduct,
                           cbLicense,
                           pbLicense,
                           pucMarkFlags
                           );
    } // end try
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) 
    {
        status = TLS_E_INTERNAL;
    }


cleanup:

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;

    *pdwErrCode = TLSMapReturnCode(status);

    InterlockedDecrement( &lpContext->m_RefCount );

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-----------------------------------------------------------------------------
error_status_t
TLSRpcMarkLicense(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ UCHAR ucMarkFlags,
    /* [in] */ const DWORD  cbLicense,
    /* [in, size_is(cbLicense)] */ PBYTE   pbLicense,
    /* [in, out, ref] */ PDWORD pdwErrCode
    )
/*++

Description:

    Set markings on the passed in license

Arguments:

    phContext - client context handle
    ucMarkFlags - markings on license
    cbLicense - size of license to be checked
    pbLicense - license to be checked

Return via pdwErrCode:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_INVALID_LICENSE   License passed in is bad
    LSERVER_E_DATANOTFOUND      license not found in database
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    This function forwards the request to the issuing license server.  The
    issuer modifies the database entry of the license to set the markings.

++*/
{
    DWORD status = ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    BOOL bForwardRequest = TRUE;
    DWORD dwNumLicensedProduct = 0;
    PLICENSEDPRODUCT pLicensedProduct=NULL;
    DWORD index;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );
    
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcMarkLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        //
        // do not forward any request or infinite loop might
        // occur.
        //
        bForwardRequest = FALSE;
    }

    //
    // Convert blob to licensed product structure
    //
    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            NULL        // find size to allocate
                        );

    if(status != LICENSE_STATUS_OK || dwNumLicensedProduct == 0)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                               dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                               );

    if(pLicensedProduct == NULL)
    {
        status = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    status=LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(status != LICENSE_STATUS_OK)
    {
        status = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    try {

        status = TLSMarkLicenseRequest(
                           bForwardRequest,
                           ucMarkFlags,
                           pLicensedProduct,
                           cbLicense,
                           pbLicense
                           );
    } // end try
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) 
    {
        status = TLS_E_INTERNAL;
    }


cleanup:

    for(index =0; index < dwNumLicensedProduct; index++)
    {
        LSFreeLicensedProduct(pLicensedProduct+index);
    }

    FreeMemory(pLicensedProduct);

    lpContext->m_LastError=status;

    *pdwErrCode = TLSMapReturnCode(status);

    InterlockedDecrement( &lpContext->m_RefCount );

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcAllocateConcurrentLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR szHydraServer,
    /* [in] */ TLSLICENSEREQUEST __RPC_FAR *pRequest,
    /* [ref][out][in] */ LONG __RPC_FAR *pdwQuantity,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Description:

    Allocate concurrent licenses base on product.

Arguments:

    phContext - client context handle
    szHydraServer - name of hydra server requesting concurrent licenses
    pRequest - product to request for concurrent license.
    dwQuantity - See note

Return via dwErrCode:
    LSERVER_S_SUCCESS
    LSERVER_E_INVALID_DATA      Invalid parameter.
    LSERVER_E_NO_PRODUCT        request product not installed
    LSERVER_E_NO_LICNESE        no available license for request product 
    LSERVER_E_LICENSE_REVOKED   Request license has been revoked
    LSERVER_E_LICENSE_EXPIRED   Request license has expired
    LSERVER_E_CORRUPT_DATABASE  Corrupt database
    LSERVER_E_INTERNAL_ERROR    Internal error in license server

Note:
    dwQuantity
    Input                       Output
    -------------------------   -----------------------------------------
    0                           Total number of concurrent license 
                                issued to hydra server.
    > 0, number of license      Actual number of license allocated
         requested
    < 0, number of license      Actual number of license returned, always
         to return              positive value.

++*/
{
#if 1

    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;

#else

    PMHANDLE hClient;

    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    PTLSDbWorkSpace pDbWorkSpace;

    TLSDBLICENSEREQUEST LsLicenseRequest;
    TCHAR szUnknown[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szClientMachineName[LSERVER_MAX_STRING_SIZE];
    TCHAR szClientUserName[LSERVER_MAX_STRING_SIZE];
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+1];

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    CTLSPolicy* pPolicy = NULL;
    BOOL bAllocateLicense = TRUE;

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;

    #ifdef DBG
    DWORD dwStartTime=GetTickCount();
    #endif


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAllocateConcurrentLicense\n"),
            lpContext->m_Client
        );

    if(*pdwQuantity > 1)
    {
        TLSASSERT(*pdwQuantity > 1);
    }

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Acquire policy module, a default policy module will
    // be returned.
    //
    pPolicy = AcquirePolicyModule(
                            szCompanyName, //(LPCTSTR)pRequest->ProductInfo.pbCompanyName,
                            szProductId,   //(LPCTSTR)pRequest->ProductInfo.pbProductID
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    //
    // return error if string is too big.
    // 
    LoadResourceString(
                IDS_UNKNOWN_STRING, 
                szUnknown, 
                sizeof(szUnknown)/sizeof(szUnknown[0])
            );

    _tcsncpy(
            szClientMachineName, 
            (szHydraServer) ? szHydraServer : szUnknown,
            LSERVER_MAX_STRING_SIZE
        );

    _tcsncpy(
            szClientUserName, 
            (szHydraServer) ? szHydraServer : szUnknown,
            LSERVER_MAX_STRING_SIZE
        );

    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        szClientMachineName,
                        szClientUserName,
                        0,
                        &PMLicenseRequest
                    );

    //
    // Inform Policy module start of new license request
    //
    status = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(pAdjustedRequest != NULL)
    {
        if(_tcsicmp(PMLicenseRequest.pszCompanyName,pAdjustedRequest->pszCompanyName) != 0)
        {                               
            // try to steal license from other company???
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_POLICYERROR,
                    status = TLS_E_POLICYMODULEERROR,
                    pPolicy->GetCompanyName(),
                    pPolicy->GetProductId()
                );

            goto cleanup;
        }
    }
    else
    {
        pAdjustedRequest = &PMLicenseRequest;
    }


    //
    // form DB request structure
    //
    status = TLSFormDBRequest(
                            pRequest->pbEncryptedHwid, 
                            pRequest->cbEncryptedHwid,
                            pAdjustedRequest->dwProductVersion,
                            pAdjustedRequest->pszCompanyName,
                            pAdjustedRequest->pszProductId,
                            pAdjustedRequest->dwLanguageId,
                            pAdjustedRequest->dwPlatformId,
                            pAdjustedRequest->pszMachineName,
                            pAdjustedRequest->pszUserName,
                            &LsLicenseRequest
                        );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    LsLicenseRequest.pPolicy = pPolicy;
    LsLicenseRequest.hClient = hClient;
    LsLicenseRequest.pPolicyLicenseRequest = pAdjustedRequest;
    LsLicenseRequest.pClientLicenseRequest = &PMLicenseRequest;
    
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    bAllocateLicense = (*pdwQuantity) > 0;

    CLEANUPSTMT;

    BEGIN_TRANSACTION(pDbWorkSpace);

    try {
        status = TLSDBAllocateConcurrentLicense( 
                                USEHANDLE(pDbWorkSpace),
                                szHydraServer, 
                                &LsLicenseRequest, 
                                pdwQuantity 
                            );
    } 
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) {
        SetLastError(status = TLS_E_INTERNAL);
    }
    
    if(TLS_ERROR(status))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }

    FREEDBHANDLE(pDbWorkSpace);


cleanup:

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ALLOCATECONCURRENT;
    #endif

    #ifdef DBG
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_DETAILSIMPLE,
            _TEXT("\t%s : TLSRpcRequestNewLicense() takes %dms\n"),
            lpContext->m_Client,
            GetTickCount() - dwStartTime
        );
    #endif
    
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            (PVOID) status,
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);
    return RPC_S_OK;

#endif
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetLastError( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD cbBufferSize,
    /* [size_is][string][out][in] */ LPTSTR szBuffer,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return error description text for client's last LSXXX call

Arguments:

    IN phContext - Client context
    IN cbBufferSize - max. size of szBuffer
    IN OUT szBuffer - Pointer to a buffer to receive the 
                      null-terminated character string containing 
                      error description

Returns via dwErrCode:
    LSERVER_S_SUCCESS

    TLS_E_INTERNAL     No error or can't find corresponding error
                       description.

    Error code from WideCharToMultiByte().

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPTSTR lpMsgBuf=NULL;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetLastError\n"),
            lpContext->m_Client
        );

    try {
        DWORD dwRet;
        dwRet=FormatMessage( 
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM | 
                                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL,
                        lpContext->m_LastError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                    );
        if(dwRet == 0)
        {
            status = GetLastError();
        }
        else
        {
            _tcsncpy(
                    szBuffer, 
                    (LPTSTR)lpMsgBuf, 
                    min(_tcslen((LPTSTR)lpMsgBuf), *cbBufferSize-1)
                );
            szBuffer[min(_tcslen((LPTSTR)lpMsgBuf), *cbBufferSize-1)] = _TEXT('\0');
            *cbBufferSize = _tcslen(szBuffer) + 1;
        }
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }        

    if(lpMsgBuf)
        LocalFree(lpMsgBuf);

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GET_LASTERROR;
    #endif
  
    lpContext->m_LastError=status;
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSKeyPackSearchParm lpSearchParm,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Function to begin enumerate through all key pack installed on server
    based on search criterial.

Arguments:

    phContext - client context handle.
    dwSearchParm - search criterial.
    bMatchAll - match all search criterial.
    lpSearchParm - search parameter.

Return Value:  

LSERVER_S_SUCCESS
LSERVER_E_SERVER_BUSY       Server is too busy to process request
LSERVER_E_OUTOFMEMORY
TLS_E_INTERNAL
LSERVER_E_INTERNAL_ERROR    
LSERVER_E_INVALID_DATA      Invalid data in search parameter
LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, likely, previous
                            enumeration has not ended.
++*/
{

    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );
    _se_translator_function old_trans_se_func = NULL;

    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackEnumBegin\n"),
            lpContext->m_Client
        );

    //
    // This will use cached db connection, in-consistency may occurred,
    // visibility of changes in one connection may not appear right away
    // on another connection handle, this is expected behavoir for Jet and
    // so are we, user can always re-fresh.
    //
    do {
        if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
        {
            SetLastError(status=TLS_E_INVALID_SEQUENCE);
            break;
        }

        try {

            LPENUMHANDLE hEnum;

            hEnum = TLSDBLicenseKeyPackEnumBegin( 
                                        bMatchAll, 
                                        dwSearchParm, 
                                        lpSearchParm 
                                    );
            if(hEnum)
            {
                lpContext->m_ContextType = CONTEXTHANDLE_KEYPACK_ENUM_TYPE;
                lpContext->m_ContextHandle = (PVOID)hEnum;
            }
            else
            {
                status = GetLastError();
            }
        } 
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }        

    } while(FALSE);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKENUMBEGIN;
    #endif

    *dwErrCode = TLSMapReturnCode(status);
    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackEnumNext( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSKeyPack lpKeyPack,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Return next key pack that match search criterial

Arguments:

    phContext - client context handle
    lpKeyPack - key pack that match search criterial

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_I_NO_MORE_DATA      No more keypack match search criterial
    TLS_E_INTERNAL     General error in license server
    LSERVER_E_INTERNAL_ERROR    Internal error in license server
    LSERVER_E_SERVER_BUSY       License server is too busy to process request
    LSERVER_E_OUTOFMEMORY       Can't process request due to insufficient memory
    LSERVER_E_INVALID_SEQUENCE  Invalid calling sequence, must call
                                LSKeyPackEnumBegin().

++*/
{
    DWORD status = ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    BOOL bShowAll = FALSE;


    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackEnumNext\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );

    if(lpContext->m_ClientFlags == CLIENT_ACCESS_LSERVER)
    {
        bShowAll = TRUE;
    }

    // this one might cause access violation
    memset(lpKeyPack, 0, sizeof(LSKeyPack));

    if(lpContext->m_ContextType != CONTEXTHANDLE_KEYPACK_ENUM_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
    }
    else
    {
        do {
            try {
                LPENUMHANDLE hEnum=(LPENUMHANDLE)lpContext->m_ContextHandle;
                status=TLSDBLicenseKeyPackEnumNext( 
                                        hEnum, 
                                        lpKeyPack,
                                        bShowAll
                                    );
            }
            catch( SE_Exception e ) {
                status = e.getSeNumber();
            }
            catch(...) {
                status = TLS_E_INTERNAL;
            }
        } while(status == TLS_I_MORE_DATA);
    }

    lpContext->m_LastError=GetLastError();
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKENUMNEXT;
    #endif

    *dwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackEnumEnd\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    try {
        if(lpContext->m_ContextType != CONTEXTHANDLE_KEYPACK_ENUM_TYPE)
        {
            SetLastError(status=ERROR_INVALID_HANDLE);
        }
        else
        {
            LPENUMHANDLE hEnum=(LPENUMHANDLE)lpContext->m_ContextHandle;

            TLSDBLicenseKeyPackEnumEnd(hEnum);
            lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
            lpContext->m_ContextHandle=NULL;
        }
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }        

    lpContext->m_LastError=GetLastError();
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKENUMEND;
    #endif

    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackAdd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ LPLSKeyPack lpKeypack,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Add a license key pack.

Arguments:

    phContext - client context handle.
    lpKeyPack - key pack to be added.
    
Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DUPLICATE             Product already installed.
    LSERVER_E_INVALID_DATA
    LSERVER_E_CORRUPT_DATABASE

Note:

    Application must call LSKeyPackSetStatus() to activate keypack

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;
    DWORD status=ERROR_SUCCESS;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackAdd\n"),
            lpContext->m_Client
        );


    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else
    {
        if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
        {
            status=TLS_E_ALLOCATE_HANDLE;
        }
        else   
        {
            CLEANUPSTMT;

            BEGIN_TRANSACTION(pDbWkSpace);

            try {
                if(lpKeypack->ucKeyPackStatus == LSKEYPACKSTATUS_ADD_LICENSE ||
                   lpKeypack->ucKeyPackStatus == LSKEYPACKSTATUS_REMOVE_LICENSE)
                {
                    status = TLSDBLicenseKeyPackUpdateLicenses( 
                                                USEHANDLE(pDbWkSpace), 
                                                lpKeypack->ucKeyPackStatus == LSKEYPACKSTATUS_ADD_LICENSE,
                                                lpKeypack 
                                            );
                }
                else
                {
                    status = TLSDBLicenseKeyPackAdd( 
                                            USEHANDLE(pDbWkSpace), 
                                            lpKeypack 
                                        );
                }

                if(status == ERROR_SUCCESS)
                {
                    if( _tcsicmp( lpKeypack->szCompanyName, PRODUCT_INFO_COMPANY_NAME ) == 0 )
                    {
                        //
                        // check with known termsrv product ID.
                        //
                        if( _tcsnicmp(  lpKeypack->szProductId, 
                                        TERMSERV_PRODUCTID_SKU, 
                                        _tcslen(TERMSERV_PRODUCTID_SKU)) == 0 )
                        {
                            TLSResetLogLowLicenseWarning(
                                                    lpKeypack->szCompanyName,
                                                    TERMSERV_PRODUCTID_SKU, 
                                                    MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                    FALSE
                                                );
                        }
                        else if(_tcsnicmp(  lpKeypack->szProductId, 
                                            TERMSERV_PRODUCTID_INTERNET_SKU, 
                                            _tcslen(TERMSERV_PRODUCTID_INTERNET_SKU)) == 0 )
                        {
                            TLSResetLogLowLicenseWarning(
                                                    lpKeypack->szCompanyName,
                                                    TERMSERV_PRODUCTID_INTERNET_SKU, 
                                                    MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                    FALSE
                                                );
                        }
                        else
                        {
                            TLSResetLogLowLicenseWarning(
                                                    lpKeypack->szCompanyName,
                                                    lpKeypack->szProductId, 
                                                    MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                    FALSE
                                                );
                        }
                    }
                    else
                    {
                        TLSResetLogLowLicenseWarning(
                                                lpKeypack->szCompanyName,
                                                lpKeypack->szProductId, 
                                                MAKELONG(lpKeypack->wMinorVersion, lpKeypack->wMajorVersion),
                                                FALSE
                                            );
                    }
                }
            }
            catch(...) {
                status = TLS_E_INTERNAL;
            }

            if(TLS_ERROR(status))
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            else
            {
                COMMIT_TRANSACTION(pDbWkSpace);
            }
        
            FREEDBHANDLE(pDbWkSpace);
        }
    }

    //
    // Post a sync work object
    //
    if( status == ERROR_SUCCESS )
    {
        if( lpKeypack->ucKeyPackType != LSKEYPACKTYPE_FREE )
        {
            if(TLSAnnounceLKPToAllRemoteServer(
                                        lpKeypack->dwKeyPackId,
                                        0
                                    ) != ERROR_SUCCESS)
            {
                TLSLogWarningEvent(TLS_W_ANNOUNCELKP_FAILED);
            }
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKADD;
    #endif

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcKeyPackSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParm,
    /* [ref][in] */ LPLSKeyPack lpKeyPack,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Routine to activate/deactivated a key pack.

Arguments:

    phContext - client context handle
    dwSetParam - type of key pack status to be set.
    lpKeyPack - new key pack status.

Return Value:  

    LSERVER_S_SUCCESS
    LSERVER_E_INTERNAL_ERROR
    TLS_E_INTERNAL
    LSERVER_E_INVALID_DATA     
    LSERVER_E_SERVER_BUSY
    LSERVER_E_DATANOTFOUND      Key pack is not in server
    LSERVER_E_CORRUPT_DATABASE

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;

    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcKeyPackSetStatus\n"),
            lpContext->m_Client
        );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else if( (dwSetParm & ~(LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_EXPIREDATE)) &&
             !(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ) ) 
    {
        status = TLS_E_INVALID_DATA;
    }
    else
    {
        if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
        {
            status=TLS_E_ALLOCATE_HANDLE;
        }
        else   
        {
            CLEANUPSTMT;

            BEGIN_TRANSACTION(pDbWkSpace);

            try {
                status=TLSDBLicenseKeyPackSetStatus( 
                                        USEHANDLE(pDbWkSpace), 
                                        dwSetParm, 
                                        lpKeyPack 
                                    );
            }
            catch(...) {
                status = TLS_E_INTERNAL;
            }

            if(TLS_ERROR(status))
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            else
            {
                COMMIT_TRANSACTION(pDbWkSpace);
            }

            FREEDBHANDLE(pDbWkSpace);
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_KEYPACKSETSTATUS;
    #endif

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [in] */ BOOL bMatchAll,
    /* [ref][in] */ LPLSLicenseSearchParm lpSearchParm,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Description:

    Begin enumeration of license issued based on search criterial

Arguments:

    phContext - client context handle
    dwSearchParm - license search criterial.
    bMatchAll - match all search criterial
    lpSearchParm - license(s) to be enumerated.

Return Value:  

    Same as LSKeyPackEnumBegin().

++*/
{
    PTLSDbWorkSpace pDbWkSpace = NULL;
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumBegin\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //
    // This will use cached db connection, in-consistency may occurred,
    // visibility of changes in one connection may not appear right away
    // on another connection handle, this is expected behavoir for Jet and
    // so are we, user can always re-fresh.
    //

    do {
        if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
        {
            SetLastError(status=TLS_E_INVALID_SEQUENCE);
            break;
        }

        pDbWkSpace = AllocateWorkSpace(g_EnumDbTimeout);

        // allocate ODBC connections
        if(pDbWkSpace == NULL)
        {
            status=TLS_E_ALLOCATE_HANDLE;
            break;
        }

        try {   
            LICENSEDCLIENT license;

            ConvertLSLicenseToLicense(lpSearchParm, &license);
            status = TLSDBLicenseEnumBegin( 
                                pDbWkSpace, 
                                bMatchAll, 
                                dwSearchParm & LICENSE_TABLE_EXTERN_SEARCH_MASK, 
                                &license 
                            );
        }
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }

        if(status == ERROR_SUCCESS)
        {
            lpContext->m_ContextType = CONTEXTHANDLE_LICENSE_ENUM_TYPE;
            lpContext->m_ContextHandle = (PVOID)pDbWkSpace;
        }
    } while(FALSE);

    if(status != ERROR_SUCCESS)
    {
        if(pDbWkSpace)
        {
            ReleaseWorkSpace(&pDbWkSpace);
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMBEGIN;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    lpContext->m_LastError=status;
    *dwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumNext( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSLicense lpLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Abstract:

    Fetch next record match enumeration criterial.

Parameters:

    phContext : Client context handle.
    lpLicense : return next record that match enumeration criterial.
    dwErrCode : error code.

Returns:

    Function returns RPC status, dwErrCode return error code.

Note:

    Must have call TLSRpcLicenseEnumBegin().

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );
    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumNext\n"),
            lpContext->m_Client
        );

    if(lpContext->m_ContextType != CONTEXTHANDLE_LICENSE_ENUM_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
    }
    else
    {
        PTLSDbWorkSpace pDbWkSpace=(PTLSDbWorkSpace)lpContext->m_ContextHandle;
        try {
            LICENSEDCLIENT license;

            memset(lpLicense, 0, sizeof(LSLicense));

            status=TLSDBLicenseEnumNext( 
                                pDbWkSpace, 
                                &license
                            );
            if(status == ERROR_SUCCESS)
            {
                ConvertLicenseToLSLicense(&license, lpLicense);
            }
        } 
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }        
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMNEXT;
    #endif
   
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumNextEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out] */ LPLSLicenseEx lpLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Abstract:

    Fetch next record match enumeration criterial.

Parameters:

    phContext : Client context handle.
    lpLicense : return next record that match enumeration criterial.
    dwErrCode : error code.

Returns:

    Function returns RPC status, dwErrCode return error code.

Note:

    Must have call TLSRpcLicenseEnumBegin().

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );
    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumNextEx\n"),
            lpContext->m_Client
        );

    if(lpContext->m_ContextType != CONTEXTHANDLE_LICENSE_ENUM_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
    }
    else
    {
        PTLSDbWorkSpace pDbWkSpace=(PTLSDbWorkSpace)lpContext->m_ContextHandle;
        try {
            LICENSEDCLIENT license;

            memset(lpLicense, 0, sizeof(LSLicenseEx));

            status=TLSDBLicenseEnumNext( 
                                pDbWkSpace, 
                                &license
                            );
            if(status == ERROR_SUCCESS)
            {
                ConvertLicenseToLSLicenseEx(&license, lpLicense);
            }
        } 
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }        
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMNEXT;
    #endif
   
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

Abstract:

    Terminate a enumeration.

Parameters:

    phContext :
    dwErrCode :

Returns:


Note

++*/
{
    DWORD status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseEnumEnd\n"),
            lpContext->m_Client
        );

    try {
        if(lpContext->m_ContextType != CONTEXTHANDLE_LICENSE_ENUM_TYPE)
        {
            SetLastError(status=ERROR_INVALID_HANDLE);
        }
        else
        {
            PTLSDbWorkSpace pDbWkSpace = (PTLSDbWorkSpace)lpContext->m_ContextHandle;

            TLSDBLicenseEnumEnd(pDbWkSpace);
            ReleaseWorkSpace(&pDbWkSpace);
            lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
        }
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }        

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSEENUMEND;
    #endif

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcLicenseSetStatus( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSetParam,
    /* [in] */ LPLSLicense lpLicense,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLicenseSetStatus\n"),
            lpContext->m_Client
        );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else if(dwSetParam != LSLICENSE_EXSEARCH_LICENSESTATUS)
    {
        status = TLS_E_INVALID_DATA;
    }
    else
    {
        if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
        {
            status=TLS_E_ALLOCATE_HANDLE;
        }
        else
        {
            CLEANUPSTMT;

            BEGIN_TRANSACTION(pDbWkSpace);

            try {
                LICENSEDCLIENT license;

                ConvertLSLicenseToLicense(lpLicense, &license);
                status=TLSDBLicenseSetValue( 
                                    USEHANDLE(pDbWkSpace), 
                                    dwSetParam, 
                                    &license,
                                    FALSE 
                                );
            }
            catch(...) {
                status = TLS_E_INTERNAL;
            }

            if(TLS_ERROR(status))
            {
                ROLLBACK_TRANSACTION(pDbWkSpace);
            }
            else
            {
                COMMIT_TRANSACTION(pDbWkSpace);
            }

            FREEDBHANDLE(pDbWkSpace);
        }
    }

    #if DBG
    lpContext->m_LastCall = RPC_CALL_LICENSESETSTATUS;
    #endif

    lpContext->m_LastError = status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetAvailableLicenses( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParm,
    /* [ref][in] */ LPLSKeyPack lplsKeyPack,
    /* [ref][out] */ LPDWORD lpdwAvail,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    PTLSDbWorkSpace pDbWkSpace=NULL;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetAvailableLicenses\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );

    //
    // Don't use global cached DB connection handle, it is possible
    // to get in-consistent value using other DB handle, however, it is
    // also possible that during the time that this function return and
    // the time that client actually make the call to allocate license,
    // all available licenses were allocated by other client.
    //
    pDbWkSpace = AllocateWorkSpace(g_GeneralDbTimeout);
    if(pDbWkSpace == NULL)
    {
        status=TLS_E_ALLOCATE_HANDLE;
    }
    else
    {
        try {
            LICENSEPACK keypack;

            memset(&keypack, 0, sizeof(keypack));

            ConvertLsKeyPackToKeyPack(
                            lplsKeyPack, 
                            &keypack, 
                            NULL
                        );

            status = TLSDBKeyPackGetAvailableLicenses(
                                            pDbWkSpace,
                                            dwSearchParm,
                                            &keypack,
                                            lpdwAvail
                                        );

            //FreeTlsLicensePack(&keypack);
        } 
        catch(...) {
            status = TLS_E_INTERNAL;    
        }

        ReleaseWorkSpace(&pDbWkSpace);
    }        
    
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetRevokeKeyPackList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfRange,
    /* [size_is][out] */ LPLSRange __RPC_FAR *ppRevokeRange,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetRevokeLicenseList( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [out][in] */ PDWORD pcbNumberOfRange,
    /* [size_is][out] */ LPLSRange __RPC_FAR *ppRevokeRange,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcReturnKeyPack( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwKeyPackId,
    /* [in] */ DWORD dwReturnReason,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcReturnLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwKeyPackId,
    /* [in] */ DWORD dwLicenseId,
    /* [in] */ DWORD dwReturnReason,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcInstallCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertType,
    /* [in] */ DWORD dwCertLevel,
    /* [in] */ DWORD cbSignCert,
    /* [size_is][in] */ PBYTE pbSignCert,
    /* [in] */ DWORD cbExchCert,
    /* [size_is][in] */ PBYTE pbExchCert,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcInstallCertificate\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    DWORD cbLsSignCert=0;
    PBYTE pbLsSignCert=NULL;

    DWORD cbLsExchCert=0;
    PBYTE pbLsExchCert=NULL;

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(pbSignCert == NULL || pbExchCert == NULL)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;

    }

#if DBG
    //
    // Verify input data
    //
    status = TLSVerifyCertChainInMomory(
                                g_hCryptProv,
                                pbSignCert,
                                cbSignCert
                            );
    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
    }

    //
    // Verify input data
    //
    status = TLSVerifyCertChainInMomory(
                                g_hCryptProv,
                                pbExchCert,
                                cbExchCert
                            );
    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
    }
#endif

    //
    // Block RPC call to serialize install certificate
    //
    if(AcquireRPCExclusiveLock(INFINITE) == FALSE)
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    if(AcquireAdministrativeLock(INFINITE) == TRUE)
    {
        try {
            if(dwCertLevel == 0)
            {
                status = TLSSaveRootCertificatesToStore(
                                               g_hCryptProv,
                                               cbSignCert, 
                                               pbSignCert, 
                                               cbExchCert,
                                               pbExchCert
                                            );
            }
            else
            {
                status = TLSSaveCertificatesToStore(
                                                g_hCryptProv, 
                                                dwCertType, 
                                                dwCertLevel, 
                                                cbSignCert, 
                                                pbSignCert, 
                                                cbExchCert,
                                                pbExchCert
                                            );

                if(status == ERROR_SUCCESS && dwCertType == CERTIFICATE_CA_TYPE)
                {
                    if(cbSignCert)
                    {
                        status = IsCertificateLicenseServerCertificate(
                                                            g_hCryptProv,
                                                            AT_SIGNATURE,
                                                            cbSignCert,
                                                            pbSignCert,
                                                            &cbLsSignCert,
                                                            &pbLsSignCert
                                                        );
                    }

                    if(status == ERROR_SUCCESS && cbExchCert)
                    {
                        status = IsCertificateLicenseServerCertificate(
                                                            g_hCryptProv,
                                                            AT_KEYEXCHANGE,
                                                            cbExchCert,
                                                            pbExchCert,
                                                            &cbLsExchCert,
                                                            &pbLsExchCert
                                                        );

                    }

                    //
                    // Install what we have here.
                    //
                    if(status == ERROR_SUCCESS && (cbLsExchCert || pbLsExchCert))
                    {
                        status = TLSInstallLsCertificate(
                                                    cbLsSignCert, 
                                                    pbLsSignCert, 
                                                    cbLsExchCert, 
                                                    pbLsExchCert
                                                );
                    }

                    #ifdef ENFORCE_LICENSING

                    // enforce version, check what's installed and restore backup if necessary
                    // non-enforce, just install, we won't use it anyway.
                    if(status == ERROR_SUCCESS && (cbLsExchCert || pbLsExchCert))
                    {
                        // reload certificate
                        if(TLSLoadVerifyLicenseServerCertificates() != ERROR_SUCCESS)
                        {
                            status = TLS_E_INVALID_DATA;

                            // delete the primary certificate registry key
                            TLSRegDeleteKey(
                                        HKEY_LOCAL_MACHINE,
                                        LSERVER_SERVER_CERTIFICATE_REGKEY
                                    );

                            //
                            // reload certificate, if anything goes wrong, we will goes 
                            // back to unregister mode.
                            //
                            if(TLSLoadServerCertificate() == FALSE)
                            {
                                // critical error occurred
                                TLSLogErrorEvent(TLS_E_LOAD_CERTIFICATE);
                                
                                // initiate self-shutdown
                                GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
                            }
                        }
                        else
                        {
                            DWORD dwStatus;

                            // make sure our backup is up to date.
                            dwStatus = TLSRestoreLicenseServerCertificate(
                                                                LSERVER_SERVER_CERTIFICATE_REGKEY,
                                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                                            );
                            if(dwStatus != ERROR_SUCCESS)
                            {
                                TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                                TLSRegDeleteKey(
                                        HKEY_LOCAL_MACHINE,
                                        LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP1
                                    );
                            }
                                    
                            dwStatus = TLSRestoreLicenseServerCertificate(
                                                                LSERVER_SERVER_CERTIFICATE_REGKEY,
                                                                LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                                            );
                            if(dwStatus != ERROR_SUCCESS)
                            {
                                TLSLogWarningEvent(TLS_W_BACKUPCERTIFICATE);

                                TLSRegDeleteKey(
                                        HKEY_LOCAL_MACHINE,
                                        LSERVER_SERVER_CERTIFICATE_REGKEY_BACKUP2
                                    );
                            }
                        }
                    }
                    #endif

                    if(pbLsSignCert)
                    {
                        FreeMemory(pbLsSignCert);
                    }

                    if(pbLsExchCert)
                    {
                        FreeMemory(pbLsExchCert);
                    }
                }
            }
        }
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }

        ReleaseAdministrativeLock();
    }
    else
    {
        status=TLS_E_ALLOCATE_HANDLE;
    }

    ReleaseRPCExclusiveLock();

cleanup:

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_INSTALL_SERV_CERT;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
error_status_t 
TLSRpcGetServerCertificate( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ BOOL bSignCert,
    /* [size_is][size_is][out] */ LPBYTE __RPC_FAR *ppCertBlob,
    /* [ref][out] */ LPDWORD lpdwCertBlobLen,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    InterlockedIncrement( &lpContext->m_RefCount );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetServerCertificate\n"),
            lpContext->m_Client
        );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
    }
    else if(!g_pbExchangeEncodedCert || !g_cbExchangeEncodedCert ||
            !g_pbSignatureEncodedCert || !g_cbSignatureEncodedCert)
    {
        status = TLS_E_NO_CERTIFICATE;
    }
    else 
    {
        if(AcquireAdministrativeLock(INFINITE) == TRUE)
        {
            try{
                status = TLSSaveCertAsPKCS7( 
                                        (bSignCert) ? g_pbSignatureEncodedCert : g_pbExchangeEncodedCert,
                                        (bSignCert) ? g_cbSignatureEncodedCert : g_cbExchangeEncodedCert,
                                        ppCertBlob,
                                        lpdwCertBlobLen
                                    );

                // hack so that we can continue testing...
                if(g_bHasHydraCert == FALSE)
                {
                    if(g_pbServerSPK != NULL && g_cbServerSPK != 0)
                    {
                        status = TLS_W_SELFSIGN_CERTIFICATE;
                    }
                    else
                    {
                        status = TLS_W_TEMP_SELFSIGN_CERT;
                    }
                }
            }
            catch( SE_Exception e ) {
                status = e.getSeNumber();
            }
            catch(...)
            {
                status = TLS_E_INTERNAL;
            }

            ReleaseAdministrativeLock();
        }
        else
        {
            status = TLS_E_ALLOCATE_HANDLE;
        }
    }

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GETSERV_CERT;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);
    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

//-------------------------------------------------------------------------------
void
MyFreeLicenseKeyPack(
    PLicense_KeyPack pLicenseKeyPack 
    )
/*
*/
{
    DWORD i;

    PKeyPack_Description pKpDesc;

    if( pLicenseKeyPack->pDescription )
    {
        for( i = 0, pKpDesc = pLicenseKeyPack->pDescription;
             i < pLicenseKeyPack->dwDescriptionCount;
             i++, pKpDesc++ )
        {
            if(pKpDesc->pDescription)
                LocalFree( pKpDesc->pDescription );

            if(pKpDesc->pbProductName)
                LocalFree( pKpDesc->pbProductName );
        }
    }

    if(pLicenseKeyPack->pDescription)
        LocalFree( pLicenseKeyPack->pDescription );

    if(pLicenseKeyPack->pbManufacturer && pLicenseKeyPack->cbManufacturer != 0)
        LocalFree( pLicenseKeyPack->pbManufacturer );

    if(pLicenseKeyPack->pbManufacturerData && pLicenseKeyPack->cbManufacturerData != 0)
        LocalFree( pLicenseKeyPack->pbManufacturerData );

    if(pLicenseKeyPack->pbProductId && pLicenseKeyPack->cbProductId != 0)
        LocalFree( pLicenseKeyPack->pbProductId );
    return;
}

//---------------------------------------------------------------------
error_status_t 
TLSRpcRegisterLicenseKeyPack( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [size_is][in] */ LPBYTE pbCHCertBlob,
    /* [in] */ DWORD cbCHCertBlobSize,
    /* [size_is][in] */ LPBYTE pbRootCertBlob,
    /* [in] */ DWORD cbRootCertBlob,
    /* [size_is][in] */ LPBYTE lpKeyPackBlob,
    /* [in] */ DWORD dwKeyPackBlobLen,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*++

++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    LSKeyPack keypack;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRegisterLicenseKeyPack\n"),
            lpContext->m_Client
        );

    PTLSDbWorkSpace pDbWkSpace;

    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }


    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status=TLS_E_ALLOCATE_HANDLE;
    }
    else
    {
        License_KeyPack pLicenseKeyPack;
        LicensePackDecodeParm LkpDecodeParm;

        memset(
                &LkpDecodeParm,
                0,
                sizeof(LicensePackDecodeParm)
            );

        LkpDecodeParm.hCryptProv = g_hCryptProv;
        LkpDecodeParm.pbDecryptParm = (PBYTE)g_pszServerPid;
        LkpDecodeParm.cbDecryptParm = (lstrlen(g_pszServerPid) * sizeof(TCHAR));
        LkpDecodeParm.cbClearingHouseCert = cbCHCertBlobSize;
        LkpDecodeParm.pbClearingHouseCert = pbCHCertBlob;
        LkpDecodeParm.pbRootCertificate = pbRootCertBlob;
        LkpDecodeParm.cbRootCertificate = cbRootCertBlob;

        //
        // make code clean, always start a transaction
        //
        CLEANUPSTMT;
        BEGIN_TRANSACTION(pDbWkSpace);

        try {
            status = DecodeLicenseKeyPackEx(
                                    &pLicenseKeyPack,
                                    &LkpDecodeParm,
                                    dwKeyPackBlobLen,
                                    lpKeyPackBlob
                                );

            if(status != LICENSE_STATUS_OK)
            {
                status = TLS_E_DECODE_KEYPACKBLOB;
                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_RPC,
                        DBGLEVEL_FUNCTION_DETAILSIMPLE,
                        _TEXT("Can't decode key pack blob - %d...\n"),
                        status);
            }
            else
            {
                status=TLSDBRegisterLicenseKeyPack(
                                    USEHANDLE(pDbWkSpace), 
                                    &pLicenseKeyPack,
                                    &keypack
                                );

                MyFreeLicenseKeyPack(&pLicenseKeyPack);
            }
        }
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }

        if(TLS_ERROR(status)) 
        {
            ROLLBACK_TRANSACTION(pDbWkSpace);
        }
        else
        {
            COMMIT_TRANSACTION(pDbWkSpace);
        }

        FREEDBHANDLE(pDbWkSpace);
    }

    //
    // Post a sync work object
    //
    if(status == ERROR_SUCCESS)
    {
        if(TLSAnnounceLKPToAllRemoteServer(
                                        keypack.dwKeyPackId,
                                        0
                                    ) != ERROR_SUCCESS)
        {
            TLSLogWarningEvent(TLS_W_ANNOUNCELKP_FAILED);
        }
    }

cleanup:

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_REGISTER_LICENSE_PACK;
    #endif

    InterlockedDecrement( &lpContext->m_RefCount );
    *dwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcRequestTermServCert(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ LPTLSHYDRACERTREQUEST pRequest,
    /* [ref][out][in] */ PDWORD pcbChallengeData,
    /* [size_is][out] */ PBYTE* ppbChallengeData,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine to issue certificate to Terminal Server.

Parameter:

    phContext : Client context handle.
    pRequest : Terminal Server specific certificate request.
    pcbChallengeData : size of Server randomly generated challenge data 
                       to Terminal Server.
    ppbChallengeData : Server randomly generated challenge data to Terminal
                       server.

    pdwErrCode : Error code.

Returns:

    Function always return RPC_S_OK, actual error code is returned in
    pdwErrCode.

Note:

    Routine does not actually issue a license to Terminal Server, Terminal
    Server must call TLSRpcRetrieveTermServCert() to retrieve its own 
    license.

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    LPTERMSERVCERTREQHANDLE lpHandle=NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRequestTermServCert\n"),
            lpContext->m_Client
        );

    *ppbChallengeData = NULL;
    *pcbChallengeData = 0;

    // verify client handle 
    InterlockedIncrement( &lpContext->m_RefCount );
    if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
    {
        SetLastError(status=TLS_E_INVALID_SEQUENCE);
        goto cleanup;
    }

    lpHandle = (LPTERMSERVCERTREQHANDLE)AllocateMemory(
                                                sizeof(TERMSERVCERTREQHANDLE)
                                            );
    if(lpHandle == NULL)
    {
        SetLastError(status = ERROR_OUTOFMEMORY);
        goto cleanup;
    }

    //
    // Generate Challenge Data
    //
    lpHandle->pCertRequest = pRequest;
    status = TLSGenerateChallengeData( 
                        CLIENT_INFO_HYDRA_SERVER,
                        &lpHandle->cbChallengeData,
                        &lpHandle->pbChallengeData
                    );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    // return challenge data
    *pcbChallengeData = lpHandle->cbChallengeData;
    *ppbChallengeData = (PBYTE)midl_user_allocate(*pcbChallengeData);
    if(*ppbChallengeData == NULL)
    {
        SetLastError(status = ERROR_OUTOFMEMORY);
        goto cleanup;
    }

    memcpy( *ppbChallengeData,
            lpHandle->pbChallengeData,
            lpHandle->cbChallengeData);

    lpContext->m_ContextHandle = (HANDLE)lpHandle;
    lpContext->m_ContextType = CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE;

cleanup:

    if(status != ERROR_SUCCESS)
    {
        // frees up memory.
        // Can't overwrite context type.
        //lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;

        if(lpHandle != NULL)
        {
            FreeMemory(lpHandle->pbChallengeData);
            FreeMemory(lpHandle);
        }

        if(*ppbChallengeData != NULL)
        {
            midl_user_free(*ppbChallengeData);
        }

        if(pRequest != NULL)
        {
            midl_user_free(pRequest);
        }

        *ppbChallengeData = NULL;
        *pcbChallengeData = 0;
    }

    InterlockedDecrement( &lpContext->m_RefCount );
    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_REQUEST_TERMSRV_CERT;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcRetrieveTermServCert(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbResponseData,
    /* [size_is][in] */ PBYTE pbResponseData,
    /* [ref][out][in] */ PDWORD pcbCert,
    /* [size_is][out] */ PBYTE* ppbCert,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine to retrieve Terminal Server's license.

Parameters:

    phContext : client context handle.
    cbResponseData : size of Terminal Server responses data to 
                     license server's challenge.
    pbResponseData : Terminal Server responses data to license 
                     server's challenge.
    pcbCert : Size of Terminal Server's license in bytes.
    ppbCert : Terminal Server's license.
    pdwErrCode : error code if fail.

Returns:

    Function returns RPC_S_OK, actual error code returns in
    pdwErrCode.

Note:

    Must have call TLSRpcRequestTermServCert().


--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    LPTERMSERVCERTREQHANDLE lpHandle=NULL;
    CTLSPolicy* pPolicy=NULL;
    PMHANDLE hClient;

    PBYTE pbPkcs7=NULL;
    DWORD cbPkcs7=0;
    TLSDBLICENSEREQUEST LicenseRequest;
    DWORD dwQuantity = 1;
    TLSPRODUCTINFO ProductInfo;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE];
    TCHAR szMachineName[MAXCOMPUTERNAMELENGTH];
    TCHAR szUserName[MAXUSERNAMELENGTH];

    PTLSDbWorkSpace pDbWkSpace;

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;

    TLSDBLICENSEDPRODUCT LicensedProduct;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

	

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcRetrieveTermServCert\n"),
            lpContext->m_Client
        );


    // verify client handle 
    InterlockedIncrement( &lpContext->m_RefCount );
    if(lpContext->m_ContextType != CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE)
    {
        SetLastError(status = TLS_E_INVALID_SEQUENCE);
        goto cleanup;
    }

    lpHandle = (LPTERMSERVCERTREQHANDLE)lpContext->m_ContextHandle;
    if( lpHandle == NULL || lpHandle->pCertRequest == NULL ||
        lpHandle->pCertRequest->pbEncryptedHwid == NULL ||
        lpHandle->pCertRequest->cbEncryptedHwid == 0 )
    {
        SetLastError(status = TLS_E_INVALID_SEQUENCE);
        goto cleanup;
    }

	
    //
    // Verify challenge response data
    //

    
    //
    // Request a license from specific key pack
    //

    memset(&LicenseRequest, 0, sizeof(TLSDBLICENSEREQUEST));

    if(!LoadResourceString(
                IDS_HS_COMPANYNAME,
                szCompanyName,
                sizeof(szCompanyName) / sizeof(szCompanyName[0])))
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }    

    if(lpContext->m_Client == NULL)
    {
        if(!LoadResourceString(
                    IDS_HS_MACHINENAME,
                    LicenseRequest.szMachineName,
                    sizeof(LicenseRequest.szMachineName)/sizeof(LicenseRequest.szMachineName[0])))
        {
            SetLastError(status = TLS_E_INTERNAL);
            goto cleanup;
        }

        if(!LoadResourceString(
                    IDS_HS_USERNAME,
                    LicenseRequest.szUserName,
                    sizeof(LicenseRequest.szUserNam