 taken from a GC or not

Arguments:

    lpServer - The server to get the Facts from

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    handle_t Handle = NULL;

    if(IsBadWritePtr(lpDNSDomainName,
                     sizeof(LPWSTR*) )){
        return ERROR_INVALID_PARAMETER;
    }

    Win32Err = DsRolepServerBind( (PDSROLE_SERVER_NAME)lpServer,
                                  &Handle );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );                     
    }
    
    RpcTryExcept {

        Win32Err = DsRolerGetDatabaseFacts( Handle,
                                          ( LPWSTR )lpRestorePath,
                                          lpDNSDomainName,
                                          State );
    } RpcExcept( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err = DsRolepApiReturnResult( RpcExceptionCode( ) );

    } RpcEndExcept;

    DsRolepServerUnbind( (PDSROLE_SERVER_NAME)lpServer, Handle );


    return Win32Err;
}



//
// Local functions
//
DWORD
DsRolepGetPrimaryDomainInformationDownlevel(
    IN LPWSTR Server,
    OUT PBYTE *Buffer
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_PRIMARY_DOMAIN_INFO PDI = NULL;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRole = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO ADI = NULL;
    UNICODE_STRING UnicodeServer;
    OBJECT_ATTRIBUTES OA;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC PDIB = NULL;
    DSROLE_MACHINE_ROLE MachineRole = DsRole_RoleStandaloneServer;
    NT_PRODUCT_TYPE ProductType;

    Win32Err = DsRolepGetProductTypeForServer( Server, &ProductType );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }


    InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL);
    if ( Server ) {

        RtlInitUnicodeString( &UnicodeServer, Server );
    }

    Status = LsaOpenPolicy( Server ? &UnicodeServer : NULL,
                            &OA,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyPrimaryDomainInformation,
                                            ( PVOID * ) &PDI );

        if ( NT_SUCCESS( Status ) ) {

            switch ( ProductType ) {
            case NtProductWinNt:
                if ( PDI->Sid == NULL ) {

                    MachineRole = DsRole_RoleStandaloneWorkstation;

                } else {

                    MachineRole = DsRole_RoleMemberWorkstation;

                }
                break;

            case NtProductServer:
                if ( PDI->Sid == NULL ) {

                    MachineRole = DsRole_RoleStandaloneServer;

                } else {

                    MachineRole = DsRole_RoleMemberServer;

                }
                break;

            case NtProductLanManNt:

                Status = LsaQueryInformationPolicy( PolicyHandle,
                                                    PolicyLsaServerRoleInformation,
                                                    ( PVOID * )&ServerRole );
                if ( NT_SUCCESS( Status ) ) {

                    if ( ServerRole->LsaServerRole == PolicyServerRolePrimary ) {

                        //
                        // If we think we're a primary domain controller, we'll need to
                        // guard against the case where we're actually standalone during setup
                        //
                        Status = LsaQueryInformationPolicy( PolicyHandle,
                                                            PolicyAccountDomainInformation,
                                                            ( PVOID * )&ADI );
                        if ( NT_SUCCESS( Status ) ) {


                            if ( PDI->Sid == NULL ||
                                 ADI->DomainSid == NULL ||
                                 !RtlEqualSid( ADI->DomainSid, PDI->Sid ) ) {

                                MachineRole = DsRole_RoleStandaloneServer;

                            } else {

                                MachineRole = DsRole_RolePrimaryDomainController;

                            }
                        }


                    } else {

                        MachineRole = DsRole_RoleBackupDomainController;
                    }
                }

                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

        }

        //
        // Build the return buffer
        //
        if ( NT_SUCCESS( Status ) ) {

            PDIB = MIDL_user_allocate( sizeof( DSROLE_PRIMARY_DOMAIN_INFO_BASIC ) +
                                       PDI->Name.Length + sizeof( WCHAR ) );

            if ( PDIB == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlZeroMemory( PDIB, sizeof( DSROLE_PRIMARY_DOMAIN_INFO_BASIC ) +
                                       PDI->Name.Length + sizeof( WCHAR ) );

                PDIB->MachineRole = MachineRole;
                PDIB->DomainNameFlat = ( LPWSTR ) ( ( PBYTE )PDIB +
                                                sizeof( DSROLE_PRIMARY_DOMAIN_INFO_BASIC ) );
                RtlCopyMemory( PDIB->DomainNameFlat, PDI->Name.Buffer, PDI->Name.Length );

                *Buffer = ( PBYTE )PDIB;
            }
        }

        LsaClose( PolicyHandle );

        LsaFreeMemory( PDI );

        if ( ADI != NULL ) {

            LsaFreeMemory( ADI );
        }

        if ( ServerRole != NULL ) {

            LsaFreeMemory( ServerRole );
        }
    }

    Win32Err = RtlNtStatusToDosError( Status );

    return( Win32Err );
}


DWORD
DsRolepGetProductTypeForServer(
    IN LPWSTR Server,
    IN OUT PNT_PRODUCT_TYPE ProductType
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR RegServer = NULL;
    HKEY RemoteKey, ProductKey;
    PBYTE Buffer = NULL;
    ULONG Type, Size = 0;



    if ( Server == NULL ) {

        if ( RtlGetNtProductType( ProductType ) == FALSE ) {

            Win32Err = RtlNtStatusToDosError( STATUS_UNSUCCESSFUL );

        }

    } else {

        if ( wcslen( Server ) > 2 && *Server == L'\\' && *( Server + 1 ) == L'\\' ) {

            RegServer = Server;

        } else {

            RegServer = LocalAlloc( LMEM_FIXED, ( wcslen( Server ) + 3 ) * sizeof( WCHAR ) );

            if ( RegServer ) {

                swprintf( RegServer, L"\\\\%ws", Server );

            } else {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegConnectRegistry( RegServer,
                                           HKEY_LOCAL_MACHINE,
                                           &RemoteKey );

            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = RegOpenKeyEx( RemoteKey,
                                         L"system\\currentcontrolset\\control\\productoptions",
                                         0,
                                         KEY_READ,
                                         &ProductKey );

                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegQueryValueEx( ProductKey,
                                                L"ProductType",
                                                0,
                                                &Type,
                                                0,
                                                &Size );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Buffer = LocalAlloc( LMEM_FIXED, Size );

                        if ( Buffer ) {

                            Win32Err = RegQueryValueEx( ProductKey,
                                                        L"ProductType",
                                                        0,
                                                        &Type,
                                                        Buffer,
                                                        &Size );

                            if ( Win32Err == ERROR_SUCCESS ) {

                                if ( !_wcsicmp( ( PWSTR )Buffer, L"LanmanNt" ) ) {

                                    *ProductType = NtProductLanManNt;

                                } else if ( !_wcsicmp( ( PWSTR )Buffer, L"ServerNt" ) ) {

                                    *ProductType = NtProductServer;

                                } else if ( !_wcsicmp( ( PWSTR )Buffer, L"WinNt" ) ) {

                                    *ProductType = NtProductWinNt;

                                } else {

                                    Win32Err = ERROR_UNKNOWN_PRODUCT;
                                }
                            }

                            LocalFree( Buffer );

                        } else {

                            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    RegCloseKey( ProductKey );
                }


                RegCloseKey( RemoteKey );
            }

        }

        if ( RegServer != Server ) {

            LocalFree( RegServer );
        }
    }

    return( Win32Err );

}

NTSTATUS
DsRolepRandomFill(
    IN ULONG BufferSize,
    IN OUT PUCHAR Buffer
)
/*++

Routine Description:

    This routine fills a buffer with random data.

Parameters:

    BufferSize - Length of the input buffer, in bytes.

    Buffer - Input buffer to be filled with random data.

Return Values:

    Errors from NtQuerySystemTime()


--*/
{
    ULONG Index;
    LARGE_INTEGER Time;
    ULONG Seed;
    NTSTATUS NtStatus;


    NtStatus = NtQuerySystemTime(&Time);
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    Seed = Time.LowPart ^ Time.HighPart;

    for (Index = 0 ; Index < BufferSize ; Index++ )
    {
        *Buffer++ = (UCHAR) (RtlRandom(&Seed) % 256);
    }
    return(STATUS_SUCCESS);

}

DWORD
DsRolepEncryptPasswordStart(
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR *Passwords,
    IN ULONG   Count,
    OUT RPC_BINDING_HANDLE *RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    IN OUT PDSROLEPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPasswords
    )
/*++

Routine Description:

    This routine takes a number of cleartext unicode NT password from the user,
    and encrypts them with the session key.
    
    This routine's algorithm was taken from CliffV's work when encrypting the
    passwords for the NetrJoinDomain2 interface.

Parameters:

    ServerName - UNC server name of the server to remote the API to

    Passwords - the cleartext unicode NT passwords.
    
    Count - the number of password

    RpcBindingHandle - RPC handle used for acquiring a session key.

    RedirHandle - Returns a handle to the redir.  Since RpcBindingHandles don't represent
        and open connection to the server, we have to ensure the connection stays open
        until the server side has a chance to get this same UserSessionKey.  The only
        way to do that is to keep the connect open.

        Returns NULL if no handle is needed.

    EncryptedUserPassword - receives the encrypted cleartext passwords.
        If lpPassword is NULL, a NULL is returned for that entry.

Return Values:

    If this routine returns NO_ERROR, the returned data must be freed using
        LocalFree.


--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    PDSROLEPR_USER_PASSWORD UserPassword = NULL;
    ULONG PasswordSize;
    ULONG i;

    //
    // Initialization
    //

    *RpcBindingHandle = NULL;
    *RedirHandle = NULL;
    for ( i = 0; i < Count; i++ ) {
        EncryptedUserPasswords[i] = NULL;
    }

    //
    // Verify parameters
    //
    for ( i = 0; i < Count; i++ ) {
        if ( Passwords[i] ) {
            PasswordSize = wcslen( Passwords[i] ) * sizeof(WCHAR);
            if ( PasswordSize > DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
                WinError = ERROR_PASSWORD_RESTRICTION;
                goto Cleanup;
            }
        }
    }

    //
    // Get an RPC handle to the server.
    //

    WinError = DsRolepServerBind( (PDSROLE_SERVER_NAME) ServerName,
                                  RpcBindingHandle );

    if ( ERROR_SUCCESS != WinError ) {
        goto Cleanup;
    }

    //
    // Get the session key.
    //

    NtStatus = RtlGetUserSessionKeyClientBinding(
                   *RpcBindingHandle,
                   RedirHandle,
                   &UserSessionKey );

    if ( !NT_SUCCESS(NtStatus) ) {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    //
    // Encrypt the passwords
    //
    for ( i = 0; i < Count; i++ ) {
        

        if ( NULL == Passwords[i] ) {
            // Nothing to encrypt
            continue;
        }

        PasswordSize = wcslen( Passwords[i] ) * sizeof(WCHAR);

        //
        // Allocate a buffer to encrypt and fill it in.
        //
    
        UserPassword = LocalAlloc( 0, sizeof(DSROLEPR_USER_PASSWORD) );
    
        if ( UserPassword == NULL ) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    
        //
        // Copy the password into the tail end of the buffer.
        //
    
        RtlCopyMemory(
            ((PCHAR) UserPassword->Buffer) +
                (DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                PasswordSize,
            Passwords[i],
            PasswordSize );
    
        UserPassword->Length = PasswordSize;
    
        //
        // Fill the front of the buffer with random data
        //
    
        NtStatus = DsRolepRandomFill(
                    (DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        PasswordSize,
                    (PUCHAR) UserPassword->Buffer );
    
        if ( !NT_SUCCESS(NtStatus) ) {
            WinError = RtlNtStatusToDosError( NtStatus );
            goto Cleanup;
        }
    
        NtStatus = DsRolepRandomFill(
                    DSROLE_OBFUSCATOR_LENGTH,
                    (PUCHAR) UserPassword->Obfuscator );

        if ( !NT_SUCCESS(NtStatus) ) {
            WinError = RtlNtStatusToDosError( NtStatus );
            goto Cleanup;
        }
    
    
        //
        // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
        //  strings with a single key is weak (if you crack one you've cracked them all).
        //  So compute a key that's unique for this particular encryption.
        //
        //
    
        MD5Init(&Md5Context);
    
        MD5Update( &Md5Context, (LPBYTE)&UserSessionKey, sizeof(UserSessionKey) );
        MD5Update( &Md5Context, UserPassword->Obfuscator, sizeof(UserPassword->Obfuscator) );
    
        MD5Final( &Md5Context );
    
        rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );
    
    
        //
        // Encrypt it.
        //  Don't encrypt the obfuscator.  The server needs that to compute the key.
        //
    
        rc4( &Rc4Key, sizeof(UserPassword->Buffer)+sizeof(UserPassword->Length), (LPBYTE) UserPassword->Buffer );

        EncryptedUserPasswords[i] = (PDSROLEPR_ENCRYPTED_USER_PASSWORD) UserPassword;
        UserPassword = NULL;

    }

    WinError = ERROR_SUCCESS;

Cleanup:

    if ( WinError != ERROR_SUCCESS ) {
        if ( UserPassword != NULL ) {
            LocalFree( UserPassword );
        }
        if ( *RpcBindingHandle != NULL ) {
            DsRolepServerUnbind( NULL, *RpcBindingHandle );
            *RpcBindingHandle = NULL;
        }
        if ( *RedirHandle != NULL ) {
            NtClose( *RedirHandle );
            *RedirHandle = NULL;
        }
        for ( i = 0; i < Count; i++ ) {
            if ( EncryptedUserPasswords[i] ) {
                LocalFree( EncryptedUserPasswords[i] );
                EncryptedUserPasswords[i] = NULL;
            }
        }
    }

    return WinError;
}


VOID
DsRolepEncryptPasswordEnd(
    IN RPC_BINDING_HANDLE RpcBindingHandle,
    IN HANDLE RedirHandle OPTIONAL,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD *EncryptedUserPasswords OPTIONAL,
    IN ULONG Count
    )
/*++

Routine Description:

    This routine takes the variables returned by DsRolepEncryptPasswordStart and
    frees them.

Parameters:

    RpcBindingHandle - RPC handle used for acquiring a session key.

    RedirHandle - Handle to the redirector

    EncryptedUserPasswords - the encrypted cleartext passwords.
    
    Count - the number of passwords

Return Values:

--*/
{
    ULONG i;

    //
    // Free the RPC binding handle.
    //

    if ( RpcBindingHandle != NULL ) {
        (VOID) DsRolepServerUnbind ( NULL, RpcBindingHandle );
    }

    //
    // Close the redir handle.
    //

    if ( RedirHandle != NULL ) {
        NtClose( RedirHandle );
    }

    //
    // Free the encrypted passwords.
    //

    for ( i = 0; i < Count; i++ ) {
        if ( EncryptedUserPasswords[i] != NULL ) {
            LocalFree( EncryptedUserPasswords[i] );
        }
    }

    return;
}

DWORD
DsRolepHashkey(
    IN OUT LPWSTR key,
    OUT PVOID  SysKey,
    IN ULONG cbSysKey
    )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    MD5_CTX Md5;
    if(cbSysKey<SYSKEY_SIZE) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    cbSysKey=wcslen(key)*sizeof(WCHAR);

    MD5Init( &Md5 );
    MD5Update( &Md5, (PUCHAR) key, cbSysKey );
    MD5Final( &Md5 );

    ZeroMemory( key, cbSysKey );

    cbSysKey=SYSKEY_SIZE;
    CopyMemory( SysKey, Md5.digest, cbSysKey );

    return ERROR_SUCCESS;
}

DWORD
DsRolepEncryptHash(
    IN OUT PUNICODE_STRING EncryptedSyskey
    )
/*++

    Routine Description

    This routine is used to store the boot type
    in the registry

    Paramaeters

        NewType Indicates the new boot type

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
--*/
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\inc\dssetcon.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetcon.h

Abstract:

    This file contains contains structures and definitions to be including
    in both the dssetup.idl file and regular C code

Author:

Environment:

Revision History:

--*/

#define DSROLE_OBFUSCATOR_LENGTH 8
#define DSROLE_MAX_PASSWORD_LENGTH PWLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:

!INCLUDE $(NTMAKEENV)\makefile.plt

CLIENT_ACF = dssetup.acf
SERVER_ACF = dssetups.acf

CLIENT_INC_FILE = dssetup_c.h
SERVER_INC_FILE = dssetrpc.h

INCS  = -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(DS_INC_PATH) -I..\inc

# take MIDL_OPTIMIZATION_NT5 from tools\makefile.plt.

MIDL_FLAGS= $(MIDL_FLAGS) -out .\$(O)

CLIENT_FLAGS = -oldnames -c_ext -ms_ext $(MIDL_FLAGS)  -acf $(CLIENT_ACF) -header $(CLIENT_INC_FILE) -server none
SERVER_FLAGS = -oldnames -c_ext -ms_ext $(MIDL_FLAGS)  -acf $(SERVER_ACF) -header $(SERVER_INC_FILE) -client none

CPP = -cpp_cmd "$(MIDL_CPP)" 

#
# Separate client and server targets.  Note that the .h file produced
# when MIDL is run with the client .acf file attached differs from the
# .h file produced when MIDL is run with the server .acf file attached.
#

CLIENT_TARGETS = $(O)\dssetup_c.c  \
                 $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = $(O)\dssetup_s.c  \
                 $(O)\$(SERVER_INC_FILE)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

#
# MIDL COMPILE
#
$(CLIENT_TARGETS) : dssetup.idl $(CLIENT_ACF)
    midl $(CPP) $(MIDL_OPTIMIZATION_NT5) $(CLIENT_FLAGS) $(INCS) dssetup.idl

$(SERVER_TARGETS) : dssetup.idl $(SERVER_ACF)
    midl $(CPP) $(MIDL_OPTIMIZATION_NT5) $(SERVER_FLAGS) $(INCS) dssetup.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\inc\dssetp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __DSSETP_H__
#define __DSSETP_H__

#include <winldap.h>
#include <dsysdbg.h>
#include <dssetrpc.h>
#include <dns.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <logonmsv.h>

#define DEB_TRACE_DS        0x00000008
#define DEB_TRACE_UPDATE    0x00000010
#define DEB_TRACE_LOCK      0x00000020
#define DEB_TRACE_SERVICES  0x00000040
#define DEB_TRACE_NET       0x00000080

#if DBG

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT  DsysAssert

    DECLARE_DEBUG2( DsRole )

    #define DsRoleDebugOut( args ) DsRoleDebugPrint args

    VOID
    DsRoleDebugInitialize(
        VOID
        );


#else

    #define  DsRoleDebugOut(args)
    #define  DsRoleDebugInitialize()

#endif  // DBG


#define DSROLEP_EVENT_NAME L"\\DsRoleLsaEventName"
#define DSROLEP_PROD_KEY_PATH L"System\\CurrentControlSet\\Control\\ProductOptions"
#define DSROLEP_PROD_VALUE L"ProductType"
#define DSROLEP_SERVER_PRINCIPAL_NAME L"DsRole"

extern handle_t ClientBindingHandle;

//
// Determines whether a bit flag is turned on or not
//
#define FLAG_ON(flag,bits)        ((flag) & (bits))
#define FLAG_OFF(flag,bits)       (!FLAG_ON(flag,bits))

#define NELEMENTS(x)  (sizeof(x)/sizeof((x)[0]))

#define DSROLEP_MIDL_ALLOC_AND_COPY_STRING_ERROR( dest, src, err )                              \
if ( (src) ) {                                                                                  \
    (dest) = MIDL_user_allocate(  (wcslen( (src) ) + 1) * sizeof( WCHAR ) );                    \
    if ( !(dest) ) {                                                                            \
        err = ERROR_NOT_ENOUGH_MEMORY;                                                          \
    } else {                                                                                    \
        wcscpy((dest), (src));                                                                  \
    }                                                                                           \
} else {                                                                                        \
    (dest) = NULL;                                                                              \
}

//
// Options for specifiying the behavior of the path validation function
//
#define DSROLEP_PATH_VALIDATE_EXISTENCE 0x00000001
#define DSROLEP_PATH_VALIDATE_LOCAL     0x00000002
#define DSROLEP_PATH_VALIDATE_NTFS      0x00000004


typedef enum _DSROLEP_MACHINE_TYPE {

    DSROLEP_MT_CLIENT = 0,
    DSROLEP_MT_STANDALONE,
    DSROLEP_MT_MEMBER

} DSROLEP_MACHINE_TYPE, *PDSROLEP_MACHINE_TYPE;

//
// Utility functions
//
DWORD
DsRolepDecryptPassword(
    IN PUNICODE_STRING EncryptedPassword,
    IN OUT PUNICODE_STRING DecryptedPassword,
    OUT PUCHAR Seed
    );

DWORD
DsRolepGetMachineType(
    IN OUT PDSROLEP_MACHINE_TYPE MachineType );

NTSTATUS
DsRolepInitialize(
    VOID
    );

NTSTATUS
DsRolepInitializePhase2(
    VOID
    );

DWORD
DsRolepSetProductType(
    IN DSROLEP_MACHINE_TYPE MachineType
    );

DWORD
DsRolepCreateAuthIdentForCreds(
    IN PWSTR Account,
    IN PWSTR Password,
    OUT PSEC_WINNT_AUTH_IDENTITY *AuthIdent
    );

VOID
DsRolepFreeAuthIdentForCreds(
    IN  PSEC_WINNT_AUTH_IDENTITY AuthIdent
    );

DWORD
DsRolepForceTimeSync(
    IN HANDLE ImpToken,
    IN PWSTR TimeSource
    );

DWORD
DsRolepDnsNameToFlatName(
    IN  LPWSTR DnsName,
    OUT LPWSTR *FlatName,
    OUT PULONG StatusFlag
    );

DWORD
DsRolepValidatePath(
    IN  LPWSTR Path,
    IN  ULONG ValidationCriteria,
    OUT PULONG MatchingCriteria
    );

DWORD
DsRolepCopyDsDitFiles(
    IN LPWSTR DsPath
    );

DWORD
DsRolepSetDcSecurity(
    IN HANDLE ClientToken,
    IN LPWSTR SysvolRootPath,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN BOOLEAN Upgrade,
    IN BOOLEAN Replica
    );

DWORD
DsRolepDsGetDcForAccount(
    IN LPWSTR Server OPTIONAL, 
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );

DWORD
DsRolepSetMachineAccountType(
    IN LPWSTR Dc,
    IN HANDLE ClientToken,
    IN LPWSTR User,
    IN LPWSTR Password,
    IN LPWSTR AccountName,
    IN ULONG AccountBits,
    IN OUT WCHAR** AccountDn OPTIONAL
    );

NTSTATUS
DsRolepGetMixedModeFlags(
    IN PSID DomainSid,
    OUT PULONG Flags
    );

//
// Prototype from protos.h
//
ULONG
SpmpReportEvent(
    IN BOOL Unicode,
    IN WORD EventType,
    IN ULONG EventId,
    IN ULONG Category,
    IN ULONG SizeOfRawData,
    IN PVOID RawData,
    IN ULONG NumberOfStrings,
    ...
    );

DWORD
DsRolepGenerateRandomPassword(
    IN ULONG Length,
    IN WCHAR *Buffer
    );


DWORD
DsRolepDelnodePath(
    IN  LPWSTR Path,
    IN  ULONG BufferSize,
    IN  BOOLEAN DeleteRoot
    );

DWORD
DsRolepIsDnsNameChild(
    IN  LPWSTR ParentDnsName,
    IN  LPWSTR ChildDnsName
    );

DWORD                         
ImpDsRolepDsGetDcForAccount(
    IN HANDLE CallerToken,
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );

NET_API_STATUS
NET_API_FUNCTION
ImpNetpManageIPCConnect(
    IN  HANDLE  CallerToken,
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  ULONG   fOptions
    );

NTSTATUS
ImpLsaOpenPolicy(
    IN HANDLE CallerToken,
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
ImpLsaDelete(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    );

NTSTATUS
ImpLsaQueryInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );


NTSTATUS
ImpLsaOpenTrustedDomainByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );

NTSTATUS
ImpLsaOpenTrustedDomain(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
ImpLsaCreateTrustedDomainEx(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
ImpLsaQueryTrustedDomainInfoByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
ImpLsaQueryDomainInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    );

NTSTATUS
ImpLsaClose(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    );

#endif // __DSSETP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\cancel.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition

#include "cancel.h"

DWORD
DsRolepCancel(
    BOOL BlockUntilDone
    )
/*++

Routine Description:

    This routine will cancel a currently running operation

Arguments:

    BlockUntilDone - if TRUE, then this call waits for the current operation to
                     complete before returning. Otherwise return without waiting

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    BOOL     fWaitForCancelToFinish = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Canceling current operation...\n" ));

    //
    // Grab the global lock
    //
    LockOpHandle();

    //
    // Determine if we are in a cancelable state
    //
    if (  (DsRolepCurrentOperationHandle.OperationState == DSROLEP_FINISHED)
       || (DsRolepCurrentOperationHandle.OperationState == DSROLEP_CANCELING) ) {

        //
        // Cancel is happening or just finished, just leave
        //
        Win32Err = ERROR_SUCCESS;
        fWaitForCancelToFinish = FALSE;

        DsRolepLogPrint(( DEB_TRACE, "Cancel already happened or the operation is finished.\n" ));

    } else if ( !( (DsRolepCurrentOperationHandle.OperationState == DSROLEP_RUNNING)
                 ||(DsRolepCurrentOperationHandle.OperationState == DSROLEP_RUNNING_NON_CRITICAL)) ) {

        //
        // Invalid state transition requested
        //
        Win32Err = ERROR_NO_PROMOTION_ACTIVE;

    } else {

        // Tell the ds to cancel

        //
        // N.B.  This callout to the ds is made under lock.
        //
        DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstallCancel );

        if ( ERROR_SUCCESS == Win32Err ) {

            Win32Err = ( *DsrNtdsInstallCancel )();

        }

        if ( ERROR_SUCCESS == Win32Err )
        {
            Status = NtSetEvent( DsRolepCurrentOperationHandle.CancelEvent, NULL );

            if ( !NT_SUCCESS( Status ) ) {

                Win32Err = RtlNtStatusToDosError( Status );

            } else {

                DsRolepCurrentOperationHandle.OperationState = DSROLEP_CANCELING;

            }

        } else {

            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_ERROR,
                                                   "Unable to cancel the ds%lu\n",
                                                   Win32Err )) );
        }
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    //
    // Now, wait for the operation to complete
    //
    if ( Win32Err == ERROR_SUCCESS 
      && fWaitForCancelToFinish  
      && BlockUntilDone  ) {

        DsRolepLogPrint(( DEB_TRACE, "Waiting for the role change operation to complete\n" ));

        Status = NtWaitForSingleObject( DsRolepCurrentOperationHandle.CompletionEvent, TRUE, 0 );

        if ( !NT_SUCCESS( Status ) ) {

            Win32Err = RtlNtStatusToDosError( Status );
        }
    }

    DsRolepLogPrint(( DEB_TRACE, "Request for cancel returning %lu\n", Win32Err ));

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\dssetup_s_stub.c ===
#include "dssetup_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\cancel.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cancel.h

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __CANCEL_H__
#define __CANCEL_H__

DWORD
DsRolepCancel(
    BOOL BlockUntilDone
    );

#endif // __CANCEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\dsrolepl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsrolep.h

Abstract:

    Definitions and globals for internal only debug and support routines

Author:

    Mac McLain      (MacM)       Aug 11, 1997

Environment:

Revision History:

--*/
#ifndef __DSROLEP1_H__
#define __DSROLEP1_H__

#define DSROLEP_VERBOSE_LOGGING

#ifdef DSROLEP_VERBOSE_LOGGING

extern HANDLE DsRolepLogFile;

#define DSROLEP_LOGNAME L"\\debug\\DCPROMO.LOG"
#define DSROLEP_BAKNAME L"\\debug\\DCPROMO.BAK"

DWORD
DsRolepInitializeLog(
    VOID
    );

DWORD
DsRolepSetAndClearLog(
    VOID
    );

DWORD
DsRolepCloseLog(
    VOID
    );

VOID
DsRolepLogPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define DsRolepLogPrint( x )  DsRolepLogPrintRoutine x
#define DsRolepDisplayOptional( y ) y ? y : L"(NULL)"
#define DsRolepLogOnFailure( z, a ) if ( z != ERROR_SUCCESS ) a
#define DsRolepLogGuid( l, t, g )  g == NULL ? DsRolepLogPrint(( l, "%S (NULL)\n", t )) :       \
        DsRolepLogPrint(( l, "%S %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",            \
                        t,(g)->Data1,(g)->Data2,(g)->Data3,(g)->Data4[0],                       \
                        (g)->Data4[1],(g)->Data4[2],(g)->Data4[3],(g)->Data4[4],                \
                        (g)->Data4[5],(g)->Data4[6],(g)->Data4[7]))

#define DsRolepLogSid( l, t, s )                                                                \
{ LPWSTR sidstring;                                                                             \
  ConvertSidToStringSidW( s, &sidstring );                                                      \
  DsRolepLogPrint(( l, "%S %ws\n", t, sidstring ));                                             \
  LocalFree(sidstring);                                                                         \
}
                                                                                               
#define DsRolepUnicodestringtowstr( s, u )                                                      \
{ s = (WCHAR*)malloc(u.Length+sizeof(WCHAR));                                                               \
  if (s){                                                                                       \
      CopyMemory(s,u.Buffer,u.Length);                                                          \
      s[u.Length/sizeof(WCHAR)] = L'\0';                                                        \
  }                                                                                             \
}



#else

#define DsRolepInitializeLog()
#define DsRolepCloseLog()
#define DsRolepLogPrint( x )
#define DsRolepDisplayOptional( y )
#define DsRolepLogOnFailure( z, a )
#define DsRolepLogGuid( t, g )
#define DsRolepLogSid( t, s )
#define DsRolepSetAndClearLog()
#define DsRolepUnicodestringtowstr( s, u )
#endif

#endif // __DSROLEP1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    Implementation of the server side of the DsRole API's

Author:

    Colin Brace        (ColinBr)    April 5, 1999.

Environment:

    User Mode

Revision History:

    Reorg'ed from code written by
    
    Mac McLain          (MacM)       Feb 10, 1997

--*/

#include <setpch.h>
#include <dssetp.h>
#include <dsgetdc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <lsarpc.h>
#include <db.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>
#include <loadfn.h>
#include <lmjoin.h>
#include <netsetup.h>
#include <lmcons.h>
#include <lmerr.h>
#include <icanon.h>
#include <dsrole.h>
#include <dsrolep.h>
#include <dsconfig.h>

#include <crypt.h>
#include <rc4.h>
#include <md5.h>

#include "secure.h"
#include "threadman.h"
#include "upgrade.h"
#include "cancel.h"


//
// Static global.  This flag is used to indicate that the system is installed enough to get
// us going.  There is no need to protect it, since it is only toggled from off to on
//
static BOOLEAN DsRolepSamInitialized = FALSE;

//
// Local forwards
//
DWORD
DsRolepWaitForSam(
    VOID
    );

DWORD
DsRolepCheckFilePaths(
    IN LPWSTR DsDirPath,
    IN LPWSTR DsLogPath,
    IN LPWSTR SysVolPath
    );

DWORD
DsRolepIsValidProductSuite(
    IN BOOL fNewForest,
    IN BOOL fReplica,
    IN LPWSTR DomainName
    );

DWORD
DsRolepDecryptPasswordsWithKey(
    IN handle_t RpcBindingHandle,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD * EncryptedPasswords,
    IN ULONG Count,
    IN OUT UNICODE_STRING *EncodedPasswords,
    OUT PUCHAR Seed
    );

VOID
DsRolepFreePasswords(
    IN OUT UNICODE_STRING *Passwords,
    IN ULONG Count
    );

DWORD
DsRolepDecryptHash(
    IN PUNICODE_STRING BootKey
    );


//
// RPC dispatch routines
//
DWORD
DsRolerDcAsDc(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FlatDomainName,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDomainAdminPassword, OPTIONAL
    IN  LPWSTR SiteName OPTIONAL,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR SystemVolumeRootPath,
    IN  LPWSTR ParentDnsDomainName OPTIONAL,
    IN  LPWSTR ParentServer OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword, OPTIONAL
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDsRepairPassword, OPTIONAL
    IN  ULONG Options,
    OUT PDSROLER_HANDLE DsOperationHandle)
/*++

Routine Description:

    Rpc server routine for installing a server as a DC

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords       

    DnsDomainName - Dns domain name of the domain to install

    FlatDomainName - NetBIOS domain name of the domain to install

    EDomainAdminPassword - Encrypted password to set on the administrator account if it is a new install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go

    SystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.

    ParentDnsDomainName - Optional.  If present, set this domain up as a child of the
        specified domain

    Account - User account to use when setting up as a child domain

    EPassword - Encrypted password to use with the above account
    
    EDsRepairPassword - Encrypted password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_INVALID_STATE - This machine is not a server

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    DSROLEP_MACHINE_TYPE MachineRole;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs;
    UCHAR Seed = 0;

    NTSTATUS Status;
    HANDLE Policy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ServerInfo = NULL;

    BOOL fHandleInit = FALSE;

#define DSROLEP_DC_AS_DC_DA_PWD_INDEX        0
#define DSROLEP_DC_AS_DC_PWD_INDEX           1
#define DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX 2
#define DSROLEP_DC_AS_DC_MAX_PWD_COUNT       3

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DC_AS_DC_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_DC_AS_DC_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_DC_AS_DC_DA_PWD_INDEX]        = EDomainAdminPassword;
    EncryptedPasswords[DSROLEP_DC_AS_DC_PWD_INDEX]           = EPassword;
    EncryptedPasswords[DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX] = EDsRepairPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );

    //
    // Do some parameter checking
    //
    if (   !DnsDomainName 
        || !DsDatabasePath 
        || !DsLogPath 
        || !FlatDomainName 
        || !SystemVolumeRootPath ) {

         return( ERROR_INVALID_PARAMETER );

    }

    if ( !ParentDnsDomainName 
      && !SiteName )
    {
        // Site name must be specified when installing the root of the forest
        return ( ERROR_INVALID_PARAMETER );
    }

    if ( FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT )
      && !ParentDnsDomainName  ) {

        //
        // When installing a new tree in an existing forest, 
        // the root domain DNS name must be present.
        //
        return ( ERROR_INVALID_PARAMETER );
    }

    if ( FLAG_ON( Options, DSROLE_DC_NO_NET )
      && ParentDnsDomainName ) {

        //
        // No net option when installing a child domain
        // does not make sense
        //
        return ( ERROR_INVALID_PARAMETER );
    }

    //
    // Check the access of the caller
    //
    Win32Err = DsRolepCheckPromoteAccess();
    if ( ERROR_SUCCESS != Win32Err ) {

        return Win32Err;
        
    }

    //
    // Init the logging
    //
    DsRolepInitializeLog();

    //
    // Check that the current OS configuration supports this request
    //
    Win32Err = DsRolepIsValidProductSuite((ParentDnsDomainName == NULL) ? TRUE : FALSE,
                                          FALSE,
                                          DnsDomainName);
    if ( ERROR_SUCCESS != Win32Err ) {
        goto Cleanup;
    }

    //
    // Dump the parameters to the log
    //

    DsRolepLogPrint(( DEB_TRACE,
                      "Promotion request for domain controller of new domain\n" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "DnsDomainName  %ws\n",
                      DnsDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tFlatDomainName  %ws\n",
                      FlatDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSiteName  %ws\n",
                      DsRolepDisplayOptional( SiteName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSystemVolumeRootPath  %ws\n",
                      SystemVolumeRootPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tDsDatabasePath  %ws, DsLogPath  %ws\n",
                      DsDatabasePath, DsLogPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tParentDnsDomainName  %ws\n",
                      DsRolepDisplayOptional( ParentDnsDomainName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tParentServer  %ws\n",
                      DsRolepDisplayOptional( ParentServer ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tAccount %ws\n",
                      DsRolepDisplayOptional( Account ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    //
    // Make sure that we are not a member of a domain
    //

    Win32Err = DsRolerGetPrimaryDomainInformation(NULL,
                                                  DsRolePrimaryDomainInfoBasic,
                                                  (PDSROLER_PRIMARY_DOMAIN_INFORMATION*)&ServerInfo);
    if (ERROR_SUCCESS == Win32Err) {
        ASSERT(ServerInfo);
        if(ServerInfo->MachineRole != DsRole_RoleStandaloneServer) {
            Win32Err = ERROR_CURRENT_DOMAIN_NOT_ALLOWED;
            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "Verifying domain membership failed: %lu\n",
                                                   Win32Err )) );
            goto Cleanup;    
        }
    } else if (ERROR_SUCCESS == Win32Err){
        DsRoleFreeMemory(ServerInfo);
        ServerInfo = NULL;    
    } else {
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "DsRoleGetPrimaryDomainInformation failed: %lu\n",
                                               Win32Err )) );
        goto Cleanup;    
    }

    

    //
    // Verify the path names we are given
    //
    DsRolepLogPrint(( DEB_TRACE,"Validate supplied paths\n" ));
    Win32Err = DsRolepCheckFilePaths( DsDatabasePath,
                                      DsLogPath,
                                      SystemVolumeRootPath );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // If we are doing a parent/child setup, verify our name
    //
    if (  ParentDnsDomainName &&
         !FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

        DsRolepLogPrint(( DEB_TRACE, "Child domain creation -- check the new domain name is child of parent domain name.\n" ));

        Win32Err = DsRolepIsDnsNameChild( ParentDnsDomainName, DnsDomainName );
        if ( ERROR_SUCCESS != Win32Err ) {
            
            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "Verifying the child domain dns name failed: %lu\n",
                                                   Win32Err )) );
            goto Cleanup;
        }

    }

    //
    // Validate the netbios domain name is not in use
    //
    DsRolepLogPrint(( DEB_TRACE,"Domain Creation -- check that the flat name is unique.\n" ));

    Win32Err = NetpValidateName( NULL,
                                 FlatDomainName,
                                 NULL,
                                 NULL,
                                 NetSetupNonExistentDomain );

    if ( FLAG_ON( Options, DSROLE_DC_NO_NET )
     && (Win32Err == ERROR_NETWORK_UNREACHABLE)) {

        //
        // See NT bug 386193.  This option allows a first DC in forest
        // to installed with no network (useful for evaluation)
        //
        DsRolepLogPrint(( DEB_TRACE,"Ignoring network unreachable status\n" ));

        Win32Err = ERROR_SUCCESS;
    }
    
    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Flat name validation of %ws failed with %lu\n",
                                               FlatDomainName,
                                               Win32Err )) );

        goto Cleanup;
    }

    // No workstations or domain controllers allowed

    Win32Err = DsRolepGetMachineType( &MachineRole );
    if ( Win32Err == ERROR_SUCCESS ) {

        switch ( MachineRole ) {
        case DSROLEP_MT_CLIENT:
        case DSROLEP_MT_MEMBER:

            Win32Err = ERROR_INVALID_SERVER_STATE;
            break;

        }
    }
    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_TRACE,"This operation is not valid on a workstation or domain controller\n" ));
        goto Cleanup;
    }

    //
    // At this point, we are good to go
    //
    DsRolepLogPrint(( DEB_TRACE,"Start the worker task\n" ));

    //
    // Do our necessary initializations
    //
    Win32Err = DsRolepInitializeOperationHandle( );
    if ( Win32Err != ERROR_SUCCESS ) {

        goto Cleanup;
    }
    fHandleInit = TRUE;

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                &Seed );

    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }

    //
    // If everything is fine, go ahead and do the setup
    //
    Win32Err = DsRolepBuildPromoteArgumentBlock( DnsDomainName,
                                                 FlatDomainName,
                                                 SiteName,
                                                 DsDatabasePath,
                                                 DsLogPath,
                                                 NULL,
                                                 SystemVolumeRootPath,
                                                 NULL,
                                                 ParentDnsDomainName,
                                                 ParentServer,
                                                 Account,
                                                 &Passwords[DSROLEP_DC_AS_DC_PWD_INDEX],
                                                 &Passwords[DSROLEP_DC_AS_DC_DA_PWD_INDEX],
                                                 &Passwords[DSROLEP_DC_AS_DC_DS_REPAIR_PWD_INDEX],
                                                 Options,
                                                 Seed,
                                                 &PromoteArgs );

    DsRolepFreePasswords( Passwords,
                          NELEMENTS(Passwords) );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_DC,
                                            ( PVOID )PromoteArgs );

        //
        // Once the thread has started, no more errors can occur in this
        // function
        //
        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepFreeArgumentBlock( &PromoteArgs, TRUE );
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

    //
    // That's it
    //

Cleanup:

    // Always reset to a known state
    if ( ERROR_SUCCESS != Win32Err && fHandleInit )
    {
        DsRolepResetOperationHandle( DSROLEP_IDLE );
    }

    if ( ServerInfo ) {
        DsRoleFreeMemory(ServerInfo);
        ServerInfo = NULL;
    }

    DsRolepLogPrint(( DEB_TRACE,"Request for promotion returning %lu\n", Win32Err ));

    return( Win32Err );
}




DWORD
DsRolerDcAsReplica(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR ReplicaPartner,
    IN  LPWSTR SiteName OPTIONAL,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR RestorePath OPTIONAL,
    IN  LPWSTR SystemVolumeRootPath,
    IN  PUNICODE_STRING Bootkey,
    IN  LPWSTR Account,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDsRepairPassword,
    IN  ULONG Options,
    OUT PDSROLER_HANDLE DsOperationHandle)
/*++

Routine Description:

    Rpc server routine for installing a server a replica in an existing domain

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords

    DnsDomainName - Dns domain name of the domain to install into

    ReplicaPartner -  The name of a Dc within the existing domain, against which to replicate

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go

    SystemVolumeRootPath - Absolute path on the local machine which will be the root of
        the system volume.
        
    BootKey - needed for media installs where the password is not in the registry or on a disk
    
    cbBootKey - size of the bootkey

    Account - User account to use when setting up as a child domain

    EPassword - Encrypted password to use with the above account
    
    EDsRepairPassword - Encrypted password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_INVALID_STATE - This machine is not a server

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    DSROLEP_MACHINE_TYPE MachineRole;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs;
    ULONG VerifyOptions, VerifyResults;
    UCHAR Seed;

#define DSROLEP_DC_AS_REPLICA_PWD_INDEX           0
#define DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX 1
#define DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT       2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_DC_AS_REPLICA_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_DC_AS_REPLICA_PWD_INDEX]           = EPassword;
    EncryptedPasswords[DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX] = EDsRepairPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );

    //
    // Do some parameter checking
    //
    if ( !DnsDomainName 
      || !DsDatabasePath 
      || !DsLogPath 
      || !SystemVolumeRootPath ) {

         return( ERROR_INVALID_PARAMETER );

    }

    Win32Err = DsRolepCheckPromoteAccess();
    if ( ERROR_SUCCESS != Win32Err ) {

        return Win32Err;
        
    }

    //
    // Init the logging
    //
    DsRolepInitializeLog();


    //
    // Check that the current OS configuration supports this request
    //
    Win32Err = DsRolepIsValidProductSuite(FALSE,
                                          TRUE,
                                          DnsDomainName);
    if ( ERROR_SUCCESS != Win32Err ) {
        goto Cleanup;
    }


    DsRolepLogPrint(( DEB_TRACE,
                      "Promotion request for replica domain controller\n" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "DnsDomainName  %ws\n",
                      DnsDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tReplicaPartner  %ws\n",
                      DsRolepDisplayOptional( ReplicaPartner ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSiteName  %ws\n",
                      DsRolepDisplayOptional( SiteName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tDsDatabasePath  %ws, DsLogPath  %ws\n",
                      DsDatabasePath, DsLogPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSystemVolumeRootPath  %ws\n",
                      SystemVolumeRootPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tAccount %ws\n",
                      DsRolepDisplayOptional(Account) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    //
    // Verify the path names we are given
    //

    DsRolepLogPrint(( DEB_TRACE,"Validate supplied paths\n" ));
    Win32Err = DsRolepCheckFilePaths( DsDatabasePath,
                                      DsLogPath,
                                      SystemVolumeRootPath );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto Cleanup;
        
    }


    //
    // Do our necessary initializations
    //
    Win32Err = DsRolepInitializeOperationHandle( );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepGetMachineType( &MachineRole );

        if ( Win32Err == ERROR_SUCCESS ) {

            switch ( MachineRole ) {
            case DSROLEP_MT_CLIENT:
            case DSROLEP_MT_MEMBER:

                DsRolepLogPrint(( DEB_TRACE,"This operation is not valid on a workstation or domain controller\n" ));
                Win32Err = ERROR_INVALID_SERVER_STATE;
                break;


            }
        }
    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                &Seed );

    if (Win32Err == ERROR_SUCCESS) {
        Win32Err = DsRolepDecryptHash(Bootkey);
    }

    //
    // If everything is fine, go ahead and do the setup
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_TRACE,"Start the worker task\n" ));

        Win32Err = DsRolepBuildPromoteArgumentBlock( DnsDomainName,
                                                     NULL,
                                                     SiteName,
                                                     DsDatabasePath,
                                                     DsLogPath,
                                                     RestorePath,
                                                     SystemVolumeRootPath,
                                                     Bootkey,
                                                     NULL,
                                                     ReplicaPartner,
                                                     Account,
                                                     &Passwords[DSROLEP_DC_AS_REPLICA_PWD_INDEX],
                                                     NULL,
                                                     &Passwords[DSROLEP_DC_AS_REPLICA_DS_REPAIR_PWD_INDEX],
                                                     Options,
                                                     Seed,
                                                     &PromoteArgs );
    
        DsRolepFreePasswords( Passwords,
                              NELEMENTS(Passwords) );
    
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_REPLICA,
                                                ( PVOID )PromoteArgs );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepFreeArgumentBlock( &PromoteArgs, TRUE );
            }
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepResetOperationHandle( DSROLEP_IDLE );
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

Cleanup:

    DsRolepLogPrint(( DEB_TRACE,"Request for promotion returning %lu\n", Win32Err ));

    return( Win32Err );
}



DWORD
DsRolerDemoteDc(
    IN handle_t RpcBindingHandle,
    IN LPWSTR DnsDomainName,
    IN DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN LPWSTR Account,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword,
    IN ULONG Options,
    IN BOOL LastDcInDomain,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EDomainAdminPassword,
    OUT PDSROLER_HANDLE DsOperationHandle
    )
/*++

Routine Description:

    Rpc server routine for demoting a dc to a server

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords                          

    DnsDomainName - Dns domain name of the domain to be demoted.  Null means all of the supported
        domain names

    ServerRole - The new role this machine should take

    Account - OPTIONAL User account to use when deleting the trusted domain object

    EPassword - Encrypted password to use with the above account

    Options - Options to control the demotion of the domain

    LastDcInDomain - If TRUE, the Dc being demoted is the last Dc in the domain.

    EDomainAdminPassword - Encrypted password to set on the administrator account if it is a new install

    DsOperationHandle - Handle to the operation is returned here.


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_INVALID_STATE - This machine is not a server

--*/
{
    DSROLEP_MACHINE_TYPE MachineRole;
    DWORD Win32Err;
    PDSROLEP_OPERATION_DEMOTE_ARGS DemoteArgs;
    UCHAR Seed;

#define DSROLEP_DEMOTE_PWD_INDEX        0
#define DSROLEP_DEMOTE_ADMIN_PWD_INDEX  1
#define DSROLEP_DEMOTE_MAX_PWD_COUNT    2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_DEMOTE_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_DEMOTE_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_DEMOTE_PWD_INDEX] =       EPassword;
    EncryptedPasswords[DSROLEP_DEMOTE_ADMIN_PWD_INDEX] = EDomainAdminPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );

    if (   (LastDcInDomain && (DsRoleServerMember == ServerRole))
        || (!LastDcInDomain && (DsRoleServerStandalone == ServerRole)) ) {

        //
        // These configurations are not supported
        //
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check the access right for demote
    //
    Win32Err = DsRolepCheckDemoteAccess();
    if ( ERROR_SUCCESS != Win32Err ) {

        return Win32Err;
        
    }

    //
    // Initialize return value to NULL
    //

    *DsOperationHandle = NULL;

    DsRolepInitializeLog();

    DsRolepLogPrint(( DEB_TRACE,
                      "Request for demotion of domain controller\n" ));

    DsRolepLogPrint(( DEB_TRACE,
                      "DnsDomainName  %ws\n",
                      DsRolepDisplayOptional( DnsDomainName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tServerRole  %lu\n",
                      ServerRole ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tAccount %ws ",
                      DsRolepDisplayOptional( Account ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tLastDcInDomain  %S\n",
                      LastDcInDomain ? "TRUE" : "FALSE" ));


    //
    // Do our necessary initializations
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepInitializeOperationHandle( );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepGetMachineType( &MachineRole );

            if ( Win32Err == ERROR_SUCCESS ) {

                switch ( MachineRole ) {
                case DSROLEP_MT_CLIENT:
                case DSROLEP_MT_STANDALONE:

                    DsRolepLogPrint(( DEB_TRACE,"This operation is only valid on a domain controller\n" ));
                    Win32Err = ERROR_INVALID_SERVER_STATE;
                    break;


                }
            }
        }
    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                &Seed );


    //
    // Spawn the demotion thread
    //
    if ( Win32Err == ERROR_SUCCESS ) {


        DsRolepLogPrint(( DEB_TRACE,"Start the worker task\n" ));

        Win32Err = DsRolepBuildDemoteArgumentBlock( ServerRole,
                                                    DnsDomainName,
                                                    Account,
                                                    &Passwords[DSROLEP_DEMOTE_PWD_INDEX],
                                                    Options,
                                                    ( BOOLEAN )LastDcInDomain,
                                                    &Passwords[DSROLEP_DEMOTE_ADMIN_PWD_INDEX],
                                                    Seed,
                                                    &DemoteArgs );

        DsRolepFreePasswords( Passwords,
                              NELEMENTS(Passwords) );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_DEMOTE,
                                                ( PVOID )DemoteArgs );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepFreeArgumentBlock( &DemoteArgs, FALSE );
            }
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepResetOperationHandle( DSROLEP_IDLE );
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

    DsRolepLogPrint(( DEB_TRACE,"Request for demotion returning %lu\n", Win32Err ));

    return( Win32Err );
}



DWORD
DsRolerGetDcOperationProgress(
    IN PDSROLE_SERVER_NAME Server,
    IN PDSROLER_HANDLE DsOperationHandle,
    IN OUT PDSROLER_SERVEROP_STATUS *ServerOperationStatus
    )
/*++

Routine Description:

    Rpc server routine for determining the present state of the operation

Arguments:

    Server - Server the call was remoted to

    DsOperationHandle - Handle returned from a previous call

    ServerOperationStatus - Where the status information is returned

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_HANDLE - A bad Operation handle was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

     __try {

        if ( DsOperationHandle == NULL ||
             *DsOperationHandle != ( DSROLER_HANDLE )&DsRolepCurrentOperationHandle) {

           Win32Err = ERROR_INVALID_HANDLE;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err =  GetExceptionCode();
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepGetDcOperationProgress( ( PDSROLE_SERVEROP_HANDLE )DsOperationHandle,
                                                  ServerOperationStatus );
    }

    return( Win32Err );
}



DWORD
DsRolerGetDcOperationResults(
    IN PDSROLE_SERVER_NAME Server,
    IN PDSROLER_HANDLE DsOperationHandle,
    OUT PDSROLER_SERVEROP_RESULTS *ServerOperationResults
    )
/*++

Routine Description:

    Rpc server routine for determining the final results of the operation.  If the operation
    is not yet completed, this function will block until it does complete.

Arguments:

    Server - Server the call was remoted to

    DsOperationHandle - Handle returned from a previous call

    ServerOperationResults - Where the final operation results are returned.

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_HANDLE - A bad Operation handle was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

     __try {

        if ( DsOperationHandle == NULL ||
             *DsOperationHandle != ( DSROLER_HANDLE )&DsRolepCurrentOperationHandle) {

           Win32Err = ERROR_INVALID_HANDLE;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err =  GetExceptionCode();
    }

    if ( Win32Err == ERROR_SUCCESS ) {


        Win32Err = DsRolepGetDcOperationResults( ( PDSROLE_SERVEROP_HANDLE )DsOperationHandle,
                                                 ServerOperationResults );

        DsRolepCloseLog();
    }


    return( Win32Err );
}






DWORD
WINAPI
DsRolerDnsNameToFlatName(
    IN  LPWSTR Server OPTIONAL,
    IN  LPWSTR DnsName,
    OUT LPWSTR *FlatName,
    OUT PULONG StatusFlag
    )
/*++

Routine Description:

    Rpc server routine for determining the default flat (netbios) domain name for the given
    Dns domain name

Arguments:

    Server - Server the call was remoted to

    DnsName - Dns name to convert

    FlatName - Where the flat name is returned.  Alocated via MIDL_user_allocate

    StatusFlag - Where the status flag is returned

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad input or NULL return parameter was given
--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( DnsName == NULL || FlatName == NULL || StatusFlag == NULL ) {

        return( ERROR_INVALID_PARAMETER );

    }

    Win32Err = DsRolepDnsNameToFlatName( DnsName,
                                         FlatName,
                                         StatusFlag );

    return( Win32Err );
}


#define GET_PDI_COPY_STRING_AND_INSERT( _unicode_, _buffer_ )                       \
if ( ( _unicode_)->Length == 0 ) {                                                  \
                                                                                    \
    ( _buffer_ ) = NULL;                                                            \
                                                                                    \
} else {                                                                            \
                                                                                    \
    ( _buffer_ ) = MIDL_user_allocate( (_unicode_)->Length + sizeof( WCHAR ) );     \
    if ( ( _buffer_ ) == NULL ) {                                                   \
                                                                                    \
        Status = STATUS_INSUFFICIENT_RESOURCES;                                     \
        goto GetInfoError;                                                          \
                                                                                    \
    } else {                                                                        \
                                                                                    \
        BuffersToFree[ BuffersCnt++ ] = ( PBYTE )( _buffer_ );                      \
        RtlCopyMemory( ( _buffer_ ),                                                \
                       ( _unicode_ )->Buffer,                                       \
                       ( _unicode_ )->Length );                                     \
        ( _buffer_ )[ ( _unicode_ )->Length / sizeof( WCHAR ) ] = UNICODE_NULL;     \
    }                                                                               \
}

DWORD
WINAPI
DsRolerGetDatabaseFacts(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State
    )
/*++

Routine Description:

    This function will give information about a restore database
    1. the way the syskey is stored
    2. the domain that the database came from
    3. where the backup was taken from a GC or not

Arguments:

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err=ERROR_SUCCESS;

    Win32Err = DsRolepCheckPromoteAccess();
    if ( ERROR_SUCCESS != Win32Err ) {
        return Win32Err;
    }

    return DsRolepGetDatabaseFacts(lpRestorePath,
                                   lpDNSDomainName,
                                   State);
}



DWORD
DsRolerGetPrimaryDomainInformation(
    IN PDSROLE_SERVER_NAME Server,
    IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PDSROLER_PRIMARY_DOMAIN_INFORMATION *DomainInfo
    )
/*++

Routine Description:

    Determine the principal name to use for authenticated Rpc

Arguments:

    Server - Server the call was remoted to

    ServerPrincipal - Where the server principal name is returned


Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A NULL return parameter was given

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    PBYTE BuffersToFree[ 6 ];
    ULONG BuffersCnt = 0, i;
    PDSROLER_PRIMARY_DOMAIN_INFO_BASIC BasicInfo;
    PDSROLE_UPGRADE_STATUS_INFO Upgrade;
    PDSROLE_OPERATION_STATE_INFO OperationStateInfo = 0;
    BOOLEAN IsUpgrade;
    ULONG PreviousServerRole;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRole;
    PPOLICY_DNS_DOMAIN_INFO CurrentDnsInfo = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;
    LSAPR_HANDLE PolicyHandle = NULL;
    LSAPR_OBJECT_ATTRIBUTES PolicyObject;
    GUID                    NullGuid;

    memset( &NullGuid, 0, sizeof(GUID) );
    #define IS_GUID_PRESENT(x)  (memcmp(&(x), &NullGuid, sizeof(GUID)))

    if ( DomainInfo == NULL ) {

        return( ERROR_INVALID_PARAMETER );
    }

    //
    // This particular interface cannot be called until the Lsa and Sam are fully initialized.
    // As such, we will have to wait until they are..
    //
    if ( !DsRolepSamInitialized ) {

        Win32Err = DsRolepWaitForSam();
        if ( Win32Err != ERROR_SUCCESS ) {

            return( Win32Err );
        }

        DsRolepSamInitialized = TRUE;
    }

    switch ( InfoLevel ) {
    case DsRolePrimaryDomainInfoBasic:

        BasicInfo = MIDL_user_allocate( sizeof( DSROLER_PRIMARY_DOMAIN_INFO_BASIC ) );

        if ( BasicInfo == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto GetInfoError;

        } else {

            BuffersToFree[ BuffersCnt++ ] = ( PBYTE )BasicInfo;
        }

        //
        // Open a handle to the policy and ensure the callers has access to read it
        //

        RtlZeroMemory(&PolicyObject, sizeof(PolicyObject));

        Status = LsarOpenPolicy(
                        NULL,   // Local LSA
                        &PolicyObject,
                        POLICY_VIEW_LOCAL_INFORMATION,
                        &PolicyHandle );

        if ( !NT_SUCCESS(Status) ) {
            Win32Err = RtlNtStatusToDosError( Status );
            goto GetInfoError;
        }


        //
        // Get the current information
        //
        Status =  LsarQueryInformationPolicy(
                            PolicyHandle,
                            PolicyDnsDomainInformationInt,
                            (PLSAPR_POLICY_INFORMATION *) &CurrentDnsInfo );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Get the machine role
            //
            switch ( LsapProductType ) {
            case NtProductWinNt:
                if ( CurrentDnsInfo->Sid == NULL ) {

                    BasicInfo->MachineRole = DsRole_RoleStandaloneWorkstation;

                } else {

                    BasicInfo->MachineRole = DsRole_RoleMemberWorkstation;

                }
                break;

            case NtProductServer:
                if ( CurrentDnsInfo->Sid == NULL ) {

                    BasicInfo->MachineRole = DsRole_RoleStandaloneServer;

                } else {

                    BasicInfo->MachineRole = DsRole_RoleMemberServer;

                }
                break;

            case NtProductLanManNt:

                Status = LsarQueryInformationPolicy(
                                PolicyHandle,
                                PolicyLsaServerRoleInformation,
                                (PLSAPR_POLICY_INFORMATION *) &ServerRole );

                if (NT_SUCCESS( Status ) ) {

                    if ( ServerRole->LsaServerRole == PolicyServerRolePrimary ) {

                        //
                        // If we think we're a primary domain controller, we'll need to
                        // guard against the case where we're actually standalone during setup
                        //
                        Status = LsarQueryInformationPolicy(
                                    PolicyHandle,
                                    PolicyAccountDomainInformation,
                                    (PLSAPR_POLICY_INFORMATION *) &AccountDomainInfo );

                        if ( NT_SUCCESS( Status ) ) {


                            if ( CurrentDnsInfo->Sid == NULL ||
                                 AccountDomainInfo->DomainSid == NULL ||
                                 !RtlEqualSid( AccountDomainInfo->DomainSid,
                                               CurrentDnsInfo->Sid ) ) {

                                BasicInfo->MachineRole = DsRole_RoleStandaloneServer;

                            } else {

                                BasicInfo->MachineRole = DsRole_RolePrimaryDomainController;

                            }
                            LsaIFree_LSAPR_POLICY_INFORMATION(
                                    PolicyAccountDomainInformation,
                                    ( PLSAPR_POLICY_INFORMATION )AccountDomainInfo );
                        }


                    } else {

                        BasicInfo->MachineRole = DsRole_RoleBackupDomainController;
                    }

                    LsaIFree_LSAPR_POLICY_INFORMATION( PolicyLsaServerRoleInformation,
                                                       ( PLSAPR_POLICY_INFORMATION )ServerRole );
                }

                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

        }

        //
        // Now, build the rest of the information
        //
        if ( NT_SUCCESS( Status ) ) {


            if ( LsapDsIsRunning ) {

                BasicInfo->Flags = DSROLE_PRIMARY_DS_RUNNING;

                Status = DsRolepGetMixedModeFlags( CurrentDnsInfo->Sid, &( BasicInfo->Flags ) );

            } else {

                BasicInfo->Flags = 0;

            }

            if ( NT_SUCCESS( Status ) ) {

                //
                // Flat name
                //
                GET_PDI_COPY_STRING_AND_INSERT( &CurrentDnsInfo->Name, BasicInfo->DomainNameFlat );
    
                //
                // Dns domain name
                //
                GET_PDI_COPY_STRING_AND_INSERT( &CurrentDnsInfo->DnsDomainName, BasicInfo->DomainNameDns );
    
                //
                // Dns tree name
                //
                GET_PDI_COPY_STRING_AND_INSERT( &CurrentDnsInfo->DnsForestName, BasicInfo->DomainForestName );
    
                //
                // Finally, the Guid.
                //
                if ( IS_GUID_PRESENT(CurrentDnsInfo->DomainGuid) ) {
    
                    RtlCopyMemory( &BasicInfo->DomainGuid,
                                   &CurrentDnsInfo->DomainGuid,
                                   sizeof( GUID ) );
    
                    BasicInfo->Flags |= DSROLE_PRIMARY_DOMAIN_GUID_PRESENT;
                }

            }
        }

        if ( NT_SUCCESS( Status ) ) {

            *DomainInfo = ( PDSROLER_PRIMARY_DOMAIN_INFORMATION )BasicInfo;
            BuffersCnt = 0;

        } else {

            Win32Err = RtlNtStatusToDosError( Status );
        }


        break;

    case DsRoleUpgradeStatus:

        Win32Err = DsRolepQueryUpgradeInfo( &IsUpgrade,
                                            &PreviousServerRole );

        if ( Win32Err == ERROR_SUCCESS ) {

            Upgrade = MIDL_user_allocate( sizeof( DSROLE_UPGRADE_STATUS_INFO ) );

            if ( Upgrade == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;
                goto GetInfoError;

            } else {

                BuffersToFree[ BuffersCnt++ ] = ( PBYTE )Upgrade;

                //
                // Now, build the information
                //
                if ( IsUpgrade ) {

                    Upgrade->OperationState = DSROLE_UPGRADE_IN_PROGRESS;

                    switch ( PreviousServerRole ) {
                    case PolicyServerRoleBackup:
                        Upgrade->PreviousServerState = DsRoleServerBackup;
                        break;

                    case PolicyServerRolePrimary:
                        Upgrade->PreviousServerState = DsRoleServerPrimary;
                        break;

                    default:

                        Win32Err = ERROR_INVALID_SERVER_STATE;
                        break;

                    }

                } else {

                    RtlZeroMemory( Upgrade, sizeof( DSROLE_UPGRADE_STATUS_INFO ) );
                }

                //
                // Make sure to return the values if we should
                //
                if ( Win32Err == ERROR_SUCCESS ) {

                    *DomainInfo = ( PDSROLER_PRIMARY_DOMAIN_INFORMATION )Upgrade;
                    BuffersCnt = 0;

                }

            }
        }
        break;

    case DsRoleOperationState:

        OperationStateInfo = MIDL_user_allocate( sizeof( DSROLE_OPERATION_STATE_INFO ) );

        if ( OperationStateInfo == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto GetInfoError;

        }

        if ( RtlAcquireResourceExclusive( &DsRolepCurrentOperationHandle.CurrentOpLock, TRUE ) ) {

            DsRoleDebugOut(( DEB_TRACE_LOCK,
                             "Lock grabbed in DsRolerGetPrimaryDomainInformation\n"));

            if ( DSROLEP_OPERATION_ACTIVE( DsRolepCurrentOperationHandle.OperationState ) ) {

                OperationStateInfo->OperationState = DsRoleOperationActive;

            } else if ( DSROLEP_IDLE == DsRolepCurrentOperationHandle.OperationState ) {

                OperationStateInfo->OperationState = DsRoleOperationIdle;

            } else {

                ASSERT( DSROLEP_NEED_REBOOT == DsRolepCurrentOperationHandle.OperationState );

                //
                // If the assert isn't true, then we are very confused and should probably
                // indicate we need a reboot.
                //
                OperationStateInfo->OperationState = DsRoleOperationNeedReboot;
            }

            RtlReleaseResource( &DsRolepCurrentOperationHandle.CurrentOpLock );
            DsRoleDebugOut(( DEB_TRACE_LOCK, "Lock released\n" ));

            //
            // Set the out param
            //
            *DomainInfo = ( PDSROLER_PRIMARY_DOMAIN_INFORMATION )OperationStateInfo;

        } else {

            Win32Err = ERROR_BUSY;
        }

        break;



    default:
        Win32Err = ERROR_INVALID_PARAMETER;
        break;
    }

GetInfoError:

    if ( CurrentDnsInfo != NULL ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION )CurrentDnsInfo );

    }


    //
    // Free any buffers that we may have allocated
    //
    for ( i = 0; i < BuffersCnt; i++ ) {

        MIDL_user_free( BuffersToFree[ i ] );
    }

    if ( PolicyHandle != NULL ) {
        LsarClose( &PolicyHandle );
    }

    return( Win32Err );
}





DWORD
DsRolerCancel(
    IN PDSROLE_SERVER_NAME Server,
    IN PDSROLER_HANDLE DsOperationHandle
    )
/*++

Routine Description:

    Cancels a currently running operation

Arguments:

    Server - Server to remote the call to

    DsOperationHandle - Handle of currently running operation.  Returned by one of the DsRoleDcAs
        apis


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

     __try {

        if ( DsOperationHandle == NULL ||
             *DsOperationHandle != ( DSROLER_HANDLE )&DsRolepCurrentOperationHandle) {

           Win32Err = ERROR_INVALID_HANDLE;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        Win32Err =  GetExceptionCode();
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepCancel( TRUE );  // Block until done

    }

    return( Win32Err );
}




DWORD
DsRolerServerSaveStateForUpgrade(
    IN PDSROLE_SERVER_NAME Server,
    IN LPWSTR AnswerFile OPTIONAL
    )
/*++

Routine Description:

    This function is to be invoked during setup and saves the required server state to
    complete the promotion following the reboot.  Following the successful completion
    of this API call, the server will be demoted to a member server in the same domain.

Arguments:

    AnswerFile -- Optional path to an answer file to be used by DCPROMO during the subsequent
        invocation


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // Check the access of the caller
    //
    // N.B another access check would be to check that this is GUI mode
    // setup, but checking for admin is safer.  It works because setup.exe
    // runs under local system which has builtin\administrators in its
    // token.
    //
    Win32Err = DsRolepCheckPromoteAccess();
    if ( ERROR_SUCCESS != Win32Err ) {

        return Win32Err;

    }

    (VOID) DsRolepInitializeLog();

    Win32Err = DsRolepSaveUpgradeState( AnswerFile );

    return( Win32Err );
}



DWORD
DsRolerUpgradeDownlevelServer(
    IN  handle_t RpcBindingHandle,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR SiteName,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR SystemVolumeRootPath,
    IN  LPWSTR ParentDnsDomainName OPTIONAL,
    IN  LPWSTR ParentServer OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EPassword,
    IN  PDSROLEPR_ENCRYPTED_USER_PASSWORD EDsRepairPassword,
    IN  ULONG Options,
    OUT PDSROLER_HANDLE *DsOperationHandle
    )
/*++

Routine Description:

    This routine process the information saved from a DsRoleServerSaveStateForUpgrade to
    promote a downlevel (NT4 or previous) server to an NT5 DC

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords
    
    DnsDomainName - Dns domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go

    SystemVolumeRootPath - Absolute path on the local machine which will be the root of
      the system volume.

    ParentDnsDomainName - Optional.  If present, set this domain up as a child of the
      specified domain

    ParentServer - Optional.  If present, use this server in the parent domain to replicate
      the required information from

    Account - User account to use when contacting other servers

    EPassword - Encrypted password to use with the above account
    
    EDsRepairPassword - Encrypted password to use for the admin account of the repair mode

    Options - Options to control the creation of the domain

    DsOperationHandle - Handle to the operation is returned here.


Return Values:

    ERROR_SUCCESS - Success
    ERROR_INVALID_SERVER_STATE - Not in upgrade mode

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    BOOLEAN IsUpgrade;
    ULONG PreviousServerState, VerifyOptions, VerifyResults;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs;
    NTSTATUS Status;
    HANDLE LocalPolicy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_DNS_DOMAIN_INFO PrimaryDomainInfo = NULL;
    UCHAR Seed = 0;

#define DSROLEP_UPGRADE_PWD_INDEX            0
#define DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX  1
#define DSROLEP_UPGRADE_MAX_PWD_COUNT        2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_UPGRADE_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_UPGRADE_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_UPGRADE_PWD_INDEX] = EPassword;
    EncryptedPasswords[DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX] = EDsRepairPassword;

    RtlZeroMemory( Passwords, sizeof(Passwords) );
    
    *DsOperationHandle = NULL;

    //
    // Do some parameter checking
    //
    if ( !DnsDomainName || !DsDatabasePath || !DsLogPath || !SystemVolumeRootPath ) {

        Win32Err = ERROR_INVALID_PARAMETER;
        goto DsRolepUpgradeError;

    }

    DsRolepInitializeLog();

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolerDcAsDc: DnsDomainName  %ws\n",
                      DnsDomainName ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSiteName  %ws\n",
                      DsRolepDisplayOptional( SiteName ) ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tSystemVolumeRootPath  %ws\n",
                      SystemVolumeRootPath ));

    DsRolepLogPrint(( DEB_TRACE,
                      "\tDsDatabasePath  %ws, DsLogPath  %ws\n",
                      DsDatabasePath, DsLogPath ));

    if ( ParentDnsDomainName ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "\tParentDnsDomainName  %ws\n",
                          ParentDnsDomainName ));

    }

    if ( ParentServer ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "\tParentServer  %ws\n",
                          ParentServer ));

    }

    if ( Account ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "\tAccount %ws\n",
                          Account ));
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "\tOptions  %lu\n",
                      Options ));

    Win32Err = DsRolepQueryUpgradeInfo( &IsUpgrade, &PreviousServerState );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto DsRolepUpgradeError;
    }

    if ( !IsUpgrade || PreviousServerState == PolicyServerRoleBackup ) {

        Win32Err = ERROR_INVALID_SERVER_STATE;
        goto DsRolepUpgradeError;

    }

    //
    // Verify the path names we are given
    //
    DsRolepLogPrint(( DEB_TRACE,"Validate supplied paths\n" ));
    Win32Err = DsRolepCheckFilePaths( DsDatabasePath,
                                      DsLogPath,
                                      SystemVolumeRootPath );
    if ( ERROR_SUCCESS != Win32Err ) {

        goto DsRolepUpgradeError;
        
    }

    //
    // If we are doing a parent/child setup, verify our name
    //
    if ( Win32Err == ERROR_SUCCESS && ParentDnsDomainName &&
         !FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

        Win32Err = DsRolepIsDnsNameChild( ParentDnsDomainName, DnsDomainName );
    }

    //
    // Get the current domain name
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &LocalPolicy );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( LocalPolicy,
                                                PolicyPrimaryDomainInformation,
                                                &PrimaryDomainInfo );

            LsaClose( LocalPolicy );
        }

        Win32Err = RtlNtStatusToDosError( Status );

    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                &Seed );

    //
    // Finally, we'll do the promotion
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepInitializeOperationHandle( );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepBuildPromoteArgumentBlock( DnsDomainName,
                                                         PrimaryDomainInfo->Name.Buffer,
                                                         SiteName,
                                                         DsDatabasePath,
                                                         DsLogPath,
                                                         NULL,
                                                         SystemVolumeRootPath,
                                                         NULL,
                                                         ParentDnsDomainName,
                                                         ParentServer,
                                                         Account,
                                                         &Passwords[DSROLEP_UPGRADE_PWD_INDEX],
                                                         NULL,
                                                         &Passwords[DSROLEP_UPGRADE_DS_REPAIR_PWD_INDEX],
                                                         Options | DSROLE_DC_DOWNLEVEL_UPGRADE,
                                                         Seed,
                                                         &PromoteArgs );

        }

        DsRolepFreePasswords( Passwords,
                              NELEMENTS(Passwords) );


        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepSpinWorkerThread( DSROLEP_OPERATION_DC,
                                                ( PVOID )PromoteArgs );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepFreeArgumentBlock( &PromoteArgs, TRUE );
            }
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepResetOperationHandle( DSROLEP_IDLE );
        }

    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *DsOperationHandle = (DSROLER_HANDLE)&DsRolepCurrentOperationHandle;

    }

    LsaFreeMemory( PrimaryDomainInfo );


DsRolepUpgradeError:

    return( Win32Err );
}



DWORD
DsRolerAbortDownlevelServerUpgrade(
    IN handle_t RpcBindingHandle,
    IN LPWSTR Account, OPTIONAL
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EAccountPassword,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD EAdminPassword,
    IN ULONG Options
    )
/*++

Routine Description:

    This routine cleans up the information saved from a DsRoleSaveServerStateForUpgrade call,
    leaving the machine as a member or standalone server

Arguments:

    RpcBindingHandle - the RPC context, used to decrypt the passwords                                   

    Account - User account to use when contacting other servers

    EPassword - Encrypted password to use with the above account

    EAdminPassword - Encrypted new local administrator account password
    
    Options - Options to control the behavior.  Currently support flags are:
        DSROLEP_ABORT_FOR_REPLICA_INSTALL   - The upgrade is being aborted to do a replica install

Return Values:

    ERROR_SUCCESS - Success
    ERROR_INVALID_PARAMETER - An invalid machine role was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    BOOLEAN AccountInfoSet = FALSE, Impersonated = FALSE;
    UCHAR Seed = 0;
    UNICODE_STRING EPassword, EPassword2;
    WCHAR *OldAccountDn = NULL;
    WCHAR SecurityLogPath[MAX_PATH+1];
    PUNICODE_STRING Password = NULL;
    PUNICODE_STRING AdminPassword = NULL;
    HANDLE ClientToken = NULL;

#define DSROLEP_ABORT_PWD_INDEX        0
#define DSROLEP_ABORT_ADMIN_PWD_INDEX  1
#define DSROLEP_ABORT_MAX_PWD_COUNT    2

    PDSROLEPR_ENCRYPTED_USER_PASSWORD EncryptedPasswords[DSROLEP_ABORT_MAX_PWD_COUNT];
    UNICODE_STRING Passwords[DSROLEP_ABORT_MAX_PWD_COUNT];

    EncryptedPasswords[DSROLEP_ABORT_PWD_INDEX] = EAccountPassword;
    EncryptedPasswords[DSROLEP_ABORT_ADMIN_PWD_INDEX] = EAdminPassword;
    RtlZeroMemory( Passwords, sizeof(Passwords) );
    
    EPassword.Buffer = NULL;
    EPassword2.Buffer = NULL;

    Win32Err = DsRolepCheckPromoteAccess();
    if ( ERROR_SUCCESS != Win32Err ) {

        return Win32Err;
        
    }

    Win32Err = DsRolepDecryptPasswordsWithKey ( RpcBindingHandle,
                                                EncryptedPasswords,
                                                NELEMENTS(EncryptedPasswords),
                                                Passwords,
                                                &Seed );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }
    RtlCopyMemory( &EPassword,  &Passwords[DSROLEP_ABORT_ADMIN_PWD_INDEX], sizeof(UNICODE_STRING));
    RtlCopyMemory( &EPassword2, &Passwords[DSROLEP_ABORT_PWD_INDEX], sizeof(UNICODE_STRING));

    //
    // Initialize the operation handle so we pull in the dynamically
    // loaded libraries
    //
    Win32Err = DsRolepInitializeOperationHandle( );

    if ( Win32Err != ERROR_SUCCESS ) {

        return( Win32Err );
    }

    DsRolepInitializeLog();

    if ( FLAG_ON( Options, DSROLEP_ABORT_FOR_REPLICA_INSTALL ) )
    {
        //
        // This is the NT4 to NT5 BDC upgrade.  Nothing to do
        // 
        //
        DsRolepLogPrint(( DEB_TRACE, "Performing NT4 to NT5 BDC upgrade.\n"));
        Win32Err = ERROR_SUCCESS;
        goto Exit;

    }

    Win32Err = DsRolepGetImpersonationToken( &ClientToken );
    if (ERROR_SUCCESS != Win32Err) {

        goto Exit;
    }

    //
    // First, find the Dc that has this account
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepDsGetDcForAccount( NULL,
                                             NULL,
                                             NULL,
                                             DS_DIRECTORY_SERVICE_REQUIRED |
                                                    DS_WRITABLE_REQUIRED |
                                                    DS_FORCE_REDISCOVERY |
                                                    DS_AVOID_SELF,
                                             UF_SERVER_TRUST_ACCOUNT,
                                             &DomainControllerInfo );

        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Set the machine account type
            //

            DsRolepLogPrint(( DEB_TRACE, "Searching for the machine account ...\n"));

            RtlRunDecodeUnicodeString( Seed, &EPassword2 );
            Win32Err = DsRolepSetMachineAccountType( DomainControllerInfo->DomainControllerName,
                                                     ClientToken,
                                                     Account,
                                                     EPassword2.Buffer,
                                                     NULL,
                                                     UF_WORKSTATION_TRUST_ACCOUNT,
                                                     &OldAccountDn );
            RtlRunEncodeUnicodeString( &Seed, &EPassword2 );

            if ( Win32Err == ERROR_SUCCESS ) {

                AccountInfoSet = TRUE;

            } else {

                DsRolepLogPrint(( DEB_TRACE, "DsRolepSetMachineAccountType returned %d\n",
                                  Win32Err ));
            }

            if ( OldAccountDn ) {

                // the machine object was moved
                DsRolepLogPrint(( DEB_TRACE, "Moved account %ws to %ws\n",
                                  Account,
                                  OldAccountDn ));
            }
        }

    }

    if ( ERROR_SUCCESS != Win32Err ) {

        goto Exit;
        
    }

    //
    // Set the security for a freshly installed NT5 server. See bug 391574
    //

    DsRolepLogPrint(( DEB_TRACE, "Setting security for server ...\n"));

    #define SECURITY_SRV_INF_FILE L"defltsv.inf"
    
    ZeroMemory( SecurityLogPath, MAX_PATH+1 );
    if ( GetWindowsDirectory( SecurityLogPath, MAX_PATH ) )
    {
    
        wcsncat( SecurityLogPath, L"\\security\\logs\\scesetup.log", ((sizeof(SecurityLogPath)/sizeof(WCHAR))-wcslen(SecurityLogPath)) );

        Win32Err  = DsrSceSetupSystemByInfName(SECURITY_SRV_INF_FILE,
                                               SecurityLogPath,                                                   
                                               AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY,
                                               SCESETUP_CONFIGURE_SECURITY,
                                               NULL,    // used only for GUI mode                                 
                                               NULL );  // used only for GUI mode
    
    } else {

        Win32Err = GetLastError();

    }

    if ( ERROR_SUCCESS != Win32Err ) {

        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Setting security on server files failed with %lu\n",
                                               Win32Err )) );

        // This error has been handled
        Win32Err = ERROR_SUCCESS;
    }

    DsRolepLogPrint(( DEB_TRACE, "Setting security for server finished\n"));



    //
    // Change the user password
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlRunDecodeUnicodeString( Seed, &EPassword );
        Win32Err = DsRolepSetBuiltinAdminAccountPassword( EPassword.Buffer );
        RtlRunEncodeUnicodeString( &Seed, &EPassword );

        //
        // Delete the upgrade information
        //
        if ( Win32Err == ERROR_SUCCESS ) {
    
            Win32Err = DsRolepDeleteUpgradeInfo();
        }
    }


    //
    // If that failed, try and restore the machine account info
    //
    if ( Win32Err != ERROR_SUCCESS && AccountInfoSet ) {

        RtlRunDecodeUnicodeString( Seed, &EPassword2 );
        Win32Err2 = DsRolepSetMachineAccountType( DomainControllerInfo->DomainControllerName,
                                                  ClientToken,
                                                  Account,
                                                  EPassword2.Buffer,
                                                  NULL,
                                                  UF_SERVER_TRUST_ACCOUNT,
                                                  &OldAccountDn );  //don't care about dn
        RtlRunEncodeUnicodeString( &Seed, &EPassword2 );

        if ( Win32Err2 != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE, "DsRolepSetMachineAccountType returned %d\n", Win32Err2 ));

        } else {

            if ( OldAccountDn ) {

                //
                // the machine object was moved back
                //
                DsRolepLogPrint(( DEB_TRACE, "Attempted to move account %ws to %ws\n",
                                 Account,
                                 OldAccountDn ));
            }
        }
    }

Exit:

    DsRolepFreePasswords( Passwords,
                          NELEMENTS(Passwords) );

    NetApiBufferFree( DomainControllerInfo );

    if ( OldAccountDn ) {

        RtlFreeHeap( RtlProcessHeap(), 0, OldAccountDn );
    }

    if (ClientToken) {
        CloseHandle(ClientToken);
    }

    (VOID) DsRolepResetOperationHandle( DSROLEP_IDLE ); 

    return( Win32Err );
}





//
// Local function definitions
//
DWORD
DsRolepWaitForSam(
    VOID
    )
/*++

Routine Description:

    This routine waits for the SAM_SERVICE_STARTED event

Arguments:

    VOID
Return Values:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Response;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    HANDLE EventHandle = NULL;

    //
    // Open the event
    //
    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtCreateEvent( &EventHandle,
                            SYNCHRONIZE,
                            &EventAttributes,
                            NotificationEvent,
                            FALSE );


    //
    // If the event already exists, just open it.
    //
    if( Status == STATUS_OBJECT_NAME_EXISTS || Status == STATUS_OBJECT_NAME_COLLISION ) {

        Status = NtOpenEvent( &EventHandle,
                              SYNCHRONIZE,
                              &EventAttributes );
    }


    if ( NT_SUCCESS( Status ) ) {

        Status = NtWaitForSingleObject( EventHandle, TRUE, NULL );

        NtClose( EventHandle );
    }



    return( RtlNtStatusToDosError( Status ) );
}

DWORD
DsRolepCheckFilePaths(
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN LPWSTR SystemVolumeRootPath
    )
/*++

Routine Description:

Arguments:

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG VerifyOptions, VerifyResults;
    ULONG Length;

    //
    // Make sure that niether the log path nor the datapath path
    // is a subset of the SystemVolumeRootPath
    //
    Length = wcslen( SystemVolumeRootPath );
    if ( !_wcsnicmp( SystemVolumeRootPath, DsDatabasePath, Length )
      || !_wcsnicmp( SystemVolumeRootPath, DsLogPath, Length )   ) {

        DsRolepLogPrint(( DEB_TRACE, "Database paths subset of sysvol\n" ));

        WinError = ERROR_BAD_PATHNAME;
        
    }

    if ( WinError == ERROR_SUCCESS ) {

        VerifyOptions = DSROLEP_PATH_VALIDATE_LOCAL | DSROLEP_PATH_VALIDATE_EXISTENCE;
        WinError = DsRolepValidatePath( DsDatabasePath, VerifyOptions, &VerifyResults );

       if ( WinError == ERROR_SUCCESS ) {

           if ( VerifyResults != VerifyOptions ) {

               WinError = ERROR_BAD_PATHNAME;
           }
       }
    }

    if ( WinError == ERROR_SUCCESS ) {

        WinError = DsRolepValidatePath( DsLogPath, VerifyOptions, &VerifyResults );

        if ( WinError == ERROR_SUCCESS ) {

            if ( VerifyResults != VerifyOptions ) {

                WinError = ERROR_BAD_PATHNAME;
            }
        }
    }

    if ( WinError == ERROR_SUCCESS ) {

        VerifyOptions = DSROLEP_PATH_VALIDATE_LOCAL | DSROLEP_PATH_VALIDATE_NTFS;
        WinError = DsRolepValidatePath( SystemVolumeRootPath, VerifyOptions, &VerifyResults );

        if ( WinError == ERROR_SUCCESS ) {

            if ( VerifyResults != VerifyOptions ) {

                WinError = ERROR_BAD_PATHNAME;
            }
        }
    }

    return WinError;
}

BOOL
IsProductSuiteConfigured(
    WORD Suite
    )
{

    OSVERSIONINFOEXA  osvi;
    DWORDLONG dwlConditionMask = 0;

    //
    // Setup the request for the desired suite
    //
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    osvi.wSuiteMask = Suite;

    //
    // Setup the condition
    //
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_AND);

    return VerifyVersionInfoA(&osvi,
                              VER_SUITENAME,
                              dwlConditionMask);

}

BOOL
IsWebBlade(
    VOID
    )
{
    return IsProductSuiteConfigured(VER_SUITE_BLADE);
}

BOOL 
IsSBS(
    VOID
    )
{
    return IsProductSuiteConfigured(VER_SUITE_SMALLBUSINESS_RESTRICTED);
}

DWORD
DsRolepIsValidProductSuite(
    IN BOOL fNewForest,
    IN BOOL fReplica,
    IN LPWSTR DomainName
    )
/*++

Routine Description:

    This routine determines if the promotion request is valid for the
    current configuration of the OS.

Arguments:

    fNewForest -- a new forest is requested.
    
    fReplica -- a replica is requested
    
    DomainName -- the name of the domain to create or join
    
Return Values:

    ERROR_SUCCESS, ERROR_NOT_SUPPORTED, resource errors otherwise     

--*/
{
    DWORD err = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DCInfo = NULL;

    if (IsWebBlade()) {
        // See Windows RAID issue 195265
        err = ERROR_NOT_SUPPORTED;
        goto Exit;
    }

    if (IsSBS()) {

        if (fReplica) {

            err = DsGetDcNameW(NULL,
                               DomainName,
                               NULL,
                               NULL,
                               0,
                               &DCInfo);
            if (ERROR_SUCCESS != err) {

                // Return the resource or configuration error
                DsRolepLogPrint((DEB_ERROR,
                                 "Request to find a DC for %ws failed (%d)\n", 
                                 DomainName, 
                                 err));
                goto Exit;
            }

            if ( !(DnsNameCompareEqual == DnsNameCompareEx_W(DomainName,
                                                             DCInfo->DnsForestName,
                                                             0 ))) {                       
                // See Windows issue 373388
                // Must be the root of the forest
                err = ERROR_NOT_SUPPORTED;
                goto Exit;
            }

        } else if (!fNewForest) {

            // See Windows NT issue 353854
            err = ERROR_NOT_SUPPORTED;
            goto Exit;
        }
    }

Exit:

    if (DCInfo) {
        NetApiBufferFree(DCInfo);
    }

    return err;
}



DWORD
DsRolepDecryptPasswordsWithKey(
    IN handle_t RpcBindingHandle,
    IN PDSROLEPR_ENCRYPTED_USER_PASSWORD * EncryptedPasswords,
    IN ULONG Count,
    IN OUT UNICODE_STRING *EncodedPasswords,
    OUT PUCHAR Seed
    )
/*++

Routine Description:

    Decrypts a set of passwords encrypted with the user session key.

Arguments:

    RpcBindingHandle - Rpc Binding handle describing the session key to use.

    EncryptedPasswords - Encrypted passwords to decrypt.
    
    Count - the number of passwords

    EncodedPassword - Returns the Encoded password.
        The password has been encoded
        Buffer should be freed using LocalFree.
        
    Seed - the seed that was used to encode the password        

Return Value:

    ERROR_SUCCESS; a resource or parameter error otherwise

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    USER_SESSION_KEY UserSessionKey;
    RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;

    LPWSTR PasswordPart;

    ULONG i;

    //
    // Get the session key
    //
    Status = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)RpcBindingHandle,
                    &UserSessionKey );

    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
    }

    for ( i = 0; i < Count; i++ ) {

        PDSROLEPR_USER_PASSWORD Password = (PDSROLEPR_USER_PASSWORD) EncryptedPasswords[i];
        LPWSTR ClearPassword;
    
        //
        // Handle the trivial case
        //
        RtlInitUnicodeString( &EncodedPasswords[i], NULL );
        if ( Password == NULL ) {
            continue;
        }
    
        //
        // The UserSessionKey is the same for the life of the session.  RC4'ing multiple
        //  strings with a single key is weak (if you crack one you've cracked them all).
        //  So compute a key that's unique for this particular encryption.
        //
        //
    
        MD5Init(&Md5Context);
    
        MD5Update( &Md5Context, (LPBYTE)&UserSessionKey, sizeof(UserSessionKey) );
        MD5Update( &Md5Context, Password->Obfuscator, sizeof(Password->Obfuscator) );
    
        MD5Final( &Md5Context );
    
        rc4_key( &Rc4Key, MD5DIGESTLEN, Md5Context.digest );
    
    
        //
        // Decrypt the Buffer
        //
    
        rc4( &Rc4Key, sizeof(Password->Buffer)+sizeof(Password->Length), (LPBYTE) Password->Buffer );
    
        //
        // Check that the length is valid.  If it isn't bail here.
        //
    
        if (Password->Length > DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
            WinError = ERROR_INVALID_PASSWORD;
            goto Cleanup;
        }
    
        //
        // Return the password to the caller.
        //
    
        ClearPassword = LocalAlloc( 0,  Password->Length + sizeof(WCHAR) );
    
        if ( ClearPassword == NULL ) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    
        //
        // Copy the password into the buffer
        //
        RtlCopyMemory( ClearPassword,
                       ((PCHAR) Password->Buffer) +
                       (DSROLE_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                       Password->Length,
                       Password->Length );
    
        ClearPassword[Password->Length/sizeof(WCHAR)] = L'\0';
    
        RtlInitUnicodeString( &EncodedPasswords[i], ClearPassword );

        //
        // Now encode it
        //
        RtlRunEncodeUnicodeString( Seed, &EncodedPasswords[i] );

    }

Cleanup:

    if ( WinError != ERROR_SUCCESS ) {

        for ( i = 0; i < Count; i++ ) {
            if ( EncodedPasswords[i].Buffer ) {
                LocalFree( EncodedPasswords[i].Buffer );
                RtlInitUnicodeString( &EncodedPasswords[i], NULL );
            }
        }
    }

    return WinError;
}


VOID
DsRolepFreePasswords(
    IN OUT UNICODE_STRING *Passwords,
    IN ULONG Count
    )

/*++

Routine Description:

    Frees the variables returned from DsRolepDecryptPasswordsWithKey

Arguments:

    Passwords - the encoded passwords to free
    
    Count - the number of passwords

Return Value:

    ERROR_SUCCESS; a resource or parameter error otherwise

--*/
{
    ULONG i;

    for ( i = 0; i < Count; i++ ) {

        if ( Passwords[i].Buffer ) {
             
            RtlZeroMemory( Passwords[i].Buffer, Passwords[i].Length );
            LocalFree( Passwords[i].Buffer );
            RtlInitUnicodeString( &Passwords[i], NULL );
        }
    }
}

DWORD
DsRolepDecryptHash(
    IN PUNICODE_STRING BootKey
    )
/*++

Routine Description:

    Frees the variables returned from DsRolepDecryptPasswordsWithKey

Arguments:

    Passwords - the encoded passwords to free
    
    Count - the number of passwords

Return Value:

    ERROR_SUCCESS; a resource or parameter error otherwise

--*/
{
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\ds.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ds.h
    
Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __DS_H__
#define __DS_H__

DWORD
DsRolepInstallDs(
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FlatDomainName,
    IN  LPWSTR DnsTreeName,
    IN  LPWSTR SiteName,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR RestorePath,
    IN  LPWSTR SysVolRootPath,
    IN  PUNICODE_STRING Bootkey,
    IN  LPWSTR AdminAccountPassword,
    IN  LPWSTR ParentDnsName OPTIONAL,
    IN  LPWSTR Server OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR SafeModePassword OPTIONAL,
    IN  LPWSTR SourceDomain,
    IN  ULONG Options,
    IN  BOOLEAN Replica,
    IN  HANDLE  ImpersonateToken,
    OUT LPWSTR *InstalledSite,
    IN  OUT GUID   *DomainGuid,
    OUT PSID   *NewDomainSid
    );

DWORD
DsRolepStopDs(
    IN  BOOLEAN DsInstalled
    );

DWORD
DsRolepUninstallDs(
    );

DWORD
DsRolepDemoteDs(
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR DomainAdminPassword,
    IN LPWSTR SupportDc,
    IN LPWSTR SupportDomain,
    IN HANDLE ImpersonateToken,
    IN BOOLEAN LastDcInDomain
    );


DWORD
DsRolepDemoteFlagsToNtdsFlags(
    DWORD Flags
    );

DWORD
WINAPI
DsRolepGetDatabaseFacts(
    IN  LPWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State
    );

#endif // __DS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\loadfn.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    loadfn.h

Abstract:

    Definitions and globals for dynamically loading the required functions from
    the setup dlls

Author:

    Mac McLain      (MacM)       June 11, 1997

Environment:

Revision History:

--*/
#ifndef __LOADFN_H__
#define __LOADFN_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines NTDSSET_ALLOCATE
//
#ifdef EXTERN
    #undef EXTERN
#endif

#ifdef NTDSSET_ALLOCATE
    #define EXTERN
#else
    #define EXTERN extern
#endif


#include <scesetup.h>

typedef DWORD ( *DSR_NtdsInstall )(
            IN PNTDS_INSTALL_INFO InstallInfo,
            OUT LPWSTR *InstalledSiteName, OPTIONAL
            OUT GUID   *NewDnsDomainGuid,  OPTIONAL
            OUT PSID   *NewDnsDomainSid    OPTIONAL
            );

typedef DWORD ( *DSR_NtdsInstallShutdown )(
            VOID
            );

typedef DWORD ( *DSR_NtdsInstallUndo )(
            VOID
            );

typedef DWORD ( *DSR_NtdsGetDefaultDnsName )(
            OUT OPTIONAL WCHAR *DnsName,
            IN  OUT ULONG *DnsNameLength
            );

typedef DWORD ( *DSR_NtdsSetReplicaMachineAccount )(
            IN SEC_WINNT_AUTH_IDENTITY *Credentials,
            IN HANDLE                   ClientToken,                
            IN LPWSTR                   DcName,
            IN LPWSTR                   AccountName,
            IN ULONG                    AccountFlags,
            IN OUT WCHAR**              AccountDn OPTIONAL
            );

typedef DWORD ( *DSR_NtdsPrepareForDemotion ) (
            IN ULONG Flags,
            IN LPWSTR ServerName,
            IN SEC_WINNT_AUTH_IDENTITY *Credentials,       OPTIONAL
            IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
            IN CALLBACK_ERROR_TYPE      pfnErrorStatus,    OPTIONAL
            IN HANDLE                   ClientToken,       OPTIONAL
            OUT PNTDS_DNS_RR_INFO      *pDnsRRInfo
            );

typedef DWORD ( *DSR_NtdsPrepareForDemotionUndo ) (
            VOID
            );

typedef DWORD ( *DSR_NtdsDemote ) (
            IN PSEC_WINNT_AUTH_IDENTITY Credentials,   OPTIONAL
            IN LPWSTR                   AdminPassword, OPTIONAL
            IN DWORD                    Flags,
            IN LPWSTR                   ServerName,
            IN HANDLE                   ClientToken,
            IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtdsInstallCancel ) (
            VOID
            );

typedef DWORD ( *DSR_NtdsInstallReplicateFull ) (
            IN CALLBACK_STATUS_TYPE     pfnStatusCallBack,
            IN HANDLE                   ClientToken,
            IN ULONG                    ulRepOptions
            );

typedef DWORD ( *DSR_NtdsFreeDnsRRInfo ) (
            IN PNTDS_DNS_RR_INFO     pDnsRRInfo
            );
//
// Security editor prototypes
//
typedef DWORD ( WINAPI *DSR_SceDcPromoteSecurityEx ) (
    IN HANDLE ClientToken,
    IN ULONG Options,
    IN CALLBACK_STATUS_TYPE pfnStatusCallBack
    );

typedef DWORD ( WINAPI *DSR_SceDcPromoCreateGPOsInSysvolEx ) (
    IN HANDLE ClientToken,
    IN LPWSTR Domain,
    IN LPWSTR SysvolRoot,
    IN ULONG Options,
    IN CALLBACK_STATUS_TYPE pfnStatusCallBack
    );

typedef DWORD ( WINAPI *DSR_SceSetupSystemByInfName ) (
    IN PWSTR InfFullName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    );

//
// NTFRS initialization prototypes
//
typedef DWORD ( *DSR_NtFrsApi_PrepareForPromotionW ) (
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_PrepareForDemotionW ) (
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_PrepareForDemotionUsingCredW ) (
            IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
            IN HANDLE ClientToken,
            IN CALLBACK_ERROR_TYPE     pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_StartPromotionW ) (
            IN PWCHAR   ParentComputer,                         OPTIONAL
            IN PWCHAR   ParentAccount,                          OPTIONAL
            IN PWCHAR   ParentPassword,                         OPTIONAL
            IN DWORD    DisplayCallBack(IN PWCHAR Display),     OPTIONAL
            IN CALLBACK_ERROR_TYPE      pfnErrorCallBack,       OPTIONAL
            IN PWCHAR   ReplicaSetName,
            IN PWCHAR   ReplicaSetType,
            IN DWORD    ReplicaSetPrimary,
            IN PWCHAR   ReplicaSetStage,
            IN PWCHAR   ReplicaSetRoot
            );

typedef DWORD ( *DSR_NtFrsApi_StartDemotionW ) (
            IN PWCHAR   ReplicaSetName,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_WaitForPromotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_WaitForDemotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_CommitPromotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_CommitDemotionW ) (
            IN DWORD    TimeoutInMilliSeconds,
            IN CALLBACK_ERROR_TYPE  pfnErrorCallBack   OPTIONAL
            );

typedef DWORD ( *DSR_NtFrsApi_AbortPromotionW ) (
            VOID
            );

typedef DWORD ( *DSR_NtFrsApi_AbortDemotionW ) (
            VOID
            );

#ifndef W32TIME_PROMOTE

//
// w32time doesn't currently have any exported headers.
//
#define W32TIME_PROMOTE 0x1
#define W32TIME_DEMOTE  0x2
#define W32TIME_PROMOTE_FIRST_DC_IN_TREE 0x4

#endif

typedef VOID ( *DSR_W32TimeDcPromo ) (
        DWORD dwFlags
        );

EXTERN DSR_NtdsInstall DsrNtdsInstall;
EXTERN DSR_NtdsInstallShutdown DsrNtdsInstallShutdown;
EXTERN DSR_NtdsInstallUndo DsrNtdsInstallUndo;
EXTERN DSR_NtdsGetDefaultDnsName DsrNtdsGetDefaultDnsName;
EXTERN DSR_NtdsSetReplicaMachineAccount DsrNtdsSetReplicaMachineAccount;
EXTERN DSR_NtdsPrepareForDemotion DsrNtdsPrepareForDemotion;
EXTERN DSR_NtdsPrepareForDemotionUndo DsrNtdsPrepareForDemotionUndo;
EXTERN DSR_NtdsDemote DsrNtdsDemote;
EXTERN DSR_NtdsInstallCancel DsrNtdsInstallCancel;
EXTERN DSR_NtdsInstallReplicateFull DsrNtdsInstallReplicateFull;
EXTERN DSR_NtdsFreeDnsRRInfo DsrNtdsFreeDnsRRInfo;
EXTERN DSR_SceDcPromoteSecurityEx DsrSceDcPromoteSecurityEx;
EXTERN DSR_SceDcPromoCreateGPOsInSysvolEx DsrSceDcPromoCreateGPOsInSysvolEx;
EXTERN DSR_SceSetupSystemByInfName DsrSceSetupSystemByInfName;
EXTERN DSR_NtFrsApi_PrepareForPromotionW DsrNtFrsApi_PrepareForPromotionW;
EXTERN DSR_NtFrsApi_PrepareForDemotionW DsrNtFrsApi_PrepareForDemotionW;
EXTERN DSR_NtFrsApi_PrepareForDemotionUsingCredW DsrNtFrsApi_PrepareForDemotionUsingCredW;
EXTERN DSR_NtFrsApi_StartPromotionW DsrNtFrsApi_StartPromotionW;
EXTERN DSR_NtFrsApi_StartDemotionW DsrNtFrsApi_StartDemotionW;
EXTERN DSR_NtFrsApi_WaitForPromotionW DsrNtFrsApi_WaitForPromotionW;
EXTERN DSR_NtFrsApi_WaitForDemotionW DsrNtFrsApi_WaitForDemotionW;
EXTERN DSR_NtFrsApi_CommitPromotionW DsrNtFrsApi_CommitPromotionW;
EXTERN DSR_NtFrsApi_CommitDemotionW DsrNtFrsApi_CommitDemotionW;
EXTERN DSR_NtFrsApi_AbortPromotionW DsrNtFrsApi_AbortPromotionW;
EXTERN DSR_NtFrsApi_AbortDemotionW DsrNtFrsApi_AbortDemotionW;
EXTERN DSR_W32TimeDcPromo DsrW32TimeDcPromo;

DWORD
DsRolepLoadSetupFunctions(
    VOID
    );

VOID
DsRolepUnloadSetupFunctions(
    VOID
    );

VOID
DsRolepInitSetupFunctions(
    VOID
    );

//
// N.B.  If this assert fires, then the operation handle lock
// has been misused.
//
#define DSROLE_GET_SETUP_FUNC( status, pfunc )              \
if ( pfunc == NULL ) {                                      \
    ASSERT( pfunc );                                        \
    status = DsRolepLoadSetupFunctions();                   \
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\ds.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition

#include "secure.h"

DWORD
DsRolepInstallDs(
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FlatDomainName,
    IN  LPWSTR DnsTreeRoot,
    IN  LPWSTR SiteName,
    IN  LPWSTR DsDatabasePath,
    IN  LPWSTR DsLogPath,
    IN  LPWSTR RestorePath,
    IN  LPWSTR SysVolRootPath,
    IN  PUNICODE_STRING Bootkey,
    IN  LPWSTR AdminAccountPassword,
    IN  LPWSTR ParentDnsName,
    IN  LPWSTR Server OPTIONAL,
    IN  LPWSTR Account OPTIONAL,
    IN  LPWSTR Password OPTIONAL,
    IN  LPWSTR SafeModePassword OPTIONAL,
    IN  LPWSTR SourceDomain OPTIONAL,
    IN  ULONG  Options,
    IN  BOOLEAN Replica,
    IN  HANDLE ImpersonateToken,
    OUT LPWSTR *InstalledSite,
    IN  OUT GUID *DomainGuid,
    OUT PSID   *NewDomainSid
    )
/*++

Routine Description:

    Wrapper for the routine that does the actual install.

Arguments:

    DnsDomainName - Dns domain name of the domain to install

    FlatDomainName - NetBIOS domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go
    
    RestorePath - Location of a restored database.

    EnterpriseSysVolPath -- Absolute path on the local machine for the enterprise wide
                            system volume

    DomainSysVolPath -- Absolute path on the local machine for the domain wide system volume

    AdminAccountPassword -- Administrator password to set for the domain

    ParentDnsName - Optional.  Parent domain name

    Server -- Optional.  Replica partner or name of Dc in parent domain

    Account - User account to use when setting up as a child domain

    Password - Password to use with the above account

    Replica - If TRUE, treat this as a replica install
    
    ImpersonateToken - the token of caller of the role change API

    InstalledSite - Name of the site the Dc was installed into

    DomainGuid - Where the new domain guid is returned

    NewDomainSid - Where the new domain sid is returned.

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTDS_INSTALL_INFO DsInstallInfo;
    PSEC_WINNT_AUTH_IDENTITY AuthIdent = NULL;
    BOOL fRewindServer = FALSE;

    RtlZeroMemory( &DsInstallInfo, sizeof( DsInstallInfo ) );

    if ( !Replica ) {

        if ( ParentDnsName == NULL ) {

            DsInstallInfo.Flags = NTDS_INSTALL_ENTERPRISE;

        } else {

            DsInstallInfo.Flags = NTDS_INSTALL_DOMAIN;
        }

    } else {

        DsInstallInfo.Flags = NTDS_INSTALL_REPLICA;
    }

    if ( FLAG_ON( Options, DSROLE_DC_ALLOW_DC_REINSTALL ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_DC_REINSTALL;
    }

    if ( FLAG_ON( Options, DSROLE_DC_ALLOW_DOMAIN_REINSTALL ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_DOMAIN_REINSTALL;
    }

    if ( FLAG_ON( Options, DSROLE_DC_DOWNLEVEL_UPGRADE ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_UPGRADE;
    }

    if ( FLAG_ON( Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_NEW_TREE;
    }

    if ( FLAG_ON( Options, DSROLE_DC_ALLOW_ANONYMOUS_ACCESS ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_ALLOW_ANONYMOUS;
    }

    if ( FLAG_ON( Options, DSROLE_DC_DEFAULT_REPAIR_PWD ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_DFLT_REPAIR_PWD;
    }

    if ( FLAG_ON( Options, DSROLE_DC_SET_FOREST_CURRENT ) ) {

        DsInstallInfo.Flags |= NTDS_INSTALL_SET_FOREST_CURRENT;
    }

    if ( Server 
      && Server[0] == L'\\'  ) {
        //
        // Don't pass in \\
        //
        Server += 2;
        fRewindServer = TRUE;
    }

    DsInstallInfo.DitPath = ( PWSTR )DsDatabasePath;
    DsInstallInfo.LogPath = ( PWSTR )DsLogPath;
    DsInstallInfo.SysVolPath = (PWSTR)SysVolRootPath;
    DsInstallInfo.RestorePath = ( PWSTR )RestorePath;
    DsInstallInfo.BootKey = Bootkey->Buffer;
    DsInstallInfo.cbBootKey = Bootkey->Length;
    DsInstallInfo.SiteName = ( PWSTR )SiteName;
    DsInstallInfo.DnsDomainName = ( PWSTR )DnsDomainName;
    DsInstallInfo.FlatDomainName = ( PWSTR )FlatDomainName;
    DsInstallInfo.DnsTreeRoot = ( PWSTR )DnsTreeRoot;
    DsInstallInfo.ReplServerName = ( PWSTR )Server;
    DsInstallInfo.pfnUpdateStatus = DsRolepStringUpdateCallback;
    DsInstallInfo.pfnOperationResultFlags = DsRolepOperationResultFlagsCallBack;
    DsInstallInfo.AdminPassword = AdminAccountPassword;
    DsInstallInfo.pfnErrorStatus = DsRolepStringErrorUpdateCallback;
    DsInstallInfo.ClientToken = ImpersonateToken;
    DsInstallInfo.SafeModePassword = SafeModePassword;
    DsInstallInfo.SourceDomainName = SourceDomain;
    DsInstallInfo.Options = Options;

    if (DsInstallInfo.RestorePath && *DsInstallInfo.RestorePath){
    
        WCHAR *RealDNSDomainName=NULL;
        ULONG state=0;
        
        Win32Err = DsRolepGetDatabaseFacts(DsInstallInfo.RestorePath,
                                           &RealDNSDomainName,
                                           &state);
        if(ERROR_SUCCESS != Win32Err) {
            DSROLEP_FAIL1( Win32Err, 
                           DSROLERES_PROMO_FAILED,
                           L"the domain information could not be retrived from the backup.");
            MIDL_user_free(RealDNSDomainName);
            return ERROR_CURRENT_DOMAIN_NOT_ALLOWED;        
        }

        if(FALSE == DnsNameCompare_W(RealDNSDomainName,DsInstallInfo.DnsDomainName)) {
            DSROLEP_FAIL2( ERROR_CURRENT_DOMAIN_NOT_ALLOWED, 
                           DSROLERES_WRONG_DOMAIN,
                           DsInstallInfo.DnsDomainName,
                           RealDNSDomainName );
            MIDL_user_free(RealDNSDomainName);
            return ERROR_CURRENT_DOMAIN_NOT_ALLOWED;
        }
        MIDL_user_free(RealDNSDomainName);

    }
    //
    // Build the cred structure
    //
    Win32Err = DsRolepCreateAuthIdentForCreds( Account, Password, &AuthIdent );

    if ( Win32Err == ERROR_SUCCESS ) {

        DsInstallInfo.Credentials = AuthIdent;

        if (!DsInstallInfo.RestorePath) {

            Win32Err = DsRolepCopyDsDitFiles( DsDatabasePath );

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DSROLEP_CURRENT_OP0( DSROLEEVT_INSTALL_DS );

            DsRolepLogPrint(( DEB_TRACE_DS, "Calling NtdsInstall for %ws\n", DnsDomainName ));

            DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstall );

            if ( Win32Err == ERROR_SUCCESS ) {

                DsRolepSetAndClearLog();

                Win32Err = ( *DsrNtdsInstall )( &DsInstallInfo,
                                                InstalledSite,
                                                DomainGuid,
                                                NewDomainSid );

                DsRolepSetAndClearLog();

                DsRolepLogPrint(( DEB_TRACE_DS, "NtdsInstall for %ws returned %lu\n",
                                  DnsDomainName, Win32Err ));

#if DBG
                if ( Win32Err != ERROR_SUCCESS ) {

                    DsRolepLogPrint(( DEB_TRACE_DS, "NtdsInstall parameters:\n" ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tFlags: %lu\n", DsInstallInfo.Flags ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tDitPath: %ws\n", DsInstallInfo.DitPath ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tLogPath: %ws\n", DsInstallInfo.LogPath ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tSiteName: %ws\n", DsInstallInfo.SiteName ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tDnsDomainName: %ws\n",
                                      DsInstallInfo.DnsDomainName ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tFlatDomainName: %ws\n",
                                      DsInstallInfo.FlatDomainName ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tDnsTreeRoot: %ws\n",
                                      DsInstallInfo.DnsTreeRoot ? DsInstallInfo.DnsTreeRoot :
                                                                                    L"(NULL)" ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tReplServerName: %ws\n",
                                      DsInstallInfo.ReplServerName ?
                                                     DsInstallInfo.ReplServerName : L"(NULL)" ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tCredentials: %p\n",
                                      DsInstallInfo.Credentials ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tpfnUpdateStatus: %p\n",
                                      DsInstallInfo.pfnUpdateStatus ));
                    DsRolepLogPrint(( DEB_TRACE_DS, "\tAdminPassword: %p\n",
                                      DsInstallInfo.AdminPassword ));
                }
#endif
            }
        }
        
        DsRolepFreeAuthIdentForCreds( AuthIdent );
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepInstallDs returned %lu\n",
                      Win32Err ));

    if ( fRewindServer ) {

        Server -= 2;
        
    }

    return( Win32Err );
}




DWORD
DsRolepStopDs(
    IN  BOOLEAN DsInstalled
    )
/*++

Routine Description:

    "Uninitinalizes" the Lsa and stops the Ds

Arguments:

    DsInstalled -- If TRUE, stop the Ds.

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( DsInstalled ) {

        NTSTATUS Status = LsapDsUnitializeDsStateInfo();

        if ( NT_SUCCESS( Status ) ) {

            DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstallShutdown );

            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = ( *DsrNtdsInstallShutdown )();

                if ( Win32Err != ERROR_SUCCESS ) {

                    DsRoleDebugOut(( DEB_ERROR,
                                     "NtdsInstallShutdown failed with %lu\n", Win32Err ));
                }
            }

        } else {

            Win32Err = RtlNtStatusToDosError( Status );

        }

    }

    DsRolepLogOnFailure( Win32Err,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepStopDs failed with %lu\n",
                                            Win32Err )) );

    return( Win32Err );
}



DWORD
DsRolepDemoteDs(
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR AdminPassword,
    IN LPWSTR SupportDc,
    IN LPWSTR SupportDomain,
    IN HANDLE ImpersonateToken,
    IN BOOLEAN LastDcInDomain
    )
/*++

Routine Description:

    Wrapper for the routine that does the actual demotion.

Arguments:

    DnsDomainName - Dns domain name of the domain to demote

    Account - Account to use for the demotion

    Password - Password to use with the above account

    AdminPassword -- Administrator password to set for the domain

    SupportDc - Optional.  Name of a Dc in a domain (current or parent) to
        clean up Ds information

    SupportDomain - Optional.  Name of the domain (current or parent) to
        clean up Ds information
        
    ImpersonateToken - the token of caller of the role change API

    LastDcInDomain - If TRUE, this is the last Dc in the domain

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PSEC_WINNT_AUTH_IDENTITY AuthIdent = NULL;
    NTSTATUS Status;

    DSROLEP_CURRENT_OP0( DSROLEEVT_UNINSTALL_DS );

    DsRoleDebugOut(( DEB_TRACE_DS, "Calling NtdsDemote for %ws\n", DnsDomainName ));

    DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsDemote );

    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepSetAndClearLog();

        //
        // Build the cred structure
        //
        Win32Err = DsRolepCreateAuthIdentForCreds( Account, Password, &AuthIdent );

        if ( Win32Err == ERROR_SUCCESS ) {

            Status = LsapDsUnitializeDsStateInfo();

            if ( !NT_SUCCESS( Status ) ) {

                Win32Err = RtlNtStatusToDosError( Status );

            }

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE_DS, "Invoking NtdsDemote\n" ));

            Win32Err = ( *DsrNtdsDemote )( AuthIdent,
                                           AdminPassword,
                                           LastDcInDomain ? NTDS_LAST_DC_IN_DOMAIN : 0,
                                           SupportDc,
                                           ImpersonateToken,
                                           DsRolepStringUpdateCallback,
                                           DsRolepStringErrorUpdateCallback );

            if ( Win32Err != ERROR_SUCCESS ) {

                //
                // Switch the LSA back to using the DS
                //
                LsapDsInitializeDsStateInfo( LsapDsDs );
            }

            //
            // Free the allocated creditials structure
            //
            DsRolepFreeAuthIdentForCreds( AuthIdent );
        }

        DsRolepSetAndClearLog();

        DsRolepLogPrint(( DEB_TRACE_DS, "NtdsDemote returned %lu\n",
                          Win32Err ));

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepDemoteDs returned %lu\n",
                      Win32Err ));

    DSROLEP_FAIL0( Win32Err, DSROLERES_DEMOTE_DS );
    return( Win32Err );
}





DWORD
DsRolepUninstallDs(
    VOID
    )
/*++

Routine Description:

    Uninstalls the Ds.

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsInstallUndo );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err =  ( *DsrNtdsInstallUndo )( );

    }

    DsRoleDebugOut(( DEB_TRACE_DS, "NtdsUnInstall returned %lu\n", Win32Err ));

    return( Win32Err );

}

DWORD
DsRolepDemoteFlagsToNtdsFlags(
    DWORD Flags
    )
{
    DWORD fl = 0;

    fl |= ( FLAG_ON( Flags, DSROLE_DC_DONT_DELETE_DOMAIN ) ? NTDS_DONT_DELETE_DOMAIN : 0 );

    return fl;
}

DWORD
DsRolepLoadHive(
    IN LPWSTR Hive,
    IN LPWSTR KeyName
    )
/*++

Routine Description:

    This function will load a hive into the registry
    
Arguments:

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.


Return Values:

    ERROR_SUCCESS - Success

--*/

{
    DWORD Win32Err = ERROR_SUCCESS;

    Win32Err = RegLoadKeyW(
                      HKEY_LOCAL_MACHINE,        
                      KeyName, 
                      Hive);

    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_WARN, "Failed to load key %ws: %lu retrying\n",
                          Hive,
                          Win32Err ));
        RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,
                  KeyName);
        Win32Err = RegLoadKeyW(
                      HKEY_LOCAL_MACHINE,        
                      KeyName, 
                      Hive);
        if (Win32Err != ERROR_SUCCESS) {
            DsRolepLogPrint(( DEB_ERROR, "Failed to load key %ws: %lu\n",
                          Hive,
                          Win32Err ));
            goto cleanup;
        }

    }

    cleanup:

    return Win32Err;

}

DWORD                            
WINAPI
DsRolepGetDatabaseFacts(
    IN  LPWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State
    )
/*++

Routine Description:

    This function will give information about a restore database
    1. the way the syskey is stored
    2. the domain that the database came from
    3. where the backup was taken from a GC or not

Arguments:

    lpRestorePath - The location of the restored files.
    
    lpDNSDomainName - This parameter will recieve the name of the domain that this backup came
                      from

    State - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    WCHAR regsystemfilepath[MAX_PATH];
    WCHAR regsecurityfilepath[MAX_PATH];
    DWORD controlset=0;
    DWORD BootType=0;
    DWORD GCready=0;
    DWORD type=REG_DWORD;
    DWORD size=sizeof(DWORD);
    ULONG cbregsystemfilepath=MAX_PATH*2;
    HKEY  LsaKey=NULL;
    HKEY  phkOldlocation=NULL;
    HKEY  OldSecurityKey=NULL;
    DWORD Win32Err=ERROR_SUCCESS;
    BOOLEAN fWasEnabled=FALSE;
    NTSTATUS Status=STATUS_SUCCESS;
    BOOL SystemKeyloaded=FALSE;
    BOOL SecurityKeyloaded=FALSE;

    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,           // Enable
                                 FALSE,          // not client; process wide
                                 &fWasEnabled );
    ASSERT( NT_SUCCESS( Status ) );


    if(IsBadWritePtr(lpDNSDomainName,
                     sizeof(LPWSTR*) )){
        Win32Err =  ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    *State=0;

    //set up the location of the system registry file

    wcscpy(regsystemfilepath,lpRestorePath);
    wcscat(regsystemfilepath,L"\\registry\\system");

    //
    // Get the source path of the database and the log files from the old
    // registry
    //
    
    Win32Err = DsRolepLoadHive(regsystemfilepath,
                               IFM_SYSTEM_KEY);

    if (ERROR_SUCCESS != Win32Err) {

        goto cleanup;

    }

    SystemKeyloaded = TRUE;

    //find the default controlset
    Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"ifmSystem\\Select",
                  0,
                  KEY_READ,
                  & LsaKey );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueExW( 
                LsaKey,
                L"Default",
                0,
                &type,
                (PUCHAR) &controlset,
                &size
                );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Couldn't Discover proper controlset: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegCloseKey(LsaKey);
    LsaKey=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                      Win32Err ));
        goto cleanup;
    }

    //Find the boot type
    if (controlset == 1) {
        Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"ifmSystem\\ControlSet001\\Control\\Lsa",
                      0,
                      KEY_READ,
                      & LsaKey );
    } else {
        Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"ifmSystem\\ControlSet002\\Control\\Lsa",
                      0,
                      KEY_READ,
                      & LsaKey );
    }

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueExW( 
                LsaKey,
                L"SecureBoot",
                0,
                &type,
                (PUCHAR) &BootType,
                &size
                );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Couldn't Discover proper controlset: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    Win32Err = RegCloseKey(LsaKey);
    LsaKey=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                      Win32Err ));
        goto cleanup;
    }
    
    //find if a GC or not
    if (controlset == 1) {
        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,        
                      L"ifmSystem\\ControlSet001\\Services\\NTDS\\Parameters",  
                      0,
                      KEY_READ,
                      &phkOldlocation 
                    );
    } else {
        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,        
                      L"ifmSystem\\ControlSet002\\Services\\NTDS\\Parameters",  
                      0,
                      KEY_READ,
                      &phkOldlocation 
                    );
    }

    if (Win32Err != ERROR_SUCCESS) {
        DsRolepLogPrint(( DEB_ERROR, "RegOpenKeyExW failed to discover the GC state of the database %d\n",
                      Win32Err ));
        goto cleanup;
    }

    Win32Err = RegQueryValueEx(
                      phkOldlocation,           
                      TEXT(GC_PROMOTION_COMPLETE), 
                      0,
                      &type,       
                      (VOID*)&GCready,        
                      &size      
                      );
    if (Win32Err != ERROR_SUCCESS && ERROR_FILE_NOT_FOUND != Win32Err) {
        DsRolepLogPrint(( DEB_ERROR, "RegQueryValueEx failed to discover the GC state of the database %d\n",
                      Win32Err ));
        goto cleanup;

    }

    //
    // The System key is no longer needed unload it.
    //
    {
        DWORD tWin32Err = ERROR_SUCCESS;
    
        if ( phkOldlocation ) {
            tWin32Err = RegCloseKey(phkOldlocation);
            phkOldlocation = NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }

        if(SystemKeyloaded){
            tWin32Err = RegUnLoadKeyW(
                          HKEY_LOCAL_MACHINE,
                          IFM_SYSTEM_KEY);
            SystemKeyloaded = FALSE;
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "RegUnLoadKeyW failed to unload system key with %d\n",
                              tWin32Err ));
            }
        }

    }

    //set up the location of the Security registry file

    wcscpy(regsecurityfilepath,lpRestorePath);
    wcscat(regsecurityfilepath,L"\\registry\\security");

    Win32Err = DsRolepLoadHive(regsecurityfilepath,
                               IFM_SECURITY_KEY);

    if (ERROR_SUCCESS != Win32Err) {

        goto cleanup;

    }

    SecurityKeyloaded = TRUE;

    //open the security key to pass to LsapRetrieveDnsDomainNameFromHive()
    Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"ifmSecurity",
                  0,
                  KEY_READ,
                  & OldSecurityKey );

    if (Win32Err != ERROR_SUCCESS)
    {
        DsRolepLogPrint(( DEB_ERROR, "Failed to open key: %lu\n",
                          Win32Err ));
        goto cleanup;
    }

    //Allocate memory to be returned to the client
    *lpDNSDomainName = MIDL_user_allocate((DNS_MAX_NAME_LENGTH+1)*sizeof(WCHAR));
    if(!*lpDNSDomainName){
        Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    ZeroMemory(*lpDNSDomainName,DNS_MAX_NAME_LENGTH*sizeof(WCHAR));

    size = (DNS_MAX_NAME_LENGTH+1)*sizeof(WCHAR);

    //looking for the DNS name of the Domain that the replica is part of.

    Status = LsapRetrieveDnsDomainNameFromHive(OldSecurityKey,
                                               &size,
                                               *lpDNSDomainName
                                               );
    if (!NT_SUCCESS(Status)) {
        DsRolepLogPrint(( DEB_ERROR, "Failed to retrieve DNS domain name for hive : %lu\n",
                          RtlNtStatusToDosError(Status) ));
        Win32Err = RtlNtStatusToDosError(Status);
        goto cleanup;
    }

    if (GCready) {
        *State |= DSROLE_DC_IS_GC;
    }

    if (BootType == 1) {
        *State |= DSROLE_KEY_STORED;
    } else if ( BootType == 2) {
        *State |= DSROLE_KEY_PROMPT;
    } else if ( BootType == 3) {
        *State |= DSROLE_KEY_DISK;
    } else {
        DsRolepLogPrint(( DEB_ERROR, "Didn't discover Boot type Error Unknown\n"));
        MIDL_user_free(*lpDNSDomainName);
        *lpDNSDomainName=NULL;
    }


    cleanup:
    {
        DWORD tWin32Err = ERROR_SUCCESS;
    
        if ( LsaKey ) {
            tWin32Err = RegCloseKey(LsaKey);
            LsaKey=NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }

        if ( OldSecurityKey ) {
            tWin32Err = RegCloseKey(OldSecurityKey);
            OldSecurityKey=NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }
    
        if ( phkOldlocation ) {
            tWin32Err = RegCloseKey(phkOldlocation);
            phkOldlocation=NULL;
            if ( tWin32Err != ERROR_SUCCESS ) {
                DsRolepLogPrint(( DEB_ERROR, "RegCloseKey failed with %d\n",
                              tWin32Err ));
            }
        }
        
        if(SystemKeyloaded){
            tWin32Err = RegUnLoadKeyW(
                          HKEY_LOCAL_MACHINE,
                          IFM_SYSTEM_KEY);
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "RegUnLoadKeyW failed with %d\n",
                              tWin32Err ));
            }
        }

        if (SecurityKeyloaded) {
            tWin32Err = RegUnLoadKeyW(
                          HKEY_LOCAL_MACHINE,
                          IFM_SECURITY_KEY);
            if ( tWin32Err != ERROR_SUCCESS) {
                DsRolepLogPrint(( DEB_ERROR, "RegUnLoadKeyW failed with %d\n",
                              tWin32Err ));
            }
        }
    }
    
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                       FALSE,          // Disable
                       FALSE,          // not client; process wide
                       &fWasEnabled );
    ASSERT( NT_SUCCESS( Status ) );

    if ((ERROR_SUCCESS != Win32Err) && *lpDNSDomainName) {

        MIDL_user_free(*lpDNSDomainName);    
        *lpDNSDomainName=NULL;

    }

    return Win32Err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\loadfn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#define NTDSSET_ALLOCATE    // Cause extern allocations to happen here
#include "loadfn.h"
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition

#include "secure.h"


//
// Global data
//
HANDLE NtDsSetupDllHandle = NULL;
HANDLE SceSetupDllHandle = NULL;
HANDLE NtfrsApiDllHandle = NULL;
HANDLE W32TimeDllHandle = NULL;

#define DSROLE_LOAD_FPTR( status, handle, fbase )                   \
if ( status == ERROR_SUCCESS ) {                                    \
                                                                    \
    Dsr##fbase = ( DSR_##fbase)GetProcAddress( handle, #fbase );    \
                                                                    \
    if ( Dsr##fbase == NULL ) {                                     \
                                                                    \
        status = ERROR_PROC_NOT_FOUND;                              \
    }                                                               \
}

DWORD
DsRolepLoadSetupFunctions(
    VOID
    )
/*++

Routine Description:

    This function will load all of the function pointers as utilized from Ntdsetup.dll
    
    N.B.  This routine must be called when the global op handle lock is held.

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HANDLE DllHandle = NULL;

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    if ( NtDsSetupDllHandle == NULL ) {

        DllHandle = LoadLibraryA( "Ntdsetup" );

        if ( DllHandle == NULL ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to load NTDSETUP.DLL\n" ));
            Win32Err = ERROR_MOD_NOT_FOUND;

        } else {

            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstall );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallShutdown );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallUndo );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsGetDefaultDnsName );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsPrepareForDemotion );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsPrepareForDemotionUndo );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsDemote );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsSetReplicaMachineAccount );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallCancel );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsInstallReplicateFull );
            DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtdsFreeDnsRRInfo );

            NtDsSetupDllHandle = DllHandle;
        }

        //
        // Load the ones for secsetup
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            DllHandle = LoadLibraryA( "scecli" );

            if ( DllHandle == NULL ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to load SCECLI.DLL\n" ));
                Win32Err = ERROR_MOD_NOT_FOUND;

            } else {

                DSROLE_LOAD_FPTR( Win32Err, DllHandle, SceDcPromoteSecurityEx );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, SceDcPromoCreateGPOsInSysvolEx );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, SceSetupSystemByInfName );

                SceSetupDllHandle = DllHandle;

            }
        }

        //
        // Load the ones for ntfrsapi
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            DllHandle = LoadLibraryA( "ntfrsapi" );

            if ( DllHandle == NULL ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to load NTFRSAPI.DLL\n" ));
                Win32Err = ERROR_MOD_NOT_FOUND;

            } else {

                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_PrepareForPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_PrepareForDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_PrepareForDemotionUsingCredW  );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_StartPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_StartDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_WaitForPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_WaitForDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_CommitPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_CommitDemotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_AbortPromotionW );
                DSROLE_LOAD_FPTR( Win32Err, DllHandle, NtFrsApi_AbortDemotionW );

                NtfrsApiDllHandle = DllHandle;

            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DllHandle = LoadLibraryA( "w32time" );
            if ( DllHandle == NULL ) {

                DsRolepLogPrint(( DEB_ERROR, "Failed to load W32TIME.DLL\n" ));
                Win32Err = ERROR_MOD_NOT_FOUND;

            } else {

                DSROLE_LOAD_FPTR( Win32Err, DllHandle, W32TimeDcPromo );

                W32TimeDllHandle = DllHandle;

            }
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepUnloadSetupFunctions();
    }

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    return( Win32Err );
}


VOID
DsRolepUnloadSetupFunctions(
    VOID
    )
/*++

Routine Description:

    This function will unload the dll handles loaded by DsRolepLoadSetupFunctions
    
    
    N.B.  This routine must be called when the global op handle lock is held.

Arguments:

    VOID

Returns:

    VOID

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    if ( NtDsSetupDllHandle != NULL ) {

        FreeLibrary( NtDsSetupDllHandle );
        NtDsSetupDllHandle = NULL;

    }

    if ( SceSetupDllHandle != NULL ) {

        FreeLibrary( SceSetupDllHandle );
        SceSetupDllHandle = NULL;

    }

    if ( NtfrsApiDllHandle != NULL ) {

        FreeLibrary( NtfrsApiDllHandle );
        NtfrsApiDllHandle = NULL;
    }

    if ( W32TimeDllHandle != NULL ) {

        FreeLibrary( W32TimeDllHandle );
        W32TimeDllHandle = NULL;
    }

    DsRolepInitSetupFunctions();

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    return;
}


VOID
DsRolepInitSetupFunctions(
    VOID
    )
/*++

Routine Description:

    This function will initialize the setup function pointers to NULL

Arguments:

    VOID

Returns:

    VOID

--*/
{
    DsrNtdsInstall = NULL;
    DsrNtdsInstallShutdown = NULL;
    DsrNtdsInstallUndo = NULL;
    DsrNtdsGetDefaultDnsName = NULL;
    DsrNtdsPrepareForDemotion = NULL;
    DsrNtdsPrepareForDemotionUndo = NULL;
    DsrNtdsDemote = NULL;
    DsrNtdsSetReplicaMachineAccount = NULL;
    DsrNtdsInstallCancel = NULL;
    DsrNtdsFreeDnsRRInfo = NULL;
    DsrSceDcPromoteSecurityEx = NULL;
    DsrSceDcPromoCreateGPOsInSysvolEx = NULL;
    DsrNtFrsApi_PrepareForPromotionW = NULL;
    DsrNtFrsApi_PrepareForDemotionW = NULL;
    DsrNtFrsApi_StartPromotionW = NULL;
    DsrNtFrsApi_StartDemotionW = NULL;
    DsrNtFrsApi_WaitForPromotionW = NULL;
    DsrNtFrsApi_WaitForDemotionW = NULL;
    DsrNtFrsApi_CommitPromotionW = NULL;
    DsrNtFrsApi_CommitDemotionW = NULL;
    DsrNtFrsApi_AbortPromotionW = NULL;
    DsrNtFrsApi_AbortDemotionW = NULL;
    DsrW32TimeDcPromo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\log.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Definitions and globals for internal only debug and support routines

Author:

    Mac McLain      (MacM)       Aug 11, 1997

Environment:

Revision History:

--*/
#ifndef __LOG_H__
#define __LOG_H__

#define DSROLEP_VERBOSE_LOGGING

#ifdef DSROLEP_VERBOSE_LOGGING


#define DEB_TRACE_DS        0x00000008
#define DEB_TRACE_UPDATE    0x00000010
#define DEB_TRACE_LOCK      0x00000020
#define DEB_TRACE_SERVICES  0x00000040
#define DEB_TRACE_NET       0x00000080

//
// exported so it can be init'ed in DsRolepInitialize
//
extern CRITICAL_SECTION LogFileCriticalSection;

DWORD
DsRolepInitializeLog(
    VOID
    );

DWORD
DsRolepSetAndClearLog(
    VOID
    );

DWORD
DsRolepCloseLog(
    VOID
    );

VOID
DsRolepLogPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define DsRolepLogPrint( x )  DsRolepLogPrintRoutine x
#define DsRolepDisplayOptional( y ) y ? y : L"(NULL)"
#define DsRolepLogOnFailure( z, a ) if ( z != ERROR_SUCCESS ) a
#define DsRolepLogGuid( l, t, g )  g == NULL ? DsRolepLogPrint(( l, "%S (NULL)\n", t )) :       \
        DsRolepLogPrint(( l, "%S %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",            \
                        t,(g)->Data1,(g)->Data2,(g)->Data3,(g)->Data4[0],                       \
                        (g)->Data4[1],(g)->Data4[2],(g)->Data4[3],(g)->Data4[4],                \
                        (g)->Data4[5],(g)->Data4[6],(g)->Data4[7]))

#define DsRolepLogSid( l, t, s )                                                                \
{ LPWSTR sidstring;                                                                             \
  ConvertSidToStringSidW( s, &sidstring );                                                      \
  DsRolepLogPrint(( l, "%S %ws\n", t, sidstring ));                                             \
  LocalFree(sidstring);                                                                         \
}

#define DsRolepUnicodestringtowstr( s, u )                                                      \
{ s = (WCHAR*)malloc(u.Length+sizeof(WCHAR));                                                               \
  if (s){                                                                                       \
      CopyMemory(s,u.Buffer,u.Length);                                                          \
      s[u.Length/sizeof(WCHAR)] = L'\0';                                                        \
  }                                                                                             \
}



#else

#define DsRolepInitializeLog()
#define DsRolepCloseLog()
#define DsRolepLogPrint( x )
#define DsRolepDisplayOptional( y )
#define DsRolepLogOnFailure( z, a )
#define DsRolepLogGuid( t, g )
#define DsRolepLogSid( t, s )
#define DsRolepSetAndClearLog()
#define DsRolepUnicodestringtowstr( s, u )
#endif

#endif // __LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\log.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.c

Abstract:

    Implementation of the internal debug and support routines

Author:

    Colin Brace              April 5, 1999

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <loadfn.h>
#include <samrpc.h>
#include <samisrv.h>
#include <nlrepl.h>
#include <lmjoin.h>
#include <netsetp.h>
#include <lmaccess.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>

#define UNICODE_BYTE_ORDER_MARK 0xFEFF

//
// Global handle to the log file
//
HANDLE DsRolepLogFile = NULL;
CRITICAL_SECTION LogFileCriticalSection;

#define LockLogFile()    RtlEnterCriticalSection( &LogFileCriticalSection );
#define UnlockLogFile()  RtlLeaveCriticalSection( &LogFileCriticalSection );

//
// log file name
//
#define DSROLEP_LOGNAME L"\\debug\\DCPROMO.LOG"
#define DSROLEP_BAKNAME L"\\debug\\DCPROMO.BAK"

DWORD
DsRolepInitializeLogHelper(
    IN DWORD TimesCalled
    )
/*++

Routine Description:

    Initializes the debugging log file used by DCPROMO and the dssetup apis
    
    N.B. This will not delete a previous log file; rather it will continue
    to use the same one.

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR LogFileName[ MAX_PATH + 1 ];
    WCHAR bakLogFileName[ MAX_PATH + 1 ];
    WCHAR cBOM = UNICODE_BYTE_ORDER_MARK;
    BOOLEAN fSuccess;

    ASSERT(TimesCalled <= 2 && L"MoveFile failed to move file but reported success.");
    if (TimesCalled > 2) {
        DsRoleDebugOut(( DEB_ERROR,
                         "MoveFile failed to move file but reported success.\n",
                         dwErr ));
        return ERROR_GEN_FAILURE;
    }

    LockLogFile();

    //
    // Construct the log file name
    //
    if ( !GetWindowsDirectoryW( LogFileName,
                                sizeof( LogFileName )/sizeof( WCHAR ) ) ) {

        dwErr = GetLastError();
        DsRoleDebugOut(( DEB_ERROR,
                         "GetWindowsDirectory failed with %lu\n",
                         dwErr ));
        goto Exit;
    }
    wcscat( LogFileName, DSROLEP_LOGNAME );
    DsRoleDebugOut(( DEB_TRACE,
                     "Logfile name: %ws\n",
                     LogFileName ));

    //
    // Open the file
    //
    DsRolepLogFile = CreateFileW( LogFileName,
                                  GENERIC_WRITE | GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

    if ( DsRolepLogFile == INVALID_HANDLE_VALUE ) {

        dwErr = GetLastError();

        DsRoleDebugOut(( DEB_ERROR,
                         "CreateFile on %ws failed with %lu\n",
                         LogFileName,
                         dwErr ));
        DsRolepLogFile = NULL;
        goto Exit;
    }

    if ( ERROR_ALREADY_EXISTS != GetLastError() ) {
        //This is a unicode file so if it was just
        //created the Byte-order Mark needs to be
        //added to the beginning of the file.

        DWORD lpNumberOfBytesWritten = 0;

        if ( !WriteFile(DsRolepLogFile,
                        (LPCVOID)&cBOM,
                        sizeof(WCHAR), 
                        &lpNumberOfBytesWritten,
                        NULL) )
        {
            dwErr = GetLastError();
            DsRoleDebugOut(( DEB_ERROR,
                         "WriteFile on %ws failed with %lu\n",
                         LogFileName,
                         dwErr ));
            goto Exit;
        }

        ASSERT(lpNumberOfBytesWritten == sizeof(WCHAR));

    } else {
        //See if the opened file is UNICODE
        //if not move it and create a new file.
        WCHAR wcBuffer = 0;
        DWORD lpNumberOfBytesRead = 0;

        if ( !ReadFile(DsRolepLogFile,
                       (LPVOID)&wcBuffer,
                       sizeof(WCHAR),
                       &lpNumberOfBytesRead,
                       NULL) ) 
        {
            dwErr = GetLastError();
            DsRoleDebugOut(( DEB_ERROR,
                         "ReadFile on %ws failed with %lu\n",
                         LogFileName,
                         dwErr ));
            goto Exit;    
        }

        ASSERT(lpNumberOfBytesRead == sizeof(WCHAR));

        if (cBOM != wcBuffer) {
            //This is not a UNICODE FILE Move it.
            //Create a New Dcpromo Log

            //
            // Construct the bak log file name
            //
            if ( !GetWindowsDirectoryW( bakLogFileName,
                                        sizeof( bakLogFileName )/sizeof( WCHAR ) ) ) {
        
                dwErr = GetLastError();
                DsRoleDebugOut(( DEB_ERROR,
                                 "GetWindowsDirectory failed with %lu\n",
                                 dwErr ));
                goto Exit;
            }
            wcscat( bakLogFileName, DSROLEP_BAKNAME );
            DsRoleDebugOut(( DEB_TRACE,
                             "Logfile name: %ws\n",
                             bakLogFileName ));

            if ( DsRolepLogFile ) {
        
                 CloseHandle( DsRolepLogFile );
                 DsRolepLogFile = NULL;
                
            }

            //move the file
            if ( !MoveFile(LogFileName,                           
                           bakLogFileName) )
            {
                 dwErr = GetLastError();
                 DsRoleDebugOut(( DEB_ERROR,
                                  "MoveFile From %ws to %ws failed with %lu\n",
                                  LogFileName,
                                  bakLogFileName,
                                  dwErr ));
                 goto Exit;
            }

            UnlockLogFile();

            return DsRolepInitializeLogHelper(TimesCalled+1);
        
        }


    }

    //No longer need read access so reopen the file
    //with just write access.

    if ( DsRolepLogFile ) {
        
         CloseHandle( DsRolepLogFile );
         DsRolepLogFile = NULL;
        
    }

    DsRolepLogFile = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

    //
    // Goto to the end of the file
    //
    if( SetFilePointer( DsRolepLogFile,
                        0, 0,
                        FILE_END ) == 0xFFFFFFFF ) {

        dwErr = GetLastError();
        DsRoleDebugOut(( DEB_ERROR,
                         "SetFilePointer failed with %lu\n",
                         dwErr ));
        goto Exit;
    }

    //
    // That's it
    //
    ASSERT( ERROR_SUCCESS == dwErr );

Exit:

    if ( (ERROR_SUCCESS != dwErr)
      && (NULL != DsRolepLogFile)   ) {

        CloseHandle( DsRolepLogFile );
        DsRolepLogFile = NULL;
        
    }

    UnlockLogFile();

    return( dwErr );
}

DWORD
DsRolepInitializeLog(
    VOID
    )
/*++

Routine Description:

    Initializes the debugging log file used by DCPROMO and the dssetup apis
    
    N.B. This will not delete a previous log file; rather it will continue
    to use the same one.

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{

    //caller the helper function for the first time.
    return DsRolepInitializeLogHelper(1);

}



DWORD
DsRolepCloseLog(
    VOID
    )
/*++

Routine Description:

    Closes the debugging log file used by DCPROMO and the dssetup apis

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    LockLogFile();

    if ( DsRolepLogFile != NULL ) {

        CloseHandle( DsRolepLogFile );
        DsRolepLogFile = NULL;
    }

    UnlockLogFile();

    return( dwErr );
}



//
// Stolen and hacked up from netlogon code
//

VOID
DsRolepDebugDumpRoutine(
    IN DWORD DebugFlag,
    IN LPWSTR Format,
    va_list arglist
    )

{
    #define DsRolepDebugDumpRoutine_BUFFERSIZE 1024

    WCHAR OutputBuffer[DsRolepDebugDumpRoutine_BUFFERSIZE];
    ULONG length;
    DWORD BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;

    //
    // If we don't have an open log file, just bail
    //
    if ( DsRolepLogFile == NULL ) {

        return;
    }

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        CHAR  *Prolog;

        if ( FLAG_ON( DebugFlag, DEB_ERROR ) ) {
            Prolog = "[ERROR] ";
        } else if ( FLAG_ON( DebugFlag, DEB_WARN ) ) {
            Prolog = "[WARNING] ";
        } else if (  FLAG_ON( DebugFlag, DEB_TRACE ) 
                  || FLAG_ON( DebugFlag, DEB_TRACE_DS ) ) {
            Prolog = "[INFO] ";
        } else {
            Prolog = "";
        }

        //
        // Put the timestamp at the begining of the line.
        //
        GetLocalTime( &SystemTime );
        length += (ULONG) wsprintfW( &OutputBuffer[length],
                                     L"%02u/%02u %02u:%02u:%02u %S",
                                     SystemTime.wMonth,
                                     SystemTime.wDay,
                                     SystemTime.wHour,
                                     SystemTime.wMinute,
                                     SystemTime.wSecond,
                                     Prolog );
    }

    //
    // Put a the information requested by the caller onto the line
    //
    length += (ULONG) wvsprintfW(&OutputBuffer[length],
                                 Format, 
                                 arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == L'\n' );
    if ( BeginningOfLine ) {

        OutputBuffer[length-1] = L'\r';
        OutputBuffer[length] = L'\n';
        OutputBuffer[length+1] = L'\0';
        length++;
    }

    ASSERT( length <= sizeof( OutputBuffer ) / sizeof( WCHAR ) );

    //
    // Grab the lock
    //
    LockLogFile();

    //
    // Write the debug info to the log file.
    //
    if ( !WriteFile( DsRolepLogFile,
                     OutputBuffer,
                     length*sizeof(WCHAR),
                     &BytesWritten,
                     NULL ) ) {

        DsRoleDebugOut(( DEB_ERROR,
                         "Log write of %ws failed with %lu\n",
                         OutputBuffer,
                         GetLastError() ));
    }

    DsRoleDebugOut(( DebugFlag,
                     "%ws",
                     OutputBuffer ));



    //
    // Release the lock
    //
    UnlockLogFile();

    return;

}

VOID
DsRolepLogPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    PWCHAR WFormat = NULL;
    va_list arglist;
    DWORD WinErr = ERROR_SUCCESS;
    DWORD Bufsize = strlen(Format)+1;

    WFormat = (PWCHAR)malloc(Bufsize*sizeof(WCHAR));
    if ( WFormat ) {
        MultiByteToWideChar(CP_ACP,
                            0,
                            Format,
                            -1,
                            WFormat,
                            Bufsize
                            );
    } else {
        DsRoleDebugOut(( DEB_ERROR,
                         "Log write failed with %lu\n",
                         ERROR_NOT_ENOUGH_MEMORY ));
    }

    va_start(arglist, Format);

    if ( WFormat ) {
        DsRolepDebugDumpRoutine( DebugFlag, WFormat, arglist );
    }
    
    va_end(arglist);

    if (WFormat) {
        free(WFormat);
    }
}

DWORD
DsRolepSetAndClearLog(
    VOID
    )
/*++

Routine Description:

    Flushes the log and seeks to the end of the file

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    LockLogFile();

    if ( DsRolepLogFile != NULL ) {

        if( SetFilePointer( DsRolepLogFile,
                            0, 0,
                            FILE_END ) == 0xFFFFFFFF ) {

            dwErr = GetLastError();
        }

        if( FlushFileBuffers( DsRolepLogFile ) == FALSE ) {

            dwErr = GetLastError();
        }
    }

    UnlockLogFile();

    return( dwErr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\lsa.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __LSA_H__
#define __LSA_H__

#include <lsarpc.h>
#include <lsaisrv.h>

typedef struct {

    BOOLEAN PolicyBackedUp;
    BOOLEAN EfsPolicyPresent;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    PPOLICY_DNS_DOMAIN_INFO      DnsDomainInfo;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    PPOLICY_DOMAIN_EFS_INFO EfsPolicy;

} DSROLEP_DOMAIN_POLICY_INFO, *PDSROLEP_DOMAIN_POLICY_INFO;

DWORD
DsRolepSetLsaDnsInformationNoParent(
    IN  LPWSTR DnsDomainName
    );

DWORD
DsRolepSetLsaInformationForReplica(
    IN HANDLE CallerToken,
    IN LPWSTR ReplicaPartner,
    IN LPWSTR Account,
    IN LPWSTR Password
    );

DWORD
DsRolepSetLsaDomainPolicyInfo(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR EnterpriseDnsName,
    IN GUID *DomainGuid,
    IN PSID DomainSid,
    DWORD  InstallOptions,
    OUT PDSROLEP_DOMAIN_POLICY_INFO DomainPolicyInfo
    );


DWORD
DsRolepBackupDomainPolicyInfo(
    IN PLSA_HANDLE LsaHandle, OPTIONAL
    OUT PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    );

DWORD
DsRolepRestoreDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainPolicyInfo
    );

DWORD
DsRolepFreeDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainPolicyInfo
    );

DWORD
DsRolepUpgradeLsaToDs(
    BOOLEAN InitializeLsa
    );

VOID
DsRolepFindSelfAndParentInForest(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo,
    OUT PLSAPR_TREE_TRUST_INFO CurrentEntry,
    IN PUNICODE_STRING LocalDomain,
    OUT PLSAPR_TREE_TRUST_INFO *ParentEntry,
    OUT PLSAPR_TREE_TRUST_INFO *OwnEntry
    );

#endif // __LSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\ophandle.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ophandle.c

Abstract:

    Routines to manipulate the global operation handle            

Author:

    Colin Brace        (ColinBr)     April 5, 1999

Environment:

    User Mode

Revision History:

    Reorganized from
    
    Mac McLain          (MacM)       Feb 10, 1997

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <spmgr.h>  // For SetupPhase definition

#include "secure.h"
#include "ophandle.h"

//
// Global data -- init'ed to an idle state in DsRoleInitialize
//
DSROLEP_OPERATION_HANDLE   DsRolepCurrentOperationHandle;

DWORD
DsRolepInitializeOperationHandle(
    VOID
    )
/*++

Routine Description:

    Does the initialization of the operation handle.  The operation handle controls state
    and actions of the ds setup apis

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES EventAttr;
    UNICODE_STRING EventName;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    if ( DSROLEP_IDLE != DsRolepCurrentOperationHandle.OperationState ) {

        //
        // Not idle?  Bail
        //
        Win32Err = ERROR_PROMOTION_ACTIVE;

    } else {

        Win32Err = DsRolepGetImpersonationToken(&DsRolepCurrentOperationHandle.ClientToken);
        if (ERROR_SUCCESS != Win32Err) {
            DsRolepCurrentOperationHandle.ClientToken=NULL;
            DsRolepLogPrintRoutine(DEB_WARN, "Cannot get user Token for Format Message: %ul\n",
                                   Win32Err);
            Win32Err = ERROR_SUCCESS;
            //if Error log and continue
        }

        //
        // We are idle, and hence ready to perform a role change
        //
        RtlInitUnicodeString(&EventName, DSROLEP_EVENT_NAME);

        InitializeObjectAttributes(&EventAttr, &EventName, 0, NULL, NULL);

        Status = NtCreateEvent( &DsRolepCurrentOperationHandle.CompletionEvent,
                                EVENT_ALL_ACCESS,
                                &EventAttr,
                                NotificationEvent,
                                FALSE);
        if (Status == STATUS_OBJECT_NAME_COLLISION ) {

            //
            // If the event exists but the operation active flag is clear, we'll
            // go ahead and use the event
            //
            Status = NtResetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );
        }


        if ( NT_SUCCESS( Status ) ) {

            //
            // Create the cancel event
            //
            Status = NtCreateEvent( &DsRolepCurrentOperationHandle.CancelEvent,
                                    EVENT_MODIFY_STATE | SYNCHRONIZE ,
                                    NULL,
                                    NotificationEvent,
                                    FALSE );

            if ( NT_SUCCESS( Status ) ) {

                //
                // We are ready to roll!
                //

                DsRolepCurrentOperationHandle.OperationState = DSROLEP_RUNNING;

                //
                // Set the initial message
                //
                DsRolepCurrentOperationHandle.MsgIndex = DSROLERES_STARTING;
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Load the functions we'll need
            //
            Win32Err = DsRolepLoadSetupFunctions();

        }

    }


    //
    // Release the lock
    //
    UnlockOpHandle();

    if ( ERROR_SUCCESS != Win32Err
       || !NT_SUCCESS( Status ) ) {

        if ( ERROR_SUCCESS == Win32Err ) {

            Win32Err = RtlNtStatusToDosError( Status );

        }

        DsRolepLogPrint(( DEB_ERROR, "Internal error trying to initialize operation handle (%lu).\n", Win32Err ));

        //
        // Reset the handle state
        //
        DsRolepResetOperationHandle( DSROLEP_IDLE );
    }

    return( Win32Err );
}



DWORD
DsRolepResetOperationHandle(
    DSROLEP_OPERATION_STATE OpState
    )
/*++

Routine Description:

    Resets the operation handle following a failed or successful completion 
    of the operation

Arguments:

    VOID

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES EventAttr;
    UNICODE_STRING EventName;
    NTSTATUS Status = STATUS_SUCCESS;

    // These are the only two states that make sense
    ASSERT( (OpState == DSROLEP_IDLE) || (OpState == DSROLEP_NEED_REBOOT) );

    //
    // Lock the operation handle
    //
    LockOpHandle();

    // It should always be active
    ASSERT( DSROLEP_OPERATION_ACTIVE( DsRolepCurrentOperationHandle.OperationState) );
    if ( DSROLEP_OPERATION_ACTIVE( DsRolepCurrentOperationHandle.OperationState) )
    {
        if(DsRolepCurrentOperationHandle.ClientToken){
            CloseHandle(DsRolepCurrentOperationHandle.ClientToken);
            DsRolepCurrentOperationHandle.ClientToken = NULL;
        }
        //
        // Release the resource of the operation handle
        //
        if ( DsRolepCurrentOperationHandle.CompletionEvent ) {

            Status = NtClose( DsRolepCurrentOperationHandle.CompletionEvent );
            DsRolepCurrentOperationHandle.CompletionEvent = NULL;

            if ( !NT_SUCCESS( Status ) ) {

                DsRoleDebugOut(( DEB_TRACE_DS,
                                 "Failed to close event handle: 0x%lx\n", Status ));
            }
        }

        if ( DsRolepCurrentOperationHandle.CancelEvent ) {

            Status = NtClose( DsRolepCurrentOperationHandle.CancelEvent );
            DsRolepCurrentOperationHandle.CancelEvent = NULL;

            if ( !NT_SUCCESS( Status ) ) {

                DsRoleDebugOut(( DEB_TRACE_DS,
                                 "Failed to close event handle: 0x%lx\n", Status ));
            }
        }

        if ( DsRolepCurrentOperationHandle.OperationThread != NULL ) {

            CloseHandle( DsRolepCurrentOperationHandle.OperationThread );
            DsRolepCurrentOperationHandle.OperationThread = NULL;
        }

        //
        // Unload the global functions
        //
        DsRolepUnloadSetupFunctions();

        //
        // Clear the static variables
        //
        DsRolepResetOperationHandleLockHeld();

        //
        // Reset the operation state
        //
        DsRolepCurrentOperationHandle.OperationState = OpState;
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    if ( !NT_SUCCESS( Status ) ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }

    return( Win32Err );

}


VOID
DsRolepResetOperationHandleLockHeld(
    VOID
    )
/*++

Routine Description:

    Resets the operation handle following a failed or successful completion of the operation

Arguments:

    VOID

Returns:

    VOID

--*/
{

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    if ( DsRolepCurrentOperationHandle.Parameter1 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter1 );
        DsRolepCurrentOperationHandle.Parameter1 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter2 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter2 );
        DsRolepCurrentOperationHandle.Parameter2 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter3 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter3 );
        DsRolepCurrentOperationHandle.Parameter3 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter4 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter4 );
        DsRolepCurrentOperationHandle.Parameter4 = NULL;
    }

    DsRolepCurrentOperationHandle.CompletionEvent = NULL;
    DsRolepCurrentOperationHandle.OperationState = DSROLEP_IDLE;
    DsRolepCurrentOperationHandle.OperationStatus = 0;
    DsRolepCurrentOperationHandle.MsgIndex = 0;
    DsRolepCurrentOperationHandle.DisplayStringCount = 0;
    DsRolepCurrentOperationHandle.MsgModuleHandle = NULL;
    DsRolepCurrentOperationHandle.UpdateStringDisplayable = NULL;
    DsRolepCurrentOperationHandle.FinalResultStringDisplayable = NULL;
    DsRolepCurrentOperationHandle.InstalledSiteName = NULL;
    DsRolepCurrentOperationHandle.OperationResultFlags = 0;

    ASSERT( DsRolepCurrentThreadOwnsLock() );

    return;

}

DWORD
DsRolepSetCurrentOperationStatus(
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    )
/*++

Routine Description:

    Internal routine for updating the current operation handle statics

Arguments:

    MsgIndex - Display message resource index

    Parameter1 - First display parameter

    Parameter2 - Second display parameter

    Parameter3 - Third display parameter

    Parameter4 - Fourth display parameter


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Size;

    ASSERT( MsgIndex != 0 );

    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.MsgIndex = MsgIndex;

    //
    // Release previously held parameters
    //
    if ( DsRolepCurrentOperationHandle.Parameter1 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter1 );
        DsRolepCurrentOperationHandle.Parameter1 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter2 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter2 );
        DsRolepCurrentOperationHandle.Parameter2 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter3 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter3 );
        DsRolepCurrentOperationHandle.Parameter3 = NULL;
    }
    if ( DsRolepCurrentOperationHandle.Parameter4 ) {
        LocalFree( DsRolepCurrentOperationHandle.Parameter4 );
        DsRolepCurrentOperationHandle.Parameter4 = NULL;
    }

    //
    // Copy the new ones in
    //
    if ( Parameter1 ) {
        Size = (wcslen( Parameter1 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter1 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter1 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter1, Parameter1  );
    }

    if ( Parameter2 ) {
        Size = (wcslen( Parameter2 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter2 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter2 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter2, Parameter2 );
    }

    if ( Parameter3 ) {
        Size = (wcslen( Parameter3 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter3 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter3 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter3, Parameter3 );
    }

    if ( Parameter4 ) {
        Size = (wcslen( Parameter4 ) + 1) * sizeof(WCHAR);
        DsRolepCurrentOperationHandle.Parameter4 = LocalAlloc( 0, Size );
        if ( !DsRolepCurrentOperationHandle.Parameter4 ) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto ReleaseLock;
        }
        wcscpy( DsRolepCurrentOperationHandle.Parameter4, Parameter4 );
    }

    {
        PWSTR DisplayString;
        DWORD E2;
        E2 = DsRolepFormatOperationString(
                           DsRolepCurrentOperationHandle.MsgIndex,
                           &DisplayString,
                           DsRolepCurrentOperationHandle.Parameter1,
                           DsRolepCurrentOperationHandle.Parameter2,
                           DsRolepCurrentOperationHandle.Parameter3,
                           DsRolepCurrentOperationHandle.Parameter4 );

        if ( E2 == ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE, "%ws", DisplayString ));
            MIDL_user_free( DisplayString );
        }
    }

ReleaseLock:

    //
    // Don't forget to release the lock
    //
    UnlockOpHandle();


    return( Win32Err );
}



DWORD
DsRolepSetFailureMessage(
    IN DWORD FailureStatus,
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    )
/*++

Routine Description:

    Internal routine for updating the failure return string

Arguments:

    FailureStatus - Error code for the failure

    MsgIndex - Display message resource index

    Parameter1 - First display parameter

    Parameter2 - Second display parameter

    Parameter3 - Third display parameter

    Parameter4 - Fourth display parameter


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR DisplayString = NULL;

    ASSERT( MsgIndex != 0 );

    Win32Err = DsRolepFormatOperationString( MsgIndex,
                                             &DisplayString,
                                             Parameter1,
                                             Parameter2,
                                             Parameter3,
                                             Parameter4 );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepStringErrorUpdateCallback( DisplayString, FailureStatus );

        MIDL_user_free( DisplayString );
    }

    return( Win32Err );
}



DWORD
DsRolepSetOperationDone(
    IN DWORD Flags,
    IN DWORD OperationStatus
    )
/*++

Routine Description:

    Indicates that the requested operation has completed

Arguments:

    Flags -- currently : DSROLEP_OP_DEMOTION
                         DSROLEP_OP_PROMOTION
                                             
    OperationStatus - Final status of the requsted operation

Returns:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    DSROLEP_CURRENT_OP0( DSROLEEVT_PROMOTION_COMPLETE );
    DsRolepCurrentOperationHandle.OperationState = DSROLEP_FINISHED;

    if ( DsRolepCurrentOperationHandle.OperationStatus == 0 
     ||  (OperationStatus == ERROR_CANCELLED) ) {

        DsRolepCurrentOperationHandle.OperationStatus = OperationStatus;
    }

    if ( ERROR_SUCCESS == DsRolepCurrentOperationHandle.OperationStatus ) {

        //
        // Log an event indicating the role has changed
        //
        DWORD MsgId = 0;
        if ( Flags & DSROLEP_OP_DEMOTION ) {

            MsgId = DSROLERES_DEMOTE_SUCCESS;
            
        } else if ( Flags & DSROLEP_OP_PROMOTION ) {

            MsgId = DSROLERES_PROMOTE_SUCCESS;
            
        } else {

            ASSERT( FALSE && !"Bad Parameter" );

        }

        SpmpReportEvent( TRUE,
                         EVENTLOG_INFORMATION_TYPE,
                         MsgId,
                         0,
                         0,
                         NULL,
                         0 );
    }

    //
    // If the operation was cancelled, give the same error message every
    // time
    //
    if ( ERROR_CANCELLED == DsRolepCurrentOperationHandle.OperationStatus ) {

        (VOID) DsRolepSetFailureMessage( ERROR_CANCELLED,
                                         DSROLERES_OP_CANCELLED,
                                         NULL, NULL, NULL, NULL );
    }

    //
    // Signal the completion event
    //
    Status = NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    DsRoleDebugOut(( DEB_TRACE_DS, "DsRolepSetOperationDone[ %lu ]\n",
                      OperationStatus ));


    //
    // Release the lock
    //
    UnlockOpHandle();

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepSetOperationDone returned %lu\n",
                       RtlNtStatusToDosError( Status ) ));


    return( RtlNtStatusToDosError( Status ) );
}


DWORD
DsRolepGetDcOperationProgress(
    IN PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    IN OUT PDSROLER_SERVEROP_STATUS *ServerOperationStatus
    )
/*++

Routine Description:

    Implementation of the RPC server for determining the current level of progress of an
    operation

Arguments:

    DsOperationHandle - Handle to an open operation

    ServerOperationStatus - Where the status is returned.

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    //
    // Allocate the return structure
    //
    *ServerOperationStatus = MIDL_user_allocate( sizeof( DSROLER_SERVEROP_STATUS ) );

    if ( *ServerOperationStatus == NULL )  {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // Build the return string
        //
        if ( DsRolepCurrentOperationHandle.MsgIndex == 0  ) {

            ( *ServerOperationStatus )->CurrentOperationDisplayString = MIDL_user_allocate(
                ( wcslen( DsRolepCurrentOperationHandle.UpdateStringDisplayable ) + 1 ) *
                                                                            sizeof( WCHAR ) );


            if ( ( *ServerOperationStatus )->CurrentOperationDisplayString == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                wcscpy( ( *ServerOperationStatus )->CurrentOperationDisplayString,
                        DsRolepCurrentOperationHandle.UpdateStringDisplayable );

                //
                // Set the status flags if they exist
                //
                if ( DsRolepCurrentOperationHandle.OperationState == DSROLEP_RUNNING_NON_CRITICAL ) {

                    ( *ServerOperationStatus )->OperationStatus =
                                                        DSROLE_CRITICAL_OPERATIONS_COMPLETED;
                } else {

                    ( *ServerOperationStatus )->OperationStatus = 0;

                }

                ( *ServerOperationStatus )->CurrentOperationDisplayStringIndex =
                            DsRolepCurrentOperationHandle.DisplayStringCount == 0 ? 0 :
                                    DsRolepCurrentOperationHandle.DisplayStringCount - 1;
            }

        } else {

            Win32Err = DsRolepFormatOperationString(
                           DsRolepCurrentOperationHandle.MsgIndex,
                           &( *ServerOperationStatus )->CurrentOperationDisplayString,
                           DsRolepCurrentOperationHandle.Parameter1,
                           DsRolepCurrentOperationHandle.Parameter2,
                           DsRolepCurrentOperationHandle.Parameter3,
                           DsRolepCurrentOperationHandle.Parameter4 );
        }

        if ( Win32Err != ERROR_SUCCESS ) {

            MIDL_user_free( *ServerOperationStatus );
            *ServerOperationStatus = NULL;
        }
    }

    //
    // If the operation isn't completed, return that information to the caller
    //
    if ( Win32Err == ERROR_SUCCESS &&
         DsRolepCurrentOperationHandle.OperationState != DSROLEP_FINISHED ) {

        Win32Err = ERROR_IO_PENDING;
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    return( Win32Err );
}



DWORD
DsRolepFormatOperationString(
    IN ULONG MsgId,
    OUT LPWSTR *FormattedString,
    ...
    )
/*++

Routine Description:

    Allocates and formats the buffer string to be returned

Arguments:

    MsgId - Which message id to format

    FormattedString - Where the string is allocated.  Allocation uses MIDL_user_allocate

    ... - va_list of arguments for the formatted string

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR MsgBuffer[ 512 + 1];
    PWSTR Msg = MsgBuffer;
    ULONG MsgLength = (sizeof(MsgBuffer) / sizeof(MsgBuffer[0]) ) - 1;
    ULONG Length;
    BOOL  fSuccess = FALSE;
    va_list ArgList;

    va_start( ArgList, FormattedString );

    //
    // Load the module handle for lsasrv.dll, so we can get our messages
    //
    if ( DsRolepCurrentOperationHandle.MsgModuleHandle == NULL ) {

        DsRolepCurrentOperationHandle.MsgModuleHandle = GetModuleHandle( L"LSASRV" );

        ASSERT( DsRolepCurrentOperationHandle.MsgModuleHandle );

        if ( DsRolepCurrentOperationHandle.MsgModuleHandle == NULL ) {

            return( GetLastError() );
        }
    }


    //
    // Get the required buffer size
    //

    //
    // FormatMessage complains when given a NULL input buffer, so we'll pass in one, even though
    // it won't be used because of the size being 0.
    //
    fSuccess = ImpersonateLoggedOnUser(DsRolepCurrentOperationHandle.ClientToken);
    // if we couldn't impersonate we continue anyway.
    if (!fSuccess) {
        DsRolepLogPrintRoutine(DEB_WARN, "Cannot get user locale for Format Message: %ul\n",
                               GetLastError());
    }

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                            DsRolepCurrentOperationHandle.MsgModuleHandle,
                            MsgId, 0, Msg, MsgLength, &ArgList );

    if ( Length == 0 ) {

        Win32Err = GetLastError();

        ASSERT( Win32Err != ERROR_MR_MID_NOT_FOUND );

        if ( Win32Err == ERROR_INSUFFICIENT_BUFFER ) {

            Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    DsRolepCurrentOperationHandle.MsgModuleHandle,
                                    MsgId, 0, ( PWSTR )&Msg, 0, &ArgList );
            if ( Length == 0 ) {

                Win32Err = GetLastError();

            } else {

                Win32Err = ERROR_SUCCESS;
            }

        }

    }

    if (fSuccess) {
        fSuccess = RevertToSelf();
        if (!fSuccess) {
            DsRolepLogPrintRoutine(DEB_WARN, "Cannot reset to system security setting: %ul\n",
                                   GetLastError());
        }
    }

    if( Win32Err == ERROR_SUCCESS ) {

        //
        // Allocate a buffer
        //
        Length = ( wcslen( Msg ) + 1 ) * sizeof( WCHAR );
        *FormattedString = MIDL_user_allocate( Length );

        if ( *FormattedString == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            RtlCopyMemory( *FormattedString, Msg, Length );

        }
    }

    if ( Msg != MsgBuffer ) {

        LocalFree( Msg );
    }

    return( Win32Err );
}


VOID
DsRolepSetCriticalOperationsDone(
    VOID
    )
/*++

Routine Description:

    Indicates to our current operation status block that the critical portion of the install
    has been completed...


Arguments:

    VOID

Returns:

    VOID

--*/
{
    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.OperationState = DSROLEP_RUNNING_NON_CRITICAL;

    //
    // Release the lock
    //
    UnlockOpHandle();

    return;
}



VOID
DsRolepIncrementDisplayStringCount(
    VOID
    )
/*++

Routine Description:

    Increments the count of the successfully started display update strings.  This is always
    the index into the list of DisplayStrings PLUS ONE.


Arguments:

    VOID

Returns:

    VOID

--*/
{
    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.DisplayStringCount++;

    //
    // Release the lock
    //
    UnlockOpHandle();

    return;
}



DWORD
DsRolepGetDcOperationResults(
    IN  PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLER_SERVEROP_RESULTS *ServerOperationResults
    )
/*++

Routine Description:

    Gets the results of the final operation.  If the operation has not yet completed, this
    function will block until it does

Arguments:

    DsOperationHandle - Handle to an open operation

    ServerOperationResults - Where the result is returned.

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    DSROLEP_OPERATION_STATE  OpState;
    BOOLEAN fNeedReboot = FALSE;


    //
    // Parameter checking
    //
    if ( !ServerOperationResults ) {

        return ERROR_INVALID_PARAMETER;
        
    }

    //
    // Make sure an operation is active
    //
    LockOpHandle();

    OpState = DsRolepCurrentOperationHandle.OperationState;

    UnlockOpHandle();

    //
    // It's an error if the operation isn't active
    //
    if ( !DSROLEP_OPERATION_ACTIVE( OpState ) ) {

        return ERROR_NO_PROMOTION_ACTIVE;

    }

    //
    // Wait for the operation to complete
    //
    Status = NtWaitForSingleObject( DsRolepCurrentOperationHandle.CompletionEvent, TRUE, NULL );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Lock the handle
        //
        LockOpHandle();

        //
        // Allocate the return structure
        //
        *ServerOperationResults = MIDL_user_allocate( sizeof( DSROLER_SERVEROP_RESULTS ) );

        if ( *ServerOperationResults == NULL )  {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            ( *ServerOperationResults )->OperationResultsFlags = 0;

            //
            // Build the return string
            //
            if ( DsRolepCurrentOperationHandle.OperationStatus != ERROR_SUCCESS ||
                 DsRolepCurrentOperationHandle.MsgIndex == 0  ) {

                DSROLEP_MIDL_ALLOC_AND_COPY_STRING_ERROR(
                    ( *ServerOperationResults )->OperationStatusDisplayString,
                    DsRolepCurrentOperationHandle.OperationStatus != ERROR_SUCCESS ?
                            DsRolepCurrentOperationHandle.FinalResultStringDisplayable :
                            DsRolepCurrentOperationHandle.UpdateStringDisplayable,
                    Win32Err );

            } else {

                Win32Err = DsRolepFormatOperationString(
                               DsRolepCurrentOperationHandle.MsgIndex,
                               &( *ServerOperationResults )->OperationStatusDisplayString,
                               DsRolepCurrentOperationHandle.Parameter1,
                               DsRolepCurrentOperationHandle.Parameter2,
                               DsRolepCurrentOperationHandle.Parameter3,
                               DsRolepCurrentOperationHandle.Parameter4 );
            }


            if ( Win32Err == ERROR_SUCCESS ) {

                ( *ServerOperationResults )->OperationStatus =
                                            DsRolepCurrentOperationHandle.OperationStatus;
                DsRoleDebugOut(( DEB_TRACE_DS,
                                 "Returning status %lu\n",
                                 DsRolepCurrentOperationHandle.OperationStatus ));

                // If the operation finished successfully, we need
                // a reboot
                if ( ERROR_SUCCESS == DsRolepCurrentOperationHandle.OperationStatus )
                {    
                    fNeedReboot = TRUE;
                }
            }

            //
            // Return the site name, if it exists
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                DSROLEP_MIDL_ALLOC_AND_COPY_STRING_ERROR(
                    ( *ServerOperationResults)->ServerInstalledSite,
                    DsRolepCurrentOperationHandle.InstalledSiteName,
                    Win32Err );

                if ( Win32Err != ERROR_SUCCESS ) {

                    MIDL_user_free(
                             ( *ServerOperationResults )->OperationStatusDisplayString );
                }
            }

            //
            // Set the flags, if necessary
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                    ( *ServerOperationResults )->OperationResultsFlags |=
                        DsRolepCurrentOperationHandle.OperationResultFlags;
            }

            if ( Win32Err != ERROR_SUCCESS ) {

                MIDL_user_free( *ServerOperationResults );
                *ServerOperationResults = NULL;
            }


            UnlockOpHandle();

            //
            // Reset our current operation handle
            //
            DsRolepResetOperationHandle( fNeedReboot ? DSROLEP_NEED_REBOOT : DSROLEP_IDLE );


        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }


    return( Win32Err );
}

DWORD
DsRolepOperationResultFlagsCallBack(
    IN DWORD Flags
    )
/*++

Routine Description:

    Internal routine for updating the Operation Results Flags

Arguments:

    Flags - DWORD of flags to | with current flags


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    LockOpHandle();

    DsRolepCurrentOperationHandle.OperationResultFlags |= Flags;

    UnlockOpHandle();

    return( Win32Err );
}

DWORD
DsRolepStringUpdateCallback(
    IN  PWSTR StringUpdate
    )
/*++

Routine Description:

    Internal routine for updating the current operation handle statics

Arguments:

    StringUpdate - Displayables string to set in place of the current parameters


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG len;

    //
    // Grab the lock
    //
    LockOpHandle();

    DsRolepCurrentOperationHandle.MsgIndex   = 0;
    DsRolepCurrentOperationHandle.Parameter1 = 0;
    DsRolepCurrentOperationHandle.Parameter2 = 0;
    DsRolepCurrentOperationHandle.Parameter3 = 0;
    DsRolepCurrentOperationHandle.Parameter4 = 0;

    if ( StringUpdate ) {

        DsRolepLogPrint(( DEB_TRACE, "%ws\n", StringUpdate ));

    }

    DsRoleDebugOut(( DEB_TRACE_UPDATE,
                     "DsRolepSetCurrentOperationStatus for string %ws\n",
                     StringUpdate ));

    if ( DsRolepCurrentOperationHandle.UpdateStringDisplayable ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DsRolepCurrentOperationHandle.UpdateStringDisplayable );
        
    }

    DsRolepCurrentOperationHandle.UpdateStringDisplayable =
        RtlAllocateHeap( RtlProcessHeap(), 0,
                         ( wcslen( StringUpdate ) + 1 ) * sizeof( WCHAR ) );

    if ( DsRolepCurrentOperationHandle.UpdateStringDisplayable == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        wcscpy( DsRolepCurrentOperationHandle.UpdateStringDisplayable, StringUpdate );

    }

    //
    // Don't forget to release the lock
    //
    UnlockOpHandle();

    return( Win32Err );
}



DWORD
DsRolepStringErrorUpdateCallback(
    IN PWSTR String,
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    Internal routine for updating the last failure operation

Arguments:

    String - Displayable error string

    ErrorCode - Error code associated with this failure

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // Grab the lock
    //
    LockOpHandle();

    if ( (ERROR_SUCCESS == DsRolepCurrentOperationHandle.OperationStatus) 
      || (ERROR_CANCELLED == ErrorCode)  ) {

        //
        // Cancel overides previous error codes
        //

        if ( DsRolepCurrentOperationHandle.FinalResultStringDisplayable ) {
            RtlFreeHeap( RtlProcessHeap(), 0, DsRolepCurrentOperationHandle.FinalResultStringDisplayable );
        }

        DsRolepCurrentOperationHandle.FinalResultStringDisplayable =
          RtlAllocateHeap( RtlProcessHeap(), 0, ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );

        if ( DsRolepCurrentOperationHandle.FinalResultStringDisplayable == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            wcscpy( DsRolepCurrentOperationHandle.FinalResultStringDisplayable, String );
            DsRolepCurrentOperationHandle.OperationStatus = ErrorCode;
            DsRoleDebugOut(( DEB_TRACE_UPDATE,
                             "DsRolepStringErrorUpdateCallback for error %lu and string %ws\n",
                             ErrorCode,
                             String ));


            DsRolepLogPrint(( DEB_TRACE, "Error - %ws (%d)\n", String, ErrorCode ));
        }
    }

    //
    // Release the lock
    //
    UnlockOpHandle();

    return( Win32Err );
}

DWORD
DsRolepSetOperationHandleSiteName(
    IN LPWSTR SiteName
    )
{
    LockOpHandle();

    DsRolepCurrentOperationHandle.InstalledSiteName = SiteName;

    UnlockOpHandle();

    return ERROR_SUCCESS;

}

BOOLEAN
DsRolepCurrentThreadOwnsLock(
    VOID
    )
/*++

  Routine Description

        Tests wether the current thread owns the lock

--*/
{
    ULONG_PTR ExclusiveOwnerThread = (ULONG_PTR) DsRolepCurrentOperationHandle.CurrentOpLock.ExclusiveOwnerThread;
    ULONG_PTR CurrentThread = (ULONG_PTR) (NtCurrentTeb())->ClientId.UniqueThread;

    if ((DsRolepCurrentOperationHandle.CurrentOpLock.NumberOfActive <0) && (ExclusiveOwnerThread==CurrentThread))
        return TRUE;

    return FALSE;
}


VOID
DsRolepClearErrors(
    VOID
    )
/*++

  Routine Description

        This routine clears the global status.  The purpose of this is to 
        clear errors that components may have set after the demotion is 
        unrollable and should not return errors.
        
--*/
{

    //
    // Grab the lock
    //
    LockOpHandle();

    if ( DsRolepCurrentOperationHandle.OperationStatus != ERROR_SUCCESS ) {

        //
        // Set a warning that something went wrong
        //
        DsRolepLogPrint(( DEB_TRACE, "Clearing a global error" ));

        DSROLEP_SET_NON_FATAL_ERROR( DsRolepCurrentOperationHandle.OperationStatus );

    } 

    if ( DsRolepCurrentOperationHandle.FinalResultStringDisplayable ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DsRolepCurrentOperationHandle.FinalResultStringDisplayable );
        DsRolepCurrentOperationHandle.FinalResultStringDisplayable = NULL;

    }
        
    DsRolepCurrentOperationHandle.OperationStatus = ERROR_SUCCESS;       

    //
    // Release the lock
    //
    UnlockOpHandle();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\lsa.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition
#include <Sddl.h>

#include "secure.h"
#include "lsa.h"


DWORD
DsRolepSetLsaInformationForReplica(
    IN HANDLE CallerToken,
    IN LPWSTR ReplicaPartner,
    IN LPWSTR Account,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This function will set the local Lsa database information to that of the replica partner

Arguments:

    ReplicaPartner -- Replica partner to get the information from

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    UNICODE_STRING PartnerServer;
    HANDLE LocalPolicy = NULL , PartnerPolicy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PBYTE Buffer;
    ULONG i;
    BOOLEAN UseAdded = FALSE;
    PWSTR FullServerPath = NULL;
    POLICY_INFORMATION_CLASS InfoClasses[ ] = {

        PolicyDnsDomainInformation
    };

    if ( !ReplicaPartner ) {

        return( ERROR_INVALID_PARAMETER );
    }

    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_LSA_FROM, ReplicaPartner );

    //
    // Open both lsas
    //
    RtlInitUnicodeString( &PartnerServer, ReplicaPartner );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = ImpLsaOpenPolicy( CallerToken,
                              &PartnerServer,
                              &ObjectAttributes,
                               MAXIMUM_ALLOWED,
                               &PartnerPolicy
                              );

    if ( Status == STATUS_ACCESS_DENIED ) {
        WCHAR *BufPartnerServer = NULL;
        BufPartnerServer = (WCHAR*)malloc(PartnerServer.Length+sizeof(WCHAR));
        if (BufPartnerServer) {
            CopyMemory(BufPartnerServer,PartnerServer.Buffer,PartnerServer.Length);
            BufPartnerServer[PartnerServer.Length/sizeof(WCHAR)] = L'\0';
            DsRolepLogPrint(( DEB_TRACE,
                              "LsaOpenPolicy on %ws failed with  0x%lx. Establishing use.\n",
                              BufPartnerServer, Status ));
            free(BufPartnerServer);
        }
        //
        // Try establishing a session first...
        //
        if ( *ReplicaPartner != L'\\' ) {

            FullServerPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              ( wcslen( ReplicaPartner ) + 3 ) * sizeof( WCHAR ) );
            if ( FullServerPath == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                swprintf( FullServerPath, L"\\\\%ws", ReplicaPartner );
                Status = STATUS_SUCCESS;
            }

        } else {

            FullServerPath = ReplicaPartner;
            Status = STATUS_SUCCESS;
        }

        if ( NT_SUCCESS( Status ) ) {


            Win32Err = ImpNetpManageIPCConnect( CallerToken,
                                                FullServerPath,
                                                Account,
                                                Password,
                                                NETSETUPP_CONNECT_IPC );

            if ( Win32Err == ERROR_SUCCESS ) {

                UseAdded = TRUE;

                Status = ImpLsaOpenPolicy( CallerToken,
                                          &PartnerServer,
                                          &ObjectAttributes,
                                           MAXIMUM_ALLOWED,
                                          &PartnerPolicy );

            } else {

                 DsRolepLogPrint(( DEB_TRACE,
                                   "NetUseAdd to %ws failed with %lu\n",
                                   FullServerPath, Win32Err ));
                //
                // Temp status code so we know a failure occurred.
                //
                Status = STATUS_UNSUCCESSFUL;
            }

        }

    } else if ( !NT_SUCCESS( Status ) ) {

        WCHAR *BufPartnerServer = NULL;
        BufPartnerServer = (WCHAR*)malloc(PartnerServer.Length+sizeof(WCHAR));
        if (BufPartnerServer) {
            CopyMemory(BufPartnerServer,PartnerServer.Buffer,PartnerServer.Length);
            BufPartnerServer[PartnerServer.Length/sizeof(WCHAR)] = L'\0';
            DsRolepLogPrint(( DEB_TRACE,
                              "LsaOpenPolicy on %ws failed with  0x%lx.\n",
                              BufPartnerServer, Status ));
            free(BufPartnerServer);
        }

    }

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &LocalPolicy );

        if ( !NT_SUCCESS( Status ) ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Local LsaOpenPoolicy returned 0x%lx\n",
                              Status ));

        }
    }

    for ( i = 0;
          i < sizeof( InfoClasses ) / sizeof( POLICY_INFORMATION_CLASS ) && NT_SUCCESS( Status );
          i++ ) {


        Status = ImpLsaQueryInformationPolicy( CallerToken,
                                              PartnerPolicy,
                                              InfoClasses[ i ],
                                              &Buffer );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaSetInformationPolicy( LocalPolicy,
                                              InfoClasses[ i ],
                                              Buffer );

            LsaFreeMemory( Buffer );
        }

        DsRolepLogPrint(( DEB_TRACE,
                          "Setting Lsa policy %lu returned 0x%lx\n",
                          InfoClasses[ i ], Status ));


    }

    //
    // Now, the same for the Efs policy
    //
    if ( NT_SUCCESS( Status ) ) {

        Status = ImpLsaQueryDomainInformationPolicy( CallerToken,
                                                     PartnerPolicy,
                                                     PolicyDomainEfsInformation,
                                                    &Buffer );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaSetDomainInformationPolicy( LocalPolicy,
                                                    PolicyDomainEfsInformation,
                                                    Buffer );
            DsRolepLogPrint(( DEB_TRACE,
                              "Setting Efs policy from %ws returned 0x%lx\n",
                              ReplicaPartner, Status ));

            LsaFreeMemory( Buffer );

        } else {

            DsRolepLogPrint(( DEB_TRACE,
                              "Reading Efs policy from %ws returned 0x%lx\n",
                              ReplicaPartner, Status ));

            if ( Status ==  STATUS_OBJECT_NAME_NOT_FOUND ) {

                Status = STATUS_SUCCESS;
            }

        }
    }


    if ( LocalPolicy ) {

        LsaClose( LocalPolicy );
    }

    if ( PartnerPolicy ) {

        ImpLsaClose( CallerToken, PartnerPolicy );
    }

    if ( UseAdded ) {

        Win32Err = ImpNetpManageIPCConnect( CallerToken,
                                            FullServerPath,
                                            Account,
                                            Password,
                                            (NETSETUPP_DISCONNECT_IPC|NETSETUPP_USE_LOTS_FORCE) );

    }

    if ( FullServerPath && FullServerPath != ReplicaPartner ) {

        RtlFreeHeap( RtlProcessHeap(), 0, FullServerPath );
    }

    //
    // We won't bother cleaning up any of the information we set on the local machine in
    // the failure case, since it won't hurt anything to have it here.
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }

    DsRoleDebugOut(( DEB_TRACE_DS, "DsRolepSetLsaInformationForReplica %lu\n", Win32Err ));

    DsRolepLogOnFailure( Win32Err,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepSetLsaInformationForReplica failed with %lu\n",
                                           Win32Err )) );
    return( Win32Err );

}


DWORD
DsRolepSetLsaDomainPolicyInfo(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR EnterpriseDnsName,
    IN GUID *DomainGuid,
    IN PSID DomainSid,
    DWORD  InstallOptions,
    OUT PDSROLEP_DOMAIN_POLICY_INFO BackupDomainInfo
    )
/*++

Routine Description:

    This routine sets the PolicyAccountDomainInformation and
    PolicyDnsDomainInformation in the lsa to reflect the
    recent role changes.

Arguments:

    DnsDomainName - The Dns domain name of the newly installed Domain/Dc

    FlatDomainName - The NetBIOS domain name of the newly installed Domain/Dc

    EnterpriseDnsName - The Dns domain name of the root of the enterprise

    DomainGuid - The new domain guid

    DomainSid - The new domain sid

    InstallOptions : this describes the kind of install (new domain, enterprise,
                                                         or replica)
    DomainGuid - The guid of the new domain is returned here

Returns:

    ERROR_SUCCESS - Success; win error otherwise

--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    POLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    POLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    POLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    LSA_HANDLE PolicyHandle = NULL;

    //
    // If we are setting up the replica, we don't have things like the flat domain name and
    // the domain sid, so we'll use the information we have backed up.
    //
    if ( FlatDomainName == NULL || DomainSid == NULL ) {

        RtlCopyMemory( &AccountDomainInfo.DomainName,
                       &BackupDomainInfo->DnsDomainInfo->Name,
                       sizeof( UNICODE_STRING ) );
        AccountDomainInfo.DomainSid = BackupDomainInfo->DnsDomainInfo->Sid ;

    } else {

        RtlInitUnicodeString( &AccountDomainInfo.DomainName,
                              FlatDomainName);

        AccountDomainInfo.DomainSid = DomainSid;
    }

    //
    // Open the Lsa
    //
    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_WRITE,
                            &PolicyHandle );


    //
    // Set the AccountDomain information first
    //
    if ( NT_SUCCESS( Status ) ) {

        //
        // Set the values in the Account Domain Policy structure.
        //
        WCHAR *BufDomainName = NULL;

        DsRolepLogPrint(( DEB_TRACE, "Setting AccountDomainInfo to:\n" ));

        BufDomainName = (WCHAR*)malloc(AccountDomainInfo.DomainName.Length+sizeof(WCHAR));
        if (BufDomainName) {
            CopyMemory(BufDomainName,AccountDomainInfo.DomainName.Buffer,AccountDomainInfo.DomainName.Length);
            BufDomainName[AccountDomainInfo.DomainName.Length/sizeof(WCHAR)] = L'\0';
            DsRolepLogPrint(( DEB_TRACE,
                              "\tDomain: %ws\n",
                              BufDomainName, Status ));
            free(BufDomainName);
        }

        DsRolepLogSid( DEB_TRACE, "\tSid: ", AccountDomainInfo.DomainSid );


        Status = LsaSetInformationPolicy( PolicyHandle,
                                          PolicyAccountDomainInformation,
                                          ( PVOID )&AccountDomainInfo );

        DsRolepLogOnFailure( RtlNtStatusToDosError( Status ),
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Setting AccountDomainInformation failed with 0x%lx\n",
                                                RtlNtStatusToDosError( Status ) )) );

    }


    //
    // Set the Dns domain information
    //
    if ( NT_SUCCESS( Status ) && !FLAG_ON( InstallOptions, NTDS_INSTALL_REPLICA ) ) {

        RtlInitUnicodeString( &DnsDomainInfo.Name, FlatDomainName );
        RtlInitUnicodeString( &DnsDomainInfo.DnsDomainName, DnsDomainName );
        RtlInitUnicodeString( &DnsDomainInfo.DnsForestName, EnterpriseDnsName );
        RtlCopyMemory( &DnsDomainInfo.DomainGuid, DomainGuid, sizeof( GUID ) );
        DnsDomainInfo.Sid = DomainSid;

        Status = LsaSetInformationPolicy( PolicyHandle,
                                          PolicyDnsDomainInformation,
                                          ( PVOID )&DnsDomainInfo );

        DsRolepLogOnFailure( RtlNtStatusToDosError( Status ),
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Setting DnsDomainInformation failed with 0x%lx\n",
                                                RtlNtStatusToDosError( Status ) )) );
    }


    //
    // If it isn't a replica, wipe the efs policy
    //
    if ( NT_SUCCESS( Status ) && !FLAG_ON( InstallOptions, NTDS_INSTALL_REPLICA ) ) {

        Status = LsaSetDomainInformationPolicy( PolicyHandle,
                                                PolicyDomainEfsInformation,
                                                NULL );

        if ( Status ==  STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;
        }

        DsRolepLogOnFailure( RtlNtStatusToDosError( Status ),
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Erasing EfsPolicy failed with 0x%lx\n",
                                                Status )) );
    }


    //
    // Now, cleanup and exit
    //
    if ( PolicyHandle ) {

        LsaClose( PolicyHandle );
    }


    return( RtlNtStatusToDosError( Status ) );

}



DWORD
DsRolepBackupDomainPolicyInfo(
    IN PLSA_HANDLE LsaHandle, OPTIONAL
    OUT PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    )
/*++

Routine Description

    This routine reads and saves in a global the state of the
    account domain policy and primary domain policy so if an error
    occurs then the original state can be preserved.

Parameters

    DomainInfo : pointer, to be filled in by this routine

Return Values

    ERROR_SUCCESS if no errors; a winerror otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT(DomainInfo);

    if ( DomainInfo->PolicyBackedUp ) {

        return( STATUS_SUCCESS );
    }

    if ( LsaHandle == NULL ) {
        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &PolicyHandle );

    } else {

        PolicyHandle = LsaHandle;
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyDnsDomainInformation,
                       ( PVOID * )&DomainInfo->DnsDomainInfo);
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyAccountDomainInformation,
                       ( PVOID * )&DomainInfo->AccountDomainInfo);
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy(
                       PolicyHandle,
                       PolicyLsaServerRoleInformation,
                       ( PVOID * )&DomainInfo->ServerRoleInfo);
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryDomainInformationPolicy(
                       PolicyHandle,
                       PolicyDomainEfsInformation,
                       ( PVOID * )&DomainInfo->EfsPolicy );

        if ( NT_SUCCESS( Status ) ) {

            DomainInfo->EfsPolicyPresent = TRUE;

        } else {

            //
            // It's ok for the Efs policy not to have existed
            //
            if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                DomainInfo->EfsPolicyPresent = TRUE;
                Status = STATUS_SUCCESS;

            } else {

                DomainInfo->EfsPolicyPresent = FALSE;

            }
        }
    }

    if ( PolicyHandle && PolicyHandle != LsaHandle ) {

        LsaClose( PolicyHandle );
    }


    if ( NT_SUCCESS( Status ) ) {

        DomainInfo->PolicyBackedUp = TRUE;
    }

    return( RtlNtStatusToDosError( Status ) );

}



DWORD
DsRolepRestoreDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    )
/*++

Routine Description

    This routine sets the account and primary domain information to be
    the values that were stored of by DsRolepBackupDomainPolicyInformation.

Parameters

    DomainInfo : pointer, expected to be filled

Return Values

    ERROR_SUCCESS if no errors; a winerror otherwise

    ERROR_INVALID_DATA - The data was never successfully backed up

--*/
{

    NTSTATUS Status, Status2;
    HANDLE   PolicyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ASSERT(DomainInfo);

    if ( !DomainInfo->PolicyBackedUp ) {

        return( ERROR_INVALID_DATA );
    }

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_WRITE,
                            &PolicyHandle );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaSetInformationPolicy( PolicyHandle,
                                          PolicyDnsDomainInformation,
                                          ( PVOID )DomainInfo->DnsDomainInfo );


        Status2 = LsaSetInformationPolicy( PolicyHandle,
                                           PolicyAccountDomainInformation,
                                           ( PVOID )DomainInfo->AccountDomainInfo );

        if ( NT_SUCCESS( Status ) && !NT_SUCCESS( Status2 ) ) {

            Status = Status2;
        }

        //
        // Restore the Efs policy, if it exists
        //
        if ( NT_SUCCESS( Status ) && DomainInfo->EfsPolicyPresent ) {

            Status = LsaSetDomainInformationPolicy( PolicyHandle,
                                                    PolicyDomainEfsInformation,
                                                    ( PVOID )DomainInfo->EfsPolicy );
        }


        Status2 = LsaClose( PolicyHandle );

        if ( NT_SUCCESS( Status ) ) {

            Status = Status2;
        }

    }

    DsRolepLogOnFailure( Status,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "RestoreDomainPolicyInfo failed with 0x%lx\n",
                                           Status )) );

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
DsRolepFreeDomainPolicyInfo(
    IN PDSROLEP_DOMAIN_POLICY_INFO DomainInfo
    )
/*++

Routine Description

    This routine free the structures that were allocated during
    DsRolepBackupDomainPolicyInformation.

Parameters

    DomainInfo : pointer, expected to be filled so the fields can be freed

Return Values

    ERROR_SUCCESS if no errors; a winerror otherwise

--*/
{
    if ( DomainInfo->AccountDomainInfo ) {

        LsaFreeMemory( DomainInfo->AccountDomainInfo );
    }

    if ( DomainInfo->DnsDomainInfo ) {

        LsaFreeMemory( DomainInfo->DnsDomainInfo );
    }

    if ( DomainInfo->ServerRoleInfo ) {

        LsaFreeMemory( DomainInfo->ServerRoleInfo );
    }

    if ( DomainInfo->EfsPolicyPresent ) {

        LsaFreeMemory( DomainInfo->EfsPolicy );
    }

    return ERROR_SUCCESS;
}

DWORD
DsRolepUpgradeLsaToDs(
    BOOLEAN InitializeLsa
    )
/*++

Routine Description:

    Prompts Lsa to upgrade all the information it stores in the registry into the Ds

Arguments:

    None

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD WinError = ERROR_SUCCESS;


    if ( InitializeLsa ) {

        //
        // Make the Lsa think that we're initialized
        //
        DSROLEP_CURRENT_OP0( DSROLEEVT_SET_LSA );

        //
        // Make the Lsa think that we're initialized
        //
        Status = LsapDsInitializeDsStateInfo( LsapDsDsSetup );

        if ( !NT_SUCCESS( Status ) ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to convince Lsa to reinitialize: 0x%lx\n",
                              Status ));

        } else {

            Status = LsaIUpgradeRegistryToDs( FALSE );

        }

    }
    return( WinError == ERROR_SUCCESS ? RtlNtStatusToDosError( Status ) : WinError );
}


VOID
DsRolepFindSelfAndParentInForest(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo,
    OUT PLSAPR_TREE_TRUST_INFO CurrentEntry,
    IN PUNICODE_STRING LocalDomain,
    OUT PLSAPR_TREE_TRUST_INFO *ParentEntry,
    OUT PLSAPR_TREE_TRUST_INFO *OwnEntry
    )
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG i;
    BOOLEAN ParentKnown = FALSE;


    if ( *ParentEntry && *OwnEntry ) {

        return;

    }

    if ( ForestTrustInfo->ParentDomainReference ) {

        CurrentEntry = ForestTrustInfo->ParentDomainReference;
        ParentKnown = TRUE;
    }

    for ( i = 0; i < CurrentEntry->Children && *OwnEntry == NULL; i++ ) {

        if ( RtlCompareUnicodeString(
                    ( PUNICODE_STRING )&CurrentEntry->ChildDomains[ i ].DnsDomainName,
                    LocalDomain,
                    TRUE ) == 0  ) {

            *OwnEntry = &CurrentEntry->ChildDomains[ i ];
            *ParentEntry = CurrentEntry;
            break;
        }

        if ( !ParentKnown ) {

            DsRolepFindSelfAndParentInForest( ForestTrustInfo,
                                              &CurrentEntry->ChildDomains[ i ],
                                              LocalDomain,
                                              ParentEntry,
                                              OwnEntry );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\rpcinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcinit.c

Abstract:

    DSROLE - RPC Server Initialization

Author:

    Scott Birrell       (ScottBi)      April 29, 1991
    Mac McLain          (MacM)         April 14, 1997 - Copied from lsa\server

Environment:

Revision History:

--*/

#include <dssetrpc.h>




VOID DSROLER_HANDLE_rundown(
    DSROLER_HANDLE LsaHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\netname.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netname.c

Abstract:

    Miscellaneous network naming helper functions

Author:

    Mac McLain          (MacM)       Oct 16, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <netsetup.h>
#include <lsarpc.h>
#include <db.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>

#include <dns.h>
#include <dnsapi.h>

#define MAX_NAME_ATTEMPTS   260

DWORD
WINAPI
DsRolepDnsNameToFlatName(
    IN  LPWSTR DnsName,
    OUT LPWSTR *FlatName,
    OUT PULONG StatusFlag
    )
/*++

Routine Description:

    Determines the suggested netbios domain name for the given dns name

Arguments:

    DnsName - The Dns domain name to generate a flat name for

    FlatName - Where the flat name is to be returned

    StatusFlag - Where the status is returned

Returns:

    STATUS_SUCCESS - Success

--*/
{
    DWORD Win32Error = ERROR_SUCCESS;
    NTSTATUS Status;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;
    BOOLEAN FindFromDns = TRUE;
    WCHAR NbDomainName[ DNLEN + 1], NbNameAdd[ 4 ];
    PWSTR Current = NULL;
    WCHAR BaseChar;
    ULONG CurrentAttempt = 0;
    ULONG i,j;


    *StatusFlag = 0;

    DsRolepLogPrint(( DEB_TRACE,
                      "Getting NetBIOS name for Dns name %ws\n",
                      DnsName ));

    //
    // First, see if we are part of domain currently or not.  If we are, then it's a simple
    // matter of returning the current Netbios domain name.
    //
    Status = LsaIQueryInformationPolicyTrusted(
                 PolicyAccountDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION * )&AccountDomainInfo );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaIQueryInformationPolicyTrusted(
                     PolicyDnsDomainInformation,
                     ( PLSAPR_POLICY_INFORMATION * )&DnsDomainInfo );

        if ( !NT_SUCCESS( Status ) ) {

            LsaIFree_LSAPR_POLICY_INFORMATION(
                    PolicyAccountDomainInformation,
                    ( PLSAPR_POLICY_INFORMATION )AccountDomainInfo );
        }


    }

    if ( NT_SUCCESS( Status ) ) {


        if ( DnsDomainInfo->Sid == NULL || AccountDomainInfo->DomainSid == NULL ||
             !RtlEqualSid( AccountDomainInfo->DomainSid, DnsDomainInfo->Sid ) ) {

            //
            // We're not a member of the domain
            //
            FindFromDns = TRUE;

        } else {

            //
            // We are a domain member
            //
            WCHAR *BufDomainName = NULL;
            BufDomainName = (WCHAR*)malloc(DnsDomainInfo->Name.Length+sizeof(WCHAR));
            if (BufDomainName) {
              CopyMemory(BufDomainName,DnsDomainInfo->Name.Buffer,DnsDomainInfo->Name.Length);
              BufDomainName[DnsDomainInfo->Name.Length/sizeof(WCHAR)] = L'\0';
              DsRolepLogPrint(( DEB_TRACE,
                              "Using existing NetBIOS domain name %ws\n",
                              BufDomainName ));
              free(BufDomainName);
            }

            *FlatName = MIDL_user_allocate(
                                    ( DnsDomainInfo->Name.Length + 1 ) * sizeof( WCHAR ) );

            if ( *FlatName == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlCopyMemory( *FlatName, DnsDomainInfo->Name.Buffer,
                                DnsDomainInfo->Name.Length );
                ( *FlatName )[DnsDomainInfo->Name.Length / sizeof( WCHAR )] = UNICODE_NULL;
                *StatusFlag = DSROLE_FLATNAME_UPGRADE;
                *StatusFlag |= DSROLE_FLATNAME_DEFAULT;
                FindFromDns = FALSE;
            }

        }

        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyAccountDomainInformation,
                ( PLSAPR_POLICY_INFORMATION )AccountDomainInfo );

        LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyDnsDomainInformation,
                ( PLSAPR_POLICY_INFORMATION )DnsDomainInfo );
    }

    //
    // If there was no domain name defined, we'll have to get one from the dns name
    //
    if ( Win32Error == ERROR_SUCCESS && FindFromDns ) {

        //
        // Ok, to start with, pull off the first DNLEN characters from the DNS name
        //
        RtlZeroMemory(NbDomainName, sizeof(WCHAR)*(DNLEN+1) );
        wcsncpy( NbDomainName, DnsName, DNLEN );

        Current = wcschr( NbDomainName, L'.' );

        if ( Current ) {

            *Current = UNICODE_NULL;
        }

        //
        // See if the name is currently in use or not
        //
        DsRolepLogPrint(( DEB_TRACE,
                          "Testing default NetBIOS name %ws\n",
                          NbDomainName ));

        Win32Error = NetpValidateName( NULL,
                                       NbDomainName,
                                       NULL,
                                       NULL,
                                       NetSetupNonExistentDomain );

        if ( Win32Error == ERROR_SUCCESS ) {

            *StatusFlag = DSROLE_FLATNAME_DEFAULT;

        } else if ( Win32Error == ERROR_DUP_NAME ) {

            //
            // Position on the last character in the name
            //
            Current = NbDomainName + wcslen( NbDomainName ) - 1;

            ASSERT(Current <= (NbDomainName + DNLEN - 1));

            //
            // If our name is less than the max.  Set our current next to the last character
            //
            if ( (NbDomainName + DNLEN - 1) != Current ) {

                Current++;
                *( Current + 1 ) = UNICODE_NULL;
            }


            while ( CurrentAttempt < MAX_NAME_ATTEMPTS ) {

                _ultow( CurrentAttempt, NbNameAdd, 10 );

                ASSERT( wcslen( NbNameAdd ) < 4 );

                //
                // See if we need to adjust the position of where we copy
                //
                if ( CurrentAttempt == 10 || CurrentAttempt == 100 ) {

                    if ( (NbDomainName + DNLEN) < (Current + wcslen(NbNameAdd)) ) {

                        Current--;
                    }
                }

                wcscpy( Current, NbNameAdd );

                DsRolepLogPrint(( DEB_TRACE,
                                  "Testing default NetBIOS name %ws\n",
                                  NbDomainName ));

                Win32Error = NetpValidateName( NULL,
                                               NbDomainName,
                                               NULL,
                                               NULL,
                                               NetSetupNonExistentDomain );

                //
                // If we've found a name that is in use, try again
                //
                if ( Win32Error != ERROR_DUP_NAME ) {

                    break;
                }

                CurrentAttempt++;
            }

        }


        //
        // If we found a valid name, return it
        //
        if ( Win32Error == ERROR_SUCCESS ) {

            *FlatName = MIDL_user_allocate( ( wcslen( NbDomainName ) + 1 ) * sizeof( WCHAR ) );
            if ( *FlatName == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                wcscpy( *FlatName, NbDomainName );

                DsRolepLogPrint(( DEB_TRACE,
                                  "Found usable NetBIOS domain name %ws\n",
                                  NbDomainName ));

            }

        }

    }



    return( Win32Error );
}





DWORD
DsRolepIsDnsNameChild(
    IN  LPWSTR ParentDnsName,
    IN  LPWSTR ChildDnsName
    )
/*++

Routine Description:

    Determines whether the child dns domain name is indeed a child of the parent.  This means
    that the only difference between the names is the left most component of the child dns name.

Arguments:

    ParentDnsName - The Dns domain name of the parent

    ChildDnsName - The Dns name of the childe .

Returns:

    STATUS_SUCCESS - Success

    ERROR_INVALID_DOMAINNAME - The child dns name is not a child of the parent dns name

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    PWSTR Sep = wcschr( ChildDnsName, L'.' );

    if ( Sep == NULL || !DnsNameCompare_W( Sep + 1, ParentDnsName ) ) {

        Win32Err = ERROR_INVALID_DOMAINNAME;

    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\secure.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    secure.h

Abstract:

    Security related routines

Author:

    Colin Brace   (ColinBr)

Environment:

    User Mode

Revision History:

--*/
#ifndef __SECURE_H__
#define __SECURE_H__

BOOLEAN
DsRolepCreateInterfaceSDs(
    VOID
    );

DWORD
DsRolepCheckPromoteAccess(
    VOID
    );

DWORD
DsRolepCheckDemoteAccess(
    VOID
    );

DWORD
DsRolepGetImpersonationToken(
    OUT HANDLE *ImpersonationToken
    );

#endif // __SECURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\ophandle.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ophandle.h

Abstract:

    Routines to manipulate the global DsRole operation handle

Author:

    Colin Brace         (ColinBr)       April 5, 1999

Environment:

    User Mode

Revision History:

--*/
#ifndef __OPHANDLE_H__
#define __OPHANDLE_H__

//
// First, a type definition of the finite difference states a role operation
// can be in
//

//
//  Operation State diagram of a role change
//
//           
//     /-----------------------\
//     |    (operation failed  |  
//     |     or cancelled)     |
//     v                       ^
//  Idle <--> Running  --> Finished  ---------------> Need Reboot
//            |    |           ^      (operation
//            |    |           |       succeeded)
//            |    |           |
//            |    |           |
//            |    v           |
//            |  Cancelling -->|
//            |    ^           ^
//            |    |           |
//            |    |           |
//            |    |           |
//            v    ^           |
//         Running             |
//       Non Critical ---------/ 
//
//
// N.B. Running to Idle to a rare error case, where the worker thread could
//      not be created.
//
//

typedef enum _DSROLEP_OPERATION_STATE {

    DSROLEP_IDLE = 0,
    DSROLEP_RUNNING,
    DSROLEP_RUNNING_NON_CRITICAL,
    DSROLEP_CANCELING,
    DSROLEP_FINISHED,
    DSROLEP_NEED_REBOOT

} DSROLEP_OPERATION_STATE;

#define DSROLEP_OPERATION_ACTIVE( Op ) \
    ( (Op == DSROLEP_IDLE) || (Op == DSROLEP_NEED_REBOOT) ? FALSE : TRUE )

//
// Now, the definition of the global operation handle that controls a role
// change
// 
// Whenever reading or writing a value to the operation handle, you must 
// lock the structure first.
//
// Use LockOpHandle() and UnLockOpHandle().
// 
//
typedef struct _DSROLEP_OPERATION_HANDLE {

    RTL_RESOURCE CurrentOpLock;
    DSROLEP_OPERATION_STATE OperationState;
    HANDLE CompletionEvent;
    HANDLE OperationThread;
    HANDLE MsgModuleHandle;
    HANDLE CancelEvent;
    HANDLE ClientToken;
    ULONG OperationStatus;
    ULONG MsgIndex;
    ULONG DisplayStringCount;
    PVOID Parameter1;
    PVOID Parameter2;
    PVOID Parameter3;
    PVOID Parameter4;
    PWSTR UpdateStringDisplayable;
    PWSTR FinalResultStringDisplayable;
    PWSTR InstalledSiteName;
    DWORD OperationResultFlags;

} DSROLEP_OPERATION_HANDLE, *PDSROLEP_OPERATION_HANDLE;


extern DSROLEP_OPERATION_HANDLE   DsRolepCurrentOperationHandle;

//
// Type definition for the server handle
//
typedef DSROLE_SERVEROP_HANDLE *PDSROLE_SERVEROP_HANDLE;

//
// Macros for locking the the operation handle
//
#define LockOpHandle() RtlAcquireResourceExclusive( &DsRolepCurrentOperationHandle.CurrentOpLock, TRUE );
#define UnlockOpHandle() RtlReleaseResource( &DsRolepCurrentOperationHandle.CurrentOpLock );

//
// Function for knowing is current thread owns the lock
//

BOOLEAN
DsRolepCurrentThreadOwnsLock(
    VOID
    );

//
// Macros for setting the current operation state
//
#define DSROLEP_CURRENT_OP0( msg )                                          \
        DsRolepSetCurrentOperationStatus( msg, NULL, NULL, NULL, NULL );

#define DSROLEP_CURRENT_OP1( msg, p1 )                                      \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, NULL, NULL, NULL );

#define DSROLEP_CURRENT_OP2( msg, p1, p2 )                                  \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, ( PVOID )p2,    \
                                          NULL, NULL );
#define DSROLEP_CURRENT_OP3( msg, p1, p2, p3 )                              \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, ( PVOID )p2,    \
                                          NULL, NULL );
#define DSROLEP_CURRENT_OP4( msg, p1, p2, p3, p4 )                          \
        DsRolepSetCurrentOperationStatus( msg, ( PVOID )p1, ( PVOID )p2,    \
                                          ( PVOID )p3, ( PVOID )p4 );

#define DSROLEP_FAIL0( err, msg )                                           \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, NULL, NULL, NULL, NULL );

#define DSROLEP_FAIL1( err, msg, p1 )                                       \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), NULL, NULL, NULL );

#define DSROLEP_FAIL2( err, msg, p1, p2 )                                   \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), ( PVOID )( p2 ), NULL, NULL );

#define DSROLEP_FAIL3( err, msg, p1, p2, p3 )                           \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), ( PVOID )( p2 ), \
                                  ( PVOID )( p3 ), NULL );

#define DSROLEP_FAIL4( err, msg, p1, p2, p3, p4 )                           \
        if(err != ERROR_SUCCESS) DsRolepSetFailureMessage( err, msg, ( PVOID )( p1 ), ( PVOID )( p2 ), \
                                  ( PVOID )( p3 ), ( PVOID )( p4 ) );

#define DSROLEP_SET_NON_FATAL_ERROR( Err )                DsRolepCurrentOperationHandle.OperationResultFlags |= DSROLE_NON_FATAL_ERROR_OCCURRED;
#define DSROLEP_SET_NON_CRIT_REPL_ERROR( )                DsRolepCurrentOperationHandle.OperationResultFlags |= DSROLE_NON_CRITICAL_REPL_NOT_FINISHED;
#define DSROLEP_SET_IFM_RESTORED_DATABASE_FILES_MOVED( )  DsRolepCurrentOperationHandle.OperationResultFlags |= DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED;

//
// Macro to determine whether to cancel an operation or not
//
#define DSROLEP_CHECK_FOR_CANCEL( WErr )                                  \
{                                                                         \
    LockOpHandle();                                                       \
    if( DsRolepCurrentOperationHandle.OperationState == DSROLEP_CANCELING \
     && (WErr == ERROR_SUCCESS)) {                                        \
                                                                          \
        WErr = ERROR_CANCELLED;                                           \
    }                                                                     \
    UnlockOpHandle();                                                     \
}

#define DSROLEP_CHECK_FOR_CANCEL_EX( WErr, Label )                        \
{                                                                         \
    LockOpHandle();                                                       \
    if( DsRolepCurrentOperationHandle.OperationState == DSROLEP_CANCELING \
     && (WErr == ERROR_SUCCESS)) {                                        \
                                                                          \
        WErr = ERROR_CANCELLED;                                           \
        UnlockOpHandle();                                                 \
        goto Label;                                                       \
    }                                                                     \
    UnlockOpHandle();                                                     \
}

//
// Prototypes for worker functions
//
DWORD
DsRolepGetDcOperationProgress(
    IN PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    IN OUT PDSROLER_SERVEROP_STATUS *ServerOperationStatus
    );

DWORD
DsRolepGetDcOperationResults(
    IN  PDSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLER_SERVEROP_RESULTS *ServerOperationResults
    );

DWORD
DsRolepSetOperationHandleSiteName(
    IN LPWSTR SiteName
    );

VOID
DsRolepSetCriticalOperationsDone(
    VOID
    );

DWORD
DsRolepInitializeOperationHandle(
    VOID
    );

typedef enum _DSROLEP_OPERATION_TYPE {

    DSROLEP_OPERATION_DC = 0,
    DSROLEP_OPERATION_REPLICA,
    DSROLEP_OPERATION_DEMOTE

} DSROLEP_OPERATION_TYPE, *PDSROLEP_OPERATION_TYPE;

DWORD
DsRolepResetOperationHandle(
    DSROLEP_OPERATION_STATE OpState
    );

VOID
DsRolepResetOperationHandleLockHeld(
    VOID
    );

DWORD
DsRolepSetCurrentOperationStatus(
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    );

DWORD
DsRolepSetFailureMessage(
    IN DWORD FailureStatus,
    IN ULONG MsgIndex,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3,
    IN PVOID Parameter4
    );


VOID
DsRolepClearErrors(
    VOID
    );

#define DSROLEP_OP_PROMOTION 0x00000001
#define DSROLEP_OP_DEMOTION  0x00000002

DWORD
DsRolepSetOperationDone(
    IN DWORD Flags,
    IN DWORD OperationStatus
    );

DWORD
DsRolepFormatOperationString(
    IN ULONG MsgId,
    OUT LPWSTR *FormattedString,
    ...
    );

DWORD
DsRolepStringUpdateCallback(
    IN  PWSTR StringUpdate
    );

DWORD
DsRolepStringErrorUpdateCallback(
    IN PWSTR String,
    IN DWORD ErrorCode
    );

DWORD
DsRolepOperationResultFlagsCallBack(
    IN DWORD Flags
    );

#endif // __OPHANDLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\services.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    services.c

Abstract:

    Routines to manage nt service configurations for promotion and demotion

Author:

    Colin Brace    ColinBr     March 29, 1999.

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>

#include <malloc.h>  // alloca

#include <lmcons.h>  // net api definitions
#include <lmsvc.h>   // service names
#include <ismapi.h>  //defines ISM_SERVICE_CONTROL_REMOVE_STOP

#include "services.h"

//
// These last 3 magic values supplied by Shirish Koti (koti) to setup up
// ras services for macintosh on a domain controller
//
#define DSROLEP_MSV10_PATH    L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define DSROLEP_RASSFM_NAME   L"Auth2"
#define DSROLEP_RASSFM_VALUE  L"RASSFM"

//
// Global Data for this module
//

//
// Table based data for the intrinsic nt services
//
typedef struct _DSROLEP_SERVICE_ITEM
{
    LPWSTR ServiceName;       // name of the service to configure

    ULONG  ConfigureOn;       // the dsrole flag to enable the service

    ULONG  ConfigureOff;      // the dsrole flag to disable the service

    ULONG  RevertSettings;    // the dsrole flags to use to revert settings

    LPWSTR Dependencies[3]; // the dependencies the service has when enabled

} DSROLEP_SERVICE_ITEM;

//
// These are services that run on machines that are part of a domain
//
DSROLEP_SERVICE_ITEM DsRoleDomainServices[] = 
{
    {
        SERVICE_W32TIME,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_NETLOGON,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DEMANDSTART,
        0,
        NULL, NULL, NULL
    }
};

ULONG DsRoleDomainServicesCount = sizeof(DsRoleDomainServices) / sizeof(DsRoleDomainServices[0]);

//
// These are servers that run on machines that are domain controllers
//
DSROLEP_SERVICE_ITEM DsRoleDomainControllerServices[] = 
{
    {
        SERVICE_RPCLOCATOR,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_ISMSERV,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DISABLED | DSROLEP_SERVICE_STOP_ISM,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_KDC,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DISABLED,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_TRKSVR,
        DSROLEP_SERVICE_AUTOSTART,
        DSROLEP_SERVICE_DEMANDSTART,
        DSROLEP_SERVICES_INVALID,
        NULL, NULL, NULL
    },
    {
        SERVICE_NETLOGON,
        DSROLEP_SERVICE_AUTOSTART | DSROLEP_SERVICE_DEP_ADD,
        DSROLEP_SERVICE_AUTOSTART | DSROLEP_SERVICE_DEP_REMOVE,
        DSROLEP_SERVICES_INVALID,
        SERVICE_SERVER, NULL, NULL
    }
};

ULONG DsRoleDomainControllerServicesCount = sizeof(DsRoleDomainControllerServices) / sizeof(DsRoleDomainControllerServices[0]);

//
// Local forwards
//
DWORD
DsRolepSetRegStringValue(
    IN LPWSTR Path,
    IN LPWSTR ValueName,
    IN LPWSTR Value
    );

DWORD
DsRolepConfigureGenericServices(
    IN DSROLEP_SERVICE_ITEM *ServiceArray,
    IN ULONG                 ServiceCount,
    IN ULONG                 Flags
    );

DWORD
DsRolepMakeAdjustedDependencyList(
    IN HANDLE hSvc,
    IN DWORD  ServiceOptions,
    IN LPWSTR Dependency,
    OUT LPWSTR *DependenyList
    );

DWORD
DsRolepGetServiceConfig(
    IN SC_HANDLE hScMgr,
    IN LPWSTR ServiceName,
    IN SC_HANDLE ServiceHandle,
    IN LPQUERY_SERVICE_CONFIG *ServiceConfig
    );
    
//
// Small helper functions
//
DWORD DsRolepFlagsToServiceFlags(
    IN DWORD f
    )
{

    if ( FLAG_ON( f, DSROLEP_SERVICE_BOOTSTART ) ) return SERVICE_BOOT_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_SYSTEM_START ) ) return SERVICE_SYSTEM_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_AUTOSTART ) ) return SERVICE_AUTO_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_DEMANDSTART ) ) return SERVICE_DEMAND_START;
    if ( FLAG_ON( f, DSROLEP_SERVICE_DISABLED ) ) return SERVICE_DISABLED;
    
    // No flag, no change
    return SERVICE_NO_CHANGE;
}

DWORD DsRolepServiceFlagsToDsRolepFlags(
    IN DWORD f
    )
{

    if ( f == SERVICE_BOOT_START ) return DSROLEP_SERVICE_BOOTSTART;
    if ( f == SERVICE_SYSTEM_START ) return DSROLEP_SERVICE_SYSTEM_START;
    if ( f == SERVICE_AUTO_START ) return DSROLEP_SERVICE_AUTOSTART;
    if ( f == SERVICE_DEMAND_START ) return DSROLEP_SERVICE_DEMANDSTART;
    if ( f == SERVICE_DISABLED ) return DSROLEP_SERVICE_DISABLED;
    if ( f == SERVICE_NO_CHANGE ) return 0;

    ASSERT( FALSE && !"Unknown service start type" );

    // This is safe
    return DSROLEP_SERVICE_DEMANDSTART;
}

//
// Exported (from this file) functions
//
DWORD
DsRolepConfigureDomainControllerServices(
    IN DWORD Flags
    )

/*++

Routine Description

Parameters

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    //
    // Configure the registry for RASSFM service
    //
    if ( FLAG_ON( Flags, DSROLEP_SERVICES_ON ) ) {

        WinError = DsRolepSetRegStringValue(DSROLEP_MSV10_PATH,
                                              DSROLEP_RASSFM_NAME,
                                              DSROLEP_RASSFM_VALUE);

        //
        // This is not fatal -- log message
        //

        WinError = ERROR_SUCCESS;
        
    }

    //
    // Configure the intrinsic nt services
    //
    WinError = DsRolepConfigureGenericServices( DsRoleDomainControllerServices,
                                                DsRoleDomainControllerServicesCount,
                                                Flags );

                                         

    //
    // No need to undo RASSFM change
    //

    return WinError;
}

DWORD
DsRolepConfigureDomainServices(
    DWORD Flags
    )
/*++

Routine Description

Parameters

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    //
    // Configure the intrinsic nt services
    //
    WinError = DsRolepConfigureGenericServices( DsRoleDomainServices,
                                                DsRoleDomainServicesCount,
                                                Flags );

    return WinError;
}


DWORD
DsRolepStartNetlogon(
    VOID
    )
{
    DWORD WinError = ERROR_SUCCESS;

    WinError  = DsRolepConfigureService( SERVICE_NETLOGON,
                                         DSROLEP_SERVICE_START,
                                         NULL,
                                         NULL );
    return WinError;
}

DWORD
DsRolepStopNetlogon(
    OUT BOOLEAN *WasRunning
    )
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG PreviousSettings = 0;

    WinError  = DsRolepConfigureService( SERVICE_NETLOGON,
                                         DSROLEP_SERVICE_STOP,
                                         NULL,
                                         &PreviousSettings );

    if (  (ERROR_SUCCESS == WinError) 
       && WasRunning ) {

        *WasRunning = (BOOLEAN) FLAG_ON( PreviousSettings, DSROLEP_SERVICE_START );
                       
    }

    return WinError;
}

//
// Local functions
//

DWORD
DsRolepSetRegStringValue(LPWSTR Path,
                         LPWSTR ValueName,
                         LPWSTR Value)
/*++

Routine Description

    This routine sets Value as a REG_SZ value on the value ValueName
    on the key Path

Parameters

    Path,  a registry path relative to HKLM

    ValueName, a null-terminated string

    Value, a null terminated string

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinErroror = ERROR_INVALID_PARAMETER, WinErroror2;
    HKEY  hKey;

    ASSERT(Path);
    ASSERT(ValueName);
    ASSERT(Value);

    if (Path && ValueName && Value) {

        WinErroror = RegCreateKey(HKEY_LOCAL_MACHINE,
                                  Path,
                                  &hKey);

        if (ERROR_SUCCESS == WinErroror) {

            WinErroror = RegSetValueEx(hKey,
                                       ValueName,
                                       0, // reserved
                                       REG_SZ,
                                       (VOID*)Value,
                                       (wcslen(Value)+1)*sizeof(WCHAR));


            WinErroror2 = RegCloseKey(hKey);
            ASSERT(ERROR_SUCCESS == WinErroror2);

        }

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "DsRolepSetRegStringValue on %ws\\%ws to %ws returned %lu\n",
                      Path,
                      ValueName,
                      Value,
                      WinErroror ));


    return WinErroror;

}

DWORD
DsRolepConfigureGenericServices(
    IN DSROLEP_SERVICE_ITEM *ServiceArray,
    IN ULONG                 ServiceCount,
    IN ULONG                 Flags
    )
/*++

Routine Description:

Arguments:

Returns:

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    ULONG ServicesInstalled;



    //
    // Configure each service
    //
    for ( ServicesInstalled = 0;
            ServicesInstalled < ServiceCount && (WinError == ERROR_SUCCESS);
                ServicesInstalled++ ) {


        ULONG *RevertSettings = &ServiceArray[ServicesInstalled].RevertSettings;
        ULONG Operation = 0;

        //
        // Check for cancel before contining if we are not reverting
        //
        if ( !FLAG_ON( Flags, DSROLEP_SERVICES_REVERT ) ) {
            
            DSROLEP_CHECK_FOR_CANCEL( WinError );
            if ( ERROR_SUCCESS != WinError ) {
                break;
            }
        }

        //
        // Determine the operation flag
        //
        if ( FLAG_ON( Flags, DSROLEP_SERVICES_ON ) ) {

            Operation |= ServiceArray[ServicesInstalled].ConfigureOn;
            *RevertSettings = 0;

        } else if ( FLAG_ON( Flags, DSROLEP_SERVICES_OFF ) ) {

            Operation |= ServiceArray[ServicesInstalled].ConfigureOff;
            *RevertSettings = 0;

        } else if ( FLAG_ON( Flags, DSROLEP_SERVICES_REVERT ) ) {
            
            Operation |= ServiceArray[ServicesInstalled].RevertSettings;

            //
            // N.B. We don't want to set the revert settings when we are
            // reverting!
            //
            RevertSettings = NULL;

        }

        if ( FLAG_ON( Flags, DSROLEP_SERVICES_START ) ) {

            Operation |= DSROLEP_SERVICE_START;

        } else if ( FLAG_ON( Flags, DSROLEP_SERVICES_STOP ) ) {
            
            Operation |= DSROLEP_SERVICE_STOP;
        }

        //
        // Currently we don't handle more than one dependency
        //
        ASSERT( NULL == ServiceArray[ ServicesInstalled ].Dependencies[1] );

        // We should do something
        ASSERT( 0 != Operation );

        //
        // Configure the service
        //
        WinError = DsRolepConfigureService( ServiceArray[ ServicesInstalled ].ServiceName,
                                            Operation,
                                            ServiceArray[ ServicesInstalled ].Dependencies[0],
                                            RevertSettings
                                            );

    }

    //
    // If there is an error, undo the work already done
    //
    if (  ERROR_SUCCESS != WinError 
      && !FLAG_ON( Flags, DSROLEP_SERVICES_REVERT )  ) {

        DWORD WinError2;
        ULONG i;

        for ( i = 0; i < ServicesInstalled; i++ ) {
    
            //
            // Configure the service
            //
            WinError2 = DsRolepConfigureService( ServiceArray[ i ].ServiceName,
                                                 ServiceArray[ServicesInstalled].RevertSettings,
                                                 ServiceArray[ i ].Dependencies[0],
                                                 NULL  // we don't need to know revert settings
                                                 );
    
            //
            // This should succeed, though since this is the undo path it is
            // not critical
            //
            ASSERT( ERROR_SUCCESS == WinError2 );
        }
    }


    return WinError;
}

DWORD
DsRolepConfigureService(
    IN LPWSTR ServiceName,
    IN ULONG ServiceOptions,
    IN LPWSTR  Dependency OPTIONAL,
    OUT ULONG *RevertServiceOptions OPTIONAL
    )
/*++

Routine Description:

    Starts, stops, or modifies the configuration of a service.

Arguments:

    ServiceName - Service to configure

    ServiceOptions - Stop, start, dependency add/remove, or configure

    Dependency - a null terminated string identify a dependency

    ServiceWasRunning - Optional.  When stopping a service, the previous service state
                        is returned here

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad service option was given

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    SC_HANDLE hScMgr = NULL, hSvc = NULL;
    ULONG OpenMode = 0;
    LPENUM_SERVICE_STATUS DependentServices = NULL;
    ULONG DependSvcSize = 0, DependSvcCount = 0, i;
    LPWSTR NewDependencyList = NULL;
    DWORD NewStartType = SERVICE_NO_CHANGE;
    ULONG UpdateMsgId = DSROLEEVT_CONFIGURE_SERVICE;

    //
    // If the service doesn't stop within two minutes minute, continue on
    //
    ULONG AccumulatedSleepTime;
    ULONG MaxSleepTime = 120000;


    BOOLEAN ConfigChangeRequired = FALSE;
    BOOLEAN RunChangeRequired = FALSE;

    DWORD   PreviousStartType = SERVICE_NO_CHANGE;
    BOOLEAN fServiceWasRunning = FALSE;


    //
    // Parameter checks
    //
    ASSERT( ! (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_ADD )
           && (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE ))) );

    ASSERT( ! (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_AUTOSTART )
           && (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DISABLED ))) );

    ASSERT( ! (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START )
           && (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ))) );

    //
    // Do some logic to determine the open mode of the service
    //
    NewStartType = DsRolepFlagsToServiceFlags( ServiceOptions );

    if ( (SERVICE_NO_CHANGE != NewStartType)                ||
        FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_ADD )  ||
        FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE ))
    {
        ConfigChangeRequired = TRUE;
    }

    if( ConfigChangeRequired ) {

        OpenMode |= SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG;
    }

    if( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ) ) {

        OpenMode |= SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_QUERY_STATUS;
        UpdateMsgId = DSROLEEVT_STOP_SERVICE;
        RunChangeRequired = TRUE;
    }

    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP_ISM ) ) {

        OpenMode |= SERVICE_USER_DEFINED_CONTROL;

    }

    if( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START ) ) {

        OpenMode |= SERVICE_START | SERVICE_QUERY_STATUS;
        UpdateMsgId = DSROLEEVT_START_SERVICE;
        RunChangeRequired = TRUE;
    }
    
    //
    // Open the service control manager
    //
    hScMgr = OpenSCManager( NULL,
                            SERVICES_ACTIVE_DATABASE,
                            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    if ( hScMgr == NULL ) {

        WinError = GetLastError();
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Can't contact the service controller manager (%lu)\n",
                                                WinError )) );
        goto Cleanup;

    }

    //
    // Open the service
    //
    hSvc = OpenService( hScMgr,
                        ServiceName,
                        OpenMode );

    if ( hSvc == NULL ) {

        WinError = GetLastError();
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "OpenService on %ws failed with %lu\n",
                                                ServiceName,
                                                WinError )) );
        goto Cleanup;
    } 

    
    DSROLEP_CURRENT_OP1( UpdateMsgId, ServiceName );

    //
    // Determine if the service is running if we are going to be stopping or
    // starting it
    //
    if( RunChangeRequired ) {

        SERVICE_STATUS SvcStatus;

        if( QueryServiceStatus( hSvc,&SvcStatus ) == FALSE ) {
    
            WinError = GetLastError();
            goto Cleanup;
        }
    
        if ( SvcStatus.dwCurrentState == SERVICE_RUNNING ) {
    
            fServiceWasRunning = TRUE;
                                        
        }
    }

    //
    // Determine the current start type if we are going to be changing it
    //
    if ( ConfigChangeRequired ) {

        LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
        DWORD                  Size = 0;
        BOOL                   fSuccess;

        QueryServiceConfig( hSvc,
                            ServiceConfig,
                            Size,
                            &Size );

        ASSERT( GetLastError() == ERROR_INSUFFICIENT_BUFFER );

        ServiceConfig = (LPQUERY_SERVICE_CONFIG) alloca( Size );

        fSuccess = QueryServiceConfig( hSvc,
                                       ServiceConfig,
                                       Size,
                                      &Size );

        if ( !fSuccess ) {
            WinError = GetLastError();
            goto Cleanup;
        }

        PreviousStartType = ServiceConfig->dwStartType;
    }

    //
    // Do the config change
    //
    if ( ConfigChangeRequired ) {

        //
        // Make a new dependency list
        //
    
        if ( Dependency ) {
    
            WinError = DsRolepMakeAdjustedDependencyList( hSvc,
                                                          ServiceOptions,
                                                          Dependency,
                                                          &NewDependencyList );
    
            if ( ERROR_SUCCESS != WinError ) {
                goto Cleanup;
            }
        
        }

        //
        // Change the service with new parameters
        //
        if ( ChangeServiceConfig( hSvc,
                                  SERVICE_NO_CHANGE,
                                  NewStartType,
                                  SERVICE_NO_CHANGE,
                                  NULL,
                                  NULL,
                                  0,
                                  NewDependencyList,
                                  NULL, NULL, NULL ) == FALSE ) {
    
            WinError = GetLastError();
            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "ChangeServiceConfig on %ws failed with %lu\n",
                                                   ServiceName,
                                                   WinError )) );

            goto Cleanup;
        }

    }

    // Stop the service.
    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ) || FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP_ISM ) ) {
    
        SERVICE_STATUS  SvcStatus;
    
        WinError = ERROR_SUCCESS;
    
        //
        // Enumerate all of the dependent services first
        //
        if(EnumDependentServices( hSvc,
                                  SERVICE_ACTIVE,
                                  NULL,
                                  0,
                                  &DependSvcSize,
                                  &DependSvcCount ) == FALSE ) {
    
            WinError = GetLastError();
        }
    
    
    
        if ( WinError == ERROR_MORE_DATA ) {
    
            DependentServices = RtlAllocateHeap( RtlProcessHeap(), 0, DependSvcSize );
    
            if ( DependentServices == NULL) {
    
                WinError = ERROR_OUTOFMEMORY;
    
            } else {
    
                if( EnumDependentServices( hSvc,
                                           SERVICE_ACTIVE,
                                           DependentServices,
                                           DependSvcSize,
                                           &DependSvcSize,
                                           &DependSvcCount ) == FALSE ) {
    
                    WinError = GetLastError();
    
                } else {
    
                    for ( i = 0; i < DependSvcCount; i++) {
    
                        DsRoleDebugOut(( DEB_TRACE,
                                          "Service %ws depends on %ws\n",
                                          DependentServices[i].lpServiceName,
                                          ServiceName ));
    
                        WinError = DsRolepConfigureService(
                                         DependentServices[i].lpServiceName,
                                         DSROLEP_SERVICE_STOP,
                                         NULL,
                                         NULL );
    
                        if ( WinError != ERROR_SUCCESS ) {
    
                            break;
                        }
    
                    }
                }
    
                RtlFreeHeap( RtlProcessHeap(), 0, DependentServices );
            }
    
        }
    
    
        if ( WinError == ERROR_SUCCESS ) {
    
            if ( (FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP_ISM )?
                  ControlService( hSvc,
                                  ISM_SERVICE_CONTROL_REMOVE_STOP,
                                  &SvcStatus ):
                  ControlService( hSvc,
                                  SERVICE_CONTROL_STOP,
                                  &SvcStatus )) == FALSE ) {
    
                WinError = GetLastError();
    
                //
                // It's not an error if the service wasn't running
                //
                if ( WinError == ERROR_SERVICE_NOT_ACTIVE ) {
    
                    WinError = ERROR_SUCCESS;
                }
    
            } else {
    
                WinError = ERROR_SUCCESS;
    
                //
                // Wait for the service to stop
                //
                AccumulatedSleepTime = 0;
                while ( TRUE ) {
    
                    if( QueryServiceStatus( hSvc,&SvcStatus ) == FALSE ) {
    
                        WinError = GetLastError();
                    }
    
                    if ( WinError != ERROR_SUCCESS ||
                                        SvcStatus.dwCurrentState == SERVICE_STOPPED) {
    
                        break;
                    
                    }

                    if ( AccumulatedSleepTime < MaxSleepTime ) {

                        if ( 0 == SvcStatus.dwWaitHint ) {

                            //if we are told not to wait we will
                            //wait for 5 seconds anyway.
                            //bug # 221482

                            Sleep ( 5000 );
                            AccumulatedSleepTime += 5000;

                        } else  {

                            Sleep( SvcStatus.dwWaitHint );
                            AccumulatedSleepTime += SvcStatus.dwWaitHint;

                        }

                    } else {

                        //
                        // Give up and return an error
                        //
                        WinError = WAIT_TIMEOUT;
                        break;
                    }
                }
            }
    
            DsRoleDebugOut(( DEB_TRACE, "StopService on %ws returned %lu\n",
                              ServiceName, WinError ));
    
        }
    
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "StopService on %ws failed with %lu\n",
                                               ServiceName,
                                               WinError )) );

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }
    
    }

    if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START ) ) {

        //
        // See about changing its state
        //
        if ( StartService( hSvc, 0, NULL ) == FALSE ) {

            WinError = GetLastError();

        } else {

            WinError = ERROR_SUCCESS;
        }

        DsRoleDebugOut(( DEB_TRACE, "StartService on %ws returned %lu\n",
                          ServiceName, WinError ));
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "StartService on %ws failed with %lu\n",
                                               ServiceName,
                                               WinError )) );

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }

    }

    //
    // Success! By the time we are here, we have completed the task asked
    // of us, so set the Revert parameter
    //
    ASSERT( ERROR_SUCCESS == WinError );
    if ( RevertServiceOptions ) {

        *RevertServiceOptions = 0;

        if( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_STOP ) 
         && fServiceWasRunning   ) {

            *RevertServiceOptions |= DSROLEP_SERVICE_START;
        }
    
        if(  FLAG_ON( ServiceOptions, DSROLEP_SERVICE_START ) 
          && !fServiceWasRunning ) {

            *RevertServiceOptions |= DSROLEP_SERVICE_STOP;
        }

        if ( PreviousStartType != SERVICE_NO_CHANGE ) {
            *RevertServiceOptions |= DsRolepServiceFlagsToDsRolepFlags( PreviousStartType );
        }

        if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_ADD ) ) {
            *RevertServiceOptions |= DSROLEP_SERVICE_DEP_REMOVE;
        }

        if ( FLAG_ON( ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE ) ) {
            *RevertServiceOptions |= DSROLEP_SERVICE_DEP_ADD;
        }
    }

Cleanup:

    if ( hSvc ) {

        CloseServiceHandle( hSvc );

    }

    if ( hScMgr ) {
        
        CloseServiceHandle( hScMgr );

    }

    if ( NewDependencyList ) {

        RtlFreeHeap(RtlProcessHeap(), 0, NewDependencyList);
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Configuring service %ws to %lu returned %lu\n",
                      ServiceName,
                      ServiceOptions,
                      WinError ));

    DSROLEP_FAIL1( WinError, DSROLERES_SERVICE_CONFIGURE, ServiceName );

    return( WinError );
}

DWORD
DsRolepMakeAdjustedDependencyList(
    IN HANDLE hSvc,
    IN DWORD  ServiceOptions,
    IN LPWSTR Dependency,
    OUT LPWSTR *NewDependencyList
    )
/*++

Routine Description

    This function adds or removes Dependency from the service referred to
    by hSvc.

Parameters

    hSvc, a handle to an open service

    ServiceOptions,  either DSROLEP_SERVICE_DEP_REMOVE or DSROLEP_SERVICE_DEP_ADD

    Dependency, null terminated string

    NewDependencyList, a block list of strings to freed by the caller

Return Values

    ERROR_SUCCESS if no errors; a system service error otherwise.

--*/
{
    DWORD WinError = STATUS_SUCCESS;
    BOOLEAN fDone = FALSE;

    WCHAR *CurrentDependency;
    ULONG CurrentDependencyLength;

    ULONG DependencySize;
    ULONG DependencyListSize;
    ULONG NewDependencyListSize;

    LPWSTR TempDependencyList = NULL;
    WCHAR  *CurrNewList;

    LPQUERY_SERVICE_CONFIG ServiceConfigInfo=NULL;

    //
    // Query for the existing dependencies
    //
    WinError = DsRolepGetServiceConfig(NULL,
                                       NULL,
                                       hSvc,
                                       &ServiceConfigInfo);

    if (ERROR_SUCCESS != WinError) {
        goto Cleanup;
    }


    if (FLAG_ON(ServiceOptions, DSROLEP_SERVICE_DEP_ADD)) {


        // Get the size of the dependency
        DependencySize = (wcslen(Dependency) + 1)*sizeof(WCHAR); // for NULL

        // Get the size of the dependency list
        DependencyListSize = 0;
        CurrentDependency = ServiceConfigInfo->lpDependencies;
        while (CurrentDependency && *CurrentDependency != L'\0') {

            // Get the current list size
            if (!_wcsicmp(CurrentDependency, Dependency)) {
                //
                // Dependency is already here
                //
                break;
                fDone = TRUE;
            }

            CurrentDependencyLength = wcslen(CurrentDependency) + 1; // for NULL
            DependencyListSize += CurrentDependencyLength * sizeof(WCHAR);

            CurrentDependency += CurrentDependencyLength;

        }

        if ( fDone ) {

            WinError = ERROR_SUCCESS;
            goto Cleanup;
        }


        // Calculate the size of the new dependency list
        NewDependencyListSize = DependencyListSize +
                                DependencySize     +
                                sizeof(WCHAR);  // the whole string of strings
                                                // NULL terminated
        //
        // Now allocate a space to hold the new dependency array
        //
        TempDependencyList = RtlAllocateHeap(RtlProcessHeap(),
                                             0,
                                             NewDependencyListSize);
        if (!TempDependencyList) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory(TempDependencyList, NewDependencyListSize);
        RtlCopyMemory(TempDependencyList,
                      ServiceConfigInfo->lpDependencies,
                      DependencyListSize);
        RtlCopyMemory(&TempDependencyList[DependencyListSize/sizeof(WCHAR)],
                      Dependency,
                      DependencySize);

    } else if (FLAG_ON(ServiceOptions, DSROLEP_SERVICE_DEP_REMOVE)) {

        // Get the size of the dependency
        DependencySize = (wcslen(Dependency) + 1)*sizeof(WCHAR); // for NULL

        // Get the size of the dependency list
        DependencyListSize = 0;
        CurrentDependency = ServiceConfigInfo->lpDependencies;
        while (CurrentDependency && *CurrentDependency != L'\0') {

            CurrentDependencyLength = wcslen(CurrentDependency) + 1; // for NULL
            DependencyListSize += CurrentDependencyLength * sizeof(WCHAR);

            CurrentDependency += CurrentDependencyLength;

        }

        // Calculate the size of the new dependency list
        NewDependencyListSize = DependencyListSize -
                                DependencySize     +
                                sizeof(WCHAR);  // the whole string of strings
                                                // NULL terminated
        //
        // Now allocate a space to hold the new dependency array
        // This is overkill, but not much.
        //
        TempDependencyList = RtlAllocateHeap(RtlProcessHeap(),
                                             0,
                                             NewDependencyListSize);
        if (!TempDependencyList) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlZeroMemory(TempDependencyList, NewDependencyListSize);

        CurrentDependency = ServiceConfigInfo->lpDependencies;
        CurrNewList = TempDependencyList;

        while (CurrentDependency && *CurrentDependency != L'\0') {

            CurrentDependencyLength = wcslen(CurrentDependency) + 1; // for NULL

            // Get the current list size
            if (!_wcsicmp(CurrentDependency, Dependency)) {
                //
                // This is the one - don't copy it
                //
            } else {
                wcscpy(CurrNewList, CurrentDependency);
                CurrNewList += CurrentDependencyLength;
            }

            CurrentDependency += CurrentDependencyLength;
        }

    }

Cleanup:

    if (WinError != ERROR_SUCCESS && TempDependencyList) {
        RtlFreeHeap(RtlProcessHeap(), 0, TempDependencyList);
        *NewDependencyList = NULL;
    } else {
        *NewDependencyList = TempDependencyList;
    }

    if (ServiceConfigInfo) {

        RtlFreeHeap(RtlProcessHeap(), 0, ServiceConfigInfo);
    }

    return( WinError );
}


DWORD
DsRolepGetServiceConfig(
    IN SC_HANDLE hScMgr,
    IN LPWSTR ServiceName,
    IN SC_HANDLE ServiceHandle,
    IN LPQUERY_SERVICE_CONFIG *ServiceConfig
    )
/*++

Routine Description:

Parameters:

Return Values:

    ERROR_SUCCESS
    ERROR_NOT_ENOUGH_MEMORY

--*/
{
    DWORD Win32Error;
    SC_HANDLE hService;
    ULONG SizeNeeded;

#if DBG
    if (!ServiceHandle) {
        ASSERT(ServiceName);
        ASSERT(hScMgr);
    }
#endif

    if (!ServiceHandle) {

        hService = OpenService( hScMgr,
                                ServiceName,
                                SERVICE_QUERY_CONFIG );
    } else {

        hService = ServiceHandle;

    }

    if (hService) {

        SizeNeeded = 0;
        Win32Error = ERROR_SUCCESS;
        if (!QueryServiceConfig(hService,
                                NULL,
                                0,
                                &SizeNeeded)) {

            Win32Error = GetLastError();

        }
        ASSERT(Win32Error == ERROR_INSUFFICIENT_BUFFER);
        ASSERT( SizeNeeded > 0 );

        *ServiceConfig = RtlAllocateHeap(RtlProcessHeap(),
                                         0,
                                         SizeNeeded);
        if (*ServiceConfig) {

            Win32Error = ERROR_SUCCESS;
            if (!QueryServiceConfig(hService,
                                    *ServiceConfig,
                                    SizeNeeded,
                                    &SizeNeeded)) {

                Win32Error = GetLastError();
            }

        } else {

            Win32Error = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (!ServiceHandle) {
            CloseServiceHandle(hService);
        }

    } else {

        Win32Error = GetLastError();

    }

    DsRolepLogOnFailure( Win32Error,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepGetServiceConfig on %ws failed with %lu\n",
                                            ServiceName,
                                            Win32Error )) );

    return Win32Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\services.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    services.h

Abstract:

    Routines to manage nt service configurations for promotion and demotion
    
Author:

    Colin Brace    ColinBr     March 29, 1999.

Environment:

    User Mode

Revision History:

--*/


//
// Control bits for the "Flags" parameter
// 

// Not a valid flag
#define DSROLEP_SERVICES_INVALID        0x0

// Configure start type of services to become new role
#define DSROLEP_SERVICES_ON             0x00000001

// Configure start type of services to leave old role
#define DSROLEP_SERVICES_OFF            0x00000002

// Stop or start services -- can be used with above flags
#define DSROLEP_SERVICES_STOP           0x00000004
#define DSROLEP_SERVICES_START          0x00000008

// Configure services back to original state -- no other flags
// above are valid with this flags
#define DSROLEP_SERVICES_REVERT         0x00000010

//
// This routine configures the services relevant to a domain controller
//
DWORD
DsRolepConfigureDomainControllerServices(
    IN DWORD Flags
    );

//
// This routine configures the services relevant to a member of a domain
// (including domain controllers)
//
DWORD
DsRolepConfigureDomainServices(
    IN DWORD Flags
    );

//
// Simple routines to manage netlogon running state (not
//
DWORD
DsRolepStartNetlogon(
    VOID
    );

DWORD
DsRolepStopNetlogon(
    OUT BOOLEAN *WasRunning
    );

//
// A "low level" routine to manipulate a service directly
//

//
// Options for controlling services (through the ServiceOptions)
//
#define DSROLEP_SERVICE_STOP         0x00000001
#define DSROLEP_SERVICE_START        0x00000002

#define DSROLEP_SERVICE_BOOTSTART    0x00000004
#define DSROLEP_SERVICE_SYSTEM_START 0x00000008
#define DSROLEP_SERVICE_AUTOSTART    0x00000010
#define DSROLEP_SERVICE_DEMANDSTART  0x00000020
#define DSROLEP_SERVICE_DISABLED     0x00000040

#define DSROLEP_SERVICE_DEP_ADD      0x00000080
#define DSROLEP_SERVICE_DEP_REMOVE   0x00000100

#define DSROLEP_SERVICE_STOP_ISM     0x00000200

DWORD
DsRolepConfigureService(
    IN  LPWSTR  ServiceName,
    IN  ULONG   ServiceOptions,
    IN  LPWSTR  Dependency OPTIONAL,
    OUT ULONG * PreviousSettings  OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\secure.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    secure.c

Abstract:

    Security related routines

Author:

    Colin Brace   (ColinBr)

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>

#include "secure.h"

//
// Data global to this module only
//
SECURITY_DESCRIPTOR DsRolepPromoteSD;
SECURITY_DESCRIPTOR DsRolepDemoteSD;

//
// DsRole related access masks
//
#define DSROLE_ROLE_CHANGE_ACCESS     0x00000001

#define DSROLE_ALL_ACCESS            (STANDARD_RIGHTS_REQUIRED    | \
                                      DSROLE_ROLE_CHANGE_ACCESS )

GENERIC_MAPPING DsRolepInfoMapping = 
{
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    DSROLE_ALL_ACCESS                      // Generic all
};

//
// Function definitions
//
BOOLEAN
DsRolepCreateInterfaceSDs(
    VOID
    )
/*++

Routine Description:

    This routine creates the in memory access control lists that 
    are used to perform security checks on callers of the DsRoler
    API's.
    
    The model is as follows:
    
    Promote: the caller must have the builtin admin SID
    
    Demote: the caller must have the builtin admin SID
    

Arguments:

    None.          

Returns:

    TRUE if successful; FALSE otherwise         
    

--*/
{
    NTSTATUS Status;
    BOOLEAN  fSuccess = TRUE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AclLength = 0;
    PSID BuiltinAdminsSid = NULL;
    PSID *AllowedSids [] = 
    {
        &BuiltinAdminsSid
    };
    ULONG cAllowedSids = sizeof(AllowedSids) / sizeof(AllowedSids[0]);
    ULONG i;
    PACL DsRolepPromoteAcl = NULL;
    PACL DsRolepDemoteAcl = NULL;


    //
    // Build the builtin administrators sid
    //
    Status = RtlAllocateAndInitializeSid(
             &NtAuthority,
             2,
             SECURITY_BUILTIN_DOMAIN_RID,
             DOMAIN_ALIAS_RID_ADMINS,
             0, 0, 0, 0, 0, 0,
             &BuiltinAdminsSid
             );
    if ( !NT_SUCCESS( Status ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }

    //
    // Calculate how much space we'll need for the ACL
    //
    AclLength = sizeof( ACL );
    for ( i = 0; i < cAllowedSids; i++ ) {

        AclLength += (sizeof( ACCESS_ALLOWED_ACE ) 
                    - sizeof(DWORD) 
                    + GetLengthSid((*AllowedSids[i])) );
    }

    DsRolepPromoteAcl = LocalAlloc( 0, AclLength );
    if ( !DsRolepPromoteAcl ) {
        fSuccess = FALSE;
        goto Cleanup;
    }

    if ( !InitializeAcl( DsRolepPromoteAcl, AclLength, ACL_REVISION ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }

    for ( i = 0; i < cAllowedSids; i++ ) {

        if ( !AddAccessAllowedAce( DsRolepPromoteAcl,
                                   ACL_REVISION,
                                   DSROLE_ALL_ACCESS,
                                   *(AllowedSids[i]) ) ) {
            fSuccess = FALSE;
            goto Cleanup;
        }
        
    }

    //
    // Now make the security descriptor
    //
    if ( !InitializeSecurityDescriptor( &DsRolepPromoteSD,
                                         SECURITY_DESCRIPTOR_REVISION ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorOwner( &DsRolepPromoteSD,
                                       BuiltinAdminsSid,
                                       FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorGroup( &DsRolepPromoteSD,
                                       BuiltinAdminsSid,
                                       FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorDacl( &DsRolepPromoteSD,
                                      TRUE,  // DACL is present
                                      DsRolepPromoteAcl,
                                      FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }


    //
    // Make the demote access check the same
    //
    DsRolepDemoteAcl = LocalAlloc( 0, AclLength );
    if ( !DsRolepDemoteAcl ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    RtlCopyMemory( DsRolepDemoteAcl, DsRolepPromoteAcl, AclLength );


    //
    // Now make the security descriptor
    //
    if ( !InitializeSecurityDescriptor( &DsRolepDemoteSD,
                                         SECURITY_DESCRIPTOR_REVISION ) ) {
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorOwner( &DsRolepDemoteSD,
                                       BuiltinAdminsSid,
                                       FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorGroup( &DsRolepDemoteSD,
                                       BuiltinAdminsSid,
                                       FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }
    if ( !SetSecurityDescriptorDacl( &DsRolepDemoteSD,
                                      TRUE,  // DACL is present
                                      DsRolepDemoteAcl,
                                      FALSE    ) ) {  // not defaulted
        fSuccess = FALSE;
        goto Cleanup;
    }

Cleanup:

    if ( !fSuccess ) {

        for ( i = 0; i < cAllowedSids; i++ ) {
            if ( *(AllowedSids[i]) ) {
                RtlFreeHeap( RtlProcessHeap(), 0, *(AllowedSids[i]) );
            }
        }
        if ( DsRolepPromoteAcl ) {
            LocalFree( DsRolepPromoteAcl );
        }
        if ( DsRolepDemoteAcl ) {
            LocalFree( DsRolepDemoteAcl );
        }
    }

    return fSuccess;
}


DWORD
DsRolepCheckClientAccess(
    PSECURITY_DESCRIPTOR pSD,
    DWORD                DesiredAccess
    )
/*++

Routine Description:

    This routine grabs a copy of the client's token and then performs
    an access to make the client has the privlege found in pSD

Arguments:

    pSD : a valid security descriptor
    
    DesiredAccess: the access mask the client is asking for

Returns:

    ERROR_SUCCESS, ERROR_ACCESS_DENIED, or system error

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    BOOL  fStatus, fAccessAllowed = FALSE;
    HANDLE ClientToken = 0;
    DWORD  AccessGranted = 0;
    BYTE   Buffer[500];
    PRIVILEGE_SET *PrivilegeSet = (PRIVILEGE_SET*)Buffer;
    DWORD         PrivilegeSetSize = sizeof(Buffer);

    WinError = DsRolepGetImpersonationToken( &ClientToken );

    if ( ERROR_SUCCESS == WinError ) {

        fStatus = AccessCheck(  pSD,
                                ClientToken,
                                DesiredAccess,
                                &DsRolepInfoMapping,
                                PrivilegeSet,
                                &PrivilegeSetSize,
                                &AccessGranted,
                                &fAccessAllowed );

        if ( !fStatus ) {

            WinError = GetLastError();

        } else {

            if ( !fAccessAllowed ) {

                WinError = ERROR_ACCESS_DENIED;

            }
        }
    }

    if ( ClientToken ) {

        NtClose( ClientToken );
        
    }

    return WinError;

}


DWORD
DsRolepCheckPromoteAccess(
    VOID
    )
{
    return DsRolepCheckClientAccess( &DsRolepPromoteSD, 
                                     DSROLE_ROLE_CHANGE_ACCESS );
}

DWORD
DsRolepCheckDemoteAccess(
    VOID
    )
{
    return DsRolepCheckClientAccess( &DsRolepDemoteSD, 
                                     DSROLE_ROLE_CHANGE_ACCESS );
}


DWORD
DsRolepGetImpersonationToken(
    OUT HANDLE *ImpersonationToken
    )
/*++

Routine Description:

    This function will impersonate the invoker of this call and then duplicate their token

Arguments:

    ImpersonationToken - Where the duplicated token is returned

Returns:

    ERROR_SUCCESS - Success


--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttrs;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    HANDLE ClientToken;

    //
    // Impersonate the caller
    //
    Win32Err = RpcImpersonateClient( 0 );

    if ( Win32Err == ERROR_SUCCESS ) {

        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_QUERY | TOKEN_DUPLICATE,
                                    TRUE,
                                    &ClientToken );

        RpcRevertToSelf( );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Duplicate the token
            //
            InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
            SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
            SecurityQofS.ImpersonationLevel = SecurityImpersonation;
            SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
            SecurityQofS.EffectiveOnly = FALSE;
            ObjAttrs.SecurityQualityOfService = &SecurityQofS;
            Status = NtDuplicateToken( ClientToken,
                                       TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_DUPLICATE,
                                       &ObjAttrs,
                                       FALSE,
                                       TokenImpersonation,
                                       ImpersonationToken );


            NtClose( ClientToken );
        }

        if ( !NT_SUCCESS( Status ) ) {

            Win32Err = RtlNtStatusToDosError( Status );
        }

    }

    return( Win32Err );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\setpch.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    setpch.h

Abstract:

    DsSetup and configuration - precompiled includes for C Server Side

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

Revision History:

--*/

#ifndef __SETPCH_H__
#define __SETPCH_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dssetrpc.h>
#include <dsrole.h>
#include <lsapmsgs.h>
#include <lsacomp.h>
#include <ntdsetup.h>
#include <log.h>
#include <secure.h>
#include <ophandle.h>
#include <lsa.h>
#include <ds.h>

#endif // __SETPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\setutl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    setutl.c

Abstract:

    Miscellaneous helper functions

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>
#include <confname.h>
#include <loadfn.h>
#include <ntdsa.h>
#include <dsconfig.h>
#include <attids.h>
#include <samisrv.h>
#include <dsp.h>
#include <lsaisrv.h>
#include <malloc.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <netsetp.h>
#include <winsock2.h>
#include <nspapi.h>
#include <dsgetdcp.h>
#include <lmremutl.h>
#include <spmgr.h>  // For SetupPhase definition
#include <ntdsetup.h>
#include <shlwapi.h>

#include "secure.h"
#include "cancel.h"

#if DBG
    DEFINE_DEBUG2(DsRole);

    DEBUG_KEY   DsRoleDebugKeys[] = {
        {DEB_ERROR,         "Error"},
        {DEB_WARN,          "Warn"},
        {DEB_TRACE,         "Trace"},
        {DEB_TRACE_DS,      "NtDs"},
        {DEB_TRACE_UPDATE,  "Update"},
        {DEB_TRACE_LOCK,    "Lock"},
        {DEB_TRACE_SERVICES,"Services"},
        {DEB_TRACE_NET,     "Net"},
        {0,                 NULL }
        };

VOID
DsRoleDebugInitialize()
{
    DsRoleInitDebug(DsRoleDebugKeys);
}

#endif // DBG


BOOL
DsRolepShutdownNotification(
    DWORD   dwCtrlType
    );


//
// Global data for this module
//
BOOLEAN GlobalOpLockHeld = FALSE;



NTSTATUS
DsRolepInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes the server portion of the DsRole APIs.  Called from LsaSrv
    DsRolerGetDcOperationProgress return init

Arguments:

    VOID


Returns:

    STATUS_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RPC_STATUS RPCError = RPC_S_OK;
    PWSTR KerbPrinc;

    //
    // Zero out global operation handle
    //
    RtlZeroMemory( &DsRolepCurrentOperationHandle, sizeof(DsRolepCurrentOperationHandle));

    //
    // Init the lock
    //
    RtlInitializeResource( &DsRolepCurrentOperationHandle.CurrentOpLock );


    //
    // Grab the lock
    //
    LockOpHandle();
    GlobalOpLockHeld = TRUE;

    DsRolepResetOperationHandleLockHeld();

    DsRoleDebugInitialize();

    RPCError = RpcServerRegisterIf( dssetup_ServerIfHandle,
                                       NULL,
                                       NULL );
    if (RPC_S_OK != RPCError) {
        DsRoleDebugOut(( DEB_ERROR,
                         "RpcServerRegisterIf failed %d\n",
                         RPCError ));
    }
    

    DsRolepInitSetupFunctions();

    //
    // Create the SD's that are used to perform access checks for DsRoler
    // callers
    //
    if ( !DsRolepCreateInterfaceSDs() ) {

        return STATUS_NO_MEMORY;

    }

    try {

        Status = RtlInitializeCriticalSection( &LogFileCriticalSection );

        } except ( 1 ) {

        Status =  STATUS_NO_MEMORY;
    }

    if(NT_SUCCESS(Status)) {
        //
        // Register our shutdown routine
        //
    
        if (!SetConsoleCtrlHandler(DsRolepShutdownNotification, TRUE)) {
            DsRoleDebugOut(( DEB_ERROR,
                             "SetConsoleCtrlHandler failed %d\n",
                             GetLastError() ));
        }
    
        if (!SetProcessShutdownParameters(480, SHUTDOWN_NORETRY)) {
            DsRoleDebugOut(( DEB_ERROR,
                             "SetProcessShutdownParameters failed %d\n",
                             GetLastError() ));
        }
    }

    

    return( Status );
}




NTSTATUS
DsRolepInitializePhase2(
    VOID
    )
/*++

Routine Description:

    Second phase of the promotion/demotion api initialization.  This initialization is slated
    to happen after the Lsa has finished all of it's initializations

Arguments:

    VOID


Returns:

    STATUS_SUCCESS - Success

    STATUS_UNSUCCESSFUL -- The function was called when the global lock wasn't held

--*/
{
    ULONG RpcStatus = STATUS_SUCCESS;
    PWSTR KerbPrinc;

    ASSERT( GlobalOpLockHeld );

    if ( !GlobalOpLockHeld ) {

        return( STATUS_UNSUCCESSFUL );
    }

    if ( !SetupPhase ) {

        //
        // Register the Rpc authenticated server info
        //
        RpcStatus = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_KERBEROS,
                                                 &KerbPrinc);

        if ( RpcStatus == RPC_S_OK ) {

            DsRoleDebugOut(( DEB_TRACE_DS, "Kerberos Principal name: %ws\n",
                             KerbPrinc ));

            RpcStatus = RpcServerRegisterAuthInfo(KerbPrinc,
                                                  RPC_C_AUTHN_GSS_NEGOTIATE,
                                                  NULL,
                                                  NULL);
            RpcStringFree( &KerbPrinc );

        } else {

            DsRoleDebugOut(( DEB_TRACE_DS, "RpcServerInqDefaultPrincName failed with %lu\n",
                             RpcStatus ));

            RpcStatus = RPC_S_OK;

        }

        if ( RpcStatus == RPC_S_OK) {

            RpcStatus = RpcServerRegisterAuthInfo( DSROLEP_SERVER_PRINCIPAL_NAME,
                                                   RPC_C_AUTHN_GSS_NEGOTIATE,
                                                   NULL,
                                                   NULL );

            if ( RpcStatus != RPC_S_OK ) {

                DsRoleDebugOut(( DEB_ERROR,
                                 "RpcServerRegisterAuthInfo for %ws failed with 0x%lx\n",
                                 DSROLEP_SERVER_PRINCIPAL_NAME,
                                 RpcStatus ));
                RpcStatus = RPC_S_OK;
            }

        }
    }


    //
    // Release the lock, as was opened in Initialization, phase 1
    //
    GlobalOpLockHeld = FALSE;
    RtlReleaseResource( &DsRolepCurrentOperationHandle.CurrentOpLock );

    return( RpcStatus == RPC_S_OK ? STATUS_SUCCESS : RPC_NT_UNKNOWN_AUTHZ_SERVICE );
}




DWORD
DsRolepGetMachineType(
    IN OUT PDSROLEP_MACHINE_TYPE MachineType
    )
/*++

Routine Description:

    Determines the type of machine this is being run on.

Arguments:

    MachineType - Where the machine type is being returned

Returns:

    STATUS_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( LsapProductType == NtProductWinNt ) {

        *MachineType = DSROLEP_MT_CLIENT;

    } else if ( LsapProductType == NtProductServer ) {

        *MachineType = DSROLEP_MT_STANDALONE;

    } else {

        *MachineType = DSROLEP_MT_MEMBER;

    }

    return( Win32Err );
}


DWORD
DsRolepSetProductType(
    IN DSROLEP_MACHINE_TYPE MachineType
    )
/*++

Routine Description:

    Changes the role of the product to the type specified.

Arguments:

    MachineType - Type of ProductRole to set

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad service option was given

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR MachineSz = NULL;
    HKEY ProductHandle;
    ULONG Size = 0;

    switch ( MachineType ) {
    case DSROLEP_MT_STANDALONE:
        MachineSz = L"ServerNT";
        Size = sizeof( L"ServerNT" );
        break;

    case DSROLEP_MT_MEMBER:
        MachineSz = L"LanmanNT";
        Size = sizeof( L"LanmanNT");
        break;

    case DSROLEP_MT_CLIENT:
    default:

        Win32Err = ERROR_INVALID_PARAMETER;
        break;
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 DSROLEP_PROD_KEY_PATH,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_WRITE,            // desired access
                                 &ProductHandle );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegSetValueEx( ProductHandle,
                                      (LPCWSTR)DSROLEP_PROD_VALUE,
                                      0,
                                      REG_SZ,
                                      (CONST BYTE *)MachineSz,
                                      Size );


            RegCloseKey( ProductHandle );
        }
    }

    DsRoleDebugOut(( DEB_TRACE_DS, "SetProductType to %ws returned %lu\n",
                     MachineSz, Win32Err ));

    DsRolepLogPrint(( DEB_TRACE,
                      "SetProductType to %lu [%ws] returned %lu\n",
                       MachineType,
                       DsRolepDisplayOptional(MachineSz),
                       Win32Err ));

    DSROLEP_FAIL1( Win32Err, DSROLERES_PRODUCT_TYPE, MachineSz );


    return( Win32Err );
}

DWORD
DsRolepCreateAuthIdentForCreds(
    IN PWSTR Account,
    IN PWSTR Password,
    OUT PSEC_WINNT_AUTH_IDENTITY *AuthIdent
    )
/*++

Routine Description:

    Internal routine to create an AuthIdent structure for the given creditentials

Arguments:

    Account - Account name

    Password - Password for the account

    AuthIdent - AuthIdentity struct to allocate and fill in.


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed.

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR UserCredentialString = NULL;

    ASSERT( AuthIdent );

    //
    // If there are no creds, just return
    //
    if ( Account == NULL ) {

        *AuthIdent = NULL;
        return( Win32Err );
    }

    *AuthIdent = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( SEC_WINNT_AUTH_IDENTITY ) );

    if ( *AuthIdent == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        RtlZeroMemory( *AuthIdent, sizeof( SEC_WINNT_AUTH_IDENTITY ) );
        UserCredentialString = RtlAllocateHeap( RtlProcessHeap(), 0,
                                                ( wcslen( Account ) + 1 ) * sizeof( WCHAR ) );
        if ( UserCredentialString ) {

            wcscpy( UserCredentialString, Account );

            ( *AuthIdent )->User = wcsstr( UserCredentialString, L"\\" );

            if ( ( *AuthIdent )->User ) {

               //
               // There is a domain name
               //
               *( ( *AuthIdent )->User ) = L'\0';
               ( ( *AuthIdent )->User )++;
               ( *AuthIdent )->Domain = UserCredentialString;

            } else {

               ( *AuthIdent )->User = UserCredentialString;
               ( *AuthIdent )->Domain = L"";

            }

            if ( ( *AuthIdent )->User ) {

                ( *AuthIdent )->UserLength = wcslen( ( *AuthIdent )->User );
            }

            if ( ( *AuthIdent )->Domain ) {

                ( *AuthIdent )->DomainLength = wcslen( ( *AuthIdent )->Domain );
            }

            ( *AuthIdent )->Password = Password;

            if ( Password ) {

                ( *AuthIdent )->PasswordLength = wcslen( Password );
            }

            ( *AuthIdent )->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        } else {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            //
            // Free the memory allocated for the top level structure
            //
            RtlFreeHeap( RtlProcessHeap(), 0, *AuthIdent );
            *AuthIdent = NULL;
        }
    }

    return( Win32Err );
}


VOID
DsRolepFreeAuthIdentForCreds(
    IN  PSEC_WINNT_AUTH_IDENTITY AuthIdent
    )
/*++

Routine Description:

    Free the authident structure allocated above

Arguments:

    AuthIdent - AuthIdentity struct to free


Returns:

    VOID

--*/
{

    if ( AuthIdent ) {

        if ( AuthIdent->Domain == NULL ) {

            RtlFreeHeap( RtlProcessHeap(), 0, AuthIdent->User );

        } else {

            if ( *AuthIdent->Domain != L'\0' ) {

                RtlFreeHeap( RtlProcessHeap(), 0, AuthIdent->Domain );
            }
        }

        RtlFreeHeap( RtlProcessHeap(), 0, AuthIdent );
    }

}

NTSTATUS
ImpLsaOpenPolicy(
    IN HANDLE CallerToken,
    IN PLSA_UNICODE_STRING SystemName OPTIONAL,
    IN PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN OUT PLSA_HANDLE PolicyHandle
    )
/*++

Routine Description:

    This routine impersonates CallerToken and then calls into LsaOpenPolicy.

    This purpose of this routine is call into the LSA on a different machine
    using the RDR session for the caller of the DsRole API.  The caller is
    represented by CallerToken.  This is necessary because the RDR sessions
    are keyed by (logon id/remote server name) and we don't want to use the
    logon id of the lsass.exe process since this is a shared logon id for
    lsass.exe and services.exe and will lead to unresolable credentials
    conflict.

    N.B.  The LSA rpc calls that follow the (Imp)LsaOpenPolicy will use the
    handle returned by this function and then magically uses the right RDR
    session to make the RPC call.

Arguments:

    CallerToken - the token of the DsRole involker

    Others -- see LsaOpenPolicy


Returns:

    STATUS_ACCESS_DENIED if the impersonattion fails.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaOpenPolicy( SystemName,
                                ObjectAttributes,
                                DesiredAccess,
                                PolicyHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

DWORD                         
ImpDsRolepDsGetDcForAccount(
    IN HANDLE CallerToken,
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
/*++

Routine Description:

    This function will impersoniate logged on user and call DsRolepDsGetDcForAccount

Arguments:

    CallerToken - The Token of the DsRole involker.

    Server - The server to call GetDc on.

    Domain - Domain to find the Dc for

    Account - Account to look for.  If NULL, the current computer name is used

    Flags - Flags to bas in to the GetDc call

    AccountBits - Account control bits to search for

    DomainControllerInfo - Where the info is returned

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        WinError = DsRolepDsGetDcForAccount(Server,
                                            Domain,
                                            Account,
                                            Flags,
                                            AccountBits,
                                            DomainControllerInfo
                                            );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );

    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        WinError = ERROR_ACCESS_DENIED;
    }

    return WinError;
}

NET_API_STATUS
NET_API_FUNCTION
ImpNetpManageIPCConnect(
    IN  HANDLE  CallerToken,
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  ULONG   fOptions
    )
/*++

Routine Description:

    This routine impersonates CallerToken and then calls into
    NetpManageIPCConnect.

    This purpose of this routine is to create a RDR using the logon id of
    the caller of the DsRole api's.  The caller is represented by CallerToken.
    This is necessary because the RDR sessions are keyed by
    (logon id/remote server name) and we don't want to use the
    logon id of the lsass.exe process since this is a shared logon id for
    lsass.exe and services.exe and will lead to unresolable credentials
    conflict.

Arguments:

    CallerToken - the token of the DsRole involker

    Others -- see LsaOpenPolicy


Returns:

    STATUS_ACCESS_DENIED if the impersonattion fails.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        WinError = NetpManageIPCConnect( lpServer,
                                         lpAccount,
                                         lpPassword,
                                         fOptions );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );

    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        WinError = ERROR_ACCESS_DENIED;
    }

    return WinError;

}


DWORD
DsRolepGenerateRandomPassword(
    IN ULONG Length,
    IN WCHAR *Buffer
    )
/*++

Routine Description:

    This local function is used to generate a random password of no more than the
    specified length.  It is assumed that the destination buffer is of sufficient length.

Arguments:

    Length - Length of the buffer

    Buffer - Buffer to fill

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG PwdLength, i;
    LARGE_INTEGER Time;
    HCRYPTPROV CryptProvider = 0;


    PwdLength = Length;

    //
    // Generate a random password.
    //
    if ( CryptAcquireContext( &CryptProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT ) ) {

        if ( CryptGenRandom( CryptProvider,
                              PwdLength * sizeof( WCHAR ),
                              ( LPBYTE )Buffer ) ) {

            Buffer[ PwdLength ] = UNICODE_NULL;

            //
            // Make sure there are no NULL's in the middle of the list
            //
            for ( i = 0; i < PwdLength; i++ ) {

                if ( Buffer[ i ] == UNICODE_NULL ) {

                    Buffer[ i ] = 0xe;
                }
            }

        } else {

            Win32Err = GetLastError();
        }

        CryptReleaseContext( CryptProvider, 0 );


    } else {

        Win32Err = GetLastError();
    }

    return( Win32Err );

}
DWORD
DsRolepCopyDsDitFiles(
    IN LPWSTR DsPath
    )
/*++

Routine Description:

    This function copies the initial database files from the install point to the
    specified Ds database directory

Arguments:

    DsPath - Path where the Ds database files are to reside

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR Source[MAX_PATH + 1];
    WCHAR Dest[MAX_PATH + 1];
    ULONG SrcLen = 0, DestLen = 0;
    PWSTR Current;
    ULONG i;
    PWSTR DsDitFiles[] = {
        L"ntds.dit"
        };



    if( ExpandEnvironmentStrings( L"%WINDIR%\\system32\\", Source, MAX_PATH ) == FALSE ) {

        Win32Err = GetLastError();

    } else {

        SrcLen = wcslen( Source );
        wcscpy( Dest, DsPath );

        if ( *(Dest + (wcslen( DsPath ) - 1 )) != L'\\' ) {

            wcscat( Dest, L"\\" );
        }

        DestLen = wcslen( Dest );

    }

    //
    // Then, create the destination directory
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Current = wcschr( DsPath + 4, L'\\' );

        while ( Win32Err == ERROR_SUCCESS ) {

            if ( Current != NULL ) {

                *Current = UNICODE_NULL;

            }

            if ( CreateDirectory( DsPath, NULL ) == FALSE ) {

            
                Win32Err = GetLastError();
    
                if ( Win32Err == ERROR_ALREADY_EXISTS) {
    
                    Win32Err = ERROR_SUCCESS;
    
                } else if ( Win32Err == ERROR_ACCESS_DENIED ) {
    
                    if ( PathIsRoot(DsPath) ) {

                        //If the path given to CreateDirectory is a root path then
                        //it will fail with ERROR_ACCESS_DENIED instead of
                        //ERROR_ALREADY_EXISTS but the path is still a valid one for
                        //ntds.dit and the log files to be placed in.

                        Win32Err = ERROR_SUCCESS;

                    }
                }
            }

            if ( Current != NULL ) {

                *Current = L'\\';

                Current = wcschr( Current + 1, L'\\' );

            } else {

                break;

            }

        }
    }

    //
    // Then copy them.
    //
    for ( i = 0; i < sizeof( DsDitFiles) / sizeof( PWSTR ) && Win32Err == ERROR_SUCCESS ; i++ ) {

        wcscpy( Source + SrcLen, DsDitFiles[i] );
        wcscpy( Dest + DestLen, DsDitFiles[i] );

        DSROLEP_CURRENT_OP2( DSROLEEVT_COPY_DIT, Source, Dest );
        if ( CopyFile( Source, Dest, TRUE ) == FALSE ) {

            Win32Err = GetLastError();

            if ( Win32Err == ERROR_ALREADY_EXISTS ||
                 Win32Err == ERROR_FILE_EXISTS ) {

                Win32Err = ERROR_SUCCESS;

            } else {

                DsRolepLogPrint(( DEB_ERROR, "Failed to copy install file %ws to %ws: %lu\n",
                                  Source, Dest, Win32Err ));
            }
        }
    }

    return( Win32Err );
}


#define DSROLEP_SEC_SYSVOL   L"SYSVOL"
#define DSROLEP_SEC_DSDIT    L"DSDIT"
#define DSROLEP_SEC_DSLOG    L"DSLOG"

DWORD
DsRolepSetDcSecurity(
    IN HANDLE ClientToken,
    IN LPWSTR SysVolRootPath,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN BOOLEAN Upgrade,
    IN BOOLEAN Replica
    )
/*++

Routine Description:

    This function will invoke the security editor to set the security on the Dc install files

Arguments:

    SysVolRootPath - Root used for the system volume

    DsDatabasePath - Path to where the Ds database files go

    DsLogPath - Path to where the Ds log files go

    Upgrade - If TRUE, the machine is undergoing an upgrade

    Replica - If TRUE, the machine is going through an upgrade

Returns:

    ERROR_SUCCESS - Success

--*/
{

    DWORD Win32Err = ERROR_SUCCESS, i;
    WCHAR InfPath[ MAX_PATH + 1 ];
    PWSTR Paths[ 3 ], Tags[ 3 ];
    ULONG Options = 0;

    Paths[ 0 ] = SysVolRootPath;
    Paths[ 1 ] = DsDatabasePath;
    Paths[ 2 ] = DsLogPath;
    Tags[ 0 ] = DSROLEP_SEC_SYSVOL;
    Tags[ 1 ] = DSROLEP_SEC_DSDIT;
    Tags[ 2 ] = DSROLEP_SEC_DSLOG;

    //
    // Set the environment variables.  secedt uses the environment variables to pass around
    // information, so we will set the for the duration of this function
    //
    if ( Win32Err == ERROR_SUCCESS ) {


        ASSERT( sizeof( Paths ) / sizeof( PWSTR ) == sizeof( Tags ) / sizeof( PWSTR ) );
        for ( i = 0; i < sizeof( Paths ) / sizeof( PWSTR ) && Win32Err == ERROR_SUCCESS; i++ ) {

            if ( SetEnvironmentVariable( Tags[ i ], Paths[ i ] ) == FALSE ) {

                Win32Err = GetLastError();
                DsRolepLogPrint(( DEB_TRACE,
                                  "SetEnvironmentVariable %ws = %ws failed with %lu\n",
                                  Tags[ i ],
                                  Paths[ i ],
                                  Win32Err ));
                break;
            }
        }
    }

    //
    // Now, invoke the security editing code
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepSetAndClearLog();
        DSROLEP_CURRENT_OP0( DSROLEEVT_SETTING_SECURITY );

        Options |= Upgrade ? SCE_PROMOTE_FLAG_UPGRADE : 0;
        Options |= Replica ? SCE_PROMOTE_FLAG_REPLICA : 0;

        Win32Err = ( *DsrSceDcPromoteSecurityEx )( ClientToken,
                                                   Options,
                                                   DsRolepStringUpdateCallback );
        DsRolepSetAndClearLog();
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Setting security on Dc files failed with %lu\n",
                                               Win32Err )) );
    }


    //
    // Delete the environment variables
    //
    for ( i = 0; i < sizeof( Paths ) / sizeof( PWSTR ); i++ ) {

        if ( SetEnvironmentVariable( Tags[ i ], NULL ) == FALSE ) {

            DsRolepLogPrint(( DEB_TRACE,
                             "SetEnvironmentVariable %ws = NULL failed with %lu\n",
                             Tags[ i ],
                             GetLastError() ));
        }
    }

    //
    // Currently, setting the security will not cause the promote to fail
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        //
        // Raise an event
        //
        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         DSROLERES_FAIL_SET_SECURITY,
                         0,
                         sizeof( ULONG ),
                         &Win32Err,
                         1,
                         SCE_DCPROMO_LOG_PATH );

        DSROLEP_SET_NON_FATAL_ERROR( Win32Err );

    }

    Win32Err = ERROR_SUCCESS;

    return( Win32Err );
}




DWORD                         
DsRolepDsGetDcForAccount(
    IN LPWSTR Server OPTIONAL,
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN ULONG Flags,
    IN ULONG AccountBits,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
/*++

Routine Description:

    This function is equivalent to DsGetDcName but will search for the Dc that holds the
    specified account.

Arguments:

    ReplicaServer - The server to call GetDc on.

    Domain - Domain to find the Dc for

    Account - Account to look for.  If NULL, the current computer name is used

    Flags - Flags to bas in to the GetDc call

    AccountBits - Account control bits to search for

    DomainControllerInfo - Where the info is returned

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG Length = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // If we have no account, use the computer name
    //
    if ( Account == NULL ) {

        if ( GetComputerName( ComputerName, &Length ) == FALSE ) {

            Win32Err = GetLastError();

        } else {

            wcscat( ComputerName, SSI_SECRET_PREFIX );
            Account = ComputerName;
        }
    }

    //
    // Now, do the find
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DSROLEP_CURRENT_OP2( DSROLEEVT_FIND_DC_FOR_ACCOUNT, Domain, Account );
        Win32Err = DsGetDcNameWithAccountW( Server,
                                            Account,
                                            AccountBits,
                                            Domain,
                                            NULL,
                                            NULL,
                                            Flags,
                                            DomainControllerInfo );

        if ( ERROR_NO_SUCH_USER == Win32Err ) {

            //
            // The error should read "no machine account", not "no user"
            // since we are searching for a machine account.
            //

            Win32Err = ERROR_NO_TRUST_SAM_ACCOUNT;
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_DC,
                                 ( PWSTR ) ( ( *DomainControllerInfo )->DomainControllerName + 2 ),
                                 Domain );

        } else {

            DsRolepLogPrint(( DEB_ERROR, "Failed to find a DC for domain %ws: %lu\n",
                              Domain, Win32Err ));

        }


    }



    return( Win32Err );
}




DWORD
DsRolepSetMachineAccountType(
    IN LPWSTR Dc,
    IN HANDLE ClientToken,
    IN LPWSTR User,
    IN LPWSTR Password,
    IN LPWSTR AccountName,
    IN ULONG AccountBits,
    IN OUT WCHAR** AccountDn
    )
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    USER_INFO_1 *CurrentUI1;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG Length = MAX_COMPUTERNAME_LENGTH + 1;
    PSEC_WINNT_AUTH_IDENTITY AuthIdent = NULL;

    //
    // If we have no account, use the computer name
    //
    if ( AccountName == NULL ) {

        if ( GetComputerName( ComputerName, &Length ) == FALSE ) {

            Win32Err = GetLastError();

        } else {

            wcscat( ComputerName, SSI_SECRET_PREFIX );
            AccountName = ComputerName;
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepCreateAuthIdentForCreds( User, Password, &AuthIdent );
    }

    //
    // Call the support dll
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_TRACE, "Searching for the machine account for %ws on %ws...\n",
                           AccountName, Dc ));

        DSROLEP_CURRENT_OP0( DSROLEEVT_MACHINE_ACCT );

        DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtdsSetReplicaMachineAccount );

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( Dc && *Dc == L'\\' ) {

                Dc += 2;
            }

            Win32Err = (*DsrNtdsSetReplicaMachineAccount)( AuthIdent,
                                                           ClientToken, 
                                                           Dc,
                                                           AccountName,
                                                           AccountBits,
                                                           AccountDn );
        }

        DsRolepLogPrint(( DEB_TRACE, "NtdsSetReplicaMachineAccount returned %d\n", Win32Err ));

        DsRolepFreeAuthIdentForCreds( AuthIdent );
    }

    return( Win32Err );
}



DWORD
DsRolepForceTimeSync(
    IN HANDLE ImpToken,
    IN PWSTR TimeSource
    )
/*++

Routine Description:

    This function forces a time sync with the specified server

Arguments:

    TimeSource - Server to use for the time source

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR ServerName = NULL;
    PTIME_OF_DAY_INFO TOD;
    HANDLE ThreadToken = 0;
    TOKEN_PRIVILEGES Enabled, Previous;
    DWORD PreviousSize;
    TIME_FIELDS TimeFields;
    LARGE_INTEGER SystemTime;

    BOOL connected=FALSE;
    NETRESOURCE NetResource;
    WCHAR *remotename=NULL;

    BOOL fSuccess = FALSE;

    if ( !TimeSource ) {
        Win32Err = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    //
    // Build the server name with preceeding \\'s
    //
    if ( *TimeSource != L'\\' ) {

        ServerName = RtlAllocateHeap( RtlProcessHeap(), 0,
                                      ( wcslen( TimeSource ) + 3 ) * sizeof( WCHAR ) );

        if ( ServerName == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            DsRolepLogPrint(( DEB_ERROR, "Failed to open a NULL session with %ws for time sync.  Out of Memory. Failed with %d\n",
                             TimeSource,
                             Win32Err ));
            goto cleanup;

        } else {

            swprintf( ServerName, L"\\\\%ws", TimeSource );
        }

    } else {

        ServerName = TimeSource;
    }

    //
    // Enable the systemtime privilege
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_READ | TOKEN_WRITE,
                                    TRUE,
                                    &ThreadToken );

        if ( Status == STATUS_NO_TOKEN ) {

            Status = NtOpenProcessToken( NtCurrentProcess(),
                                         TOKEN_WRITE | TOKEN_READ,
                                         &ThreadToken );
        }

        if ( NT_SUCCESS( Status ) ) {

            Enabled.PrivilegeCount = 1;
            Enabled.Privileges[0].Luid.LowPart = SE_SYSTEMTIME_PRIVILEGE;
            Enabled.Privileges[0].Luid.HighPart = 0;
            Enabled.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            PreviousSize = sizeof( Previous );

            Status = NtAdjustPrivilegesToken( ThreadToken,
                                              FALSE,
                                              &Enabled,
                                              sizeof( Enabled ),
                                              &Previous,
                                              &PreviousSize );
            //
            // Since we modified the thread token and the thread is shortlived, we won't bother
            // restoring it later.
            //
        }

        if ( ThreadToken ) {

            NtClose( ThreadToken );
            
        }



        Win32Err = RtlNtStatusToDosError( Status );
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Failed to enable the SE_SYSTEMTIME_PRIVILEGE: %lu\n",
                                               Win32Err )) );

    }


    //
    // Get the remote time
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DSROLEP_CURRENT_OP1( DSROLEEVT_TIMESYNC, TimeSource );

        fSuccess = ImpersonateLoggedOnUser( ImpToken );
        if ( !fSuccess ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to impersonate caller, error %lu\n",
                              GetLastError() ));
        
            //
            // We couldn't impersonate?
            //
            

            // We will continue anyway

        }
        
    }
    


    remotename = RtlAllocateHeap(
                  RtlProcessHeap(), 0,
                   sizeof(WCHAR)*(wcslen(L"\\ipc$")+wcslen(ServerName)+1));
    if ( remotename == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;
        DsRolepLogPrint(( DEB_ERROR, "Failed to open a NULL session with %ws for time sync.  Out of Memory. Failed with %d\n",
                             ServerName,
                             Win32Err ));
        
    } 
                                                                            
    wsprintf(remotename,L"%s\\ipc$",ServerName);
    
    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;
    
    //get permission to access the server
    Win32Err=WNetAddConnection2W(&NetResource,
                             L"",
                             L"",
                             0);
    if ( Win32Err == NO_ERROR ) {
        connected=TRUE;
    }
    else {
        DsRolepLogPrint(( DEB_WARN, "Failed to open a NULL session with %ws for time sync.  Failed with %d\n",
                         ServerName,
                         Win32Err ));
        //We will attempt to Time sync anyway
    }

    Win32Err = NetRemoteTOD( ServerName, ( LPBYTE * )&TOD );

    if ( Win32Err == ERROR_SUCCESS ) {

        TimeFields.Hour = ( WORD )TOD->tod_hours;
        TimeFields.Minute = ( WORD )TOD->tod_mins;
        TimeFields.Second = ( WORD )TOD->tod_secs;
        TimeFields.Milliseconds = ( WORD )TOD->tod_hunds * 10;
        TimeFields.Day = ( WORD )TOD->tod_day;
        TimeFields.Month = ( WORD )TOD->tod_month;
        TimeFields.Year = ( WORD )TOD->tod_year;

        if ( !RtlTimeFieldsToTime( &TimeFields, &SystemTime ) ) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            if ( connected ) {
                WNetCancelConnection2(remotename,
                                  0,
                                  TRUE);
            }
        
            if( remotename ) {
        
                RtlFreeHeap( RtlProcessHeap(), 0, remotename );
        
            }
        
            fSuccess = RevertToSelf();
            ASSERT( fSuccess );
            connected=FALSE;

            Status = NtSetSystemTime( &SystemTime, NULL );

            if ( !NT_SUCCESS( Status ) ) {

                DsRolepLogPrint(( DEB_ERROR, "NtSetSystemTime failed with 0x%lx\n", Status ));
            }


        }
    

        Win32Err = RtlNtStatusToDosError( Status );

        NetApiBufferFree( TOD );

    } else {

        DsRolepLogPrint(( DEB_ERROR, "Failed to get the current time on %ws: %lu\n",
                          TimeSource, Win32Err ));

    }
    
            
        
        
    //
    // For the IDS, consider a failure here non-fatal
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "NON-FATAL error forcing a time sync (%lu).  Ignoring\n",
                          Win32Err ));
        Win32Err = ERROR_SUCCESS;

    }

    cleanup:

    if ( connected ) {
        WNetCancelConnection2(remotename,
                          0,
                          TRUE);
    

        if( remotename ) {
    
            RtlFreeHeap( RtlProcessHeap(), 0, remotename );
    
        }
    
        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    }

    
    return( Win32Err );
}




NTSTATUS
DsRolepGetMixedModeFlags(
    IN PSID DomainSid,
    OUT PULONG Flags
    )
/*++

Routine Description:

    This routine will determine whether the machine is currently in mixed mode or not

Arguments:

    Flags - Pointer to a flags value to be altered.  If the machine is a mixed mode, we simply
        or in the proper value.

Return Values:

    NTSTATUS        

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN mixedDomain;

    Status = SamIMixedDomain2( DomainSid, &mixedDomain );

    if ( NT_SUCCESS( Status ) && mixedDomain) {
        *Flags |= DSROLE_PRIMARY_DS_MIXED_MODE;
    }

    return( Status );
}


BOOL
DsRolepShutdownNotification(
    DWORD   dwCtrlType
    )
/*++

Routine Description:

    This routine is called by the system when system shutdown is occuring.

    It stops a role change if one is in progress.
    
Arguments:

    dwCtrlType -- the notification


Return Value:

    FALSE - to allow any other shutdown routines in this process to
        also be called.

--*/
{
    if ( dwCtrlType == CTRL_SHUTDOWN_EVENT ) {

        //
        // Cancel the operation
        // 
        (VOID) DsRolepCancel( FALSE );  // Don't block

    }

    return FALSE;
}

DWORD
DsRolepDeregisterNetlogonDnsRecords(
    PNTDS_DNS_RR_INFO pInfo
    )
/*++

Routine Description:

    This routine is called during demotion to call netlogon to deregister
    its the service DNS records for this domain controller
   
Arguments:

    pInfo -- structure containing the parameters for the deregistration

Return Value:

    An error from DsDeregisterDnsHostRecordsW

--*/
{

    DWORD WinError = ERROR_SUCCESS;
    HKEY  hNetlogonParms = NULL;
    BOOL  fDoDeregistration = TRUE;

    if ( !pInfo ) {
        return STATUS_SUCCESS;
    }

#define NETLOGON_PATH L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
#define AVOID_DNS_DEREG_KEY L"AvoidDnsDeregOnShutdown"

    WinError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             NETLOGON_PATH,
                             0,
                             KEY_READ,
                             &hNetlogonParms );

    if ( ERROR_SUCCESS == WinError ) {

        DWORD val = 0;
        DWORD len = sizeof(DWORD);
        DWORD type;

        WinError = RegQueryValueEx( hNetlogonParms,
                                    AVOID_DNS_DEREG_KEY,
                                    0,
                                    &type,
                                    (BYTE*)&val,
                                    &len );

        if ( (ERROR_SUCCESS == WinError)
         &&  (type == REG_DWORD)
         &&  (val == 0)       ) {

            //
            // Don't bother; netlogon has already done the deregistration.
            //
            fDoDeregistration = FALSE;
        }

        RegCloseKey( hNetlogonParms );
    }

    if ( fDoDeregistration ) { 

        //
        // Ask netlogon to do the deregistration
        //
        WinError = DsDeregisterDnsHostRecordsW( NULL, // go local
                                                pInfo->DnsDomainName,
                                                &pInfo->DomainGuid,
                                                &pInfo->DsaGuid,
                                                pInfo->DnsHostName );
    } else {

        WinError = ERROR_SUCCESS;

    }

    return WinError;

}

NTSTATUS
ImpLsaDelete(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaDelete( ObjectHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );

    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaQueryInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            InformationClass,
                                            Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;
}


NTSTATUS
ImpLsaOpenTrustedDomainByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaOpenTrustedDomainByName( PolicyHandle,
                                             TrustedDomainName,
                                             DesiredAccess,
                                             TrustedDomainHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaOpenTrustedDomain(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaOpenTrustedDomain( PolicyHandle,
                                       TrustedDomainSid,
                                       DesiredAccess,
                                       TrustedDomainHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}


NTSTATUS
ImpLsaCreateTrustedDomainEx(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaCreateTrustedDomainEx( PolicyHandle,
                                           TrustedDomainInformation,
                                           AuthenticationInformation,
                                           DesiredAccess,
                                           TrustedDomainHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaQueryTrustedDomainInfoByName(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryTrustedDomainInfoByName( PolicyHandle,
                                                  TrustedDomainName,
                                                  InformationClass,
                                                  Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}


NTSTATUS
ImpLsaQueryDomainInformationPolicy(
    IN HANDLE CallerToken,
    IN LSA_HANDLE PolicyHandle,
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    OUT PVOID *Buffer
    )
/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaQueryDomainInformationPolicy( PolicyHandle,
                                                  InformationClass,
                                                  Buffer );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}

NTSTATUS
ImpLsaClose(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This routine is a wrapper for the Lsa call.  See The comments for
    ImpOpenLsaPolicy for details.                                                              

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fSuccess;

    fSuccess = ImpersonateLoggedOnUser( CallerToken );
    if ( fSuccess ) {

        Status = LsaClose( ObjectHandle );

        fSuccess = RevertToSelf();
        ASSERT( fSuccess );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to impersonate caller, error %lu\n",
                          GetLastError() ));

        //
        // We couldn't impersonate?
        //
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\sysvol.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sysvol.c

Abstract:

    Miscellaneous routines to manage and manipulate the system volume tree

Author:

    Mac McLain          (MacM)       Oct 16, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <loadfn.h>
#include <ntfrsipi.h>
#include <shlwapi.h>
#include "sysvol.h"

//
// Local function prototypes
//
DWORD
DsRolepCreateSysVolLinks(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName
    );

DWORD
DsRolepRemoveDirectoryOrLink(
    IN  LPWSTR Path
    );

DWORD
DsRolepTreeCopy(
    IN LPWSTR Source,
    IN LPWSTR Dest
    );

DWORD
DsRolepValidatePath(
    IN  LPWSTR Path,
    IN  ULONG ValidationCriteria,
    OUT PULONG MatchingCriteria
    )
/*++

Routine Description:

    This function will validate the path against the specified criteria.  This can include
    whether it is local or not, whether it is NTFS, etc.

    If the function returns success, the MatchingCriteria can be examined to find out which
    of the ValidationCriteria are set

Arguments:

    Path - Path to validate

    ValidationCriteria - What to check for.  Refer to DSROLEP_PATH_VALIDATE_*.

    MatchingCriteria - This is where the indications of validity are returned.  If the path
        meets the check, the corresponding bit from the ValidationCriteria is turned on
        here.


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    DWORD Info, Flags, Len;
    WCHAR PathRoot[ 4 ];
    WCHAR Type[ 6 ];

    DsRolepLogPrint(( DEB_TRACE,
                      "Validating path %ws.\n",
                      Path ));


    *MatchingCriteria = 0;
    if ( FLAG_ON( ValidationCriteria, DSROLEP_PATH_VALIDATE_EXISTENCE ) ) {

        Info = GetFileAttributes( Path );

        if ( Info == 0xFFFFFFFF ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_ERROR,
                              "\tCan't get file attributes (%lu)\n",
                              Win32Err ));

        } else if ( FLAG_ON( Info, FILE_ATTRIBUTE_DIRECTORY ) ) {

            *MatchingCriteria |= DSROLEP_PATH_VALIDATE_EXISTENCE;

            DsRolepLogPrint(( DEB_TRACE,
                              "\tPath is a directory\n" ));
        } else {

            DsRolepLogPrint(( DEB_WARN,
                              "\tPath is a NOT directory\n" ));

        }

    }

    if ( Win32Err == ERROR_SUCCESS ) {

        wcsncpy( PathRoot, Path, 3 );
        PathRoot[ 3 ] = UNICODE_NULL;
    }

    if ( Win32Err == ERROR_SUCCESS &&
         FLAG_ON( ValidationCriteria, DSROLEP_PATH_VALIDATE_LOCAL ) ) {

        Info = GetDriveType( PathRoot );

        if ( Info == DRIVE_FIXED ) {

            *MatchingCriteria |= DSROLEP_PATH_VALIDATE_LOCAL;

            DsRolepLogPrint(( DEB_TRACE,
                              "\tPath is on a fixed disk drive.\n" ));
        } else {

            DsRolepLogPrint(( DEB_WARN,
                              "\tPath is NOT on a fixed disk drive.\n" ));
        }
    }

    if ( Win32Err == ERROR_SUCCESS &&
         FLAG_ON( ValidationCriteria, DSROLEP_PATH_VALIDATE_NTFS ) ) {

        if ( GetVolumeInformation( PathRoot, NULL, 0, NULL, &Len,
                                   &Flags, Type, sizeof( Type ) / sizeof( WCHAR ) ) == FALSE ) {

           Win32Err = GetLastError();

           //
           // If we've already failed to validate the information, we'll return ERROR_SUCCESS.
           //
           if ( *MatchingCriteria != ( ValidationCriteria & ~DSROLEP_PATH_VALIDATE_NTFS ) ) {

               Win32Err = ERROR_SUCCESS;
           } else {

               DsRolepLogPrint(( DEB_TRACE,
                                 "\tCan't determine if path is on an NTFS volume.\n" ));
           }

        } else {

           if ( _wcsicmp( Type, L"NTFS" ) == 0 ) {

               *MatchingCriteria |= DSROLEP_PATH_VALIDATE_NTFS;

               DsRolepLogPrint(( DEB_TRACE,
                                 "\tPath is on an NTFS volume\n" ));
           } else {

               DsRolepLogPrint(( DEB_WARN,
                                 "\tPath is NOT on an NTFS volume\n" ));

           }
        }
    }

    return( Win32Err );
}


#define DSROLEP_SV_SYSVOL       L"sysvol"
#define DSROLEP_SV_DOMAIN       L"domain"
#define DSROLEP_SV_STAGING_AREA L"staging areas"
#define DSROLEP_SV_STAGING      L"staging"
#define DSROLEP_SV_SCRIPTS      L"scripts"

#define DSROLEP_LONG_PATH_PREFIX    L"\\\\?\\"
DWORD
DsRolepCreateSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FrsReplicaServer, OPTIONAL
    IN  LPWSTR Account,
    IN  LPWSTR Password,
    IN  PWSTR Site,
    IN  BOOLEAN FirstDc
    )
/*++

Routine Description:

    This function will create the system volume tree for use by NTFRS.

Arguments:

    Path - Root path under which to create the system volume tree

    DnsDomainName - Dns domain name

    FrsReplicaServer - The OPTIONAL name of the server to replicate the sysvol from

    Site - Site this Dc is in

    FirstDc - If TRUE, this is the first Dc in a domain

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    PWSTR RelativePaths[] = {
        DSROLEP_SV_DOMAIN,
        DSROLEP_SV_DOMAIN L"\\" DSROLEP_SV_SCRIPTS,  // DO NOT CHANGE THIS POSITION without also
                                                     // updating ScriptsIndex below
        DSROLEP_SV_STAGING_AREA,
        DSROLEP_SV_STAGING,
        DSROLEP_SV_STAGING L"\\" DSROLEP_SV_DOMAIN,
        DSROLEP_SV_SYSVOL                           // This must always be the last thing
                                                    // in the list

        };
    ULONG ScriptsIndex = 1; // DO NOT CHANGE THIS with out changing the position of the
                            // DOMAIN\\SCRIPTS entry above
    PWSTR CreatePath = NULL, PathEnd = NULL;
    PWSTR StagingPath = NULL, StagingPathEnd;
    ULONG MaxPathLen, i;
    BOOLEAN RootCreated = FALSE;

    //
    // Make sure the buffer is big enough to hold everything.  The
    // longest path is the domain root under the staging area
    //
    MaxPathLen = sizeof( DSROLEP_LONG_PATH_PREFIX ) +
                 ( wcslen( Path ) * sizeof( WCHAR ) ) +
                 sizeof( WCHAR ) +
                 sizeof( DSROLEP_SV_STAGING_AREA ) +
                 sizeof( WCHAR ) +
                 ( ( wcslen( DnsDomainName ) + 1 ) * sizeof( WCHAR ) );




    CreatePath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

    if ( CreatePath == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // The path exceeds max path, so prepend the \\?\ that allows
        // for paths greater than max path
        //
        if ( MaxPathLen > MAX_PATH * sizeof( WCHAR ) ) {

            swprintf( CreatePath,
                      L"\\\\?\\%ws",
                      Path );

        } else {

            wcscpy( CreatePath, Path );
        }
    }



    //
    // Create the root path, if it doesn't exist
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        PathEnd = CreatePath + wcslen( CreatePath );

         if ( CreateDirectory( CreatePath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            if ( Win32Err == ERROR_ALREADY_EXISTS) {

                //
                // The path exists, so delete it...
                //
                DsRolepLogPrint(( DEB_TRACE,
                                  "Deleting current sysvol path %ws \n",
                                  CreatePath ));
                Win32Err = DsRolepDelnodePath( CreatePath,
                                               MaxPathLen,
                                               FALSE );

                if ( Win32Err == ERROR_INVALID_PARAMETER ) {

                    Win32Err = ERROR_SUCCESS;
                }

            } else if ( Win32Err == ERROR_ACCESS_DENIED && PathIsRoot(CreatePath) ){

                //The sysvol cannot be path at a root directry (i.e. d:\)
                //note: d:\sysvol would be legal
                DSROLEP_FAIL0( Win32Err, DSROLERES_FAILED_SYSVOL_CANNOT_BE_ROOT_DIRECTORY )
                goto Exit;

            } else {

                DsRolepLogPrint(( DEB_TRACE,
                                  "Failed to create path %ws: %lu\n",
                                  CreatePath,
                                  Win32Err ));
            }

        } else {

            RootCreated = TRUE;

        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *PathEnd = L'\\';
        PathEnd++;
    } else {

        //
        // Bail, with a specific error
        //
        DSROLEP_FAIL0( Win32Err, DSROLERES_SYSVOL_DIR_ERROR )

        goto Exit;

    }

    //
    // Now, create the rest of the paths...
    //
    for ( i = 0;
          i < sizeof( RelativePaths ) / sizeof( PWSTR ) &&
            Win32Err == ERROR_SUCCESS;
          i++ ) {


        //
        // Only create the scripts directory on the first dc
        //
        if ( i == ScriptsIndex && !FirstDc ) {

            continue;
        }
        wcscpy( PathEnd, RelativePaths[ i ] );

        if( CreateDirectory( CreatePath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to create path %ws: %lu\n",
                               CreatePath,
                               Win32Err ));
            break;


        }
    }

    //
    // Then, create the symbolic links
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        *PathEnd = UNICODE_NULL;
        Win32Err = DsRolepCreateSysVolLinks( Path, DnsDomainName );
    }

    //
    // Prepare for replication of sysvol
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Make sure the path for the staging area is large enough
        //
        StagingPath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

        if ( StagingPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // The path exceeds max path, so prepend the \\?\ that allows
            // for paths greater than max path
            //
            swprintf( StagingPath,
                      L"\\\\?\\%ws",
                      Path );
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            StagingPathEnd = StagingPath + wcslen( StagingPath );

            if ( *StagingPathEnd != L'\\' ) {

                *StagingPathEnd = L'\\';
                StagingPathEnd++;
            }

            DSROLE_GET_SETUP_FUNC( Win32Err, DsrNtFrsApi_PrepareForPromotionW );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( DsrNtFrsApi_PrepareForPromotionW );
                Win32Err = ( *DsrNtFrsApi_PrepareForPromotionW )( DsRolepStringErrorUpdateCallback );

                if ( Win32Err == ERROR_SUCCESS ) {

                    //
                    // Build the domain sysvol
                    //
                    swprintf( StagingPathEnd,
                              L"%ws\\%ws",
                              DSROLEP_SV_STAGING_AREA,
                              DnsDomainName );

                    swprintf( PathEnd,
                              L"%ws\\%ws",
                              DSROLEP_SV_SYSVOL,
                              DnsDomainName );

                    Win32Err = ( *DsrNtFrsApi_StartPromotionW )(
                                   FrsReplicaServer,
                                   Account,
                                   Password,
                                   DsRolepStringUpdateCallback,
                                   DsRolepStringErrorUpdateCallback,
                                   DnsDomainName,
                                   NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                   FirstDc,
                                   StagingPath,
                                   CreatePath );

                    if ( Win32Err != ERROR_SUCCESS ) {


                        DsRolepLogPrint(( DEB_ERROR,
                                          "NtFrsApi_StartPromotionW on %ws / %ws / %ws failed with %lu\n",
                                          DnsDomainName,
                                          StagingPath,
                                          CreatePath,
                                          Win32Err ));
                        Win32Err2 = DsRolepFinishSysVolPropagation( FALSE, TRUE );
                        ASSERT( Win32Err2 == ERROR_SUCCESS );
                    }

                } else {

                    DsRolepLogPrint(( DEB_ERROR,
                                      "NtFrsApi_PrepareForPromotionW failed with %lu\n",
                                      Win32Err ));

                }
            }

        }
    }

    //
    // If something failed, delete the created sysvol tree
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        Win32Err2 = DsRolepDelnodePath( CreatePath,
                                        MaxPathLen,
                                        RootCreated );

        if ( Win32Err2 != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_TRACE,
                              "Failed to delete path %ws: %lu\n",
                              CreatePath,
                              Win32Err2 ));
        }

    }

Exit:

    //
    // Free the path buffers if allocated
    //
    if ( CreatePath  ) {

        RtlFreeHeap( RtlProcessHeap(), 0, CreatePath );
    }

    if ( StagingPath  ) {

        RtlFreeHeap( RtlProcessHeap(), 0, StagingPath );
    }

    return( Win32Err );
}

DWORD
DsRolepRemoveSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  GUID *DomainGuid
    )
/*++

Routine Description:

    This function will remote the create system volume tree

Arguments:

    Path - Root path under which to create the system volume tree

    DnsDomainName - Dns domain name

    DomainGuid - The Guid of the new domain

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    //
    // If we can't reset the FRS domain guid, do NOT remove the tree.  Otherwise, this
    // delete will propagate around!
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepDelnodePath( Path, ( wcslen( Path ) + 1 ) * sizeof( WCHAR ), TRUE );
    }

    return( Win32Err );
}



#define DSROLEP_ALL_STR L"\\*.*"
DWORD
DsRolepDelnodePath(
    IN  LPWSTR Path,
    IN  ULONG BufferSize,
    IN  BOOLEAN DeleteRoot
    )
/*++

Routine Description:

    This function removes the specified file path

Arguments:

    Path - Root path to delete

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    ULONG Len, PathLen = wcslen( Path );
    PWSTR FullPath, FindPath;
    WCHAR PathBuff[ MAX_PATH + 1];


    //
    // See if we need to allocate a buffer
    //
    Len = sizeof( DSROLEP_ALL_STR ) + ( PathLen * sizeof( WCHAR ) );
    if ( BufferSize >= Len ) {

        FindPath = Path;
        wcscat( FindPath, DSROLEP_ALL_STR );

    } else {

        FindPath = RtlAllocateHeap( RtlProcessHeap(), 0, Len );

        if ( FindPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            swprintf( FindPath, L"%ws%ws", Path, DSROLEP_ALL_STR );
        }
    }


    if ( Win32Err == ERROR_SUCCESS ) {

        FindHandle = FindFirstFile( FindPath, &FindData );

        if ( FindHandle == INVALID_HANDLE_VALUE ) {

            Win32Err = GetLastError();

            //
            // If we get back a path not found error, it's probably a link that we delete the
            // supporting storage for.  This is not considered an error.
            //
            if ( Win32Err == ERROR_PATH_NOT_FOUND ) {

                Win32Err = ERROR_NO_MORE_FILES;
            }


            if ( Win32Err != ERROR_SUCCESS && Win32Err != ERROR_NO_MORE_FILES ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "FindFirstFile on %ws failed with %lu\n",
                                  FindPath, Win32Err ));
            }

        }

    }


    while ( Win32Err == ERROR_SUCCESS ) {

        if ( wcscmp( FindData.cFileName, L"." ) &&
             wcscmp( FindData.cFileName, L".." ) ) {

            Len = ( wcslen( FindData.cFileName ) + 1 + PathLen + 1 ) * sizeof( WCHAR );

            if ( Len > sizeof( FullPath ) ) {

                FullPath = RtlAllocateHeap( RtlProcessHeap(), 0, Len );

                if ( FullPath == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                }

            } else {

                FullPath = PathBuff;
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                Path[ PathLen ] = UNICODE_NULL;
                swprintf( FullPath, L"%ws\\%ws", Path, FindData.cFileName );


                if ( FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) ) {

                    Win32Err = DsRolepDelnodePath( FullPath, Len, TRUE );

                } else {

                    //
                    //  Remove the readonly/hidden bits
                    //
                    SetFileAttributes( FullPath,
                                       FILE_ATTRIBUTE_NORMAL );


                    if ( DeleteFileW( FullPath ) == FALSE ) {

                        Win32Err = GetLastError();
                        if ( Win32Err != ERROR_SUCCESS ) {

                            DsRolepLogPrint(( DEB_ERROR,
                                              "DeleteFileW on %ws failed with %lu\n",
                                              FullPath, Win32Err ));
                        }
                    }
                }
            }

            if ( FullPath != PathBuff ) {

                RtlFreeHeap( RtlProcessHeap(), 0, FullPath );
            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( FindNextFile( FindHandle, &FindData ) == FALSE ) {

                Win32Err = GetLastError();
            }

            if ( Win32Err != ERROR_SUCCESS && Win32Err != ERROR_NO_MORE_FILES ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "FindNextFile after on %ws failed with %lu\n",
                                  FindData.cFileName, Win32Err ));
            }
        }
    }

    //
    // Close the handle before trying to remove the directory
    //
    if ( FindHandle != INVALID_HANDLE_VALUE ) {

        FindClose( FindHandle );
    }

    if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_NO_MORE_FILES ) {

        Win32Err = ERROR_SUCCESS;

    }

    //
    // Remove the directory
    //
    if ( DeleteRoot && Win32Err == ERROR_SUCCESS ) {


        Win32Err = DsRolepRemoveDirectoryOrLink( Path );

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Removal of path %ws failed with %lu\n",
                              Path, Win32Err ));
        }
    }

    //
    // Cleanup
    //
    if ( FindPath != Path ) {

        RtlFreeHeap( RtlProcessHeap(), 0, FindPath );
    }

    return( Win32Err );
}



DWORD
DsRolepRemoveDirectoryOrLink(
    IN  LPWSTR Path
    )
/*++

Routine Description:

    This function removes the symbolic link or directory indicated

Arguments:

    Path - Path to remove


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Attributes;
    UNICODE_STRING NtPath;
    OBJECT_ATTRIBUTES ObjectAttrs;
    HANDLE Handle;
    IO_STATUS_BLOCK IOSb;
    FILE_DISPOSITION_INFORMATION Disposition = {
        TRUE
        };

    Attributes = GetFileAttributes( Path );
    Attributes &= ~( FILE_ATTRIBUTE_HIDDEN    |
                        FILE_ATTRIBUTE_SYSTEM |
                        FILE_ATTRIBUTE_READONLY );

    if ( !SetFileAttributes( Path, Attributes ) ) {

        return( GetLastError() );
    }

    //
    // Initialize
    //
    NtPath.Buffer = NULL;

    //
    // Convert the name
    //
    if ( RtlDosPathNameToNtPathName_U( Path, &NtPath, NULL, NULL ) == FALSE ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Open the object
    //
    if ( NT_SUCCESS( Status ) ) {

        InitializeObjectAttributes( &ObjectAttrs, &NtPath, OBJ_CASE_INSENSITIVE, NULL, NULL );

        Status = NtOpenFile( &Handle,
                             SYNCHRONIZE | FILE_READ_DATA | DELETE,
                             &ObjectAttrs,
                             &IOSb,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN_FOR_BACKUP_INTENT            |
                                    FILE_OPEN_REPARSE_POINT         |
                                    FILE_SYNCHRONOUS_IO_NONALERT );


        if ( NT_SUCCESS( Status ) ) {

            Status = NtSetInformationFile( Handle,
                                           &IOSb,
                                           &Disposition,
                                           sizeof( Disposition ),
                                           FileDispositionInformation );

            NtClose( Handle );
        }
    }

    //
    // Free the memory
    //
    if ( NtPath.Buffer ) {

        RtlFreeUnicodeString( &NtPath );
    }


    if ( !NT_SUCCESS( Status )  ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to delete %ws: 0x%lx\n",
                          Path,
                          Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}


#pragma warning(push)
#pragma warning(disable:4701)


DWORD
DsRolepCreateSymLink(
    IN  LPWSTR LinkPath,
    IN  LPWSTR LinkValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING Link, Value, DosValue;
    OBJECT_ATTRIBUTES ObjectAttrs;
    HANDLE Handle;
    IO_STATUS_BLOCK IOSb;
    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer = NULL;
    ULONG Len;

    //
    // Initialize
    //
    Link.Buffer = NULL;
    Value.Buffer = NULL;

    //
    // Convert the names
    //
    if ( RtlDosPathNameToNtPathName_U( LinkPath, &Link, NULL, NULL ) ) {

        if ( RtlDosPathNameToNtPathName_U( LinkValue, &Value, NULL, NULL ) ) {

            RtlInitUnicodeString( &DosValue, LinkValue );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Open the object
    //
    if ( NT_SUCCESS( Status ) ) {

        InitializeObjectAttributes( &ObjectAttrs, &Link, OBJ_CASE_INSENSITIVE, NULL, NULL );
        Status = NtCreateFile( &Handle,
                               SYNCHRONIZE | FILE_WRITE_DATA,
                               &ObjectAttrs,
                               &IOSb,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_OPEN_REPARSE_POINT,
                               NULL,
                               0 );

        if ( NT_SUCCESS( Status ) ) {

            Len = ( FIELD_OFFSET( REPARSE_DATA_BUFFER,
                                 MountPointReparseBuffer.PathBuffer ) -
                    REPARSE_DATA_BUFFER_HEADER_SIZE ) +
                    Value.Length + sizeof(UNICODE_NULL) +
                    DosValue.Length + sizeof(UNICODE_NULL);

            ReparseBufferHeader = RtlAllocateHeap( RtlProcessHeap(),
                                                   0,
                                                   REPARSE_DATA_BUFFER_HEADER_SIZE + Len );
            if ( ReparseBufferHeader == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                ReparseBufferHeader->ReparseDataLength = (USHORT)Len;
                ReparseBufferHeader->Reserved = 0;
                ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
                ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength =
                                                            Value.Length;
                ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset =
                                                            Value.Length + sizeof( UNICODE_NULL );
                ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength =
                                                            DosValue.Length;
                RtlCopyMemory( ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                               Value.Buffer,
                               Value.Length );

                RtlCopyMemory( (PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                                    Value.Length + sizeof(UNICODE_NULL),
                                DosValue.Buffer,
                                DosValue.Length );

                ReparseBufferHeader->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;

                Status = NtFsControlFile( Handle,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &IOSb,
                                          FSCTL_SET_REPARSE_POINT,
                                          ReparseBufferHeader,
                                          REPARSE_DATA_BUFFER_HEADER_SIZE +
                                                           ReparseBufferHeader->ReparseDataLength,
                                          NULL,
                                          0 );

                RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );

            }

            NtClose( Handle );
        }

    }
    //
    // Free any allocated strings
    //
    if ( Link.Buffer ) {

        RtlFreeUnicodeString( &Link );
    }

    if ( Value.Buffer ) {

        RtlFreeUnicodeString( &Value );
    }

    if ( !NT_SUCCESS( Status )  ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to create the link between %ws and %ws: 0x%lx\n",
                          LinkPath,
                          LinkValue,
                          Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}

#pragma warning(pop)



DWORD
DsRolepCreateSysVolLinks(
    IN  LPWSTR Path,
    IN  PWSTR DnsDomainName
    )
/*++

Routine Description:

    This function creates the symbolic links used by the system volume tree

Arguments:

    Path - Root path under which to create the links

    DnsDomainName - The Dns domain name of the new domain


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR DestPathBuf[ MAX_PATH + 5];
    WCHAR LinkPathBuf[ MAX_PATH + 5];
    PWSTR DestPath = DestPathBuf, LinkPath = LinkPathBuf;
    PWSTR DestPathEnd = NULL, LinkPathEnd = NULL;
    ULONG MaxPathLen, DnsDomainNameSize, Len = wcslen( Path );


    if ( * ( Path + Len - 1 ) == L'\\' ) {

        Len--;
        *( Path + Len ) = UNICODE_NULL;
    }

    //
    // The longest destination path is the path\\staging\\DnsDomainName
    //
    MaxPathLen = (ULONG)(( sizeof( DSROLEP_SV_STAGING L"\\" ) + 1 ) +
                 ( ( wcslen ( DnsDomainName ) + 1 ) * sizeof( WCHAR ) ) +
                 ( ( Len + 5 ) * sizeof( WCHAR ) ));

    if ( MaxPathLen > sizeof( DestPathBuf ) / 4 ) {

        DestPath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

        if ( DestPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // The path exceeds max path, so prepend the \\?\ that allows
            // for paths greater than max path
            //
            swprintf( DestPath,
                      L"\\\\?\\%ws\\",
                      Path );
        }

    } else {

        swprintf( DestPath, L"%ws\\", Path );
    }



    //
    // The longest link path is the domain named one
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        DestPathEnd = DestPath + wcslen( DestPath );

        DnsDomainNameSize = wcslen( DnsDomainName ) * sizeof( WCHAR );

        MaxPathLen = (ULONG)(sizeof( DSROLEP_SV_STAGING_AREA )  + 1 +
                     sizeof( DSROLEP_SV_SYSVOL ) +
                     ( ( wcslen( Path ) + 5 ) * sizeof( WCHAR ) )+
                     DnsDomainNameSize);

        if ( MaxPathLen > sizeof( LinkPathBuf ) / 4 ) {

            LinkPath = RtlAllocateHeap( RtlProcessHeap(), 0, MaxPathLen );

            if ( LinkPath == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                //
                // The path exceeds max path, so prepend the \\?\ that allows
                // for paths greater than max path
                //
                swprintf( LinkPath,
                          L"\\\\?\\%ws\\%ws\\",
                          Path,
                          DSROLEP_SV_SYSVOL );
            }

        } else {

            swprintf( LinkPath, L"%ws\\%ws\\", Path, DSROLEP_SV_SYSVOL );
        }

    }

    //
    // Then, the domain path
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        LinkPathEnd = LinkPath + wcslen( LinkPath );

        wcscpy( DestPathEnd, DSROLEP_SV_DOMAIN );
        wcscpy( LinkPathEnd, DnsDomainName );

        if ( CreateDirectory( LinkPath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to create the link directory %ws: %lu\n",
                              LinkPath,
                              Win32Err ));
        } else {

            Win32Err = DsRolepCreateSymLink( LinkPath, DestPath );
        }
    }

    //
    // Finally, the domain link for the staging area.
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        LinkPathEnd--;
        while ( *( LinkPathEnd - 1 ) != L'\\' ) {

            LinkPathEnd--;
        }

        swprintf( DestPathEnd, L"%ws\\%ws", DSROLEP_SV_STAGING, DSROLEP_SV_DOMAIN  );
        swprintf( LinkPathEnd, L"%ws\\%ws", DSROLEP_SV_STAGING_AREA, DnsDomainName );

        if ( CreateDirectory( LinkPath, NULL ) == FALSE ) {

            Win32Err = GetLastError();

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to create the link directory %ws: %lu\n",
                              LinkPath,
                              Win32Err ));
        } else {

            Win32Err = DsRolepCreateSymLink( LinkPath, DestPath );
        }
    }

    //
    // Clean up any allocated buffers
    //
    if ( DestPath != DestPathBuf ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DestPath );
    }

    if ( LinkPath != LinkPathBuf ) {

        RtlFreeHeap( RtlProcessHeap(), 0, LinkPath );
    }

    return( Win32Err );
}



#define DSROLEP_FRS_PATH        \
L"\\Registry\\Machine\\System\\CurrentControlSet\\services\\NtFrs\\parameters\\sysvol\\"
#define DSROLEP_FRS_COMMAND     L"ReplicaSetCommand"
#define DSROLEP_FRS_NAME        L"ReplicaSetName"
#define DSROLEP_FRS_TYPE        L"ReplicaSetType"
#define DSROLEP_FRS_SITE        L"ReplicaSetSite"
#define DSROLEP_FRS_PRIMARY     L"ReplicaSetPrimary"
#define DSROLEP_FRS_STAGE       L"ReplicationStagePath"
#define DSROLEP_FRS_ROOT        L"ReplicationRootPath"
#define DSROLEP_FRS_CREATE      L"Create"
#define DSROLEP_FRS_DELETE      L"Delete"

#define DSROLEP_NETLOGON_PATH        \
L"System\\CurrentControlSet\\services\\Netlogon\\parameters\\"
#define DSROLEP_NETLOGON_SYSVOL     L"SysVol"
#define DSROLEP_NETLOGON_SCRIPTS    L"Scripts"

DWORD
DsRolepGetNetlogonScriptsPath(
    IN HKEY NetlogonHandle,
    OUT LPWSTR *ScriptsPath
    )
/*++

Routine Description:

    This function reads the old netlogon scripts path and expands it to a valid path

Arguments:

    NetlogonHandle - Open handle to the netlogon parameters registry key

    ScriptsPath -- Where the expanded path is retunred.

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR TempPath = NULL;
    ULONG Type, Length = 0;

    //
    // First, get the current scripts path
    //
    Win32Err = RegQueryValueEx( NetlogonHandle,
                                DSROLEP_NETLOGON_SCRIPTS,
                                0, // reserved
                                &Type,
                                0,
                                &Length );

    if ( Win32Err == ERROR_SUCCESS ) {

        *ScriptsPath = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

        if ( *ScriptsPath == NULL ) {

            Win32Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            Win32Err = RegQueryValueEx( NetlogonHandle,
                                        DSROLEP_NETLOGON_SCRIPTS,
                                        0,
                                        &Type,
                                        ( PBYTE )*ScriptsPath,
                                        &Length );


            if ( Win32Err == ERROR_SUCCESS && Type == REG_EXPAND_SZ ) {

                Length = ExpandEnvironmentStrings( *ScriptsPath,
                                                   TempPath,
                                                   0 );
                if ( Length == 0 ) {

                    Win32Err = GetLastError();

                } else {

                    TempPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                                ( Length + 1 ) * sizeof( WCHAR ) );

                    if ( TempPath == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Length = ExpandEnvironmentStrings( *ScriptsPath,
                                                           TempPath,
                                                           Length );
                        if ( Length == 0 ) {

                            Win32Err = GetLastError();
                            RtlFreeHeap( RtlProcessHeap(), 0, TempPath );

                        } else {

                            RtlFreeHeap( RtlProcessHeap(), 0, *ScriptsPath );
                            *ScriptsPath = TempPath;
                        }

                    }
                }
            }
        }
    }

    return( Win32Err );
}


DWORD
DsRolepSetNetlogonSysVolPath(
    IN LPWSTR SysVolRoot,
    IN LPWSTR DnsDomainName,
    IN BOOLEAN IsUpgrade,
    IN OUT PBOOLEAN OkToCleanup
    )
/*++

Routine Description:

    This function sets the root of the system volume in the Netlogon parameters section
    of the registry.  The value is set under the key SysVol.

Arguments:

    SysVolRoot - Path to the root of the system volume to be set

    DnsDomainName - Name of the dns domain name

    IsUpgrade - If TRUE, this means that logon scripts are moved

    OkToCleanup - A flag is returned here indicating whether the old scripts can be cleaned up

Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HKEY  NetlogonHandle = NULL;
    PWSTR OldScriptsPath = NULL, NewScriptsPath = NULL, TempPath, FullSysVolPath = NULL;
    ULONG Type, Length;

    if ( OkToCleanup ) {

        *OkToCleanup =  FALSE;
    }

    //
    // Build the full scripts path
    //
    FullSysVolPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                       ( wcslen( SysVolRoot ) + 1 )  * sizeof( WCHAR ) +
                                        sizeof( DSROLEP_SV_SYSVOL ) );

    if ( FullSysVolPath == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        wcscpy( FullSysVolPath, SysVolRoot );

        if ( FullSysVolPath[ wcslen( FullSysVolPath ) - 1 ] != L'\\' ) {

            wcscat( FullSysVolPath, L"\\" );
        }

        wcscat( FullSysVolPath, DSROLEP_SV_SYSVOL );

        SysVolRoot = FullSysVolPath;
    }

    //
    // Open the netlogon key
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 DSROLEP_NETLOGON_PATH,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 &NetlogonHandle );

        if ( Win32Err != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to open %ws: %lu\n", DSROLEP_NETLOGON_PATH, Win32Err ));

            return( Win32Err );
        }

        //
        // First, set the sysvol key
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegSetValueEx( NetlogonHandle,
                                      DSROLEP_NETLOGON_SYSVOL,
                                      0,
                                      REG_SZ,
                                      ( CONST PBYTE )SysVolRoot,
                                      ( wcslen( SysVolRoot ) + 1 ) * sizeof( WCHAR ) );

            if ( Win32Err != ERROR_SUCCESS ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "Failed to set %ws: %lu\n", DSROLEP_NETLOGON_SYSVOL, Win32Err ));

            }

        }
    }

    //
    // If this is an upgrade, move the scripts...
    //
    if ( Win32Err == ERROR_SUCCESS && IsUpgrade ) {

        Win32Err = DsRolepGetNetlogonScriptsPath( NetlogonHandle,
                                                  &OldScriptsPath );


        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Build the new scripts path
            //
            Length = wcslen( SysVolRoot ) + 1 + wcslen( DnsDomainName ) + 1 +
                            ( sizeof( DSROLEP_NETLOGON_SCRIPTS ) / sizeof( WCHAR ) + 1 );

            if ( Length > MAX_PATH ) {

                Length += 5;
            }


            NewScriptsPath = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              Length  * sizeof( WCHAR ) );

            if ( NewScriptsPath == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if ( Length > MAX_PATH ) {

                    wcscpy( NewScriptsPath, L"\\\\?\\" );

                } else {

                    *NewScriptsPath = UNICODE_NULL;
                }

                wcscat( NewScriptsPath, SysVolRoot );

                if ( NewScriptsPath[ wcslen( SysVolRoot ) - 1 ] != L'\\' ) {

                    wcscat( NewScriptsPath, L"\\" );
                }

                wcscat( NewScriptsPath, DnsDomainName );
                wcscat( NewScriptsPath, L"\\" );
                wcscat( NewScriptsPath, DSROLEP_NETLOGON_SCRIPTS );
            }
        }

        //
        // Now, the copy...
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            DSROLEP_CURRENT_OP2( DSROLEEVT_MOVE_SCRIPTS, OldScriptsPath, NewScriptsPath );

            Win32Err = DsRolepTreeCopy( OldScriptsPath, NewScriptsPath );

            if ( Win32Err != ERROR_SUCCESS ) {


                DsRolepLogPrint(( DEB_ERROR,
                                  "DsRolepTreeCopy from %ws to %ws failed with %lu\n",
                                  OldScriptsPath,
                                  NewScriptsPath,
                                  Win32Err ));

            }
            DSROLEP_CURRENT_OP0( DSROLEEVT_SCRIPTS_MOVED );
        }





        if ( Win32Err != ERROR_SUCCESS ) {

            //
            // Raise the an event
            //
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAIL_SCRIPT_COPY,
                             0,
                             sizeof( ULONG ),
                             &Win32Err,
                             2,
                             OldScriptsPath,
                             NewScriptsPath );

            DSROLEP_SET_NON_FATAL_ERROR( Win32Err );

            Win32Err = ERROR_SUCCESS;

        }

        RtlFreeHeap( RtlProcessHeap(), 0, OldScriptsPath );
        RtlFreeHeap( RtlProcessHeap(), 0, NewScriptsPath );

    }

    if ( OkToCleanup ) {
        *OkToCleanup = TRUE;
    }

    //
    // Close the handle
    //
    if ( NetlogonHandle ) {

        RegCloseKey( NetlogonHandle );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, FullSysVolPath );

    return( Win32Err );
}


DWORD
DsRolepCleanupOldNetlogonInformation(
    VOID
    )
/*++

Routine Description:

    This function cleans up the old netlogon scripts information, including deleting the
    registry key and deleting the old scripts.  It should only be called after netlogon has'
    been successfully upgraded

Arguments:


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err, Win32Err2;
    HKEY  NetlogonHandle = NULL;
    PWSTR OldScriptsPath = NULL;

    DsRolepLogPrint(( DEB_TRACE,
                      "Cleaning up old Netlogon information\n"));
    //
    // Open the netlogon key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_NETLOGON_PATH,
                             0,
                             KEY_READ | KEY_WRITE,
                             &NetlogonHandle );

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to open %ws: %lu\n", DSROLEP_NETLOGON_PATH, Win32Err ));

    } else {

        Win32Err = DsRolepGetNetlogonScriptsPath( NetlogonHandle,
                                                  &OldScriptsPath );
        if ( ERROR_FILE_NOT_FOUND == Win32Err) {

            Win32Err = ERROR_SUCCESS;
            goto cleanup;

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsRolepDelnodePath( OldScriptsPath, wcslen( OldScriptsPath), FALSE );

        }

        //
        // Finally, delete the scripts key
        //
        Win32Err2 = RegDeleteValue( NetlogonHandle, DSROLEP_NETLOGON_SCRIPTS );

        if ( Win32Err2 != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to delete registry key %ws: %lu\n",
                              DSROLEP_NETLOGON_SCRIPTS, Win32Err2 ));

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = Win32Err2;
        }

    }

    cleanup:

    if ( NetlogonHandle ) {
        RegCloseKey( NetlogonHandle );
    }

    if ( OldScriptsPath ) {
        RtlFreeHeap( RtlProcessHeap(), 0, OldScriptsPath );
    }

    return( Win32Err );
}






DWORD
DsRolepFinishSysVolPropagation(
    IN BOOLEAN Commit,
    IN BOOLEAN Promote
    )
/*++

Routine Description:

    This function will commit or abort an NTFRS initial propagation

Arguments:

    Commit - If TRUE, the operation is committed.  If FALSE, the operation is aborted

    Promote - If TRUE, the operation is a promotion.  If FALSE, the operation is a demotion

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( Commit ) {

        if ( Promote ) {

            ASSERT( DsrNtFrsApi_WaitForPromotionW );
            Win32Err = ( *DsrNtFrsApi_WaitForPromotionW )( INFINITE,
                                                           DsRolepStringErrorUpdateCallback );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( DsrNtFrsApi_CommitPromotionW );
                Win32Err = ( *DsrNtFrsApi_CommitPromotionW )( INFINITE,
                                                              DsRolepStringErrorUpdateCallback );
            }

        } else {

            ASSERT( DsrNtFrsApi_WaitForDemotionW );
            Win32Err = ( *DsrNtFrsApi_WaitForDemotionW )( INFINITE,
                                                          DsRolepStringErrorUpdateCallback );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( DsrNtFrsApi_CommitDemotionW );
                Win32Err = ( *DsrNtFrsApi_CommitDemotionW )( INFINITE,
                                                             DsRolepStringErrorUpdateCallback );
            }
        }

    } else {

        if ( Promote ) {

            ASSERT( DsrNtFrsApi_AbortPromotionW );
            Win32Err = ( *DsrNtFrsApi_AbortPromotionW )();

        } else {

            ASSERT( DsrNtFrsApi_AbortDemotionW );
            Win32Err =  ( *DsrNtFrsApi_AbortDemotionW )();
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "DsRolepFinishSysVolPropagation (%S %S) failed with %lu\n",
                          Commit ? "Commit" : "Abort",
                          Promote ? "Promote" : "Demote",
                          Win32Err ));

    }
    return( Win32Err );
}


DWORD
DsRolepAllocAndCopyPath(
    IN LPWSTR Source,
    IN LPWSTR Component,
    OUT LPWSTR *FullPath
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Len = 0;
    BOOL ExtPath = FALSE;

    Len = wcslen( Source ) + 1 + wcslen( Component ) + 1;

    if ( Len > MAX_PATH ) {

        Len += 5;
        ExtPath = TRUE;
    }

    *FullPath = RtlAllocateHeap( RtlProcessHeap(), 0, Len * sizeof( WCHAR ) );

    if ( *FullPath == NULL ) {

        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

    } else {


        if ( ExtPath ) {

            swprintf( *FullPath, L"\\\\?\\%ws\\%ws", Source, Component );

        } else {

            swprintf( *FullPath, L"%ws\\%ws", Source, Component );
        }
    }

    return( Win32Err );
}



DWORD
DsRolepTreeCopy(
    IN LPWSTR Source,
    IN LPWSTR Dest
    )
/*++

Routine Description:

    This function will do a tree copy from the source directory to the destination

Arguments:

    Source - Source dir

    Dest - Dest dir

Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;
    PWSTR SourcePath = NULL, DestPath = NULL, TempPath;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;

    //
    // Build the path for findfirst/findnext
    //
    Win32Err = DsRolepAllocAndCopyPath( Source,
                                        L"*.*",
                                        &SourcePath );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto TreeCopyError;
    }


    //
    // Now, enumerate the paths
    //
    FindHandle = FindFirstFile( SourcePath, &FindData );

    if ( FindHandle == INVALID_HANDLE_VALUE ) {

        Win32Err = GetLastError();
        DsRolepLogPrint(( DEB_ERROR,
                          "FindFirstFile on %ws failed with %lu\n",
                          Source, Win32Err ));
        goto TreeCopyError;
    }



    while ( Win32Err == ERROR_SUCCESS ) {

        if ( wcscmp( FindData.cFileName, L"." ) &&
             wcscmp( FindData.cFileName, L".." ) ) {

            //
            // Build the source path
            //
            Win32Err = DsRolepAllocAndCopyPath( Source,
                                                FindData.cFileName,
                                                &TempPath );

            if ( Win32Err == ERROR_SUCCESS ) {

                RtlFreeHeap( RtlProcessHeap(), 0, SourcePath );
                SourcePath = TempPath;

            } else {

                goto TreeCopyError;
            }

            //
            // Build the destination path
            //
            Win32Err = DsRolepAllocAndCopyPath( Dest,
                                                FindData.cFileName,
                                                &TempPath );

            if ( Win32Err == ERROR_SUCCESS ) {

                RtlFreeHeap( RtlProcessHeap(), 0, DestPath );
                DestPath = TempPath;

            } else {

                goto TreeCopyError;
            }


            //
            // Now, either do the copy, or copy the directory
            //
            if ( FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) ) {

                if ( CreateDirectory( DestPath, NULL ) == FALSE ) {

                    Win32Err = GetLastError();
                    DsRolepLogPrint(( DEB_ERROR,
                                      "CreateDirectory on %ws failed with %lu\n",
                                      DestPath, Win32Err ));

                } else {

                    Win32Err = DsRolepTreeCopy( SourcePath, DestPath );
                }

            } else {

                if ( CopyFile( SourcePath, DestPath, FALSE ) == FALSE ) {

                    Win32Err = GetLastError();
                    DsRolepLogPrint(( DEB_ERROR,
                                      "CopyFile from %ws to %ws failed with %lu\n",
                                      SourcePath, DestPath, Win32Err ));

                }
            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( FindNextFile( FindHandle, &FindData ) == FALSE ) {

                Win32Err = GetLastError();
            }

            if ( Win32Err != ERROR_SUCCESS && Win32Err != ERROR_NO_MORE_FILES ) {

                DsRolepLogPrint(( DEB_ERROR,
                                  "FindNextFile after on %ws failed with %lu\n",
                                  FindData.cFileName, Win32Err ));
            }
        }
    }

TreeCopyError:

    //
    // Close the handle
    //
    if ( FindHandle != INVALID_HANDLE_VALUE ) {

        FindClose( FindHandle );
    }

    if ( Win32Err == ERROR_NO_MORE_FILES ) {

        Win32Err = ERROR_SUCCESS;

    }

    //
    // Cleanup
    //
    if ( SourcePath ) {

        RtlFreeHeap( RtlProcessHeap(), 0, SourcePath );
    }

    if ( DestPath ) {

        RtlFreeHeap( RtlProcessHeap(), 0, DestPath );
    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\sysvol.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sysvol.h

Abstract:

    Routines to manage the system volume installation            

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __SYSVOL_H__
#define __SYSVOL_H__

DWORD
DsRolepRemoveSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  GUID *DomainGuid
    );

DWORD
DsRolepCreateSysVolPath(
    IN  LPWSTR Path,
    IN  LPWSTR DnsDomainName,
    IN  LPWSTR FrsReplicaServer, OPTIONAL
    IN  LPWSTR Account,
    IN  LPWSTR Password,
    IN  PWSTR Site,
    IN  BOOLEAN FirstDc
    );

DWORD
DsRolepFinishSysVolPropagation(
    IN BOOLEAN Commit,
    IN BOOLEAN Promote
    );

DWORD
DsRolepSetFrsInfoForDelete(
    IN GUID *ReplicaDomainGuid,
    IN BOOLEAN Restore
    );

DWORD
DsRolepSetNetlogonSysVolPath(
    IN LPWSTR SysVolRoot,
    IN LPWSTR DomainName,
    IN BOOLEAN IsUpgrade,
    IN PBOOLEAN OkToCleanup
    );

DWORD
DsRolepCleanupOldNetlogonInformation(
    VOID
    );


#endif // __SYSVOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\trustdom.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    trustdom.h

Abstract:

    Routines to manage trusts during promotion/demotion

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __TRUSTDOM_H__
#define __TRUSTDOM_H__

DWORD
DsRolepCreateTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN LPWSTR DnsDomainName,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    );

NTSTATUS
DsRolepCreateParentTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN ULONG Options,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    OUT PLSA_HANDLE TrustedDomainHandle
    );

DWORD
DsRolepDeleteParentTrustObject(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDomainInfo
    );

NTSTATUS
DsRolepCreateChildTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN LSA_HANDLE ChildLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsInfo,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    IN ULONG Options
    );

DWORD
DsRolepRemoveTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    );


#endif // __TRUSTDOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\threadman.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    threadman.c

Abstract:

    Implementation of the thread and thread management routines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmsname.h>
#include <loadfn.h>
#include <lsarpc.h>
#include <db.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>
#include <lmaccess.h>
#include <netsetp.h>
#include <samrpc.h>   // for samisrv.h
#include <samisrv.h>  // for nlrepl.h
#include <nlrepl.h>   // for I_NetNotifyDsChange
#include <Lmshare.h>  // for NetShareDel()
#include <autoenr.h>  // for CertAutoRemove()

#include "secure.h"
#include "services.h"
#include "upgrade.h"
#include "trustdom.h"
#include "sysvol.h"
#include "lsa.h"
#include "ds.h"

#include "threadman.h"


// forward from setutl.h
DWORD
DsRolepDeregisterNetlogonDnsRecords(
    PNTDS_DNS_RR_INFO pInfo
    );

//
// Helpful macros
//
#define DSROLEP_MAKE_DNS_RELATIVE(name)                                         \
if(name) {                                                                      \
    DWORD _StripAbsoluteLength_ = wcslen( name );                               \
    if ( *(name + _StripAbsoluteLength_ - 1 ) == L'.' ) {                       \
        *(name + _StripAbsoluteLength_ - 1 ) = UNICODE_NULL;                    \
    }                                                                           \
}

#define DSROLEP_ALLOC_AND_COPY_STRING_EXIT( dest, src, label )                                  \
if ( (src) ) {                                                                                  \
    (dest) = RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen( (src) ) + 1) * sizeof( WCHAR ) );   \
    if ( !(dest) ) {                                                                            \
        goto label;                                                                             \
    } else {                                                                                    \
        wcscpy((dest), (src));                                                                  \
    }                                                                                           \
} else {                                                                                        \
    (dest) = NULL;                                                                              \
}

#define DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( dest, src, label )                          \
if ( (src) && (src)->Buffer ) {                                                                                  \
    (dest)->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, (src)->MaximumLength );              \
    if ( (dest)->Buffer == NULL ) {                                                             \
        goto label;                                                                             \
    } else {                                                                                    \
        (dest)->Length = (src)->Length;                                                         \
        (dest)->MaximumLength = (src)->MaximumLength;                                           \
        RtlCopyMemory( (dest)->Buffer, (src)->Buffer, (src)->MaximumLength );                   \
    }                                                                                           \
} else {                                                                                        \
    RtlZeroMemory( (dest), sizeof( UNICODE_STRING ) );                                          \
}


//
// Function definitions
//
DWORD
DsRolepBuildPromoteArgumentBlock(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR SiteName,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN LPWSTR RestorePath,
    IN LPWSTR SystemVolumeRootPath,
    IN PUNICODE_STRING Bootkey,
    IN LPWSTR Parent,
    IN LPWSTR Server,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING DomainAdminPassword,
    IN PUNICODE_STRING SafeModePassword,
    IN ULONG Options,
    IN UCHAR PasswordSeed,
    IN OUT PDSROLEP_OPERATION_PROMOTE_ARGS *Promote
    )
/*++

Routine Description:

    Builds an argument structure to pass into one of the promote worker functions.  Since the
    rpc call will return before the thread completes, we'll have to copy all our argument strings.

    Since parameters may be changed through out the course of promotion, we assume allocations
    are made from the process heap.


    Resultant argument block should be freed via DsRolepFreeArgumentBlock

Arguments:

    DnsDomainName - Dns domain name of the domain to install

    FlatDomainName - Flat (NetBIOS) domain name of the domain to install

    SiteName - Name of the site this DC should belong to

    DsDatabasePath - Absolute path on the local machine where the Ds DIT should go

    DsLogPath - Absolute path on the local machine where the Ds log files should go
    
    RestorePath - Location of a restored database.

    SystemVolumeRootPath - Absolute path on the local machine to be the root of the system
        volume root path.
        
    Bootkey - Needed when you don't have the key in the registry or on a disk
    
    cbBootkey - size of the bootkey

    Parent - Optional.  Parent domain name

    Server -- Optional.  Replica partner or server in parent domain

    Account - User account to use when setting up as a child domain

    Password - Password to use with the above account

    DomainAdminPassword - Password to set the domain administartor account

    Options - Options to control the creation of the domain

    PasswordSeed - Seed used to hide the passwords

    Promote - Where the allocated argument block is returned


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD WinError = ERROR_NOT_ENOUGH_MEMORY;

    *Promote = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( DSROLEP_OPERATION_PROMOTE_ARGS ) );
    if ( *Promote == NULL ) {

        goto BuildPromoteDone;
    }

    RtlZeroMemory( *Promote, sizeof( DSROLEP_OPERATION_PROMOTE_ARGS ) );

    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->DnsDomainName, DnsDomainName, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->FlatDomainName, FlatDomainName, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->SiteName, SiteName, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->DsDatabasePath, DsDatabasePath, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->DsLogPath, DsLogPath, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->RestorePath, RestorePath, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->SysVolRootPath, SystemVolumeRootPath, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->Parent, Parent, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->Server, Server, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Promote)->Account, Account, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->Password), Password,
                                                BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->DomainAdminPassword),
                                                DomainAdminPassword, BuildPromoteDone );

    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->SafeModePassword),
                                                SafeModePassword, BuildPromoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Promote)->Bootkey),
                                                Bootkey, BuildPromoteDone );
    (*Promote)->Options = Options;
    (*Promote)->Decode = PasswordSeed;

    WinError = DsRolepGetImpersonationToken( &(*Promote)->ImpersonateToken );

BuildPromoteDone:

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepFreeArgumentBlock( Promote, TRUE );
    }

    return( WinError );
}




DWORD
DsRolepBuildDemoteArgumentBlock(
    IN DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN ULONG Options,
    IN BOOL LastDcInDomain,
    IN PUNICODE_STRING AdminPassword,
    IN UCHAR PasswordSeed,
    IN OUT PDSROLEP_OPERATION_DEMOTE_ARGS *Demote
    )
/*++

Routine Description:

    Builds an argument structure to pass into the demote worker functions.  Since the rpc call
    will return before the thread completes, we'll have to copy all our argument strings.

    Resultant argument block should be freed via DsRolepFreeArgumentBlock

Arguments:

    ServerRole - New role for the server

    DnsDomainName - Dns domain name of the domain to uninstall.  NULL means all of them

    Account - User account to use when setting up as a child domain

    Password - Password to use with the above account

    Options - Options to control the creation of the domain

    LastDcInDomain - If TRUE, the Dc being demoted is the last Dc in the domain.

    AdminPassword - Password to set on the administrator account if it is a new install

    PasswordSeed - Seed used to hide the passwords

    Demote - Where the allocated argument block is returned


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD WinError = ERROR_NOT_ENOUGH_MEMORY;

    *Demote = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( DSROLEP_OPERATION_DEMOTE_ARGS ) );

    if ( *Demote == NULL ) {

        goto BuildDemoteDone;
    }

    RtlZeroMemory( *Demote, sizeof( DSROLEP_OPERATION_DEMOTE_ARGS ) );

    (*Demote)->ServerRole = ServerRole;
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Demote)->DomainName, DnsDomainName, BuildDemoteDone );
    DSROLEP_ALLOC_AND_COPY_STRING_EXIT( (*Demote)->Account, Account, BuildDemoteDone );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Demote)->Password), Password, BuildDemoteDone );
    (*Demote)->LastDcInDomain = ( LastDcInDomain != 0 );
    DSROLEP_ALLOC_AND_COPY_UNICODE_STRING_EXIT( &((*Demote)->AdminPassword),
                                                AdminPassword,
                                                BuildDemoteDone );
    (*Demote)->Options = Options;
    (*Demote)->Decode = PasswordSeed;

    WinError = DsRolepGetImpersonationToken( & (*Demote)->ImpersonateToken );

BuildDemoteDone:

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepFreeArgumentBlock( Demote, FALSE );
    }

    return( WinError );
}



VOID
DsRolepFreeArgumentBlock(
    IN PVOID *ArgumentBlock,
    IN BOOLEAN Promote
    )
/*++

Routine Description:

    Frees an arugment block allocated via DsRolepBuildPromote/DemoteArgumentBlock
    Since parameters may be changed through out the course of promotion, we assume allocations
    are made from the process heap.

Arguments:

    ArgumentBlock - Argument block to free

    Promote - If TRUE, this is a promote argument block.  If FALSE, it's a demote arg block

Returns:

    VOID

--*/
{
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArg;
    PDSROLEP_OPERATION_DEMOTE_ARGS Demote;
    PVOID HeapHandle = RtlProcessHeap();

    if ( !ArgumentBlock ) {

        return;
    }

    //
    // Free it all
    //
    if ( Promote ) {

        PromoteArg = ( PDSROLEP_OPERATION_PROMOTE_ARGS )*ArgumentBlock;

        RtlFreeHeap( HeapHandle, 0, PromoteArg->DnsDomainName );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->FlatDomainName );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->SiteName );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->DsDatabasePath );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->DsLogPath );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->SysVolRootPath );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Parent );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Server );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Account );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->Password.Buffer );
        RtlFreeHeap( HeapHandle, 0, PromoteArg->DomainAdminPassword.Buffer );

        if ( PromoteArg->ImpersonateToken ) {

            NtClose( PromoteArg->ImpersonateToken );
        }

    } else {

        Demote = ( PDSROLEP_OPERATION_DEMOTE_ARGS )*ArgumentBlock;
        RtlFreeHeap( HeapHandle, 0, Demote->Account );
        RtlFreeHeap( HeapHandle, 0, Demote->Password.Buffer );
        RtlFreeHeap( HeapHandle, 0, Demote->DomainName );
        RtlFreeHeap( HeapHandle, 0, Demote->AdminPassword.Buffer );
        if ( Demote->ImpersonateToken ) {

            NtClose( Demote->ImpersonateToken );
        }
    }

    RtlFreeHeap( HeapHandle, 0, *ArgumentBlock );
}



DWORD
DsRolepSpinWorkerThread(
    IN DSROLEP_OPERATION_TYPE Operation,
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually creates the worker thread that will do the promot/demote


Arguments:

    Operation - Demote, Promote as DC, or Promote as Replica

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

    INVALID_PARAMETER - An unexpected operation type encounterd

--*/
{
    DWORD WinError = ERROR_SUCCESS, IgnoreError;
    NTSTATUS NtStatus;
    DWORD ThreadId;

    //
    // The basic premise is that we'll utilize the Completion event to indicate when
    // the thread is full initialized.
    //
    NtStatus = NtResetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );
    WinError = RtlNtStatusToDosError( NtStatus );

    if ( ERROR_SUCCESS == WinError ) {

        switch ( Operation) {
        case DSROLEP_OPERATION_DC:

            DsRolepCurrentOperationHandle.OperationThread = CreateThread(
                        NULL,
                        0,
                        ( LPTHREAD_START_ROUTINE )DsRolepThreadPromoteDc,
                        ArgumentBlock,
                        0,
                        &ThreadId );
            break;


        case DSROLEP_OPERATION_REPLICA:

            DsRolepCurrentOperationHandle.OperationThread = CreateThread(
                        NULL,
                        0,
                        ( LPTHREAD_START_ROUTINE )DsRolepThreadPromoteReplica,
                        ArgumentBlock,
                        0,
                        &ThreadId );
            break;

        case DSROLEP_OPERATION_DEMOTE:

            DsRolepCurrentOperationHandle.OperationThread = CreateThread(
                        NULL,
                        0,
                        ( LPTHREAD_START_ROUTINE )DsRolepThreadDemote,
                        ArgumentBlock,
                        0,
                        &ThreadId );
            break;

        default:

            DsRoleDebugOut(( DEB_ERROR,
                             "Unexpected operation %lu encountered\n", Operation ));

            WinError = ERROR_INVALID_PARAMETER;
            break;


        }

        //
        // Check for failure
        //
        if ( WinError == ERROR_SUCCESS &&
             DsRolepCurrentOperationHandle.OperationThread == NULL ) {

             WinError = GetLastError();
        }


        //
        // If it worked, wait for the thread to indicate its ready
        //
        if ( WinError == ERROR_SUCCESS ) {

            if ( WaitForSingleObject( DsRolepCurrentOperationHandle.CompletionEvent,
                                      INFINITE ) == WAIT_FAILED ) {

                WinError = GetLastError();

            } else {

                NtResetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );
            }
        }

    }

    if ( WinError == ERROR_SUCCESS ) {

        DsRoleDebugOut(( DEB_TRACE,
                         "Thread %lu successfully started\n", ThreadId ));

    } else {

        DsRolepLogPrint(( DEB_ERROR,
                             "Thread %lu unsuccessfully started: %lu\n", ThreadId, WinError ));

    }


    return( WinError );
}




DWORD
DsRolepThreadPromoteDc(
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually "promotes" a server to a dc of an new domain.  Additionally, this
    domain can be set up as a child of an existing domain. This is accomplished by:
        Installing the Ds as a replica
        Setting the DnsDomainTree LSA information
        Optionally configuring it as a child of an existing domain
        Configuring the KDC

Arguments:

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD IgnoreError;
    PWSTR ParentDc = NULL;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs = ( PDSROLEP_OPERATION_PROMOTE_ARGS )ArgumentBlock;
    DSROLEP_DOMAIN_POLICY_INFO BackupDomainPolicyInfo;
    ULONG FindOptions;
    GUID DomainGuid;
    PWSTR InstalledSite = NULL;
    PSID NewDomainSid = NULL;
    PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo = NULL;
    PWSTR DnsDomainTreeName = NULL;


    //
    // BOOLEAN's to maintain state
    //
    // N.B. The order of these booleans is the order in which they
    //      are changed -- please maintain order and make sure that
    //      the PromoteUndo section undoes them in the reverse order
    //
    BOOLEAN IPCConnection                   = FALSE;  // resource -- release on exit
    BOOLEAN RestartNetlogon                 = FALSE;
    BOOLEAN SysVolCreated                   = FALSE;
    BOOLEAN CleanupNetlogon                 = FALSE;  // nothing to undo
    BOOLEAN DsInstalled                     = FALSE;
    BOOLEAN DsRunning                       = FALSE;
    BOOLEAN DomainPolicyInfoChanged         = FALSE;
    BOOLEAN DomainServicesChanged           = FALSE; 
    BOOLEAN DomainControllerServicesChanged = FALSE; 
    BOOLEAN TrustCreated                    = FALSE;
    BOOLEAN ProductTypeChanged              = FALSE;

    //
    // Init the stack space
    //
    RtlZeroMemory(&BackupDomainPolicyInfo, sizeof(BackupDomainPolicyInfo));

    //
    // Set our event to indicate we're starting
    //
    NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    //
    // If we have an existing domain in the forest to install from and we
    // weren't given a site or source server name, we need to make a dsgetdc
    // name.
    //
    if ( PromoteArgs->Server ) {

        ParentDc = PromoteArgs->Server;
        
    }

    if ( PromoteArgs->Parent != NULL  &&
         ( (PromoteArgs->Server == NULL) 
        || (PromoteArgs->SiteName == NULL) )    ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "No source DC or no site name specified. Searching for dc in domain %ws: ( DS_REQUIRED | WRITABLE )\n",
                          PromoteArgs->Parent ));


        DSROLEP_CURRENT_OP1( DSROLEEVT_SEARCH_DC, PromoteArgs->Parent );

        FindOptions = DS_DIRECTORY_SERVICE_REQUIRED | DS_WRITABLE_REQUIRED | DS_FORCE_REDISCOVERY;

        WinError = DsGetDcName(NULL, 
                               PromoteArgs->Parent, 
                               NULL, 
                               NULL,
                               FindOptions,
                              &DomainControllerInfo );

        if ( ERROR_SUCCESS != WinError ) { 

            DsRolepLogPrint(( DEB_TRACE, 
                             "Couldn't find domain controller in domain %ws (error: %d)\n", 
                             ParentDc,
                             WinError ));

            if ( PromoteArgs->Server == NULL ) {

                //
                // This is a fatal error if we can't find a dc in the parent domain
                // If we have a server, then we can derive a site name later on if
                // necessary
                //
                DSROLEP_FAIL1( WinError, DSROLERES_FIND_DC, PromoteArgs->Parent );
    
                DsRolepLogPrint(( DEB_ERROR,
                                  "Failed to find a dc for %ws: %lu\n",
                                  PromoteArgs->Parent,
                                  WinError ));
    
                goto PromoteUndo;
            
            }

            //
            // This isn't fatal since we are a source server
            //
            DsRolepLogPrint(( DEB_TRACE, "Using supplied domain controller: %ws\n", ParentDc ));
            WinError = ERROR_SUCCESS;

        } else {

            //
            // The dsgetdcname succeeded
            //
            if ( PromoteArgs->Server == NULL ) {

                //
                // Use the found domain controller
                //

                DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_DC,
                                     PromoteArgs->Parent,
                                     ParentDc );
    
                DsRolepLogPrint(( DEB_TRACE_DS, "No user specified source DC\n" ));
                ParentDc = DomainControllerInfo->DomainControllerName;
    
            }

            //
            // Determine the site that we are going to be installed in
            // the results of the parent query
            //
            if ( PromoteArgs->SiteName == NULL ) {
    
                DsRolepLogPrint(( DEB_TRACE_DS, "No user specified site\n" ));
    
                PromoteArgs->SiteName = DomainControllerInfo->ClientSiteName;
    
                if ( (PromoteArgs->SiteName == NULL) 
                  && (!_wcsicmp(ParentDc, DomainControllerInfo->DomainControllerName))  ) {
    
                    DsRolepLogPrint(( DEB_TRACE_DS, "This machine is not in a configured site ... using source DC's site.\n" ));
    
                    PromoteArgs->SiteName = DomainControllerInfo->DcSiteName;
    
                } else {
    
                    //
                    // We can't find a site.  That's ok -- the ds will find one for
                    // us
                    //
                }

            }

            if ( PromoteArgs->SiteName ) {
                
                DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_SITE,
                                     PromoteArgs->SiteName,
                                     PromoteArgs->Parent );
            } else {
    
                DsRolepLogPrint(( DEB_TRACE_DS, "This machine is not in a configured site\n" ));
            }
        }

    } else {

        //
        // The caller supplied both the source server and site name
        //
        ParentDc = PromoteArgs->Server;

        DsRolepLogPrint(( DEB_TRACE, "Using supplied domain controller: %ws\n", ParentDc ));
        DsRolepLogPrint(( DEB_TRACE, "Using supplied site: %ws\n", PromoteArgs->SiteName ));
    }

    //
    // Ok, we have determined the our source domain controller and destination
    // site
    //

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Force the time synch
    //
    if (   ParentDc 
        && FLAG_ON( PromoteArgs->Options, DSROLE_DC_FORCE_TIME_SYNC ) ) {

        

        WinError = DsRolepForceTimeSync( PromoteArgs->ImpersonateToken,
                                         ParentDc );

        if ( ERROR_SUCCESS != WinError ) {

           DsRolepLogPrint(( DEB_WARN, "Time sync with %ws failed with %d\n",
                             ParentDc,
                             WinError ));

        //
           // This is not a fatal error
           //
           WinError = ERROR_SUCCESS;

        }
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // If we are setting up a child domain, establish a session first
    //
    if ( ParentDc ) {

        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                            ParentDc,
                                            PromoteArgs->Account,
                                            PromoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );

        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( ERROR_SUCCESS != WinError ) {

            DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, ParentDc );
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to establish the session with %ws: 0x%lx\n", ParentDc,
                              WinError ));
            goto PromoteUndo;

        }
        IPCConnection = TRUE;

    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // If we have a parent dc, get the LSA policy from it
    //

    //
    // Strip the trailing '.' from the Dns name if we happen to have an absolute name
    //
    DSROLEP_MAKE_DNS_RELATIVE( PromoteArgs->DnsDomainName );
    DnsDomainTreeName = PromoteArgs->DnsDomainName;
    if ( ParentDc ) {

        NTSTATUS Status;
        UNICODE_STRING ParentServer;
        HANDLE ParentPolicy = NULL;
        OBJECT_ATTRIBUTES ObjectAttributes;

        DSROLEP_CURRENT_OP1( DSROLEEVT_MACHINE_POLICY, ParentDc );

        RtlInitUnicodeString( &ParentServer, ParentDc );

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = ImpLsaOpenPolicy( PromoteArgs->ImpersonateToken,
                                       &ParentServer,
                                       &ObjectAttributes,
                                        MAXIMUM_ALLOWED,
                                       &ParentPolicy );

        if ( NT_SUCCESS( Status ) ) {

            Status = ImpLsaQueryInformationPolicy( PromoteArgs->ImpersonateToken,
                                                   ParentPolicy,
                                                   PolicyDnsDomainInformation,
                                                  &ParentDnsDomainInfo );

            ImpLsaClose( PromoteArgs->ImpersonateToken, ParentPolicy );
        }

        //
        // We'll have to build it as a NULL terminated string
        //
        if ( NT_SUCCESS( Status ) && ParentDnsDomainInfo->DnsForestName.Length  ) {

            if ( ParentDnsDomainInfo->DnsForestName.Buffer[
                    ParentDnsDomainInfo->DnsForestName.Length / sizeof( WCHAR ) ] == UNICODE_NULL ) {

                DnsDomainTreeName = ( PWSTR )ParentDnsDomainInfo->DnsForestName.Buffer;

            } else {

                DnsDomainTreeName = RtlAllocateHeap(
                                        RtlProcessHeap(), 0,
                                        ParentDnsDomainInfo->DnsForestName.Length + sizeof( WCHAR ) );

                if ( DnsDomainTreeName == NULL ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopyMemory( DnsDomainTreeName,
                                   ParentDnsDomainInfo->DnsForestName.Buffer,
                                   ParentDnsDomainInfo->DnsForestName.Length );

                    DnsDomainTreeName[ ParentDnsDomainInfo->DnsForestName.Length /
                                                                sizeof( WCHAR ) ] = UNICODE_NULL;
                }
            }

        }


        WinError = RtlNtStatusToDosError( Status );

        DSROLEP_FAIL1( WinError, DSROLERES_POLICY_READ_REMOTE, ParentDc );

        if ( ERROR_SUCCESS != WinError ) {

            goto PromoteUndo;

        }
    }


    //
    // If we are doing a root install, make sure we were given the forest root
    // as our parent
    //
    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_TRUST_AS_ROOT ) ) {

         DSROLEP_MAKE_DNS_RELATIVE( PromoteArgs->Parent );
         DSROLEP_MAKE_DNS_RELATIVE( DnsDomainTreeName );
         if ( _wcsicmp( PromoteArgs->Parent, DnsDomainTreeName ) ) {

            //
            // Names don't match... We can't allow this...
            //
            DsRolepLogPrint(( DEB_ERROR,
                              "Tried to specify domain %ws as a forest root but "
                              "%ws is the actual root\n",
                              PromoteArgs->Parent,
                              DnsDomainTreeName ));

            WinError = ERROR_INVALID_DOMAINNAME;
            DSROLEP_FAIL1( WinError, DSROLERES_NOT_FOREST_ROOT, PromoteArgs->Parent );

            goto PromoteUndo;
         }
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Make a back up of the local policy...
    //
    WinError = DsRolepBackupDomainPolicyInfo( NULL, &BackupDomainPolicyInfo );

    if ( ERROR_SUCCESS != WinError ) {

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );

        goto PromoteUndo;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Stop netlogon
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_STOP_SERVICE, SERVICE_NETLOGON );
    WinError = DsRolepStopNetlogon( &RestartNetlogon );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_WARN, "Failed to stop NETLOGON (%d)\n", WinError ));

        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Stopped NETLOGON\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Create the system volume information so we can seed the system volume while the Ds is
    // installing
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_CREATE_SYSVOL, PromoteArgs->SysVolRootPath );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = DsRolepCreateSysVolPath( PromoteArgs->SysVolRootPath,
                                        PromoteArgs->DnsDomainName,
                                        ParentDc,
                                        PromoteArgs->Account,
                                        PromoteArgs->Password.Buffer,
                                        PromoteArgs->SiteName,
                                        TRUE );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );

    DSROLEP_CURRENT_OP1( DSROLEEVT_SVSETUP, PromoteArgs->SysVolRootPath );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to create the system volume (%d)\n", WinError ));
        goto PromoteUndo;

    }
    SysVolCreated = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Created the system volume\n" ));
    
    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Setup the Ds
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->SafeModePassword );
    WinError = DsRolepInstallDs( PromoteArgs->DnsDomainName,
                                 PromoteArgs->FlatDomainName,
                                 DnsDomainTreeName,
                                 PromoteArgs->SiteName,
                                 PromoteArgs->DsDatabasePath,
                                 PromoteArgs->DsLogPath,
                                 PromoteArgs->RestorePath,
                                 PromoteArgs->SysVolRootPath,
                                 &(PromoteArgs->Bootkey),
                                 PromoteArgs->DomainAdminPassword.Buffer,
                                 PromoteArgs->Parent,
                                 ParentDc,
                                 PromoteArgs->Account,
                                 PromoteArgs->Password.Buffer,
                                 PromoteArgs->SafeModePassword.Buffer,
                                 PromoteArgs->Parent,
                                 PromoteArgs->Options,
                                 FALSE,
                                 PromoteArgs->ImpersonateToken,
                                 &InstalledSite,
                                 &DomainGuid,
                                 &NewDomainSid );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->SafeModePassword );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to install the directory service (%d)\n", WinError ));
        goto PromoteUndo;
    }
    DsRunning = TRUE;
    DsInstalled = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Installed the directory service\n", WinError ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the LSA domain policy
    //
    WinError = DsRolepSetLsaDomainPolicyInfo( PromoteArgs->DnsDomainName,
                                              PromoteArgs->FlatDomainName,
                                              DnsDomainTreeName,
                                              &DomainGuid,
                                              NewDomainSid,
                                              NTDS_INSTALL_DOMAIN,
                                              &BackupDomainPolicyInfo );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the LSA policy (%d)\n", WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_WRITE_LOCAL );

        goto PromoteUndo;
    }
    DomainPolicyInfoChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Set the LSA policy\n"));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Configure the domain relative services
    //
    WinError = DsRolepConfigureDomainServices( DSROLEP_SERVICES_ON  );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to configure the domain services (%d)\n", WinError ));

        goto PromoteUndo;

    }
    DomainServicesChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Configured the domain services\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Configure the domain controller relative services
    //
    WinError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_ON );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to configure the domain controller services (%d)\n", WinError ));
        goto PromoteUndo;

    }
    DomainControllerServicesChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Configured the domain controller services\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Finally, upgrade the Lsa to the Ds.
    //
    WinError = DsRolepUpgradeLsaToDs( TRUE );

    if ( ERROR_SUCCESS != WinError ) {

        DSROLEP_FAIL0( WinError, DSROLERES_LSA_UPGRADE );
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Upgrade of the LSA into the DS failed with %lu\n",
                                                WinError )) );

        goto PromoteUndo;
        
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );
    

    //
    // Create the trust objects and set the DnsDomainTree information
    //
    if ( ParentDc ) {

        WinError = DsRolepCreateTrustedDomainObjects( PromoteArgs->ImpersonateToken,
                                                      ParentDc,
                                                      PromoteArgs->DnsDomainName,
                                                      ParentDnsDomainInfo,
                                                      PromoteArgs->Options );
        if ( WinError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to create trusted domain objects (%d)\n", WinError ));

            goto PromoteUndo;

        }
        TrustCreated = TRUE;

        DsRolepLogPrint(( DEB_TRACE, "Created trusted domain objects\n" ));
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Create the GPO for policy
    //
    WinError = ( *DsrSceDcPromoCreateGPOsInSysvolEx )( PromoteArgs->ImpersonateToken,
                                                       PromoteArgs->DnsDomainName,
                                                       PromoteArgs->SysVolRootPath,
                                                       FLAG_ON( PromoteArgs->Options,
                                                                  DSROLE_DC_DOWNLEVEL_UPGRADE ) ?
                                                                    SCE_PROMOTE_FLAG_UPGRADE :
                                                                    0,
                                                       DsRolepStringUpdateCallback );

    if ( ERROR_SUCCESS != WinError ) {
        
        DSROLEP_FAIL1( WinError, DSROLERES_GPO_CREATION, PromoteArgs->DnsDomainName );
    
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "Creation of GPO failed with %lu\n",
                                               WinError )) );
        goto PromoteUndo;

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Created GPO\n" ));
    

    //
    // Stop the Ds
    //
    DsRolepStopDs( DsRunning );
    DsRunning = FALSE;


    //
    // If the install succeeded, make sure to save off the new site name
    //
    WinError = DsRolepSetOperationHandleSiteName( InstalledSite );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to copy site name (%d)\n", WinError ));

        goto PromoteUndo;

    }
    //
    // If we update it, NULL out the local parameter so we don't attempt to delete it
    //

    InstalledSite = NULL;

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the computers Dns domain name
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );
    WinError = NetpSetDnsComputerNameAsRequired( PromoteArgs->DnsDomainName );
    if ( ERROR_SUCCESS != WinError ) {
        
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "NetpSetDnsComputerNameAsRequired to %ws failed with %lu\n",
                                               PromoteArgs->DnsDomainName,
                                               WinError )) );
        DSROLEP_FAIL1( WinError, DSROLERES_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );

        goto PromoteUndo;
    }

    //
    // Restart netlogon if it was stopped and if a failure occurred
    //

    //
    // Complete the sysvol replication
    //
    WinError = DsRolepFinishSysVolPropagation( TRUE, TRUE );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to complete system volume replication (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Completed system volume replication\n"));
    
    //
    // Next, set the sysvol path for netlogon
    //
    WinError = DsRolepSetNetlogonSysVolPath( PromoteArgs->SysVolRootPath,
                                             PromoteArgs->DnsDomainName,
                                             ( BOOLEAN )FLAG_ON( PromoteArgs->Options,
                                                                 DSROLE_DC_DOWNLEVEL_UPGRADE ),
                                             &CleanupNetlogon );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set system volume path for NETLOGON (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set system volume path for NETLOGON\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the machine role
    //
    WinError = DsRolepSetProductType( DSROLEP_MT_MEMBER );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the product type (%d)\n", WinError ));

        goto PromoteUndo;
        
    }
    ProductTypeChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Set the product type\n" ));


    //
    // Set the security on the dc files
    //
    WinError = DsRolepSetDcSecurity( PromoteArgs->ImpersonateToken,
                                     PromoteArgs->SysVolRootPath,
                                     PromoteArgs->DsDatabasePath,
                                     PromoteArgs->DsLogPath,
                                     ( BOOLEAN )FLAG_ON( PromoteArgs->Options,
                                                                 DSROLE_DC_DOWNLEVEL_UPGRADE ),
                                     FALSE );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set security on domain controller (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set security on domain controller\n"));


    DsRolepSetCriticalOperationsDone();

    //
    // From here to do the end, perform, and only perform, non critical 
    // operations
    //

    //
    // Indicate that we are no longer doing upgrades, if applicable
    //
    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_DOWNLEVEL_UPGRADE ) ) {

        WinError = DsRolepDeleteUpgradeInfo();

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to cleanup upgrade info (%d)\n",
                                               WinError )) );

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Removed upgrade info\n" ));
        }

        // This error isn't interesting to propogate
        WinError = ERROR_SUCCESS;
    }

    //
    // Remove any old netlogon stuff if we got that far
    //
    if ( CleanupNetlogon ) {

        WinError = DsRolepCleanupOldNetlogonInformation();

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to cleanup old netlogon information (%d)\n",
                                               WinError )) );

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Removed old netlogon information\n" ));
        }

        // This error isn't interesting to propogate
        WinError = ERROR_SUCCESS;
    }

    //
    // Set the default logon domain to the current domain name
    //
    WinError = DsRolepSetLogonDomain( PromoteArgs->FlatDomainName, FALSE );
    if ( ERROR_SUCCESS != WinError ) {
        
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to set default logon domain to %ws (%d)\n",
                                                PromoteArgs->FlatDomainName,
                                                WinError )) );

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Set default logon domain to %ws\n",
                              PromoteArgs->FlatDomainName ));
        }

        //
        // This is no reason to fail
        //
        WinError = ERROR_SUCCESS;

    }

    //
    // Notify the time server we have completed the promotion
    //
    {
        DWORD dwTimeFlags = W32TIME_PROMOTE;

        if (  FLAG_ON( PromoteArgs->Options, DSROLE_DC_TRUST_AS_ROOT )
           || (NULL == PromoteArgs->Parent) ) {
            //
            // Any tree root, including the root of the forest
            // should have this flag.
            //
            dwTimeFlags |= W32TIME_PROMOTE_FIRST_DC_IN_TREE;
        }

        (*DsrW32TimeDcPromo)( dwTimeFlags );
    }

    //
    // By this time, we have successfully completed the promotion operation
    //
    ASSERT( ERROR_SUCCESS == WinError );

    
PromoteExit:

    // The DS should not be running at this point
    ASSERT( FALSE == DsRunning );

    //
    // Release any resources
    //

    //
    // Tear down the session to the parent, if we have one
    //
    if ( IPCConnection ) {

        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        IgnoreError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                             ParentDc,
                                             PromoteArgs->Account,
                                             PromoteArgs->Password.Buffer,
                                             (NETSETUPP_DISCONNECT_IPC | NETSETUPP_USE_LOTS_FORCE));
        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( IgnoreError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_WARN,
                             "Failed to destroy the session with %ws: 0x%lx\n", ParentDc,
                             IgnoreError ));
        }

        IPCConnection = FALSE;
    }

    if ( ParentDnsDomainInfo ) {

        if ( DnsDomainTreeName != ParentDnsDomainInfo->DnsForestName.Buffer ) {

            RtlFreeHeap( RtlProcessHeap(), 0, DnsDomainTreeName );
        }

        LsaFreeMemory( ParentDnsDomainInfo );
    }
    
    if ( InstalledSite ) {
        RtlFreeHeap( RtlProcessHeap(), 0, InstalledSite );
    }

    if ( NewDomainSid ) {
        RtlFreeHeap( RtlProcessHeap(), 0, NewDomainSid );
    }

    DsRolepFreeDomainPolicyInfo( &BackupDomainPolicyInfo );

    if ( DomainControllerInfo != NULL ) {

        if ( PromoteArgs->SiteName == DomainControllerInfo->DcSiteName ||
             PromoteArgs->SiteName == DomainControllerInfo->ClientSiteName ) {

            PromoteArgs->SiteName = NULL;
        }

        NetApiBufferFree( DomainControllerInfo );

    }

    DsRolepFreeArgumentBlock( &ArgumentBlock, TRUE );

    //
    // Reset our operation handle and set the final operation status
    //
    DsRolepSetOperationDone( DSROLEP_OP_PROMOTION, WinError );

    ExitThread( WinError );

    return( WinError );


PromoteUndo:

    //
    // Something must have failed if we are undoing
    //
    ASSERT( WinError != ERROR_SUCCESS );

    if ( ProductTypeChanged ) {

        IgnoreError = DsRolepSetProductType( DSROLEP_MT_STANDALONE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback product type (%d)\n",
                                                IgnoreError )) );

        ProductTypeChanged = FALSE;
    }

    if ( TrustCreated ) {

        IgnoreError = DsRolepRemoveTrustedDomainObjects( PromoteArgs->ImpersonateToken,
                                                       ParentDc,
                                                       ParentDnsDomainInfo,
                                                       FLAG_ON( PromoteArgs->Options,
                                                        DSROLE_DC_PARENT_TRUST_EXISTS ) ?
                                                            0 :
                                                            DSROLE_DC_DELETE_PARENT_TRUST );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback trusted domain object creations (%d)\n",
                                                IgnoreError )) );

        TrustCreated = FALSE;
    }

    if ( DomainControllerServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );
        DomainControllerServicesChanged = FALSE;
    }

    if ( DomainServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain services configuration (%d)\n",
                                                IgnoreError )) );
        DomainServicesChanged = FALSE;
    }

    if ( DomainPolicyInfoChanged ) {

        IgnoreError  = DsRolepRestoreDomainPolicyInfo(&BackupDomainPolicyInfo);

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain policy information (%d)\n",
                                                IgnoreError )) );
        DomainPolicyInfoChanged = FALSE;
    }

    if ( DsRunning ) {

        IgnoreError = DsRolepStopDs( DsRunning );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to stop the directory service (%d)\n",
                                                IgnoreError )) );
            
        DsRunning = FALSE;
        
    }

    if ( DsInstalled ) {

        IgnoreError = DsRolepUninstallDs( );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback directory service installation (%d)\n",
                                                IgnoreError )) );
        DsInstalled = FALSE;
    }



    if ( SysVolCreated ) {

        IgnoreError =  DsRolepFinishSysVolPropagation( FALSE, TRUE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to abort system volume installation (%d)\n",
                                                IgnoreError )) );

        IgnoreError = DsRolepRemoveSysVolPath( PromoteArgs->SysVolRootPath,
                                               PromoteArgs->DnsDomainName,
                                              &DomainGuid );

        
        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to remove system volume path (%d)\n",
                                                IgnoreError )) );
        SysVolCreated = FALSE;
    }


    if ( RestartNetlogon ) {

        IgnoreError = DsRolepStartNetlogon();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restart netlogon (%d)\n",
                                                IgnoreError )) );

        RestartNetlogon = FALSE;
    }


    //
    // We are finished the undo -- exit the thread
    //
    ASSERT( ERROR_SUCCESS != WinError );

    goto PromoteExit;

}





DWORD
DsRolepThreadPromoteReplica(
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually "promotes" a server to a replica of an existing domain.  This is
    accomplished by:
        Installing the Ds as a replica
        Setting the DnsDomainTree LSA information
        Configuring the KDC

    Required are the Dns domain name and the name of a replica within the domain, and the
    Db and Log paths

Arguments:

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

--*/
{
    DWORD WinError = ERROR_SUCCESS, IgnoreError;
    PDSROLEP_OPERATION_PROMOTE_ARGS PromoteArgs = (PDSROLEP_OPERATION_PROMOTE_ARGS)ArgumentBlock;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    DSROLEP_DOMAIN_POLICY_INFO BackupDomainPolicyInfo;
    ULONG FindOptions = 0;
    GUID DomainGuid;
    PWSTR InstalledSite = NULL, ReplicaServer = NULL;
    PSID NewDomainSid = NULL;
    WCHAR LocalMachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    ULONG Length = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // BOOLEAN's to maintain state
    //
    // N.B. The order of these booleans is the order in which they
    //      are changed -- please maintain order and make sure that
    //      the PromoteUndo section undoes them in the reverse order
    //
    BOOLEAN IPCConnection                   = FALSE;  // resource -- release on exit
    BOOLEAN RestartNetlogon                 = FALSE;
    BOOLEAN SysVolCreated                   = FALSE;
    BOOLEAN DsInstalled                     = FALSE;
    BOOLEAN DsRunning                       = FALSE;
    BOOLEAN DomainPolicyInfoChanged         = FALSE;
    BOOLEAN DomainControllerServicesChanged = FALSE; 
    BOOLEAN ProductTypeChanged              = FALSE;


    RtlZeroMemory(&BackupDomainPolicyInfo, sizeof(BackupDomainPolicyInfo));

    //
    // Set our event to indicate we're starting
    //
    NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );

    //
    // Get the account name
    //
    if ( GetComputerName( LocalMachineAccountName, &Length ) == FALSE ) {

        WinError = GetLastError();

        DsRolepLogPrint(( DEB_ERROR, "Failed to get computer name (%d)\n", WinError ));

        goto PromoteUndo;

    } else {

        wcscat( LocalMachineAccountName, L"$" );
    }

    //
    // Strip the trailing '.' from the Dns name if we happen to have an absolute name
    //
    DSROLEP_MAKE_DNS_RELATIVE( PromoteArgs->DnsDomainName );

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    if (PromoteArgs->Server) {

        if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_FORCE_TIME_SYNC ) ) {

        
            WinError = DsRolepForceTimeSync( PromoteArgs->ImpersonateToken,
                                             PromoteArgs->Server );
    
            if ( ERROR_SUCCESS != WinError ) {
    
                // the machine object was moved
               DsRolepLogPrint(( DEB_WARN, "Time sync with %ws failed with %d\n",
                                 PromoteArgs->Server,
                                 WinError ));
    
               WinError = ERROR_SUCCESS;
    
            }
        
        }
    
        DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );


        //
        // Start a connection to the ReplicaServer
        //
        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                            PromoteArgs->Server,
                                            PromoteArgs->Account,
                                            PromoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );
    
        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( WinError != ERROR_SUCCESS ) {
            
            DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, PromoteArgs->Server );
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to establish the session with %ws: 0x%lx\n", PromoteArgs->Server,
                              WinError ));
    
            goto PromoteUndo;
    
        }

        ReplicaServer = PromoteArgs->Server;

        IPCConnection = TRUE;

    }

    //
    // Find the server that holds the machine account for this machine
    //
    FindOptions = DS_DIRECTORY_SERVICE_REQUIRED | DS_WRITABLE_REQUIRED | DS_FORCE_REDISCOVERY |
                  DS_RETURN_DNS_NAME;
    WinError = ImpDsRolepDsGetDcForAccount( PromoteArgs->ImpersonateToken,
                                            PromoteArgs->Server,
                                            PromoteArgs->DnsDomainName,
                                            LocalMachineAccountName,
                                            FindOptions,
                                            UF_WORKSTATION_TRUST_ACCOUNT |
                                               UF_SERVER_TRUST_ACCOUNT,
                                            &DomainControllerInfo );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to get domain controller for account %ws (%d)\n", LocalMachineAccountName, WinError ));

        DSROLEP_FAIL1( WinError, DSROLERES_FIND_DC, PromoteArgs->DnsDomainName );

        goto PromoteUndo;
        
    }

    //
    // Determine source server
    //
    if ( NULL == PromoteArgs->Server ) {

        //
        // No server was passed -- use the result of the dsgetdc
        //
        ReplicaServer = DomainControllerInfo->DomainControllerName;

    } else {

        ReplicaServer = PromoteArgs->Server;

        if ( !DnsNameCompare_W(*(PromoteArgs->Server)==L'\\'?(PromoteArgs->Server)+2:PromoteArgs->Server,
                               *(DomainControllerInfo->DomainControllerName)==L'\\'?(DomainControllerInfo->DomainControllerName)+2:DomainControllerInfo->DomainControllerName ) ) {

            WinError = ERROR_DS_UNWILLING_TO_PERFORM;

            DsRolepLogPrint(( DEB_ERROR, "DsGetDcForAccount Failed to get the requested domain controller %ws for account %ws (%d)\n",
                              PromoteArgs->Server,
                              LocalMachineAccountName,
                              WinError));

            DSROLEP_FAIL3( WinError, 
                           DSROLERES_FAILED_FIND_REQUESTED_DC, 
                           PromoteArgs->Server,
                           LocalMachineAccountName,
                           DomainControllerInfo->DomainControllerName );

            goto PromoteUndo;
        
        }

    }

    //
    // Determine destination site
    //
    if ( PromoteArgs->SiteName == NULL ) {

        PromoteArgs->SiteName = DomainControllerInfo->ClientSiteName;

        
        if ( PromoteArgs->SiteName == NULL ) {

            PromoteArgs->SiteName = DomainControllerInfo->DcSiteName;

        }
    }

    DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_SITE,
                         PromoteArgs->SiteName,
                         ReplicaServer );


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    if (!IPCConnection) {

        //
        // Force the time synch
        //
        DsRolepLogPrint(( DEB_TRACE, "Forcing time sync\n"));
    
        if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_FORCE_TIME_SYNC ) ) {
    
            
            WinError = DsRolepForceTimeSync( PromoteArgs->ImpersonateToken,
                                             ReplicaServer );
    
            if ( ERROR_SUCCESS != WinError ) {
    
                // the machine object was moved
               DsRolepLogPrint(( DEB_WARN, "Time sync with %ws failed with %d\n",
                                 ReplicaServer,
                                 WinError ));
    
               WinError = ERROR_SUCCESS;
    
            }
        
        }
    
        DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    
        //
        // Attempt to start a RDR connection because we will need one later on
        //
        
        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                            ReplicaServer,
                                            PromoteArgs->Account,
                                            PromoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );
    
        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( WinError != ERROR_SUCCESS ) {
            
            DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, ReplicaServer );
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to establish the session with %ws: 0x%lx\n", ReplicaServer,
                              WinError ));
    
            goto PromoteUndo;
    
        }
        IPCConnection = TRUE;
    }


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Stop netlogon
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_STOP_SERVICE, SERVICE_NETLOGON );

    WinError = DsRolepStopNetlogon( &RestartNetlogon );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to stop NETLOGON (%d)\n", WinError ));

        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Stopped NETLOGON\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Create the system volume information
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = DsRolepCreateSysVolPath( PromoteArgs->SysVolRootPath,
                                        PromoteArgs->DnsDomainName,
                                        ReplicaServer,
                                        PromoteArgs->Account,
                                        PromoteArgs->Password.Buffer,
                                        PromoteArgs->SiteName,
                                        FALSE );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to create system volume path (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Created system volume path\n" ));

    SysVolCreated = TRUE;

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Setup the Ds
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->SafeModePassword );
    WinError = DsRolepInstallDs( PromoteArgs->DnsDomainName,
                                 PromoteArgs->FlatDomainName,
                                 NULL,    // DnsTreeRoot not used for replica installs
                                 PromoteArgs->SiteName,
                                 PromoteArgs->DsDatabasePath,
                                 PromoteArgs->DsLogPath,
                                 PromoteArgs->RestorePath,
                                 PromoteArgs->SysVolRootPath,
                                 &(PromoteArgs->Bootkey),
                                 PromoteArgs->DomainAdminPassword.Buffer,
                                 PromoteArgs->Parent,
                                 ReplicaServer,
                                 PromoteArgs->Account,
                                 PromoteArgs->Password.Buffer,
                                 PromoteArgs->SafeModePassword.Buffer,
                                 PromoteArgs->DnsDomainName,
                                 PromoteArgs->Options,
                                 TRUE,
                                 PromoteArgs->ImpersonateToken,
                                 &InstalledSite,
                                 &DomainGuid,
                                 &NewDomainSid );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->DomainAdminPassword );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->SafeModePassword );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to install to Directory Service (%d)\n", WinError ));
        goto PromoteUndo;
        
    }
    DsRunning = TRUE;
    DsInstalled = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Installed Directory Service\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the lsa domain information to reflect the new security database
    // that was brought in.  The Set below does not set the DnsDomainInformation,
    // since the flat name is not yet known.  The DnsDomainInformation gets
    // set by the DsRolepSetLsaInformationForReplica call following.
    //
    WinError = DsRolepBackupDomainPolicyInfo( NULL, &BackupDomainPolicyInfo );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to make backup of LSA policy (%d)\n", WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );
        goto PromoteUndo;
        
    }

    WinError = DsRolepSetLsaDomainPolicyInfo( PromoteArgs->DnsDomainName,
                                              PromoteArgs->FlatDomainName,
                                              NULL,
                                              &DomainGuid,
                                              NewDomainSid,
                                              NTDS_INSTALL_REPLICA,
                                              &BackupDomainPolicyInfo );
    if ( ERROR_SUCCESS != WinError  ) {
        
        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_WRITE_LOCAL );
        goto PromoteUndo;

    }
    DomainPolicyInfoChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Wrote the LSA policy information for the local machine\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // This extra call is necessary to get the dns tree information
    //
    RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
    WinError = DsRolepSetLsaInformationForReplica( PromoteArgs->ImpersonateToken,
                                                   ReplicaServer,
                                                   PromoteArgs->Account,
                                                   PromoteArgs->Password.Buffer );
    RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
    if ( ERROR_SUCCESS != WinError ) {
        
        DSROLEP_FAIL1( WinError, DSROLERES_POLICY_READ_REMOTE, ReplicaServer );
        goto PromoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE, "Read the LSA policy information from %ws\n", 
                      ReplicaServer ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Configure the services for a domain controller
    //
    WinError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_ON );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to configure domain controller services (%d)\n", WinError ));
        
        goto PromoteUndo;
    }
    DomainControllerServicesChanged = TRUE;

    DsRolepLogPrint(( DEB_TRACE, "Configured domain controller services\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, PromoteUndo );

    //
    // Set the computers Dns domain name
    //
    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );
    WinError = NetpSetDnsComputerNameAsRequired( PromoteArgs->DnsDomainName );
    if ( ERROR_SUCCESS != WinError ) {
        
        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "NetpSetDnsComputerNameAsRequired to %ws failed with %lu\n",
                                               PromoteArgs->DnsDomainName,
                                               WinError )) );
        DSROLEP_FAIL1( WinError, DSROLERES_SET_COMPUTER_DNS, PromoteArgs->DnsDomainName );
        goto PromoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE, "Set the computer's Dns domain name to %ws.\n",
                      PromoteArgs->DnsDomainName ));

    //
    // Complete the sysvol replication
    //
    if ( SysVolCreated ) {

        WinError = DsRolepFinishSysVolPropagation( TRUE, TRUE );
        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to complete system volume replication (%d)\n", WinError ));

            goto PromoteUndo;
            
        }

        DsRolepLogPrint(( DEB_TRACE, "Completed system volume replication\n" ));
    }
    
    //
    // Set the machine role
    //
    WinError = DsRolepSetProductType( DSROLEP_MT_MEMBER );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the product type (%d)\n", WinError ));

        goto PromoteUndo;
    }
    DsRolepLogPrint(( DEB_TRACE, "Set the product type\n" ));

    ProductTypeChanged = TRUE;

    //
    // Save off the new site name
    //
    WinError = DsRolepSetOperationHandleSiteName( InstalledSite );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the operation handle(%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    //
    // If we update it, NULL out the local parameter so we don't attempt to delete it
    //
    InstalledSite = NULL;


    //
    // Next, set the sysvol path for netlogon
    //
    WinError = DsRolepSetNetlogonSysVolPath( PromoteArgs->SysVolRootPath,
                                             PromoteArgs->DnsDomainName,
                                             FALSE,
                                             NULL );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set the system volume path for NETLOGON (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set the system volume path for NETLOGON\n" ));

    //
    // Finally, set the security on the dc files
    //
    WinError = DsRolepSetDcSecurity( PromoteArgs->ImpersonateToken,
                                     PromoteArgs->SysVolRootPath,
                                     PromoteArgs->DsDatabasePath,
                                     PromoteArgs->DsLogPath,
                                     ( BOOLEAN )FLAG_ON( PromoteArgs->Options,
                                                                 DSROLE_DC_DOWNLEVEL_UPGRADE ),
                                     TRUE );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to set security for the domain controller (%d)\n", WinError ));
        goto PromoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "Set security for the domain controller\n" ));


    //
    // We have done all operations for the promotion; now continue replicating
    // ds information until done, or cancelled
    //
    DsRolepLogPrint(( DEB_TRACE, "Replicating non critical information\n" ));

    DsRolepSetCriticalOperationsDone();

    if ( !FLAG_ON( PromoteArgs->Options, DSROLE_DC_CRITICAL_REPLICATION_ONLY ) ) {

        //in the Install From Media case we do not want to do a full sync of the
        //Non-Critical objects
        if ((PromoteArgs->RestorePath != NULL)) {
            WinError = (*DsrNtdsInstallReplicateFull) ( DsRolepStringUpdateCallback, PromoteArgs->ImpersonateToken, NTDS_IFM_PROMOTION );
        } else {
            WinError = (*DsrNtdsInstallReplicateFull) ( DsRolepStringUpdateCallback, PromoteArgs->ImpersonateToken, 0 );
        }
    
        if ( WinError != ERROR_SUCCESS ) {
    
            //
            // Error code doesn't matter, but we'll log it anyway
            //
            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_WARN,
                                                  "Non critical replication returned %lu\n", WinError )) );
        
            if (ERROR_SUCCESS == WinError) {
                DsRolepLogPrint(( DEB_TRACE, "Replicating non critical information (Complete)\n" ));
            }
            if ( ERROR_SUCCESS != WinError ) {
        
                DSROLEP_SET_NON_CRIT_REPL_ERROR();
            }
    
            WinError = ERROR_SUCCESS;
            
        }
        
    } else {

        DsRolepLogPrint(( DEB_TRACE, "User specified to not replicate non-critical data\n" ));

    }


    //
    // Indicate that we are no longer doing upgrades, if applicable
    //
    if ( FLAG_ON( PromoteArgs->Options, DSROLE_DC_DOWNLEVEL_UPGRADE ) ) {

        WinError = DsRolepDeleteUpgradeInfo();

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to remove upgrade information (%d)\n",
                                               WinError )) );
        // This error isn't interesting to propogate
        WinError = ERROR_SUCCESS;

    }

    //
    // Remove any old netlogon stuff if we got that far
    //
    WinError = DsRolepCleanupOldNetlogonInformation();

    if ( (FLAG_ON( PromoteArgs->Options, DSROLE_DC_DOWNLEVEL_UPGRADE )) && ERROR_SUCCESS != WinError ) {

        if (ERROR_SUCCESS == WinError) {
            DsRolepLogPrint(( DEB_TRACE, "Removed any old netlogon information\n" ));
        }

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to clean up old netlogon information (%d)\n",
                                                WinError )) );

    }

    WinError = ERROR_SUCCESS;


    //
    // Set the default logon domain to the current domain name
    //

    //
    // We'll have to get it from the backed up policy information, since it isn't actually
    // passed in
    //
    WinError = DsRolepSetLogonDomain(
                   ( PWSTR )BackupDomainPolicyInfo.DnsDomainInfo->Name.Buffer,
                   FALSE );
    if ( ERROR_SUCCESS != WinError ) {

        PWCHAR bufDnsDomainInfo = NULL;

        bufDnsDomainInfo = (WCHAR*)malloc(BackupDomainPolicyInfo.DnsDomainInfo->Name.Length+1);

        if (bufDnsDomainInfo) {
            CopyMemory(bufDnsDomainInfo,
                       BackupDomainPolicyInfo.DnsDomainInfo->Name.Buffer,
                       BackupDomainPolicyInfo.DnsDomainInfo->Name.Length);
            bufDnsDomainInfo[BackupDomainPolicyInfo.DnsDomainInfo->Name.Length/sizeof(WCHAR)] = L'\0';
        
        
            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_WARN,
                                                   "Failed to set default logon domain to %ws (%d)\n",
                                                    bufDnsDomainInfo,
                                                    WinError )) );
    
            if (ERROR_SUCCESS == WinError) {
                DsRolepLogPrint(( DEB_TRACE, "Set default logon domain to %ws\n",
                                              bufDnsDomainInfo ));
            }

            free(bufDnsDomainInfo);

        }

        //
        // This is not worth failing for
        //
        WinError = ERROR_SUCCESS;

    }

    //
    // Stop the ds
    //
    DsRolepStopDs( DsRunning );
    DsRunning = FALSE;

    DsRolepLogPrint(( DEB_TRACE, "Stopped the DS\n" ));

    //
    // Notify the time server we have completed the promotion
    //
    (*DsrW32TimeDcPromo)( W32TIME_PROMOTE );

    
    //
    // Set Netlogon registry key during DCPromo to ensure that kerberos is talking 
    // to a DC w/ new User AccountControl flag
    //
    IgnoreError = NetpStoreIntialDcRecord(DomainControllerInfo);
    if ( IgnoreError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_WARN,
                         "Failed to set Netlogon registry key during DCPromo %ws\r\n",
                         IgnoreError ));
    }

    //
    // At this point we have succeeded the promotion
    //
    ASSERT( ERROR_SUCCESS == WinError );


PromoteExit:


    //
    // Released acquired resources
    //
    if ( IPCConnection ) {

        RtlRunDecodeUnicodeString( PromoteArgs->Decode, &PromoteArgs->Password );
        IgnoreError = ImpNetpManageIPCConnect( PromoteArgs->ImpersonateToken,
                                               ReplicaServer,
                                               PromoteArgs->Account,
                                               PromoteArgs->Password.Buffer,
                                              (NETSETUPP_DISCONNECT_IPC | NETSETUPP_USE_LOTS_FORCE ) );
        RtlRunEncodeUnicodeString( &PromoteArgs->Decode, &PromoteArgs->Password );
        if ( IgnoreError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_ERROR,
                             "Failed to destroy the session with %ws: 0x%lx\n", ReplicaServer,
                             IgnoreError ));
        }
        IPCConnection = FALSE;
    }


    if ( DomainControllerInfo != NULL ) {

        if ( PromoteArgs->SiteName == DomainControllerInfo->ClientSiteName ||
             PromoteArgs->SiteName == DomainControllerInfo->DcSiteName ) {

            PromoteArgs->SiteName = NULL;
        }

        NetApiBufferFree( DomainControllerInfo );

    }

    RtlFreeHeap( RtlProcessHeap(), 0, InstalledSite );
    RtlFreeHeap( RtlProcessHeap(), 0, NewDomainSid );

    DsRolepFreeDomainPolicyInfo(&BackupDomainPolicyInfo);
    //
    // Reset our operation handle
    //
    DsRolepSetOperationDone( DSROLEP_OP_PROMOTION, WinError );

    DsRolepFreeArgumentBlock( &ArgumentBlock, TRUE );

    ExitThread( WinError );
    return( WinError );

PromoteUndo:

    //
    // Something must have failed to have gotten us here
    //
    ASSERT( ERROR_SUCCESS != WinError );

    if ( ProductTypeChanged ) {

        IgnoreError = DsRolepSetProductType( DSROLEP_MT_STANDALONE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback product type (%d)\n",
                                                IgnoreError )) );

        ProductTypeChanged = FALSE;
    }

    if ( DomainControllerServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );

        DomainControllerServicesChanged = FALSE;
    }

    if ( DomainPolicyInfoChanged ) {

        IgnoreError = DsRolepRestoreDomainPolicyInfo(&BackupDomainPolicyInfo);

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restore domain policy information (%d)\n",
                                                IgnoreError )) );
        DomainPolicyInfoChanged = FALSE;
    }

    if ( DsRunning ) {
        
        IgnoreError = DsRolepStopDs( DsRunning );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to stop the directory service (%d)\n",
                                                IgnoreError )) );
        DsRunning = FALSE;
    }

    if ( DsInstalled ) {

        IgnoreError = DsRolepUninstallDs( );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to undo the directory service installation (%d)\n",
                                                IgnoreError )) );
        DsInstalled = FALSE;
    }

    if ( SysVolCreated ) {

        IgnoreError = DsRolepFinishSysVolPropagation( FALSE, TRUE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to abort system volume installation (%d)\n",
                                                IgnoreError )) );

        IgnoreError = DsRolepRemoveSysVolPath( PromoteArgs->SysVolRootPath,
                                               PromoteArgs->DnsDomainName,
                                               &DomainGuid );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to remove system volume path (%d)\n",
                                                IgnoreError )) );

        SysVolCreated = FALSE;

    }

    if ( RestartNetlogon ) {

        IgnoreError = DsRolepStartNetlogon();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restart NETLOGON (%d)\n",
                                                IgnoreError )) );
        RestartNetlogon = FALSE;
    }

    //
    // That's it -- terminate the operation
    // 

    ASSERT( ERROR_SUCCESS != WinError );

    goto PromoteExit;

}



DWORD
DsRolepThreadDemote(
    IN PVOID ArgumentBlock
    )
/*++

Routine Description:

    This function actually "demotes" a dc to standalone or member server.  This is
    accomplished by:
        Uninstalling the Ds
        Configuring the KDC
        Changing the product type
        Removing the system volume tree

    Required is the new server role

Arguments:

    ArgumentBlock - Block of arguments appropriate for the operation


Returns:

    ERROR_SUCCESS - Success

    ERROR_NO_SUCH_DOMAIN - The local domain information could not be located

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

    ERROR_DS_CANT_ON_NON_LEAF - The domain is not a leaf domain

--*/
{
    DWORD WinError = ERROR_SUCCESS, IgnoreError;
    NET_API_STATUS NetStatus = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO DomainControllerInfo = NULL;
    PDSROLEP_OPERATION_DEMOTE_ARGS DemoteArgs = ( PDSROLEP_OPERATION_DEMOTE_ARGS )ArgumentBlock;
    DSROLEP_DOMAIN_POLICY_INFO BackupDomainPolicyInfo;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    HANDLE Policy = NULL;
    NTSTATUS Status;
    PWSTR ParentDomainName = NULL, CurrentDomain = NULL, SupportDc = NULL;
    PWSTR SupportDomain = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;

    ULONG ServicesOffFlags = DSROLEP_SERVICES_OFF | DSROLEP_SERVICES_STOP;
    ULONG ServicesOnFlags = DSROLEP_SERVICES_REVERT;

    PNTDS_DNS_RR_INFO pDnsRRInfo = NULL;

    ULONG Flags = 0;
    PSEC_WINNT_AUTH_IDENTITY Credentials = NULL;

    //
    // BOOLEAN's to maintain state
    //
    // N.B. The order of these booleans is the order in which they
    //      are changed -- please maintain order and make sure that
    //      the DemoteUndo section undoes them in the reverse order
    //
    BOOLEAN IPCConnection                   = FALSE;  // resource -- release on exit
    BOOLEAN DsPrepareDemote                 = FALSE;
    BOOLEAN FrsDemote                       = FALSE;
    BOOLEAN NotifiedNetlogonToDeregister    = FALSE;
    BOOLEAN RestartNetlogon                 = FALSE;
    BOOLEAN DomainControllerServicesChanged = FALSE; 
    BOOLEAN DomainServicesChanged           = FALSE; 
    BOOLEAN Unrollable                      = FALSE;  // at this point, don't
                                                      // try to rollback
    //
    // Set our event to indicate we're starting
    //
    NtSetEvent( DsRolepCurrentOperationHandle.CompletionEvent, NULL );


    //
    // Get the current domain information, potentially the parent Domain and see if
    // we are valid to be demoted
    //
    DSROLEP_CURRENT_OP0( DSROLEEVT_LOCAL_POLICY );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &Policy );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( Policy,
                                            PolicyDnsDomainInformation,
                                            &DnsDomainInfo );

    }

    if ( !NT_SUCCESS( Status ) ) {

        WinError = RtlNtStatusToDosError( Status );
        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );
        goto DemoteUndo;
    }

    if ( DemoteArgs->DomainName == NULL ) {

        CurrentDomain = DnsDomainInfo->DnsDomainName.Buffer;

    } else {

        //
        // Strip the trailing '.' from the Dns name if we happen to have an absolute name
        //
        DSROLEP_MAKE_DNS_RELATIVE( DemoteArgs->DomainName );

        CurrentDomain = DemoteArgs->DomainName;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Determine whether it is legal to demote this domain.  Also, get the parent Dns domain name
    //
    if ( DemoteArgs->LastDcInDomain ) {

        PLSAPR_FOREST_TRUST_INFO ForestTrustInfo = NULL;
        PLSAPR_TREE_TRUST_INFO OwnEntry = NULL, ParentEntry = NULL;

        Status = LsaIQueryForestTrustInfo( Policy,
                                           &ForestTrustInfo );
        WinError = RtlNtStatusToDosError( Status );

        if ( WinError == ERROR_SUCCESS ) {

            //
            // Check the root
            //
            if ( RtlCompareUnicodeString(
                    ( PUNICODE_STRING )&ForestTrustInfo->RootTrust.DnsDomainName,
                    &DnsDomainInfo->DnsDomainName,
                    TRUE ) == 0  ) {

                OwnEntry = &ForestTrustInfo->RootTrust;
                ParentEntry = NULL;

            } else {

                //
                // Find our own entry in the list and our parent...
                //
                DsRolepFindSelfAndParentInForest( ForestTrustInfo,
                                                  &ForestTrustInfo->RootTrust,
                                                  &DnsDomainInfo->DnsDomainName,
                                                  &ParentEntry,
                                                  &OwnEntry );
            }

            if ( OwnEntry == NULL ) {

                WinError = ERROR_NO_SUCH_DOMAIN;

            } else {

                //
                // If we have children, it's an error
                //
                if ( OwnEntry->Children != 0 ) {

                    WCHAR *BufOwnEntry = NULL;
                    DsRolepUnicodestringtowstr( BufOwnEntry, OwnEntry->DnsDomainName )
                    if (BufOwnEntry) {
                      DsRolepLogPrint(( DEB_TRACE,
                                      "We ( %ws ) think we have %lu children\n",
                                      BufOwnEntry,
                                      OwnEntry->Children ));
                      free(BufOwnEntry);
                    } else {
                      DsRolepLogPrint(( DEB_TRACE,
                                      "We think we have %lu children: Can display string ERROR_NOT_ENOUGH_MEMORY\n",
                                      OwnEntry->Children ));
                    }

                    WinError = ERROR_DS_CANT_ON_NON_LEAF;
                }

                //
                // Copy off our parent information
                //
                if ( WinError == ERROR_SUCCESS && ParentEntry != NULL ) {

                    WCHAR *BufOwnEntry = NULL;
                    DsRolepUnicodestringtowstr( BufOwnEntry, OwnEntry->DnsDomainName )
                    if (BufOwnEntry) {
                      DsRolepLogPrint((DEB_TRACE,
                                      "Domain %ws is our parent parent\n",
                                      BufOwnEntry));
                      free(BufOwnEntry);
                    } else {
                      DsRolepLogPrint(( DEB_TRACE,
                                      "Domain (?) is our parent parent: Can display domain string ERROR_NOT_ENOUGH_MEMORY\n"));
                    }

                    ParentDomainName = RtlAllocateHeap(
                                  RtlProcessHeap(), 0,
                                  ParentEntry->DnsDomainName.Length + sizeof( WCHAR ) );
                    if ( ParentDomainName == NULL ) {

                        WinError = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        RtlCopyMemory( ParentDomainName,
                                       ParentEntry->DnsDomainName.Buffer,
                                       ParentEntry->DnsDomainName.Length );
                        ParentDomainName[
                            ParentEntry->DnsDomainName.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
                    }
                }

            }
        }

        LsaIFreeForestTrustInfo( ForestTrustInfo );

        if ( ERROR_SUCCESS != WinError ) {

            DSROLEP_FAIL1( WinError, DSROLERES_LEAF_DOMAIN, CurrentDomain );
            goto DemoteUndo;
        }

    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );


    //
    // Locate a Dc to help with the demotion
    //
    if ( DemoteArgs->LastDcInDomain ) {

        SupportDomain = ParentDomainName;

    } else {

        SupportDomain = CurrentDomain;
    }

    //
    // If this is the last domain in the enterprise, there will be no
    // parent domain and possibly no replicas to assist.
    //
    // Note: netlogon is still running, so use the avoid self flag
    //
    if ( SupportDomain ) {

        DSROLEP_CURRENT_OP1( DSROLEEVT_SEARCH_DC, SupportDomain  );

        if ( !DemoteArgs->LastDcInDomain )
        {
            //
            // Demoting a replica - find someone with our machine account
            //
            ULONG FindOptions = DS_DIRECTORY_SERVICE_REQUIRED | 
                                DS_WRITABLE_REQUIRED | 
                                DS_FORCE_REDISCOVERY | 
                                DS_AVOID_SELF;

            WCHAR LocalMachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
            ULONG Length = sizeof(LocalMachineAccountName) / sizeof(LocalMachineAccountName[0]);

            //
            // Get the account name
            //
            if ( GetComputerName( LocalMachineAccountName, &Length ) == FALSE ) {

                WinError = GetLastError();

                DsRolepLogPrint(( DEB_ERROR, "Failed to get computer name (%d)\n", WinError ));

                goto DemoteUndo;
        
            } else {

                wcscat( LocalMachineAccountName, L"$" );
                WinError = DsRolepDsGetDcForAccount( NULL,
                                                     SupportDomain,
                                                     LocalMachineAccountName,
                                                     FindOptions,
                                                     UF_WORKSTATION_TRUST_ACCOUNT |
                                                        UF_SERVER_TRUST_ACCOUNT,
                                                     &DomainControllerInfo );
            }

        } else {

            WinError = DsGetDcName( NULL, SupportDomain, NULL, NULL,
                                    DS_DIRECTORY_SERVICE_REQUIRED |
                                    DS_WRITABLE_REQUIRED |
                                    DS_AVOID_SELF |
                                    DS_FORCE_REDISCOVERY,
                                    &DomainControllerInfo );
        }

        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to find a domain controller for %ws: %lu\n",
                              SupportDomain, WinError ));
            
            DSROLEP_FAIL1( WinError, DSROLERES_FIND_DC, SupportDomain );

            goto DemoteUndo;
        }

        SupportDc = DomainControllerInfo->DomainControllerName;
        if ( *SupportDc == L'\\' ) {

            SupportDc += 2;
        }

        DsRolepLogPrint(( DEB_TRACE_DS, "Support Dc in %ws is %ws\n",
                          SupportDomain,
                          SupportDc ));
        DSROLEP_CURRENT_OP2( DSROLEEVT_FOUND_DC,
                             SupportDc,
                             SupportDomain );
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Attempt to establish a RDR session with our support DC
    // if necessary
    //
    if ( SupportDc ) {
        
        //
        // Impersonate to get logon id of caller
        //
        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( DemoteArgs->ImpersonateToken,
                                            SupportDc,
                                            DemoteArgs->Account,
                                            DemoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );
    
        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
        if ( ERROR_SUCCESS != WinError ) {
    
            DSROLEP_FAIL1( WinError, DSROLERES_NET_USE, SupportDc );
            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to establish the session with %ws: 0x%lx\n", SupportDc,
                              WinError ));
            goto DemoteUndo;
    
        }
        IPCConnection = TRUE;
    }


    //
    // Prepare the ds for demotion
    //

    DSROLE_GET_SETUP_FUNC( WinError, DsrNtdsPrepareForDemotion );
    ASSERT( ERROR_SUCCESS == WinError );

    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );

    WinError = DsRolepCreateAuthIdentForCreds(DemoteArgs->Account,
                                              DemoteArgs->Password.Buffer,
                                              &Credentials);

    if ( ERROR_SUCCESS == WinError ) {

        if ( DemoteArgs->LastDcInDomain ) {
    
            Flags |= NTDS_LAST_DC_IN_DOMAIN;
        }
    
        Flags |= DsRolepDemoteFlagsToNtdsFlags( DemoteArgs->Options );
    
        DSROLEP_CURRENT_OP0( DSROLEEVT_PREPARE_DEMOTION );
        WinError = ( *DsrNtdsPrepareForDemotion ) ( Flags,
                                                    SupportDc,
                                                    Credentials,
                                                    DsRolepStringUpdateCallback,
                                                    DsRolepStringErrorUpdateCallback,
                                                    DemoteArgs->ImpersonateToken,
                                                    &pDnsRRInfo );

    
        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );


        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR, "Failed to prepare the Directory Service for uninstallation (%d)\n", WinError ));

            goto DemoteUndo;
            
        }
        DsPrepareDemote = TRUE;

    } else {

        DsRolepLogPrint(( DEB_ERROR, "Failed to create authentication credentials (%d)\n", WinError ));

        goto DemoteUndo;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Start the sysvol demotions
    //
    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );

    WinError = ( *DsrNtFrsApi_PrepareForDemotionUsingCredW ) ( Credentials,
                                                               DemoteArgs->ImpersonateToken,
                                                              DsRolepStringErrorUpdateCallback );


    RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR, "Failed to get computer name (%d)\n", WinError ));
        DSROLEP_FAIL0( WinError, DSROLERES_SYSVOL_DEMOTION );
        goto DemoteUndo;
        
    }

    WinError = ( *DsrNtFrsApi_StartDemotionW )( CurrentDomain,
                                                DsRolepStringErrorUpdateCallback );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to start system volume demotion on domain (%d)\n",
                          WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_SYSVOL_DEMOTION );
        goto DemoteUndo;
        
    }
    // At this point we have signalled one frs replica set to be demote so
    // we must wait on it
    FrsDemote = TRUE;

    WinError = ( *DsrNtFrsApi_StartDemotionW )( L"ENTERPRISE",
                                                DsRolepStringErrorUpdateCallback );

    if ( WinError != ERROR_SUCCESS ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to start system volume demotion on enterprise (%d)\n",
                          WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_SYSVOL_DEMOTION );
        goto DemoteUndo;

    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Started system volume demotion on enterprise\n" ));


    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Note that if a failure occurs after we uninstall the Ds, than we will not attempt to
    // reinstall it, since we don't have enough information to do so.  In that case, the machine
    // will be in a somewhat inconsistent state.  However, some errors are acceptable:
    //
    //   Failure to delete the trusted domain object - Continuable
    //   Stoping the KDC - Continuable
    //
    //
    // Also, note that "uninstalling the DS" also sets the LSA account domain
    // sid and the server role so no errors should be returned to the caller
    // after uninstalling the DS. The machine will become the new role on the
    // next reboot.
    //

    WinError = DsRolepBackupDomainPolicyInfo( NULL, &BackupDomainPolicyInfo );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to backup LSA domain policy (%d)\n",
                          WinError ));

        DSROLEP_FAIL0( WinError, DSROLERES_POLICY_READ_LOCAL );
        goto DemoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Read the LSA policy information from the local machine\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );


    //
    // Set netlogon we are demoting so it will deregister the DNS records
    //
    Status = I_NetNotifyDsChange( NlDcDemotionInProgress );
    if ( !NT_SUCCESS( Status ) ) {

        WinError = RtlNtStatusToDosError( Status );
        
        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to tell NETLOGON to deregister records (%d)\n",
                          WinError ));
        goto DemoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Informed NETLOGON to deregister records\n" ));

    NotifiedNetlogonToDeregister = TRUE;

    //
    // Stop netlogon
    //
    WinError = DsRolepStopNetlogon( &RestartNetlogon );
    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to stop NETLOGON (%d)\n",
                          WinError ));
        goto DemoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Stopped NETLOGON\n" ));

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Disable the domain controller services
    //
    WinError  = DsRolepConfigureDomainControllerServices( ServicesOffFlags );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to configure domain controller services (%d)\n",
                          WinError ));
        goto DemoteUndo;
    }

    DsRolepLogPrint(( DEB_TRACE,
                      "Configured domain controller services\n" ));

    DomainControllerServicesChanged = TRUE;
        
    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Disable the domain related services if necessary
    //
    if ( DemoteArgs->ServerRole == DsRoleServerStandalone ) {

        WinError  = DsRolepConfigureDomainServices( ServicesOffFlags );

        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogPrint(( DEB_ERROR,
                              "Failed to configure domain services (%d)\n",
                              WinError ));

            goto DemoteUndo;

        }
        DsRolepLogPrint(( DEB_TRACE,
                      "Configured domain services\n" ));

        DomainServicesChanged = TRUE;
    }

    DSROLEP_CHECK_FOR_CANCEL_EX( WinError, DemoteUndo );

    //
    // Remove the Ds
    //
    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
    RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->AdminPassword );
    WinError = DsRolepDemoteDs( CurrentDomain,
                                DemoteArgs->Account,
                                DemoteArgs->Password.Buffer,
                                DemoteArgs->AdminPassword.Buffer,
                                SupportDc,
                                SupportDomain,
                                DemoteArgs->ImpersonateToken,
                                DemoteArgs->LastDcInDomain );

    RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
    RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->AdminPassword );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to demote the directory service (%d)\n",
                          WinError ));
        goto DemoteUndo;
        
    }

    DsRolepLogPrint(( DEB_TRACE, "This machine is no longer a domain controller\n" ));

    //
    // The operation cannot be cancelled at this point since the ds has
    // been removed from the machine and from the enterprise
    //
    Unrollable = TRUE;

    //
    // Optionally remove the trust with the parent
    //
    if ( DemoteArgs->LastDcInDomain &&
         ParentDomainName != NULL ) {

        //
        // Establish a session first -- should be a no-op since we already
        // have a connection
        //
        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
        WinError = ImpNetpManageIPCConnect( DemoteArgs->ImpersonateToken,
                                            SupportDc,
                                            DemoteArgs->Account,
                                            DemoteArgs->Password.Buffer,
                                            NETSETUPP_CONNECT_IPC );

        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
        if ( WinError == ERROR_SUCCESS ) {

            WinError = DsRolepDeleteParentTrustObject( DemoteArgs->ImpersonateToken,
                                                       SupportDc,
                                                       DnsDomainInfo );

            if ( WinError != ERROR_SUCCESS ) {

                DsRolepLogOnFailure( WinError,
                                     DsRolepLogPrint(( DEB_WARN,
                                                       "Failed to delete the "
                                                       "trust on %ws: %lu\n",
                                                       SupportDc,
                                                       WinError )) );
                if (ERROR_SUCCESS == WinError) {
                    DsRolepLogPrint(( DEB_TRACE,
                                      "Deleted the trust on %ws\n",
                                       SupportDc ));
                }
            }

        } else {

            // This is not a fatal error
            DsRolepLogPrint(( DEB_WARN,
                              "Failed to establish the session with %ws: 0x%lx\n", SupportDc,
                              WinError ));

        }

        //
        // This error is not fatal
        //
        if ( ERROR_SUCCESS != WinError )
        {

            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAILED_TO_DELETE_TRUST,
                             0,
                             sizeof( ULONG ),
                             &WinError,
                             1,
                             ParentDomainName );

            DSROLEP_SET_NON_FATAL_ERROR( WinError );

            // Error case is handled

            WinError = ERROR_SUCCESS;
        }
    }

    //
    // Finish our NTFRS demotion
    //
    if ( FrsDemote ) {

        WinError = DsRolepFinishSysVolPropagation( TRUE,
                                                   FALSE );

        if ( ERROR_SUCCESS != WinError ) {

            DsRolepLogOnFailure( WinError,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "Failed to finish system volume demotion (%d)\n",
                                                    WinError )) );

            if (ERROR_SUCCESS == WinError) {
                    DsRolepLogPrint(( DEB_TRACE,
                                      "Finished system volume demotion\n" ));
            }
            
        }

        //
        // It is not fatal if the FRS fails at this point
        //
        if ( ERROR_SUCCESS != WinError )
        {
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_FAILED_TO_DEMOTE_FRS,
                             0,
                             sizeof( ULONG ),
                             &WinError,
                             0,
                             NULL );

            DSROLEP_SET_NON_FATAL_ERROR( WinError );

        }

        // Reset status code
        WinError = ERROR_SUCCESS;

    }

    //
    // Call into the SCE so we can be configured to be a server
    //
    WinError = ( *DsrSceDcPromoteSecurityEx )( DemoteArgs->ImpersonateToken,
                                               SCE_PROMOTE_FLAG_DEMOTE,
                                               DsRolepStringUpdateCallback );

    if ( ERROR_SUCCESS != WinError ) {

        DsRolepLogOnFailure( WinError,
                             DsRolepLogPrint(( DEB_ERROR,
                                               "Setting security on server files failed with %lu\n",
                                               WinError )) );

        if (ERROR_SUCCESS == WinError) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "Set security on server files\n" ));
        }

        // This error has been handled
        WinError = ERROR_SUCCESS;
    }

    //
    // remove all trusted root certificates from DC when the machine will dis-join from the enterprise
    //
    if (DemoteArgs->ServerRole == DsRoleServerStandalone) {

        if (!CertAutoRemove(CERT_AUTO_REMOVE_COMMIT)){

            DsRolepLogPrint(( DEB_WARN,
                              "Failed to remove all trusted root certificates from this machine: (%d)\n",
                              GetLastError()));

        }

    } 

    //
    // Notify the time server we have completed the demotion
    //
    (*DsrW32TimeDcPromo)( W32TIME_DEMOTE );
    

    //
    // At this point we have successfully completed the demotion
    //
    ASSERT( ERROR_SUCCESS == WinError );

    //
    // Clear errors components may have erroneously set while running
    //
    DsRolepClearErrors();

DemoteExit:

    if ( Policy ) {

        LsaClose( Policy );
    }

    if ( Credentials ) {

        RtlFreeHeap( RtlProcessHeap(), 0, Credentials );

    }

    if ( pDnsRRInfo ) {

        ( *DsrNtdsFreeDnsRRInfo )(pDnsRRInfo);
        
    }

    //
    // Tear down the session to the parent, if we have one
    //
    if ( IPCConnection ) {

        RtlRunDecodeUnicodeString( DemoteArgs->Decode, &DemoteArgs->Password );
        IgnoreError = ImpNetpManageIPCConnect( DemoteArgs->ImpersonateToken,
                                               SupportDc,
                                               DemoteArgs->Account,
                                               DemoteArgs->Password.Buffer,
                                               (NETSETUPP_DISCONNECT_IPC|NETSETUPP_USE_LOTS_FORCE) );
        RtlRunEncodeUnicodeString( &DemoteArgs->Decode, &DemoteArgs->Password );
        if ( IgnoreError != ERROR_SUCCESS ) {

            DsRolepLogPrint(( DEB_WARN,
                             "Failed to destroy the session with %ws: 0x%lx\n", SupportDc,
                             IgnoreError ));
        }

        IPCConnection = FALSE;
    }

    //Delete persistent shares 
    NetStatus = NetShareDel( NULL, L"SYSVOL", 0);

    if(NetStatus != ERROR_SUCCESS) {

        DsRolepLogPrint(( DEB_WARN,
                             "Failed to destroy the share SYSVOL.  Failed with %d\n", NetStatus ));
    }


    NetStatus = NetShareDel( NULL, L"NETLOGON", 0);

    if(NetStatus != ERROR_SUCCESS) {

        DsRolepLogPrint(( DEB_WARN,
                             "Failed to destroy the share NETLOGON.  Failed with %d\n", NetStatus ));
    }

    //
    // Reset our operation handle
    //
    DsRolepSetOperationDone( DSROLEP_OP_DEMOTION, WinError );

    DsRolepFreeArgumentBlock( &ArgumentBlock, FALSE );

    LsaFreeMemory( DnsDomainInfo );

    RtlFreeHeap( RtlProcessHeap(), 0, ParentDomainName );

    NetApiBufferFree( DomainControllerInfo );

    
    ExitThread( WinError );
    return( WinError );

DemoteUndo:

    //
    // Assert that aomething went wrong if we are here
    //
    ASSERT( ERROR_SUCCESS != WinError );

    //
    // We shouldn't be here if we are in an unrollable state
    //
    ASSERT( FALSE == Unrollable );

    if ( FrsDemote ) {

        IgnoreError = DsRolepFinishSysVolPropagation( FALSE,
                                                      FALSE );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to abort system volume demotion (%d)\n",
                                                IgnoreError )) );

        FrsDemote = FALSE;
    }

    if ( NotifiedNetlogonToDeregister ) {

        //
        // "NlDcDemotionCompleted" sounds strange here since the demotion
        // failed.  However, the meaning is that netlogon should now continue
        // to perform as if demotion is not running.  No need to set in the
        // success case since NETLOGON won't be restarted.
        //

        Status = I_NetNotifyDsChange( NlDcDemotionCompleted );
        IgnoreError = RtlNtStatusToDosError( Status );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to tell NETLOGON that demotion is over (%d)\n",
                                                IgnoreError )) );

        NotifiedNetlogonToDeregister = FALSE;
        
    }

    if ( RestartNetlogon ) {

        IgnoreError = DsRolepStartNetlogon();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to restart netlogon (%d)\n",
                                                IgnoreError )) );

        RestartNetlogon = FALSE;
    }

    if ( DomainControllerServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainControllerServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );

        DomainControllerServicesChanged = FALSE;
    }

    if ( DomainServicesChanged ) {

        IgnoreError = DsRolepConfigureDomainServices( DSROLEP_SERVICES_REVERT );

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to rollback domain controller services configuration (%d)\n",
                                                IgnoreError )) );

        DomainServicesChanged = FALSE;
    }

    if ( DsPrepareDemote ) {

        IgnoreError = ( *DsrNtdsPrepareForDemotionUndo ) ();

        DsRolepLogOnFailure( IgnoreError,
                             DsRolepLogPrint(( DEB_WARN,
                                               "Failed to undo directory service preparation for demotion (%d)\n",
                                                IgnoreError )) );


        DsPrepareDemote = FALSE;

    }

    //
    // Ok -- we have rolled back, make sure we still have an error and then 
    // exit
    //
    ASSERT( ERROR_SUCCESS != WinError );

    goto DemoteExit;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\threadman.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    Routines the

Author:

    Colin Brace        (ColinBr)    April 5, 1999
Environment:

    User Mode

Revision History:

    Mac McLain          (MacM)       Feb 10, 1997
    
--*/
#ifndef __THREADMAN_H__
#define __THREADMAN_H__

//
// Arguments for the promote thread
//
typedef struct _DSROLEP_OPERATION_PROMOTE_ARGS {

    LPWSTR DnsDomainName;
    LPWSTR FlatDomainName;
    LPWSTR SiteName;
    LPWSTR DsDatabasePath;
    LPWSTR DsLogPath;
    LPWSTR RestorePath;
    LPWSTR SysVolRootPath;
    UNICODE_STRING Bootkey;
    LPWSTR Parent;
    LPWSTR Server;
    LPWSTR Account;
    UNICODE_STRING Password;
    UNICODE_STRING DomainAdminPassword;
    ULONG Options;
    HANDLE ImpersonateToken;
    UCHAR Decode;
    UNICODE_STRING SafeModePassword;
} DSROLEP_OPERATION_PROMOTE_ARGS, *PDSROLEP_OPERATION_PROMOTE_ARGS;

//
// Argument threads for the demotion thread
//
typedef struct _DSROLEP_OPERATION_DEMOTE_ARGS {

    DSROLE_SERVEROP_DEMOTE_ROLE ServerRole;
    LPWSTR DomainName;
    LPWSTR Account;
    UNICODE_STRING Password;
    BOOLEAN LastDcInDomain;
    UNICODE_STRING AdminPassword;
    ULONG Options;
    HANDLE ImpersonateToken;
    UCHAR Decode;
} DSROLEP_OPERATION_DEMOTE_ARGS, *PDSROLEP_OPERATION_DEMOTE_ARGS;


//
// Prototypes for thread functions
//
DWORD
DsRolepThreadPromoteDc(
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepThreadPromoteReplica(
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepThreadDemote(
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepSpinWorkerThread(
    IN DSROLEP_OPERATION_TYPE Operation,
    IN PVOID ArgumentBlock
    );

DWORD
DsRolepBuildPromoteArgumentBlock(
    IN LPWSTR DnsDomainName,
    IN LPWSTR FlatDomainName,
    IN LPWSTR SiteName,
    IN LPWSTR DsDatabasePath,
    IN LPWSTR DsLogPath,
    IN LPWSTR RestorePath,
    IN LPWSTR SystemVolumeRootPath,
    IN PUNICODE_STRING Bootkey,
    IN LPWSTR Parent,
    IN LPWSTR Server,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING DomainAdminPassword,
    IN PUNICODE_STRING SafeModeAdminPassword,
    IN ULONG Options,
    IN UCHAR PasswordSeed,
    IN OUT PDSROLEP_OPERATION_PROMOTE_ARGS *Promote
    );

DWORD
DsRolepBuildDemoteArgumentBlock(
    IN DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN LPWSTR DnsDomainName,
    IN LPWSTR Account,
    IN PUNICODE_STRING Password,
    IN ULONG Options,
    IN BOOL LastDcInDomain,
    IN PUNICODE_STRING DomainAdminPassword,
    IN UCHAR PasswordSeed,
    OUT PDSROLEP_OPERATION_DEMOTE_ARGS *Demote
    );


VOID
DsRolepFreeArgumentBlock(
    IN PVOID ArgumentBlock,
    IN BOOLEAN Promote
    );

#endif // __THREADMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\trustdom.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    trustdom.c

Abstract:

    Implementation of the functions to manage the trust link between 2 servers

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <db.h>
#include <lsads.h>
#include <lsasrvmm.h>
#include <lsaisrv.h>
#include <lmcons.h>
#include <cryptdll.h>

#include "trustdom.h"

DWORD
DsRolepSetLsaDnsInformationNoParent(
    IN  LPWSTR DnsDomainName
    )
/*++

Routine Description:

    In the case where we are installing as a standalong or root Dc, set the Lsa
    POLICY_DNS_DOMAIN_INFORMATION DnsForestName value to point to ourselves.

Arguments:

    DnsDomainName - Dns domain path to set

Returns:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPOLICY_DNS_DOMAIN_INFO CurrentDnsInfo;
    PLSAPR_POLICY_INFORMATION  LsaPolicy;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Policy;

    //
    // Open our local policy
    //
    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_WRITE,
                            &Policy );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Get the current information
        //
        Status =  LsaQueryInformationPolicy( Policy,
                                             PolicyDnsDomainInformation,
                                             ( PVOID * )&LsaPolicy );
        if ( NT_SUCCESS( Status ) ) {

            //
            // Add in the new...
            //
            CurrentDnsInfo = (PPOLICY_DNS_DOMAIN_INFO)LsaPolicy;
            RtlInitUnicodeString( &CurrentDnsInfo->DnsForestName, DnsDomainName );

            DsRolepLogPrint(( DEB_TRACE, "Configuring DnsForestName to %ws\n",
                              DnsDomainName ));

            //
            // And write it out..
            //
            Status = LsaSetInformationPolicy( Policy,
                                              PolicyDnsDomainInformation,
                                              LsaPolicy );


            //
            // Don't want to actually free the passed in buffer
            //
            RtlZeroMemory( &CurrentDnsInfo->DnsForestName, sizeof( UNICODE_STRING ) );

            LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation, LsaPolicy );

        }

        LsaClose( Policy );

    }

    DsRolepLogOnFailure( Status,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "DsRolepSetLsaDnsInformationNoParent failed with 0x%lx\n",
                                           Status )) );

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
DsRolepCreateTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN LPWSTR DnsDomainName,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    )
/*++

Routine Description:

    Creates the trusted domain object on the domains if they should exist and sets the
    Lsa POLICY_DNS_DOMAIN_INFORMATION DnsTree value to either the value of our parent in
    a parent/child install, or as the root otherwise.

Arguments:

    ParentDc - Optional.  Name of the parent Dc

    DnsDomainName - Dns name of the domain we're installing into

    ParentDnsDomainInfo - DNS domain information obtained from the parent

    Options - Options that dictate what steps are taken

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ParentServer;
    HANDLE LocalPolicy = NULL , ParentPolicy = NULL;
    PPOLICY_DNS_DOMAIN_INFO LocalDnsInfo = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ParentTrustedDomain = NULL;

    WCHAR GeneratedPassword[ PWLEN + 1 ];
    ULONG Length = PWLEN;

    LSA_AUTH_INFORMATION AuthData;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx;

    DSROLEP_CURRENT_OP1( DSROLEEVT_SET_LSA_FROM, ParentDc );

    //
    // Make the Lsa think that we're initialized
    //
    Status = LsapDsInitializeDsStateInfo( LsapDsDsSetup );

    if ( !NT_SUCCESS( Status ) ) {

        DsRolepLogPrint(( DEB_TRACE,
                          "Failed to convince Lsa to reinitialize: 0x%lx\n",
                          Status ));

        return( RtlNtStatusToDosError( Status ) );
    }


    //
    // Prepare the Auth Info
    //
    RtlZeroMemory( &AuthInfoEx, sizeof(AuthInfoEx) );
    RtlZeroMemory( &AuthData, sizeof(AuthData) );
    RtlZeroMemory( &GeneratedPassword, sizeof(GeneratedPassword) );

    Win32Err = DsRolepGenerateRandomPassword( Length,
                                              GeneratedPassword );

    if ( ERROR_SUCCESS == Win32Err ) {

        Status = NtQuerySystemTime( &AuthData.LastUpdateTime );

        if ( NT_SUCCESS( Status ) ) {

            AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
            AuthData.AuthInfoLength = Length;
            AuthData.AuthInfo = (PUCHAR)GeneratedPassword;

            AuthInfoEx.IncomingAuthInfos = 1;
            AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
            AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;


            AuthInfoEx.OutgoingAuthInfos = 1;
            AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
            AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;

        }

    } else {


        DsRolepLogPrint(( DEB_ERROR,
                          "Failed to generate a trust password: %lu\n",
                          Win32Err ));

        Status = STATUS_UNSUCCESSFUL;
    }


    if ( NT_SUCCESS( Status ) ) {

        //
        // Open both lsas
        //
        RtlInitUnicodeString( &ParentServer, ParentDc );
    
        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
    
        Status = ImpLsaOpenPolicy( CallerToken,
                                  &ParentServer,
                                  &ObjectAttributes,
                                   POLICY_TRUST_ADMIN | POLICY_VIEW_LOCAL_INFORMATION,
                                   &ParentPolicy 
                                   );
    
        if ( NT_SUCCESS( Status ) ) {
    
            RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
            Status = LsaOpenPolicy( NULL,
                                    &ObjectAttributes,
                                    POLICY_TRUST_ADMIN | POLICY_VIEW_LOCAL_INFORMATION,
                                    &LocalPolicy );
        } else {
    
            DsRolepLogPrint(( DEB_TRACE,
                              "OpenPolicy on %ws failed with 0x%lx\n",
                              ParentDc,
                              Status ));
        }

    }

    //
    // Get our local dns domain information
    //
    if ( NT_SUCCESS( Status ) ) {


        Status = LsaQueryInformationPolicy( LocalPolicy,
                                            PolicyDnsDomainInformation,
                                            &LocalDnsInfo );
    }

    //
    // Now, create the trusted domain objects
    //
    if ( NT_SUCCESS( Status ) ) {

        DSROLEP_CURRENT_OP1( DSROLEEVT_CREATE_PARENT_TRUST,
                             ParentDnsDomainInfo->DnsDomainName.Buffer );


        if ( !FLAG_ON( Options, DSROLE_DC_PARENT_TRUST_EXISTS ) ||
             FLAG_ON( Options, DSROLE_DC_CREATE_TRUST_AS_REQUIRED ) ) {

            DsRoleDebugOut(( DEB_TRACE_DS, "Creating trust object ( %lu ) on %ws\n",
                             Options,
                             ParentDc ));

            Status = DsRolepCreateParentTrustObject( CallerToken,
                                                     ParentPolicy,
                                                     LocalDnsInfo,
                                                     Options,
                                                     &AuthInfoEx,
                                                     &ParentTrustedDomain );

            if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

                DSROLEP_FAIL2( RtlNtStatusToDosError( Status ),
                               DSROLERES_PARENT_TRUST_EXISTS, ParentDc, DnsDomainName );

            } else {

                DSROLEP_FAIL2( RtlNtStatusToDosError( Status ),
                               DSROLERES_PARENT_TRUST_FAIL, DnsDomainName, ParentDc );
            }
        }

        //
        // Now the child
        //
        if ( NT_SUCCESS( Status ) ) {

            DSROLEP_CURRENT_OP1( DSROLEEVT_CREATE_TRUST,
                                 LocalDnsInfo->DnsDomainName.Buffer );
            Status = DsRolepCreateChildTrustObject( CallerToken,
                                                    ParentPolicy,
                                                    LocalPolicy,
                                                    ParentDnsDomainInfo,
                                                    LocalDnsInfo,
                                                    &AuthInfoEx,
                                                    Options );


            if ( !NT_SUCCESS( Status ) ) {

                DsRolepLogPrint(( DEB_TRACE,
                                  "DsRolepCreateChildTrustObject failed: 0x%lx\n",
                                  Status ));
                
            }
            //
            // If we created the parent object, we had better try and delete it now.  Note that
            // it isn't fatal if we can't
            //
            if ( !NT_SUCCESS( Status ) && !FLAG_ON( Options, DSROLE_DC_PARENT_TRUST_EXISTS ) ) {

                NTSTATUS Status2;

                Status2 = ImpLsaDelete( CallerToken, ParentTrustedDomain );

                if ( !NT_SUCCESS( Status2 ) ) {
    
                    DsRolepLogPrint(( DEB_TRACE,
                                      "LsaDelete of ParentTrustedDomain failed: 0x%lx\n",
                                      Status2 ));
                    
                }


            } else {

                if ( ParentTrustedDomain ) {

                    ImpLsaClose( CallerToken, ParentTrustedDomain );
                }
            }
        }
    }

    LsaFreeMemory( LocalDnsInfo );

    if ( LocalPolicy ) {

        LsaClose( LocalPolicy );
    }

    if ( ParentPolicy ) {

        ImpLsaClose( CallerToken, ParentPolicy );
    }

    // Don't leave the information in the pagefile
    RtlZeroMemory( &AuthInfoEx, sizeof(AuthInfoEx) );
    RtlZeroMemory( &AuthData, sizeof(AuthData) );
    RtlZeroMemory( &GeneratedPassword, sizeof(GeneratedPassword) );

    //
    // We won't bother cleaning up any of the DnsTreeInformation we set on the local machine in
    // the failure case, since it won't hurt anything to have it here.
    //


    return( RtlNtStatusToDosError( Status ) );
}

NTSTATUS
DsRolepHandlePreExistingTrustObject(
                        IN HANDLE Token, OPTIONAL
                        IN LSA_HANDLE Lsa,
                        TRUSTED_DOMAIN_INFORMATION_EX *pTDIEx,
                        TRUSTED_DOMAIN_AUTH_INFORMATION * pAuthInfoEx,
                        OUT PLSA_HANDLE TrustedDomainHandle
                        )
/*++

  This routine does the appropriate handling for the case of the pre existing
  trust object ( ie opening the object, checking if it were the right one 
  and then deleting it if required

  Paramters

    Token -- token to impersonate if necessary (used when talking to remote
             server)
             
    Lsa  Handle to the LSA
    pTDIEx the TDO that is being created that recieved the object name collision error

  Return Values

    STATUS_SUCCESS
    Other Error Codes
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_HANDLE    TrustedDomain = 0;

    *TrustedDomainHandle = 0;

    // We should have something to go on
    ASSERT(   pTDIEx->Sid 
           || (pTDIEx->FlatName.Length > 0) 
           || (pTDIEx->Name.Length > 0) );

    //
    // We have a conflict, either by name or by sid.
    // Try to open by sid, dns domain name, and then flat domain name
    //
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    if (  (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        && pTDIEx->Sid ) {

        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaOpenTrustedDomain( Token,
                                              Lsa,
                                              pTDIEx->Sid,
                                              DELETE,
                                           ( PVOID * )&TrustedDomain);
            
        } else {

            Status = LsaOpenTrustedDomain( Lsa,
                                           pTDIEx->Sid,
                                           DELETE,
                                           ( PVOID * )&TrustedDomain);

        }
        

        if ( !NT_SUCCESS( Status ) ) {

            DsRolepLogPrint(( DEB_WARN,
                              "Failed to find trust object by sid: 0x%lx\n",
                              Status ));

            if ( STATUS_NO_SUCH_DOMAIN == Status ) {
                
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
            
        }
    }

    if ( (Status == STATUS_OBJECT_NAME_NOT_FOUND)
      && pTDIEx->Name.Length > 0   ) {

        //
        // Couldn't find by sid -- try dns name
        //
        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaOpenTrustedDomainByName( Token,
                                                    Lsa,
                                                  &pTDIEx->Name,
                                                   DELETE,
                                                 ( PVOID * ) &TrustedDomain );
            
        } else {

            Status = LsaOpenTrustedDomainByName( Lsa,
                                                &pTDIEx->Name,
                                                 DELETE,
                                                 ( PVOID * ) &TrustedDomain );

        }
        if ( !NT_SUCCESS( Status ) ) {

            WCHAR *BufpTDIEx = NULL;
            DsRolepUnicodestringtowstr( BufpTDIEx, pTDIEx->Name )
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_WARN,
                                  "Failed to find trust object for %ws: 0x%lx\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            }
        }
    }

    if ( (Status == STATUS_OBJECT_NAME_NOT_FOUND) 
      && pTDIEx->FlatName.Length > 0 ) {

        //
        // Couldn't find by dns name -- try flat name
        //
        if ( ARGUMENT_PRESENT(Token) ) {
            
            Status = ImpLsaOpenTrustedDomainByName( Token, 
                                                    Lsa,
                                                   &pTDIEx->FlatName,
                                                   DELETE,
                                                 ( PVOID * )&TrustedDomain );
        } else {

            Status = LsaOpenTrustedDomainByName( Lsa,
                                                 &pTDIEx->FlatName,
                                                 DELETE,
                                                 ( PVOID * )&TrustedDomain );
        }

        if ( !NT_SUCCESS( Status ) ) {

            WCHAR *BufpTDIEx = NULL;
            DsRolepUnicodestringtowstr( BufpTDIEx, pTDIEx->FlatName )
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_WARN,
                                  "Failed to find trust object for %ws: 0x%lx\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            }
        }
    }

    if ( NT_SUCCESS( Status ) ) {

        //
        // We found it
        //
        ASSERT( 0 != TrustedDomain );

        if ( ARGUMENT_PRESENT(Token) ) {

            Status = ImpLsaDelete( Token, TrustedDomain );
            
        }  else {

            Status = LsaDelete( TrustedDomain );

        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Raise an event that we had deleted an existing trust object
            //
            SpmpReportEvent( TRUE,
                             EVENTLOG_WARNING_TYPE,
                             DSROLERES_INCOMPATIBLE_TRUST,
                             0,
                             sizeof( ULONG ),
                             &Status,
                             1,
                             pTDIEx->Name.Buffer );
        
            DSROLEP_SET_NON_FATAL_ERROR( 0 );

        } else {

            DsRolepLogPrint(( DEB_WARN,
                              "Failed to delete trust object: 0x%lx\n",
                              Status ));
            
        }

    } else {

        DsRolepLogPrint(( DEB_WARN,
                          "Couldn't find existing trust object: 0x%lx\n",
                          Status ));

    }

    //
    // At this point, we tried our best to remove the offending object
    // Retry the create
    //
    Status = STATUS_SUCCESS;

    DsRolepLogPrint(( DEB_TRACE, "Attempting to recreate trust object\n" ));
    
    
    //
    // Now, let us go ahead and recreate the trust object on the
    // parent
    //
    if ( ARGUMENT_PRESENT(Token) ) {
        Status = ImpLsaCreateTrustedDomainEx( Token,
                                              Lsa,
                                              pTDIEx,
                                              pAuthInfoEx,
                                              DELETE,  // the only thing we do with 
                                                    // this handle is delete on
                                                    // failure
                                             &TrustedDomain );
        
    } else {

        Status = LsaCreateTrustedDomainEx( Lsa,
                                           pTDIEx,
                                           pAuthInfoEx,
                                           DELETE,  // the only thing we do with 
                                                    // this handle is delete on
                                                    // failure
                                           &TrustedDomain );
    }
    
    if ( !NT_SUCCESS( Status ) ) {

        //
        // We want to capture and examine these cases
        //
        WCHAR *BufpTDIEx = NULL;

        ASSERT( NT_SUCCESS( Status ) );

        DsRolepUnicodestringtowstr( BufpTDIEx, pTDIEx->Name )
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Second Trust creation"
                              "with %ws failed with 0x%lx\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }
    }

    if (NT_SUCCESS(Status))
    {
        *TrustedDomainHandle = TrustedDomain;
    }
    else
    {
        ASSERT(!TrustedDomain);
    }


    return (Status);

}


NTSTATUS
DsRolepCreateParentTrustObject(
    IN HANDLE CallerToken, 
    IN LSA_HANDLE ParentLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN ULONG Options,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    OUT PLSA_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    Creates the trusted domain object on the parent domain.  If the object does not exist,
    it will create the object and initialize it with a random password

Arguments:

    CallerToken - token to impersonate when talking to remote server 
                  
    ParentLsa - Handle to the Lsa on the parent Dc

    ChildDnsInfo - POLICY_DNS_DOMAIN_INFORMAITON from ourself

    Options - Options that dictate what steps are taken

    TrustedDomainHandle - Where the trusted domain handle is returned

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR GeneratedPassword[ PWLEN + 1 ];
    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    LSA_AUTH_INFORMATION AuthData;
    PTRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx = NULL;
    LSA_HANDLE TrustedDomain;
    LARGE_INTEGER Time;
    ULONG Seed, Length = PWLEN, i, Win32Err;
    PSID OpenSid = NULL;
    BOOLEAN DeleteExistingTrust = FALSE;

    RtlCopyMemory( &TDIEx.Name, &ChildDnsInfo->DnsDomainName,
                   sizeof( UNICODE_STRING ) );
    RtlCopyMemory( &TDIEx.FlatName, &ChildDnsInfo->Name,
                   sizeof( UNICODE_STRING ) );
    TDIEx.Sid = ChildDnsInfo->Sid;

    if ( TDIEx.Name.Length &&
         TDIEx.Name.Buffer[ ( TDIEx.Name.Length - 1 ) / sizeof(WCHAR)] == L'.' ) {

        TDIEx.Name.Buffer[ ( TDIEx.Name.Length - 1 ) / sizeof(WCHAR)] = UNICODE_NULL;
        TDIEx.Name.Length -= sizeof(WCHAR);

    }

    TDIEx.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
    TDIEx.TrustType = TRUST_TYPE_UPLEVEL;
    TDIEx.TrustAttributes = 0;

    {
        WCHAR *BufpTDIEx = NULL;
        
        DsRolepLogPrint(( DEB_TRACE, "Creating trusted domain object on parent\n" ));
        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "\tDnsDomain: %ws\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        } 

        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.FlatName );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "\tFlat name: %ws\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }
        DsRolepLogPrint(( DEB_TRACE, "\tDirection: %lu\n", TDIEx.TrustDirection ));
        DsRolepLogPrint(( DEB_TRACE, "\tType: %lu\n", TDIEx.TrustType ));
        DsRolepLogPrint(( DEB_TRACE, "\tAttributes: 0x%lx\n", TDIEx.TrustAttributes ));
    }

    Status = ImpLsaCreateTrustedDomainEx( CallerToken,
                                          ParentLsa,
                                         &TDIEx,
                                          AuthInfoEx,
                                          DELETE,  // we may have to delete on 
                                                // rollback
                                       &TrustedDomain );
    if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

        DsRolepLogPrint(( DEB_TRACE, "Parent trust object already exists on parent\n" ));

        Status = DsRolepHandlePreExistingTrustObject(
                        CallerToken,
                        ParentLsa,
                        &TDIEx,
                        AuthInfoEx,
                        &TrustedDomain
                        );


    } else if ( Status != STATUS_SUCCESS ) {

        WCHAR *BufpTDIEx = NULL;
            
        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Parent LsaCreateTrustedDomainEx on %ws failed with 0x%lx\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }

    }

    if ( NT_SUCCESS( Status ) ) {

        *TrustedDomainHandle = TrustedDomain;

    }

    return( Status );
}



NTSTATUS
DsRolepCreateChildTrustObject(
    IN HANDLE CallerToken,
    IN LSA_HANDLE ParentLsa,
    IN LSA_HANDLE ChildLsa,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsInfo,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDnsInfo,
    IN PTRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx,
    IN ULONG Options
    )
/*++

Routine Description:

    Creates the trusted domain object on the child domain.  It does this by reading the
    auth info stored on the parent object, swapping its order, and writing it on the child
    object

Arguments:

    ParentLsa - Handle to the Lsa on the parent Dc

    ChildLsa - Handle to our local Lsa

    ParentDnsInfo - POLICY_DNS_DOMAIN_INFORMATION from our parent Dc

    ChildDnsInfo - POLICY_DNS_DOMAIN_INFORMAITON from ourself

    Options - Options that dictate what steps are taken

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, SecondaryStatus;
    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    PTRUSTED_DOMAIN_INFORMATION_EX ParentEx;
    PTRUSTED_DOMAIN_AUTH_INFORMATION ParentAuthData;
    LSA_HANDLE TrustedDomain;
    UNICODE_STRING ChildDnsName;

    //
    // Basically, we'll create a trusted domain object with no auth data, and then pull over the
    // auth data from our parent.
    //
    RtlCopyMemory( &TDIEx.Name, &ParentDnsInfo->DnsDomainName,
                   sizeof( UNICODE_STRING ) );
    RtlCopyMemory( &TDIEx.FlatName, &ParentDnsInfo->Name,
                   sizeof( UNICODE_STRING ) );
    TDIEx.Sid = ParentDnsInfo->Sid;
    TDIEx.TrustAttributes = 0;

    //
    // Note that if the parent object exists, we'll want to read it's properties, and
    // set our trust up accordingly
    //
    if ( FLAG_ON( Options, DSROLE_DC_PARENT_TRUST_EXISTS ) ) {

        Status = ImpLsaQueryTrustedDomainInfoByName( CallerToken,
                                                     ParentLsa,
                                                    &ChildDnsInfo->DnsDomainName,
                                                    TrustedDomainInformationEx,
                                                   ( PVOID * )&ParentEx );

        if ( !NT_SUCCESS( Status ) ) {

            WCHAR *BufDnsDomainName = NULL;
            
            DsRolepUnicodestringtowstr( BufDnsDomainName, ChildDnsInfo->DnsDomainName );
            if (BufDnsDomainName) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "Failed to read trust info from parent for %ws: 0x%lx\n",
                                  BufDnsDomainName,
                                  Status ));
                free(BufDnsDomainName);
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            //
            // Make sure that the trust on the parent object is correct
            //
            if ( ChildDnsInfo->Sid == NULL ||
                 ParentEx->Sid == NULL ||
                 !RtlEqualSid( ChildDnsInfo->Sid, ParentEx->Sid ) ||
                 RtlEqualUnicodeString( &ChildDnsInfo->Name, &ParentEx->Name, TRUE ) ) {

                Status = STATUS_DOMAIN_TRUST_INCONSISTENT;
            }
        }

        if ( NT_SUCCESS( Status ) ) {

            TDIEx.TrustDirection = 0;
            TDIEx.TrustType = 0;
            if ( FLAG_ON( ParentEx->TrustDirection, TRUST_DIRECTION_INBOUND ) ) {

                TDIEx.TrustDirection |= TRUST_DIRECTION_OUTBOUND;
            }

            if ( FLAG_ON( ParentEx->TrustDirection, TRUST_DIRECTION_OUTBOUND ) ) {

                TDIEx.TrustDirection |= TRUST_DIRECTION_INBOUND;
            }

            TDIEx.TrustType = ParentEx->TrustType;

            LsaFreeMemory( ParentEx );
        }

        DSROLEP_FAIL1( RtlNtStatusToDosError( Status ),
                       DSROLERES_NO_PARENT_TRUST, ParentDnsInfo->DnsDomainName.Buffer );


    } else {

        TDIEx.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
        TDIEx.TrustType = TRUST_TYPE_UPLEVEL;

        RtlCopyMemory( &ChildDnsName, &ChildDnsInfo->DnsDomainName, sizeof( UNICODE_STRING ) );
        if ( ChildDnsName.Buffer[ (ChildDnsName.Length - 1) / sizeof(WCHAR)] == L'.' ) {

            ChildDnsName.Buffer[ (ChildDnsName.Length - 1) / sizeof(WCHAR)] = UNICODE_NULL;
            ChildDnsName.Length -= sizeof(WCHAR);

        }
    }

    if ( NT_SUCCESS( Status ) ) {

        {
            WCHAR *BufpTDIEx = NULL;
            
            DsRolepLogPrint(( DEB_TRACE, "Creating trusted domain object on child\n" ));
            DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "\tDnsDomain: %ws\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            } 
    
            DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.FlatName );
            if (BufpTDIEx) {
                DsRolepLogPrint(( DEB_TRACE,
                                  "\tFlat name: %ws\n",
                                  BufpTDIEx,
                                  Status ));
                free(BufpTDIEx);
            } 
            DsRolepLogPrint(( DEB_TRACE, "\tDirection: %lu\n", TDIEx.TrustDirection ));
            DsRolepLogPrint(( DEB_TRACE, "\tType: %lu\n", TDIEx.TrustType ));
            DsRolepLogPrint(( DEB_TRACE, "\tAttributes: 0x%lx\n", TDIEx.TrustAttributes ));
        }

        Status = LsaCreateTrustedDomainEx( ChildLsa,
                                           &TDIEx,
                                           AuthInfoEx,
                                           0,   // no access necessary
                                           &TrustedDomain );

    }

    if (STATUS_OBJECT_NAME_COLLISION==Status)
    {
        //
        // The object might actually exist, in cases we are upgrading from NT4 etc
        //
        DsRolepLogPrint(( DEB_TRACE, "Child domain trust object already exists on child\n" ));
        Status = DsRolepHandlePreExistingTrustObject(
                                NULL,
                                ChildLsa,
                                &TDIEx,
                                AuthInfoEx,
                                &TrustedDomain
                                );

        
    }

    if ( !NT_SUCCESS( Status ) ) {

        WCHAR *BufpTDIEx = NULL;
            
        DsRolepUnicodestringtowstr( BufpTDIEx, TDIEx.Name );
        if (BufpTDIEx) {
            DsRolepLogPrint(( DEB_TRACE,
                              "Child LsaCreateTrustedDomainEx on %ws failed with 0x%lx\n",
                              BufpTDIEx,
                              Status ));
            free(BufpTDIEx);
        }

        DSROLEP_FAIL1( RtlNtStatusToDosError( Status ),
                       DSROLERES_NO_PARENT_TRUST, ParentDnsInfo->DnsDomainName.Buffer );

    } else {

        //
        // We should have a trusted domain object
        //
        ASSERT( 0 != TrustedDomain );
        if ( TrustedDomain ) {
            
            LsaClose( TrustedDomain );
            
        }
    }

    return( Status );
}




DWORD
DsRolepRemoveTrustedDomainObjects(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ParentDnsDomainInfo,
    IN ULONG Options
    )
/*++

Routine Description:

    This function will remove the trusted domain objects as a link is being torn down.
    It will determine who the trust is with, and remove the local trust to that object.
    Optionally, it will also remove the trust from the parent

Arguments:

    ParentDc - Optional name of a Dc on our parent

    ParentDnsDomainInfo - DNS Domain information from the parent

    Options - Whether to remove the parents object or not

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad option was provided

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ParentServer;
    HANDLE LocalPolicy = NULL , ParentPolicy = NULL;
    HANDLE Trust;
    PPOLICY_DNS_DOMAIN_INFO LocalDnsInfo = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DSROLEP_CURRENT_OP0( DSROLEEVT_DELETE_TRUST );

    //
    // If there is no parent Dc, there is no trust...
    //
    if ( ParentDc == NULL ) {

        return( ERROR_SUCCESS );
    }

    //
    // Open both lsas
    //
    RtlInitUnicodeString( &ParentServer, ParentDc );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = ImpLsaOpenPolicy( CallerToken,
                              &ParentServer,
                              &ObjectAttributes,
                              MAXIMUM_ALLOWED,
                              &ParentPolicy );

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );
        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &LocalPolicy );
    } else {

        DsRolepLogPrint(( DEB_TRACE,
                          "OpenPolicy on %ws failed with 0x%lx\n",
                          ParentDc,
                          Status ));
    }

    //
    // Get the DnsTree information from the local machine
    //
    if ( NT_SUCCESS( Status ) ) {


        Status = LsaQueryInformationPolicy( LocalPolicy,
                                            PolicyDnsDomainInformation,
                                            &LocalDnsInfo );
    }

    //
    // Now, open the parent trusted domain object
    //
    if ( NT_SUCCESS( Status ) && FLAG_ON( Options, DSROLE_DC_DELETE_PARENT_TRUST )  ) {

        Status = ImpLsaOpenTrustedDomain( CallerToken,
                                         ParentPolicy,
                                         LocalDnsInfo->Sid,
                                         DELETE,
                                         &Trust );

        if ( NT_SUCCESS( Status ) ) {

            Status = ImpLsaDelete( CallerToken, Trust );

        } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;

        }

    }

    //
    // Now, the local one
    //
    if ( NT_SUCCESS( Status ) ) {

        Status = LsaOpenTrustedDomain( LocalPolicy,
                                       ParentDnsDomainInfo->Sid,
                                       DELETE,
                                       &Trust );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaDelete( Trust );

        } else if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            Status = STATUS_SUCCESS;

        }

    }


    //
    // Cleanup
    //
    LsaFreeMemory( LocalDnsInfo );

    if ( LocalPolicy ) {

        LsaClose( LocalPolicy );
    }

    if ( ParentPolicy ) {

        ImpLsaClose( CallerToken, ParentPolicy );
    }

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
DsRolepDeleteParentTrustObject(
    IN HANDLE CallerToken,
    IN LPWSTR ParentDc,
    IN PPOLICY_DNS_DOMAIN_INFO ChildDomainInfo
    )
/*++

Routine Description:

    Deletes the trusted domain object on the parent domain.

Arguments:

    ParentDc - Name of a Dc in the parent domain to connect to

    ChildDnsInfo - POLICY_DNS_DOMAIN_INFORMAITON from ourself

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad results pointer was given

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ParentServer;
    HANDLE ParentPolicy = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ParentTrustedDomain, TrustedDomain;

    RtlInitUnicodeString( &ParentServer, ParentDc );

    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = ImpLsaOpenPolicy( CallerToken,
                              &ParentServer,
                              &ObjectAttributes,
                               POLICY_TRUST_ADMIN|POLICY_VIEW_LOCAL_INFORMATION,
                              &ParentPolicy );

    if ( NT_SUCCESS( Status ) ) {

        Status = ImpLsaOpenTrustedDomain( CallerToken,
                                          ParentPolicy,
                                          ChildDomainInfo->Sid,
                                          DELETE,
                                         &TrustedDomain );

        if ( NT_SUCCESS( Status ) ) {

            Status = ImpLsaDelete( CallerToken, TrustedDomain );

            if ( !NT_SUCCESS( Status ) ) {

                ImpLsaClose( CallerToken, TrustedDomain );
            }
        }

        ImpLsaClose( CallerToken, ParentPolicy );
    }


    return( RtlNtStatusToDosError( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\upgrade.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dssetp.ch

Abstract:

    local funciton prototypes/defines

Author:

    Mac McLain          (MacM)       Feb 10, 1997

Environment:

    User Mode

Revision History:

--*/
#ifndef __UPGRADE_H__
#define __UPGRADE_H__

DWORD
DsRolepSaveUpgradeState(
    IN LPWSTR AnswerFile
    );

DWORD
DsRolepDeleteUpgradeInfo(
    VOID
    );

DWORD
DsRolepQueryUpgradeInfo(
    OUT PBOOLEAN IsUpgrade,
    OUT PULONG ServerRole
    );

DWORD
DsRolepSetLogonDomain(
    IN LPWSTR Domain,
    IN BOOLEAN FailureAllowed
    );

DWORD
DsRolepGetBuiltinAdminAccountName(
    OUT LPWSTR *BuiltinAdmin
    );

DWORD
DsRolepSetBuiltinAdminAccountPassword(
    IN LPWSTR Password
    );

#endif // __UPGRADE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\delprof\delprof.c ===
//*************************************************************
//  File name: delprof.c
//
//  Description:  Utility to delete user profiles
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <locale.h>
#include "delprof.h"
#include "userenv.h"

//
// Globals
//

BOOL bQuiet;
BOOL bIgnoreErrors;
BOOL bPromptBeforeDelete;
BOOL bLocalComputer = FALSE;
TCHAR szComputerName[MAX_PATH];
TCHAR szSystemRoot[2*MAX_PATH];
TCHAR szSystemDrive[2*MAX_PATH];
LONG lDays;
HINSTANCE hInst;
LPDELETEITEM lpDeleteList;
LONG lCurrentDateInDays;


//*************************************************************
//
//  Usage()
//
//  Purpose:    prints the usage info
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void Usage (void)
{
    TCHAR szTemp[100];

    LoadString (hInst, IDS_USAGE1, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE2, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE3, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE4, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE5, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE6, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE7, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE8, szTemp, 100);
    _tprintf(szTemp);

    LoadString (hInst, IDS_USAGE9, szTemp, 100);
    _tprintf(szTemp);
}


//*************************************************************
//
//  InitializeGlobals()
//
//  Purpose:    Initializes the global variables
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void InitializeGlobals (void)
{
    OSVERSIONINFO ver;
    SYSTEMTIME systime;


    //
    // Initialize global variables
    //

    bQuiet = FALSE;
    bIgnoreErrors = FALSE;
    bPromptBeforeDelete = FALSE;
    szComputerName[0] = TEXT('\0');
    lDays = 0;
    lpDeleteList = NULL;

    setlocale(LC_ALL,"");

    hInst = GetModuleHandle(TEXT("delprof.exe"));

    GetLocalTime (&systime);

    lCurrentDateInDays = gdate_dmytoday(systime.wYear, systime.wMonth, systime.wDay);
}


//*************************************************************
//
//  CheckGlobals()
//
//  Purpose:    Checks the global variables
//
//  Parameters: void
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void CheckGlobals (void)
{
    DWORD dwSize;
    TCHAR szTemp[MAX_PATH];

    //
    // If szComputerName is still NULL, fill in the computer name
    // we're running on.
    //

    if (szComputerName[0] == TEXT('\0')) {

       szComputerName[0] = TEXT('\\');
       szComputerName[1] = TEXT('\\');

       dwSize = MAX_PATH - 2;
       GetComputerName (szComputerName+2, &dwSize);
       bLocalComputer = TRUE;

    } else {

       //
       // Make sure that the computer name starts with \\
       //

       if (szComputerName[0] != TEXT('\\')) {
           szTemp[0] = TEXT('\\');
           szTemp[1] = TEXT('\\');
           _tcscpy(szTemp+2, szComputerName);
           _tcscpy(szComputerName, szTemp);
       }
    }


    //
    // If the user has requested to run in Quiet mode,
    // then we turn off the prompt on every delete option.
    //

    if (bQuiet) {
        bPromptBeforeDelete = FALSE;
    }

}


//*************************************************************
//
//  ParseCommandLine()
//
//  Purpose:    Parses the command line
//
//  Parameters: lpCommandLine   -   Command line
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL ParseCommandLine (LPTSTR lpCommandLine)
{
    LPTSTR lpTemp;
    TCHAR  szDays[32];


    //
    // Check for NULL command line
    //

    if (!lpCommandLine || !*lpCommandLine)
        return TRUE;


    //
    // Find the executable name
    //

    while (*lpCommandLine && (_tcsncmp(lpCommandLine, TEXT("delprof"), 7) != 0)) {
        lpCommandLine++;
    }

    if (!*lpCommandLine) {
        return TRUE;
    }


    //
    // Find the first argument
    //

    while (*lpCommandLine && ((*lpCommandLine != TEXT(' ')) &&
                              (*lpCommandLine != TEXT('/')) &&
                              (*lpCommandLine != TEXT('-')))) {
        lpCommandLine++;
    }


    //
    // Skip white space
    //

    while (*lpCommandLine && (*lpCommandLine == TEXT(' '))) {
        lpCommandLine++;
    }

    if (!*lpCommandLine) {
        return TRUE;
    }


    //
    // We should be at the first argument now.
    //

    if ((*lpCommandLine != TEXT('/')) &&  (*lpCommandLine != TEXT('-'))) {
        Usage();
        return FALSE;
    }


    while (1) {

        //
        // Increment the pointer and branch to the correct argument.
        //

        lpCommandLine++;

        switch (*lpCommandLine) {

            case TEXT('?'):
                Usage();
                ExitProcess(0);
                break;

            case TEXT('Q'):
            case TEXT('q'):
                bQuiet = TRUE;
                lpCommandLine++;
                break;

            case TEXT('I'):
            case TEXT('i'):
                bIgnoreErrors = TRUE;
                lpCommandLine++;
                break;

            case TEXT('P'):
            case TEXT('p'):
                bPromptBeforeDelete = TRUE;
                lpCommandLine++;
                break;

            case TEXT('C'):
            case TEXT('c'):

                //
                // Find the colon
                //

                lpCommandLine++;

                if (*lpCommandLine != TEXT(':')) {
                   Usage();
                   return FALSE;
                }


                //
                // Find the first character
                //

                lpCommandLine++;

                if (!*lpCommandLine) {
                   Usage();
                   return FALSE;
                }

                //
                // Copy the computer name
                //

                lpTemp = szComputerName;
                while (*lpCommandLine && ((*lpCommandLine != TEXT(' ')) &&
                                          (*lpCommandLine != TEXT('/')))){
                      *lpTemp++ = *lpCommandLine++;
                }
                *lpTemp = TEXT('\0');

                break;

            case TEXT('D'):
            case TEXT('d'):

                //
                // Find the colon
                //
                
                lpCommandLine++;

                if (*lpCommandLine != TEXT(':')) {
                   Usage();
                   return FALSE;
                }


                //
                // Find the first character
                //

                lpCommandLine++;

                if (!*lpCommandLine) {
                   Usage();
                   return FALSE;
                }

                //
                // Copy the number of days (in characters)
                //

                lpTemp = szDays;
                while (*lpCommandLine && ((*lpCommandLine != TEXT(' ')) &&
                                          (*lpCommandLine != TEXT('/')) &&
                                          (*lpCommandLine != TEXT('-')))) {
                      *lpTemp++ = *lpCommandLine++;
                }
                
                *lpTemp = TEXT('\0');


                //
                // Convert the days into a number
                //

                lDays = _ttol(szDays);
                break;

            default:
                Usage();
                return FALSE;
        }


        //
        // Skip white space
        //

        while (*lpCommandLine && (*lpCommandLine == TEXT(' '))) {
            lpCommandLine++;
        }


        if (!*lpCommandLine) {
            return TRUE;
        }


        //
        // We should be at the next argument now.
        //

        if ((*lpCommandLine != TEXT('/')) && (*lpCommandLine != TEXT('-'))) {
            Usage();
            return FALSE;
        }
    }

    return TRUE;
}


//*************************************************************
//
//  Confirm()
//
//  Purpose:    Confirm the user really wants to delete the profiles
//
//  Parameters: void
//
//  Return:     TRUE if we should continue
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL Confirm ()
{
    TCHAR szTemp[100];
    TCHAR tChar, tTemp;


    //
    // If we are prompting for every profile, then don't
    // give the general prompt.
    //

    if (bPromptBeforeDelete) {
        return TRUE;
    }


    //
    // If the user is requesting a specific day count,
    // give a more appropriate confirmation message.
    //

    if (lDays > 0) {
        LoadString (hInst, IDS_CONFIRMDAYS, szTemp, 100);
        _tprintf (szTemp, szComputerName, lDays);
    } else {
        LoadString (hInst, IDS_CONFIRM, szTemp, 100);
        _tprintf (szTemp, szComputerName);
    }

    tChar = _gettchar();

    tTemp = tChar;
    while (tTemp != TEXT('\n')) {
        tTemp = _gettchar();
    }


    if ((tChar == TEXT('Y')) || (tChar == TEXT('y'))) {
        return TRUE;
    }


    //
    // If the user didn't press Y/y, then we bail.
    //

    LoadString (hInst, IDS_NO, szTemp, 100);
    _tprintf (szTemp);

    return FALSE;
}


//*************************************************************
//
//  PrintLastError()
//
//  Purpose:    Displays the last error string to the user
//
//  Parameters: lError  -   error code
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

void PrintLastError(LONG lError)
{
   TCHAR szMessage[MAX_PATH];

   FormatMessage(
            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            lError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            szMessage,
            MAX_PATH,
            NULL);

   _tprintf (szMessage);
}


//*************************************************************
//
//  AddNode()
//
//  Purpose:    Adds a new node to the link list
//
//  Parameters: szSubKey        -   SubKey
//              szProfilePath   -   Profile Path (or NULL)
//              bDir            -   Directory or file
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   szProfilePath can be NULL.  In this case, we
//              are just removing the bogus registry entry.
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL AddNode (LPTSTR szSubKey, LPTSTR szProfilePath, BOOL bDir)
{
    LPDELETEITEM lpItem, lpTemp;
    UINT uAlloc = 0;


    //
    // Create a new node
    //

    uAlloc = sizeof(DELETEITEM) + (lstrlen(szSubKey) + 1) * sizeof(TCHAR);

    if (szProfilePath) {
        uAlloc +=(lstrlen(szProfilePath) + 1) * sizeof(TCHAR);
    }

    lpItem = LocalAlloc (LPTR, uAlloc);

    if (!lpItem) {
        return FALSE;
    }

    lpItem->lpSubKey = (LPTSTR)((LPBYTE)lpItem + sizeof(DELETEITEM));
    _tcscpy(lpItem->lpSubKey, szSubKey);

    if (szProfilePath) {
        lpItem->lpProfilePath = lpItem->lpSubKey + lstrlen(szSubKey) + 1;
        _tcscpy(lpItem->lpProfilePath, szProfilePath);
    } else {
        lpItem->lpProfilePath = NULL;
    }

    lpItem->bDir = bDir;


    //
    // Add this node to the global lpItemList
    //

    if (lpDeleteList) {
        lpTemp = lpDeleteList;

        while (lpTemp->pNext) {
            lpTemp = lpTemp->pNext;
        }

        lpTemp->pNext = lpItem;
    } else {
        lpDeleteList = lpItem;
    }

    return TRUE;
}


//*************************************************************
//
//  GetProfileDateInDays()
//
//  Purpose:    Gets the profile date in days.
//
//  Parameters: szProfilePath   -   Profile path
//              bDir            -   Directory or file
//
//  Return:     age in days.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

LONG GetProfileDateInDays(LPTSTR szProfilePath, BOOL bDir)
{
    TCHAR szTemp[MAX_PATH];
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LONG days;
    SYSTEMTIME systime;
    FILETIME ft;


    if (bDir) {

        //
        // Tack on ntuser.* to find the registry hive.
        //

        _tcscpy(szTemp, szProfilePath);
        _tcscat(szTemp, TEXT("\\ntuser.*"));

        hFile = FindFirstFile (szTemp, &fd);

    } else {

        //
        // szProfilePath points to a file.
        //

        hFile = FindFirstFile (szProfilePath, &fd);
    }


    if (hFile != INVALID_HANDLE_VALUE) {

        FindClose (hFile);

        FileTimeToLocalFileTime (&fd.ftLastWriteTime, &ft);
        FileTimeToSystemTime (&ft, &systime);

        days = gdate_dmytoday(systime.wYear, systime.wMonth, systime.wDay);

    } else {
        days = lCurrentDateInDays;
    }

    return days;
}


//*************************************************************
//
//  CheckProfile()
//
//  Purpose:    Checks if the given profile should be deleted.
//              If so, it is added to the list.
//
//  Parameters: hKeyLM    -   Local Machine key
//              hKeyUsers - HKEY_USERS key
//              lpSid     -   Sid string (key name)
//
//  Return:     TRUE if successful
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL CheckProfile (HKEY hKeyLM, HKEY hKeyUsers, LPTSTR lpSid)
{
    LONG lResult;
    HKEY hkey;
    TCHAR szSubKey[MAX_PATH];
    DWORD dwSize, dwType;
    TCHAR szTemp[MAX_PATH];
    TCHAR szProfilePath[MAX_PATH];
    TCHAR szError[100];
    DWORD dwAttribs;
    BOOL  bDir;
    LONG  lProfileDateInDays;


    //
    // Check if the profile is in use
    //

    lResult = RegOpenKeyEx (hKeyUsers, lpSid, 0, KEY_READ, &hkey);

    if (lResult == ERROR_SUCCESS) {
        RegCloseKey (hkey);
        return TRUE;
    }


    //
    // Open the profile information
    //

    wsprintf (szSubKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s"),
              lpSid);

    lResult = RegOpenKeyEx (hKeyLM,
                            szSubKey,
                            0,
                            KEY_READ,
                            &hkey);

    if (lResult != ERROR_SUCCESS) {
        LoadString (hInst, IDS_FAILEDOPENPROFILE, szError, 100);
        _tprintf(szError, lpSid);
        PrintLastError(lResult);
        return FALSE;
    }


    //
    // Query for the ProfileImagePath
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hkey,
                               TEXT("ProfileImagePath"),
                               NULL,
                               &dwType,
                               (LPBYTE)szTemp,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        LoadString (hInst, IDS_FAILEDPATHQUERY, szError, 100);
        _tprintf(szError, lpSid);
        PrintLastError(lResult);
        RegCloseKey (hkey);
        return FALSE;
    }


    //
    // Expand the path.
    //

    if (_tcsnicmp(TEXT("%SystemRoot%"), szTemp, 12) == 0) {
        _stprintf(szProfilePath, TEXT("%s\\%s"), szSystemRoot, szTemp+13);
    }
    else if (_tcsnicmp(TEXT("%SystemDrive%"), szTemp, 13) == 0) {
        _stprintf(szProfilePath, TEXT("%s\\%s"), szSystemDrive, szTemp+14);
    }
    else if (NULL == _tcschr(szTemp, TEXT('%')) && !bLocalComputer) {
        if (TEXT(':') == szTemp[1])
            szTemp[1] = TEXT('$');
        _stprintf(szProfilePath, TEXT("%s\\%s"), szComputerName, szTemp);
    }
    else {
        LoadString (hInst, IDS_SKIPPROFILE, szError, 100);
        _tprintf(szError, szTemp);
        goto Exit;
    }
    //
    // Is this a directory or a file?
    //

    dwAttribs = GetFileAttributes (szProfilePath);

    if (dwAttribs == -1) {
        AddNode (szSubKey, NULL, FALSE);
        goto Exit;
    }

    bDir = (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;


    //
    // Check Time/Date stamp.  If the profile date is older
    // than the amount specified, add it to the delete list.
    //

    lProfileDateInDays = GetProfileDateInDays(szProfilePath, bDir);

    if (lCurrentDateInDays >= lProfileDateInDays) {

        if ((lCurrentDateInDays - lProfileDateInDays) >= lDays) {
            AddNode (szSubKey, szProfilePath, bDir);
        }
    }


Exit:
    RegCloseKey (hkey);

    return TRUE;
}


//*************************************************************
//
//  DelProfiles()
//
//  Purpose:    Deletes the user profiles
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

BOOL DelProfiles(void)
{
    HKEY hKeyLM = NULL, hKeyUsers = NULL, hKeyProfiles = NULL;
    HKEY hKeyCurrentVersion = NULL;
    LONG lResult;
    BOOL bResult = FALSE, bTemp;
    TCHAR szError[100];
    DWORD dwIndex = 0, dwNameSize, dwClassSize;
    DWORD dwBufferSize;
    TCHAR szName[MAX_PATH];
    TCHAR szClass[MAX_PATH], szTemp[MAX_PATH];
    TCHAR tChar, tTemp;
    FILETIME ft;
    LPDELETEITEM lpTemp;
    LPTSTR pSid, lpEnd;
    DWORD lProfileKeyLen;


    lProfileKeyLen = lstrlen(TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"))+1;

    //
    // Open the registry
    //

    lResult = RegConnectRegistry(szComputerName, HKEY_LOCAL_MACHINE, &hKeyLM);

    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    lResult = RegConnectRegistry(szComputerName, HKEY_USERS, &hKeyUsers);

    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    //
    // Get the value of %SystemRoot% and %SystemDrive% relative to the computer
    //

    lResult = RegOpenKeyEx(hKeyLM,
                           TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                           0,
                           KEY_READ,
                           &hKeyCurrentVersion);
   
            
    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    dwBufferSize = MAX_PATH * sizeof(TCHAR);

    lResult = RegQueryValueEx(hKeyCurrentVersion,
                              TEXT("SystemRoot"),
                              NULL,
                              NULL,
                              (BYTE *) szTemp,
                              &dwBufferSize);

    if (lResult != ERROR_SUCCESS) {
        PrintLastError(lResult);
        goto Exit;
    }

    if (!bLocalComputer) {
        szTemp[1] = TEXT('$');

        _tcscpy(szSystemRoot, szComputerName); lstrcat(szSystemRoot, TEXT("\\"));
        _tcscpy(szSystemDrive, szComputerName); lstrcat(szSystemDrive, TEXT("\\"));

        lpEnd = szSystemDrive+lstrlen(szSystemDrive);
        _tcsncpy(lpEnd, szTemp, 2);

        lpEnd = szSystemRoot+lstrlen(szSystemRoot);
        _tcscpy(lpEnd, szTemp);
    }
    else {
        _tcsncpy(szSystemDrive, szTemp, 2);
        _tcscpy(szSystemRoot, szTemp);
    }

    //
    // Open the ProfileList key
    //

    lResult = RegOpenKeyEx (hKeyLM,
                            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyProfiles);

    if (lResult != ERROR_SUCCESS) {

        LoadString (hInst, IDS_FAILEDPROFILELIST, szError, 100);
        _tprintf(szError);
        PrintLastError(lResult);
        goto Exit;
    }


    //
    // Enumerate the profiles
    //

    dwNameSize = dwClassSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKeyProfiles,
                           dwIndex,
                           szName,
                           &dwNameSize,
                           NULL,
                           szClass,
                           &dwClassSize,
                           &ft);


    while (lResult == ERROR_SUCCESS) {

        //
        // Hand the profile info off to CheckProfile
        // to determine if the profile should be deleted or not.
        //

        if (!CheckProfile (hKeyLM, hKeyUsers, szName)) {
            if (!bIgnoreErrors) {
                goto Exit;
            }
        }


        //
        // Reset for the next loop
        //
        dwIndex++;
        dwNameSize = dwClassSize = MAX_PATH;

        lResult = RegEnumKeyEx(hKeyProfiles,
                               dwIndex,
                               szName,
                               &dwNameSize,
                               NULL,
                               szClass,
                               &dwClassSize,
                               &ft);
    }


    //
    // Check for errors
    //

    if (lResult != ERROR_NO_MORE_ITEMS) {
        LoadString (hInst, IDS_FAILEDENUM, szError, 100);
        _tprintf(szError);
        PrintLastError(lResult);
        goto Exit;
    }


    //
    // Remove profiles
    //

    lpTemp = lpDeleteList;

    while (lpTemp) {

        if (lpTemp->lpProfilePath) {

            //
            // Prompt before deleting the profile (if approp).
            //

            if (bPromptBeforeDelete) {

                while (1) {
                    LoadString (hInst, IDS_DELETEPROMPT, szError, 100);
                    _tprintf (szError, lpTemp->lpProfilePath);


                    tChar = _gettchar();

                    tTemp = tChar;
                    while (tTemp != TEXT('\n')) {
                        tTemp = _gettchar();
                    }

                    if ((tChar == TEXT('N')) || (tChar == TEXT('n'))) {
                        goto LoopAgain;
                    }

                    if ((tChar == TEXT('A')) || (tChar == TEXT('a'))) {
                        bPromptBeforeDelete = FALSE;
                        break;
                    }

                    if ((tChar == TEXT('Y')) || (tChar == TEXT('y'))) {
                        break;
                    }
                }
            }

            //
            // Delete the profile
            //

            LoadString (hInst, IDS_DELETING, szError, 100);
            _tprintf (szError, lpTemp->lpProfilePath);

            pSid = lpTemp->lpSubKey+lProfileKeyLen;

            bTemp = DeleteProfile(pSid, lpTemp->lpProfilePath, ((bLocalComputer)? NULL:szComputerName));            

            if (bTemp) {
                LoadString (hInst, IDS_SUCCESS, szError, 100);
                _tprintf (szError, lpTemp->lpProfilePath);

            } else {
                LoadString (hInst, IDS_FAILED, szError, 100);
                _tprintf (szError, lpTemp->lpProfilePath);
                PrintLastError(GetLastError());
            }
        } else {

            //
            // If there isn't a profile path, then we are just
            // cleaning up the bogus registry entry.
            //

            bTemp = TRUE;

            //
            // Clean up the registry.
            //

            RegDeleteKey (hKeyLM, lpTemp->lpSubKey);

        }


        //
        // Did the clean up fail?
        //

        if (!bTemp) {
            if (!bIgnoreErrors) {
                goto Exit;
            }
        }

LoopAgain:
        lpTemp = lpTemp->pNext;
    }


    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (hKeyCurrentVersion)
        RegCloseKey(hKeyCurrentVersion);

    if (hKeyProfiles)
        RegCloseKey(hKeyProfiles);

    if (hKeyLM)
        RegCloseKey(hKeyLM);

    if (hKeyUsers)
        RegCloseKey(hKeyUsers);


    if (lpDeleteList) {
        do {
            lpTemp = lpDeleteList->pNext;
            LocalFree (lpDeleteList);
            lpDeleteList = lpTemp;
        } while (lpDeleteList);
    }

    return bResult;
}


//*************************************************************
//
//  main()
//
//  Purpose:    main entry point
//
//  Parameters: argc    -   number of arguments
//              argv    -   arguments
//
//  Return:     0 if successful
//              1 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/18/96     ericflo    Created
//
//*************************************************************

int __cdecl main( int argc, char *argv[])
{

    //
    // Initialize the globals
    //

    InitializeGlobals();


    //
    // Parse the command line
    //

    if (!ParseCommandLine(GetCommandLine())) {
        return 1;
    }


    //
    // Check the globals variables
    //

    CheckGlobals();


    //
    // Confirmation
    //

    if (!bQuiet) {
        if (!Confirm()) {
            return 1;
        }
    }


    //
    // Remove the profiles
    //

    if (!DelProfiles()) {
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\common\optlogon.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    optlogon.c

Abstract:

    This module contains the shared rountines for the optimized logon.

Author:

    Cenk Ergan (cenke) - 2001/05/07

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ginacomn.h>

//
// The registry values under ProfileList\%UserSidString% checked when 
// determining if we should logon by cached credentials by default.
//

#define GC_PROFILE_LIST_PATH               L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define GC_NEXT_LOGON_CACHEABLE_VALUE_NAME L"NextLogonCacheable"
#define GC_SYNC_LOGON_SCRIPT_VALUE_NAME    L"RunLogonScriptSync"
#define GC_OPTIMIZED_LOGON_VALUE_NAME      L"OptimizedLogonStatus"

/***************************************************************************\
* GcCheckIfProfileAllowsCachedLogon
*
* Returns whether profile settings are not compatible with doing fast-cached
* logons every logon, e.g. roaming profile, remote home directory etc.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcCheckIfProfileAllowsCachedLogon(
    PUNICODE_STRING HomeDirectory,
    PUNICODE_STRING ProfilePath,
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    )
{
    DWORD ErrorCode;
    DWORD LogonCacheable;
    DWORD UserPreference;

    //
    // Start with the assumption that the logon is not cacheable.
    //

    ErrorCode = ERROR_SUCCESS;
    LogonCacheable = FALSE;

    //
    // Is the home directory on the network (i.e. a UNC path)?
    //

    if (HomeDirectory &&
        HomeDirectory->Length > 4 && 
        GcIsUNCPath(HomeDirectory->Buffer)) {
        goto cleanup;        
    }

    //
    // Is the profile path on the network (i.e. a UNC path)?
    //

    if (ProfilePath &&
        ProfilePath->Length > 4 && 
        GcIsUNCPath(ProfilePath->Buffer)) {

        //
        // Check if the user has explicitly requested his roaming profile to
        // be local on this machine.
        //

        UserPreference = GcGetUserPreferenceValue(UserSidString);

        //
        // If user preference is not 0, then the roaming user profile is not 
        // set to be local on this machine: we can't do optimized logon.
        //

        if (UserPreference) {
            goto cleanup;
        }
    }

    //
    // The logon is cacheable.
    //

    LogonCacheable = TRUE;

  cleanup:

    if (ErrorCode == ERROR_SUCCESS) {
        *NextLogonCacheable = LogonCacheable;
    }

    return ErrorCode;
}
 
/***************************************************************************\
* GcCheckIfLogonScriptsRunSync
*
* Returns whether logons scripts are to be run synchronously.
* Default is asynchronous.
*
* History:
* 04-25-01 Cenke        Created
\***************************************************************************/
BOOL 
GcCheckIfLogonScriptsRunSync(
    PWCHAR UserSidString
    )
{
    DWORD ErrorCode;
    BOOL bSync = FALSE;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               FALSE,
                                               GC_SYNC_LOGON_SCRIPT_VALUE_NAME,
                                               &(DWORD)bSync);

    if (ErrorCode != ERROR_SUCCESS) {
        bSync = FALSE;
    }

    return bSync;
}

/***************************************************************************\
* GcAccessProfileListUserSetting
*
* Queries or sets a DWORD value for the specified user under the local 
* machine profile list key.
*
* History:
* 05-01-01 Cenke        Created
\***************************************************************************/
DWORD
GcAccessProfileListUserSetting (
    PWCHAR UserSidString,
    BOOL SetValue,
    PWCHAR ValueName,
    PDWORD Value
    )
{
    HKEY ProfileListKey;
    HKEY UserProfileKey;
    ULONG Result;
    DWORD ErrorCode;
    DWORD ValueType;
    DWORD Size;

    //
    // Initialize locals.
    //

    UserProfileKey = NULL;
    ProfileListKey = NULL;
    
    //
    // Open the ProfileList registry key.
    //

    Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          GC_PROFILE_LIST_PATH,
                          0,
                          KEY_READ,
                          &ProfileListKey);

    if (Result != ERROR_SUCCESS) {
        ErrorCode = Result;
        goto cleanup;
    }

    //
    // Open the user's profile key under the ProfileList key using user's SID.
    //

    Result = RegOpenKeyEx(ProfileListKey,
                          UserSidString,
                          0,
                          KEY_READ | KEY_WRITE,
                          &UserProfileKey);

    if (Result != ERROR_SUCCESS) {
        ErrorCode = Result;
        goto cleanup;
    }

    if (SetValue) {

        //
        // Set the value.
        //

        Result = RegSetValueEx(UserProfileKey,
                               ValueName,
                               0,
                               REG_DWORD,
                               (BYTE *) Value,
                               sizeof(DWORD));

        if (Result != ERROR_SUCCESS) {
            ErrorCode = Result;
            goto cleanup;
        }

    } else {

        //
        // Query the value.
        //

        Size = sizeof(DWORD);

        Result = RegQueryValueEx(UserProfileKey,
                                 ValueName,
                                 0,
                                 &ValueType,
                                 (BYTE *) Value,
                                 &Size);

        if (Result != ERROR_SUCCESS) {
            ErrorCode = Result;
            goto cleanup;
        }

    }

    //
    // We are done.
    //
    
    ErrorCode = ERROR_SUCCESS;

  cleanup:

    if (ProfileListKey) {
        RegCloseKey(ProfileListKey);
    }

    if (UserProfileKey) {
        RegCloseKey(UserProfileKey);
    }

    return ErrorCode;
}
   

/***************************************************************************\
* GcGetNextLogonCacheable
*
* Returns whether we are allowed to perform a cached logon at the next logon.
* For instance, if last time we logged on using cached credentials, our attempt 
* at background logon failed for a reason (e.g. password expired) we want to 
* force the user to hit the network logon path to deal with.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcGetNextLogonCacheable(
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    )
{
    DWORD ErrorCode;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               FALSE,
                                               GC_NEXT_LOGON_CACHEABLE_VALUE_NAME,
                                               NextLogonCacheable);
                                             
    return ErrorCode;
}

/***************************************************************************\
* GcSetNextLogonCacheable
*
* Sets whether we are allowed to perform a cached logon at the next logon.
* For instance, if after logging on the user with cached credentials our attempt 
* at background logon fails for a reason (e.g. password expired) we want to 
* force the user to hit the network logon path to deal with.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcSetNextLogonCacheable(
    PWCHAR UserSidString,
    DWORD NextLogonCacheable
    )
{
    DWORD ErrorCode;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               TRUE,
                                               GC_NEXT_LOGON_CACHEABLE_VALUE_NAME,
                                               &NextLogonCacheable);
                                             
    return ErrorCode;
}

/***************************************************************************\
* GcSetOptimizedLogonStatus
*
* Saves optimized logon status for the user in the profile list.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD
GcSetOptimizedLogonStatus(
    PWCHAR UserSidString,
    DWORD OptimizedLogonStatus
    )
{
    DWORD ErrorCode;

    ErrorCode = GcAccessProfileListUserSetting(UserSidString,
                                               TRUE, 
                                               GC_OPTIMIZED_LOGON_VALUE_NAME,
                                               &OptimizedLogonStatus);

    return ErrorCode;
}

/***************************************************************************\
* GcGetUserPreferenceValue
*
* Gets user preference flags on whether the user's roaming profile is set
* to be local on this machine.
*
* History:
* 05-01-01 Cenke        Copied from gina\userenv\profile.cpp
\***************************************************************************/
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define PROFILE_LOCALONLY            TEXT("LocalProfile")
#define USER_PREFERENCE              TEXT("UserPreference")
#define USERINFO_LOCAL               0
#define USERINFO_UNDEFINED           99
const TCHAR c_szBAK[] = TEXT(".bak");

DWORD 
GcGetUserPreferenceValue(
    LPTSTR SidString
    )
{
    TCHAR LocalProfileKey[MAX_PATH];
    DWORD RegErr, dwType, dwSize, dwTmpVal, dwRetVal = USERINFO_UNDEFINED;
    LPTSTR lpEnd;
    HKEY hkeyProfile, hkeyPolicy;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SYSTEM_POLICIES_KEY,
                     0, KEY_READ,
                     &hkeyPolicy) == ERROR_SUCCESS) {

        dwSize = sizeof(dwTmpVal);
        RegQueryValueEx(hkeyPolicy,
                        PROFILE_LOCALONLY,
                        NULL, &dwType,
                        (LPBYTE) &dwTmpVal,
                        &dwSize);

        RegCloseKey (hkeyPolicy);
        if (dwTmpVal == 1) {
            dwRetVal = USERINFO_LOCAL;
            return dwRetVal;
        }
    }    
   
    if (SidString != NULL) {

        //
        // Query for the UserPreference value
        //

        lstrcpy(LocalProfileKey, GC_PROFILE_LIST_PATH);
        lpEnd = GcCheckSlash (LocalProfileKey);
        lstrcpy(lpEnd, SidString);

        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);


        if (RegErr == ERROR_SUCCESS) {

            dwSize = sizeof(dwRetVal);
            RegQueryValueEx(hkeyProfile,
                            USER_PREFERENCE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwRetVal,
                            &dwSize);

            RegCloseKey (hkeyProfile);
        }

        lstrcat(LocalProfileKey, c_szBAK);
        RegErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              LocalProfileKey,
                              0,
                              KEY_READ,
                              &hkeyProfile);


        if (RegErr == ERROR_SUCCESS) {

            dwSize = sizeof(dwRetVal);
            RegQueryValueEx(hkeyProfile,
                            USER_PREFERENCE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwRetVal,
                            &dwSize);

            RegCloseKey (hkeyProfile);
        }
    }

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\dsrole\server\upgrade.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    Implements the server side of the routines to upgrade NT4 (downlevel) servers

Author:

    Mac McLain          (MacM)       24 January, 1998

Environment:

    User Mode

Revision History:

--*/
#include <setpch.h>
#include <dssetp.h>
#include <loadfn.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <samrpc.h>
#include <samisrv.h>
#include <db.h>

#define DSROLEP_UPGRADE_KEY         L"Security\\"
#define DSROLEP_UPGRADE_VALUE       L"Upgrade"
#define DSROLEP_UPGRADE_WINLOGON    \
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\"
#define DSROLEP_UPGRADE_SAVE_PREFIX L"DcpromoOld_"
#define DSROLEP_UPGRADE_AUTOADMIN   L"AutoAdminLogon"
#define DSROLEP_UPGRADE_AUTOPASSWD  L"DefaultPassword"
#define DSROLEP_UPGRADE_DEFDOMAIN   L"DefaultDomainName"
#define DSROLEP_UPGRADE_DEFUSER     L"DefaultUserName"
#define DSROLEP_UPGRADE_AUTOUSERINIT    L"Userinit"
#define DSROLEP_UPGRADE_DCPROMO     L",dcpromo /upgrade"
#define DSROLEP_UPGRADE_ANSWERFILE  L"/answer:"

DWORD
DsRolepSetLogonDomain(
    IN LPWSTR Domain,
    IN BOOLEAN FailureAllowed
    )
/*++

Routine Description:

    This function sets the default logon domain for winlogon

Arguments:

    Domain -- Default logon domain

    FailureAllowed -- If true, a failure is not considered catastrophic

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HKEY  WinlogonHandle = NULL;

    //
    // Open the key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_UPGRADE_WINLOGON,
                             0,
                             KEY_READ | KEY_WRITE,
                             &WinlogonHandle );

    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Default logon domain
        //
        Win32Err = RegSetValueEx( WinlogonHandle,
                                  DSROLEP_UPGRADE_DEFDOMAIN,
                                  0,
                                  REG_SZ,
                                  ( CONST PBYTE )Domain,
                                  ( wcslen( Domain ) + 1 ) * sizeof( WCHAR ) );

        RegCloseKey( WinlogonHandle );
    }

    if ( Win32Err != ERROR_SUCCESS && FailureAllowed ) {

        //
        // Raise an event
        //
        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         DSROLERES_FAIL_LOGON_DOMAIN,
                         0,
                         sizeof( ULONG ),
                         &Win32Err,
                         1,
                         Domain );

        DSROLEP_SET_NON_FATAL_ERROR( Win32Err );
        Win32Err = ERROR_SUCCESS;
    }

    return( Win32Err );
}


#pragma warning(push)
#pragma warning(disable:4701)

DWORD
DsRolepSaveUpgradeState(
    IN LPWSTR AnswerFile
    )
/*++

Routine Description:

    This function is to be invoked during setup and saves the required server state to
    complete the promotion following the reboot.  Following the successful completion
    of this API call, the server will be demoted to a member server in the same domain.

Arguments:

    AnswerFile -- Optional path to an answer file to be used by DCPROMO during the subsequent
        invocation

Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    LSAPR_HANDLE PolicyHandle = NULL;
    POLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE  Handle = NULL;
    HKEY WinlogonHandle, UpgradeKey;
    ULONG Disp, Length;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    PBYTE UserInitBuffer, TempBuffer;
    DWORD Type;
    LPWSTR NewAdminPassword = NULL;

    WCHAR  Buffer[MAX_PATH];
    LPWSTR AdminName = Buffer;
    LPWSTR DefaultAdminName = L"Administrator";

    //
    // Get the localized Admin
    // 
    Length = sizeof(Buffer)/sizeof(Buffer[0]);

    Status = SamIGetDefaultAdministratorName( AdminName,
                                             &Length );

    if ( !NT_SUCCESS(Status) ) {

        DsRolepLogOnFailure( ERROR_GEN_FAILURE,
                            DsRolepLogPrint(( DEB_TRACE,
                                               "SamIGetDefaultAdministratorName failed with 0x%x\n",
                                               Status )) );

        AdminName = DefaultAdminName;
        Status = STATUS_SUCCESS;

    }



    //
    // Steps involved: Set new SAM hives
    //                 Save LSA state
    //                 Set auto admin logon

    //
    // Invoke the SAM save code.  It returns the new account domain sid
    //
    DSROLEP_CURRENT_OP0( DSROLEEVT_UPGRADE_SAM );
    Win32Err = NtdsPrepareForDsUpgrade( &AccountDomainInfo,
                                        &NewAdminPassword );
    DsRolepLogOnFailure( Win32Err,
                        DsRolepLogPrint(( DEB_TRACE,
                                           "NtdsPrepareForDsUpgrade failed with %lu\n",
                                           Win32Err )) );


    //
    // Set the new lsa account domain sid
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( NULL,
                                &ObjectAttributes,
                                POLICY_READ | POLICY_WRITE |
                                            POLICY_VIEW_LOCAL_INFORMATION | POLICY_TRUST_ADMIN,
                                &PolicyHandle );


        if ( NT_SUCCESS( Status ) ) {

            //
            // Set the new policy info
            //
            Status = LsaSetInformationPolicy( PolicyHandle,
                                              PolicyAccountDomainInformation,
                                              ( PVOID ) &AccountDomainInfo );

        }

        Win32Err = RtlNtStatusToDosError( Status );

        RtlFreeHeap( RtlProcessHeap(), 0, AccountDomainInfo.DomainSid );
        RtlFreeHeap( RtlProcessHeap(), 0, AccountDomainInfo.DomainName.Buffer );
    }

    //
    // Set the LSA registry keys that let the server know on the next reboot that this
    // is an upgrade
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Get the current server role
        //
        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyLsaServerRoleInformation,
                                            ( PVOID )&ServerRoleInfo );

        Win32Err = RtlNtStatusToDosError( Status );

        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Open the key
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                         DSROLEP_UPGRADE_KEY,
                                         0,
                                         KEY_READ | KEY_WRITE,
                                         &UpgradeKey );
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the server role
                //
                Win32Err = RegSetValueEx( UpgradeKey,
                                          DSROLEP_UPGRADE_VALUE,
                                          0,
                                          REG_DWORD,
                                          ( CONST PBYTE )&ServerRoleInfo->LsaServerRole,
                                          sizeof( DWORD ) );
                RegCloseKey( UpgradeKey );
            }


            LsaFreeMemory( ServerRoleInfo );

        }

    }

    //
    // Set the machine to do auto admin logon
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Get the computer name. That will be used for the default logon domain
        //
        Length = MAX_COMPUTERNAME_LENGTH + 1;

        if ( GetComputerName( ComputerName, &Length ) == FALSE ) {

            Win32Err = GetLastError();

        } else {

            //
            // Open the root key
            //
            Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                     DSROLEP_UPGRADE_WINLOGON,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     &WinlogonHandle );

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Auto logon
                //

                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOADMIN,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOADMIN,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_AUTOADMIN,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_AUTOADMIN,
                                              0,
                                              REG_SZ,
                                              ( CONST PBYTE )L"1",
                                              2 *  sizeof ( WCHAR ) );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the account password
                //
                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOPASSWD,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOPASSWD,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_AUTOPASSWD,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_AUTOPASSWD,
                                              0,
                                              REG_SZ,
                                              (BYTE*)NewAdminPassword,
                                              NewAdminPassword ? (wcslen(NewAdminPassword)+1)*sizeof(WCHAR) : 0 );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the user name to be administrator
                //

                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_DEFUSER,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_DEFUSER,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFUSER,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_DEFUSER,
                                              0,
                                              REG_SZ,
                                              ( CONST PBYTE )AdminName,
                                              ( wcslen( AdminName ) + 1 ) * sizeof( WCHAR ) );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Set the logon domain to the machine
                //
                //
                // First, see if the value currently exists...
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_DEFDOMAIN,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_DEFDOMAIN,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFDOMAIN,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    Win32Err = ERROR_SUCCESS;
                }


                if ( Win32Err == ERROR_SUCCESS ) {

                    Win32Err = RegSetValueEx( WinlogonHandle,
                                              DSROLEP_UPGRADE_DEFDOMAIN,
                                              0,
                                              REG_SZ,
                                              ( CONST PBYTE )ComputerName,
                                              ( wcslen( ComputerName ) + 1 ) * sizeof( WCHAR ) );
                }
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Finally, set dcpromo to autostart
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOUSERINIT,
                                            0, // reserved
                                            &Type,
                                            0,
                                            &Length );

                if ( Win32Err == ERROR_SUCCESS ) {

                    Length += sizeof( DSROLEP_UPGRADE_DCPROMO );

                    if ( AnswerFile ) {

                        Length += sizeof( DSROLEP_UPGRADE_ANSWERFILE ) +
                                   ( wcslen( AnswerFile ) * sizeof( WCHAR ) );
                    }

                    UserInitBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                                      Length );
                    if ( UserInitBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOUSERINIT,
                                                    0,
                                                    &Type,
                                                    UserInitBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {
                            wcscat( ( PWSTR )UserInitBuffer, DSROLEP_UPGRADE_DCPROMO );

                            if ( AnswerFile ) {

                                wcscat( ( PWSTR )UserInitBuffer, DSROLEP_UPGRADE_ANSWERFILE );
                                wcscat( ( PWSTR )UserInitBuffer, AnswerFile );
                            }

                            Status = RegSetValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_AUTOUSERINIT,
                                                    0,
                                                    Type,
                                                    UserInitBuffer,
                                                    ( wcslen( ( PWSTR )UserInitBuffer ) + 1 ) *
                                                                    sizeof( WCHAR ) );
                        }

                    }


                    RtlFreeHeap( RtlProcessHeap(), 0, UserInitBuffer );
                }


                RegCloseKey( WinlogonHandle );

            }

        }
    }

    if ( PolicyHandle ) {

        LsaClose( PolicyHandle );
    }

    //
    // Set the product types
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = DsRolepSetProductType( DSROLEP_MT_STANDALONE );

    }

    if ( NewAdminPassword ) {

        RtlFreeHeap( RtlProcessHeap(), 0, NewAdminPassword );

    }

    return( Win32Err );
}

#pragma warning(pop)


DWORD
DsRolepDeleteUpgradeInfo(
    VOID
    )
/*++

Routine Description:

    This function deletes the saved information

Arguments:

    VOID


Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, RestoreError = Win32Err;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HKEY WinlogonHandle, UpgradeKey;
    PWSTR Remove, Next, DeletePath;
    PBYTE UserInitBuffer, TempBuffer;
    DWORD Type, Length = 0;

    //
    // Remove autostarting dcpromo
    //

    //
    // Open the root key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_UPGRADE_WINLOGON,
                             0,
                             KEY_READ | KEY_WRITE,
                             &WinlogonHandle );

#if DBG
    DsRolepLogOnFailure( Win32Err,
                         DsRolepLogPrint(( DEB_TRACE,
                                           "RegOpenKeyEx on %ws failed with %lu\n",
                                           DSROLEP_UPGRADE_WINLOGON,
                                           Win32Err )) );
#endif

    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Stop dcpromo from autostarting...
        //
        Win32Err = RegQueryValueEx( WinlogonHandle,
                                    DSROLEP_UPGRADE_AUTOUSERINIT,
                                    0, // reserved
                                    &Type,
                                    0,
                                    &Length );

#if DBG
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "RegQueryValyueEx on %ws failed with %lu\n",
                                               DSROLEP_UPGRADE_AUTOUSERINIT,
                                               Win32Err )) );
#endif
        if ( Win32Err == ERROR_SUCCESS ) {


            UserInitBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                              Length );
            if ( UserInitBuffer == NULL ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_AUTOUSERINIT,
                                            0,
                                            &Type,
                                            UserInitBuffer,
                                            &Length );

#if DBG
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegQueryValyueEx on %ws failed with %lu\n",
                                                       DSROLEP_UPGRADE_AUTOUSERINIT,
                                                       Win32Err )) );
#endif
                if ( Win32Err == ERROR_SUCCESS ) {

                    Remove = wcsstr ( ( PWSTR )UserInitBuffer, DSROLEP_UPGRADE_DCPROMO );

                    if ( Remove ) {

                        Next = Remove + ( ( sizeof( DSROLEP_UPGRADE_DCPROMO ) - sizeof( WCHAR ) ) /
                                                                                sizeof( WCHAR ) );
                        while ( *Next ) {

                            *Remove++ = *Next++;
                        }
                        *Remove = UNICODE_NULL;

                        Status = RegSetValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_AUTOUSERINIT,
                                                0,
                                                Type,
                                                UserInitBuffer,
                                                ( wcslen( ( PWSTR )UserInitBuffer ) + 1 ) *
                                                                sizeof( WCHAR ) );
#if DBG
                        DsRolepLogOnFailure( Win32Err,
                                             DsRolepLogPrint(( DEB_TRACE,
                                                               "RegQSetValyueEx on %ws failed with %lu\n",
                                                                DSROLEP_UPGRADE_AUTOUSERINIT,
                                                                Win32Err )) );
#endif
                    }
                }

            }


            RtlFreeHeap( RtlProcessHeap(), 0, UserInitBuffer );
        }


        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Auto logon
            //

            //
            // Restore the old values, if they exist
            //
            DeletePath = DSROLEP_UPGRADE_AUTOADMIN;
            Length = 0;
            Win32Err = RegQueryValueEx( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_AUTOADMIN,
                                        0,
                                        &Type,
                                        0,
                                        &Length );
            if ( Win32Err == ERROR_SUCCESS ) {

                TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                if ( TempBuffer == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    Win32Err = RegQueryValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_AUTOADMIN,
                                                0,
                                                &Type,
                                                TempBuffer,
                                                &Length );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegSetValueEx( WinlogonHandle,
                                                  DSROLEP_UPGRADE_AUTOADMIN,
                                                  0,
                                                  Type,
                                                  TempBuffer,
                                                  Length );
                        RegDeleteValue( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_AUTOADMIN );
                    }

                    RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                }


            } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegDeleteKey on %ws failed with %lu\n",
                                                       DeletePath,
                                                       Win32Err )) );
                //
                // An error here is not considered fatal...
                //
                Win32Err = ERROR_SUCCESS;
            }

            //
            // Restore the default user logon name
            //
            DeletePath = DSROLEP_UPGRADE_DEFUSER;
            Length = 0;
            Win32Err = RegQueryValueEx( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFUSER,
                                        0,
                                        &Type,
                                        0,
                                        &Length );
            if ( Win32Err == ERROR_SUCCESS ) {

                TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                if ( TempBuffer == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    Win32Err = RegQueryValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFUSER,
                                                0,
                                                &Type,
                                                TempBuffer,
                                                &Length );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegSetValueEx( WinlogonHandle,
                                                  DSROLEP_UPGRADE_DEFUSER,
                                                  0,
                                                  Type,
                                                  TempBuffer,
                                                  Length );
                        RegDeleteValue( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFUSER );
                    }

                    RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                }


            } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegDeleteKey on %ws failed with %lu\n",
                                                       DeletePath,
                                                       Win32Err )) );
                //
                // An error here is not considered fatal...
                //
                Win32Err = ERROR_SUCCESS;
            }

            //
            // Restore the default domain name
            //
            DeletePath = DSROLEP_UPGRADE_DEFDOMAIN;
            Length = 0;
            Win32Err = RegQueryValueEx( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFDOMAIN,
                                        0,
                                        &Type,
                                        0,
                                        &Length );
            if ( Win32Err == ERROR_SUCCESS ) {

                TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                if ( TempBuffer == NULL ) {

                    Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                } else {

                    Win32Err = RegQueryValueEx( WinlogonHandle,
                                                DSROLEP_UPGRADE_SAVE_PREFIX
                                                                        DSROLEP_UPGRADE_DEFDOMAIN,
                                                0,
                                                &Type,
                                                TempBuffer,
                                                &Length );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = RegSetValueEx( WinlogonHandle,
                                                  DSROLEP_UPGRADE_DEFDOMAIN,
                                                  0,
                                                  Type,
                                                  TempBuffer,
                                                  Length );
                        RegDeleteValue( WinlogonHandle,
                                        DSROLEP_UPGRADE_SAVE_PREFIX DSROLEP_UPGRADE_DEFDOMAIN );
                    }

                    RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                }


            } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                DsRolepLogOnFailure( Win32Err,
                                     DsRolepLogPrint(( DEB_TRACE,
                                                       "RegDeleteKey on %ws failed with %lu\n",
                                                       DeletePath,
                                                       Win32Err )) );
                //
                // An error here is not considered fatal...
                //
                Win32Err = ERROR_SUCCESS;
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                //
                // Delete the account password
                //
                Length = 0;
                Win32Err = RegQueryValueEx( WinlogonHandle,
                                            DSROLEP_UPGRADE_SAVE_PREFIX
                                                                       DSROLEP_UPGRADE_AUTOPASSWD,
                                            0,
                                            &Type,
                                            0,
                                            &Length );
                if ( Win32Err == ERROR_SUCCESS ) {

                    TempBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

                    if ( TempBuffer == NULL ) {

                        Win32Err = ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        Win32Err = RegQueryValueEx( WinlogonHandle,
                                                    DSROLEP_UPGRADE_SAVE_PREFIX
                                                                       DSROLEP_UPGRADE_AUTOPASSWD,
                                                    0,
                                                    &Type,
                                                    TempBuffer,
                                                    &Length );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            Win32Err = RegSetValueEx( WinlogonHandle,
                                                      DSROLEP_UPGRADE_AUTOPASSWD,
                                                      0,
                                                      Type,
                                                      TempBuffer,
                                                      Length );
                            RegDeleteValue( WinlogonHandle,
                                            DSROLEP_UPGRADE_SAVE_PREFIX
                                                                     DSROLEP_UPGRADE_AUTOPASSWD );
                        }

                        RtlFreeHeap( RtlProcessHeap(), 0, TempBuffer );
                    }


                } else if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

                    DeletePath = DSROLEP_UPGRADE_AUTOPASSWD;
                    Win32Err = RegDeleteValue( WinlogonHandle, DeletePath );
                    DsRolepLogOnFailure( Win32Err,
                                         DsRolepLogPrint(( DEB_TRACE,
                                                           "RegDeleteKey on %ws failed with %lu\n",
                                                           DeletePath,
                                                           Win32Err )) );
                    //
                    // An error here is not considered fatal...
                    //
                    Win32Err = ERROR_SUCCESS;
                }
            }

            if ( Win32Err != ERROR_SUCCESS ) {

                //
                // Raise an event
                //
                SpmpReportEvent( TRUE,
                                 EVENTLOG_WARNING_TYPE,
                                 DSROLERES_FAIL_DISABLE_AUTO_LOGON,
                                 0,
                                 sizeof( ULONG ),
                                 &Win32Err,
                                 1,
                                 DeletePath );

                DSROLEP_SET_NON_FATAL_ERROR( Win32Err );
                Win32Err = ERROR_SUCCESS;

            }
        }


        RegCloseKey( WinlogonHandle );

    }

    //
    // Delete the registry key that LSA uses to determine if this is an upgrade
    //


    //
    // Open the key
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 DSROLEP_UPGRADE_KEY,
                                 0,
                                 DELETE | KEY_SET_VALUE,
                                 &UpgradeKey );

#if DBG
        DsRolepLogOnFailure( Win32Err,
                             DsRolepLogPrint(( DEB_TRACE,
                                               "RegOpenKey on %ws failed with %lu\n",
                                               DSROLEP_UPGRADE_KEY,
                                               Win32Err )) );
#endif
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = RegDeleteValue( UpgradeKey, DSROLEP_UPGRADE_VALUE );

            if ( ERROR_FILE_NOT_FOUND == Win32Err ) {

                // This is ok.
                Win32Err = ERROR_SUCCESS;
                
            }
#if DBG
            DsRolepLogOnFailure( Win32Err,
                                 DsRolepLogPrint(( DEB_TRACE,
                                                   "RegDeleteKey on %ws failed with %lu\n",
                                                   DSROLEP_UPGRADE_KEY,
                                                   Win32Err )) );
#endif
            RegCloseKey( UpgradeKey );
        }
    }

    //
    // Finally remove the nt4 LSA information
    //

    //
    // Remove the nt4 LSA stuff that has been put into the registry
    //
    LsapDsUnitializeDsStateInfo();

    Status = LsaIUpgradeRegistryToDs( TRUE );

    RestoreError = RtlNtStatusToDosError( Status );

    DsRolepLogOnFailure( RestoreError,
                         DsRolepLogPrint(( DEB_WARN,
                                           "Failed to cleanup NT4 LSA (%d)\n",
                                           RestoreError )) );

    if ( ERROR_SUCCESS != RestoreError
      && ERROR_SUCCESS == Win32Err ) {

        Win32Err = RestoreError;
        
    }

    return( Win32Err );
}



DWORD
DsRolepQueryUpgradeInfo(
    OUT PBOOLEAN IsUpgrade,
    OUT PULONG ServerRole
    )
/*++

Routine Description:

    This function queries the current update information.

Arguments:

    IsUpgrade - A pointer to a BOOLEAN to hold a value of TRUE if there is upgrade information
                saved away, or a FALSE if not

    ServerRole - If this is an upgrade, the previous server role is returned here.


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HKEY UpgradeKey;
    ULONG Type, Length = sizeof( ULONG );

    //
    // Open the upgrade key
    //
    Win32Err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                             DSROLEP_UPGRADE_KEY,
                             0,
                             KEY_READ | KEY_WRITE,
                             &UpgradeKey );

    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Finally, set dcpromo to autostart
        //
        Win32Err = RegQueryValueEx( UpgradeKey,
                                    DSROLEP_UPGRADE_VALUE,
                                    0, // reserved
                                    &Type,
                                    ( PBYTE )ServerRole,
                                    &Length );
        if ( Win32Err == ERROR_SUCCESS ) {

            *IsUpgrade = TRUE;

        }

        RegCloseKey( UpgradeKey );

    }

    if ( Win32Err == ERROR_FILE_NOT_FOUND ) {

        Win32Err = ERROR_SUCCESS;
        *IsUpgrade = FALSE;
    }

    return( Win32Err );
}


DWORD
DsRolepGetBuiltinAdminAccountName(
    OUT LPWSTR *BuiltinAdmin
    )
/*++

Routine Description:

    This routine finds the alias name for the builtin user account ADMINISTRATOR

Arguments:

    BuiltinAdmin - Where the admin name is returned

Return Values:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY UaspNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5];
    PSID Sid = ( PSID )SidBuff;
    SID_NAME_USE SNE;
    LPWSTR Domain = NULL;
    LPWSTR Name = NULL;
    ULONG NameLen = 0, DomainLen = 0;


    //
    // Build the sid
    //
    RtlInitializeSid( Sid, &UaspNtAuthority, 2 );
    *( RtlSubAuthoritySid( Sid, 0 ) ) = SECURITY_BUILTIN_DOMAIN_RID;
    *( RtlSubAuthoritySid( Sid, 1 ) ) = DOMAIN_USER_RID_ADMIN;

    if ( LookupAccountSid( NULL,
                           Sid,
                           NULL,
                           &NameLen,
                           NULL,
                           &DomainLen,
                           &SNE ) == FALSE ) {

        Win32Err = GetLastError();

        if ( Win32Err == ERROR_INSUFFICIENT_BUFFER ) {

            Win32Err = ERROR_SUCCESS;

            Name = RtlAllocateHeap( RtlProcessHeap(), 0, NameLen * sizeof( WCHAR ) );

            Domain = RtlAllocateHeap( RtlProcessHeap(), 0, DomainLen * sizeof( WCHAR ) );

            if ( !Name || !Domain ) {

                Win32Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if ( LookupAccountSid( NULL,
                                       Sid,
                                       Name,
                                       &NameLen,
                                       Domain,
                                       &DomainLen,
                                       &SNE ) == FALSE ) {

                    Win32Err = GetLastError();
                }

            }
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        RtlFreeHeap( RtlProcessHeap(), 0, Domain );
        RtlFreeHeap( RtlProcessHeap(), 0, Name );
    }

    return( Win32Err );
}


DWORD
DsRolepSetBuiltinAdminAccountPassword(
    IN LPWSTR Password
    )
/*++

Routine Description:

    This routine will change the password on the builtin administrator account to the one
    specified

Arguments:

    Password - Password to set

Return Values:

    ERROR_SUCCESS - Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAM_HANDLE SamHandle, SamDomainHandle, SamAdministrator;
    PPOLICY_ACCOUNT_DOMAIN_INFO  AccountDomainInfo;
    LSA_HANDLE PolicyHandle;
    USER_ALL_INFORMATION UserAllInfo;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UserPassword;


    RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );


    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( PolicyHandle,
                                            PolicyAccountDomainInformation,
                                            ( PVOID * )&AccountDomainInfo );

        LsaClose( PolicyHandle );
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = SamConnect( NULL,
                             &SamHandle,
                             MAXIMUM_ALLOWED,
                             &ObjectAttributes );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Open the builtin domain
            //
            Status = SamOpenDomain( SamHandle,
                                    MAXIMUM_ALLOWED,
                                    AccountDomainInfo->DomainSid,
                                    &SamDomainHandle );

            if ( NT_SUCCESS( Status ) ) {

                Status = SamOpenUser( SamDomainHandle,
                                      MAXIMUM_ALLOWED,
                                      DOMAIN_USER_RID_ADMIN,
                                      &SamAdministrator );

                if ( NT_SUCCESS( Status ) ) {

                    RtlZeroMemory( &UserAllInfo, sizeof( USER_ALL_INFORMATION ) );

                    RtlInitUnicodeString( &UserPassword, Password );

                    UserAllInfo.NtPassword = UserPassword;
                    UserAllInfo.NtPasswordPresent = TRUE;
                    UserAllInfo.WhichFields = USER_ALL_NTPASSWORDPRESENT;

                    Status = SamSetInformationUser( SamAdministrator,
                                                    UserAllInformation,
                                                    ( PSAMPR_USER_INFO_BUFFER )&UserAllInfo );

                    SamCloseHandle( SamAdministrator );

                }

                SamCloseHandle( SamDomainHandle );
            }

            SamCloseHandle( SamHandle );
        }

        LsaFreeMemory( AccountDomainInfo );
    }


    return( RtlNtStatusToDosError( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\common\util.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the shared utility rountines for dealing with
    sid to string conversion, services, path manipulation etc.

Author:

    Cenk Ergan (cenke) - 2001/05/07

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ginacomn.h>

/***************************************************************************\
* Sid To String routines
*
* GetUserSid - Builds a user's sid from his token.
* GetSidString - Builds a sid string from a user's token.
* DeleteSidString - Free's sid string allocated by GetSidString.
*
* History:
* 03-23-01 Cenke        Copied from userinit\gposcript.cpp
* 06-07-01 Cenke        Fixed memory leak
\***************************************************************************/

PSID
GcGetUserSid( 
    HANDLE UserToken 
    )
{
    PTOKEN_USER pUser;
    PTOKEN_USER pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;

    //
    // Allocate space for the user info
    //
    pUser = (PTOKEN_USER) LocalAlloc( LMEM_FIXED, BytesRequired );
    if ( !pUser )
    {
        return 0;
    }

    //
    // Read in the UserInfo
    //
    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL )
    {
        //
        // Allocate a bigger buffer and try again.
        //
        pTemp = (PTOKEN_USER) LocalReAlloc( pUser, BytesRequired, LMEM_MOVEABLE );
        if ( !pTemp )
        {
            LocalFree(pUser);
            return 0;
        }

        pUser = pTemp;
        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pUser);
        return 0;
    }

    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if ( !pSid )
    {
        LocalFree(pUser);
        return NULL;
    }

    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pSid);
        pSid = 0;
    }

    return pSid;
}

LPWSTR
GcGetSidString( 
    HANDLE UserToken 
    )
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;

    //
    // Get the user sid
    //
    UserSid = GcGetUserSid( UserToken );
    if ( !UserSid )
    {
        return 0;
    }

    //
    // Convert user SID to a string.
    //
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            UserSid,
                                            (BOOLEAN)TRUE ); // Allocate
    LocalFree( UserSid );

    if ( !NT_SUCCESS(NtStatus) )
    {
        return 0;
    }

    return UnicodeString.Buffer ;
}

VOID
GcDeleteSidString( 
    LPWSTR SidString 
    )
{
    UNICODE_STRING String;

    RtlInitUnicodeString( &String, SidString );
    RtlFreeUnicodeString( &String );
}

/***************************************************************************\
* GcWaitForServiceToStart
*
* Waits for the specified service to start.
*
* History:
* 03-23-01 Cenke        Copied from winlogon\wlxutil.c
\***************************************************************************/

BOOL 
GcWaitForServiceToStart (
    LPTSTR lpServiceName, 
    DWORD dwMaxWait
    )
{
    BOOL bStarted = FALSE;
    DWORD dwSize = 512;
    DWORD StartTickCount;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG lpServiceConfig = NULL;

    //
    // OpenSCManager and the service.
    //
    hScManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hScManager) {
        goto Exit;
    }

    hService = OpenService(hScManager, lpServiceName,
                           SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (!hService) {
        goto Exit;
    }

    //
    // Query if the service is going to start
    //
    lpServiceConfig = LocalAlloc (LPTR, dwSize);
    if (!lpServiceConfig) {
        goto Exit;
    }

    if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto Exit;
        }

        LocalFree (lpServiceConfig);

        lpServiceConfig = LocalAlloc (LPTR, dwSize);

        if (!lpServiceConfig) {
            goto Exit;
        }

        if (!QueryServiceConfig (hService, lpServiceConfig, dwSize, &dwSize)) {
            goto Exit;
        }
    }

    if (lpServiceConfig->dwStartType != SERVICE_AUTO_START) {
        goto Exit;
    }

    //
    // Loop until the service starts or we think it never will start
    // or we've exceeded our maximum time delay.
    //

    StartTickCount = GetTickCount();

    while (!bStarted) {

        if ((GetTickCount() - StartTickCount) > dwMaxWait) {
            break;
        }

        if (!QueryServiceStatus(hService, &ServiceStatus )) {
            break;
        }

        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            if (ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED) {
                Sleep(500);
            } else {
                break;
            }
        } else if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

            bStarted = TRUE;

        } else if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING) {
            Sleep(500);
        } else {
            Sleep(500);
        }
    }


Exit:

    if (lpServiceConfig) {
        LocalFree (lpServiceConfig);
    }

    if (hService) {
        CloseServiceHandle(hService);
    }

    if (hScManager) {
        CloseServiceHandle(hScManager);
    }

    return bStarted;
}


/***************************************************************************\
* GcCheckSlash
*
* Checks for an ending slash and adds one if it is missing.
*
* Parameters: lpDir   -   directory
* Return:     Pointer to the end of the string
*
* History:
* 06-19-95 EricFlo        Created
\***************************************************************************/

LPTSTR 
GcCheckSlash (
    LPTSTR lpDir
    )
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

/***************************************************************************\
* GcIsUNCPath
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL 
GcIsUNCPath(
    LPTSTR lpPath
    )
{
    if (lpPath[0] == TEXT('\\') && lpPath[1] == TEXT('\\')) {
        return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\delprof\delprof.h ===
//*************************************************************
//  File name: delprof.h
//
//  Description:  header file for delprof.c
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************


//
// Strings
//

#define IDS_USAGE1              1
#define IDS_USAGE2              2
#define IDS_USAGE3              3
#define IDS_USAGE4              4
#define IDS_USAGE5              5
#define IDS_USAGE6              6
#define IDS_USAGE7              7
#define IDS_USAGE8              8
#define IDS_USAGE9              9
#define IDS_CONFIRM            10
#define IDS_CONFIRMDAYS        11
#define IDS_NO                 12
#define IDS_FAILEDPROFILELIST  13
#define IDS_FAILEDENUM         14
#define IDS_FAILEDPATHQUERY    15
#define IDS_FAILEDOPENPROFILE  16
#define IDS_SKIPPROFILE        17
#define IDS_DELETEPROMPT       18
#define IDS_DELETING           19
#define IDS_SUCCESS            20
#define IDS_FAILED             21


typedef struct _DELETEITEM {
    LPTSTR lpSubKey;
    LPTSTR lpProfilePath;
    BOOL   bDir;
    struct _DELETEITEM * pNext;
} DELETEITEM, *LPDELETEITEM;


//
// Date conversion functions
//

void APIENTRY gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp);
LONG APIENTRY gdate_dmytoday(int yr, int month, int day);
int APIENTRY gdate_monthdays(int month, int year);
int APIENTRY gdate_weekday(long daynr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\delprof\gdate.c ===
/****************************** Module Header *******************************
* Module Name: GDATE.C
*
* Contains date conversion functions.
*
* Functions:
*
* gdi_isleap()
* gdate_daytodmy()
* gdate_dmytoday()
* gdate_monthdays()
* gdate_weeklyday()
*
* Comments:  This code stolen from windiff.exe
*
****************************************************************************/

#include <windows.h>
#include <string.h>

//#include "gutils.h"


BOOL gdi_isleap(LONG year);

/*---static data--------------------------------------------*/

int monthdays[] = {
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
};


/***************************************************************************
 * Function: gdate_daytomy
 *
 * Purpose:
 *
 * converts day to d/m/y
 */
void APIENTRY
gdate_daytodmy(LONG days, int FAR* yrp, int FAR* monthp, int FAR* dayp)
{
        int years;
        int nleaps;
        int month;
        int mdays;

        /* get number of completed years and calc leap days */
        years = (int) (days / 365);
        days = days % 365;
        nleaps = (years / 4) - (years / 100) + (years / 400);
        while (nleaps > days) {
                days += 365;
                years--;
                nleaps = (years / 4) - (years / 100) + (years / 400);
        }
        days -= nleaps;

        /* add one year for current (non-complete) year */
        years++;


        /* current month */
        for (month = 0; month < 12; month++) {
                mdays = monthdays[month];
                if (gdi_isleap(years) && (month == 1)) {
                        mdays++;
                }
                if (days == mdays) {
                        days = 0;
                        month++;
                        break;
                } else if (days < mdays) {
                        break;
                } else {
                        days -= mdays;
                }
        }
        /* conv month from 0-11 to 1-12 */
        if (monthp != NULL) {
                *monthp = month+1;
        }
        if (dayp != NULL) {
                *dayp = (int) days + 1;
        }
        if (yrp != NULL) {
                *yrp = years;
        }
}


/***************************************************************************
 * Function: gdate_dmytoday
 *
 * Purpose:
 *
 * converts d/m/y to a day
 */ 
LONG APIENTRY
gdate_dmytoday(int yr, int month, int day)
{
        int nleaps;
        int i;
        long ndays;

        /* exclude the current year */
        yr--;
        nleaps = (yr / 4) - (yr / 100) + (yr / 400);

        /* in any given year, day 0 is jan1 */
        month--;
        day--;
        ndays = 0;
        for (i = 0; i < month ; i++) {
                ndays += monthdays[i];
                if (gdi_isleap(yr+1) && (i == 1)) {
                        ndays++;
                }
        }
        ndays = ndays + day + nleaps + (yr * 365L);
        return(ndays);
}

/***************************************************************************
 * Function: gdate_monthdays
 *
 * Purpose:
 *
 * Gets number of days in month
 */
int APIENTRY
gdate_monthdays(int month, int year)
{
        int ndays;

        ndays = monthdays[month - 1];
        if (gdi_isleap(year) && (month == 2)) {
                ndays++;
        }
        return(ndays);
}

/***************************************************************************
 * Function: gdate_weekday
 *
 * Purpose:
 * 
 * Gets the day of the week
 */
int APIENTRY
gdate_weekday(long daynr)
{
        return((int) ((daynr + 1) % 7));
}


/***************************************************************************
 * Function: gdi_isleap
 *
 * Purpose:
 * 
 * Determines whether the year is a leap year
 */
BOOL
gdi_isleap(LONG year)
{
        if ( ((year % 4) == 0) &&
                (((year % 100) != 0) ||
                ((year % 400) == 0))) {
                        return TRUE;
        } else {
                return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\events.h ===
//*************************************************************
//
//  Events.h    -   header file for events.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "gpdasevt.h"
#include "smartptr.h"

class CEvents
{
    private:
        BOOL            m_bError;       // the kind of error to log
        DWORD           m_dwId;         // id of the msg
        XPtrLF<LPTSTR>  m_xlpStrings;   // Array to store arguments
        WORD            m_cStrings;     // Number of elements already in the array
        WORD            m_cAllocated;   // Number of elements allocated
        BOOL            m_bInitialised; // Initialised ?
        BOOL            m_bFailed;      // Failed in processing ?

        // Not implemented.
        CEvents(const CEvents& x);
        CEvents& operator=(const CEvents& x);


        BOOL ReallocArgStrings();


    public:
        CEvents(BOOL bError, DWORD dwId );
        BOOL AddArg(LPTSTR szArg);
        BOOL AddArg(DWORD dwArg);
        BOOL AddArgHex(DWORD dwArg);
        BOOL Report();
        ~CEvents();
};

extern TCHAR MessageResourceFile[];
BOOL ShutdownEvents (void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\events.cpp ===
//*************************************************************
//
//  Events.cpp    -   Routines to handle the event log
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "stdafx.h"
#include "rsopdbg.h"
#include "events.h"


HANDLE  hEventLog = NULL;
TCHAR   EventSourceName[] = TEXT("GPDAS");
TCHAR   MessageResourceFile[] = TEXT("%systemroot%\\system32\\rsopprov.exe");



//*************************************************************
//
//  InitializeEvents()
//
//  Purpose:    Opens the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL InitializeEvents (void)
{

    //
    // Open the event source
    //

    hEventLog = RegisterEventSource(NULL, EventSourceName);

    if (hEventLog) {
        return TRUE;
    }

    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("InitializeEvents:  Could not open event log.  Error = %d"), GetLastError());

    return FALSE;
}



//*************************************************************
//
//  Implementation of CEvents
//
//*************************************************************



//*************************************************************
//  CEvents::CEvents
//  Purpose:    Constructor
//
//  Parameters: 
//      bError  - Error or informational
//      dwId    - Id of the eventlog msg
//
//
//  allocates a default sized array for the messages
//*************************************************************

#define DEF_ARG_SIZE 10

CEvents::CEvents(BOOL bError, DWORD dwId ) : 
                          m_cStrings(0), m_cAllocated(0), m_bInitialised(FALSE),
                          m_bError(bError), m_dwId(dwId), m_bFailed(TRUE)
{
    //
    // Allocate a default size for the message
    //
    
    m_xlpStrings = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*DEF_ARG_SIZE);
    m_cAllocated = DEF_ARG_SIZE;
    if (!m_xlpStrings) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::CEvent  Cannot log event, failed to allocate memory, error %d"), GetLastError());
        return;
    }


    //
    // Initialise eventlog if it is not already initialised
    //
    
    if (!hEventLog) {
        if (!InitializeEvents()) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::CEvent  Cannot log event, no handle"));
            return;
        }
    }

    m_bInitialised = TRUE;    
    m_bFailed = FALSE;
}



//*************************************************************
//  CEvents::~CEvents()
//
//  Purpose:    Destructor
//
//  Parameters: void
//
//  frees the memory
//*************************************************************

CEvents::~CEvents()
{
    for (int i = 0; i < m_cStrings; i++)
        if (m_xlpStrings[i])
            LocalFree(m_xlpStrings[i]);
}

//*************************************************************
//
//  CEvents::ReallocArgStrings
//
//  Purpose: Reallocates the buffer for storing arguments in case
//           the buffer runs out
//
//  Parameters: void
//
//  reallocates
//*************************************************************

BOOL CEvents::ReallocArgStrings()
{
    XPtrLF<LPTSTR>  aStringsNew;


    //
    // first allocate a larger buffer
    //
    
    aStringsNew = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*(m_cAllocated+DEF_ARG_SIZE));

    if (!aStringsNew) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::CEvent  Couldn't allocate memory"));
        m_bFailed = TRUE;        
        return FALSE;            
    }


    //
    // copy the arguments
    //
    
    for (int i = 0; i < (m_cAllocated); i++) {
        aStringsNew[i] = m_xlpStrings[i];
    }
    
    m_xlpStrings = aStringsNew.Acquire();        
    m_cAllocated+= DEF_ARG_SIZE;

    return TRUE;
}



//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters: 
//
//*************************************************************

BOOL CEvents::AddArg(LPTSTR szArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg:  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    
    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;            
    }

    
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szArg)+1));

    if (!m_xlpStrings[m_cStrings]) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError());
        m_bFailed = TRUE;        
        return FALSE;            
    }
    

    lstrcpy(m_xlpStrings[m_cStrings], szArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters: 
//
//*************************************************************

BOOL CEvents::AddArg(DWORD dwArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg(dw):  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    
    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;            
    }

    // 2^32 < 10^10
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*20);

    if (!m_xlpStrings[m_cStrings]) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArg(dw)  Cannot allocate memory, error = %d"), GetLastError());
        m_bFailed = TRUE;        
        return FALSE;            
    }
    

    wsprintf(m_xlpStrings[m_cStrings], TEXT("%d"), dwArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters: 
//
//*************************************************************

BOOL CEvents::AddArgHex(DWORD dwArg)
{
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArgHex:  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    
    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;            
    }

    
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*20);

    if (!m_xlpStrings[m_cStrings]) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvent::AddArgHex  Cannot allocate memory, error = %d"), GetLastError());
        m_bFailed = TRUE;        
        return FALSE;            
    }
    

    wsprintf(m_xlpStrings[m_cStrings], TEXT("%#x"), dwArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::Report
//
//  Purpose: Actually collectes all the arguments and reports it to
//           the eventlog
//
//  Parameters: void
//
//*************************************************************

BOOL CEvents::Report()
{
    PSID pSid = NULL; // no sid being reportewd currently
    WORD wType=0;
    BOOL bResult = TRUE;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CEvents::Report:  Cannot log event, not initialised or failed before"));    
        return FALSE;
    }
    


    if ( m_bError ) {
        wType = EVENTLOG_ERROR_TYPE;
    } else {
        wType = EVENTLOG_INFORMATION_TYPE;
    }
            
    
    if (!ReportEvent(hEventLog, wType, 0, m_dwId, pSid, m_cStrings, 0, (LPCTSTR *)((LPTSTR *)m_xlpStrings), NULL)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING,  TEXT("CEvents::Report: ReportEvent failed.  Error = %d"), GetLastError());
        bResult = FALSE;
    }


    return bResult;
}


//*************************************************************
//
//  ShutdownEvents()
//
//  Purpose:    Stops the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL ShutdownEvents (void)
{
    BOOL bRetVal = TRUE;

    if (hEventLog) {
        bRetVal = DeregisterEventSource(hEventLog);
        hEventLog = NULL;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\idl\$(O)\$(@F)
    copy ..\idl\$(O)\$(@F) $@

$(O)\RSoP.MFL $(O)\RSoP.MOF: RSoPCore.MOF RSoPCls.MOF
    mofcomp -MOF:$(O)\RSoP.MOF -MFL:$(O)\RSoP.MFL -Amendment:ms_409 RSoPCore.MOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RSOPPROV.rc
//
#define IDS_SERVICENAME                 100
#define IDR_RSOPPROV                    100
#define IDS_GPDAS_DESC                  101
#define IDR_RsopPlanningModeProvider    102

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\stdafx.cpp ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  stdafx.cpp
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\gpdas.cpp ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  gpdas.cpp
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#include "stdafx.h"
#include "planprov.h"
#include "gpdas.h"
#include <lm.h>
#include <dsgetdc.h>
#define SECURITY_WIN32
#include <security.h>
#include "userenv.h"
#include "userenvp.h"
#include "rsopinc.h"
#include "rsoputil.h"
#include "rsopdbg.h"
#include "rsopsec.h"
#include "Indicate.h"
#include "events.h"
#include "gpfilter.h"


CDebug dbgRsop(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 TRUE );


CDebug dbgCommon(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 FALSE );


extern "C" PSID GetUserSid (HANDLE UserToken);


class CAutoNetApiBufferFree
{
private:
        LPVOID _pV;

public:
        CAutoNetApiBufferFree(LPVOID pV)
           : _pV(pV)
        {
        }

        ~CAutoNetApiBufferFree()
        {
            if (_pV)
                NetApiBufferFree(_pV);
        }
};


bool SplitName(LPCWSTR pszUser, LPWSTR* ppszUserDomain, LPWSTR* ppszUserName)
{
        if(!pszUser)
        {
                return false;
        }

        *ppszUserDomain = NULL;
        *ppszUserName = NULL;

        wchar_t* p = wcschr(pszUser, L'\\');

        if(p)
        {
                LONG userDomainLength = (LONG)(p - pszUser);
                if(!userDomainLength)
                {
                        return false;
                }

                *ppszUserDomain = new wchar_t[userDomainLength + 1];
                if(!*ppszUserDomain)
                {
                        return false;
                }

                int userNameLength = wcslen(pszUser) - userDomainLength - 1;
                *ppszUserName = new wchar_t[userNameLength + 1];
                if(!*ppszUserName)
                {
                        delete[] *ppszUserDomain;
                        *ppszUserDomain = NULL;
                        return false;
                }

                wcsncpy(*ppszUserDomain, pszUser, userDomainLength);
                wcscpy(*ppszUserName, pszUser + userDomainLength + 1);
        }
        else
        {
                int userNameLength = wcslen(pszUser);
                *ppszUserName = new wchar_t[userNameLength + 1];
                if(!*ppszUserName)
                {
                        return false;
                }

                wcscpy(*ppszUserName, pszUser);
                *ppszUserDomain = NULL;
        }

        return true;
}


//*************************************************************
//
//  RsopPlanningModeProvider::RsopPlanningModeProvider()
//
//  Purpose:   Constructor
//
//*************************************************************

RsopPlanningModeProvider::RsopPlanningModeProvider()
    : m_pWbemServices(NULL),
      m_bInitialized(NULL)
{
    _Module.IncrementServiceCount();

    m_xbstrMachName = L"computerName";
    if ( !m_xbstrMachName )
        return;

    m_xbstrMachSOM = L"computerSOM";
    if ( !m_xbstrMachSOM )
        return;

    m_xbstrMachGroups = L"computerSecurityGroups";
    if ( !m_xbstrMachGroups )
        return;

    m_xbstrUserName = L"userName";
    if ( !m_xbstrUserName )
        return;

    m_xbstrUserSOM = L"userSOM";
    if ( !m_xbstrUserSOM )
        return;

    m_xbstrUserGroups = L"userSecurityGroups";
    if ( !m_xbstrUserGroups )
        return;

    m_xbstrSite = L"site";
    if ( !m_xbstrSite )
         return;

    m_xbstrUserGpoFilter = L"userGPOFilters";
    if ( !m_xbstrUserGpoFilter )
         return;
    
    m_xbstrComputerGpoFilter = L"computerGPOFilters";
    if ( !m_xbstrComputerGpoFilter )
         return;

    m_xbstrFlags = L"flags";
    if ( !m_xbstrFlags )
         return;
    
    m_xbstrNameSpace = L"nameSpace";
    if ( !m_xbstrNameSpace )
        return;

    m_xbstrResult = L"hResult";
    if ( !m_xbstrResult )
         return;

    m_xbstrExtendedInfo = L"ExtendedInfo";
    if ( !m_xbstrExtendedInfo )
         return;

    m_xbstrClass = L"RsopPlanningModeProvider";
    if ( !m_xbstrClass )
       return;

    // m_xptrInvokerName = 0;

    m_bInitialized = TRUE;
}


//*************************************************************
//
//  Initialize()
//
//  Purpose:    WbemProvider's initialize method
//
//  Parameters: See IWbemProivderInit::Initialize
//
//  Return:     hresult
//
//*************************************************************

STDMETHODIMP RsopPlanningModeProvider::Initialize( LPWSTR pszUser,
                                                   LONG lFlags,
                                                   LPWSTR pszNamespace,
                                                   LPWSTR pszLocale,
                                                   IWbemServices __RPC_FAR *pNamespace,
                                                   IWbemContext __RPC_FAR *pCtx,
                                                   IWbemProviderInitSink __RPC_FAR *pInitSink )
{
    HRESULT hr;

    if ( !m_bInitialized ) {
        hr = pInitSink->SetStatus(E_FAIL, 0);
        return hr;
    }

    if ( !pszUser )
    {
        hr = pInitSink->SetStatus(E_INVALIDARG, 0);
        return hr;
    }

    if(m_pWbemServices)
    {
        m_pWbemServices->Release();
        m_pWbemServices = NULL;
    }

    m_pWbemServices = pNamespace;
    m_pWbemServices->AddRef();

    hr = CoMarshalInterThreadInterfaceInStream(__uuidof(IWbemServices), m_pWbemServices, &m_pStream);
    if(SUCCEEDED(hr))
        hr = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    else
    {
        m_pWbemServices->Release();
        hr = pInitSink->SetStatus(hr, 0);
    }

    return hr;
}


//*************************************************************
//
//  ExecMethodAsync()
//
//  Purpose:    Execute method
//
//  Parameters: See IWbemServices::ExecMethodAsync
//
//  Return:     hresult
//
//*************************************************************



STDMETHODIMP RsopPlanningModeProvider::ExecMethodAsync( BSTR bstrObject,
                                                        BSTR bstrMethod,
                                                        long lFlags,
                                                        IWbemContext* pCtx,
                                                        IWbemClassObject* pInParams,
                                                        IWbemObjectSink* pResponseHandler )
{

    dbgRsop.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 FALSE );


    dbgCommon.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 FALSE );
    //
    // Initialize the return status object to fail status
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecMethodAsync: Entering") );

    CFailRetStatus retStatus( pResponseHandler );
    HRESULT hr;
    XInterface<IWbemLocator> xLocator;

    hr = CoCreateInstance(  CLSID_WbemLocator,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator,
                            (LPVOID *) &xLocator );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync: CoCreateInstance returned 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    IWbemClassObject* pProvClass = NULL;
    IWbemClassObject* pOutClass = NULL;
    IWbemClassObject* pOutParams = NULL;
    IWbemServices* pWbemServices = NULL;

    hr = CoGetInterfaceAndReleaseStream(m_pStream, __uuidof(IWbemServices), (void**)&pWbemServices);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoGetInterfaceAndReleaseStream failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    hr = pWbemServices->GetObject( m_xbstrClass, 0, pCtx, &pProvClass, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetObject failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xProvClass( pProvClass );

    hr = CoMarshalInterThreadInterfaceInStream(__uuidof(IWbemServices), pWbemServices, &m_pStream);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoMarshallInterThreadInterfaceInStream failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    hr = pProvClass->GetMethod( bstrMethod, 0, NULL, &pOutClass);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetMethod failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xOutClass( pOutClass );

    hr = pOutClass->SpawnInstance(0, &pOutParams);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SpawnInstance failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xOutParams( pOutParams );
    
    XHandle                     xhUserToken;

    {
        XImpersonate xImp;

        if ( FAILED( xImp.Status() ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient() failed with 0x%x."), xImp.Status() );
            retStatus.SetError( xImp.Status() );
            return xImp.Status();
        }


        if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &xhUserToken)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Openthreadtoken failed with 0x%x after impersonation."), GetLastError() );
            retStatus.SetError( HRESULT_FROM_WIN32(GetLastError()) );
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }


    if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopDeleteSession" ) == 0 )
    {
        VARIANT vNameSpace;
        hr = pInParams->Get( m_xbstrNameSpace, 0, &vNameSpace, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine name failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvNameSpace( &vNameSpace );

        if ( vNameSpace.vt == VT_NULL )
            hr = E_INVALIDARG;
        else {
            hr = ProviderDeleteRsopNameSpace( xLocator, 
                                              vNameSpace.bstrVal,
                                              xhUserToken, 
                                              NULL, 
                                              SETUP_NS_PM);
        }

        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        return hr;
    }

    //
    // Code for RsopCreateSession method
    //

    BOOL bMachineData = TRUE;
    BOOL bUserData = TRUE;

    VARIANT vMachName;
    VariantInit( &vMachName );
    hr = pInParams->Get( m_xbstrMachName, 0, &vMachName, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine name failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvMachName( &vMachName );

    VARIANT vMachSOM;
    VariantInit( &vMachSOM );
    hr = pInParams->Get( m_xbstrMachSOM, 0, &vMachSOM, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine SOM failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    if ( vMachSOM.vt == VT_EMPTY || vMachSOM.vt == VT_NULL )
    {
        if ( vMachName.vt == VT_EMPTY || vMachName.vt == VT_NULL )
        {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: Machine name and SOM are NULL."));
            bMachineData = FALSE;
        }
        else
        {
            XPtrLF<WCHAR> szMachine = LocalAlloc( LPTR, ( wcslen( vMachName.bstrVal ) + 2 ) * sizeof( WCHAR ) );

            if ( !szMachine )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Not enough memory 0x%x."), hr );
                retStatus.SetError( hr );
                return hr;
            }

            wcscpy( szMachine, vMachName.bstrVal );
            
            XBStr xbstrSOM = GetSOM( szMachine );

            if ( !xbstrSOM )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine SOM failed with 0x%x."), hr );
                retStatus.SetError( hr );
                return hr;
            }

            vMachSOM.vt = VT_BSTR;
            vMachSOM.bstrVal = xbstrSOM.Acquire();
        }
    }

    CProgressIndicator  Indicator(  pResponseHandler,
                                    (lFlags & WBEM_FLAG_SEND_STATUS) != 0 );
    Indicator.IncrementBy( 5 );

    //
    // vMachSOM is going to have at least empty data in it all cases
    //

    XVariant xvMachSOM( &vMachSOM );

    VARIANT vUserName;
    VariantInit( &vUserName );
    hr = pInParams->Get( m_xbstrUserName, 0, &vUserName, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user name failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvUserName( &vUserName );

    VARIANT vUserSOM;
    VariantInit( &vUserSOM );
    hr = pInParams->Get( m_xbstrUserSOM, 0, &vUserSOM, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user SOM failed with 0x%x."), GetLastError() );
        retStatus.SetError( hr );
        return hr;
    }
    if ( vUserSOM.vt == VT_EMPTY || vUserSOM.vt == VT_NULL )
    {
        if ( vUserName.vt == VT_EMPTY || vUserName.vt == VT_NULL )
        {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: User name and SOM are NULL."));
            bUserData = FALSE;
        }
        else
        {
            XBStr xbstrSOM = GetSOM( vUserName.bstrVal );

            if ( !xbstrSOM )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user SOM failed with 0x%x."), GetLastError() );
                retStatus.SetError( hr );
                return hr;
            }

            vUserSOM.vt = VT_BSTR;
            vUserSOM.bstrVal = xbstrSOM.Acquire();
        }
    }

    //
    // vUserSOM is going to have at least empty data in it all cases
    //

    XVariant xvUserSOM( &vUserSOM );

    //
    // Nothing was asked for..
    //

    if ( (!bMachineData) && (!bUserData) ) {
        hr = S_OK;
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: User and machine (both name and SOM) are NULL."));
        retStatus.SetError( WBEM_E_INVALID_PARAMETER );
        return hr;
    }


    VARIANT vMachGroups;
    hr = pInParams->Get( m_xbstrMachGroups, 0, &vMachGroups, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine groups failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvMachGroups( &vMachGroups );


    VARIANT vUserGroups;
    hr = pInParams->Get( m_xbstrUserGroups, 0, &vUserGroups, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get user groups failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvUserGroups( &vUserGroups );


    VARIANT vSite;
    hr = pInParams->Get( m_xbstrSite, 0, &vSite, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get site failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvSite( &vSite );


    //
    // Add computer gpo filters
    //

    VARIANT vComputerGpoFilter;
    hr = pInParams->Get( m_xbstrComputerGpoFilter, 0, &vComputerGpoFilter, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get Gpo filter failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvComputerGpoFilter( &vComputerGpoFilter );

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::Gpo filter:Adding Computer filters") );

    CGpoFilter computerGpoFilter;
    hr = computerGpoFilter.Add( &vComputerGpoFilter );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Gpo filter:Add failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    
    //
    // Add user gpo filters
    //

    VARIANT vUserGpoFilter;
    hr = pInParams->Get( m_xbstrUserGpoFilter, 0, &vUserGpoFilter, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get Gpo filter failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    
    XVariant xvUserGpoFilter( &vUserGpoFilter );

    CGpoFilter userGpoFilter;
    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::Gpo filter:Adding User filters") );
    
    hr = userGpoFilter.Add( &vUserGpoFilter );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Gpo filter:Add failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    
    VARIANT vFlags;
    VariantInit( &vFlags );
    hr = pInParams->Get( m_xbstrFlags, 0, &vFlags, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get dwFlags failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    DWORD dwFlags = vFlags.vt == VT_EMPTY || vFlags.vt == VT_NULL ? 0 : vFlags.ulVal;
    dwFlags &= ~FLAG_INTERNAL_MASK;

    if ( dwFlags & FLAG_NO_GPO_FILTER )
    {
        dwFlags |= FLAG_NO_CSE_INVOKE;
    }
        
    //
    // do some parameter checks
    //

    if ((dwFlags & FLAG_LOOPBACK_MERGE) && (dwFlags & FLAG_LOOPBACK_REPLACE)) {            
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Loopback merge and replace, both are specified. failing"));
        retStatus.SetError( WBEM_E_INVALID_PARAMETER );
        return S_OK;
    }

    if (dwFlags & FLAG_LOOPBACK_MERGE) {            
        
        if (!bMachineData || !bUserData) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Loopback mode both user AND computer data needs to be specified"));
            retStatus.SetError( WBEM_E_INVALID_PARAMETER );
            return S_OK;
        }
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: Loopback merge mode specified"));
    }


    if (dwFlags & FLAG_LOOPBACK_REPLACE) {
        if (!bMachineData) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Loopback mode computer data needs to be specified"));
            retStatus.SetError( WBEM_E_INVALID_PARAMETER );
            return S_OK;
        }
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod:: Loopback replace mode specified"));
    }

    //
    // Below is a hack...
    // In case of replace mode, user som or account doesn't need to be supplied...
    // but we need to fool the rest of the code to think that user data is specified
    // and desired and we need to access check againt user som alone. 
    // Copy Mach som to user som
    //

    if (dwFlags & FLAG_LOOPBACK_REPLACE) {
        xvUserSOM = NULL;
    
        // reinit user som
        VariantInit( &vUserSOM );
        vUserSOM.vt = VT_BSTR;
        vUserSOM.bstrVal = SysAllocString(vMachSOM.bstrVal);
    
        if (!vUserSOM.bstrVal) {
            retStatus.SetError( hr );
            return hr;
        }
    
        xvUserSOM = &vUserSOM;
    }


    //
    // We can dump out all the input parameters here later on.
    // Currently dumping only remote Computer.
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::dwFlags = 0x%x"), dwFlags);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));

    
    // by this point we have finished all param checks. All future errors needs to be
    // returned in the method specific hResult 

    //
    // Check for access before entering policy critical section
    //

    DWORD dwExtendedInfo = 0;

    hr = AuthenticateUser(  xhUserToken,
                            vMachSOM.vt != VT_NULL ? vMachSOM.bstrVal : 0,
                            vUserSOM.vt != VT_NULL ? vUserSOM.bstrVal : 0,
                            FALSE, 
                            &dwExtendedInfo );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: AuthenticateUser() failed with 0x%x."), hr );
    }


    //
    // Synchronize with garbage collection thread in userenv.dll by acquiring Group Policy critical section
    //

    if (SUCCEEDED(hr)) {
        
        XCriticalPolicySection criticalPolicySectionMACHINE( EnterCriticalPolicySection(TRUE) );
        if(!criticalPolicySectionMACHINE)
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection (machine) failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        XCriticalPolicySection criticalPolicySectionUSER( EnterCriticalPolicySection(FALSE) );
        if( !criticalPolicySectionUSER )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection (user) failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }


        XPtrLF<WCHAR> xwszNameSpace; 

        XPtrLF<SID> xSid = GetUserSid(xhUserToken);
        if (!xSid) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetUserSid failed with error %d."), GetLastError() );
            return HRESULT_FROM_WIN32(GetLastError());
        }


        hr = SetupNewNameSpace( &xwszNameSpace,
                                0, // namespace on this machine
                                NULL, xSid,
                                xLocator, SETUP_NS_PM, NULL);
        if ( FAILED( hr ) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SetupNewNameSpace failed with 0x%x"), hr );
        }
        else 
        {

            BOOL bOk;
            bOk  = GenerateRsopPolicy(  dwFlags,
                                        vMachName.vt == VT_NULL ? 0 : vMachName.bstrVal,
                                        vMachSOM.vt == VT_NULL ? 0 : vMachSOM.bstrVal,
                                        vMachGroups.vt == VT_NULL ? 0 : vMachGroups.parray,
                                        vUserName.vt == VT_NULL ? 0 : vUserName.bstrVal,
                                        vUserSOM.vt == VT_NULL ? 0 : vUserSOM.bstrVal,
                                        vUserGroups.vt == VT_NULL ? 0 : vUserGroups.parray,
                                        vSite.vt == VT_NULL ? 0 : vSite.bstrVal,
                                        xwszNameSpace,
                                        &Indicator,
                                        &computerGpoFilter,
                                        &userGpoFilter );
            if ( !bOk )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( SUCCEEDED( hr ) )
                {
                    hr = E_FAIL;
                }

                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GenerateRsopPolicy failed with 0x%x"), hr );
//                CEvents ev(TRUE, EVENT_GENRSOP_FAILED);
//                ev.AddArg(hr); ev.Report();

                HRESULT hrDel = DeleteRsopNameSpace( xwszNameSpace, xLocator );
                if ( FAILED( hrDel ) )
                {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::DeleteRsopNameSpace failed with 0x%x"), hrDel );
                }
            }
            else
            {
                XBStr xbstrNS( xwszNameSpace );
                if ( !xbstrNS )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Memory allocate failed") );
                    retStatus.SetError( hr );
                    return hr;
                }

                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = xbstrNS;
                hr = pOutParams->Put( m_xbstrNameSpace, 0, &var, 0);
                if ( FAILED(hr) )
                {
                    dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put namespace failed with 0x%x"), hr );
                    retStatus.SetError( hr );
                    return hr;
                }
            }
        }
    }
    
    VARIANT var;
    var.vt = VT_I4;
    var.lVal = hr;

    hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    var.lVal = dwExtendedInfo;
    hr = pOutParams->Put( m_xbstrExtendedInfo, 0, &var, 0);
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    //
    // change all returns to retStatus = error_code; return S_OK;
    //

    hr = Indicator.SetComplete();
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Increment() failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    hr = pResponseHandler->Indicate(1, &pOutParams);
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\gpdas.h ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  gpdas.h
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#if !defined(AFX_GPDAS_H__6A79C813_70A7_4024_A840_66B2D92A23E8__INCLUDED_)
#define AFX_GPDAS_H__6A79C813_70A7_4024_A840_66B2D92A23E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "stdafx.h"
#include "resource.h"
#include <wbemidl.h>
#include "smartptr.h"


class RsopPlanningModeProvider : public IWbemProviderInit,
                                 public IWbemServices,
                                 public CComObjectRoot,
                                 public CComCoClass<RsopPlanningModeProvider,&CLSID_RsopPlanningModeProvider>
{
public:
        RsopPlanningModeProvider();

        ~RsopPlanningModeProvider()
        {
            if(m_pWbemServices)
                m_pWbemServices->Release();

            _Module.DecrementServiceCount();
        }

BEGIN_COM_MAP(RsopPlanningModeProvider)
        COM_INTERFACE_ENTRY(IWbemProviderInit)
        COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(RsopPlanningModeProvider)

DECLARE_REGISTRY_RESOURCEID(IDR_RsopPlanningModeProvider)

public:

    //
    // IWbemServices methods
    //

    STDMETHOD(OpenNamespace)(const BSTR Namespace,long lFlags,IWbemContext* pCtx,IWbemServices** ppWorkingNamespace,IWbemCallResult** ppResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CancelAsyncCall)(IWbemObjectSink *pSink){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CancelAsyncRequest)(long lAsyncRequestHandle){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(QueryObjectSink)( long lFlags,IWbemObjectSink **ppResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(GetObject)(const BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemClassObject** ppObject, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(GetObjectAsync)(const BSTR ObjectPath,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutClass)(IWbemClassObject* pObject, long lFlags, IWbemContext* pCtx,IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutClassAsync)(IWbemClassObject* pObject, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteClass)(const BSTR Class, long lFlags, IWbemContext* pCtx, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteClassAsync)(const BSTR Class, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateClassEnum)(const BSTR Superclass, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateClassEnumAsync)(const BSTR Superclass, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutInstance)(IWbemClassObject* pInst, long lFlags, IWbemContext* pCtx, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(PutInstanceAsync)(IWbemClassObject* pInst, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteInstance)(const BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(DeleteInstanceAsync)(const BSTR ObjectPath, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateInstanceEnum)(const BSTR Class, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(CreateInstanceEnumAsync)(const BSTR Class, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecQueryAsync)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecNotificationQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IEnumWbemClassObject** ppEnum){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecNotificationQueryAsync)(const BSTR QueryLanguage, const BSTR Query, long lFlags, IWbemContext* pCtx, IWbemObjectSink* pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecMethod)(const BSTR ObjectPath, const BSTR MethodName, long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, IWbemClassObject** ppOutParams, IWbemCallResult** ppCallResult){return WBEM_E_NOT_SUPPORTED;}
    STDMETHOD(ExecMethodAsync)(const BSTR ObjectPath, const BSTR MethodName, long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, IWbemObjectSink* pResponseHandler);

    //
    // IWbemProviderInit methods
    //

    STDMETHOD(Initialize)(LPWSTR pszUser, LONG lFlags, LPWSTR pszNamespace, LPWSTR pszLocale,IWbemServices __RPC_FAR *pNamespace,
                          IWbemContext __RPC_FAR *pCtx, IWbemProviderInitSink __RPC_FAR *pInitSink);

private:

    IWbemServices*          m_pWbemServices;
    LPSTREAM                m_pStream;

    BOOL                    m_bInitialized;
    XBStr                   m_xbstrMachName;
    XBStr                   m_xbstrMachSOM;
    XBStr                   m_xbstrMachGroups;
    XBStr                   m_xbstrUserName;
    XBStr                   m_xbstrUserSOM;
    XBStr                   m_xbstrUserGroups;
    XBStr                   m_xbstrSite;
    XBStr                   m_xbstrUserGpoFilter;
    XBStr                   m_xbstrComputerGpoFilter;
    XBStr                   m_xbstrFlags;
    XBStr                   m_xbstrNameSpace;
    XBStr                   m_xbstrResult;
    XBStr                   m_xbstrExtendedInfo;
    XBStr                   m_xbstrClass;
};

#endif // !defined(AFX_GPDAS_H__6A79C813_70A7_4024_A840_66B2D92A23E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\rsopprov.cpp ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  gpdas.h
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f RSOPPROVps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "planprov.h"
#include <stdio.h>
#include "GPDAS.h"
#include "events.h"
#include "rsopdbg.h"


CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RsopPlanningModeProvider, RsopPlanningModeProvider)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_RSOPPROV, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{6EBBFC6C-B721-4D10-9371-5D8E8C76D315}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));

    if (bService)
    {
        key.SetValue(_T("RSOPPROV"), _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_RSOPPROV, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Lock()
{
    LONG l = CComModule::Lock();
    IncrementServiceCount();
    return l;
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    DecrementServiceCount();
    return l;
}

LONG CServiceModule::IncrementServiceCount()
{
    LONG l;

   l = CoAddRefServerProcess();
   dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::IncrementServiceCount. Ref count = %d."), l);
   return l;
}

LONG CServiceModule::DecrementServiceCount()
{
    LONG srvRefCount = CoReleaseServerProcess();
    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::DecrementServiceCount. Ref count = %d. "), srvRefCount);

    if (srvRefCount == 0) {
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::Unlock Ref count came down to zero. Exitting."));
    }
    return srvRefCount;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    //
    // as part of the initialisation, install the eventlog as well.
    //

    HKEY hKey;
    DWORD dwTypes=7, dwDisp;
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\gpdas"),
                     0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

        RegSetValueEx(hKey, TEXT("EventMessageFile"), 0, REG_EXPAND_SZ, (BYTE *)MessageResourceFile, (1+lstrlen(MessageResourceFile))*sizeof(TCHAR));
        RegSetValueEx(hKey, TEXT("TypesSupported"), 0, REG_DWORD, (BYTE *)&dwTypes, sizeof(dwTypes));
        
        RegCloseKey(hKey);                    
    }
    
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions.
//
// This has static buffers and other restrictions. This is being used only in the service startup scenario
///////////////////////////////////////////////////////////////////////////////////////


void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
/*    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        CEvents ev(TRUE, EVENT_GPDAS_STARTUP);
        ev.AddArg(chMsg); ev.Report();
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
*/
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CServiceModule::ServiceMain failed to Register ServiceCtrlHandler with error %d."), GetLastError() );
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);

}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("CServiceModule::Handler Wrong opcode passed to handler %d."), dwOpcode );
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode);
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

//    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

    _Module.RevokeClassObjects();

    CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_RSOPPROVLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);

        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);

        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{6EBBFC6C-B721-4D10-9371-5D8E8C76D315}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    ShutdownEvents();    

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpdas\stdafx.h ===
//*************************************************************
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//  stdafx.h
//
//  Module: Rsop Planning mode Provider
//
//  History:    11-Jul-99   MickH    Created
//
//*************************************************************

#if !defined(AFX_STDAFX_H__1BB94413_1005_4129_B577_B9A060FFDA25__INCLUDED_)
#define AFX_STDAFX_H__1BB94413_1005_4129_B577_B9A060FFDA25__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    LONG Lock();
    void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();
    LONG IncrementServiceCount();
    LONG DecrementServiceCount();


//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
};

extern CServiceModule _Module;

#include <atlcom.h>
#include <comdef.h>

#endif // !defined(AFX_STDAFX_H__1BB94413_1005_4129_B577_B9A060FFDA25__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\client\bind.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  apis.cxx
//
//*************************************************************

#include "appmgmt.hxx"

handle_t    ghRpc = 0;

DWORD
Bind()
{
    SC_HANDLE       hSC;
    SC_HANDLE       hAppSvc;
    USHORT*         pwszStringBinding;
    SERVICE_STATUS  ServiceStatus;
    DWORD           Status;
    DWORD           Retries;
    DWORD           MaxRetries;
    BOOL            bServiceStarted;
    BOOL            bStatus;

    if ( ghRpc )
        return ERROR_SUCCESS;

    hSC = 0;
    hAppSvc = 0;

    Status = ERROR_SUCCESS;

    hSC = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE );

    if ( hSC )
        hAppSvc = OpenService( hSC, L"appmgmt", SERVICE_QUERY_STATUS | SERVICE_START );

    if ( ! hAppSvc )
    {
        Status = GetLastError();
        goto BindEnd;
    }

    bServiceStarted = FALSE;

    Retries = 0;
    MaxRetries = MAX_SERVICE_START_WAIT_TIME / SERVICE_RETRY_INTERVAL;

    do
    {
        bStatus = QueryServiceStatus( hAppSvc, &ServiceStatus );

        if ( ! bStatus )
        {
            Status = GetLastError();
            goto BindEnd;
        }

        switch ( ServiceStatus.dwCurrentState )
        {
        case SERVICE_STOPPED :
            bStatus = StartService( hAppSvc, NULL, NULL );

            if ( ! bStatus )
            {
                Status = GetLastError();
                goto BindEnd;
            }
            break;
        case SERVICE_START_PENDING :
            DWORD dwNewMaxRetries;

            dwNewMaxRetries = ServiceStatus.dwWaitHint / SERVICE_RETRY_INTERVAL;

            if ( dwNewMaxRetries < MaxRetries )
            {
                MaxRetries = dwNewMaxRetries;
            }

            break;
        case SERVICE_STOP_PENDING :
            break;
        case SERVICE_RUNNING :
            bServiceStarted = TRUE;
            break;
        default :
            ASSERT(0);
            Status = ERROR_INVALID_SERVICE_CONTROL;
            goto BindEnd;
        }

        if ( bServiceStarted )
            break;

        Sleep( SERVICE_RETRY_INTERVAL );

        Retries++;

    } while ( Retries <= MaxRetries ) ;

    if ( ! bServiceStarted )
    {
        Status = ERROR_SERVICE_REQUEST_TIMEOUT;
        goto BindEnd;
    }

    Status = RpcStringBindingCompose(
                NULL,
                (PUSHORT)L"ncalrpc",
                NULL,
                (PUSHORT)L"appmgmt",
                NULL,
                &pwszStringBinding );

    if ( ERROR_SUCCESS == Status )
    {
        if ( ! ghRpc )
        {
            Status = RpcBindingFromStringBinding(
                        pwszStringBinding,
                        &ghRpc );
        }
    
        RpcStringFree( &pwszStringBinding );
    }

BindEnd:

    if ( hAppSvc )
        CloseServiceHandle( hAppSvc );

    if ( hSC )
        CloseServiceHandle( hSC );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\client\cltevnts.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  cltevnts.cxx
//
//*************************************************************

#include "appmgmt.hxx"

void
CEvents::ZAPInstall(
    DWORD       ErrorStatus,
    WCHAR *     pwszDeploymentName,
    WCHAR *     pwszGPOName,
    WCHAR *     pwszPath
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_ZAP_FAILED,
            FALSE,
            4,
            pwszDeploymentName,
            pwszGPOName,
            pwszPath,
            wszStatus );
    }
    else
    {
        Report(
            EVENT_APPMGMT_ZAP,
            FALSE,
            2,
            pwszDeploymentName,
            pwszGPOName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\client\apis.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998-2000
//  All rights reserved
//
//  apis.cxx
//
//*************************************************************

#include "appmgmt.hxx"

static CLoadMsi * gLoadMsi = 0;
static WCHAR * gpwszWinsta = 0;

static DWORD ReportInstallStatus(
    PINSTALLCONTEXT pInstallContext,
    DWORD           InstallStatus,
    BOOL            bUninstall,
    WCHAR *         pwszDeploymentName,
    WCHAR *         pwszGPOName,
    WCHAR *         pwszDeploymentId
    );

DWORD WINAPI
InstallApplication(
    IN  PINSTALLDATA pInstallData
    )
{
    APPKEY              AppKey;
    HINSTANCE           hMsi;
    MSICONFIGUREPRODUCTEXW * pfnConfigureProduct;
    PINSTALLCONTEXT     pInstallContext;
    APPLICATION_INFO    InstallInfo;
    UNINSTALL_APPS      UninstallApps;
    DWORD               InstallUILevel;
    INSTALLUILEVEL      OldUILevel;
    DWORD               UninstallCount;
    DWORD               n;
    DWORD               ExtraStatus;
    DWORD               Status;
    BOOL                bStatus;
    boolean             bInstall;

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( DebugLevelOn(DM_VERBOSE) )
    {
        WCHAR *             pwszCommandLine;
        WCHAR               UserName[32];
        DWORD               NameLength;

        NameLength = sizeof(UserName) / sizeof(WCHAR);
        UserName[0] = 0;

        GetUserName( UserName, &NameLength );

        pwszCommandLine = GetCommandLine();
        if ( ! pwszCommandLine )
            pwszCommandLine = L"";

        DebugMsg((DM_VERBOSE, IDS_INSTALL_REQUEST, pwszCommandLine, UserName));
    }

    AppKey.Type = pInstallData->Type;
    AppKey.ProcessorArchitecture = DEFAULT_ARCHITECTURE;

    switch ( pInstallData->Type )
    {
    case APPNAME :
        AppKey.uType.AppName.Name = pInstallData->Spec.AppName.Name;
        memcpy( &AppKey.uType.AppName.PolicyId, &pInstallData->Spec.AppName.GPOId, sizeof(GUID) );
        break;
    case FILEEXT :
        AppKey.uType.FileExt = pInstallData->Spec.FileExt;
        break;
    case PROGID :
        AppKey.uType.ProgId = pInstallData->Spec.ProgId;
        break;
    case COMCLASS :
        AppKey.uType.COMClass.Clsid = pInstallData->Spec.COMClass.Clsid;
        AppKey.uType.COMClass.ClsCtx = pInstallData->Spec.COMClass.ClsCtx;

        break;
    default :
        return ERROR_INVALID_PARAMETER;
    }

    pInstallContext = 0;
    memset( &InstallInfo, 0, sizeof(InstallInfo) );
    memset( &UninstallApps, 0, sizeof(UninstallApps) );

    Status = InstallBegin(
                ghRpc,
                &AppKey,
                &pInstallContext,
                &InstallInfo,
                &UninstallApps );

    if ( Status != ERROR_SUCCESS )
        return Status;

    CLoadMsi    LoadMsi( Status );

    if ( Status != ERROR_SUCCESS )
        goto InstallApplicationExit;

    if ( InstallInfo.pwszSetupCommand )
    {
        HINSTANCE           hShell32;
        SHELLEXECUTEEXW *   pfnShellExecuteEx;
        SHELLEXECUTEINFO    ShellExInfo;
        WCHAR *             pwszCommand;
        WCHAR *             pwszParams;
        WCHAR *             pwszDirectory;

        pwszDirectory = NULL;

        pfnShellExecuteEx = 0;
        hShell32 = LoadLibrary( L"shell32.dll" );

        if ( hShell32 )
            pfnShellExecuteEx = (SHELLEXECUTEEXW *) GetProcAddress( hShell32, "ShellExecuteExW" );

        if ( ! pfnShellExecuteEx )
            Status = GetLastError();

        if ( ERROR_SUCCESS == Status )
        {
            pwszCommand = InstallInfo.pwszSetupCommand;

            if ( L'"' == pwszCommand[0] )
            {
                pwszParams = wcschr( &pwszCommand[1], L'"' );
                if ( pwszParams )
                    pwszCommand++;
            }
            else
            {
                pwszParams = wcschr( pwszCommand, L' ' );
            }

            if ( pwszParams )
            {
                *pwszParams++ = 0;
                while ( L' ' == *pwszParams )
                    pwszParams++;
            }
        }

        //
        // Need to set the current directory to that 
        // containing the actual executable
        //
        if ( ERROR_SUCCESS == Status )
        {
            WCHAR* pwszDirectoryEnd;

            //
            // Find the last pathsep, which marks the
            // end of the containing directory -- if we 
            // don't find it, the admin specified some strange
            // path and we'll just end up passing NULL for
            // the current directory
            //
            pwszDirectoryEnd = wcsrchr( pwszCommand, L'\\' );

            if ( pwszDirectoryEnd )
            {
                //
                // Get a copy of the full path that we can
                // truncate to the containing directory
                //
                pwszDirectory = StringDuplicate( pwszCommand );

                if ( pwszDirectory )
                {
                    //
                    // Truncate to the containing directory
                    //
                    pwszDirectory[ pwszDirectoryEnd - pwszCommand ] = L'\0';
                }
                else
                {
                    Status = ERROR_OUTOFMEMORY;
                }
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            ShellExInfo.cbSize = sizeof( ShellExInfo );
            ShellExInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
            ShellExInfo.hwnd = NULL;
            ShellExInfo.lpVerb = NULL;
            ShellExInfo.lpFile = pwszCommand;
            ShellExInfo.lpParameters = pwszParams;
            ShellExInfo.lpDirectory = pwszDirectory;
            ShellExInfo.nShow = SW_SHOWNORMAL;
            ShellExInfo.hProcess = 0;

            DebugMsg((DM_VERBOSE, IDS_LEGACY_INSTALL, pwszCommand));

            bStatus = (*pfnShellExecuteEx)( &ShellExInfo );

            if ( ! bStatus )
                Status = GetLastError();
        }

        delete [] pwszDirectory;

        if ( hShell32 )
            FreeLibrary( hShell32 );

        if ( (ERROR_SUCCESS == Status) && ShellExInfo.hProcess )
        {
            Status = WAIT_OBJECT_0;

            if ( LoadUser32Funcs() )
            {
                MSG     msg;
                HANDLE  Handles[2];

                Handles[0] = ShellExInfo.hProcess;

                for (;;)
                {
                    Status = (*pfnMsgWaitForMultipleObjects)( 1, Handles, FALSE, INFINITE, QS_ALLINPUT );

                    if ( (WAIT_OBJECT_0+1) == Status )
                    {
                        if ( (*pfnPeekMessageW)( &msg, NULL, 0, 0, PM_REMOVE) )
                        {
                            (*pfnTranslateMessage)( &msg );
                            (*pfnDispatchMessageW)( &msg );
                        }
                        continue;
                    }

                    break;
                }
            }

            CloseHandle( ShellExInfo.hProcess );

            if ( WAIT_OBJECT_0 == Status )
                Status = ERROR_SUCCESS;
            else
                Status = GetLastError();
        }

        gpEvents->ZAPInstall(
                    Status,
                    InstallInfo.pwszDeploymentName,
                    InstallInfo.pwszGPOName,
                    pwszCommand );

        goto InstallApplicationExit;
    }

    OldUILevel = (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NOCHANGE, NULL );

    if ( UninstallApps.Products > 0 )
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_BASIC, NULL );

    for ( UninstallCount = 0; UninstallCount < UninstallApps.Products; )
    {
        if ( UninstallApps.ApplicationInfo[UninstallCount].Flags & APPINFOFLAG_UNINSTALL )
        {
            DebugMsg((DM_VERBOSE, IDS_UNINSTALL, UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentName, UninstallApps.ApplicationInfo[UninstallCount].pwszGPOName));

            //
            // The MsiQueryProductState could fail due to out of memory -- it could
            // return INSTALL_STATE_UNKNOWN in out of memory situations, and we would incorrectly
            // unmanage the application -- so we use MsiGetProductInfo which returns a status
            // that allows us to distinguish these cases
            //
            Status = gpfnMsiGetProductInfo(
                UninstallApps.ApplicationInfo[UninstallCount].pwszProductCode,
                INSTALLPROPERTY_PACKAGECODE,
                NULL,
                NULL);

            //
            // If the product is installed, try to uninstall.  If it exists but has
            // bad configuration data, attempt the uninstall anyway in the hope that
            // it will get removed
            //
            if ( ( ERROR_SUCCESS == Status ) ||
                 ( ERROR_BAD_CONFIGURATION == Status ) )
            {
                //
                // ERROR_SUCCESS_REBOOT_INITIATED here will be treated as an error
                // since we don't want to attempt to do an install if the machine
                // is being rebooted.
                // The two REJECTED errors can be encountered when the application is 
                // only advertised and is prevented from (un)installing by policy.
                //
                Status = (*gpfnMsiConfigureProductEx)( UninstallApps.ApplicationInfo[UninstallCount].pwszProductCode, INSTALLLEVEL_MAXIMUM, INSTALLSTATE_ABSENT, NULL );

                if ( ERROR_SUCCESS_REBOOT_REQUIRED == Status )
                {
                    Status = ERROR_SUCCESS;
                }
                else if ( (ERROR_INSTALL_PACKAGE_REJECTED == Status) ||
                          (ERROR_INSTALL_TRANSFORM_REJECTED == Status) )
                {
                    Status = InstallUnmanageApp( pInstallContext, UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentId, TRUE );
                }
            }
            else if ( ERROR_UNKNOWN_PRODUCT == Status )
            {
                //
                // If we didn't find the product, treat this as a successful removal
                // since the desired state, absence of the app, is achieved.
                //
                Status = ERROR_SUCCESS;
            }

            ReportInstallStatus(
                pInstallContext,
                Status,
                TRUE,
                UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentName,
                UninstallApps.ApplicationInfo[UninstallCount].pwszGPOName,
                UninstallApps.ApplicationInfo[UninstallCount].pwszDeploymentId);
        }

        // Nothing to do here for an orphaned app.

        if ( ERROR_SUCCESS == Status )
            UninstallCount++;

        if ( Status != ERROR_SUCCESS )
            goto InstallApplicationRollback;
    }

    Status = InstallManageApp( pInstallContext, InstallInfo.pwszDeploymentId, ERROR_SUCCESS, &bInstall );

    if ( Status != ERROR_SUCCESS )
        goto InstallApplicationRollback;

    if ( InstallInfo.Flags & APPINFOFLAG_FULLUI )
        InstallUILevel = INSTALLUILEVEL_FULL;
    else // InstallInfo.Flags & APPINFOFLAG_BASICUI
        InstallUILevel = INSTALLUILEVEL_BASIC;

    if ( (APPNAME == pInstallData->Type) && (InstallInfo.Flags & APPINFOFLAG_BASICUI) )
        InstallUILevel |= INSTALLUILEVEL_ENDDIALOG;

    (void) (*gpfnMsiSetInternalUI)( (INSTALLUILEVEL) InstallUILevel, NULL );

    if ( InstallInfo.pwszDescriptor )
    {
        DebugMsg((DM_VERBOSE, IDS_INSTALL_DESC, InstallInfo.pwszDeploymentName, InstallInfo.pwszGPOName));
        Status = (*gpfnMsiProvideComponentFromDescriptor)( InstallInfo.pwszDescriptor, NULL, NULL, NULL );
        REMAP_DARWIN_STATUS( Status );

        ReportInstallStatus(
            pInstallContext,
            Status,
            FALSE,
            InstallInfo.pwszDeploymentName,
            InstallInfo.pwszGPOName,
            InstallInfo.pwszDeploymentId);
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_INSTALL_PC, InstallInfo.pwszDeploymentName, InstallInfo.pwszGPOName));
        Status = (*gpfnMsiConfigureProductEx)( InstallInfo.pwszProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_DEFAULT, NULL );
        REMAP_DARWIN_STATUS( Status );

        ReportInstallStatus(
            pInstallContext,
            Status,
            FALSE,
            InstallInfo.pwszDeploymentName,
            InstallInfo.pwszGPOName,
            InstallInfo.pwszDeploymentId);
    }

    (void) (*gpfnMsiSetInternalUI)( OldUILevel, NULL );

    //
    // If the added app was already managed, any error must be ignored, we don't want to
    // unmanage it in this case.  Darwin rollback & repair should handle these cases.
    //
    if ( (Status != ERROR_SUCCESS) && (InstallInfo.Flags & APPINFOFLAG_ALREADYMANAGED) )
        goto InstallApplicationExit;

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Now we can finally unmanage any upgraded apps.
        // If these fail, it will be fixed up in a subsequent run of policy.
        //
        for ( n = 0; n < UninstallCount; n++ )
            ExtraStatus = InstallUnmanageApp( pInstallContext, UninstallApps.ApplicationInfo[n].pwszDeploymentId, FALSE );

        goto InstallApplicationExit;
    }

    //
    // Failed to install the new app, unmanage it and fall through to our rollback.
    //

    ExtraStatus = InstallUnmanageApp( pInstallContext, InstallInfo.pwszDeploymentId, FALSE );

InstallApplicationRollback:

    for ( n = 0; n < UninstallCount; n++ )
    {
        bInstall = FALSE;
        ExtraStatus = InstallManageApp( pInstallContext, UninstallApps.ApplicationInfo[n].pwszDeploymentId, Status, &bInstall );
        if ( (ERROR_SUCCESS == ExtraStatus) && bInstall )
        {
            (void) (*gpfnMsiConfigureProductEx)( UninstallApps.ApplicationInfo[n].pwszProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_DEFAULT, NULL );
            gpEvents->Install( Status, UninstallApps.ApplicationInfo[n].pwszDeploymentName, UninstallApps.ApplicationInfo[n].pwszGPOName );
        }
    }

InstallApplicationExit:

    if ( pInstallContext )
        InstallEnd( (Status == ERROR_SUCCESS), &pInstallContext );

    FreeApplicationInfo( &InstallInfo );

    while ( UninstallApps.Products )
        FreeApplicationInfo( &UninstallApps.ApplicationInfo[--UninstallApps.Products] );
    LocalFree( UninstallApps.ApplicationInfo );

    return Status;
}

DWORD WINAPI
UninstallApplication(
    IN  WCHAR *     ProductCode,
    IN  DWORD       dwStatus
    )
{
    DWORD   Status;

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    return ARPRemoveApp( ghRpc, ProductCode, dwStatus );
}

DWORD WINAPI
CommandLineFromMsiDescriptor(
    IN  WCHAR *     Descriptor,
    OUT WCHAR *     CommandLine,
    IN OUT DWORD *  CommandLineLength
    )
{
    INSTALLUILEVEL  NewUILevel;
    INSTALLUILEVEL  OldUILevel;
    HKEY    hkAppmgmt;
    WCHAR   ProductCode[40];
    DWORD   Size;
    DWORD   ArgStart;
    DWORD   Status;

	Status = ERROR_SUCCESS;

    //
    // For this api we can not affort to dynamically load/unload msi each time, it 
    // is just called too frequently.
    // We'll store the load object in a global rather then a static in case we 
    // add support for a call-in mechanism to free this.
    //
    if ( ! gLoadMsi )
        gLoadMsi = new CLoadMsi( Status );

    if ( gLoadMsi && (Status != ERROR_SUCCESS) )
    {
        delete gLoadMsi;
        gLoadMsi = 0;
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( ! LoadUser32Funcs() )
        return ERROR_OUTOFMEMORY;

    //
    // We get the process window station in order to detect processes running
    // in non-interactive desktops where Darwin UI is not possible.  Darwin
    // itself is not aware of these situations.
    //
    if ( ! gpwszWinsta )
    {
        HWINSTA hWinsta;
        BOOL    bStatus;

        hWinsta = (*pfnGetProcessWindowStation)();

        if ( hWinsta )
        {
            Size = 0;
            (void) (*pfnGetUserObjectInformationW)( hWinsta, UOI_NAME, NULL, 0, &Size );

            gpwszWinsta = new WCHAR[Size/2];
            if ( gpwszWinsta )
            {
                bStatus = (*pfnGetUserObjectInformationW)( hWinsta, UOI_NAME, gpwszWinsta, Size, &Size );
                if ( ! bStatus )
                {
                    Status = GetLastError();
                    delete gpwszWinsta;
                    gpwszWinsta = 0;
                }
            }
            else
                Status = ERROR_OUTOFMEMORY;

            (*pfnCloseWindowStation)( hWinsta );
        }

        //
        // Since this code was added very late (just before nt5 rc3) we don't
        // treat an error in getting the window station handle as a failure in
        // this API.  Too many unknowns with the security configuration of
        // services.  We'll treat this case as a non-winsta0 process.
        //
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    //
    // If we can't grab the winsta handle or can confirm that this is a
    // non-winsta0 process, we fix the ui level to none.
    //
    if ( (0 == gpwszWinsta) || (lstrcmp( L"WinSta0", gpwszWinsta ) != 0) )
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

    OldUILevel = (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NOCHANGE, NULL );

    //
    // Some processes, like the dcom service, may not be able to handle UI
    // of any kind.  So if the UI level is currently set to none we never
    // change it.
    //
    if ( OldUILevel != INSTALLUILEVEL_NONE )
    {
        Status = (*gpfnMsiDecomposeDescriptor)(
                        Descriptor,
                        ProductCode,
                        NULL,
                        NULL,
                        NULL );

        if ( Status != ERROR_SUCCESS )
            return Status;

        Status = RegOpenKeyEx(
                        HKEY_CURRENT_USER,
                        APPMGMTKEY,
                        0,
                        KEY_READ,
                        &hkAppmgmt );

        if ( ERROR_SUCCESS == Status )
        {
            Size = sizeof( NewUILevel );

            Status = RegQueryValueEx(
                             hkAppmgmt,
                             ProductCode,
                             NULL,
                             NULL,
                             (PBYTE) &NewUILevel,
                             &Size );

            RegCloseKey( hkAppmgmt );
        }

        if ( ERROR_SUCCESS == Status )
            (*gpfnMsiSetInternalUI)( NewUILevel, NULL );
    }

    //
    // Returns a quoted exe path with appended args.  The forth parameter
    // is obsolete and returns no usefull value.
    //
    Status = (*gpfnMsiProvideComponentFromDescriptor)(
                    Descriptor,
                    CommandLine,
                    CommandLineLength,
                    &ArgStart );

    REMAP_DARWIN_STATUS( Status );

    if ( Status != ERROR_SUCCESS )
        DebugMsg((DM_VERBOSE, IDS_DESC_FAIL, Descriptor, Status));

    (*gpfnMsiSetInternalUI)( OldUILevel, NULL );

    return Status;
}

DWORD WINAPI
GetLocalManagedApplications(
    IN  BOOL                        bUserApps,
    OUT LPDWORD                     pdwApps,
    OUT PLOCALMANAGEDAPPLICATION *  prgLocalApps
    )

{
    PLOCALMANAGEDAPPLICATION    pLocalApps;
    HKEY    hkRoot;
    HKEY    hkAppmgmt;
    HKEY    hkApp;
    WCHAR   wszDeploymentId[44];
    DWORD   Size;
    DWORD   Index;
    DWORD   Apps;
    DWORD   Status;

    *pdwApps = 0;
    *prgLocalApps = 0;

    Status = ERROR_SUCCESS;

    if ( bUserApps )
        Status = RegOpenCurrentUser( KEY_READ, &hkRoot );
    else
        hkRoot = HKEY_LOCAL_MACHINE;

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = RegOpenKeyEx(
                hkRoot,
                APPMGMTKEY,
                0,
                KEY_READ,
                &hkAppmgmt );

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = RegQueryInfoKey (
                hkAppmgmt,
                NULL,
                NULL,
                NULL,
                &Apps,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL );

    if ( ERROR_SUCCESS == Status )
    {
        pLocalApps = (PLOCALMANAGEDAPPLICATION) LocalAlloc( LMEM_ZEROINIT, Apps * sizeof(LOCALMANAGEDAPPLICATION) );
        if ( ! pLocalApps )
            Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
    {
        RegCloseKey( hkAppmgmt );
        if ( bUserApps )
            RegCloseKey( hkRoot );
        return ERROR_SUCCESS;
    }

    for ( Index = 0; Index < Apps; Index++ )
    {
        Status = RegEnumKey(
                    hkAppmgmt,
                    Index,
                    wszDeploymentId,
                    sizeof(wszDeploymentId) / sizeof(WCHAR) );

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegOpenKeyEx(
                        hkAppmgmt,
                        wszDeploymentId,
                        0,
                        KEY_READ,
                        &hkApp );
        }

        if ( Status != ERROR_SUCCESS )
            break;

        Size = sizeof(DWORD);

        Status = RegQueryValueEx(
                    hkApp,
                    APPSTATEVALUE,
                    0,
                    NULL,
                    (LPBYTE) &pLocalApps[Index].dwState,
                    &Size );

        if ( ERROR_SUCCESS == Status )
            Status = ReadStringValue( hkApp, DEPLOYMENTNAMEVALUE, &pLocalApps[Index].pszDeploymentName );

        if ( ERROR_SUCCESS == Status )
            Status = ReadStringValue( hkApp, GPONAMEVALUE, &pLocalApps[Index].pszPolicyName );

        if ( ERROR_SUCCESS == Status )
            Status = ReadStringValue( hkApp, PRODUCTIDVALUE, &pLocalApps[Index].pszProductId );

        RegCloseKey( hkApp );

        if ( Status != ERROR_SUCCESS )
            break;
    }

    if ( Status != ERROR_SUCCESS )
    {
        for ( Index = 0; Index < Apps; Index++ )
        {
            LocalFree( pLocalApps[Index].pszDeploymentName );
            LocalFree( pLocalApps[Index].pszPolicyName );
            LocalFree( pLocalApps[Index].pszProductId );
        }
        LocalFree( pLocalApps );
    }
    else
    {
        *prgLocalApps = pLocalApps;
        *pdwApps = Apps;
    }

    RegCloseKey( hkAppmgmt );
    if ( bUserApps )
        RegCloseKey( hkRoot );

    return Status;
}

void WINAPI
GetLocalManagedApplicationData(
    WCHAR *             ProductCode,
    LPWSTR *            DisplayName,
    LPWSTR *            SupportUrl
    )
{
    HKEY    hkRoot;
    HKEY    hkAppmgmt;
    HKEY    hkApp;
    WCHAR   wszDeploymentId[44]; 
    WCHAR   wszProductId[40];
    DWORD   Index;
    DWORD   Size;
    DWORD   Status;
    BOOL    bUser;

    *DisplayName = 0;
    *SupportUrl = 0;

    for ( int i = 0; i < 2; i++ )
    {
        Status = ERROR_SUCCESS;
        bUser = (0 == i);

        if ( bUser )
            Status = RegOpenCurrentUser( KEY_READ, &hkRoot );
        else
            hkRoot = HKEY_LOCAL_MACHINE;
    
        if ( Status != ERROR_SUCCESS )
            break;

        hkAppmgmt = 0;
    
        Status = RegOpenKeyEx(
                    hkRoot,
                    APPMGMTKEY,
                    0,
                    KEY_READ,
                    &hkAppmgmt );
    
        if ( bUser )
            RegCloseKey( hkRoot );

        if ( ERROR_SUCCESS == Status )
        {
            DWORD InstallUI;

            Size = sizeof(InstallUI);

            // This is the hint that we will use to determine if this product is managed.
            Status = RegQueryValueEx(
                        hkAppmgmt,
                        ProductCode,
                        NULL,
                        NULL,
                        (LPBYTE) &InstallUI,
                        &Size );
        }

        if ( Status != ERROR_SUCCESS )
        {
            if ( hkAppmgmt )
                RegCloseKey( hkAppmgmt );
            continue;
        }

        for ( Index = 0 ;; Index++ )
        {
            Status = RegEnumKey(
                        hkAppmgmt,
                        Index,
                        wszDeploymentId,
                        sizeof(wszDeploymentId) / sizeof(WCHAR) );
    
            if ( ERROR_SUCCESS == Status )
            {
                Status = RegOpenKeyEx(
                            hkAppmgmt,
                            wszDeploymentId,
                            0,
                            KEY_READ,
                            &hkApp );
            }

            if ( Status != ERROR_SUCCESS )
                break;
    
            Size = sizeof(wszProductId);
            wszProductId[0] = 0;
            (void) RegQueryValueEx( hkApp, PRODUCTIDVALUE, NULL, NULL, (LPBYTE) wszProductId, &Size );
    
            if ( lstrcmpi( ProductCode, wszProductId ) != 0 )
            {
                RegCloseKey( hkApp );
                continue;
            }
    
            (void) ReadStringValue( hkApp, DEPLOYMENTNAMEVALUE, DisplayName );
            (void) ReadStringValue( hkApp, SUPPORTURL, SupportUrl );

            RegCloseKey( hkApp );
            break;
        }
    
        RegCloseKey( hkAppmgmt );

        if ( *DisplayName || *SupportUrl )
            break;
    }
}

DWORD WINAPI
GetManagedApplications(
    IN  GUID*                pCategory,
    IN  DWORD                dwQueryFlags,
    IN  DWORD                dwInfoLevel,
    OUT LPDWORD              pdwApps,
    OUT PMANAGEDAPPLICATION* prgManagedApps)
{
    LONG             Status;
    MANAGED_APPLIST  AppList;

    //
    // Initialize the out parameters
    //
    if (pdwApps) {
        *pdwApps = NULL;
    }

    if (prgManagedApps) {
        *prgManagedApps = NULL;
    }

    //
    // Validate caller parameters that aren't passed to the
    // rpc interface -- other parameters will be validated
    // by the server
    //
    if (!pdwApps || !prgManagedApps) {
        return ERROR_INVALID_PARAMETER;
    }

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    //
    // Initialize our stack variables
    //
    memset(&AppList, 0, sizeof(AppList));

    //
    // Call the method on the server.
    //
    Status = GetManagedApps( ghRpc, pCategory, dwQueryFlags, dwInfoLevel, &AppList);

    //
    // On success, set the caller's out parameters to refer
    // to the results returned by the server
    //
    if ( ERROR_SUCCESS == Status)
    {
        *pdwApps = AppList.Applications;
        *prgManagedApps = (PMANAGEDAPPLICATION) AppList.rgApps;
    }

    return Status;
}

static DWORD
ReportInstallStatus(
    PINSTALLCONTEXT pInstallContext,
    DWORD           InstallStatus,
    BOOL            bUninstall,
    WCHAR *         pwszDeploymentName,
    WCHAR *         pwszGPOName,
    WCHAR *         pwszDeploymentId
    )
{
    DWORD Status;
    DWORD dwEventId;

    Status = ERROR_SUCCESS;

    //
    // First, report the correct event based on whether
    // this is an install or an uninstall
    //
    if ( ! bUninstall )
    {
        gpEvents->Install(
            InstallStatus,
            pwszDeploymentName,
            pwszGPOName
            );    

        ( ERROR_SUCCESS == InstallStatus ) ? 
            ( dwEventId = EVENT_APPMGMT_INSTALL ) : ( dwEventId = EVENT_APPMGMT_INSTALL_FAILED );
    }
    else
    {
        gpEvents->Uninstall(
            InstallStatus,
            pwszDeploymentName,
            pwszGPOName
            );    

        ( ERROR_SUCCESS == InstallStatus ) ? 
            ( dwEventId = EVENT_APPMGMT_UNINSTALL ) : ( dwEventId = EVENT_APPMGMT_UNINSTALL_FAILED );
    }

    //
    // If there was an error, log a failure status
    //
    if ( ERROR_SUCCESS != InstallStatus )
    {
        Status = RsopReportInstallFailure(
            pInstallContext,
            pwszDeploymentId,
            dwEventId);
    }

    return Status;
}


DWORD WINAPI
GetManagedApplicationCategories(
    DWORD                dwReserved,
    APPCATEGORYINFOLIST* pAppCategory
    )
{
    DWORD           Status;
    APPCATEGORYLIST CategoryList;
    
    if ( ( 0 != dwReserved ) ||
         ! pAppCategory )
    {
        return ERROR_INVALID_PARAMETER;
    }

    memset( &CategoryList, 0, sizeof( CategoryList ) );

    Status = Bind();

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = GetManagedAppCategories(
        ghRpc,
        &CategoryList);

    *pAppCategory = *( ( APPCATEGORYINFOLIST* ) &CategoryList );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\client\app_client.c ===
#include <app_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\client\main.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  main.cxx
//
//*************************************************************

#include "appmgmt.hxx"

extern "C" BOOLEAN
AppmgmtInitialize(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        InitDebugSupport( DEBUGMODE_CLIENT );
        gpEvents = new CEvents();
        break;
    case DLL_PROCESS_DETACH :
        if ( ghRpc )
            RpcBindingFree( &ghRpc );
        delete gpEvents;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\common\cs_guids.c ===
#include <cs_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\common\cres.h ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Resource.h
//
//  Header file for app.rc
//
//*************************************************************

// Client defs
#define IDS_CLIENT_UNINSTALL    2000
#define IDS_INSTALL_PC          2001
#define IDS_INSTALL_DESC        2002
#define IDS_DESC_FAIL           2003
#define IDS_LEGACY_INSTALL      2004
#define IDS_INSTALL_REQUEST     2005

// Server defs
#define IDS_STRING              3000
#define IDS_USER                3001
#define IDS_MACHINE             3002
#define IDS_ADDASSIGNED         3003
#define IDS_ADDPUBLISHED        3004
#define IDS_GPO_NAME            3005
#define IDS_GPO_FILESYSPATH     3006
#define IDS_GPO_DSPATH          3007
#define IDS_ADDORPHANED         3008
#define IDS_INSTALLED           3009
#define IDS_REMOVE_POLICY       3010
#define IDS_PROCESSGPT_RETURN   3011
#define IDS_NOIMPERSONATE       3012
#define IDS_NUMAPPS             3013
#define IDS_ADDUNINSTALLED      3014
#define IDS_UNKNOWN             3015
#define IDS_USERAPPS_NOCAT      3016
#define IDS_CSENUMAPPS_FAIL     3017
#define IDS_ASSIGN              3018
#define IDS_GETLOCALAPPS_FAIL   3019
#define IDS_CREATEDIR_FAIL      3020
#define IDS_NOCHANGES           3021
#define IDS_GET_LOCAL_APPS      3022
#define IDS_CHECK_APP_FOUND     3023
#define IDS_CSPATH              3024
#define IDS_NOCSPATH            3025
#define IDS_LOCALASSIGN_APP     3026
#define IDS_LOCALPUBLISHED_APP  3027
#define IDS_ADDUNKNOWN          3028
#define IDS_CHECK_APP_NOTFOUND  3029
#define IDS_UNINSTALL_ACTION1   3030
#define IDS_INSTALL_ACTION1     3031
#define IDS_ASSIGN1_ACTION      3032
#define IDS_NO_LOCAL_APPS       3033
#define IDS_ASSIGN3_ACTION      3034
#define IDS_ASSIGN4_ACTION      3035
#define IDS_SCRIPT_COPY_FAIL    3036
#define IDS_ADVERTISE           3037
#define IDS_ADVERTISE_FAIL      3038
#define IDS_INSTALL             3039
#define IDS_UNMANAGE_ORPHAN     3040
#define IDS_UNDO4_ACTION        3041
#define IDS_LOCAL_APP_COUNT     3042
#define IDS_UNINSTALL           3043
#define IDS_UNMANAGE_UNINSTALL  3044
#define IDS_UNADVERTISE         3045
#define IDS_UNADVERTISE_FAIL    3046
#define IDS_UNMANAGE            3047
#define IDS_INSTALL_STATUS2     3048
#define IDS_MACHINEAPPS         3049
#define IDS_INSTALL_APPNAME     3050
#define IDS_INSTALL_FILEEXT     3051
#define IDS_INSTALL_PROGID      3052
#define IDS_INSTALL_COMCLASS    3053
#define IDS_GETAPPINFO_FAIL     3054
#define IDS_INSTALL_STATUS1     3055
#define IDS_APPINFO_FAIL        3056
#define IDS_LOCALAPPINFO_FAIL   3057
#define IDS_LOCALAPP_COUNT      3058
#define IDS_REMOVEAPP           3059
#define IDS_REMOVEAPP_STATUS    3060
#define IDS_REMOVEAPP_MATCH1    3061
#define IDS_REMOVEAPP_MATCH2    3062
#define IDS_UNDO5_ACTION        3063
#define IDS_ORPHAN_ACTION1      3064
#define IDS_NO_CLASSSTORE       3065
#define IDS_UNDO1_ACTION        3066
#define IDS_UNDO2_ACTION        3067
#define IDS_IGNORE_REMOVE       3068
#define IDS_LOCAL_APP_DUMP      3069
#define IDS_INSTALL_ACTION2     3070
#define IDS_USERAPPS_CAT        3071
#define IDS_INSTALL_DARWIN      3072
#define IDS_INSTALL_SETUP       3073
#define IDS_INSTALL_UNKNOWN     3074
#define IDS_GPOAPPS             3075
#define IDS_ORPHAN_ACTION3      3076
#define IDS_UNINSTALL_ACTION2   3077
#define IDS_NONE_ACTION1        3078
#define IDS_ENFORCE_SECURE_FAIL 3079
#define IDS_REINSTALL_ACTION1   3080
#define IDS_REINSTALL           3081
#define IDS_INSTALL_TRANSFORM   3082
#define IDS_POLICY_REMOVED      3083
#define IDS_POLICY_APPLY        3084
#define IDS_CHECK_APP           3085
#define IDS_CHECK_APP_FAIL      3086
#define IDS_ORPHAN_ACTION4      3087
#define IDS_NONE_ACTION2        3088
#define IDS_UPGRADE_INFO        3089
#define IDS_UNDO6_ACTION        3090
#define IDS_UPGRADE_REVERSE     3091
#define IDS_LOCALORPHAN_APP     3092
#define IDS_LOCALUNINSTALL_APP  3093
#define IDS_DEMAND_BLOCK1       3094
#define IDS_DEMAND_BLOCK2       3095
#define IDS_PROGID_FOUND        3096
#define IDS_CLSID_INPROC_FOUND  3097
#define IDS_CLSID_LOCAL_FOUND   3098
#define IDS_ENFORCE_SECURE_ON   3099
#define IDS_REINSTALL_ACTION2   3100
#define IDS_UNDO3_ACTION        3101
#define IDS_ERRORREASON_CSPATH  3102
#define IDS_ERRORREASON_ENUM    3103
#define IDS_ERRORREASON_LOCAL   3104
#define IDS_ERRORREASON_PROCESS 3105
#define IDS_RSOP_LOG_INIT_FAIL  3106
#define IDS_RSOP_LOG_WRITE_FAIL 3108
#define IDS_RSOP_LOG_WRITE_INFO 3109
#define IDS_RSOP_LOG_CLEAR_FAIL 3110
#define IDS_RSOP_CAT_INFO       3111
#define IDS_RSOP_CAT_WRITE_FAIL 3112
#define IDS_RSOP_SETVAL_FAIL    3113
#define IDS_RSOP_CONFLICTS_FAIL 3114
#define IDS_RSOP_SUPERSEDED     3115
#define IDS_UNMATCHED_SCRIPT    3116
#define IDS_SCRIPTINRSOP        3117
#define IDS_SCRIPTNOTINRSOP1    3118
#define IDS_SCRIPTNOTINRSOP2    3119
#define IDS_SCRIPTAPP_INDS      3120
#define IDS_SCRIPTAPP_NODS      3121
#define IDS_SCRIPTAPP_ERRORDS   3122
#define IDS_DETECTED_LOST_APPS  3123
#define IDS_SCRIPTAPP_INDS2     3124
#define IDS_CSTORE_DELETESCRIPT 3200
#define IDS_CSTORE_CLEANSCRIPTS 3201
#define IDS_CSTORE_DELPACKAGE   3202
#define IDS_CSTORE_CSCACHEPURGE 3203
#define IDS_CSTORE_CSCACHE_HIT  3204
#define IDS_CSTORE_BIND_FAIL    3205
#define IDS_CSTORE_PKG_DETAILS  3206
#define IDS_CSTORE_ENUMPACKAGE  3207
#define IDS_CSTORE_BESTFIT      3208
#define IDS_CSTORE_BESTFITSKIP  3209
#define IDS_CSTORE_BESTFIT_END  3210
#define IDS_CSTORE_CLASS_PURGE  3211
#define IDS_CSTORE_CLASS_HIT    3212
#define IDS_CSTORE_MERGEAPPINFO 3213
#define IDS_CSTORE_ONDEMAND     3214
#define IDS_CSTORE_APPINFO_END  3215
#define IDS_CSTORE_BIND         3216
#define IDS_CSTORE_BIND_STATUS  3217
#define IDS_CSTORE_CLASSSPEC    3218
#define IDS_CSTORE_MISSING_ATTR 3219
#define IDS_CSTORE_SKIP_FLAG    3220
#define IDS_CSTORE_SKIP_FILTER  3221
#define IDS_CSTORE_SKIP_INCLUDE 3222
#define IDS_CSTORE_MACHINE      3223
#define IDS_CSTORE_IMPERSONATED 3224
#define IDS_CSTORE_USER         3225
#define IDS_CSTORE_STORE_COUNT  3226
#define IDS_CSTORE_ROLLBACK_ADD 3227
#define IDS_CSTORE_EXAMINING    3228
#define IDS_CSTORE_SKIP_LANG    3229
#define IDS_CSTORE_SKIP_ARCH    3230 
#define IDS_CSTORE_SKIP_CLSID   3231
#define IDS_CSTORE_SKIP_FILE    3232
#define IDS_CSTORE_SKIP_MSI     3233
#define IDS_CSTORE_RSOPERROR    3234
#define IDS_CSTORE_REMAP_ERR    3235
#define IDS_CSTORE_BETA3_ERR    3236
#define IDS_CSTORE_CACHE_EXPIRE 3237
#define IDS_ABORT_SCOPELOSS     3238
#define IDS_ASSIGN5_ACTION      3239
#define IDS_ASYNC_REFRESH       3240
#define IDS_BACKGROUND_REFRESH  3241
#define IDS_ABORT_OPERATION     3242
#define IDS_SYNC_REFRESH        3243
#define IDS_CHANGES_DETECTED    3244
#define IDS_CHANGES_RSOP_CHANGE 3245
#define IDS_REINSTALL_ACTION3   3246
#define IDS_ERRORREASON_ASYNC_USER       3247
#define IDS_ERRORREASON_ASYNC_MACHINE    3248
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\common\list.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  list.cxx
//
//*************************************************************

#include "common.hxx"

//
// CListItem
//

void
CListItem::Remove()
{
    _pPrev->_pNext = _pNext;
    _pNext->_pPrev = _pPrev;
}

void
CListItem::InsertBefore(
    IN  CListItem * pItem
    )
{
    pItem->_pPrev = _pPrev;
    pItem->_pNext = this;
    _pPrev->_pNext = pItem;
    _pPrev = pItem;
}

//
// CList
//

CList::CList() :
    _pCurrent(NULL),
    _pCurrentSave(NULL)
{
    _Head._pNext = &_Head;
    _Head._pPrev = &_Head;
}

//
// CList::InsertLIFO()
//
// Inserts the given item at the front of the list.  Last in first out semantics.
//
void
CList::InsertLIFO(
    IN  CListItem * pItem
    )
{
    pItem->_pNext = _Head._pNext;
    pItem->_pPrev = &_Head;
    _Head._pNext->_pPrev = pItem;
    _Head._pNext = pItem;
}

//
// CList::InsertFIFO()
//
// Inserts the given item at the end of the list.  First in first out semantics.
//
void
CList::InsertFIFO(
    IN  CListItem * pItem
    )
{
    pItem->_pNext = &_Head;
    pItem->_pPrev = _Head._pPrev;
    _Head._pPrev->_pNext = pItem;
    _Head._pPrev = pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\common\dbg.cxx ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "common.hxx"

HINSTANCE ghDllInstance = 0;

//
// Global Variable containing the debugging level.  The debug level can be
// modified by both the debug init routine and the event logging init
// routine.  Debugging can be enabled even on retail systems through
// registry settings.
//

DWORD   gDebugLevel = DL_NONE;
DWORD   gDebugBreak = 0;
WCHAR * gpwszLogFile = 0;

LOADSTRINGW *   pfnLoadStringW = 0;

//
// Debug strings
//

const WCHAR cwszAppMgmt[] = L"APPMGMT (%x.%x) %02d:%02d:%02d:%03d ";
const WCHAR cwszLogTime[] = L"%02d-%02d %02d:%02d:%02d:%03d ";
const WCHAR cwszLogfile[] = L"%SystemRoot%\\Debug\\UserMode\\appmgmt.log";
const WCHAR cwszOldLogfile[] = L"%SystemRoot%\\Debug\\UserMode\\appmgmt.bak";
const WCHAR cwszCRLF[] = L"\r\n";
const char cszCRLF[] = "\r\n";

//*************************************************************
//
//  InitDebugSupport()
//
//  Sets the debugging level.
//  Also checks the registry for a debugging level.
//
//*************************************************************
void InitDebugSupport( DWORD DebugMode )
{
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;
    BOOL    bVerbose;
    DWORD   Status;
    BOOL    bStatus;

#if DBG
    gDebugLevel = DL_NORMAL;
#else
    gDebugLevel = DL_NONE;
#endif

    gDebugBreak = 0;

    Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DIAGNOSTICS_KEY,
                    0,
                    KEY_READ,
                    &hKey );

    bVerbose = FALSE;

    if ( ERROR_SUCCESS == Status )
    {
        Size = sizeof(bVerbose);
        Status = RegQueryValueEx(
                        hKey,
                        DIAGNOSTICS_POLICY_VALUE,
                        NULL,
                        &Type,
                        (LPBYTE) &bVerbose,
                        &Size );

        if ( (ERROR_SUCCESS == Status) && (Type != REG_DWORD) )
            bVerbose = FALSE;

        Size = sizeof(gDebugLevel);
        RegQueryValueEx(
                hKey,
                DEBUG_KEY_NAME,
                NULL,
                NULL,
                (LPBYTE) &gDebugLevel,
                &Size );

        Size = sizeof(gDebugBreak);
        RegQueryValueEx(
                hKey,
                DEBUGBREAK_KEY_NAME,
                NULL,
                NULL,
                (LPBYTE) &gDebugBreak,
                &Size );

        RegCloseKey(hKey);
    }

    if ( bVerbose )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    if ( gDebugLevel & DL_LOGFILE )
    {
        WCHAR   wszLogFile[MAX_PATH];
        WIN32_FILE_ATTRIBUTE_DATA   FileData;

        Status = ExpandEnvironmentStrings( cwszLogfile, wszLogFile, MAX_PATH );

        if ( (0 == Status) || (Status > MAX_PATH) )
            return;

        Size = lstrlen(wszLogFile) + 1;
        delete gpwszLogFile;
        gpwszLogFile = new WCHAR[Size];
        if ( gpwszLogFile )
            memcpy( gpwszLogFile, wszLogFile, Size * sizeof(WCHAR) );
        else
            return;

        if ( DebugMode != DEBUGMODE_POLICY )
            return;

        bStatus = GetFileAttributesEx( gpwszLogFile, GetFileExInfoStandard, &FileData );
        if ( ! bStatus )
            return;

        //
        // If the existing log file is more than 50K then we will rename it to a backup
        // copy to prevent huge bloating, otherwise we continue to use it.
        //
        if ( FileData.nFileSizeLow < (50 * 1024) )
            return;

        Status = ExpandEnvironmentStrings( cwszOldLogfile, wszLogFile, sizeof(wszLogFile) / sizeof(WCHAR) );

        if ( (0 == Status) || (Status > MAX_PATH) )
            return;

        DeleteFile( wszLogFile );
        MoveFile( gpwszLogFile, wszLogFile );
    }
}

BOOL DebugLevelOn( DWORD mask )
{
    BOOL bOutput = FALSE;

    if ( gDebugLevel & DL_VERBOSE )
        bOutput = TRUE;
    else if ( gDebugLevel & DL_NORMAL )
        bOutput = ! (mask & DM_VERBOSE);
#if DBG
    else // DL_NONE
        bOutput = (mask & DM_ASSERT);
#endif

    return bOutput;
}

//*************************************************************
//
//  _DebugMsg()
//
//  Displays debug messages based on the debug level
//  and type of debug message.
//
//  Parameters :
//      mask    -   debug message type
//      MsgID   -   debug message id from resource file
//      ...     -   variable number of parameters
//
//*************************************************************
void _DebugMsg(DWORD mask, DWORD MsgID, ...)
{
    if ( ! DebugLevelOn( mask ) )
        return;

    BOOL bEventLogOK;
    WCHAR wszDebugTitle[64];
    WCHAR wszDebugBuffer[2048]; // Hopefully this will be big enough!
    WCHAR wszMsg[MAX_PATH];
    va_list VAList;
    SYSTEMTIME systime;

    bEventLogOK = ! (mask & DM_NO_EVENTLOG);

    if ( ! LoadLoadString() )
        return;

    va_start(VAList, MsgID);

    if ( ! ghDllInstance )
        ghDllInstance = LoadLibrary( L"appmgmts.dll" );

    //
    // Event log message ids are in the 100s to 400s, verbose strings are in the
    // 1000s to 3000s.  For event log messages we must call FormatMessage.  For
    // other verbose debug output, we use LoadString to get the string resource.
    //
    if ( MsgID >= 1000 )
    {
        if ( ! (*pfnLoadStringW)( ghDllInstance, MsgID, wszMsg, MAX_PATH) )
            return;
        _vsnwprintf(wszDebugBuffer, sizeof(wszDebugBuffer)/sizeof(wszDebugBuffer[0]), wszMsg, VAList);
    }
    else
    {
        DWORD   CharsWritten;

        CharsWritten = FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    ghDllInstance,
                    MsgID,
                    0,
                    wszDebugBuffer,
                    sizeof(wszDebugBuffer) / sizeof(WCHAR),
                    &VAList );

        if ( 0 == CharsWritten )
            return;
    }

    va_end(VAList);

    GetLocalTime( &systime );
    swprintf( wszDebugTitle,
              cwszAppMgmt,
              GetCurrentProcessId(),
              GetCurrentThreadId(),
              systime.wHour,
              systime.wMinute,
              systime.wSecond,
              systime.wMilliseconds);

    if ( ! (gDebugLevel & DL_NODBGOUT) )
    {
        OutputDebugString( wszDebugTitle );
        OutputDebugString( wszDebugBuffer );
        OutputDebugString( cwszCRLF );
    }

    if ( (gDebugLevel & DL_LOGFILE) && gpwszLogFile )
    {
        HANDLE hFile;

        hFile = CreateFile(gpwszLogFile,
                           FILE_WRITE_DATA | FILE_APPEND_DATA,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( hFile != INVALID_HANDLE_VALUE )
        {
            if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
            {
                DWORD   Size;

                WriteFile(
                        hFile,
                        (LPCVOID) wszDebugBuffer,
                        lstrlen(wszDebugBuffer) * sizeof(WCHAR),
                        &Size,
                        NULL );

                WriteFile(
                        hFile,
                        (LPCVOID) cwszCRLF,
                        lstrlen(cwszCRLF) * sizeof(WCHAR),
                        &Size,
                        NULL );
            }

            CloseHandle (hFile);
        }

    }

    if ( bEventLogOK && (gDebugLevel & DL_EVENTLOG) )
        ((CEventsBase *)gpEvents)->Report( EVENT_APPMGMT_VERBOSE, FALSE, 1, wszDebugBuffer );

#if DBG
    if ( mask & DM_ASSERT )
        DebugBreak();
#endif
}

void LogTime()
{
    if ( ! (gDebugLevel & DL_LOGFILE) || ! gpwszLogFile )
        return;

    WCHAR wszDebugBuffer[64];
    SYSTEMTIME systime;
    HANDLE hFile;

    GetLocalTime( &systime );
    swprintf( wszDebugBuffer,
              cwszLogTime,
              systime.wMonth,
              systime.wDay,
              systime.wHour,
              systime.wMinute,
              systime.wSecond,
              systime.wMilliseconds);

    hFile = CreateFile(gpwszLogFile,
                       FILE_WRITE_DATA | FILE_APPEND_DATA,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
        return;

    if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
    {
        DWORD   Size;

        WriteFile(
                hFile,
                (LPCVOID) wszDebugBuffer,
                lstrlen(wszDebugBuffer) * sizeof(WCHAR),
                &Size,
                NULL );

        WriteFile(
                hFile,
                (LPCVOID) cwszCRLF,
                lstrlen(cwszCRLF) * sizeof(WCHAR),
                &Size,
                NULL );
    }

    CloseHandle (hFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\common\cutil.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  util.cxx
//
//*************************************************************

#include "common.hxx"

MSGWAITFORMULTIPLEOBJECTS *     pfnMsgWaitForMultipleObjects = 0;
PEEKMESSAGEW *      pfnPeekMessageW = 0;
TRANSLATEMESSAGE *  pfnTranslateMessage = 0;
DISPATCHMESSAGEW *  pfnDispatchMessageW = 0;
GETPROCESSWINDOWSTATION *   pfnGetProcessWindowStation = 0;
CLOSEWINDOWSTATION *        pfnCloseWindowStation = 0;
GETUSEROBJECTINFORMATIONW * pfnGetUserObjectInformationW = 0;

MSISETINTERNALUI * gpfnMsiSetInternalUI = 0;
MSICONFIGUREPRODUCTEXW * gpfnMsiConfigureProductEx = 0;
MSIPROVIDECOMPONENTFROMDESCRIPTORW * gpfnMsiProvideComponentFromDescriptor = 0;
MSIDECOMPOSEDESCRIPTORW * gpfnMsiDecomposeDescriptor = 0;
MSIGETPRODUCTINFOW * gpfnMsiGetProductInfo = 0;
MSIADVERTISESCRIPTW * gpfnMsiAdvertiseScript = 0;
MSIQUERYPRODUCTSTATEW * gpfnMsiQueryProductState = 0;
MSIISPRODUCTELEVATEDW * gpfnMsiIsProductElevated = 0;
MSIREINSTALLPRODUCTW * gpfnMsiReinstallProduct = 0;

void
FreeApplicationInfo(
    APPLICATION_INFO * ApplicationInfo
    )
{
    if ( ! ApplicationInfo )
        return;

    LocalFree( ApplicationInfo->pwszDeploymentId );
    LocalFree( ApplicationInfo->pwszDeploymentName );
    LocalFree( ApplicationInfo->pwszGPOName );
    LocalFree( ApplicationInfo->pwszProductCode );
    LocalFree( ApplicationInfo->pwszDescriptor );
    LocalFree( ApplicationInfo->pwszSetupCommand );
}

PSID
AppmgmtGetUserSid(
    HANDLE  hUserToken // = 0
    )
{
    PSID        pSid;
    HANDLE      hToken;
    PTOKEN_USER pTokenUserData;
    UCHAR       Buffer[sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG))];
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    if ( ! hUserToken )
    {
        bStatus = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

        if ( ! bStatus )
            bStatus = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );

        if ( ! bStatus )
            return NULL;
    }
    else
    {
        hToken = hUserToken;
    }

    Size = sizeof(Buffer);
    pTokenUserData = (PTOKEN_USER) Buffer;

    bStatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    pTokenUserData,
                    Size,
                    &Size );

    if ( ! hUserToken )
        CloseHandle( hToken );

    if ( ! bStatus )
        return NULL;

    Size = GetLengthSid( pTokenUserData->User.Sid );

    pSid = (PSID) LocalAlloc( 0, Size );

    if ( pSid )
    {
        bStatus = CopySid( Size, pSid, pTokenUserData->User.Sid );

        if ( ! bStatus )
        {
            LocalFree( pSid );
            pSid = NULL;
        }
    }

    return pSid;
}

void
DwordToString(
    DWORD   Number,
    WCHAR * wszNumber
    )
{
    WCHAR * pwszString;
    WCHAR   c;
    DWORD   Length;
    DWORD   n;

    pwszString = wszNumber;
    Length = 0;

    do
    {
        *pwszString++ = (WCHAR) (L'0' + Number % 10);
        Number /= 10;
        Length++;
    } while ( Number );

    *pwszString = 0;

    for ( n = 0; n < Length / 2; n++ )
    {
        c = wszNumber[n];
        wszNumber[n] = wszNumber[Length-n-1];
        wszNumber[Length-n-1] = c;
    }
}

BOOL
LoadUser32Funcs()
{
    HINSTANCE hUser32 = 0;

    if ( pfnMsgWaitForMultipleObjects && pfnPeekMessageW && pfnTranslateMessage && pfnDispatchMessageW &&
         pfnGetProcessWindowStation && pfnCloseWindowStation && pfnGetUserObjectInformationW )
        return TRUE;

    hUser32 = LoadLibrary( L"user32.dll" );

    if ( ! hUser32 )
        return FALSE;

    pfnMsgWaitForMultipleObjects = (MSGWAITFORMULTIPLEOBJECTS *) GetProcAddress( hUser32, "MsgWaitForMultipleObjects" );
    pfnPeekMessageW = (PEEKMESSAGEW *) GetProcAddress( hUser32, "PeekMessageW" );
    pfnTranslateMessage = (TRANSLATEMESSAGE *) GetProcAddress( hUser32, "TranslateMessage" );
    pfnDispatchMessageW = (DISPATCHMESSAGEW *) GetProcAddress( hUser32, "DispatchMessageW" );
    pfnGetProcessWindowStation = (GETPROCESSWINDOWSTATION *) GetProcAddress( hUser32, "GetProcessWindowStation" );
    pfnCloseWindowStation = (CLOSEWINDOWSTATION *) GetProcAddress( hUser32, "CloseWindowStation" );
    pfnGetUserObjectInformationW = (GETUSEROBJECTINFORMATIONW *) GetProcAddress( hUser32, "GetUserObjectInformationW" );

    if ( ! pfnMsgWaitForMultipleObjects || ! pfnPeekMessageW || ! pfnTranslateMessage || ! pfnDispatchMessageW ||
         ! pfnGetProcessWindowStation || ! pfnCloseWindowStation || ! pfnGetUserObjectInformationW )
    {
        FreeLibrary( hUser32 );
        return FALSE;
    }

    // user32 remains loaded

    return TRUE;
}

BOOL
LoadLoadString()
{
    HINSTANCE hUser32 = 0;

    if ( pfnLoadStringW )
        return TRUE;

    hUser32 = LoadLibrary( L"user32.dll" );

    if ( ! hUser32 )
        return FALSE;

    pfnLoadStringW = (LOADSTRINGW *) GetProcAddress( hUser32, "LoadStringW" );

    if ( ! pfnLoadStringW )

    {
        FreeLibrary( hUser32 );
        return FALSE;
    }

    // user32 remains loaded

    return TRUE;
}

void
GuidToString(
    GUID &  Guid,
    PWCHAR  pwszGuid
    )
{
    *pwszGuid = 0;

    swprintf(
        pwszGuid,
        L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0],
        Guid.Data4[1],
        Guid.Data4[2],
        Guid.Data4[3],
        Guid.Data4[4],
        Guid.Data4[5],
        Guid.Data4[6],
        Guid.Data4[7]
        );
}

void
GuidToString(
    GUID &  Guid,
    PWCHAR *ppwszGuid
    )
{
    *ppwszGuid = new WCHAR[40];
    if ( *ppwszGuid )
        GuidToString( Guid, *ppwszGuid );
}

void
StringToGuid(
    PWCHAR pwszGuid,
    GUID * pGuid
    )
{
    UNICODE_STRING  String;
    DWORD           Data;

    // mimicking scanf of L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"

    String.Buffer = pwszGuid + 1;

    String.Length = String.MaximumLength = 16;
    RtlUnicodeStringToInteger( &String, 16, &pGuid->Data1 );
    String.Buffer += 9;

    String.Length = String.MaximumLength = 8;
    RtlUnicodeStringToInteger( &String, 16, &Data );
    pGuid->Data2 = (USHORT) Data;
    String.Buffer += 5;
    RtlUnicodeStringToInteger( &String, 16, &Data );
    pGuid->Data3 = (USHORT) Data;
    String.Buffer += 5;

    String.Length = String.MaximumLength = 4;

    for ( DWORD n = 0; n <= 7; n++ )
    {
        RtlUnicodeStringToInteger( &String, 16, &Data );
        pGuid->Data4[n] = (UCHAR) Data;
        String.Buffer += 2;

        if ( 1 == n )
            String.Buffer++;
    }
}

HRESULT
CreateGuid(GUID *pGuid)
{
    int err;

    // We simply use the RPC system supplied API
    if ((err = UuidCreate(pGuid)) != RPC_S_UUID_LOCAL_ONLY)
    {
        return err ? HRESULT_FROM_WIN32(err) : S_OK;
    }

    return S_OK;
}

DWORD
ReadStringValue(
    HKEY        hKey,
    WCHAR *     pwszValueName,
    WCHAR **    ppwszValue
    )
{
    DWORD   Status;
    DWORD   Size;

    *ppwszValue = 0;

    Size = 0;

    Status = RegQueryValueEx(
                hKey,
                pwszValueName,
                0,
                NULL,
                (LPBYTE) *ppwszValue,
                &Size );

    //
    // Does not return ERROR_MORE_DATA when buffer is NULL.
    //
    if ( Status != ERROR_SUCCESS )
        return Status;

    *ppwszValue = new WCHAR[Size / 2];
    if ( ! *ppwszValue )
        return ERROR_OUTOFMEMORY;

    Status = RegQueryValueEx(
                hKey,
                pwszValueName,
                0,
                NULL,
                (LPBYTE) *ppwszValue,
                &Size );

    if ( Status != ERROR_SUCCESS )
    {
        delete *ppwszValue;
        *ppwszValue = 0;
    }

    return Status;
}

DWORD
GetSidString(
    HANDLE          hToken,
    UNICODE_STRING* pSidString
    )
{
    LONG         Status;
    BOOL         bStatus;
    DWORD        Size;
    UCHAR        Buffer[sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG))];
    PTOKEN_USER  pTokenUser;

    Status = ERROR_SUCCESS;

    Size = sizeof(Buffer);

    pTokenUser = (PTOKEN_USER) Buffer;

    bStatus = GetTokenInformation(
        hToken,
        TokenUser,
        pTokenUser,
        Size,
        &Size );

    if ( ! bStatus )
        Status = GetLastError();
    
    if ( ERROR_SUCCESS == Status )
    {
        Status = RtlConvertSidToUnicodeString(
            pSidString,
            pTokenUser->User.Sid,
            TRUE );

        if ( ! NT_SUCCESS( Status ) )
        {
            Status = RtlNtStatusToDosError( Status );
        }
    }

    return Status;
}

CLoadMsi::CLoadMsi( DWORD &Status )
{
    hMsi = LoadLibrary( L"msi.dll" );

    if ( ! hMsi )
    {
        Status = GetLastError();
        return;
    }

    gpfnMsiSetInternalUI = (MSISETINTERNALUI *) GetProcAddress( hMsi, "MsiSetInternalUI" );
    gpfnMsiConfigureProductEx = (MSICONFIGUREPRODUCTEXW *) GetProcAddress( hMsi, "MsiConfigureProductExW" );
    gpfnMsiProvideComponentFromDescriptor = (MSIPROVIDECOMPONENTFROMDESCRIPTORW *) GetProcAddress( hMsi, "MsiProvideComponentFromDescriptorW" );
    gpfnMsiDecomposeDescriptor = (MSIDECOMPOSEDESCRIPTORW *) GetProcAddress( hMsi, "MsiDecomposeDescriptorW" );
    gpfnMsiGetProductInfo = (MSIGETPRODUCTINFOW *) GetProcAddress( hMsi, "MsiGetProductInfoW" );
    gpfnMsiAdvertiseScript = (MSIADVERTISESCRIPTW *) GetProcAddress( hMsi, "MsiAdvertiseScriptW" );
    gpfnMsiQueryProductState = (MSIQUERYPRODUCTSTATEW *) GetProcAddress( hMsi, "MsiQueryProductStateW" );
    gpfnMsiIsProductElevated = (MSIISPRODUCTELEVATEDW *) GetProcAddress( hMsi, "MsiIsProductElevatedW" );
    gpfnMsiReinstallProduct = (MSIREINSTALLPRODUCTW *) GetProcAddress( hMsi, "MsiReinstallProductW" );

    if ( ! gpfnMsiSetInternalUI ||
         ! gpfnMsiConfigureProductEx ||
         ! gpfnMsiProvideComponentFromDescriptor ||
         ! gpfnMsiDecomposeDescriptor ||
         ! gpfnMsiAdvertiseScript ||
         ! gpfnMsiQueryProductState ||
         ! gpfnMsiIsProductElevated ||
         ! gpfnMsiReinstallProduct )
    {
        Status = ERROR_PROC_NOT_FOUND;
        return;
    }

    Status = ERROR_SUCCESS;
}

CLoadMsi::~CLoadMsi()
{
    if ( hMsi )
        FreeLibrary( hMsi );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\appcont.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Author: DebiM
//  Date:   January 97
//  Revision History:
//          Made Changes for reimplementation with adsldpc interfaces.
//          UShaji, Mar 1998
//
//      Class Access Implementation
//
//      This source file contains implementations for IClassAccess
//      interface on CAppContainer object.
//
//      It uses ADs interfaces (over LDAP) to talk to an LDAP
//      provider such as NTDS.
//
//---------------------------------------------------------------------
//

#include "cstore.hxx"

CBindingList BindingCache;

//
// Critical Section for All Global Objects.
//
extern CRITICAL_SECTION ClassStoreBindList;


HRESULT
UsnGet(ADS_ATTR_INFO Attr, CSUSN *pUsn);

long CompareUsn(CSUSN *pUsn1, CSUSN *pUsn2)
{
    return CompareFileTime((FILETIME *)pUsn1, (FILETIME *)pUsn2);
}

void GetExpiredTime( FILETIME* pftCurrentTime, FILETIME* pftExpiredTime )
{
    //
    // Add the cache interval time to determine
    // the time this will expire
    //
    LARGE_INTEGER liTime;

    //
    // First copy the filetime to a large integer so
    // we can perform arithmetic
    //
    liTime.LowPart = pftCurrentTime->dwLowDateTime;
    liTime.HighPart = pftCurrentTime->dwHighDateTime;

    //
    // The compiler can perform 64 bit math -- use this
    // to perform the arithmetic for calculating the
    // time at which cache entries will expire
    //
    liTime.QuadPart += CACHE_PURGE_TIME_FILETIME_INTERVAL;

    //
    // Now copy the information back to the caller's structure
    //
    pftExpiredTime->dwLowDateTime = liTime.LowPart;
    pftExpiredTime->dwHighDateTime = liTime.HighPart;
}

BOOL IsExpired(
    FILETIME* pftCurrentTime,
    FILETIME* pftExpiredTime)
{
 
    SYSTEMTIME SystemTimeCurrent;
    SYSTEMTIME SystemTimeExpiration;;
    BOOL       bRetrievedTime;

    bRetrievedTime = FileTimeToSystemTime(
        pftCurrentTime,
        &SystemTimeCurrent);

    bRetrievedTime &= FileTimeToSystemTime(
        pftExpiredTime,
        &SystemTimeExpiration);

    if ( bRetrievedTime )
    {
        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Current Time",
            SystemTimeCurrent.wMonth,
            SystemTimeCurrent.wDay,
            SystemTimeCurrent.wYear,
            SystemTimeCurrent.wHour,
            SystemTimeCurrent.wMinute,
            SystemTimeCurrent.wSecond));

        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Expire Time",
            SystemTimeExpiration.wMonth,
            SystemTimeExpiration.wDay,
            SystemTimeExpiration.wYear,
            SystemTimeExpiration.wHour,
            SystemTimeExpiration.wMinute,
            SystemTimeExpiration.wSecond));
    }

    //
    // Compare the current time to the expiration time
    //
    LONG CompareResult;

    CompareResult = CompareFileTime(
        pftCurrentTime,
        pftExpiredTime);
        
    //
    // If the current time is later than the expired time,
    // then we have expired
    //
    if ( CompareResult > 0 )
    {
        return TRUE;
    }

    return FALSE;
}

//
// CAppContainer implementation
//
CAppContainer::CAppContainer()

{
    m_fOpen = FALSE;

    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;

    m_szPackageName = NULL;

    memset (&m_PolicyId, 0, sizeof(GUID));

    m_KnownMissingClsidCache.sz = 0;
    m_KnownMissingClsidCache.start = 0;
    m_KnownMissingClsidCache.end = 0;

    m_uRefs = 1;

    m_szGpoPath = NULL;

    m_pRsopToken = NULL;
}


//
// CAppContainer implementation
//

/*----------------------------------------------------------------------*
CAppContainer Constructor:

  Parameters:
  [in]  szStoreName:    The Class Store Name without 'ADCS:' moniker
  [out] phr             The Error Code returned.

    Remarks: Tries to Bind to Base Class Store Container, get the version
    Number and Packages and Classes container underneath.

      Initializes members corresp. to their Names

        Return Codes:
        Success     S_OK
        Failures    CS_E_INVALID_VERSION
        Look at RemapErrorCodes

*----------------------------------------------------------------------*/
CAppContainer::CAppContainer(LPOLESTR   szStoreName,
                             PRSOPTOKEN pRsopToken,
                             HRESULT    *phr)

{
    LPOLESTR            pszName = NULL;
    DWORD               dwStoreVersion = 0;
    LPOLESTR            AttrNames[] = {STOREVERSION, POLICYDN};
    DWORD               posn = 0, cgot = 0;
    ADS_SEARCHPREF_INFO SearchPrefs[3];
    ADS_ATTR_INFO     * pAttrsGot = NULL;

    m_szGpoPath = NULL;

    m_pRsopToken = pRsopToken;

    *phr = S_OK;

    // set the search preference for the search Handle

    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;

    SearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SECURITY_MASK;
    SearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;

    SearchPrefs[2].vValue.Integer =
            OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;

    memset (&m_PolicyId, 0, sizeof(GUID));

    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szPackageName = NULL;

    memset (&m_PolicyId, 0, sizeof(GUID));

    m_KnownMissingClsidCache.sz = 0;
    m_KnownMissingClsidCache.start = 0;
    m_KnownMissingClsidCache.end = 0;

    m_uRefs = 1;
    //
    // For every interface pointer, we create a separate session
    //


    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);

    *phr = ADSIOpenDSObject(m_szContainerName, NULL, NULL, GetDsFlags(),
        &m_ADsContainer);

    ERROR_ON_FAILURE(*phr);
    //
    // Check the Schema Version of this container
    //

    *phr = ADSIGetObjectAttributes(m_ADsContainer, AttrNames, 2, &pAttrsGot, &cgot);

    if ((SUCCEEDED(*phr)) && (cgot))
    {

        posn = GetPropertyFromAttr(pAttrsGot, cgot, STOREVERSION);
        dwStoreVersion = 0;
        if (posn < cgot)
        {
            UnpackDWFrom(pAttrsGot[posn], &dwStoreVersion);
        }

        if (dwStoreVersion != SCHEMA_VERSION_NUMBER)
        {
            *phr = CS_E_INVALID_VERSION;
        }


        if (SUCCEEDED(*phr))
        {
            LPOLESTR        szPolicyPath = NULL;

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYDN);
            if (posn < cgot)
            {
                LPOLESTR        szParentPath = NULL, szPolicyGuid = NULL;

                UnpackStrFrom(pAttrsGot[posn], &szPolicyPath);
                //

                BuildADsParentPath(szPolicyPath, &szParentPath, &szPolicyGuid);
                if (szParentPath)
                    FreeADsMem(szParentPath);

                if (szPolicyGuid)
                {
                    if (wcslen(szPolicyGuid) == 41)
                    {
                        // valid GUID

                        GUIDFromString(&szPolicyGuid[4], &m_PolicyId);
                    }
                    FreeADsMem(szPolicyGuid);
                }
            }
        }
    }
    else
    {
        if (SUCCEEDED(*phr))
        {
            *phr = CS_E_INVALID_VERSION;
        }
    }

    if (pAttrsGot)
        FreeADsMem(pAttrsGot);

    ERROR_ON_FAILURE(*phr);

    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //

    BuildADsPathFromParent(m_szContainerName, PACKAGECONTAINERNAME, &m_szPackageName);

    m_ADsPackageContainer = NULL;


    *phr = ADSIOpenDSObject(m_szPackageName, NULL, NULL, GetDsFlags(),
        &m_ADsPackageContainer);

    ERROR_ON_FAILURE(*phr);

    *phr = ADSISetSearchPreference(m_ADsPackageContainer, SearchPrefs, 3);
    ERROR_ON_FAILURE(*phr);

    m_fOpen = TRUE;

    m_uRefs = 1;

    m_szGpoPath = AllocGpoPathFromClassStorePath( m_szContainerName );

    if ( ! m_szGpoPath )
    {
        *phr = E_OUTOFMEMORY;
    }

Error_Cleanup:
    *phr = RemapErrorCode(*phr, m_szContainerName);
    return;
}


/*----------------------------------------------------------------------*
CAppContainer Destructor:


    Parameters:
      None

    Function:
      Destroys CAppContainer object.

    Remarks:
     Frees all the members.
     Return Codes
*----------------------------------------------------------------------*/


CAppContainer::~CAppContainer(void)
{
    UINT i;

    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }

    if (m_ADsPackageContainer)
    {
        ADSICloseDSObject(m_ADsPackageContainer);
        m_ADsPackageContainer = NULL;
        FreeADsMem(m_szPackageName);
    }

    if (m_ADsContainer)
    {
        ADSICloseDSObject(m_ADsContainer);
        m_ADsContainer = NULL;
    }

    if (m_szGpoPath)
    {
        CsMemFree(m_szGpoPath);
    }
}


//
// Constructor for App Container Class factory
//
unsigned long gulcappcon = 0;

CAppContainerCF::CAppContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcappcon );
}

//
// Destructor
//
CAppContainerCF::~CAppContainerCF()
{
    //
    // Cleanup the cache
    //
    InterlockedDecrement((long *) &gulcappcon );
}

HRESULT  __stdcall  CAppContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else  if( IsEqualIID( IID_IParseDisplayName, riid ) )
    {
        pUnkTemp = (IUnknown *)(IParseDisplayName *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
        {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//
// IClassFactory Overide
//
HRESULT  __stdcall  CAppContainerCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid,
                                                                    void  ** ppvObject)
{
    CAppContainer *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CAppContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
             pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//---------------------------------------------------------------
//
//  Function:   CreateConnectedInstance
//
//  Synopsis:   Returns IClassAccess Pointer, given a class store
//              path.
//
//  Arguments:
//  [in]
//      pszPath Class Store Path without the leading ADCS:
//
//      pUserSid
//              Sid under which the calling thread is running.
//      fCache
//              Boolean that decides whether to use a cached pointer or
//              not.
//  [out]
//      ppvObject
//              IClassAccess Interface pointer
//
//  Returns:
//      S_OK, E_NOINTERFACE, E_OUTOFMEMORY, CS_E_XXX
//
//  if (fCache)
//      Looks in the cache to see if we have already tried to bind to the same
//      ClassStore Path under the same SID. If it finds it, then we just QI for
//      IClassAccess and return. o/w create a new class store pointer and caches it.
//  else
//      Just binds to a new ClassStore and returns.
//----------------------------------------------------------------
HRESULT  __stdcall
CAppContainerCF::CreateConnectedInstance(
    LPOLESTR   pszPath, 
    PSID       pUserSid,
    PRSOPTOKEN pRsopToken,
    BOOL       fCache,
    void **    ppvObject)
{
    CAppContainer   *   pIUnk = NULL;
    SCODE               sc = S_OK;
    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;
    FILETIME            ftCurrentTime;
    IClassAccess*       pNewClassAccess = NULL;

    CBinding*           pBinding;

    //
    // See if we have an existing connection in the cache
    //
    if (fCache)
    {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        
        BindingCache.Lock();

        pBinding = BindingCache.Find(
            &ftCurrentTime,
            pszPath,
            pUserSid);

        if ( pBinding ) 
        {
            if ( FAILED( pBinding->Hr ) )
            {
                sc = pBinding->Hr;
            }
            else
            {
                sc = pBinding->pIClassAccess->
                    QueryInterface( IID_IClassAccess, ppvObject );
            }
        }

        BindingCache.Unlock();
    }

    if ( fCache && pBinding )
    {
        return sc;
    }

    //
    // Couldn't find anything in the cache -- we will have to create a new connection
    //

    //
    // If this is called in the context of policy, ipsec policy may not be enabled.
    // Therefore, our communications with the directory would not be secure.
    // We will pass TRUE for the secure channel argument of the CAppContainer
    // constructor since this code path is exercised during policy and we
    // want to ensure security.
    //

    //
    // Note that this object has a refcount of 1 when created
    //
    if ((pIUnk = new CAppContainer(pszPath, pRsopToken, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAccess, (LPVOID*) &pNewClassAccess );
        }
        else
        {
            CSDBGPrint((DM_WARNING, 
                      IDS_CSTORE_BIND_FAIL,
                      pszPath,
                      sc));
        }

        pIUnk->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    //
    // Store the result in the cache -- create a binding
    // descriptor so we can cache it
    //
    CBinding* pNewBinding;

    if (fCache)
    {
        //
        // Should not cache situations out of network failures
        // For now we are only caching successes OR CS does not exist cases
        //
        if ((sc == S_OK) || (sc == CS_E_OBJECT_NOTFOUND))
        {
            HRESULT   hrBinding;

            hrBinding = E_OUTOFMEMORY;

            pNewBinding = new CBinding(
                pszPath,
                pUserSid,
                pNewClassAccess,
                sc,
                &hrBinding);

            if ( FAILED( hrBinding ) )
            {
                sc = hrBinding;
                fCache = FALSE;
            }
        }
        else
        {
            fCache = FALSE;
        }
    }

    //
    // We have the binding descriptor, now cache it
    //
    if ( fCache )
    {
        CBinding* pBindingAdded;            

        BindingCache.Lock();

        //
        // Attempt to add the binding -- if one already
        // exists, it will destroy the one we pass in and
        // use the existing binding
        //
        pBindingAdded = BindingCache.AddBinding(
            &ftCurrentTime,
            pNewBinding);

        sc = pBindingAdded->Hr;
                
        if ( SUCCEEDED(sc) )
        {
            sc = pBindingAdded->pIClassAccess->
                QueryInterface( IID_IClassAccess, ppvObject );
        }

        BindingCache.Unlock();
    }
    else
    {
        if ( SUCCEEDED(sc) )
        {
            pNewClassAccess->AddRef();
            *ppvObject = pNewClassAccess;
        }
    }

    if ( pNewClassAccess )
    {
        pNewClassAccess->Release();
    }

    return (sc);
}


HRESULT  __stdcall  CAppContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcappcon ); }
    else
    { InterlockedDecrement((long *) &gulcappcon ); }
    return(S_OK);
}

//
// IUnknown methods for CAppContainer
//
//

HRESULT  __stdcall  CAppContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
     else  if( IsEqualIID( IID_IClassAccess, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    /*
    else  if( IsEqualIID( IID_IClassRefresh, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassRefresh *)this;
    }
    else  if( IsEqualIID( IID_ICatInformation, riid ) )
    {
        pUnkTemp = (IUnknown *)(ICatInformation *)this;
    }
    */
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CAppContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CAppContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


/*----------------------------------------------------------------------*
GetPackageDetails:

  Parameters:
  [in]  pszPackageName:    The Package Name
  [out] pPackageDetail     Package Detail Structure.

    Functionality:
    Returns the PackageDetail corresp. to a Package given
    by pszPackageName.

      Remarks:
      It constructs the Full Package Name
      and calls GetPackageDetail

        Return Codes:
        Success     S_OK
        Failures    Look at RemapErrorCodes

*----------------------------------------------------------------------*/

// This is not being called currently by anybody and hence is still using PackageId.
HRESULT CAppContainer::GetPackageDetails (
                                          LPOLESTR         pszPackageId,
                                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL, szRDN[_MAX_PATH];
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot;

    if ((!pszPackageId))
        return E_INVALIDARG;

    swprintf(szRDN, L"CN=%s", pszPackageId);
    
    CSDBGPrint((DM_WARNING, 
              IDS_CSTORE_PKG_DETAILS,
              szRDN));

    BuildADsPathFromParent(m_szPackageName, szRDN, &szFullName);

    //
    // We do not enforce packet integrity options here because
    // this is only called in the context of the admin tool and we
    // can rely on ipsec to have executed at that point
    //

    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);

    hr = GetPackageDetail (hADs, NULL, pPackageDetail);

    ADSICloseDSObject(hADs);

    if (pAttr)
        FreeADsMem(pAttr);

    if (szFullName)
        FreeADsMem(szFullName);

Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


/*----------------------------------------------------------------------*
EnumPackages

  Parameters:
  [in] pszPackageName     Substring match for a package name
  [in] pCategory          Package Category.
  [in] pLastUsn           Last modification time.
  [in] dwAppFlags         Set the following bits to select specific ones
  Published Only  APPINFO_PUBLISHED
  Assigned Only   APPINFO_ASSIGNED
  Msi Only        APPINFO_MSI
  Visible         APPINFO_VISIBLE
  Auto-Install    APPINFO_AUTOINSTALL

    All Locale      APPINFO_ALLLOCALE
    All Platform    APPINFO_ALLPLATFORM

      [out] ppIEnumPackage   Returns the Enumerator

        Functionality
        Obtains an enumerator for packages in the app container.

          Remarks:

*----------------------------------------------------------------------*/

HRESULT CAppContainer::EnumPackages (
                                     LPOLESTR        pszPackageName,
                                     GUID            *pCategory,
                                     ULONGLONG       *pLastUsn,
                                     DWORD           dwQuerySpec,      // AppType options
                                     IEnumPackage    **ppIEnumPackage
                                     )
{
    HRESULT                 hr = S_OK;
    CEnumPackage           *pEnum = NULL;
    WCHAR                   szLdapFilter[1000];
    WCHAR                   szLdapFilterFinal[1500];
    UINT                    len = 0;
    UINT                    fFilters = 0;
    CSPLATFORM              *pPlatform = NULL, Platform;
    DWORD                   dwAppFlags;

    //
    // Validate
    //

    switch ( dwQuerySpec )
    {
    case APPQUERY_ALL:
    case APPQUERY_ADMINISTRATIVE:
    case APPQUERY_POLICY:
    case APPQUERY_USERDISPLAY:
    case APPQUERY_RSOP_LOGGING:
    case APPQUERY_RSOP_ARP:
        break;
    default:
        return E_INVALIDARG;
    }

    *ppIEnumPackage = NULL;

    pEnum = new CEnumPackage(m_PolicyId, NULL, m_szContainerName, m_pRsopToken );
    if(NULL == pEnum)
        return E_OUTOFMEMORY;

    //
    // Set client side filters
    //
    dwAppFlags = ClientSideFilterFromQuerySpec( dwQuerySpec, NULL != m_pRsopToken );

    //
    // Create a LDAP Search Filter based on input params
    //

    // Count Filters
    if (pszPackageName && (*pszPackageName))
        fFilters++;
    if ((pLastUsn) && (*pLastUsn))
        fFilters++;
    if (pCategory)
        fFilters++;

    if (fFilters == 0)
    {
        // No Conditionals
        swprintf (szLdapFilter,
            L"(%s=%s)", OBJECTCLASS, CLASS_CS_PACKAGE);

        len = wcslen (szLdapFilter);
    }
    else
    {

        if (fFilters > 1)
        {
            swprintf (szLdapFilter, L"(&");
            len = wcslen (szLdapFilter);
        }
        else
            len = 0;

        if (pszPackageName)
        {
            //
            // Validate
            //

            if (*pszPackageName)
            {
                swprintf (&szLdapFilter[len],
                    L"(%s=*%s*)",
                    PACKAGENAME,
                    pszPackageName);

                len = wcslen (szLdapFilter);
            }
        }

        if ((pLastUsn) && (*pLastUsn))
        {
            SYSTEMTIME SystemTime;

            FileTimeToSystemTime(
                (CONST FILETIME *) pLastUsn,
                &SystemTime);

            swprintf (&szLdapFilter[len],
                L"(%s>=%04d%02d%02d%02d%02d%02d)",
                PKGUSN,
                SystemTime.wYear,
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond+1);

            len = wcslen (szLdapFilter);
        }

        if (pCategory)
        {
            STRINGGUID szCat;

            StringFromGUID (*pCategory, szCat);
            swprintf (&szLdapFilter[len],
                L"(%s=%s)",
                PKGCATEGORYLIST,
                szCat);

            len = wcslen (szLdapFilter);
        }

        if (fFilters > 1)
        {
            szLdapFilter[len] = L')';
            szLdapFilter[++len] = NULL;
        }
    }


    //
    // Finish setting the server side filter
    // based on the query type
    //
    ServerSideFilterFromQuerySpec(
        dwQuerySpec,
        NULL != m_pRsopToken,
        szLdapFilter,
        szLdapFilterFinal);

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_ENUMPACKAGE,
              szLdapFilterFinal,
              dwAppFlags));
        
    //
    // Check all local/platform flags
    //

    if (!(dwAppFlags & APPFILTER_REQUIRE_THIS_PLATFORM))
    {
        pPlatform = NULL;
    }
    else
    {
        pPlatform = &Platform;
        GetDefaultPlatform(pPlatform);
    }

    if (pLastUsn)
    {
        //
        // Find the current store USN and return it
        //
        LPOLESTR            AttrName = STOREUSN;
        ADS_ATTR_INFO     * pAttr = NULL;
        DWORD               cgot = 0;

        hr = ADSIGetObjectAttributes(m_ADsContainer, &AttrName, 1, &pAttr, &cgot);
        if ((SUCCEEDED(hr)) && (cgot))
        {
            UsnGet(*pAttr, (CSUSN *)pLastUsn);
            if (pAttr)
                FreeADsMem(pAttr);
        }
    }

    hr = pEnum->Initialize(m_szPackageName, szLdapFilterFinal, dwQuerySpec, NULL != m_pRsopToken, pPlatform);
    ERROR_ON_FAILURE(hr);

    hr = pEnum->QueryInterface(IID_IEnumPackage,(void**) ppIEnumPackage);
    ERROR_ON_FAILURE(hr);

    return S_OK;

Error_Cleanup:
    if (pEnum)
        delete pEnum;
    *ppIEnumPackage = NULL;

    return RemapErrorCode(hr, m_szContainerName);
}


// choosing the best package that can be returned after returning from the DS
DWORD CAppContainer::ChooseBestFit(PACKAGEDISPINFO *PackageInfo, UINT *rgPriority, DWORD cRowsFetched)
{
    DWORD i=0, k=0, j = 0, temp = 0;
    DWORD index[10];

    // initialising the indices
    for (i = 0; (i <  cRowsFetched); i++)
        index[i] = i;

    // sort the index based on priority and time stamp
    for (i = 0; (i < (cRowsFetched-1)); i++)
    {
        DWORD Pri = rgPriority[i];
        k = i;
        // max element's index is in k
        for (j=(i+1); (j < cRowsFetched); ++j)
        {
            // order first by weight and then by time stamp.
            if ((rgPriority[index[j]] > Pri) ||
                ((rgPriority[index[j]] == Pri) &&
                 (CompareUsn((FILETIME *)&PackageInfo[index[j]].Usn, (FILETIME *)&PackageInfo[index[k]].Usn) == 1)))
            {
                Pri = rgPriority[index[j]];
                k = j;
            }
        }

        if (k != i)
        {
            temp = index[k];
            index[k] = index[i];
            index[i] = temp;
        }
    }

    DWORD dwPackage;
    DWORD dwBestPackage;

    dwBestPackage = 0;

    //
    // Now the packages are sorted in order from highest precedence to lowest.
    // We will now check for upgrades for each package
    //
    for (dwPackage = 0; (dwPackage < cRowsFetched); dwPackage++)
    {
        DWORD            dwPossibleUpgrader;
        PACKAGEDISPINFO* pBestPackage;

        pBestPackage = PackageInfo+index[dwBestPackage];

        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_BESTFIT,
                  pBestPackage->pszPackageName));

        //
        // Now search for someone that upgrades the current choice -- look at all packages
        // after the current one since we've already determined that the packages before
        // this one got upgraded (otherwise we wouldn't be here).
        //
        for (dwPossibleUpgrader = dwPackage + 1; dwPossibleUpgrader < cRowsFetched; dwPossibleUpgrader ++)
        {
            PACKAGEDISPINFO* pUpgraderCandidate;

            //
            // Obviously, we don't need to check the current choice
            // to see if it upgrades itself, so skip it
            //
            if (dwPossibleUpgrader == dwBestPackage)
            {
                continue;
            }

            pUpgraderCandidate = PackageInfo + index[dwPossibleUpgrader];

            //
            // See if the upgrader candidate has any upgrades, if not, keep looking
            //
            if (0 == pUpgraderCandidate->cUpgrades)
            {
                continue;
            }

            //
            // Now we have to see if any of those upgrades apply to the package we have
            // currently selected as the best
            //
            DWORD dwUpgrade;
            BOOL  fFoundUpgrade;

            fFoundUpgrade = FALSE;

            for (dwUpgrade = 0; dwUpgrade < pUpgraderCandidate->cUpgrades; dwUpgrade++)
            {
                DWORD dwValidUpgradeMask;

                dwValidUpgradeMask = UPGFLG_Uninstall |
                    UPGFLG_NoUninstall |
                    UPGFLG_Enforced;

                //
                // If this is a valid upgrade
                //
                if (pUpgraderCandidate->prgUpgradeInfoList[dwUpgrade].Flag & dwValidUpgradeMask)
                {
                    //
                    // Does it upgrade the package we think is best at this point? We only
                    // consider upgrades in this container, as we no longer allow upgrades from lower
                    // precedence class stores -- the caller who iterates through each container from
                    // highest precedence to lowest will simply choose the app from the first container in which
                    // we have a match.
                    //
                    // We use memcmp to compare guids to see if the best choice package's guid is listed
                    // as being upgraded by this upgrade candidate
                    //
                    if (memcmp(&((pUpgraderCandidate->prgUpgradeInfoList)[dwUpgrade].PackageGuid),
                               &(pBestPackage->PackageGuid), sizeof(GUID) == 0))
                    {
                        //
                        // We have a match -- reset the current best choice to the upgrade candidate
                        //
                        dwBestPackage = dwPossibleUpgrader;

                        //
                        // another package upgrades this -- no need to look any further, so we quit
                        //
                        CSDBGPrint((DM_WARNING,
                                  IDS_CSTORE_BESTFITSKIP,
                                  pBestPackage->pszPackageName,
                                  pUpgraderCandidate->pszPackageName));

                        break;
                    }
                }
            }

            //
            // If we found an upgrade in the list above, we can stop abort the search for an upgrade now --
            // if we found another, it would just be a lower precedence app since we're iterating from highest to lowest,
            // and we want the highest predecence app that upgrades the currently chosen best app
            //
            if (fFoundUpgrade)
            {
                break;
            }
        }
    }

    DWORD dwChoice;

    dwChoice = index[dwBestPackage];

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_BESTFIT_END,
              PackageInfo[dwChoice].pszPackageName));

    return dwChoice;
}

//
// CAppContainer::GetAppInfo
// -----------------------------
//
//
//
//  Synopsis:       This is the most common access point to the Class Store.
//                  It receives a CLSID and a QUERYCONTEXT.
//                  It looks up the Class Store container for a matching set
//                  of packages with in the context of the QUERYCONTEXT.
//
//                  QUERYCONTEXT includes
//                      Execution Context
//                      Locale Id
//                      Platform/OS
//
//                  If i finds an app that matches the requirements, it returns
//                  an PACKAGEDISPINFO structure containing installation details.
//
//  Arguments:      [in]  clsid
//                  [in]  pQryContext
//                  [out] pPackageInfo
//
//  Returns:        CS_E_PACKAGE_NOTFOUND
//                  S_OK
//
//
//

HRESULT STDMETHODCALLTYPE
CAppContainer::GetAppInfo(
                          uCLSSPEC       *   pclsspec,          // Class Spec (GUID/Ext/MIME)
                          QUERYCONTEXT   *   pQryContext,       // Query Attributes
                          PACKAGEDISPINFO    *   pPackageInfo
                          )

                          //
                          // This is the most common method to access the Class Store.
                          // It queries the class store for implementations for a specific
                          // Class Id, or File Ext, or ProgID.
                          //
                          // If a matching implementation is available (for the object type,
                          // client architecture, locale and class context) then the installation
                          // parameters of the package is returned.
{
    GUID        clsid;
    WCHAR       szfilterbuf[1000];
    WCHAR*      szfilter = szfilterbuf;
    WCHAR*      szNameFilter;
    STRINGGUID  szClsid;
    UINT        i, iClsid = 0;
    ULONG       cRead;
    HRESULT     hr;
    ULONG       cSize = _MAX_PATH;
    BOOL        fFound = FALSE;
    PLATFORMINFO PlatformInfo;
    LPOLESTR    pFileExt = NULL;
    BOOL        OnDemandInstallOnly = TRUE;
    WCHAR       FileExtLower [10];
    FILETIME    ftCurrentTime;

    szNameFilter = NULL;

    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    if (!m_fOpen)
        return E_FAIL;

    //
    // Check if the TypeSpec is MIMEType
    // then map it to a CLSID
    //

    switch (pclsspec->tyspec)
    {
    case TYSPEC_CLSID:

        if (IsNullGuid(pclsspec->tagged_union.clsid))
            return E_INVALIDARG;
        //
        // Check against known missing ones
        //

        hr = S_OK;

        EnterCriticalSection (&ClassStoreBindList);

        //
        // Retrieve the current time so we can determine
        // if cache entries are expired
        //
        GetSystemTimeAsFileTime( &ftCurrentTime );


        for (iClsid=m_KnownMissingClsidCache.start; (iClsid  != m_KnownMissingClsidCache.end);
                        iClsid = (iClsid+1)%(CLSIDCACHESIZE))
        {
            if ( IsExpired( &ftCurrentTime, &(m_KnownMissingClsidCache.ElemArr[iClsid].Time) ) )
            {
                // all the prev. elems must have expired.

                // delete this element
                m_KnownMissingClsidCache.start = (m_KnownMissingClsidCache.start+1)%CLSIDCACHESIZE;
                m_KnownMissingClsidCache.sz--;

                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_CLASS_PURGE));
                          
                // iClsid will be moved automatically.
                continue;
            }

            if ((IsEqualGUID(pclsspec->tagged_union.clsid,
                            m_KnownMissingClsidCache.ElemArr[iClsid].Clsid)) &&
                ((pQryContext->dwContext) == m_KnownMissingClsidCache.ElemArr[iClsid].Ctx))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_CLASS_HIT));

                hr = CS_E_PACKAGE_NOTFOUND;
                break;
            }
        }

        LeaveCriticalSection (&ClassStoreBindList);

        if (hr == CS_E_PACKAGE_NOTFOUND)
            return hr;

        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);
        swprintf (szfilter, L"(%s=%s*)", PKGCLSIDLIST, szClsid);
        break;

    case TYSPEC_FILEEXT:

        if ((pclsspec->tagged_union.pFileExt == NULL) ||
            (*(pclsspec->tagged_union.pFileExt) == NULL))
            return E_INVALIDARG;


        if (wcslen(pclsspec->tagged_union.pFileExt) > 9)
            return E_INVALIDARG;

        wcscpy (&FileExtLower[0], pclsspec->tagged_union.pFileExt);
        _wcslwr (&FileExtLower[0]);

        swprintf (szfilter,
            L"(%s=%s*)",
            PKGFILEEXTNLIST, &FileExtLower[0]);

        pFileExt = &FileExtLower[0];
        break;


    case TYSPEC_PROGID:

        if ((pclsspec->tagged_union.pProgId == NULL) ||
            (*(pclsspec->tagged_union.pProgId) == NULL))
            return E_INVALIDARG;

        swprintf (szfilter,
            L"(%s=%s)", PKGPROGIDLIST, pclsspec->tagged_union.pProgId);
        break;

    case TYSPEC_PACKAGENAME:
        //
        // Validate package name
        //

        if ((pclsspec->tagged_union.ByName.pPackageName == NULL) ||
            (*(pclsspec->tagged_union.ByName.pPackageName) == NULL))
            return E_INVALIDARG;

        //
        // The search filter syntax requires that the package name is
        // properly escaped, so we retrieve such a filter below
        //
        hr = GetEscapedNameFilter( pclsspec->tagged_union.ByName.pPackageName, &szNameFilter );

        if ( FAILED(hr) )
        {
            return hr;
        }

        szfilter = szNameFilter;

        OnDemandInstallOnly = FALSE;
        break;

    case TYSPEC_OBJECTID:
        //
        // Validate object id
        //
        if (IsNullGuid(pclsspec->tagged_union.ByObjectId.ObjectId))
            return E_INVALIDARG;

        LPWSTR EncodedGuid;

        EncodedGuid = NULL;
        hr = ADsEncodeBinaryData((PBYTE)&pclsspec->tagged_union.ByObjectId.ObjectId, sizeof(GUID), &EncodedGuid);
    
        swprintf(szfilter, L"(%s=%s)", OBJECTGUID, EncodedGuid);
    
        FreeADsMem(EncodedGuid);

        OnDemandInstallOnly = FALSE;
        break;

    default:
        return E_NOTIMPL;
    }

    //
    //
    ULONG              cRowsFetched;
    PACKAGEDISPINFO    PackageInfo[10];
    UINT               rgPriority [10];

    ADS_SEARCH_HANDLE  hADsSearchHandle = NULL;

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, pszInstallInfoAttrNames, cInstallInfoAttr, &hADsSearchHandle);

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_MERGEAPPINFO,
              szfilter));

    ERROR_ON_FAILURE(hr);

    //
    // We obtain the 10 best matches
    //
    hr = FetchInstallData(
        m_ADsPackageContainer,
        hADsSearchHandle,
        pQryContext,
        pclsspec,
        pFileExt,
        10,
        &cRowsFetched,
        &PackageInfo[0],
        &rgPriority[0],
        OnDemandInstallOnly,
        &m_PolicyId,
        m_szGpoPath
        );

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_ONDEMAND,
              cRowsFetched,
              hr));

    if (cRowsFetched == 0)
    {
        hr = CS_E_OBJECT_NOTFOUND;
        //
        // If CLSID was passed cache the miss
        //
        if (pclsspec->tyspec == TYSPEC_CLSID)
        {
            EnterCriticalSection (&ClassStoreBindList);

            if (m_KnownMissingClsidCache.sz < (CLSIDCACHESIZE-1))
            {
                memcpy (&m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Clsid,
                        &(pclsspec->tagged_union.clsid), sizeof(GUID));

                m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Ctx
                                    = pQryContext->dwContext;

                //
                // Set the time member to the current time -- this is retrieved
                // above for all clsid queries
                //
                GetExpiredTime( &ftCurrentTime,
                                &(m_KnownMissingClsidCache.ElemArr[m_KnownMissingClsidCache.end].Time) );


                m_KnownMissingClsidCache.sz++;

                m_KnownMissingClsidCache.end = (m_KnownMissingClsidCache.end+1) % CLSIDCACHESIZE;

            }
            LeaveCriticalSection (&ClassStoreBindList);
        }
    }
    else
    {
        DWORD dwChoice = 0;

        if (cRowsFetched > 1)
        {
            dwChoice = ChooseBestFit(PackageInfo, rgPriority, cRowsFetched);
        }


        memcpy (pPackageInfo, &PackageInfo[dwChoice], sizeof(PACKAGEDISPINFO));
        memset (&PackageInfo[dwChoice], NULL, sizeof(PACKAGEDISPINFO));

        // Clean up all allocations
        for (i=0; i < cRowsFetched; i++)
        {
            ReleasePackageInfo(&PackageInfo[i]);
        }
    }

    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    //
    // fill in PolicyID
    //
    if (SUCCEEDED(hr))
    {
        memcpy (&(pPackageInfo->GpoId), &m_PolicyId, sizeof(GUID));
    }

Error_Cleanup:

    if ( szNameFilter )
    {
        CsMemFree( szNameFilter );
    }
    
    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_APPINFO_END,
              hr));

    return RemapErrorCode(hr, m_szContainerName);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\clsacc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    cclsacc.cxx
//
//  Contents:    Class factory and IUnknown methods for CClassAccess
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


HRESULT  __stdcall  CClassAccess::QueryInterface(REFIID riid, void  * * ppvObject)

{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    else  if( IsEqualIID( IID_IClassAccess, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAccess *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);

}

ULONG __stdcall  CClassAccess::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccess::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}


//
// Constructor
//
unsigned long gulcClassFactory = 0;

CClassAccessCF::CClassAccessCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcClassFactory );
}

//
// Destructor
//
CClassAccessCF::~CClassAccessCF()
{
    InterlockedDecrement((long *) &gulcClassFactory );
}

HRESULT  __stdcall  CClassAccessCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }

    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassAccessCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassAccessCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;

    // 0 is the only valid value to check
    if (uTmp == 0)
    {
        delete this;
    }

    return(cRef);
}

//
// IClassFactory Overide
//
HRESULT  __stdcall  CClassAccessCF::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void  * * ppvObject)
{
    CClassAccess *  pIUnk = NULL;
    SCODE sc = S_OK;

    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassAccess()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}

HRESULT  __stdcall  CClassAccessCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcClassFactory ); }
    else
    { InterlockedDecrement((long *) &gulcClassFactory ); }
    return(S_OK);
}


CClassAccess::CClassAccess()

{
     m_uRefs = 1;
     m_cCalls = 0;
     pStoreList = NULL;
     cStores = 0;
     m_pszClassStorePath = NULL;
     m_pRsopUserToken = NULL;
}

CClassAccess::~CClassAccess()

{
    DWORD i;

    delete [] m_pszClassStorePath;

    for (i = 0; i < cStores; i++)
    {
        if (pStoreList[i]->pszClassStorePath)
        {
            CsMemFree (pStoreList[i]->pszClassStorePath);
            pStoreList[i]->pszClassStorePath = NULL;
        }
        CsMemFree(pStoreList[i]);
        pStoreList[i] = NULL;

    }
    CsMemFree(pStoreList);
    cStores = NULL;
}

//----------------------------------------------------------------------
//
//

void PrintClassSpec(
      uCLSSPEC       *   pclsspec         // Class Spec (GUID/Ext/MIME)
     )
{
    STRINGGUID szClsid;

    if (pclsspec->tyspec == TYSPEC_CLSID)
    {
        StringFromGUID (pclsspec->tagged_union.clsid, szClsid);

        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_CLASSSPEC,
                  TYSPEC_CLSID,
                  szClsid));
    }

    if (pclsspec->tyspec == TYSPEC_PROGID)
    {

        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_CLASSSPEC,
                  TYSPEC_PROGID,
                  pclsspec->tagged_union.pProgId));
    }

    if (pclsspec->tyspec == TYSPEC_FILEEXT)
    {
        CSDBGPrint((DM_WARNING,
                  IDS_CSTORE_CLASSSPEC,
                  TYSPEC_FILEEXT,
                  pclsspec->tagged_union.pFileExt));
    }
}

//----------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
CClassAccess::GetAppInfo(
         uCLSSPEC           *   pclsspec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT       *   pQryContext,         // Query Attributes
         PACKAGEDISPINFO    *   pPackageInfo
        )

        //
        // This is the most common method to access the Class Store.
        // It queries the class store for implementations for a specific
        // Class Id, or File Ext, or ProgID or MIME type.
        //
        // If a matching implementation is available for the object type,
        // client architecture, locale and class context pointer to the
        // binary is returned.
{

    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //
    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr = S_OK;
    ULONG               i = 0, j = 0, k= 0;
    IClassAccess    *   pICA = NULL;
    BOOL                fCache = FALSE;
    PSID                pUserSid = NULL;
    BOOL                fFound = FALSE;
    QUERYCONTEXT        QueryContext;

    if ((!pPackageInfo))
            return E_INVALIDARG;

    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    if ( pQryContext )
    {
        QueryContext = *pQryContext;
    }
    else
    {
        // gets the default information.
        QueryContext.dwContext = CLSCTX_ALL;
        GetDefaultPlatform( &QueryContext.Platform );
        QueryContext.Locale = LANG_SYSTEM_DEFAULT;
        QueryContext.dwVersionHi = (DWORD) -1;
        QueryContext.dwVersionLo = (DWORD) -1;
    }

    if (gDebug)
        PrintClassSpec(pclsspec);

    if (!pStoreList)
        hr = GetUserClassStores(
                    m_pszClassStorePath,
                    &pStoreList,
                    &cStores,
                    &fCache,
                    &pUserSid);


    ERROR_ON_FAILURE(hr);

    for (i=0; i < cStores; i++)
    {

        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, pUserSid, NULL, pclsspec, fCache, &i, &hr)))
        {
            ASSERT(FAILED(hr));
            return hr;
        }

        //
        // Call method on this store
        //

        pICA->AddRef();

        hr = pICA->GetAppInfo(
            pclsspec,
            &QueryContext,
            pPackageInfo);

        // Release it after use.

        pICA->Release();

        if ( CS_E_OBJECT_NOTFOUND != hr )
        {
            ERROR_ON_FAILURE(hr);
        }

        //
        // We are iterating through the class stores from highest precedence to lowest --
        // thus, the first container to return success will be our choice.
        //
        if (SUCCEEDED(hr))
        {
            fFound = TRUE;
            break;
        }

        hr = S_OK;
    }

    if ( ! fFound )
    {
        hr = CS_E_PACKAGE_NOTFOUND;
    }

 Error_Cleanup:

    if (pUserSid)
        CsMemFree (pUserSid);

    if ( pICA )
    {
        pICA->Release();
    }

    if (fFound)
    {
        return S_OK;
    }

    return hr;
}

#define MAX_GUID_CCH 38
//
// IsClassStoreForPolicy
//

BOOL IsClassStoreForPolicy(CLASSCONTAINER* pClassStore,
                           LPWSTR          wszPolicyId)
{
    LPWSTR pszPolicyGuid;

    // Path looks like:
    // LDAP://CN=<Class Store Name>,CN=<user-or-machine>,CN=<{policy-guid}>,...

    //
    // Look for ',' first
    //
    pszPolicyGuid = wcschr(pClassStore->pszClassStorePath, L',');

    if (!pszPolicyGuid)
    {
        return FALSE;
    }

    //
    // Look for the second ','
    //
    pszPolicyGuid = wcschr(pszPolicyGuid + 1, L',');

    if (!pszPolicyGuid)
    {
        return FALSE;
    }

    //
    // Now get to '{' at start of guid -- it is 4 chars
    // past the ',' which we are currently at.  Use wcschr
    // to make sure we don't go past the end of the string
    // and that our assumptions about the structure of the
    // path are correct
    //
    if (wcschr(pszPolicyGuid, L'{') == (pszPolicyGuid + 4))
    {

        pszPolicyGuid += 4;

        //
        // Now that we have the '{', we are at the start of the guid
        // and can compare with the requested policy id
        //
        if (_wcsnicmp(pszPolicyGuid, wszPolicyId, MAX_GUID_CCH) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//
// GetNextValidClassStore
//
//

IClassAccess *GetNextValidClassStore(CLASSCONTAINER** pStoreList,
                                     DWORD            cStores,
                                     PSID             pUserSid,
                                     PRSOPTOKEN       pRsopToken,
                                     uCLSSPEC*        pClassSpec,
                                     BOOL             fCache,
                                     DWORD *          pcount,
                                     HRESULT*         phr)
{
    IClassAccess *pretICA = NULL;
    BOOL          bSpecificPolicy;
    LPWSTR        wszPolicyGuid;

    wszPolicyGuid = NULL;

    *phr = S_OK;

    bSpecificPolicy = pClassSpec ? TYSPEC_PACKAGENAME == pClassSpec->tyspec : FALSE;

    if (bSpecificPolicy)
    {
        GuidToString(pClassSpec->tagged_union.ByName.PolicyId, &wszPolicyGuid);

        if (!wszPolicyGuid) {
            *phr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(*phr))
    {
        for (pStoreList += (*pcount); (*pcount) < cStores; (*pcount)++, pStoreList++)
        {
            if (bSpecificPolicy &&
                !IsClassStoreForPolicy(*pStoreList, wszPolicyGuid))
            {
                continue;
            }

            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_BIND,
                          (*pcount),
                          (*pStoreList)->pszClassStorePath));
                //
                // Bind to this Class Store
                //

                if (wcsncmp((*pStoreList)->pszClassStorePath, L"LDAP:", 5) == 0)
                {
                    //
                    // If the Storename starts with ADCS or LDAP
                    // it is NTDS based implementation. Call directly.
                    //

                    IClassAccess *pCA = NULL;
                    LPOLESTR szClassStore = (*pStoreList)->pszClassStorePath;

                    *phr = pCF->CreateConnectedInstance(
                        szClassStore,
                        pUserSid,
                        pRsopToken,
                        fCache,
                        (void **)&pCA);

                    if ( ! SUCCEEDED(*phr) )
                    {
                        break;
                    }

                    pretICA = pCA;
                }
                else
                {
                    *phr = CS_E_INVALID_PATH;
                }

                break;
            }
        }
    }

    if (wszPolicyGuid)
    {
        CsMemFree(wszPolicyGuid);
    }

    if (!pretICA)
    {
        ASSERT(FAILED(*phr));
    }

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_BIND_STATUS,
              *phr));

    return pretICA;
}


HRESULT STDMETHODCALLTYPE CClassAccess::EnumPackages(
        LPOLESTR        pszPackageName,
        GUID            *pCategory,
        ULONGLONG       *pLastUsn,
        DWORD           dwQuerySpec,
        IEnumPackage    **ppIEnumPackage)
{
    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr = S_OK;
    ULONG               i;
    IEnumPackage      **Enum;
    ULONG               cEnum = 0;
    CMergedEnumPackage *EnumMerged = NULL;
    IClassAccess       *pICA = NULL;
    ULONGLONG          LastUsn, CopyLastUsn, *pCopyLastUsn;
    BOOL               fCache = FALSE;
    PSID               pUserSid = NULL;

    switch ( dwQuerySpec )
    {
    case APPQUERY_ALL:
    case APPQUERY_ADMINISTRATIVE:
    case APPQUERY_POLICY:
    case APPQUERY_USERDISPLAY:
    case APPQUERY_RSOP_LOGGING:
    case APPQUERY_RSOP_ARP:
        break;
    default:
        return E_INVALIDARG;
    }

    LastUsn = 0;

    if (pLastUsn)
    {
        pCopyLastUsn = &CopyLastUsn;
        *pCopyLastUsn = *pLastUsn;
    }
    else
        pCopyLastUsn = NULL;

    //
    // Get the list of Class Stores for this user
    //
    if (!pStoreList)
        hr = GetUserClassStores(
                        m_pszClassStorePath,
                        &pStoreList,
                        &cStores,
                        &fCache,
                        &pUserSid);

    *ppIEnumPackage = NULL;


    if ((hr == S_OK) && (cStores == 0))
    {
        hr = CS_E_NO_CLASSSTORE;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Dynamically allocate a vector of interfaces (class stores).
        // Previously, this was a fixed size array, which, besides
        // only allowing for a small number of class stores, caused an
        // access violation because the rest of the code assumed that the
        // size of the fixed array could be arbitrarily large.
        //
        Enum = new IEnumPackage*[cStores];

        if (!Enum)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (!SUCCEEDED(hr))
    {
        //
        // Free the Sid
        //
        if (pUserSid)
            CsMemFree (pUserSid);
        return hr;
    }

    for (i=0; i < cStores; i++)
    {
        if (!(pICA = GetNextValidClassStore(pStoreList, cStores, pUserSid, m_pRsopUserToken, NULL, fCache, &i, &hr)))
        {
            ASSERT(FAILED(hr));
            return hr;
        }

        //
        // Call method on this store
        //

        hr = pICA->EnumPackages (pszPackageName,
            pCategory,
            pCopyLastUsn,
            dwQuerySpec,
            &(Enum[cEnum]));

        if (FAILED(hr))
        {
            break;
        }

        if (pCopyLastUsn)
        {
            if (LastUsn < *pCopyLastUsn)
                LastUsn = *pCopyLastUsn;
            *pCopyLastUsn = *pLastUsn;
        }
        if (SUCCEEDED(hr))
            cEnum++;
    }

    if (SUCCEEDED(hr))
    {

        EnumMerged = new CMergedEnumPackage;
        hr = EnumMerged->Initialize(Enum, cEnum);

        if (FAILED(hr))
        {
            for (i = 0; i < cEnum; i++)
                Enum[i]->Release();
            delete EnumMerged;
        }
        else
        {
            hr = EnumMerged->QueryInterface(IID_IEnumPackage, (void **)ppIEnumPackage);
            if (FAILED(hr))
                delete EnumMerged;
        }

        if (pLastUsn)
        {
            if (LastUsn > *pLastUsn)
                *pLastUsn = LastUsn;
        }
    }

    if (pUserSid)
        CsMemFree (pUserSid);

    //
    // Free the dynamically allocated vector of interfaces
    //
    delete [] Enum;

    if ( pICA )
    {
        pICA->Release();
    }

    return hr;
}

HRESULT __stdcall CClassAccess::SetClassStorePath(
    LPOLESTR         pszClassStorePath,
    void*            pRsopUserToken)
{
    DWORD cchPath;

    //
    // We only allow this to be set once -- if it's already
    // set we return an error.
    //
    if (m_pszClassStorePath)
    {
        return E_INVALIDARG;
    }

    if ( ! pszClassStorePath )
    {
        return S_OK;
    }

    cchPath = lstrlen(pszClassStorePath) + 1;

    m_pszClassStorePath = new WCHAR[cchPath];

    if (!m_pszClassStorePath)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(m_pszClassStorePath, pszClassStorePath);

    m_pRsopUserToken = (PRSOPTOKEN) pRsopUserToken;

    return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\cache.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:       cache.cxx
//
//  Contents:   Class Store Binding cache
//
//  Author:     AdamEd
//
//-------------------------------------------------------------------------

#include "cstore.hxx"


CBinding::CBinding(
    WCHAR*        wszClassStorePath,
    PSID          pSid,
    IClassAccess* pClassAccess,
    HRESULT       hrBind,
    HRESULT*      phr) 
{
    *phr = E_OUTOFMEMORY;

    Hr = hrBind;

    szStorePath = (WCHAR*) CsMemAlloc(
        ( lstrlen( wszClassStorePath ) + 1 ) *
        sizeof( *wszClassStorePath ) );

    if ( szStorePath )
    {
        UINT dwBytesRequired;

        lstrcpy( szStorePath, wszClassStorePath );
 
        dwBytesRequired = GetLengthSid(pSid);

        Sid = (PSID) CsMemAlloc( dwBytesRequired );

        if ( Sid )
        { 
            BOOL bStatus;
            
            bStatus = CopySid(
                dwBytesRequired,
                Sid,
                pSid);

            if ( ! bStatus )
            {
                LONG Status;

                Status = GetLastError();

                *phr = HRESULT_FROM_WIN32( Status );
            }
            else
            {
                *phr = S_OK;
            }
        }
    }

    if ( SUCCEEDED( *phr ) && pClassAccess )
    {
        pIClassAccess = pClassAccess;
        pIClassAccess->AddRef();
    }
}

CBinding::~CBinding()
{
    if ( pIClassAccess )
    {
        pIClassAccess->Release();
    }

    CsMemFree( Sid );
    
    CsMemFree( szStorePath );
}


BOOL
CBinding::Compare( 
    WCHAR* wszClassStorePath,
    PSID   pSid)
{
    LONG lCompare;
    BOOL bStatus;

    bStatus = FALSE;

    lCompare = lstrcmp(
        szStorePath,
        wszClassStorePath);

    if ( 0 == lCompare )
    {
        bStatus = EqualSid(
            Sid,
            pSid);
    }

    return bStatus;
}

BOOL CBinding::IsExpired( FILETIME* pftCurrentTime )
{
 
    SYSTEMTIME SystemTimeCurrent;
    SYSTEMTIME SystemTimeExpiration;;
    BOOL       bRetrievedTime;

    bRetrievedTime = FileTimeToSystemTime(
        pftCurrentTime,
        &SystemTimeCurrent);

    bRetrievedTime &= FileTimeToSystemTime(
        &Time,
        &SystemTimeExpiration);

    if ( bRetrievedTime )
    {
        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Current Time",
            SystemTimeCurrent.wMonth,
            SystemTimeCurrent.wDay,
            SystemTimeCurrent.wYear,
            SystemTimeCurrent.wHour,
            SystemTimeCurrent.wMinute,
            SystemTimeCurrent.wSecond));

        CSDBGPrint((
            DM_VERBOSE,
            IDS_CSTORE_CACHE_EXPIRE,
            L"Expire Time",
            SystemTimeExpiration.wMonth,
            SystemTimeExpiration.wDay,
            SystemTimeExpiration.wYear,
            SystemTimeExpiration.wHour,
            SystemTimeExpiration.wMinute,
            SystemTimeExpiration.wSecond));
    }

    //
    // Compare the current time to the expiration time
    //
    LONG CompareResult;

    CompareResult = CompareFileTime(
        pftCurrentTime,
        &Time);
        
    //
    // If the current time is later than the expired time,
    // then we have expired
    //
    if ( CompareResult > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


CBindingList::CBindingList() :
    _cBindings( 0 )
{
    memset( &_ListLock, 0, sizeof( _ListLock ) );

    //
    // InitializeCriticalSection has no return value --
    // in extremely low memory situations, it may
    // throw an exception
    //

    (void) InitializeCriticalSection( &_ListLock );
}


CBindingList::~CBindingList()
{
    CBinding* pBinding;

    for (
        Reset();
        pBinding = (CBinding*) GetCurrentItem();
        )
    {
        //
        // We must perform the MoveNext before the Delete
        // since it alters the list and will render its
        // current pointer invalid
        //
        MoveNext();

        Delete( pBinding );
    }

    //
    // Clean up the critical section allocated in the constructor
    //
    DeleteCriticalSection( &_ListLock );
}

void
CBindingList::Lock()
{
    EnterCriticalSection( &_ListLock );
}

void
CBindingList::Unlock()
{
    LeaveCriticalSection( &_ListLock );
}

CBinding*
CBindingList::Find(
    FILETIME* pCurrentTime,
    WCHAR*    wszClassStorePath,
    PSID      pSid)
{
    CBinding* pCurrent;
    CBinding* pExpired;

    pCurrent = NULL;

    for ( Reset(); 
          pCurrent = (CBinding*) GetCurrentItem();
          MoveNext(), Delete( pExpired ) )
    {
        BOOL bFound;

        if ( pCurrent->IsExpired( pCurrentTime ) )
        {
            pExpired = pCurrent;
            continue;
        }

        pExpired = NULL;

        bFound = pCurrent->Compare(
            wszClassStorePath,
            pSid);

        if ( bFound )
        {
            CSDBGPrint((DM_WARNING, 
                        IDS_CSTORE_CSCACHE_HIT,
                        wszClassStorePath));

            return pCurrent;
        }
    }

    return NULL;
}


CBinding*
CBindingList::AddBinding( 
    FILETIME* pCurrentTime,
    CBinding* pBinding)
{
    CBinding* pExisting;

    pExisting = Find(
        pCurrentTime,
        pBinding->szStorePath,
        pBinding->Sid);

    if ( pExisting )
    {
        delete pBinding;

        return pExisting;
    }

    if ( _cBindings >= MAXCLASSSTORES )
    {
        Reset();

        Delete( (CBinding*) GetCurrentItem() );
    }
    
    GetExpiredTime(
        pCurrentTime,
        &(pBinding->Time));

    InsertFIFO( pBinding );

    _cBindings++;

    return pBinding;
}

void
CBindingList::Delete( CBinding* pBinding )
{
    if ( pBinding )
    {
        CSDBGPrint((DM_WARNING,
                    IDS_CSTORE_CSCACHEPURGE,
                    pBinding->szStorePath));

        pBinding->Remove();

        delete pBinding;

        _cBindings--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\common\evt.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  events.cxx
//
//*************************************************************

#include "common.hxx"

CEvents * gpEvents = 0;

CEventsBase::CEventsBase()
{
    _hUserToken = 0;
}

void
CEventsBase::Report(
    DWORD       EventID,
    BOOL        bDowngradeErrors,
    WORD        Strings,
    ...
    )
{
    va_list     VAList;
    WCHAR *     ppwszStrings[10];
    WORD        Type;
    DWORD       DbgMsgLevel;

    if ( Strings > 10 )
        return;

    switch ( EventID / 100 )
    {
    case 1:
        Type = EVENTLOG_ERROR_TYPE;
        DbgMsgLevel = DM_WARNING;
        break;
    case 2:
        Type = EVENTLOG_WARNING_TYPE;
        DbgMsgLevel = DM_WARNING;
        break;
    case 3:
        Type = EVENTLOG_INFORMATION_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    case 4:
        Type = EVENTLOG_INFORMATION_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    default:
        return;
    }

    if ( bDowngradeErrors && ( EVENTLOG_ERROR_TYPE == Type ) )
    {
        Type = EVENTLOG_WARNING_TYPE;
        DbgMsgLevel = DM_WARNING;
    }

    if ( Strings > 0 )
    {
        va_start( VAList, Strings );
        for ( DWORD n = 0; n < Strings; n++ )
            ppwszStrings[n] = va_arg( VAList, WCHAR * );
        va_end( VAList );
    }

    if ( (EventID < 400) ||
         (gDebugLevel & (DL_VERBOSE | DL_EVENTLOG)) )
    {
        HANDLE  hEventLog;
        PSID    pSid;

        hEventLog = OpenEventLog( NULL, APPMGMT_EVENT_SOURCE );

        if ( ! hEventLog )
            return;

        pSid = AppmgmtGetUserSid( _hUserToken );

        (void) ReportEvent(
                        hEventLog,
                        Type,
                        0,
                        EventID,
                        pSid,
                        Strings,
                        0,
                        (LPCWCH *) ppwszStrings,
                        NULL );

        LocalFree( pSid );
        CloseEventLog( hEventLog );
    }

    //
    // Also make sure the event messages get sent to the debugger and log file.
    // Kind of hacky method, but makes it so every caller to ::Report doesn't
    // have to call _DebugMsg as well.
    // However, don't do this for the verbose messages otherwise it will be
    // dumped to the debugger twice.
    //
    if ( EVENT_APPMGMT_VERBOSE == EventID )
        return;

    switch ( Strings )
    {
    case 0 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID );
        break;
    case 1 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0] );
        break;
    case 2 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1] );
        break;
    case 3 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2] );
        break;
    case 4 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2], ppwszStrings[3] );
        break;
    case 5 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2], ppwszStrings[3], ppwszStrings[4] );
        break;
    default :
        VerboseDebugDump( L"CEvents::Report called with more params then expected!\n" );
        break;
    }
}

void
CEventsBase::Install(
    DWORD       ErrorStatus,
    WCHAR *     pwszDeploymentName,
    WCHAR *     pwszGPOName
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_INSTALL_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pwszDeploymentName,
            pwszGPOName,
            wszStatus );
    }
    else
    {
        Report(
            EVENT_APPMGMT_INSTALL,
            FALSE,
            2,
            pwszDeploymentName,
            pwszGPOName );
    }
}

void
CEventsBase::Uninstall(
    DWORD       ErrorStatus,
    WCHAR *     pwszDeploymentName,
    WCHAR *     pwszGPOName
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_UNINSTALL_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pwszDeploymentName,
            pwszGPOName,
            wszStatus );
    }
    else
    {
        Report(
            EVENT_APPMGMT_UNINSTALL,
            FALSE,
            2,
            pwszDeploymentName,
            pwszGPOName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\admin.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:    admin.cxx
//
//  Contents:Class Factory and IUnknown methods for CClassContainer
//
//  Author:  DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//
// Constructor for Class Container Class factory
//
unsigned long gulcInstances = 0;

HRESULT GetConsistentPackageFlags(
    HANDLE         hADs,
    DWORD*         pdwPackageFlags,
    UINT*          pdwUpgrades,
    UINT*          pdwInstallUiLevel,
    CLASSPATHTYPE* pdwPathType,
    DWORD*         pdwNewPackageFlags,
    WCHAR*         wszSearchFlags)
{
    HRESULT         hr;
    LPOLESTR        PackageAttrName;
    ADS_ATTR_INFO*  pAttrsGot;
    DWORD           cgot;
    DWORD           posn;
    DWORD           dwOldPackageFlags;
    DWORD           dwNewPackageFlags;

    //
    // Init locals
    //
    dwOldPackageFlags = 0;
    PackageAttrName = PACKAGEFLAGS;
    pAttrsGot = NULL;
    hr = S_OK;

    if (hADs)
    {
        //
        // We need to find the old package flags -- we do this so we can preserve
        // certain properties.
        //
        hr = ADSIGetObjectAttributes(hADs, &PackageAttrName, 1, &pAttrsGot, &cgot);

        if (SUCCEEDED(hr))
        {
            posn = GetPropertyFromAttr(pAttrsGot, cgot, PACKAGEFLAGS);
            if (posn < cgot)
                UnpackDWFrom(pAttrsGot[posn], (DWORD *)&dwOldPackageFlags);
            else  
                hr=CS_E_OBJECT_NOTFOUND;
        }
    }

    if (SUCCEEDED(hr)) 
    {
        //
        // Decide whether to start with existing flags or caller supplied flags based
        // on whether the caller passed in desired flags
        //
        dwNewPackageFlags = pdwPackageFlags ? *pdwPackageFlags : dwOldPackageFlags;

        //
        // Make sure to preserve upgrades,
        // installui, and pathtype transparently
        //
        dwNewPackageFlags |= dwOldPackageFlags & 
            (ACTFLG_POSTBETA3 |
             ACTFLG_HasUpgrades |
             ACTFLG_FullInstallUI |
             PATHTYPEMASK);

        //
        // Now set the upgrade bit according to whether there are upgrades
        //
        if (pdwUpgrades) 
        {
            dwNewPackageFlags = *pdwUpgrades ?
                dwNewPackageFlags | ACTFLG_HasUpgrades :
                dwNewPackageFlags & ~(ACTFLG_HasUpgrades);
        }

        //
        // Set the install UI level
        //
        if (pdwInstallUiLevel)
        {
            dwNewPackageFlags &= ~(ACTFLG_FullInstallUI);
            dwNewPackageFlags |= (*pdwInstallUiLevel != INSTALLUILEVEL_FULL) ?
                ACTFLG_FullInstallUI : 0;
        }

        //
        // Now or in the pathtype by shifting it to the far left -- first clear those
        // bits out
        //
        if (pdwPathType) 
        {
            dwNewPackageFlags &= ~PATHTYPEMASK;
            dwNewPackageFlags |= *pdwPathType << PATHTYPESHIFT;
        }
     
        *pdwNewPackageFlags = dwNewPackageFlags;

        if (wszSearchFlags) 
        {
            memset(wszSearchFlags, 0, MAX_SEARCH_FLAGS * sizeof(*wszSearchFlags));

            //
            // Previously, we determined the search flags based
            // on whether the package was an NT 5.0 beta 3 deployment --
            // this backward compatibility with beta 3 will not
            // be supported in subsequent versions of Windows
            //
            *wszSearchFlags = SEARCHFLAG_REMOVED;
            
            if (dwNewPackageFlags & ACTFLG_Published)
            {
                *wszSearchFlags = SEARCHFLAG_PUBLISHED;
                wszSearchFlags++;
            }

            if (dwNewPackageFlags & ACTFLG_Assigned)
            {
                *wszSearchFlags = SEARCHFLAG_ASSIGNED;
            }
        }
    }

    if (pAttrsGot) 
    {
        FreeADsMem(pAttrsGot);
    }

    return hr;
}


CClassContainerCF::CClassContainerCF()
{
    m_uRefs = 1;
    InterlockedIncrement((long *) &gulcInstances );
}

//
// Destructor
//
CClassContainerCF::~CClassContainerCF()
{
    InterlockedDecrement((long *) &gulcInstances );
}

HRESULT  __stdcall  CClassContainerCF::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(ITypeLib *)this;
    }
    else  if( IsEqualIID( IID_IClassFactory, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassFactory *)this;
    } else
    {
        sc = (E_NOINTERFACE);
    }
    
    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainerCF::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainerCF::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;
    
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateInstance
//
//  Synopsis:
//              This is the default create instance on the class factory.
//
//  Arguments:  pUnkOuter - Should be NULL
//              riid      - IID of interface wanted
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
//
HRESULT  __stdcall  CClassContainerCF::CreateInstance(
                                                      IUnknown    *   pUnkOuter,
                                                      REFIID          riid,
                                                      void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE              sc = S_OK;
    
    if( pUnkOuter == NULL )
    {
        if( (pIUnk = new CClassContainer()) != NULL)
        {
            sc = pIUnk->QueryInterface(  riid , ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
            pIUnk->Release();
        }
        else
            sc = E_OUTOFMEMORY;
    }
    else
    {
        return E_INVALIDARG;
    }
    return (sc);
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassContainerCF::CreateConnectedInstance
//
//  Synopsis:
//              This method is called by the ParseDisplayName implementation
//              on the ClassFactory object.
//              When a display name is used to bind to a Class Store
//              an IClassAdmin is returned after binding to the container.
//              This method fails if the bind fails.
//
//  Arguments:  pszPath  - DisplayName of Class Store Container
//              ppvObject - Returns the pointer to the resulting IClassAdmin.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------

HRESULT  __stdcall  CClassContainerCF::CreateConnectedInstance(
                                                               LPOLESTR        pszPath,
                                                               void        **  ppvObject)
{
    CClassContainer *  pIUnk = NULL;
    SCODE              sc = S_OK;
    HRESULT            hr = S_OK;
    
    if ((pIUnk = new CClassContainer(pszPath, &sc)) != NULL)
    {
        if (SUCCEEDED(sc))
        {
            sc = pIUnk->QueryInterface( IID_IClassAdmin, ppvObject );
            if(FAILED(sc))
            {
                sc = E_UNEXPECTED;
            }
        }
        
        pIUnk->Release();
    }
    else
        sc = E_OUTOFMEMORY;
    
    return (sc);
}

HRESULT  __stdcall  CClassContainerCF::LockServer(BOOL fLock)
{
    if(fLock)
    { InterlockedIncrement((long *) &gulcInstances ); }
    else
    { InterlockedDecrement((long *) &gulcInstances ); }
    return(S_OK);
}

//
// IUnknown methods for CClassContainer
//
//

HRESULT  __stdcall  CClassContainer::QueryInterface(REFIID riid, void  * * ppvObject)
{
    IUnknown *pUnkTemp = NULL;
    SCODE     sc = S_OK;
    if( IsEqualIID( IID_IUnknown, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else if( IsEqualIID( IID_IClassAdmin, riid ) )
    {
        pUnkTemp = (IUnknown *)(IClassAdmin *)this;
    }
    else
    {
        sc = (E_NOINTERFACE);
    }
    
    if((pUnkTemp != NULL) && (SUCCEEDED(sc)))
    {
        *ppvObject = (void  * )pUnkTemp;
        pUnkTemp->AddRef();
    }
    return(sc);
}


ULONG __stdcall  CClassContainer::AddRef()
{
    InterlockedIncrement(( long * )&m_uRefs );
    return m_uRefs;
}

ULONG __stdcall  CClassContainer::Release()
{
    unsigned long uTmp = InterlockedDecrement((long *)&m_uRefs);
    unsigned long cRef = m_uRefs;
    
    if (uTmp == 0)
    {
        delete this;
    }
    
    return(cRef);
}


// utility functions
HRESULT UpdateStoreUsn(HANDLE hADs, LPOLESTR szUsn)
{
    ADS_ATTR_INFO       pAttr[1];   
    DWORD               cModified = 0;
    HRESULT             hr = S_OK;
    
    PackStrToAttr(pAttr, STOREUSN, szUsn);
    hr = ADSISetObjectAttributes(hADs, pAttr, 1, &cModified);
    FreeAttr(pAttr[0]);
    return hr;
}


//----------------------------------------------------------
// Implementation for CClassContainer
//----------------------------------------------------------
//
CClassContainer::CClassContainer()

{
    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szCategoryName = NULL;
    m_szPackageName = NULL;

    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));
    
    m_uRefs = 1;
}


//---------------------------------------------------------------
//
//  Function:   Constructor
//
//  Synopsis:   Binds to the ClassStore given a class store path.
//
//  Arguments:
//  [in]    
//      szStoreName
//              Class Store Path without the leading ADCS:
//           
//  [out]
//      phr     
//              Sucess code.
//
//  Does an ADSI bind at the class store container and matches the
//  version numbers. if the version numbers match then it binds to the
//  class, package and category containers and keeps the bind handles.
//----------------------------------------------------------------

CClassContainer::CClassContainer(LPOLESTR szStoreName,
                                 HRESULT  *phr)
                                 
{
    DWORD               dwStoreVersion = 0;
    LPOLESTR            AttrNames[] = {STOREVERSION, POLICYDN};
    ADS_ATTR_INFO     * pAttrsGot = NULL;
    DWORD               cgot = 0, posn = 0;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    
    // set the search preference to one level search
    // and make the results come back in batches of size
    // 20 as default.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;

    // initialising.
    *phr = S_OK;

    m_fOpen = FALSE;
    m_ADsContainer = NULL;
    m_ADsPackageContainer = NULL;
    m_szCategoryName = NULL;
    m_szPackageName = NULL;
    
    m_szPolicyName = NULL;
    memset (&m_PolicyId, 0, sizeof(GUID));

    // Bind to a Class Store Container Object
    // Cache the interface pointer
    //
    wcscpy (m_szContainerName, szStoreName);
    
    *phr = ADSIOpenDSObject(m_szContainerName, NULL, NULL, GetDsFlags(),
        &m_ADsContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    //
    // Check the Schema Version of this container
    //
    
    *phr = ADSIGetObjectAttributes(m_ADsContainer, AttrNames, 2, &pAttrsGot, &cgot);
    
    if ((SUCCEEDED(*phr)) && (cgot))
    {
        posn = GetPropertyFromAttr(pAttrsGot, cgot, STOREVERSION);
        dwStoreVersion = 0;
        if (posn < cgot)
        {
            UnpackDWFrom(pAttrsGot[posn], &dwStoreVersion);

            //
            // Compare the schema with the expected version 
            //
            if (dwStoreVersion != SCHEMA_VERSION_NUMBER)
            {
                *phr = CS_E_INVALID_VERSION;
            }
        }

        if (SUCCEEDED(*phr))
        {
            LPOLESTR        szPolicyPath = NULL, szPolicyName = NULL;

            posn = GetPropertyFromAttr(pAttrsGot, cgot, POLICYDN);
            if (posn < cgot)
            {
                LPOLESTR        szParentPath = NULL, szPolicyGuid = NULL;
                
                UnpackStrFrom(pAttrsGot[posn], &szPolicyPath); 
                //

                BuildADsParentPath(szPolicyPath, &szParentPath, &szPolicyGuid);

                if (szPolicyGuid && szParentPath)
                {
                    if (wcslen(szPolicyGuid) == 41)
                    {
                        // valid GUID

                        GUIDFromString(&szPolicyGuid[4], &m_PolicyId);
                    }

                    *phr = GetGPOName( &szPolicyName );
                }
                else
                {
                    *phr = E_OUTOFMEMORY;
                }

                if (szParentPath)
                    FreeADsMem(szParentPath);

                if (szPolicyGuid)
                    FreeADsMem(szPolicyGuid);
            }

            m_szPolicyName = szPolicyName;
        }
    }
    
    if (pAttrsGot)
        FreeADsMem(pAttrsGot);

    ERROR_ON_FAILURE(*phr);
    
    //
    // Bind to the Package container Object
    // Cache the interface pointer
    //
    
    // get the package container name.
    BuildADsPathFromParent(m_szContainerName, PACKAGECONTAINERNAME, &m_szPackageName);
    
    m_ADsPackageContainer = NULL;
    
    // bind to the package container.
    *phr = ADSIOpenDSObject(m_szPackageName, NULL, NULL, GetDsFlags(),
                            &m_ADsPackageContainer);
    
    ERROR_ON_FAILURE(*phr);
    
    // set the search preference.
    *phr = ADSISetSearchPreference(m_ADsPackageContainer, SearchPrefs, 2);
    ERROR_ON_FAILURE(*phr);
    
    m_fOpen = TRUE;
    m_uRefs = 1;
    
Error_Cleanup:
    *phr = RemapErrorCode(*phr, m_szContainerName);
    return;
}


CClassContainer::~CClassContainer(void)
{
    if (m_fOpen)
    {
        m_fOpen = FALSE;
    }
    
    if (m_ADsPackageContainer)
    {
        ADSICloseDSObject(m_ADsPackageContainer);
        m_ADsPackageContainer = NULL;
    }

    if (m_szPackageName)
        FreeADsMem(m_szPackageName);
    
    if (m_szCategoryName)
        FreeADsMem(m_szCategoryName);

    if (m_ADsContainer)
    {
        ADSICloseDSObject(m_ADsContainer);
        m_ADsContainer = NULL;
    }
}

// currently unused.
BOOL InvalidDSName(LPWSTR pName)
{

    if (wcslen(pName) >= 56)
        return TRUE;

    while (*pName)
    {
        if ((*pName == L':') ||
            (*pName == L',') ||
            (*pName == L';') ||
            (*pName == L'/') ||
            (*pName == L'<') ||
            (*pName == L'>') ||
            (*pName == L'\\')||
            (*pName == L'+'))
            return TRUE;
        ++pName;
    }

    return FALSE;
}

HRESULT  CClassContainer::GetGPOInfo(GUID *pGPOId, LPOLESTR *pszPolicyName)
{
    if ((!pGPOId) || (IsBadWritePtr(pGPOId, sizeof(GUID))))
        return E_INVALIDARG;

    if ((!pszPolicyName) || (IsBadWritePtr(pszPolicyName, sizeof(LPOLESTR))))
        return E_OUTOFMEMORY;

    memcpy(pGPOId, &m_PolicyId, sizeof(GUID));

    if (m_szPolicyName)
    {
        *pszPolicyName = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(1+wcslen(m_szPolicyName)));
        if (!(*pszPolicyName))
            return E_INVALIDARG;
        wcscpy(*pszPolicyName, m_szPolicyName);
    }
    else
    {
        *pszPolicyName = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*2);
        if (!(*pszPolicyName))
            return E_OUTOFMEMORY;

        (*pszPolicyName)[0] = L'\0';
    }
    return S_OK;
}

//---------------------------------------------------------------
//
//  Function:   EnumPackages
//
//  Synopsis:   Returns an Enumerator for all the packages that satisfies
//              the query.
//
//  UsedBy      Add/Remove Programs
//
//  Arguments:
//  [in]    
//      pszFileExt
//              FileExt that has to be queried on. ignored if NULL.
//      pCategory
//              Category that has to be queried on. ignored if NULL.
//      dwAppFlags
//              One of the APPINFO_XXX. ignored if it is APPINFO_ALL.
//      pdwLocale
//              Locale that has to be queried on. Ignored if NULL.
//      pPlatform
//              Platform that has to be queried on. Ignored if NULL.
//              
//  [out]
//      ppIEnumPackage
//              Enumerator is returned. 
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Validates the inputs, Creates a EnumPackage object, makes up the
//  search string made up of file extension, category.
//----------------------------------------------------------------
HRESULT CClassContainer::EnumPackages(
                                      LPOLESTR           pszFileExt,
                                      GUID              *pCategory,
                                      DWORD              dwAppFlags,
                                      DWORD             *pdwLocale,
                                      CSPLATFORM        *pPlatform,
                                      IEnumPackage     **ppIEnumPackage
                                      )
{
    HRESULT                     hr = S_OK;
    CEnumPackage               *pEnum = NULL;
    WCHAR                       szfilter[1000], szQry[1000];

    if (pszFileExt && IsBadStringPtr(pszFileExt, _MAX_PATH))
        return E_INVALIDARG;
    
    if (pCategory && IsBadReadPtr(pCategory, sizeof(GUID)))
        return E_INVALIDARG;
    
    if (IsBadWritePtr(ppIEnumPackage, sizeof(IEnumPackage *)))
        return E_INVALIDARG;
    
    *ppIEnumPackage = NULL;
    
    pEnum = new CEnumPackage(m_PolicyId, m_szPolicyName, m_szContainerName, NULL);
    if(NULL == pEnum)
        return E_OUTOFMEMORY;
    
    //
    // Create a CommandText
    //
    swprintf(szfilter, L"(& (objectClass=%s) ", CLASS_CS_PACKAGE);
        
    if (pszFileExt)
    {
        swprintf(szQry, L"(%s=%s*) ", PKGFILEEXTNLIST, pszFileExt);
        wcscat(szfilter, szQry);
    }
    
    if (pCategory)
    {
        STRINGGUID szCat;
        StringFromGUID (*pCategory, szCat);
        swprintf(szQry, L"(%s=%s) ", PKGCATEGORYLIST, szCat);
        wcscat(szfilter, szQry);
    }
    
    wcscat(szfilter, L")");
    
    hr = pEnum->Initialize(m_szPackageName, szfilter,
        dwAppFlags, FALSE, pPlatform);
    
    ERROR_ON_FAILURE(hr);
    
    hr = pEnum->QueryInterface(IID_IEnumPackage, (void**)ppIEnumPackage);
    ERROR_ON_FAILURE(hr);
    
    return S_OK;
    
Error_Cleanup:
    if (pEnum)
        delete pEnum;
    *ppIEnumPackage = NULL;
    
    return RemapErrorCode(hr, m_szContainerName);
}

HRESULT CClassContainer::GetDNFromPackageName(LPOLESTR pszPackageName, LPOLESTR *szDN)
{
    HRESULT             hr = S_OK;
    WCHAR*              szfilter;
    WCHAR*              szEscapedName;
    LPOLESTR            AttrNames[] = {OBJECTCLASS, PACKAGEFLAGS, OBJECTDN};
    DWORD               cAttr = 3;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;
    DWORD               dwFlags = 0;

    *szDN = NULL;

    szfilter = NULL;

    //
    // To get the DN, we perform a search.  The search filter syntax requires that
    // the package name is properly escaped, so we retrieve such a filter below
    //
    hr = GetEscapedNameFilter( pszPackageName, &szfilter );

    if ( FAILED( hr ) )
    {
        RETURN_ON_FAILURE( hr );
    }

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, AttrNames, cAttr, &hADsSearchHandle);

    CsMemFree( szfilter );

    RETURN_ON_FAILURE(hr);    

    for (hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
	            ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS));
	            hr = ADSIGetNextRow(m_ADsPackageContainer, hADsSearchHandle))
    {
        hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwFlags);
            
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        else
            continue;

        if ((dwFlags & ACTFLG_Orphan) || (dwFlags & ACTFLG_Uninstall))
            continue;

        hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, OBJECTDN, &column);
        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, szDN);
            
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        else
            continue;

        break;

    }
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    
    return hr;
}

// Gets the RDN of a package given the package Guid. 
HRESULT CClassContainer::BuildDNFromPackageGuid(GUID PackageGuid, LPOLESTR *szDN)
{
    HRESULT             hr = S_OK;
    LPOLESTR            AttrName = {OBJECTDN};
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;
    LPWSTR              EncodedGuid = NULL;

    hr = ADsEncodeBinaryData((PBYTE)&PackageGuid, sizeof(GUID), &EncodedGuid);

    swprintf(szfilter, L"(%s=%s)", OBJECTGUID, EncodedGuid);

    FreeADsMem(EncodedGuid);

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szfilter, &AttrName, 1, &hADsSearchHandle);

    RETURN_ON_FAILURE(hr);

    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        ERROR_ON_FAILURE(hr = CS_E_PACKAGE_NOTFOUND);
    }

    hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, AttrName, &column);
    ERROR_ON_FAILURE(hr);

    if (SUCCEEDED(hr))
    {
        UnpackStrAllocFrom(column, szDN);
    }

    ADSIFreeColumn(m_ADsPackageContainer, &column);

Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    return hr;
}

HRESULT CClassContainer::GetPackageGuid(WCHAR *szRDN, GUID *pPackageGuid)
{
    HRESULT             hr = S_OK;
    LPOLESTR            AttrName = {OBJECTGUID};
    WCHAR               szfilter[_MAX_PATH];
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCH_COLUMN   column;

    hr = ADSIExecuteSearch(m_ADsPackageContainer, szRDN, &AttrName, 1, &hADsSearchHandle);

    RETURN_ON_FAILURE(hr);

    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
    {
        ERROR_ON_FAILURE(hr = CS_E_PACKAGE_NOTFOUND);
    }

    hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_OCTET_STRING, AttrName, &column);
    ERROR_ON_FAILURE(hr);

    if (SUCCEEDED(hr))
        UnpackGUIDFrom(column, pPackageGuid);

    ADSIFreeColumn(m_ADsPackageContainer, &column);

Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);

    return hr;
}
//---------------------------------------------------------------
//
//  Function:   GetPackageDetails
//
//  Synopsis:   Returns the PackageDetail corresponding to the PackageName.
//
//  Arguments:
//  [in]    
//      pszPackageId
//              Id of the Package.
//  [out]
//      pPackageDetail
//              PackageDetail info that is returned.
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the Package object and calls GetPackageDetail with it.
//----------------------------------------------------------------
HRESULT CClassContainer::GetPackageDetails (
                                            LPOLESTR          pszPackageName,
                                            PACKAGEDETAIL   * pPackageDetail
                                            )
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL;
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot = 0;
    
    // this can be made into a search based API. Not required for the time being.
    // Should change it if perf is a big issue.
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    // binding to the package object.    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);
    
    // calling GetPackageDetail.
    hr = GetPackageDetail (hADs, NULL, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        CsMemFree(szFullName);
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//
//  Function:   GetPackageDetails
//
//  Synopsis:   Returns the PackageDetail corresponding to the PackageName.
//
//  Arguments:
//  [in]    
//      pszPackageId
//              Id of the Package.
//  [out]
//      pPackageDetail
//              PackageDetail info that is returned.
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Binds to the Package object and calls GetPackageDetail with it.
//----------------------------------------------------------------
HRESULT CClassContainer::GetPackageDetailsFromGuid (
                                                    GUID            PkgGuid,
                                                    PACKAGEDETAIL  *pPackageDetail
                                                   )
{
    HRESULT              hr = S_OK;
    HANDLE               hADs = NULL;
    WCHAR              * szFullName = NULL, szRDN[_MAX_PATH];
    ADS_ATTR_INFO      * pAttr = NULL;
    DWORD                cgot = 0;
    
    // this can be made into a search based API. Not required for the time being.
    // Should change it if perf is a big issue.
    if (IsNullGuid(PkgGuid))
        return E_INVALIDARG;

    BuildDNFromPackageGuid(PkgGuid, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    // binding to the package object.
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);
    
    // calling GetPackageDetail.
    hr = GetPackageDetail (hADs, NULL, pPackageDetail);
    
    ADSICloseDSObject(hADs);
    
    if (pAttr)
        FreeADsMem(pAttr);
    
    if (szFullName)
        CsMemFree(szFullName);

Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}

#define FREEARR(ARR, SZ) {                                          \
                DWORD curIndex;                                     \
                for (curIndex = 0; curIndex < (SZ); curIndex++)     \
                    CsMemFree((ARR)[curIndex]);                 \
                CsMemFree(ARR);                                 \
                ARR = NULL;                                         \
        }                                                           \


//---------------------------------------------------------------
//
//  Function:   ChangePackageUpgradeInfoIncremental
//
//  Synopsis:   Mark the package as upgraded by another package
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Package Guid to identify the package.
//      szUpgradedByClassStore
//              Class Store where the package that upgrades exists
//      UpgradedByPackageGuid
//              The Guid of the package that upgrades
//      Add     Add or remove the upgradedByrelation
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Otherwise it packs all the required attributes in the ATTR_INFO
//  structure and sends it to the Directory.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageUpgradeInfoIncremental(
                         GUID           PackageGuid,
                         UPGRADEINFO    UpgradeInfo,
                         DWORD          OpFlags
                      )
{
    HRESULT         hr = S_OK;
    HANDLE          hADs = NULL;
    WCHAR          *szFullName=NULL, szGuid[_MAX_PATH], szUsn[20];
    LPOLESTR        pProp = NULL;
    ADS_ATTR_INFO   pAttr[2];
    DWORD           cAttr = 0, cModified = 0, i=0;
    UINT            len=0;

    hr = BuildDNFromPackageGuid(PackageGuid, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    // Bind to the Package Object.
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);

    StringFromGUID(UpgradeInfo.PackageGuid, szGuid);

    len = wcslen(UpgradeInfo.szClassStore);
    pProp = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *(36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2+1));
                    // Guid size+::+length++:+flagDigit+2 

    swprintf(pProp, L"%s%s%s%s%02x", UpgradeInfo.szClassStore, PKG_UPG_DELIMITER1, szGuid, PKG_UPG_DELIMITER2, UpgradeInfo.Flag%16);

    PackStrArrToAttrEx(pAttr+cAttr, UPGRADESPACKAGES, &pProp, 1, OpFlags?TRUE:FALSE);
    cAttr++;

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);

    if (hADs)
        ADSICloseDSObject(hADs);
    
    // ignore it if the property already exists.
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS))
        hr = S_OK;

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    
Error_Cleanup:
    if (szFullName)
        CsMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//
//  Function:   ChangePackageProperties
//
//  Synopsis:   Change Various (most commonly changed) properties 
//              for a given package.
//
//  Arguments:
//  [in]    
//      PackageId
//              Package Id to identify the package.
//      pszNewname
//              new Name for the Package. If it is being renamed
//              all other changes should be NULL.
//      pdwFlags
//              The Deployment Flags. Should be ACTFLG_XXX
//              Ignored if NULL.
//      pszUrl
//              Help Url for the Package. Ignored if NULL.
//      pszScriptPath
//              Script Path for the Package. Ignored if NULL.
//      pInstallUiLevel
//              The InstallationUiLevel. Ignored if NULL.
//      pdwRevision
//              REVISION. Ignored if NULL.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Otherwise it packs all the required attributes in the ATTR_INFO
//  structure and sends it to the Directory.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageProperties(
                                                 LPOLESTR       pszPackageName,
                                                 LPOLESTR       pszNewName,
                                                 DWORD         *pdwFlags,
                                                 LPOLESTR       pszUrl,
                                                 LPOLESTR       pszScriptPath,
                                                 UINT          *pInstallUiLevel,
                                                 DWORD         *pdwRevision
                                                 )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szRDN=NULL, *szFullName=NULL;
    WCHAR       szUsn[20];
    ADS_ATTR_INFO pAttr[9];
    DWORD       cAttr = 0, cModified = 0, i=0;
    DWORD       dwNewPackageFlags;
    WCHAR       wszSearchFlags[MAX_SEARCH_FLAGS];

    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;

    // if no properties have to be changed.
    if (!(pszScriptPath || pszUrl || pdwFlags || pInstallUiLevel || pdwRevision || pszNewName))
        return E_INVALIDARG;

    if (pszNewName)
    {
        // rename package

        WCHAR    szNewRDN[_MAX_PATH];
        BOOL     GenerateGuid = FALSE;
        GUID     PackageGuidId;
        WCHAR    pszPackageNewId[_MAX_PATH], *szJunk = NULL;   

        if (IsBadStringPtr(pszNewName, _MAX_PATH))
            return E_INVALIDARG;
        
        if (pszScriptPath || pszUrl || pdwFlags || pInstallUiLevel || pdwRevision)
            return E_INVALIDARG;

        // see whether the new name is valid.
        //        GenerateGuid = InvalidDSName(pszNewName);

        // see whether the newName already exists. Notice that if the same package name is 
        // entered it will return error.
        hr = GetDNFromPackageName(pszNewName, &szJunk);

        if (szJunk)
            CsMemFree(szJunk);
        szJunk = NULL;

        ERROR_ON_FAILURE(hr);

        if (hr == S_OK)
            return CS_E_OBJECT_ALREADY_EXISTS;

        // Bind to the Package Object.
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
                          &hADs);
        if (szFullName)
            CsMemFree(szFullName);
        szFullName = NULL;

        ERROR_ON_FAILURE(hr);
    }
    else 
    {
        // Bind to the Package Object.
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
            &hADs);
        ERROR_ON_FAILURE(hr);

        if (szFullName)
            CsMemFree(szFullName);
        szFullName = NULL;
    }
    
    // Just change some properties.
    //
    // Update the TimeStamp
    //
    
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    if (SUCCEEDED(hr))
    {
        hr = GetConsistentPackageFlags(
            hADs,
            pdwFlags,
            NULL,
            pInstallUiLevel,
            NULL,
            &dwNewPackageFlags,
            wszSearchFlags);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Set Package Flags
        //
        if (pdwFlags)
        {
            PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS, dwNewPackageFlags);
            cAttr++;

            if (*wszSearchFlags) 
            {
                PackStrToAttr(pAttr+cAttr, SEARCHFLAGS, wszSearchFlags);
                cAttr++;
            }
        }
    
        //
        // Change Package Script
        //
        if (pszScriptPath) 
        {
            PackStrToAttr(pAttr+cAttr, SCRIPTPATH, pszScriptPath);
            cAttr++;
        }

        //
        // Change Package Help URL
        //
        if (pszUrl) 
        {
            if ( ! *pszUrl )
            {
                pszUrl = NULL;
            }
            
            PackStrToAttr(pAttr+cAttr, HELPURL, pszUrl);
            cAttr++;
        }
    
        //
        // Change Package UI Level.
        //
        if (pInstallUiLevel) 
        {
            PackDWToAttr (pAttr+cAttr, UILEVEL, *pInstallUiLevel);
            cAttr++;
        }

        //
        // Change Revision.
        //
        if (pdwRevision) 
        {
            PackDWToAttr (pAttr+cAttr, REVISION, *pdwRevision);
            cAttr++;
        }
    
        if (pszNewName)
        {
            PackStrToAttr(pAttr+cAttr, PACKAGENAME, pszNewName);
            cAttr++;

            // also set display name so outside tools can have a
            // friendly name
            PackStrToAttr(pAttr+cAttr, PKGDISPLAYNAME, pszNewName);
            cAttr++;
        }

        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    }

    if (hADs)
        ADSICloseDSObject(hADs);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (SUCCEEDED(hr))
    {
        //
        // Update Class Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (szFullName)
        CsMemFree(szFullName);
    return RemapErrorCode(hr, m_szContainerName);
}
//---------------------------------------------------------------
//  Function:   ChangePackageCategories
//
//  Synopsis:   Change (Not Add) the Categories that a package
//              belongs to.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cCategories
//              Number of Categories.
//      rpCategory
//              Array of categories.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Converts all the categories to strings
//  Packs it and sends it to the DS.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageCategories(
                                                 LPOLESTR       pszPackageName,
                                                 UINT           cCategories,
                                                 GUID          *rpCategory
                                                 )
{
    //
    // Does not change USN
    //
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    LPOLESTR   *pszGuid = NULL;
    UINT        count;
    ADS_ATTR_INFO pAttr[1];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((cCategories) && ((!rpCategory) ||
           (IsBadReadPtr(rpCategory, sizeof(GUID) * cCategories))))
        return E_INVALIDARG;

    // Construct the Name of the Package Object.

    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
       
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);
    
    // fill in the categories
    pszGuid = (LPOLESTR *)CsMemAlloc(cCategories * sizeof(LPOLESTR));
    if (!pszGuid) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }
    
    // convert the GUIDs to Strings.
    for (count = 0; (count < cCategories); count++) 
    {
        pszGuid[count] = (LPOLESTR)CsMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
        
        if (!(pszGuid[count])) 
        {
            FREEARR(pszGuid, count);
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }
        
        StringFromGUID(rpCategory[count], pszGuid[count]);
    }
    
    // Pack it into Attribute Structure.
    PackStrArrToAttr(pAttr+cAttr, PKGCATEGORYLIST, pszGuid, cCategories);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);
    
    if (pszGuid)
        for (count = 0; (count < cCategories); count++)
            CsMemFree(pszGuid[count]);
    
    CsMemFree(pszGuid);

    if (szFullName)
        CsMemFree(szFullName);

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//  Function:   SetPriorityByFileExt
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      pszFileExt
//              File Extension for which the priority has to be changed.
//      Priority
//              Priority for the Package.
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Gets the file Extensions and changes
//  the priority corresponding to the File Extension.
//----------------------------------------------------------------
HRESULT CClassContainer::SetPriorityByFileExt(
                                              LPOLESTR pszPackageName,
                                              LPOLESTR pszFileExt,
                                              UINT     Priority
                                              )
{
    HRESULT       hr = S_OK;
    HANDLE        hADs = NULL;
    WCHAR        *szFullName=NULL;
    LPOLESTR     *prgFileExt = NULL;
    WCHAR         szUsn[20];
    ADS_ATTR_INFO pAttr[4], *pAttrGot = NULL;
    DWORD         cAttr = 0, cAttrGot = 0, cModified = 0, cShellFileExt = 0, i=0;
    LPOLESTR      pAttrNames[] = {PKGFILEEXTNLIST};
    
    // Construct the Package Name
    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
        
    // Bind to the Package Object.
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);
    
    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // get the file extensions.
    hr = ADSIGetObjectAttributes(hADs, pAttrNames, 1,  &pAttrGot,  &cAttrGot);    
    
    if  ((SUCCEEDED(hr)) && (cAttrGot))  
        UnpackStrArrFrom(pAttrGot[0], &prgFileExt, &cShellFileExt);
    
    // Look for the given file extension.
    for (i=0; i < cShellFileExt; ++i)
    {
        if (wcsncmp(prgFileExt[i], pszFileExt, wcslen(pszFileExt)) == 0)
        {
            // if the file extension is found, change the corresponding priority.
            if (wcslen(prgFileExt[i]) != (wcslen(pszFileExt)+3))
                continue;

            swprintf(prgFileExt[i], L"%s:%2d", pszFileExt, Priority%100);
            break;
        }
    }
    
    if (i == cShellFileExt)
    {
        ERROR_ON_FAILURE(hr = CS_E_OBJECT_NOTFOUND);
    }
    
    if (cShellFileExt)
    {
        PackStrArrToAttr(pAttr+cAttr, PKGFILEEXTNLIST, prgFileExt, cShellFileExt);
        cAttr++;
    }
    
    hr = ADSISetObjectAttributes(hADs,  pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:    
    CsMemFree(prgFileExt);
    
    if (szFullName)
        CsMemFree(szFullName);

    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    ADSICloseDSObject(hADs);
    
    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   ChangePackageSourceList
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cSources
//              Number of sources
//      pszSourceList
//              List of sources
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Makes the new sourcelist with the order
// maintained.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageSourceList(
                                                LPOLESTR     pszPackageName,
                                                UINT         cSources,
                                                LPOLESTR    *pszSourceList
                                                )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    UINT        count;
    WCHAR       szUsn[20];
    LPOLESTR   *pszPrioritySourceList = NULL;
    ADS_ATTR_INFO pAttr[2];
    DWORD       cAttr = 0, cModified = 0, i=0;
    
    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((!pszSourceList) ||
           (IsBadReadPtr(pszSourceList, sizeof(LPOLESTR) * cSources)))
        return E_INVALIDARG;
    
    for (count = 0; (count < cSources); count++) 
        if ((!pszSourceList[count]) || (IsBadStringPtr(pszSourceList[count], _MAX_PATH)))
            return E_INVALIDARG;

    // Construct the Name of the Package Object.
    GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
       
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);

    // Local variable for adding the order to the list.
    pszPrioritySourceList = (LPOLESTR *)CsMemAlloc(cSources * sizeof(LPOLESTR));
    if (!pszPrioritySourceList) 
    {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }

    // add the order to the list
    for (count = 0; (count < cSources); count++) 
    {
        pszPrioritySourceList[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(wcslen(pszSourceList[count])+
                                                    1+1+1+NumDigits10(cSources)));
        
        if (!(pszPrioritySourceList[count])) 
        {
            FREEARR(pszPrioritySourceList, count);
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }
        
        swprintf(pszPrioritySourceList[count], L"%d:%s", count, pszSourceList[count]);
    }

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    // Pack it into Attribute Structure.
    PackStrArrToAttr(pAttr+cAttr, MSIFILELIST, pszPrioritySourceList, cSources);
    cAttr++;
    
    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
   
    if (szFullName)
        CsMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}

//---------------------------------------------------------------
//  Function:   ChangePackageUpgradeList
//
//  Synopsis:   Changes the priority of a Package corresp. to
//              a file Extension.
//
//  Arguments:
//  [in]    
//      pszPackageName
//              Package Name to identify the package.
//      cSources
//              Number of sources
//      pszSourceList
//              List of sources
//              
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//  Binds to the Package Object, Makes the new sourcelist with the order
// maintained.
//----------------------------------------------------------------
HRESULT CClassContainer::ChangePackageUpgradeList(
                                                LPOLESTR     pszPackageName,
                                                UINT         cUpgrades,
                                                UPGRADEINFO *prgUpgradeInfoList
                                                )
{
    HRESULT     hr = S_OK;
    HANDLE      hADs = NULL;
    WCHAR      *szFullName = NULL;
    UINT        count = 0, count1 = 0, count2 = 0;
    LPOLESTR   *pProp = NULL, pAttrNames[] = {UPGRADESPACKAGES, OBJECTGUID, PACKAGEFLAGS}, *rpszUpgrades = NULL;
    ADS_ATTR_INFO pAttr[3], *pAttrGot = NULL;
    DWORD       cAttr = 0, cModified = 0, i=0, posn = 0, cUpgradeInfoStored = 0,
                cAddList = 0, cRemoveList = 0, cgot = 0;
    GUID        PkgGuid;
    WCHAR       szUsn[20];
    UPGRADEINFO *pUpgradeInfoStored = NULL, *pAddList = NULL, *pRemoveList = NULL;
    DWORD       dwPackageFlags;

    if ((!pszPackageName) || IsBadStringPtr(pszPackageName, _MAX_PATH))
        return E_INVALIDARG;

    if ((cUpgrades) && ((!prgUpgradeInfoList) ||
           (IsBadReadPtr(prgUpgradeInfoList, sizeof(UPGRADEINFO) * cUpgrades))))
        return E_INVALIDARG;

    for (count = 0; (count < cUpgrades); count++)
    {
        if ((!(prgUpgradeInfoList[count].szClassStore)) || 
            IsBadStringPtr((prgUpgradeInfoList[count].szClassStore), _MAX_PATH))
            return E_INVALIDARG;

        if (IsNullGuid(prgUpgradeInfoList[count].PackageGuid))
            return E_INVALIDARG;

        if (((prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) == 0) &&
            ((prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall) == 0) &&
            ((prgUpgradeInfoList[count].Flag & UPGFLG_UpgradedBy) == 0))
            return E_INVALIDARG;      
    }    

    // Construct the Name of the Package Object.
    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);
    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
                          &hADs);
    ERROR_ON_FAILURE(hr);
   
    // get the guid and upgrade info
    hr = ADSIGetObjectAttributes(hADs, pAttrNames, 3,  &pAttrGot,  &cgot);    
    ERROR_ON_FAILURE(hr);
    
    // Package guid
    posn = GetPropertyFromAttr(pAttrGot, cgot, OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttrGot[posn], &PkgGuid);

    // Upgrade package
    posn = GetPropertyFromAttr(pAttrGot, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
        UnpackStrArrFrom(pAttrGot[posn], &pProp, &cUpgradeInfoStored);

    // Package Flags
    posn = GetPropertyFromAttr(pAttrGot, cgot, PACKAGEFLAGS);
    if (posn < cgot)
        UnpackDWFrom(pAttrGot[posn], (DWORD *)&dwPackageFlags);

    // allocating the lists
    pUpgradeInfoStored = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*(cUpgradeInfoStored));
    pAddList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*(cUpgrades+cUpgradeInfoStored));
    pRemoveList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*(cUpgrades+cUpgradeInfoStored));

    if ((!pUpgradeInfoStored) || (!pAddList) || (!pRemoveList))
        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);

    // convert the strings to upgradinfo structures.
    for (count = 0; count < (cUpgradeInfoStored); count++)
    {
        WCHAR *pStr = NULL;
        LPOLESTR ptr = pProp[count];
        UINT len = wcslen (ptr);
            
        pUpgradeInfoStored[count].szClassStore = pProp[count];

        if (len <= 41)
            continue;

        *(ptr + len - 3) = NULL;
        pUpgradeInfoStored[count].Flag = wcstoul(ptr+(len-2), &pStr, 16);

        *(ptr + len - 3 - 36 - 2) = L'\0';
        /*      -GUID-'::'*/
        GUIDFromString(ptr+len-3-36, &(pUpgradeInfoStored[count].PackageGuid));        
    }

    cUpgradeInfoStored = count; // we might have skipped some.

    // AddList formed.
    for (count = 0; count < cUpgrades; count++)
    {
        for (count1 = 0; count1 < cUpgradeInfoStored; count1++)
        {
            // ignore flag changes
            if ((wcscmp(pUpgradeInfoStored[count1].szClassStore, prgUpgradeInfoList[count].szClassStore) == 0) && 
                (memcmp(&pUpgradeInfoStored[count1].PackageGuid, &prgUpgradeInfoList[count].PackageGuid, sizeof(GUID)) == 0))
                break;
        }

        if (count1 == cUpgradeInfoStored)
            pAddList[cAddList++] = prgUpgradeInfoList[count];
    }

    // remove list formed.
    for (count1 = 0; count1 < cUpgradeInfoStored; count1++)
    {
        for (count = 0; count < cUpgrades; count++)
        {
            // ignore flag changes
            if ((wcscmp(pUpgradeInfoStored[count1].szClassStore, prgUpgradeInfoList[count].szClassStore) == 0) && 
                (memcmp(&pUpgradeInfoStored[count1].PackageGuid, &prgUpgradeInfoList[count].PackageGuid, sizeof(GUID)) == 0))
                break;
        }

        if (count == cUpgrades)
            pRemoveList[cRemoveList++] = pUpgradeInfoStored[count];
    }

    for (count = 0; count < cAddList; count++)
    {
        // in case of UpgradedBy do no try to fix up the links.
        if (!(pAddList[count].Flag & UPGFLG_UpgradedBy))
        {            
            DWORD   Flags = 0;
            if (pAddList[count].Flag & UPGFLG_Enforced)
                Flags = UPGFLG_Enforced;
        }
    }

    for (count = 0; count < cRemoveList; count++)
    {
        // in case of UpgradedBy do no try to fix up the links.
        if (!(pRemoveList[count].Flag  & UPGFLG_UpgradedBy))
        {            
            DWORD   Flags = 0;
            if (pRemoveList[count].Flag & UPGFLG_Enforced)
                Flags = UPGFLG_Enforced;
        }
    }

    rpszUpgrades = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*cUpgrades);
    if (!rpszUpgrades)
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    for (count = 0; (count < cUpgrades); count++) 
    {
        WCHAR szPackageGuid[_MAX_PATH];
        UINT len = wcslen(prgUpgradeInfoList[count].szClassStore);

        rpszUpgrades[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *(36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2));
                                                           // Guid size+::+length++:+flagDigit+2 
        if (!rpszUpgrades[count])
        {
            FREEARR(rpszUpgrades, count);  
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        }

        StringFromGUID(prgUpgradeInfoList[count].PackageGuid, szPackageGuid);
        swprintf(rpszUpgrades[count], L"%s%s%s%s%02x", prgUpgradeInfoList[count].szClassStore, PKG_UPG_DELIMITER1, szPackageGuid,
                        PKG_UPG_DELIMITER2, prgUpgradeInfoList[count].Flag%16);
    }

    PackStrArrToAttr(pAttr+cAttr, UPGRADESPACKAGES, rpszUpgrades, cUpgrades); 
    cAttr++;

    //
    // Update the TimeStamp
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;

    //
    // Update the package flags -- this call will make sure the
    // ugprade flag is set if there are upgrades, clear if not
    //
    hr = GetConsistentPackageFlags(
        NULL,
        &dwPackageFlags,
        &cUpgrades,
        NULL,
        NULL,
        &dwPackageFlags,
        NULL);

    ERROR_ON_FAILURE(hr);

    PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS,
                  dwPackageFlags);
    cAttr++;

    // Set the Attribute
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr,  &cModified);
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    if (hADs)
        ADSICloseDSObject(hADs);

    if (szFullName)
        CsMemFree(szFullName);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);

    if (pAttrGot)
        FreeADsMem(pAttrGot);

    if (pProp)
        CsMemFree(pProp);

    if (pUpgradeInfoStored)
        CsMemFree(pUpgradeInfoStored);
    
    if (pAddList) 
        CsMemFree(pAddList);
    
    if (pRemoveList)
        CsMemFree(pRemoveList);

    return RemapErrorCode(hr, m_szContainerName);
}


extern LPOLESTR szAppCategoryColumns;

//---------------------------------------------------------------
//  Function:   GetAppCategories
//
//  Synopsis:   gets the list of Package Categories in the Domain.
//
//  Arguments:
//  [in]    
//      Locale
//              Locale for the categories. Used to get the description.
//  [out]
//      pAppCategoryList
//              the list of Application Categories in the domain
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, CS_E_XXX
//
//  Gets the FullName of the Domain, binds to the AppCategory container
//  below that. and gets all the categories with approp. types.
//----------------------------------------------------------------

HRESULT CClassContainer::GetAppCategories (
                                           LCID                  Locale,
                                           APPCATEGORYINFOLIST  *pAppCategoryList
                                           )
{
    HRESULT             hr = S_OK;
    WCHAR               szfilter[_MAX_PATH];
    WCHAR               szRootPath[_MAX_PATH], szAppCategoryContainer[_MAX_PATH];
    HANDLE              hADs = NULL;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    ADS_SEARCHPREF_INFO SearchPrefs[2];
    WCHAR*              szContainerNameForErrorReport;

    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    // we do not expect too many categories
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;
    
    if (IsBadWritePtr(pAppCategoryList, sizeof(APPCATEGORYINFOLIST)))
        return E_INVALIDARG;

    // If an error occurs here, we assume it occurred at the domain root
    szContainerNameForErrorReport = L"LDAP://rootdse";

    // get the name of the domain.
    hr = GetRootPath(szRootPath);
    ERROR_ON_FAILURE(hr);

    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    swprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
                                                        szRootPath+LDAPPREFIXLENGTH);

    // If an error occurs now, we use the name of the category container
    szContainerNameForErrorReport = szAppCategoryContainer;
    
    swprintf(szfilter, L"(objectClass=%s)", CLASS_CS_CATEGORY);
    
    //
    // We use the secure option in the bind below because this can get called
    // in client policy context (outside of the admin tool)
    //

    //binds to the category container
    hr = ADSIOpenDSObject(szAppCategoryContainer, NULL, NULL, 
                                                GetDsFlags(), &hADs);
    ERROR_ON_FAILURE(hr);
    
    hr = ADSISetSearchPreference(hADs, SearchPrefs, 2);
    ERROR_ON_FAILURE(hr);
    
    // gets a search handle
    hr = ADSIExecuteSearch(hADs, szfilter, pszCategoryAttrNames, cCategoryAttr, &hADsSearchHandle);
    ERROR_ON_FAILURE(hr);
    
    //
    // Retrieve the list of categories from the search
    // if successful, memory will be allocated for the category list
    //
    hr = FetchCategory(hADs, hADsSearchHandle, pAppCategoryList, Locale);
    ERROR_ON_FAILURE(hr);
    
Error_Cleanup:
    
    if (hADsSearchHandle)
        ADSICloseSearchHandle(hADs, hADsSearchHandle);

    if (hADs)
        ADSICloseDSObject(hADs);
    return RemapErrorCode(hr, szAppCategoryContainer);
}

//---------------------------------------------------------------
//  Function:   RegisterAppCategory
//
//  Synopsis:   Adda category and assoc desc. for the whole Domain(This is per domain
//              and not per class store.)
//
//  Arguments:
//  [in]    
//      pAppCategory
//              Pointer to a APPCATEGORYINFO structure to be added.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Finds the root path of the domain. binds to the category container
//  underneath it. deletes this particular AppCategory.
//----------------------------------------------------------------
HRESULT CClassContainer::RegisterAppCategory (
                                              APPCATEGORYINFO    *pAppCategory
                                              )
{
    WCHAR           szRootPath[_MAX_PATH], localedescription[128+16],
                    szAppCategoryContainer[_MAX_PATH], szRDN[_MAX_PATH],
                  * szFullName = NULL, szAppCatid[_MAX_PATH];

    HRESULT         hr = S_OK;
    HANDLE          hADsContainer = NULL, hADs = NULL;
    ULONG           i, j, cdesc = 0, posn = 0;
    LPOLESTR      * pszDescExisting = NULL, pszDesc = NULL;
    LPOLESTR        AttrName = LOCALEDESCRIPTION;
    ADS_ATTR_INFO * pAttrGot = NULL, pAttr[6];
    DWORD           cgot = 0, cAttr = 0;
    BOOL            fExists = TRUE;
    
    if ((!pAppCategory) || (IsBadReadPtr(pAppCategory, sizeof(APPCATEGORYINFO))))
        return E_INVALIDARG;
    
    if ((pAppCategory->pszDescription == NULL) || 
        (IsBadStringPtr(pAppCategory->pszDescription, _MAX_PATH)))
        return E_INVALIDARG;
    
    if (IsNullGuid(pAppCategory->AppCategoryId))
        return E_INVALIDARG;
    
    //
    // Enforce the maximum category description size
    //
    if ( wcslen(pAppCategory->pszDescription) > CAT_DESC_MAX_LEN )
    {
        return E_INVALIDARG;
    }

    // get the name of the root of the domain
    hr = GetRootPath(szRootPath);
    ERROR_ON_FAILURE(hr);
    
    // Bind to a AppCategory container
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    
    swprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
        szRootPath+LDAPPREFIXLENGTH);
    
    // container is supposed to exist.
    hr = ADSIOpenDSObject(szAppCategoryContainer, NULL, NULL, GetDsFlags(),
                          &hADsContainer);
    ERROR_ON_FAILURE(hr);


    RDNFromGUID(pAppCategory->AppCategoryId, szRDN);
    
    swprintf(localedescription, L"%x %s %s", pAppCategory->Locale, CAT_DESC_DELIMITER,
        pAppCategory->pszDescription);
    
    BuildADsPathFromParent(szAppCategoryContainer, szRDN, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
    
    if (SUCCEEDED(hr))
        hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttrGot, &cgot);

    if (SUCCEEDED(hr))
    {
        fExists = TRUE;
    }
    else 
    {
        fExists = FALSE;
        PackStrToAttr(pAttr, OBJECTCLASS, CLASS_CS_CATEGORY); cAttr++;
        
        PackGUIDToAttr(pAttr+cAttr, CATEGORYCATID, &(pAppCategory->AppCategoryId)); cAttr++;
        
        hr = ADSICreateDSObject(hADsContainer, szRDN, pAttr, cAttr);
        
        for (j = 0; j < cAttr; j++)
            FreeAttr(pAttr[j]);
        cAttr = 0;
        
        if (hADs)
        {
            ADSICloseDSObject(hADs);
            hADs = NULL;
        }
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
    }
    
    if (szFullName)
        FreeADsMem(szFullName);
    
    ERROR_ON_FAILURE(hr);
    
    if (fExists) {
        if (cgot) 
        {
            UnpackStrArrFrom(pAttrGot[0], &pszDescExisting, &cdesc);
        }
        
        // Existing list of descriptions
        if (posn = FindDescription(pszDescExisting, cdesc, &(pAppCategory->Locale), NULL, 0))
        {   // Delete the old value
            PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, pszDescExisting+(posn-1), 1, FALSE); cAttr++;
        }
        CsMemFree(pszDescExisting);
    }
    
    pszDesc = localedescription;
    
    PackStrArrToAttrEx(pAttr+cAttr, LOCALEDESCRIPTION, &pszDesc, 1, TRUE);
    cAttr++;
    
    DWORD cModified;
    hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);
    
Error_Cleanup:
    
    if (pAttrGot)
        FreeADsMem(pAttrGot);
    
    for (i = 0; i < cAttr; i++)
        FreeAttr(pAttr[i]);
    
    if (hADs)
        ADSICloseDSObject(hADs);
    
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);
    
    return RemapErrorCode(hr, m_szContainerName);
}



//---------------------------------------------------------------
//  Function:   UnregisterAppCategory
//
//  Synopsis:   Removes a category from the whole Domain(This is per domain)
//              and not per class store.
//
//  Arguments:
//  [in]    
//      pAppCategoryId
//              Pointer to a GUID that has to be removed.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Finds the root path of the domain. binds to the category container
//  underneath it. deletes this particular AppCategory.
//----------------------------------------------------------------
HRESULT CClassContainer::UnregisterAppCategory (
                                                GUID         *pAppCategoryId
                                                )
{
    WCHAR           szRootPath[_MAX_PATH], szRDN[_MAX_PATH],
                    szAppCategoryContainer[_MAX_PATH];
    HRESULT         hr = S_OK;
    HANDLE          hADs = NULL;
    
    if (IsBadReadPtr(pAppCategoryId, sizeof(GUID)))
        return E_INVALIDARG;
    
    hr = GetRootPath(szRootPath);
    // Bind to a AppCategory container
    
    // Names returned by GetRootPath are in only 1 format and we don't need to
    // use BuildADsPath.
    
    swprintf(szAppCategoryContainer, L"%s%s%s", LDAPPREFIX, APPCATEGORYCONTAINERNAME, 
        szRootPath+LDAPPREFIXLENGTH);
    
    hr = ADSIOpenDSObject(szAppCategoryContainer, NULL, NULL, GetDsFlags(),
                            &hADs);
    
    ERROR_ON_FAILURE(hr);
    
    RDNFromGUID(*pAppCategoryId, szRDN);
    
    hr = ADSIDeleteDSObject(hADs, szRDN);
    
    ADSICloseDSObject(hADs);
    
    // Delete this category
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szContainerName);
}


//---------------------------------------------------------------
//  Function:   DeletePackage
//
//  Synopsis:   Permanently remove a package and the associated Classes 
//              from class store
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Guid of the package that has to be removed.
//
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Deletes the package.
//  Tries to delete all the upgrade relationships from this package.
//  Errors are ignored.
//----------------------------------------------------------------
HRESULT CClassContainer::DeletePackage (LPOLESTR    szFullName
                                        )
{
    HRESULT         hr = S_OK;
    DWORD           cStr = 0, count = 0, cgot = 0, posn = 0;
    LPOLESTR        szRDN = NULL, szJunk = NULL;
    LPOLESTR      * szStr = NULL;
    LPOLESTR        pAttrName[] = {UPGRADESPACKAGES, OBJECTGUID, SCRIPTPATH};
    LPOLESTR        szScriptPath;
    ADS_ATTR_INFO * pAttr = NULL;
    HANDLE          hADs = NULL;
    WCHAR           szUsn[20];
    GUID            PackageGuid;

    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
                            &hADs);
    
    if (!SUCCEEDED(hr))
        return hr;
    
    GetCurrentUsn(szUsn);
    
    hr = ADSIGetObjectAttributes(
        hADs,
        pAttrName,
        sizeof(pAttrName) / sizeof(pAttrName[0]),
        &pAttr, &cgot);

    memset(&PackageGuid, 0, sizeof(GUID));
    posn = GetPropertyFromAttr(pAttr, cgot,  OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &PackageGuid);

    posn = GetPropertyFromAttr(pAttr, cgot,  SCRIPTPATH);
    if (posn < cgot)
    {
        UnpackStrFrom(pAttr[posn], &szScriptPath);
        
        if (szScriptPath)
        {
            BOOL fDeleted;

            fDeleted = DeleteFile(szScriptPath);
            
            CSDBGPrint((DM_WARNING,
                        IDS_CSTORE_DELETESCRIPT,
                        szScriptPath,
                        fDeleted ? ERROR_SUCCESS : GetLastError()));
        }
            
    }

    posn = GetPropertyFromAttr(pAttr, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn],  &szStr, &cStr);

    for (count = 0; count < cStr; count++)
    {
        GUID        UpgradeeGuid;
        WCHAR      *pStr = NULL;
        LPOLESTR    ptr = szStr[count];
        UINT        len = wcslen (ptr);
        DWORD       UpgradeFlag, Flags = 0;

        if (len <= 41)
            continue;

        *(ptr + (len - 3)) = NULL;
                    
        UpgradeFlag = wcstoul(ptr+(len-2), &pStr, 16);

        *(ptr + (len - 3 - 36 - 2)) = L'\0';
                 /*      -GUID-'::'*/
        GUIDFromString(ptr+len-3-36, &UpgradeeGuid);
    
        if (UpgradeFlag & UPGFLG_Enforced)
            Flags = UPGFLG_Enforced;

    }
    
    if (szStr)
        CsMemFree(szStr);
    szStr = NULL;
    cStr = 0;

    // ignore errors
    if (pAttr)
        FreeADsMem(pAttr);
    
    ADSICloseDSObject(hADs);
    
    BuildADsParentPath(szFullName, &szJunk, &szRDN);
    
    if (szJunk)
        FreeADsMem(szJunk);

    hr = ADSIDeleteDSObject(m_ADsPackageContainer, szRDN);
    if (szRDN)
        FreeADsMem(szRDN);

    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    return hr;
}

//---------------------------------------------------------------
//  Function:   RemovePackage
//
//  Synopsis:   Mark a package as disabled or orphaned
//              Or permanently remove a package and the associated Classes 
//              from class store
//
//  Arguments:
//  [in]    
//      PackageGuid
//              Guid of the package that has to be removed.
//  [in]
//      dwFlags
//              The new flags for the package. To delete the package explicitly
//              use flag zero or orphan.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Calls Delete package if the flags is zero or Orphan.
//  Otherwise it sets the new flags and stamps the new time stamp.
//----------------------------------------------------------------
HRESULT CClassContainer::RemovePackage (
                                        LPOLESTR       pszPackageName,
                                        DWORD          dwFlags
                                        )
{
    HRESULT         hr = S_OK;
    WCHAR          *szRDN = NULL, *szFullName = NULL;
    HANDLE          hADs = NULL;
    WCHAR           szUsn[20];
    ADS_ATTR_INFO   pAttr[7];
    DWORD           cAttr = 0, cModified = 0, i=0;

    if ((dwFlags != 0) && !(dwFlags & ACTFLG_Orphan) && !(dwFlags & ACTFLG_Uninstall))
        return E_INVALIDARG;
    
    hr = GetDNFromPackageName(pszPackageName, &szFullName);
    ERROR_ON_FAILURE(hr);

    if (hr != S_OK)
        return CS_E_OBJECT_NOTFOUND;

    if (dwFlags == 0)
        // delete the package from the class store
    {
        hr = DeletePackage(szFullName);
    }
    else
    {
        GUID    NewPackageId;
        WCHAR   szNewRDN[_MAX_PATH], *szRDN = NULL, *szJunk = NULL;
        DWORD   dwPackageFlags;
        WCHAR   wszSearchFlags[MAX_SEARCH_FLAGS];
        //
        // PackageName is unchanged.
        //
        GetCurrentUsn(szUsn);

        // Bind to the Package Object.
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(), &hADs);
        ERROR_ON_FAILURE(hr);

        //
        // We use GetConsistentPackageFlags so that we can add in one flag without
        // resetting the existing flags in the attribute.
        //
        hr = GetConsistentPackageFlags(
            hADs,
            &dwFlags,
            NULL,
            NULL,
            NULL,
            &dwPackageFlags,
            wszSearchFlags);

        ERROR_ON_FAILURE(hr);

        // setting the flag as orphan/uninstall
        PackDWToAttr (pAttr+cAttr, PACKAGEFLAGS, dwPackageFlags);
        cAttr++;

        if (*wszSearchFlags) 
        {
            PackStrToAttr(pAttr+cAttr, SEARCHFLAGS, wszSearchFlags);
            cAttr++;
        }
        
        // stamping the modification time for cleanup later.
        PackStrToAttr (pAttr+cAttr, PKGUSN, szUsn);
        cAttr++;
        
        hr = ADSISetObjectAttributes(hADs, pAttr, cAttr, &cModified);
        
        if (hADs)
            ADSICloseDSObject(hADs);
        
        for (i = 0; i < cAttr; i++)
            FreeAttr(pAttr[i]);
        
        if (SUCCEEDED(hr))
        {
            //
            // Update Class Store Usn
            //
            UpdateStoreUsn(m_ADsContainer, szUsn);
        }
    }
        
Error_Cleanup:
    if (szFullName)
        CsMemFree(szFullName);

    return RemapErrorCode(hr, m_szContainerName);
}

// Merges list1 and List2 into ResList removing duplicates.
HRESULT MergePropList(LPOLESTR    *List1,  DWORD   cList1,
                   LPOLESTR    *List2,  DWORD   cList2,
                   LPOLESTR   **ResList,DWORD  *cResList)
{
    DWORD i, j;
    
    *cResList = 0;
    *ResList = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*(cList1+cList2));
    if (!*ResList)
        return E_OUTOFMEMORY;

    for (i = 0; i < cList1; i++)
        (*ResList)[i] = List1[i];
    
    for (i = 0; i < cList2; i++) {
        for (j = 0; j < cList1; j++)
            if (wcscmp((*ResList)[j], List2[i]) == 0)
                break;
            
            if (j == cList1)
                (*ResList)[(*cResList)++] = List2[i];
    }

    return S_OK;
}


#define SCRIPT_IN_DIRECTORY    256

//---------------------------------------------------------------
//  Function:   RedeployPackage
//
//  Synopsis:   Redeploys an package object in the DS with new
//              package detail information
//
//  Arguments:
//
//  [in] 
//      pPackageGuid
//              Points to a guid indicating the package we wish
//              to redeploy
//
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and sets those attributes on the existing object in the ds.
//  If this returns an error the existing package is unaffected.
//
//----------------------------------------------------------------
HRESULT CClassContainer::RedeployPackage (
    GUID* pPackageGuid,
    PACKAGEDETAIL *pPackageDetail
    )
{
    HANDLE  hExistingPackage;
    HRESULT hr;
    WCHAR*  szFullName;

    hExistingPackage = NULL;
    szFullName = NULL;

    //
    // First, get the dn for the existing package
    //
    hr = BuildDNFromPackageGuid(*pPackageGuid, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    //
    // Bind to the existing package
    //
    hr = ADSIOpenDSObject(
        szFullName,
        NULL,
        NULL,
        GetDsFlags(),
        &hExistingPackage);

    ERROR_ON_FAILURE(hr);

    //
    // Now we can redeploy it with the new package detail. We
    // pass in a NULL package guid param because we won't
    // be changing the package id.
    //
    hr = DeployPackage(
        hExistingPackage,
        pPackageDetail,
        NULL);

Error_Cleanup:

    if (szFullName)
    {
        CsMemFree(szFullName);
    }
    
    if (hExistingPackage)
    {
        ADSICloseDSObject(hExistingPackage);
    }

    return hr;
}

//---------------------------------------------------------------
//  Function:   AddPackage
//
//  Synopsis:   Adds a package object in the DS.
//
//  Arguments:
//  [out]    
//      pszPackageId
//              An Id that is returned corresponding to the package.
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and tries to create the object in the DS.
//  If this returns error
//                     the whole package is removed.
//----------------------------------------------------------------
HRESULT CClassContainer::AddPackage (
                                     PACKAGEDETAIL *pPackageDetail,
                                     GUID          *pPkgGuid
                                     )
{

    //
    // Validate parameters specific to AddPackage, then
    // let the DeployPackage function do the rest of the validation
    // common between this and other methods that use it
    //
    if (!pPkgGuid || IsBadReadPtr(pPkgGuid, sizeof(GUID)))
    {
        return E_INVALIDARG;
    }


    return DeployPackage(
        NULL,               // create a new package
        pPackageDetail,
        pPkgGuid);
}

//---------------------------------------------------------------
//  Function:   DeployPackage
//
//  Synopsis:   Deploys a package object in the DS.
//
//  Arguments:
//  [in]       
//      hExistingPackage 
//              Handle to an existing package to redeploy.  If NULL,
//              a new package is created 
//                
//  [out]    
//      pszPackageId
//              An Id that is returned corresponding to a new package.
//              Must be specified if hExistingPackage is NULL.  Not set
//              on return of hExistingPackage is non-NULL.
//
//  [in]
//      pPackageDetail
//              Pointer to a PACKAGEDETAIL info for this package
//              The various validations that is done is documented
//              in associated class store doc.
//            
//  Returns:
//      S_OK, E_OUTOFMEMORY, E_INVALIDARG, CS_E_XXX
//
//  Validates the packagedetail structure. Packs ADS_ATTR_INFO structure with
//  the values and tries to create and / or set attributes
//  for the package the object in the DS.
//  If this returns error when creating a new package, the whole package is removed.
//  If this returns error when redeploying an existing package, the existing 
//  package is unaffected.
//----------------------------------------------------------------
HRESULT CClassContainer::DeployPackage(
    HANDLE        hExistingPackage,
    PACKAGEDETAIL *pPackageDetail,
    GUID          *pPkgGuid
    )
{
    HRESULT             hr = S_OK;
    WCHAR               szRDN [_MAX_PATH];
    LPOLESTR          * pszGuid1 = NULL, *pszGuid2 = NULL,
                      * pszGuid3 = NULL, *pszGuid4 = NULL,
                      * pszProgId = NULL, *pszFileExt = NULL,
                      * rpszUpgrades = NULL, *rpszSources = NULL,
                        szPackageId = NULL, szJunk = NULL;

    DWORD             * pdwArch=NULL, count = 0, cPackProgId = 0;
    ADS_ATTR_INFO       pAttr[30]; 
    DWORD               cAttr = 0;
    WCHAR               szUsn[20];
    BOOL                fPackageCreated = FALSE, GenerateGuid = FALSE;
    GUID                PackageGuidId;
    DWORD               dwPersistedPackageFlags;
    WCHAR               wszSearchFlags[MAX_SEARCH_FLAGS];
    BOOL                bCreateNewPackage;
    
    bCreateNewPackage = hExistingPackage ? FALSE : TRUE;

    if ((!(pPackageDetail->pszPackageName)) || 
                IsBadStringPtr((pPackageDetail->pszPackageName), _MAX_PATH))
        return E_INVALIDARG;


    if (!pPackageDetail)
        return E_INVALIDARG;
    
    if (IsBadReadPtr(pPackageDetail, sizeof(PACKAGEDETAIL)))
        return E_INVALIDARG;
    
    // validating ActivationInfo.
    if (pPackageDetail->pActInfo)
    {    
        if (IsBadReadPtr(pPackageDetail->pActInfo, sizeof(ACTIVATIONINFO)))
            return E_INVALIDARG;
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->pClasses,
            sizeof(CLASSDETAIL) * (pPackageDetail->pActInfo->cClasses)))
            return E_INVALIDARG;

        // validating classdetail
        for (count = 0; (count < (pPackageDetail->pActInfo->cClasses)); count++)
        {
            CLASSDETAIL *pClassDetail = (pPackageDetail->pActInfo->pClasses)+count;
            if (IsNullGuid(pClassDetail->Clsid))
               return E_INVALIDARG;

            for (DWORD count1 = 0; (count1 < (pClassDetail->cProgId)); count1++)
            {
                // if profid is NULL or an empty string.
                if ((!((pClassDetail->prgProgId)[count1])) || 
                    (!((pClassDetail->prgProgId)[count1][0])))
                    return E_INVALIDARG;
            }
        }
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgShellFileExt,
            sizeof(LPOLESTR) * (pPackageDetail->pActInfo->cShellFileExt)))
            return E_INVALIDARG;
        
        for (count = 0; count < (pPackageDetail->pActInfo->cShellFileExt); count++)
        {
            if (!pPackageDetail->pActInfo->prgShellFileExt[count])
                return E_INVALIDARG;
        }
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgPriority,
            sizeof(UINT) * (pPackageDetail->pActInfo->cShellFileExt)))
            return E_INVALIDARG;
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgInterfaceId,
            sizeof(IID) * (pPackageDetail->pActInfo->cInterfaces)))
            return E_INVALIDARG;
        
        if (IsBadReadPtr(pPackageDetail->pActInfo->prgTlbId,
            sizeof(GUID) * (pPackageDetail->pActInfo->cTypeLib)))
            return E_INVALIDARG;
    }
    
    // Validating InstallInfo
    if ((pPackageDetail->pInstallInfo == NULL) || 
        (IsBadReadPtr(pPackageDetail->pInstallInfo, sizeof(INSTALLINFO)))
        )
        return E_INVALIDARG;

    //
    // Only validate the product code if we expect one to be
    // supplied -- this is only the case if this is a Windows
    // Installer package, other deployments will not have
    // a product code
    //
    if ( DrwFilePath == pPackageDetail->pInstallInfo->PathType )
    {
        if (IsNullGuid(pPackageDetail->pInstallInfo->ProductCode))
            return E_INVALIDARG;
    }

    if (IsBadReadPtr(pPackageDetail->pInstallInfo->prgUpgradeInfoList, 
        sizeof(UPGRADEINFO)*(pPackageDetail->pInstallInfo->cUpgrades)))
        return E_INVALIDARG;
    
    for (count = 0; count < (pPackageDetail->pInstallInfo->cUpgrades); count++)
    {
        if ((!(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore)) || 
            IsBadStringPtr((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore), _MAX_PATH))
            return E_INVALIDARG;

        if (IsNullGuid(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].PackageGuid))
            return E_INVALIDARG;

        if (((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_Uninstall) == 0) &&
            ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_NoUninstall) == 0) &&
            ((pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag & UPGFLG_UpgradedBy) == 0))
            return E_INVALIDARG;      
    }    
    
    // validating PlatformInfo    
    
    if ((pPackageDetail->pPlatformInfo == NULL) || 
        (IsBadReadPtr(pPackageDetail->pPlatformInfo, sizeof(PLATFORMINFO)))
        )
        return E_INVALIDARG;
    
    if (IsBadReadPtr(pPackageDetail->pPlatformInfo->prgPlatform,
        sizeof(CSPLATFORM) * (pPackageDetail->pPlatformInfo->cPlatforms)))
        return E_INVALIDARG;
    
    if ((pPackageDetail->pPlatformInfo->cLocales == 0) ||
        (pPackageDetail->pPlatformInfo->cPlatforms == 0))
        return E_INVALIDARG;
    
    if (IsBadReadPtr(pPackageDetail->pPlatformInfo->prgLocale,
        sizeof(LCID) * (pPackageDetail->pPlatformInfo->cLocales)))
        return E_INVALIDARG;
    
    // validating InstallInfo
    
    // Validating other fields in PackageDetail structure
    
    if ((pPackageDetail->pszSourceList == NULL) ||
        (IsBadReadPtr(pPackageDetail->pszSourceList,
        sizeof(LPOLESTR) * (pPackageDetail->cSources))))
        return E_INVALIDARG;
    
    for (count = 0; count < (pPackageDetail->cSources); count++)
    {
        if ((!pPackageDetail->pszSourceList[count]) || 
                        (IsBadStringPtr(pPackageDetail->pszSourceList[count], _MAX_PATH)))
            return E_INVALIDARG;
    }
    
    if (pPackageDetail->rpCategory)
    {
        if (IsBadReadPtr(pPackageDetail->rpCategory,
            sizeof(GUID) * (pPackageDetail->cCategories)))
            return E_INVALIDARG;
    }

    // If the restrictions are too constrictive then we should go to
    // the DS, to see whether it is a valid name or not. till then..

    hr = GetDNFromPackageName(pPackageDetail->pszPackageName, &szJunk);
    if (szJunk)
        CsMemFree(szJunk);

    if (FAILED(hr))
        return RemapErrorCode(hr, m_szContainerName);

    //
    // We expect this to return S_ADS_NOMORE_ROWS if the package doesn't
    // exist, otherwise it returns S_OK -- we can use this to determine
    // if the package exists already (we care only if we're trying to 
    // create a new package)
    //
    if ( bCreateNewPackage && (hr == S_OK))
    {
        return CS_E_OBJECT_ALREADY_EXISTS;
    }
    else
    {
        ASSERT( bCreateNewPackage || (S_ADS_NOMORE_ROWS == hr) || ( hExistingPackage && (hr == S_OK) ) );
    }

    szPackageId = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*41);

    if (!(szPackageId))
        return E_OUTOFMEMORY;

    memset(&PackageGuidId, 0, sizeof(GUID));

    //
    // generate guid if we are creating a new package -- otherwise, we don't
    // need it 
    //
    if (bCreateNewPackage) 
    {
        CreateGuid(&PackageGuidId);
        StringFromGUID(PackageGuidId, szPackageId);

        //
        // Create the RDN for the Package Object
        //

        swprintf(szRDN, L"CN=%s", szPackageId);

        //
        // Only set this attribute when creating a new object -- 
        // Otherwise, a constraint violation will occur since it is
        // not permissible to change an object's class
        //
        PackStrToAttr(pAttr+cAttr, OBJECTCLASS, CLASS_CS_PACKAGE); cAttr++;
    }
    
    // fill in the activation info
    
    // add the class to the packagecontainer list
    
    if (pPackageDetail->pActInfo)
    {
        BOOL bWriteClasses;
        BOOL bWriteEmptyValue;
        UINT cClasses;
        UINT cSourceClasses;

        bWriteClasses = pPackageDetail->pActInfo->bHasClasses;
        bWriteEmptyValue = ! pPackageDetail->pActInfo->bHasClasses;

        cClasses = 0;
        cSourceClasses = pPackageDetail->pActInfo->cClasses;

        cPackProgId = 0;

        if ( ! pPackageDetail->pActInfo->bHasClasses )
        {
            cSourceClasses = 0;
        }

        //
        // To be consistent with NT5, we will not set the clsid or progid properties when the user has specified
        // that we deploy classes but there are none.  If the user has not specified that we should deploy
        // classes, we will still set this property, but it will be zero-length
        //

        if ( bWriteClasses )
        {
            if ( cSourceClasses )
            {
                pszGuid1 = (LPOLESTR *)CsMemAlloc(cSourceClasses*sizeof(LPOLESTR));
                if (!pszGuid1) {
                    ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
                }
            
                for (count = 0; count < cSourceClasses; count++) 
                {
                    WCHAR   szCtx[9];

                    pszGuid1[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(STRINGGUIDLEN+9));
                    if (!pszGuid1[count]) {
                        FREEARR(pszGuid1, count);
                        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);                                
                    }

                    StringFromGUID(pPackageDetail->pActInfo->pClasses[count].Clsid, pszGuid1[count]);
                    swprintf(szCtx, L":%8x", pPackageDetail->pActInfo->pClasses[count].dwComClassContext);
                    wcscat(pszGuid1[count], szCtx);
                    cPackProgId += pPackageDetail->pActInfo->pClasses[count].cProgId;
                }

                cClasses = cSourceClasses;
            }
        }

        LPOLESTR  wszNullGuid; 
        LPOLESTR* ppszClsids;

        ppszClsids = pszGuid1;

        //
        // If required, write the blank clsid value so that
        // the NT 5.1 ADE can determine if this package has class information.  Note that
        // an NT 5.0 ADE will never see this because this uses a null guid -- both 
        // NT 5.0 and 5.1 ADE's will never accept a request from a caller to search
        // for a null guid.
        //
        if ( bWriteEmptyValue )
        {
            wszNullGuid = PKG_EMPTY_CLSID_VALUE;
            ppszClsids = &wszNullGuid;
            cClasses = 1;
        }
        
        //
        // If there are no clsids, this will cause the value to be cleared
        //
        if ( cClasses || ! bCreateNewPackage )
        {
            PackStrArrToAttr(pAttr+cAttr, PKGCLSIDLIST, ppszClsids,  cClasses); cAttr++; 
        }

        if ( bWriteClasses )
        {
            // collecting all the progids from the various clsids.
            pszProgId = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*cPackProgId);
            if (!pszProgId) {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
        
            //
            // Reset our count of progid's -- we need to check for duplicates, so we
            // do not assume that we will have as many progid's as we allocated space for above --
            // we will increment the count for each unique progid we encounter.
            //
            cPackProgId = 0;

            for (count = 0; count < cSourceClasses; count++) {
                // for each clsid
                DWORD cClassProgId, j = 0;
                for (cClassProgId = 0; cClassProgId < pPackageDetail->pActInfo->pClasses[count].cProgId;
                     cClassProgId++) 
                {
                    // for each progid within ClassDetail
                    for (j = 0; j < cPackProgId; j++)
                    {
                        if (_wcsicmp(pszProgId[j], 
                                     pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId]) == 0)
                            break;
                    }
                    // needs to be added if there are no dups.
                    if (j == cPackProgId)
                    {
                        pszProgId[cPackProgId] =
                            pPackageDetail->pActInfo->pClasses[count].prgProgId[cClassProgId];
                        _wcslwr(pszProgId[cPackProgId]);
                        cPackProgId++;
                    }
                }
            }
        }
        else
        {
            //
            // Reset this so that we clear out progid's if we are not writing any
            //
            cPackProgId = 0;
        }

        //
        // If there are no clsids, this will cause the value to be cleared
        //
        if ( cPackProgId || ! bCreateNewPackage )
        {
            PackStrArrToAttr(pAttr+cAttr, PROGIDLIST, pszProgId, cPackProgId); cAttr++;
        }

        CsMemFree(pszProgId);
        
        if (pPackageDetail->pActInfo->cShellFileExt) {
            //
            // Store a tuple in the format <file ext>:<priority>
            //
            pszFileExt = (LPOLESTR *)CsMemAlloc((pPackageDetail->pActInfo->cShellFileExt) * sizeof(LPOLESTR));
            if (!pszFileExt)
            {
                hr = E_OUTOFMEMORY;
                ERROR_ON_FAILURE(hr);
            }
            for (count = 0; count < pPackageDetail->pActInfo->cShellFileExt; count++)
            {
                pszFileExt[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *
                    (wcslen(pPackageDetail->pActInfo->prgShellFileExt[count])+1+2+1));
                if (!pszFileExt[count]) 
                {
                    FREEARR(pszFileExt, count);
                    ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
                }
                // format is fileext+:+nn+NULL where nn = 2 digit priority
                swprintf(pszFileExt[count], L"%s:%2d",
                    pPackageDetail->pActInfo->prgShellFileExt[count],
                    pPackageDetail->pActInfo->prgPriority[count]%100);

                _wcslwr(pszFileExt[count]);
            }
            PackStrArrToAttr(pAttr+cAttr, PKGFILEEXTNLIST, pszFileExt,
                pPackageDetail->pActInfo->cShellFileExt); cAttr++;
        }
        
        //
        // Note: we no longer persist interfaces in the ds as this information
        // is not used
        //
    }
   
    // fill in the platforminfo
    
    // 
    // Note that the os version contained in this structure is not referenced in the os
    //
    if (pPackageDetail->pPlatformInfo->cPlatforms) {
        pdwArch = (DWORD *)CsMemAlloc(sizeof(DWORD)*(pPackageDetail->pPlatformInfo->cPlatforms));
        if (!pdwArch)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; (count < (pPackageDetail->pPlatformInfo->cPlatforms)); count++)
            UnpackPlatform (pdwArch+count, (pPackageDetail->pPlatformInfo->prgPlatform)+count);
        
        PackDWArrToAttr(pAttr+cAttr, ARCHLIST, pdwArch, pPackageDetail->pPlatformInfo->cPlatforms);
        cAttr++;
    }
    
    if (pPackageDetail->pPlatformInfo->cLocales) {
        PackDWArrToAttr(pAttr+cAttr, LOCALEID, pPackageDetail->pPlatformInfo->prgLocale,
            pPackageDetail->pPlatformInfo->cLocales);
        cAttr++;
    }
    
    // fill in the installinfo
    
    PackStrToAttr(pAttr+cAttr, PACKAGENAME, pPackageDetail->pszPackageName);
    cAttr++;

    // also include display name so that outside tools can get a friendly description
    PackStrToAttr(pAttr+cAttr, PKGDISPLAYNAME, pPackageDetail->pszPackageName);
    cAttr++;

    PackDWToAttr(pAttr+cAttr, PACKAGETYPE, (DWORD)(pPackageDetail->pInstallInfo->PathType));
    cAttr++;
    
    if (pPackageDetail->pInstallInfo->pszScriptPath) {
        PackStrToAttr(pAttr+cAttr, SCRIPTPATH, pPackageDetail->pInstallInfo->pszScriptPath);
        cAttr++;
    }
    
    if (pPackageDetail->pInstallInfo->pszSetupCommand) {
        PackStrToAttr(pAttr+cAttr, SETUPCOMMAND, pPackageDetail->pInstallInfo->pszSetupCommand);
        cAttr++;
    }
    
    if (pPackageDetail->pInstallInfo->pszUrl) {
        PackStrToAttr(pAttr+cAttr, HELPURL, pPackageDetail->pInstallInfo->pszUrl);
        cAttr++;
    }
    
    //
    // Store the current USN
    //
    GetCurrentUsn(szUsn);
    
    PackStrToAttr(pAttr+cAttr, PKGUSN, szUsn);
    cAttr++;
    
    // package flags

    dwPersistedPackageFlags = pPackageDetail->pInstallInfo->dwActFlags |
        ACTFLG_POSTBETA3;

    //
    // Now set the flags so that they reflect the state of this package
    //
    hr = GetConsistentPackageFlags(
        NULL,
        &dwPersistedPackageFlags,
        &(pPackageDetail->pInstallInfo->cUpgrades),
        &(pPackageDetail->pInstallInfo->InstallUiLevel),
        &(pPackageDetail->pInstallInfo->PathType),
        &dwPersistedPackageFlags,
        wszSearchFlags);

    ERROR_ON_FAILURE(hr);

    //
    // Add in a flag indicating this is a post-Beta 3 deployment
    //
    PackDWToAttr(pAttr+cAttr, PACKAGEFLAGS, dwPersistedPackageFlags);
    cAttr++;

    if (*wszSearchFlags) 
    {
        PackStrToAttr(pAttr+cAttr, SEARCHFLAGS, wszSearchFlags);
        cAttr++;
    }
    
    // product code, different from pkg guid
    PackGUIDToAttr(pAttr+cAttr, PRODUCTCODE, &(pPackageDetail->pInstallInfo->ProductCode));
    cAttr++;
    
    // Mvipc
    PackGUIDToAttr(pAttr+cAttr, MVIPC, &(pPackageDetail->pInstallInfo->Mvipc));
    cAttr++;

    // Hi Version of the package
    PackDWToAttr(pAttr+cAttr, VERSIONHI, pPackageDetail->pInstallInfo->dwVersionHi);
    cAttr++;

    
    // Low Version of the package
    PackDWToAttr(pAttr+cAttr, VERSIONLO, pPackageDetail->pInstallInfo->dwVersionLo);
    cAttr++;
    
    // Revision
    PackDWToAttr(pAttr+cAttr, REVISION, pPackageDetail->pInstallInfo->dwRevision);
    cAttr++;

    // uilevel
    PackDWToAttr (pAttr+cAttr, UILEVEL, (DWORD)pPackageDetail->pInstallInfo->InstallUiLevel);
    cAttr++;
    
    // adding cUpgrade number of Classstore/PackageGuid combinations
    if (pPackageDetail->pInstallInfo->cUpgrades) 
    {
        WCHAR szPackageGuid[_MAX_PATH];

        rpszUpgrades = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*pPackageDetail->pInstallInfo->cUpgrades);
        if (!rpszUpgrades)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++) 
        {
            UINT len = wcslen(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore);
            rpszUpgrades[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR) *(36+PKG_UPG_DELIM1_LEN+len+PKG_UPG_DELIM2_LEN+2+2));
                                                        // Guid size+::+length++:+flagDigit+2 
            if (!rpszUpgrades[count])
            {
                FREEARR(rpszUpgrades, count);  
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
            }

            StringFromGUID(pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].PackageGuid, 
                            szPackageGuid);
            swprintf(rpszUpgrades[count], L"%s%s%s%s%02x",
                        pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].szClassStore,
                        PKG_UPG_DELIMITER1,
                        szPackageGuid,
                        PKG_UPG_DELIMITER2, 
                        pPackageDetail->pInstallInfo->prgUpgradeInfoList[count].Flag%16);
        }
          
        PackStrArrToAttr(pAttr+cAttr, UPGRADESPACKAGES, rpszUpgrades,
            pPackageDetail->pInstallInfo->cUpgrades); 
        cAttr++;
    }
    
    // Fill in the source list 
    // Maintain the serial number associated with the sources. Order matters!!
    if (pPackageDetail->cSources) 
    {
        rpszSources = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*(pPackageDetail->cSources));
        if (!rpszSources)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; count < (pPackageDetail->cSources); count++) 
        {
            rpszSources[count] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(wcslen(pPackageDetail->pszSourceList[count])+
                                                    1+1+NumDigits10(pPackageDetail->cSources)));
            if (!rpszSources[count])
            {
                FREEARR(rpszSources, count);
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
            }
            swprintf(rpszSources[count], L"%d:%s", count, pPackageDetail->pszSourceList[count]);
        }
        
        PackStrArrToAttr(pAttr+cAttr, MSIFILELIST, rpszSources, pPackageDetail->cSources);
        cAttr++;
    }
    
    // fill in the categories
    // Add the package Categories
    if (pPackageDetail->cCategories)
    {
        pszGuid4 = (LPOLESTR *)CsMemAlloc((pPackageDetail->cCategories) * sizeof(LPOLESTR));
        if (!pszGuid4)
        {
            ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        for (count = 0; (count < pPackageDetail->cCategories); count++)
        {
            pszGuid4[count] = (LPOLESTR)CsMemAlloc(STRINGGUIDLEN*sizeof(WCHAR));
            if (!pszGuid4[count])
            {
                FREEARR(pszGuid4, count);
                ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            
            StringFromGUID((pPackageDetail->rpCategory)[count], pszGuid4[count]);
        }
        
        PackStrArrToAttr(pAttr+cAttr, PKGCATEGORYLIST, pszGuid4, pPackageDetail->cCategories);
        cAttr++;
    }
    
    // fill in the vendor
    
    // Publisher
    if (pPackageDetail->pszPublisher) 
    {
        PackStrToAttr(pAttr+cAttr, PUBLISHER, pPackageDetail->pszPublisher);
        cAttr++;
    }

    //
    // Create a new package if specified by the caller
    //
    if (bCreateNewPackage) 
    {
        hr = ADSICreateDSObject(m_ADsPackageContainer, szRDN, pAttr, cAttr);
        ERROR_ON_FAILURE(hr);

        memset(pPkgGuid, 0, sizeof(GUID));

        hr = GetPackageGuid(szRDN, pPkgGuid);
    }
    else
    {
        DWORD cModified;

        //
        // The caller specified us to use an existing package -- do not 
        // create a new one, just set the attributes for the existing package.
        // The ADSISetObjectAttributes call will either set all attributes or
        // none -- so if it fails, the package is just as it was 
        // before we attempted to redeploy.
        //
        hr = ADSISetObjectAttributes(hExistingPackage, pAttr, cAttr, &cModified);
    }

    ERROR_ON_FAILURE(hr);

    fPackageCreated = bCreateNewPackage ? TRUE : FALSE;

    if (!(pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_Uninstall) &&
        !(pPackageDetail->pInstallInfo->dwActFlags & ACTFLG_Orphan))
    {
        if (pPackageDetail->pInstallInfo->cUpgrades)
        {
            for (count = 0; (count < pPackageDetail->pInstallInfo->cUpgrades); count++)
                CsMemFree(rpszUpgrades[count]);
            CsMemFree(rpszUpgrades);
        }
    }
    
    if (SUCCEEDED(hr))
    {
        //
        // Update Store Usn
        //
        UpdateStoreUsn(m_ADsContainer, szUsn);
    }
    
Error_Cleanup:
    for (count = 0; count < cAttr; count++)
        FreeAttr(pAttr[count]);
    
    if (pszGuid1) {
        for (count = 0; (count < pPackageDetail->pActInfo->cClasses); count++)
            CsMemFree(pszGuid1[count]);
        CsMemFree(pszGuid1);
    }
    
    if (pszGuid2) {
        for (count = 0; (count < (pPackageDetail->pActInfo->cInterfaces)); count++)
            CsMemFree(pszGuid2[count]);
        CsMemFree(pszGuid2);
    }
    
    if (pszGuid3) {
        for (count = 0; (count < (pPackageDetail->pActInfo->cTypeLib)); count++)
            CsMemFree(pszGuid3[count]);
        CsMemFree(pszGuid3);
    }
    
    if (pszGuid4) {
        for (count = 0; (count < pPackageDetail->cCategories); count++)
            CsMemFree(pszGuid4[count]);
        CsMemFree(pszGuid4);
    }
    
    if (pszFileExt) {
        for (count = 0; (count < pPackageDetail->pActInfo->cShellFileExt); count++)
            CsMemFree(pszFileExt[count]);
        CsMemFree(pszFileExt);
    }
    
    if (pdwArch) {
        CsMemFree(pdwArch);
    }
    
    if (rpszSources) 
    {
        for (count = 0; (count < pPackageDetail->cSources); count++)
            CsMemFree(rpszSources[count]);
        CsMemFree(rpszSources);
    }

    //
    // On failure, the package should be removed from the ds if we
    // created it there.
    //
    if (FAILED(hr) && (fPackageCreated))
    {
        HRESULT hrDeleted;
        LPWSTR  wszPackageFullPath;

        //
        // Need to get a full path to the package in order to delete it.
        //
        hrDeleted = BuildADsPathFromParent(m_szPackageName, szRDN, &wszPackageFullPath);

        ASSERT(SUCCEEDED(hrDeleted));

        CSDBGPrint((DM_WARNING, IDS_CSTORE_ROLLBACK_ADD, wszPackageFullPath));

        hrDeleted = DeletePackage(wszPackageFullPath);

        //
        // Free the full path
        //
        CsMemFree(wszPackageFullPath);
    }

    return RemapErrorCode(hr, m_szContainerName);
}

//+
//
// Cleanup old packages from Class Store based on lastChangeTime
//

HRESULT CClassContainer::Cleanup (
                                  FILETIME        *pTimeBefore
                                  )
{
    //
    // Delete all packages marked as "Uninstall"
    // OR "Orphan" and are older than the time given
    //
    
    ULONG               cRowsFetched = 0;
    ADS_SEARCH_HANDLE   hADsSearchHandle = NULL;
    WCHAR               szFilter[_MAX_PATH], szRDN[_MAX_PATH];
    HRESULT             hr = S_OK;
    ADS_ATTR_INFO       pAttr;
    SYSTEMTIME          SystemTime;
    ADS_SEARCH_COLUMN   column;
    DWORD               dwPackageFlags;
    LPOLESTR            pszPackageId = NULL;
    
    if ((!pTimeBefore) ||
        IsBadReadPtr(pTimeBefore, sizeof(FILETIME)))
        return E_INVALIDARG;

    FileTimeToSystemTime(
        (CONST FILETIME *) pTimeBefore, 
        &SystemTime);  
    
    swprintf (szFilter, 
        L"(%s<=%04d%02d%02d%02d%02d%02d)", 
        PKGUSN,
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);

    CSDBGPrint((DM_VERBOSE, 
                IDS_CSTORE_CLEANSCRIPTS, 
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond));
    
    // execute the search and keep the handle returned.
    hr = ADSIExecuteSearch(m_ADsPackageContainer, szFilter, pszDeleteAttrNames,
        cDeleteAttr, &hADsSearchHandle);
    
    hr = ADSIGetFirstRow(m_ADsPackageContainer, hADsSearchHandle);
    
    while (TRUE)
    {
        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;
        
        dwPackageFlags = 0;
        
        // Get the Package State
        hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);
        
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwPackageFlags);
            ADSIFreeColumn(m_ADsPackageContainer, &column);
        }
        
        //
        // Check flag values to see if this package is Orphaned or Uninstalled
        //
        
        if ((dwPackageFlags & ACTFLG_Orphan) || (dwPackageFlags & ACTFLG_Uninstall)) 
        {
            
            hr = DSGetAndValidateColumn(m_ADsPackageContainer, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, OBJECTDN, &column);
            
            if (SUCCEEDED(hr))
            {
                WCHAR    * szDN = NULL;

                UnpackStrFrom(column, &szDN);
                hr = DeletePackage(szDN);

                CSDBGPrint((DM_WARNING,
                            IDS_CSTORE_DELPACKAGE,
                            szDN,
                            dwPackageFlags,
                            hr));

                ADSIFreeColumn(m_ADsPackageContainer, &column);
                ERROR_ON_FAILURE(hr);
            }
        }
        hr = ADSIGetNextRow(m_ADsPackageContainer, hADsSearchHandle);  
    }
    
Error_Cleanup:
    if (hADsSearchHandle)
        ADSICloseSearchHandle(m_ADsPackageContainer, hADsSearchHandle);
    return RemapErrorCode(hr, m_szContainerName);
}

HRESULT CClassContainer::GetGPOName( WCHAR** ppszPolicyName )
{
    HRESULT        hr;

    HANDLE         hGpo;

    ADS_ATTR_INFO* pAttr;
    LPOLESTR       AttrNames[] = {GPNAME};

    DWORD          cgot;
    DWORD          posn;

    WCHAR*         wszGpoPath;

    pAttr = NULL;
    hGpo = NULL;

    //
    // This object contains the path to a class store container --
    // this path is of the form LDAP://CN=ClassStore,CN=User,<gpopath>.
    // This means that the gpo path is shorter than the class store path,
    // and we can allocate memory accordingly.
    //
    DWORD cbClassStorePath;

    cbClassStorePath = lstrlen( m_szContainerName ) * sizeof ( *m_szContainerName );

    wszGpoPath = (WCHAR*) CsMemAlloc( cbClassStorePath );

    if ( ! wszGpoPath )
    {
        hr = E_OUTOFMEMORY;
        goto GetGpoName_ExitAndCleanup;
    }

    WCHAR* wszGpoSubPath;

    //
    // Get past the prefix
    //
    wszGpoSubPath = StripLinkPrefix( m_szContainerName );

    //
    // Now get past the next two delimiters
    //
    wszGpoSubPath = wcschr( wszGpoSubPath, L',' ) + 1;
    wszGpoSubPath = wcschr( wszGpoSubPath, L',' );

    //
    // Move one past the last delimiter -- we are now at the gpo path
    //
    wszGpoSubPath++;

    //
    // Create the resultant path starting with the prefix
    //
    lstrcpy( wszGpoPath, LDAPPREFIX );

    //
    // Append the gpo path -- we now have a fully qualified
    // LDAP path to the GPO
    //
    lstrcat( wszGpoPath, wszGpoSubPath );
    
    hr = ADSIOpenDSObject(
        wszGpoPath,
        NULL,
        NULL,
        GetDsFlags(),
        &hGpo);

    if (FAILED(hr))
    {
        goto GetGpoName_ExitAndCleanup;
    }

    //
    // Now get the friendly name of this gpo
    //
    hr = ADSIGetObjectAttributes(
        hGpo,
        AttrNames, 
        sizeof(AttrNames) / sizeof(*AttrNames),
        &pAttr,
        &cgot);
    
    if ( SUCCEEDED(hr) ) 
    {
        ASSERT( 1 == cgot );

        UnpackStrAllocFrom(pAttr[0], ppszPolicyName);

        if ( ! *ppszPolicyName )
        {
            hr = E_OUTOFMEMORY;
        }
    }

GetGpoName_ExitAndCleanup:
        
    if ( pAttr )
    {
        FreeADsMem( pAttr );
    }

    if (hGpo)
    {
        ADSICloseDSObject( hGpo );
    }

    if (wszGpoPath)
    {
        CsMemFree( wszGpoPath );
    }

    return hr;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\cstore.h ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:    cstore.h
//
//  Header for class store
//-------------------------------------------------------------------------
#if _MSC_VER > 1000
#pragma once
#endif

#include "cs.h"

void GetDefaultPlatform(CSPLATFORM *pPlatform,
                        BOOL        fArchitectureOverride = FALSE ,
                        LONG        OverridingArchitecture = 0);

BOOL InitializeClassStore(BOOL fInit);
void Uninitialize();

STDAPI CsGetClassAccess(IClassAccess     **     ppIClassAccess);

STDAPI CsEnumApps(LPOLESTR        pszPackageName,
        GUID            *pCategory,
        ULONGLONG       *pLastUsn,
        DWORD           dwAppFlags,
        IEnumPackage    **ppIEnumPackage);

STDAPI CsGetAppInfo(uCLSSPEC       *   pclsspec,
         QUERYCONTEXT   *   pQueryContext,
         PACKAGEDISPINFO    *   pPackageInfo);

STDAPI CsCreateClassStore(LPWSTR szPath);
STDAPI CsGetClassStore(LPWSTR szPath, void **ppIClassAdmin);
STDAPI CsDeleteClassStore(LPWSTR szPath);
STDAPI CsGetAppCategories(APPCATEGORYINFOLIST *pAppCategoryList);
STDAPI CsRegisterAppCategory(APPCATEGORYINFO *pAppCategory);
STDAPI CsUnregisterAppCategory (GUID *pAppCategoryId);
STDAPI CsGetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR *pCSPath);
STDAPI CsSetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR szCSPath);
STDAPI ReleasePackageInfo(PACKAGEDISPINFO *pPackageInfo);
STDAPI ReleaseInstallInfo(INSTALLINFO *pInstallInfo);
STDAPI ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail);
STDAPI ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryInfoList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\cslang.cxx ===
//+--------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Author: AdamEd
//  Date:   October 1998
//
//  Implementation of language support
//  in the Class Store interface module
//
//
//---------------------------------------------------------------------


#include "cstore.hxx"

LANGID gSystemLangId;


//+--------------------------------------------------------------------
//
// InitializeLanguageSupport
//
// Routine Description: 
//
//     Called at dll init to initialize globals necessary for
//     language support
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     none
//---------------------------------------------------------------------
void InitializeLanguageSupport()
{
    gSystemLangId = GetSystemDefaultLangID();
}


DWORD GetLanguagePriority(LANGID PackageLangId, DWORD dwActFlags)
{
    //
    // If the activation flags indicate that we should always
    // match regardless of language, this package gets the highest
    // precedence
    //
    if (dwActFlags & ACTFLG_IgnoreLanguage) {
        return PRI_LANG_ALWAYSMATCH;
    }

    //
    // The ignore language flag was not specified by the admin,
    // so now we must examine the language id of the package to
    // determine its desirability.
    //

    //
    // First, match against the system locale's language --
    // exact matches get highest priority
    //
    if (gSystemLangId == PackageLangId)
    {
        return PRI_LANG_SYSTEMLOCALE;
    }

    //
    // Try English -- English should function on all systems
    //
    if (LANG_ENGLISH == PRIMARYLANGID(PackageLangId))
    {
        return PRI_LANG_ENGLISH;
    }

    //
    // If we couldn't get better matches, accept language neutral
    // packages as a last resort
    //
    if (LANG_NEUTRAL == PackageLangId) {
        return PRI_LANG_NEUTRAL;
    }

    //
    // We couldn't find a match -- return the smallest priority
    //

    return 0;
}








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\cspath.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  Author: AdamEd
//  Date:   October 1998
//
//      Class Store path query / persistence
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

HRESULT
GetAppmgmtIniFilePath(
    PSID        pSid,
    LPWSTR*     ppwszPath
    )
{
    UNICODE_STRING  SidString;
    PTOKEN_USER     pTokenUser;
    WCHAR           wszPath[MAX_PATH];
    WCHAR *         pwszSystemDir;
    DWORD           AllocLength;
    DWORD           Length;
    DWORD           Size;
    DWORD           Status;
    BOOL            bStatus;

    Status = ERROR_SUCCESS;
    *ppwszPath = 0;

    pwszSystemDir = wszPath;
    AllocLength = sizeof(wszPath) / sizeof(WCHAR);

    for (;;)
    {
        Length = GetSystemDirectory(
                    pwszSystemDir,
                    AllocLength );

        if ( 0 == Length )
            return HRESULT_FROM_WIN32(GetLastError());

        if ( Length >= AllocLength )
        {
            AllocLength = Length + 1;
        
            //
            // No check for failure of alloca since it throws an 
            // exception on failure
            //
            pwszSystemDir = (WCHAR *) alloca( AllocLength * sizeof(WCHAR) );

            continue;
        }

        break;
    }

    if ( pSid )
    {
        if ( ERROR_SUCCESS == Status )
        {
            Status = RtlConvertSidToUnicodeString(
                                &SidString,
                                pSid,
                                TRUE );
        }

        if ( Status != ERROR_SUCCESS )
            return HRESULT_FROM_WIN32(Status);
    }
    else
    {
        RtlInitUnicodeString( &SidString, L"MACHINE" );
    }

    // System dir + \appmgmt\ + Sid \ + inifilename \ + null 
    *ppwszPath = new WCHAR[Length + 11 + (SidString.Length / 2) +
                          (sizeof(APPMGMT_INI_FILENAME) / sizeof(WCHAR))];

    if ( *ppwszPath )
    {
        lstrcpy( *ppwszPath, pwszSystemDir );
        if ( pwszSystemDir[lstrlen(pwszSystemDir)-1] != L'\\' )
            lstrcat( *ppwszPath, L"\\" );
        lstrcat( *ppwszPath, L"appmgmt\\" );
        lstrcat( *ppwszPath, SidString.Buffer );
        lstrcat( *ppwszPath, APPMGMT_INI_FILENAME );
    }
    else
    {
        Status = ERROR_OUTOFMEMORY;
    }

    if ( pSid )
        RtlFreeUnicodeString( &SidString );

    return HRESULT_FROM_WIN32(Status);
}

LONG
GetClassStorePathSize(
    HANDLE hFile,
    DWORD* pdwSize)
{
    BOOL    bStatus;
    DWORD   cbSizeHigh;

    //
    // Initialize the size to the length of an empty path -- this way
    // if no file is passed in we will treat that as a class store path 
    // of zero length (excluding the terminator).  This length must include
    // the terminator, so we set our initial size to that of an empty string
    //
    *pdwSize = sizeof(L'\0');

    //
    // If we have an open file with data, determine the size of the data
    //
    if ( hFile )
    {
        //
        // GetFileSize returns the logical size of the file, regardless
        // of whether the logical size is the same as the physical 
        // size due to the vagaries of different file systems or compression
        //
        *pdwSize = GetFileSize(
            hFile,
            &cbSizeHigh);

        //
        // Check for a failure from the api
        //
        if ( -1 == *pdwSize )
        {
            return GetLastError();
        }

        //
        // Check the size for validity -- a file of ridiculous
        // size will be rejected
        //
        if ( cbSizeHigh )
        {
            //
            // If the high dword is set, clearly this file
            // contains an unreasonable amount of data
            //
            return ERROR_INSUFFICIENT_BUFFER;
        } 
        else if ( *pdwSize > MAX_CSPATH_SIZE )
        {
            //
            // Again, the size should be within reasonable limits
            //
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }

    return ERROR_SUCCESS;
}



LONG 
ReadClassStorePathFromFile(
    HANDLE hFile,
    WCHAR* wszDestination,
    DWORD  cbSize)
{
    DWORD  cbRead;
    BOOL   bStatus;

    //
    // The format of the file is simple -- it is simply the stream of bytes
    // that represent a unicode string terminated by a null unicode character -- 
    // we can just read the data directly and copy it to a buffer referenced by
    // a WCHAR* -- it will be legitimate unicode string once we read it in -- it includes
    // the null unicode char as the last byte read
    //
    
    //
    // Note that we've read nothing so far
    //
    cbRead = 0;

    //
    // If the file has data, read it
    //
    if ( cbSize )
    {
        //
        // Read the data from the file into the buffer
        //
        bStatus = ReadFile(
            hFile,
            wszDestination,
            cbSize,
            &cbRead,
            NULL);

        if (!bStatus)
        {
            return GetLastError();
        }

        //
        // Verify that the last character read was a null unicode character.
        // If it wasn't, the file is corrupt -- return an error so we don't
        // try to use the corrupt data and cause repeated errors or even crashes
        //
        if ( wszDestination[ cbRead / sizeof(*wszDestination) - 1 ] != L'\0' )
        {
            return ERROR_FILE_CORRUPT;
        }
    }
    else
    {
        //
        // For empty files, we simply return an empty unicode string
        //
        wszDestination[ 0 ] = L'\0';
    }

    return ERROR_SUCCESS;
}


HRESULT ReadClassStorePath(PSID pSid, LPWSTR* ppwszClassStorePath)
{
    HRESULT hr;
    LPWSTR  wszIniFilePath;
    DWORD   cbSize;
    WCHAR*  wszClassStorePath;
    LONG    Status;
    HANDLE  hFile;

    //
    // Notes: The file being read by this function was originally an
    // ini file as generated by the WritePrivateProfileSection api.
    // Unfortunately, the corresponding GetPrivateProfileString was horribly
    // broken in the sense that it had a 32k limit on the size of values.  This
    // was not acceptable for our design, so we read the file directly
    //

    hr = GetAppmgmtIniFilePath(
        pSid,
        &wszIniFilePath);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Initialize our reference to conditionally freed data
    //
    wszClassStorePath = NULL;

    //
    // First, attempt to open the file, which should already exist.  We
    // generally do not expect concurrent readers, as there
    // are only two processes from which this file is read: services
    // and winlogon.  Neither should be reading it at the same time, though
    // a terminal server case where the same user was logged in to the machine
    // twice could cause it
    //
    hFile = CreateFile(
        wszIniFilePath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    //
    // Handle the failure cases
    //
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        //
        // We want to use NULL to indicate the absence of the file
        //
        hFile = NULL;

        Status = GetLastError();

        //
        // If the file did not exist, that's ok -- we interpret the
        // absence of the file as a blank class store path -- we
        // will not exit if the file didn't exist
        //
        if (ERROR_FILE_NOT_FOUND != Status) 
        {
            goto cleanup_and_exit;
        }
    }
     
    //
    // Now that we have access to the file or know that the file does
    // not exist, we can calculate the size of the class store path
    // from the file's size, as they have a 1-1 relationship.  Note that if the
    // file does not exist, then hFile will be NULL
    //
    Status = GetClassStorePathSize(
        hFile,
        &cbSize);

    if ( ERROR_SUCCESS != Status )
    {
        goto cleanup_and_exit;
    }

    //
    // We know the size, so allocate space, treating the size 
    // as the length (in bytes) of the string including the terminator
    //
    wszClassStorePath = new WCHAR [ cbSize / sizeof(*wszClassStorePath) ];

    if ( wszClassStorePath )
    {
        //
        // We have a buffer, so read the unicode string into
        // the buffer
        //
        Status = ReadClassStorePathFromFile(
            hFile,
            wszClassStorePath,
            cbSize);
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

cleanup_and_exit:

    //
    // We no longer need the path to the ini file -- free it
    //
    delete [] wszIniFilePath;

    //
    // Close the file if it's open
    //
    if ( hFile )
    {
        CloseHandle( hFile );
    }

    //
    // On success, set the out param.  On failure,
    // free any buffer we allocated for the class store path
    //
    if (ERROR_SUCCESS == Status)
    {
        *ppwszClassStorePath = wszClassStorePath;
    }
    else
    {
        delete [] wszClassStorePath;
    }

    return HRESULT_FROM_WIN32(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\dsapi.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2001
//
//  Author: AdamEd
//  Date:   January 2000
//
//      Abstractions for directory service layer
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

HRESULT
DSGetAndValidateColumn(
    HANDLE             hDSObject,
    ADS_SEARCH_HANDLE  hSearchHandle,
    ADSTYPE            ADsType,
    LPWSTR             pszColumnName,
    PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr;

    //
    // First, instruct adsi to unmarshal the data into
    // the column
    //
    hr = ADSIGetColumn(
        hDSObject,
        hSearchHandle,
        pszColumnName,
        pColumn);

    //
    // Validate the returned data
    //
    if ( SUCCEEDED(hr) )
    {
        //
        // Verify that the type information is correct --
        // if it is not, we cannot safely interpret the data.
        // Incorrect type information is most likely to happen
        // when adsi is unable to download the schema, possibly
        // due to kerberos errors
        //
        if ( ADsType != pColumn->dwADsType )
        {
            //
            // We need to free the column, since the caller is not
            // expected to free it if we return a failure
            //
            ADSIFreeColumn( hDSObject, pColumn );

            hr = CS_E_SCHEMA_MISMATCH;
        }
    }

    return hr;
}


HRESULT DSAccessCheck(
    PSECURITY_DESCRIPTOR pSD,
    PRSOPTOKEN           pRsopUserToken,
    BOOL*                pbAccessAllowed
    )
{
    GENERIC_MAPPING DS_GENERIC_MAPPING = { 
        GENERIC_READ_MAPPING,
        GENERIC_WRITE_MAPPING,
        GENERIC_EXECUTE_MAPPING,
        GENERIC_ALL_MAPPING };

    DWORD   dwAccessMask;                               
    HRESULT hr;

    hr = RsopAccessCheckByType(pSD,
                               0,
                               pRsopUserToken,
                               GENERIC_READ,
                               NULL,
                               0,
                               &DS_GENERIC_MAPPING,
                               NULL,
                               NULL,
                               &dwAccessMask,
                               pbAccessAllowed );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\csmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:    csmain.cxx
//
//  Contents:    All the exposed APIs.
//
//  Author:    DebiM
//
//-------------------------------------------------------------------------

#include "cstore.hxx"

//  Globals

//
// Class Factory Objects
//

CClassContainerCF   *   g_pCF       = NULL;
CAppContainerCF     *   pCF         = NULL; 
CClassAccessCF      *   pCSAccessCF = NULL;

// Debugging Output Global values.
DWORD                    gDebugLog = 0;
DWORD                    gDebugOut = 0;
DWORD                    gDebugEventLog = 0;
DWORD                    gDebug = 0;

//
//   Number of objects alive in cstore.dll
//

long ObjectCount = 0;

//
// Critical Section for All Global Objects.
//
CRITICAL_SECTION ClassStoreBindList;


//-------------------------------------------------------------------
//  Function        Uninitialize
//
//  Synopsis:       Class Store Server Uninitialization.
//                  Disconnects from all Class Containers in use.
//                  Flushes out all State information using ResetClassStoreState.
//                  Unregisters Server registrations etc..
//
//  Arguments:      None
//
//  Returns:        None
//
//-------------------------------------------------------------------
void Uninitialize()
{
    //
    // Cleanup all open containers
    //

    //ResetClassStoreState();
    //
    // release the Class Factory objects
    //
    if (pCF)
        pCF->Release();
    if (pCSAccessCF)
        pCSAccessCF->Release();

    if (g_pCF)
        g_pCF->Release();
    //
    // get rid of the critical section
    //

    DeleteCriticalSection(&ClassStoreBindList);

}


//+---------------------------------------------------------------
//
//  Function:   InitDebugValues
//
//  Synopsis:   Initializes the Debug Values for the class store.
//
//  Arguments:
//   
//  Returns:
//      S_OK
//
// Log will go into the Debugger if the first bit is 1.
// If second bit is set, log will go into a log file.
// If third bit is set, log will go into event log.
//
// Note that the above is only true of DL_CSTORE is specified --
// if not, there is no debug output for the cstore component
//
// The gDebugLevel variable is initialized by the InitDebugSupport
// call in the common static library
//
//----------------------------------------------------------------
void InitDebugValues()
{
    gDebugEventLog = gDebugLevel & DL_EVENTLOG;
    gDebugLog = gDebugLevel & DL_LOGFILE;
    gDebugOut = gDebugLevel & DL_NORMAL;

    gDebug = (gDebugLevel & DL_CSTORE) && (gDebugOut || gDebugLog || gDebugEventLog);
}

//---------------------------------------------------------------------------
//
//  Function:   InitializeClassStore
//
//  History:    7-25-96   DebiM   Created
//
//  This entry point is called at DLL attach
//----------------------------------------------------------------------------
BOOL InitializeClassStore(BOOL fInit)
{
    HRESULT     hr;
    BOOL        bStatus;
    
    ObjectCount = 1;

    InitDebugValues();

    InitializeLanguageSupport();

    pCF = new CAppContainerCF();
    pCSAccessCF = new CClassAccessCF();
    InitializeCriticalSection(&ClassStoreBindList);

    g_pCF = new CClassContainerCF;

    if (!pCF || !pCSAccessCF || !g_pCF)
    {
        return FALSE;
    }

    return TRUE;
}



void
GetDefaultPlatform(CSPLATFORM *pPlatform,
                   BOOL        fArchitectureOverride,
                   LONG        OverridingArchitecture)
{
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId;
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;
 
    //
    // Allow the caller to specify an overriding architecture for
    // cases where the default logic (use the current platform) is
    // not sufficient (demand install of inproc servers)
    //
    if ( fArchitectureOverride )
    {
        pPlatform->dwProcessorArch = OverridingArchitecture;
    }
    else
    {
        pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CsGetClassAccess
//
//  Synopsis:   Returns an instantiated interface to the Class Store
//              Co-ordinator object in Rpcss.
//
//  Arguments:  [ppIClassAccess] - where to put class access interface pointer
//
//  Returns:    S_OK - Got a Class Access Successfully
//              E_FAIL
//
//--------------------------------------------------------------------------

STDAPI CsGetClassAccess(
    IClassAccess     **     ppIClassAccess)
{
    HRESULT     hr;
    *ppIClassAccess = NULL;

    hr = pCSAccessCF->CreateInstance( NULL, 
        IID_IClassAccess, 
        (void **)ppIClassAccess);

    return hr;

}

//+-------------------------------------------------------------------
//
// CsEnumApps (DebiM 11/7/97)
//
// Returns an enumerator for packages in the Class Store (s).
// The enumerator works across all class stores in the calling users profile.
//
//
// This is used by:
//    - Add/Remove programs to select Corporate Apps
//    - winlogon to obtain the list of assigned apps
//
// Arguments:
//  [in]
//        pszPackageName    :   Optional Wildcard string for PackageName
//        pLastUsn          :   Optional Time Stamp for new packages
//        pCategory         :   Optional CategoryId
//        dwAppFlags        :   Per APPINFO_xxx in objbase.h
//  [out]
//        ppIEnumPackage    :   Returned Interface Pointer
//
// Returns :
//      S_OK or E_NO_CLASSSTORE
//
//--------------------------------------------------------------------
STDAPI
CsEnumApps(
        LPOLESTR        pszPackageName,    // Wildcard string for PackageName
        GUID            *pCategory,        // CategoryId
        ULONGLONG       *pLastUsn,         // Time Stamp for new packages
        DWORD           dwAppFlags,        // Per APPINFO_xxx in objbase.h
        IEnumPackage    **ppIEnumPackage   // Returned Interface Pointer
        )
{
    HRESULT         hr;
    IClassAccess  * pIClassAccess = NULL;

    *ppIEnumPackage = NULL;

    //
    // Get an IClassAccess 
    //
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    //
    // Get the enumerator
    //
    hr = pIClassAccess->EnumPackages (
        pszPackageName,
        pCategory,
        pLastUsn,
        dwAppFlags,
        ppIEnumPackage
        );

    pIClassAccess->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetAppInfo
//  
//  Synopsis:   Gets Package Information for a package that matches
//              the query.
//
//  Used By:
//              services. CoCreateInstance (OLE)
//
//  Arguments:
//  [in]
//      pClassSpec: 
//              The query consisting of the name or clsid or ... 
//      pQueryContext:
//              Execution context, architecture/Platform/locale req'd, 
//              Default value is the ThreadLocale and the default Platform.
//
//  [out]
//      pPackageInfo
//              Neccessary Package Information.
//           
//  Returns :
//      S_OK, CS_E_XXX errors.
// 
//  Looks up the given class specification in the DS.  If an application for
//  this class specification is found, then the application details are returned.
//  Gets the IClassAccess Pointer and calls GetAppInfo on it.
//
//  Caller needs to FREE the pPackageInfo using the Release APIs.
//--------------------------------------------------------------------

STDAPI
CsGetAppInfo(
         uCLSSPEC          *   pClassSpec,            // Class Spec (GUID/Ext/MIME)
         QUERYCONTEXT      *   pQueryContext,
         PACKAGEDISPINFO   *   pPackageInfo
         )
{
    HRESULT         hr = S_OK;
    IClassAccess  * pIClassAccess = NULL;
    
    // Gets the IClassAccess pointer
    hr = CsGetClassAccess(&pIClassAccess);
    if (!SUCCEEDED(hr))
        return hr;

    // Calls the GetAppInfo method 
    hr = pIClassAccess->GetAppInfo(pClassSpec, pQueryContext, pPackageInfo );
    pIClassAccess->Release();
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CsCreateClassStore
//  
//  Synopsis:   Creates the class store.
//
//  Used By:
//              mmc snapin.
//
//  Arguments:
//  [in]
//      szCSPath: 
//              Path where a new class store has to be created.
//           
//  Returns :
//      S_OK, CS_E_XXX errors.
// 
//  Gets the parent containers Name (GPO)
//  and the name of the class store. Creates a Class Store with this name
//  Below the parent object. 
//--------------------------------------------------------------------

STDAPI
CsCreateClassStore(LPOLESTR szCSPath) 
{
    LPOLESTR szPath = NULL;
    LPOLESTR szParentPath=NULL, szStoreName=NULL;
    HRESULT  hr = S_OK;
    LPOLESTR szPolicyName = NULL, szUserMachine = NULL;

    szPath = szCSPath;

    // Getting the path for the parent (Policy object) from the name.
    hr = BuildADsParentPath(szPath, &szParentPath, &szStoreName);

    ERROR_ON_FAILURE(hr);

    // Get the Policy Object
    hr = BuildADsParentPath(szParentPath, &szPolicyName, &szUserMachine);
    if (!SUCCEEDED(hr))
    {
        szPolicyName = NULL;
    }

    if (szUserMachine)
        FreeADsMem(szUserMachine);

    // creating class store. returns CS_E_XXX errors when it returns.
    hr = CreateRepository(szParentPath, szStoreName, szPolicyName);
    
Error_Cleanup:

    if (szPolicyName)
        FreeADsMem(szPolicyName);

    if (szParentPath)
        FreeADsMem(szParentPath);

    if (szStoreName)
        FreeADsMem(szStoreName);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetClassStore
//  
//  Synopsis:   Gets the IClassAdmin interface pointer for the input class store.
//
//  Used By:
//              mmc snapin.
//
// Arguments:
//  [in]
//      szPath: 
//              Unicode Path For the Class Store.
//         
//  [out]
//      ppIClassAdmin: 
//              IClassAdmin interface pointer.
//              
//
// Returns :
//      S_OK, or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsGetClassStore(LPOLESTR szPath, void **ppIClassAdmin)
{
    return g_pCF->CreateConnectedInstance(
                  szPath, 
                  ppIClassAdmin);
}

//+---------------------------------------------------------------
//
//  Function:   CsDeleteClassStore
//
//  Synopsis:   Public entrypoint for deleting a class store container from DS.
//              Not implemented.
//
//----------------------------------------------------------------

STDAPI
CsDeleteClassStore(LPOLESTR szPath)
{
    return E_NOTIMPL;

}

//+-------------------------------------------------------------------
//
//  Function:   CsRegisterAppCategory
//  
//  Synopsis:   Registers a cetegory under the Domain.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  Arguments:
//  [in]
//      pAppCategory:   
//              Category and its details that have to be added.
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsRegisterAppCategory(APPCATEGORYINFO *pAppCategory)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->RegisterAppCategory(pAppCategory);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsUnregisterAppCategory 
//  
//  Synopsis:   Unregister an AppCategory from the Domain.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  Arguments:
//  [in]
//      pAppCategoryId:   
//              Guid (category) that has to be unregistered.
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
//--------------------------------------------------------------------
STDAPI
CsUnregisterAppCategory (GUID *pAppCategoryId)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->UnregisterAppCategory(pAppCategoryId);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetAppCategories 
//  
//  Synopsis:   get the definitive list of Application Categories and descriptions
//              based on default Locale.
//
//  Used By:
//              This is used by Add/Remove programs.
//
//  *Comments*:
//              The caller needs to free the memory allocated using CsMemFree().
//
//  Arguments:
//  [out]
//      AppCategoryList:   
//              Returned list of GUIDs and Unicode descriptions
//
//  Returns :
//      S_OK or CS_E_XXX error codes.
// 
//  Gets the list of Categories published in the Domain.
//  The CALLER needs to FREE the memory using Release API.
//--------------------------------------------------------------------
STDAPI
CsGetAppCategories (APPCATEGORYINFOLIST  *pAppCategoryList)
{
    HRESULT         hr = S_OK;
    IClassAdmin   * pIClassAdmin = NULL;

    // get the interface pointer
    hr = g_pCF->CreateInstance(
                  NULL,
                  IID_IClassAdmin, 
                  (void **)&pIClassAdmin);

    if (!SUCCEEDED(hr))
        return hr;

    // get the app categories list.
    hr = pIClassAdmin->GetAppCategories (
                                         GetUserDefaultLCID(), 
                                         pAppCategoryList);

    // release the interface pointer.
    pIClassAdmin->Release();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CsGetClassStorePath
//  
//  Synopsis:   Returns the class store path.
//
//  Used By:
//              Winlogon/mmc snapin.
//  Arguments:
//  [in]
//      DSProfilePath: 
//              Path For the DS Object given to winlogon.
//              This is validated here.
//         
//  [out]
//      pCSPath: 
//              Unicode Path to the class store.
//           
// Returns :
//      S_OK, or CS_E_XXX error codes.
// 
//  Looks at the profile object and gets the DEFAULTCLASSSTOREPATH Property.
//  The CALLER needs to FREE the memory allocated using CsMemFree().
//--------------------------------------------------------------------

STDAPI
CsGetClassStorePath(LPOLESTR DSProfilePath, LPOLESTR *pCSPath)
{
    HRESULT        hr;

    //
    // Initialize locals
    //
    hr = S_OK;

    //
    // Initialize out parameters
    //
    *pCSPath = NULL;

    //
    // Validate the ds path string -- make sure it's NULL terminated
    //
    if ((!DSProfilePath))
        ERROR_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Make sure the ldap prefix is there
    //
    if (wcsncmp (DSProfilePath, LDAPPREFIX, LDAPPREFIXLENGTH) != 0)
        ERROR_ON_FAILURE(hr = E_INVALIDARG);

    //
    // Now build the class store path.  It would be nice if we could use
    // BuildADsPathFromParent to do this, but it does not allocate memory
    // with CoTaskMemalloc, and the interface to this function requires that
    // the returned cs path is freed by the caller with CoTaskMemfree -- thus
    // we have to do all the memory allocation and copying ourselfves.
    
    //
    // First, get memory -- length is just the length of the current ds path
    // in addition to the length for a path separator and the name of the class
    // store container
    //
    *pCSPath = (LPOLESTR) CsMemAlloc(
        wcslen(DSProfilePath) * sizeof (WCHAR) +
        sizeof (WCHAR) +
        sizeof (CLASSSTORECONTAINERNAME));

    if (!(*pCSPath))
        ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);

    //
    // Get the ds path past the prefix so we can use it
    // in creating the new path
    //
    LPOLESTR DSPathWithoutPrefix;
    
    DSPathWithoutPrefix = DSProfilePath + LDAPPREFIXLENGTH;

    //
    // currently, prefixing LDAP: at the beginning.
    //
    swprintf(*pCSPath,
             L"%s%s", 
             LDAPPREFIX CLASSSTORECONTAINERNAME LDAPPATHSEP,
             DSPathWithoutPrefix);


Error_Cleanup:

    return RemapErrorCode(hr, DSProfilePath);
}

//----------------The release APIs-------------------------
STDAPI
ReleasePackageInfo(PACKAGEDISPINFO *pPackageInfo)
{
    DWORD i;

    if (pPackageInfo) 
    {
        CsMemFree(pPackageInfo->pszScriptPath);
        CsMemFree(pPackageInfo->pszPackageName);
        for (i = 0; i < (pPackageInfo->cUpgrades); i++) 
            CsMemFree(pPackageInfo->prgUpgradeInfoList[i].szClassStore);
        CsMemFree(pPackageInfo->prgUpgradeInfoList);
        CsMemFree(pPackageInfo->pszPublisher);
        CsMemFree(pPackageInfo->rgSecurityDescriptor);
        CsMemFree(pPackageInfo->pszGpoPath);
        CsMemFree(pPackageInfo->pszUrl);

        DWORD iCategory;

        for ( iCategory = 0; iCategory < pPackageInfo->cCategories; iCategory++ )
        {
            CsMemFree( pPackageInfo->prgCategories[iCategory] );
        }

        CsMemFree(pPackageInfo->prgCategories);

        DWORD iTransform;

        for ( iTransform = 0; iTransform < pPackageInfo->cTransforms; iTransform++ )
        {
            CsMemFree( pPackageInfo->prgTransforms[iTransform] );
        }

        CsMemFree( pPackageInfo->prgTransforms );
    }

    return S_OK;
}

STDAPI
ReleaseAppCategoryInfoList(APPCATEGORYINFOLIST *pAppCategoryInfoList)
{
    DWORD i;
    if (pAppCategoryInfoList) 
    {
        for (i = 0; i < (pAppCategoryInfoList->cCategory); i++) 
            CsMemFree((pAppCategoryInfoList->pCategoryInfo)[i].pszDescription);
        CsMemFree(pAppCategoryInfoList->pCategoryInfo);

        memset( pAppCategoryInfoList, 0, sizeof( *pAppCategoryInfoList ) );
    }
    return S_OK;
}

STDAPI
ReleaseInstallInfo(INSTALLINFO *pInstallInfo)
{
    DWORD i;
    if (pInstallInfo)
    {
        CsMemFree(pInstallInfo->pszSetupCommand);
        CsMemFree(pInstallInfo->pszScriptPath);
        CsMemFree(pInstallInfo->pszUrl);
        CsMemFree(pInstallInfo->pClsid);
        for (i = 0; i < (pInstallInfo->cUpgrades); i++) 
            CsMemFree(pInstallInfo->prgUpgradeInfoList[i].szClassStore);
        CsMemFree(pInstallInfo->prgUpgradeInfoList);
    }
    return S_OK;
}

void
ReleaseClassDetail(CLASSDETAIL ClassDetail)
{
    DWORD i;
    for (i = 0; i < ClassDetail.cProgId; i++)
        CsMemFree(ClassDetail.prgProgId[i]);
    CsMemFree(ClassDetail.prgProgId);
}

STDAPI
ReleasePackageDetail(PACKAGEDETAIL *pPackageDetail)
{
   DWORD i;
   if (pPackageDetail) 
   {
       if (pPackageDetail->pActInfo)
       {   
           for (i = 0; i < pPackageDetail->pActInfo->cClasses; i++)
               ReleaseClassDetail((pPackageDetail->pActInfo->pClasses)[i]);
           CsMemFree(pPackageDetail->pActInfo->pClasses);
           
           for (i = 0; i < pPackageDetail->pActInfo->cShellFileExt; i++)
               CsMemFree((pPackageDetail->pActInfo->prgShellFileExt)[i]);
           CsMemFree(pPackageDetail->pActInfo->prgShellFileExt);

           CsMemFree(pPackageDetail->pActInfo->prgPriority);
           CsMemFree(pPackageDetail->pActInfo->prgInterfaceId);
           CsMemFree(pPackageDetail->pActInfo->prgTlbId);
           CsMemFree(pPackageDetail->pActInfo);
       }
       
       if (pPackageDetail->pPlatformInfo)
       {
           CsMemFree(pPackageDetail->pPlatformInfo->prgPlatform);
           CsMemFree(pPackageDetail->pPlatformInfo->prgLocale);
           CsMemFree(pPackageDetail->pPlatformInfo);
       }
       
       if (pPackageDetail->pInstallInfo)
       {
           ReleaseInstallInfo(pPackageDetail->pInstallInfo);
           CsMemFree(pPackageDetail->pInstallInfo);
       }
       
       for (i = 0; i < (pPackageDetail->cSources); i++)
           CsMemFree(pPackageDetail->pszSourceList[i]);
       CsMemFree(pPackageDetail->pszSourceList);

       CsMemFree(pPackageDetail->pszPackageName);
       CsMemFree(pPackageDetail->rpCategory);
   }
   return S_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\dscon.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  Author: DebiM
//  Date:   September 1996
//
//
//      Class Store Schema creation and access using ADs
//
//      This source file contains implementations for IClassAccess,
//      interface for CClassAccess object.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

HRESULT CreateContainer (HANDLE pParent,
                         LPOLESTR szName,
                         LPOLESTR szDesc
                         )
{
    
    HRESULT         hr;
    int             l;
    ADS_ATTR_INFO   Attr[2];
    
    //
    // Use the Parent Container interface to Create the child.
    //
    
    PackStrToAttr(Attr, OBJECTCLASS, CLASS_CS_CONTAINER);
    
    PackStrToAttr(Attr+1, DESCRIPTION, szDesc);

    hr = ADSICreateDSObject(pParent, szName, Attr, 2);

    //
    // Free the attributes used above
    //
    FreeAttr( Attr[0] );
    FreeAttr( Attr[1] );
    
    return hr;
    
}



HRESULT CreateRepository(LPOLESTR szParentPath, LPOLESTR szStoreName, LPOLESTR szPolicyDn)
{
    
    HRESULT         hr = S_OK;
    HANDLE          hADsParent = NULL;
    HANDLE          hADsContainer = NULL;
    HANDLE          hADsPolicy = NULL;
    LPOLESTR        szContainerName = NULL;
    LPOLESTR        szPolicyName = NULL;
    int             l;
    WCHAR           szPath [_MAX_PATH];
    WCHAR         * szFullName = NULL;
    WCHAR           szUsn[30];
    ADS_ATTR_INFO   pAttr[4];   
    DWORD           cGot = 0, cModified = 0;
    BOOL            fCreatedContainer = FALSE;

    LPOLESTR        AttrName = GPNAME;
    ADS_ATTR_INFO   * pGetAttr = NULL;
        
    if (!szParentPath)
    {
        hr = GetRootPath(szPath);
        //
        // If failed go away
        //
        if (FAILED(hr))
        {
            return hr;
        }
        
        szParentPath = szPath;
    }
    
    //
    // First get the PolicyName
    //
    if (szPolicyDn)
    {        
        hr = ADSIOpenDSObject(szPolicyDn, NULL, NULL, GetDsFlags(),
            &hADsPolicy);
        RETURN_ON_FAILURE(hr);
        
        //
        // Get the PolicyName
        //
        
        hr = ADSIGetObjectAttributes(hADsPolicy, &AttrName, 1, &pGetAttr, &cGot);
        
        if (SUCCEEDED(hr) && (cGot))
            UnpackStrAllocFrom(pGetAttr[0], &szPolicyName);
    
        if (pGetAttr)
            FreeADsMem(pGetAttr);
        pGetAttr = NULL;

        ADSICloseDSObject(hADsPolicy);
    }

    hr = ADSIOpenDSObject(szParentPath, NULL, NULL, GetDsFlags(),
        &hADsParent);
    RETURN_ON_FAILURE(hr);
    
    hr = CreateContainer(hADsParent,
        szStoreName,
        L"Application Store");

    //
    // handle this error correctly
    // see if a broken class store is left behind
    // this could happen due to DS going down after incomplete creation etc.
    // from the class store container property you could tell
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) ||
	    (hr == HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)))
    {
        //
        // There is a Class Store already
        // See if it is a good one.

        DWORD dwStoreVersion = 0;
        hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
        if (!SUCCEEDED(hr))
            return CS_E_OBJECT_ALREADY_EXISTS;
        
        hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
            &hADsContainer);
        
        FreeADsMem(szFullName);
        if (!SUCCEEDED(hr))
            return CS_E_OBJECT_ALREADY_EXISTS;

        AttrName = STOREVERSION;
        //
        // Get the Store Version
        //
        
        hr = ADSIGetObjectAttributes(hADsContainer, &AttrName, 1, &pGetAttr, &cGot);
        
        if (SUCCEEDED(hr) && (cGot))
            UnpackDWFrom(pGetAttr[0], &dwStoreVersion);
        
        if (pGetAttr)
            FreeADsMem(pGetAttr);

        ADSICloseDSObject(hADsContainer);

        if (dwStoreVersion == SCHEMA_VERSION_NUMBER)
            return CS_E_OBJECT_ALREADY_EXISTS;

        // if it is zero, then it was aborted in the middle.
        if (dwStoreVersion != 0)
            return CS_E_SCHEMA_MISMATCH;

        // If it is a bad one try to delete it
        DeleteRepository(szParentPath, szStoreName);

        //
        // Then again try to create it and proceed if successful
        //
        
        hr = CreateContainer(hADsParent,
            szStoreName,
            L"Application Store");
        
    }

    ERROR_ON_FAILURE(hr);
    fCreatedContainer = TRUE;

    hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
    ERROR_ON_FAILURE(hr);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
        &hADsContainer);
    
    ERROR_ON_FAILURE(hr);

    //
    // Create the package container
    //
    
    hr = CreateContainer (hADsContainer,
        PACKAGECONTAINERNAME,
        L"Application Packages");
    
    ERROR_ON_FAILURE(hr);
    
    //
    // Store the USN and PolicyID properties
    //

    GetCurrentUsn(szUsn);
    
    PackStrToAttr(&pAttr[0], STOREUSN, szUsn);
    PackStrToAttr(&pAttr[1], POLICYDN, szPolicyDn);
    PackStrToAttr(&pAttr[2], POLICYNAME, szPolicyName);
    PackDWToAttr(&pAttr[3], STOREVERSION, SCHEMA_VERSION_NUMBER);
    
    hr = ADSISetObjectAttributes(hADsContainer, pAttr, 4, &cModified);

    FreeAttr(pAttr[0]);
    FreeAttr(pAttr[1]);
    FreeAttr(pAttr[2]);
    FreeAttr(pAttr[3]);
    
    ADSICloseDSObject(hADsContainer);
    ADSICloseDSObject(hADsParent);
    
    FreeADsMem(szFullName);
    CsMemFree(szPolicyName);

    return RemapErrorCode(hr, szParentPath);

Error_Cleanup:
    
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);

    if (fCreatedContainer)
        ADSIDeleteDSObject(hADsParent, szStoreName);
    if (hADsParent)
        ADSICloseDSObject(hADsParent);

    if (szFullName)
        FreeADsMem(szFullName);
    if (szPolicyName)
        CsMemFree(szPolicyName);
    
    return RemapErrorCode(hr, szParentPath);
   
}

    
HRESULT DeleteRepository(LPOLESTR szParentPath, LPOLESTR szStoreName)
{
    HRESULT         hr = S_OK;
    HANDLE          hADsParent = NULL;
    HANDLE          hADsContainer = NULL;
    WCHAR         * szFullName = NULL;
        
    hr = ADSIOpenDSObject(szParentPath, NULL, NULL, GetDsFlags(),
        &hADsParent);
    RETURN_ON_FAILURE(hr);
    
    hr = BuildADsPathFromParent(szParentPath, szStoreName, &szFullName);
    
    hr = ADSIOpenDSObject(szFullName, NULL, NULL, GetDsFlags(),
        &hADsContainer);
    FreeADsMem(szFullName);
    ERROR_ON_FAILURE(hr);

    ADSIDeleteDSObject(hADsContainer, PACKAGECONTAINERNAME);
    ADSICloseDSObject(hADsContainer);
    
    ADSIDeleteDSObject(hADsParent, szStoreName);
    ADSICloseDSObject(hADsParent);
    
    return S_OK;

Error_Cleanup:
    if (hADsContainer)
        ADSICloseDSObject(hADsContainer);
    if (hADsParent)
        ADSICloseDSObject(hADsParent);
    return hr;
}

HRESULT GetRootPath(LPOLESTR szContainer)
{
    HRESULT         hr = S_OK;
    ULONG           cGot = 0;
    HANDLE          hADs = NULL;
    LPOLESTR        AttrName = {L"defaultNamingContext"}, pDN = NULL;
    ADS_ATTR_INFO * pAttr = NULL;
    
    szContainer[0] = L'\0';

    //
    // Do a bind to the machine by a GetObject for the Path
    //
    hr = ADSIOpenDSObject(L"LDAP://rootdse", NULL, NULL, GetDsFlags(),
                            &hADs);
    RETURN_ON_FAILURE(hr);
    
    hr = ADSIGetObjectAttributes(hADs, &AttrName, 1, &pAttr, &cGot);
    
    if (SUCCEEDED(hr) && (cGot))
        UnpackStrFrom(pAttr[0], &pDN);
    else
        pDN = L"\0";

    swprintf(szContainer, L"%s%s", LDAPPREFIX, pDN);
    
    ADSICloseDSObject(hADs);

    if (pAttr)
        FreeADsMem(pAttr);

    return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\dsprop.cxx ===
#include "cstore.hxx"



const WCHAR cwszCRLF[] = L"\r\n";


BOOL GetGpoIdFromClassStorePath(
    WCHAR* wszClassStorePath,
    GUID*  pGpoId)
{
    WCHAR* wszGuidStart;
    WCHAR  wszGpoId[MAX_GUIDSTR_LEN + 1];

    wszGuidStart = wcschr(wszClassStorePath, L'{');

    if (!wszGuidStart) 
    {
        return FALSE;
    }

    wcsncpy(wszGpoId, wszGuidStart, MAX_GUIDSTR_LEN);

    wszGpoId[MAX_GUIDSTR_LEN] = L'\0';

    StringToGuid(wszGpoId, pGpoId);

    return TRUE;
}


HRESULT GetUserSid(PSID *ppUserSid, UINT *pCallType);

// set property routines do not do any allocations.
// get properties have 2 different sets of routines
//             1. in which there is no allocation taking place
//                and the buffers are freed when the ds data structures
//                are freed.
//             2. Allocation takes place and these should be used for
//                data that needs to be returned back to the clients.


void FreeAttr(ADS_ATTR_INFO attr)
{
    CsMemFree(attr.pADsValues);
}

// Note: None of these APIs copies anything into their own buffers.
// It allocates a buffer for adsvalues though.

// packing a property's value into a attribute structure
// for sending in with a create/modify.

void PackStrArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty,
                      WCHAR **pszAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    
    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    
    if (!(attr->pADsValues))
        return;             

    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackDWArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD *pAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;            
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackGUIDArrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr, DWORD num)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (num)
        attr->dwControlCode = ADS_ATTR_UPDATE;
    else
        attr->dwControlCode = ADS_ATTR_CLEAR;
    
    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;           
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_OCTET_STRING;
        attr->pADsValues[i].OctetString.dwLength = sizeof(GUID);
        attr->pADsValues[i].OctetString.lpValue = (unsigned char *)(pAttr+i);
    }
}

void PackBinToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, BYTE *pAttr, DWORD sz)
{
    attr->pszAttrName = szProperty;
    attr->dwNumValues = 1;
    
    attr->dwControlCode = ADS_ATTR_UPDATE;
    
    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE));
    if (!(attr->pADsValues))
        return;           
    
    attr->pADsValues[0].dwType = ADSTYPE_OCTET_STRING;
    attr->pADsValues[0].OctetString.dwLength = sz;
    attr->pADsValues[0].OctetString.lpValue = pAttr;
}

void PackStrToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR *szAttr)
{
    if (szAttr)
        PackStrArrToAttr(attr, szProperty, &szAttr, 1);
    else
        PackStrArrToAttr(attr, szProperty, &szAttr, 0);
}

void PackDWToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD Attr)
{
    PackDWArrToAttr(attr, szProperty, &Attr, 1);
}

// passing in a pointer to GUID which is passed down into the LDAP structure.

void PackGUIDToAttr(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr)
{
    PackGUIDArrToAttr(attr, szProperty, pAttr, 1);
}

// returns the attribute corresp. to a given property.
DWORD GetPropertyFromAttr(ADS_ATTR_INFO *pattr, DWORD cNum, WCHAR *szProperty)
{
    DWORD   i;
    for (i = 0; i < cNum; i++)
        if (_wcsicmp(pattr[i].pszAttrName, szProperty) == 0)
            break;
        return i;
}



HRESULT GetCategoryLocaleDesc(LPOLESTR *pdesc, ULONG cdesc, LCID *plcid,
                              LPOLESTR szDescription)
{
    LCID     plgid;
    LPOLESTR ptr;

    szDescription[0] = L'\0';
    if (!cdesc)
        return E_FAIL; // CAT_E_NODESCRIPTION;
    
    // Try locale passed in
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get default sublang local
    plgid = PRIMARYLANGID((WORD)*plcid);
    *plcid = MAKELCID(MAKELANGID(plgid, SUBLANG_DEFAULT), SORT_DEFAULT);
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get matching lang id
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 1))
        return S_OK;
    
    // Get User Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get System Default
    *plcid = GetUserDefaultLCID();
    if (FindDescription(pdesc, cdesc, plcid, szDescription, 0))
        return S_OK;
    
    // Get the first one
    *plcid = wcstoul(pdesc[0], &ptr, 16);
    if (szDescription)
    {
        if ((ptr) && (wcslen(ptr) >= (CAT_DESC_DELIM_LEN+2)))
            wcscpy(szDescription, (ptr+CAT_DESC_DELIM_LEN+2));
        else
            szDescription = L'\0';
    }
    return S_OK;
}

//-------------------------------------------
// Returns the description corresp. to a LCID
//  desc:         list of descs+lcid
//  cdesc:        number of elements.
//      plcid:        the lcid in/out
//  szDescription:description returned.
//  GetPrimary:   Match only the primary.
//---------------------------------------

ULONG FindDescription(LPOLESTR *desc, ULONG cdesc, LCID *plcid, LPOLESTR szDescription, BOOL GetPrimary)
{
    ULONG i;
    LCID  newlcid;
    LPOLESTR ptr;
    for (i = 0; i < cdesc; i++)
    {
        newlcid = wcstoul(desc[i], &ptr, 16); // to be changed
        // error to be checked.
        if ((newlcid == *plcid) || ((GetPrimary) &&
            (PRIMARYLANGID((WORD)*plcid) == PRIMARYLANGID(LANGIDFROMLCID(newlcid)))))
        {
            if (szDescription)
            {
                if ((ptr) && (wcslen(ptr) >= (CAT_DESC_DELIM_LEN+2)))
                {
                    //
                    // Copy the description, enforcing the maximum size
                    // so we don't overflow the buffer
                    //
                    wcsncpy(szDescription,
                            (ptr+CAT_DESC_DELIM_LEN+2),
                            CAT_DESC_MAX_LEN + 1
                            );

                    //
                    // We must null terminate in case the category
                    // was longer than the maximum.  We know the buffer
                    // is equal in size to the maximum, so we can
                    // just add the terminator there.  In all other cases,
                    // wcsncpy will have written the null terminator
                    //
                    szDescription[CAT_DESC_MAX_LEN] = L'\0';
                }
                else
                    szDescription = L'\0';
            }
            if (GetPrimary)
                *plcid = newlcid;
            return i+1;
        }
    }
    return 0;
}

DWORD NumDigits10(DWORD Value)
{
    DWORD ret = 0;

    for (ret = 0; Value != 0; ret++) 
        Value = Value/10;

    return ret;
}


void ReportEventCS(HRESULT ErrorCode, HRESULT ExtendedErrorCode, LPOLESTR szContainerName)
{

    WCHAR       szErrCode[16];

    swprintf(szErrCode, L"0x%x", ExtendedErrorCode);

    CEventsBase* pEvents = (CEventsBase*) gpEvents;

    ASSERT(CS_E_NETWORK_ERROR == ErrorCode);

    pEvents->Report(
        EVENT_CS_NETWORK_ERROR,
        FALSE,
        2,
        szContainerName,
        szErrCode);
}

// remapping Error Codes returned by LDAP to reasonable class store errors.
//
HRESULT RemapErrorCode(HRESULT ErrorCode, LPOLESTR m_szContainerName)
{
    HRESULT RetCode;
    BOOL    fNetError;

    fNetError = FALSE;

    if (SUCCEEDED(ErrorCode))
        return S_OK;

    switch (ErrorCode) 
    {
        //            
        //  All kinds of failures due to ObjectNotFound
        //  due to non-existence of object OR 
        //         non-existent container OR
        //         invalid path specification
        //  Other than Access Denials
        //
        case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
        case HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):    // understand what causes this
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_FOUND):   //  -do-
            
            RetCode = CS_E_OBJECT_NOTFOUND;                       // which object - specific error
            break;

        case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
        case HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS):
        case E_ADS_OBJECT_EXISTS:
            RetCode = CS_E_OBJECT_ALREADY_EXISTS;
            break;

        //            
        //  The following errors should not be expected normally.
        //  Class Store schema mismatched should be handled correctly.
        //  Errors below may ONLY occur for corrupted data OR out-of-band changes
        //  to a Class Store content.

        case E_ADS_CANT_CONVERT_DATATYPE:
        case E_ADS_SCHEMA_VIOLATION:
        case HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
        case HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
            RetCode = CS_E_SCHEMA_MISMATCH;
            break;

        //            
        //  Any kinds of Access or Auth Denial
        //      return ACCESS_DENIED
        //

        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
        case HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        case HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):

            RetCode = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            break;

        case E_ADS_BAD_PATHNAME:
        case HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):  // this is wrong
            RetCode = CS_E_INVALID_PATH;
            break;
        
        //            
        //  Out of Memory
        //

        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY):
            
            RetCode = E_OUTOFMEMORY;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_RESOLVING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NOT_UNIQUE):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_NO_MAPPING):
        case HRESULT_FROM_WIN32(ERROR_DS_NAME_ERROR_DOMAIN_ONLY):
        case HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
        case HRESULT_FROM_WIN32(ERROR_DS_BUSY):
        case HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
        case HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
        case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
        case HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
        case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
            RetCode = ErrorCode;
            fNetError = TRUE;
            break;

        case HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
             RetCode = CS_E_ADMIN_LIMIT_EXCEEDED;
             break;

        default:
            RetCode = ErrorCode;
    }
    
    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_REMAP_ERR,
              ErrorCode,
              RetCode));

    if (RetCode == CS_E_NETWORK_ERROR)
    {
        ReportEventCS(RetCode, ErrorCode, m_szContainerName);
    }

    return RetCode;
}

// These functions are used to delete a single value from a
// multivalued property or append to a multivalued property

void PackStrArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, WCHAR **pszAttr, DWORD num,
                        BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_DN_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;            
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_DN_STRING;
        attr->pADsValues[i].DNString = pszAttr[i];
    }
}

void PackDWArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, DWORD *pAttr, DWORD num,
                       BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_INTEGER;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;             
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_INTEGER;
        attr->pADsValues[i].Integer = pAttr[i];
    }
}

void PackGUIDArrToAttrEx(ADS_ATTR_INFO *attr, WCHAR *szProperty, GUID *pAttr, DWORD num,
                         BOOL APPEND)
{
    DWORD    i;
    
    attr->pszAttrName = szProperty;
    attr->dwNumValues = num;
    
    if (APPEND)
        attr->dwControlCode = ADS_ATTR_APPEND;
    else
        attr->dwControlCode = ADS_ATTR_DELETE;

    attr->dwADsType = ADSTYPE_OCTET_STRING;
    attr->pADsValues = (ADSVALUE *)CsMemAlloc(sizeof(ADSVALUE)*num);
    if (!(attr->pADsValues))
        return;          
    
    for (i = 0; i < num; i++) {
        attr->pADsValues[i].dwType = ADSTYPE_OCTET_STRING;
        attr->pADsValues[i].OctetString.dwLength = sizeof(GUID);
        attr->pADsValues[i].OctetString.lpValue = (unsigned char *)(pAttr+i);
    }
}

WCHAR* AllocGpoPathFromClassStorePath( WCHAR* pszClassStorePath )
{
    //
    // The class store path looks like CN=ClassStore,CN=[Machine | User],<gpopath>
    // So we will simply look for two "," starting at the beginning of the path.
    // In doing this, we will take care not to access violate due to an incorrect path,
    // Since there is the possiblity that an administrator could find the persisted
    // class store path and mangle it, giving us an incorrect path that would
    // not parse according to the structure above.
    //
    WCHAR* wszGpoPath;

    //
    // Check for the first ','
    //
    wszGpoPath = wcschr(pszClassStorePath, L',');

    //
    // If we get NULL here, that means there is no ',' and the path is corrupt
    //
    if ( ! wszGpoPath )
    {
        return NULL;
    }

    //
    // Now check for the second ','
    //
    wszGpoPath = wcschr(wszGpoPath + 1, L',');

    //
    // Again, if we don't find the second ',', 
    // The path is corrupt
    //
    if ( ! wszGpoPath )
    {
        return NULL;
    }

    //
    // Now move one past
    //
    wszGpoPath++;

    //
    // The caller desires their own copy, so we will allocate space for it
    //
    WCHAR* wszGpoPathResult;

    wszGpoPathResult = (WCHAR*) CsMemAlloc( (wcslen( wszGpoPath ) + 1) * sizeof( *wszGpoPathResult ) );

    if ( ! wszGpoPathResult )
    {
        return NULL;
    }

    //
    // Now copy the gpo path
    //
    wcscpy( wszGpoPathResult, wszGpoPath );

    return wszGpoPathResult;
}

HRESULT
GetEscapedNameFilter( WCHAR* wszName, WCHAR** ppwszEscapedName )
{
    DWORD  cbLen;
    WCHAR* wszCurrent;

    //
    // This function escapes package names so that they can be used in
    // an ldap search filter.  Names containing certain characters must
    // be escaped since those characters are contained in the vocabulary
    // for the search filter grammar.
    //

    //
    // The set of characters that must be escaped and the appropriate
    // escape sequences are described in RFC 2254
    //

    //
    // Determine the maximum size needed for the filter.  We include for 3
    // times the length of the name since that is the upper bound on the
    // length of the escaped name
    //

    //
    // "(PackageAttr=\0" + "<*ppwszEscapedName>" + ")"
    //
    cbLen = sizeof( L"(" PACKAGENAME L"=" ) + ( lstrlen( wszName ) + 1 ) * sizeof( *wszName ) * 3;

    *ppwszEscapedName = (WCHAR*) CsMemAlloc( cbLen );

    if ( ! *ppwszEscapedName )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Add in the LHS of the filter expression
    //
    lstrcpy( *ppwszEscapedName, L"(" PACKAGENAME L"=" );

    //
    // We will escape the name -- move past the end of the filter expression LHS
    //
    wszCurrent = *ppwszEscapedName + ( sizeof(L"(" PACKAGENAME L"=") - 1 ) / sizeof( WCHAR );

    //
    // For each character that needs to be escaped, we will append that character's 
    // escape sequence to the string.  For characters that do not need to be escaped,
    // we simply simply append the character as-is (i.e. unescaped).
    //
    for ( ; *wszName; wszName++ )
    {
        WCHAR* EscapedChar;

        //
        // Detect characters that need to be escaped and
        // map each to its escape sequence
        //
        switch ( *wszName )
        {
        case L'*':

            EscapedChar = L"\\2a";
            break;

        case L'(':

            EscapedChar = L"\\28";
            break;

        case L')':

            EscapedChar = L"\\29";
            break;

        case L'\\':

            EscapedChar = L"\\5c";
            break;

        default:
            
            //
            // This character does not need to be escaped, just append it
            //
            *wszCurrent = *wszName;
            wszCurrent ++;

            continue;

            break;
        }
            
        //
        // We only get here if the character needed to be escaped --
        // we append the string for the escape sequence to the filter string, and
        // move our filter string location to the new end of string
        //
        lstrcpy( wszCurrent, EscapedChar );
        wszCurrent += 3;
    }

    //
    // We need to add the closing parenthesis to the filter expression
    //
    *wszCurrent++ = L')';
    *wszCurrent   = L'\0';

    return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\dsiface.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       dsiface.cxx
//
//  Contents:   ADs calls for Class Store Property Read/Write
//
//
//  History:    Sep-Oct 96.   DebiM
//
//----------------------------------------------------------------------------


#include "cstore.hxx"

#pragma warning ( disable : 4018 )
#pragma warning ( disable : 4244 )

//
// From CSPLATFORM to DS datatype
//
void
UnpackPlatform (DWORD *pdwArch,
                CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)pdwArch;
    
    *(pc) = (unsigned char)pPlatform->dwPlatformId;
    *(++pc) = (unsigned char)pPlatform->dwVersionHi;
    *(++pc) = (unsigned char)pPlatform->dwVersionLo;
    *(++pc) = (unsigned char)pPlatform->dwProcessorArch;
}

//
// From DS datatype to CSPLATFORM
//
void
PackPlatform (DWORD dwArch,
              CSPLATFORM *pPlatform)
{
    unsigned char *pc = (unsigned char *)&dwArch;
    
    pPlatform->dwPlatformId = *(pc);
    pPlatform->dwVersionHi = *(++pc);
    pPlatform->dwVersionLo = *(++pc);
    pPlatform->dwProcessorArch = *(++pc);
}


//+-------------------------------------------------------------------------
//
//  Function:   StringFromGUID
//
//--------------------------------------------------------------------------
int  StringFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    swprintf(lptsz, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        rguid.Data1, rguid.Data2, rguid.Data3,
        rguid.Data4[0], rguid.Data4[1],
        rguid.Data4[2], rguid.Data4[3],
        rguid.Data4[4], rguid.Data4[5],
        rguid.Data4[6], rguid.Data4[7]);
    
    return 36;
}

//+-------------------------------------------------------------------------
//
//  Function:   RdnFromGUID
//
//--------------------------------------------------------------------------
int  RDNFromGUID(REFGUID rguid, LPOLESTR lptsz)
{
    wcscpy (lptsz, L"CN=");
    StringFromGUID(rguid, lptsz+3);
    return 3+36;
}

//
// This converts string guids to the guid structure -- note that
// the string guid does NOT contain brace chars ('{','}') at
// the beginning and end
//
void GUIDFromString(
                    LPOLESTR psz,
                    GUID *pclsguid)
                    //
                    // Converts a Stringified GUID to GUID structure
                    //
{
    WCHAR szC [40];
    LPOLESTR szClsId;
    LPOLESTR endptr;
    
    memset ((void *)pclsguid, NULL, sizeof (GUID));
    if ((!psz) ||
        (*psz == NULL))
        return;

    if (wcslen(psz) < 36)
        return;

    wcsncpy (&szC [0], psz, 36);
    szC[36] = L'\0';

    szClsId = &szC[0];
  
    *(szClsId+36) = NULL;
    pclsguid->Data4[7] = wcstoul (szClsId+34, &endptr, 16);

    *(szClsId+34) = NULL;
    pclsguid->Data4[6] = wcstoul (szClsId+32, &endptr, 16);

    *(szClsId+32) = NULL;
    pclsguid->Data4[5] = wcstoul (szClsId+30, &endptr, 16);

    *(szClsId+30) = NULL;
    pclsguid->Data4[4] = wcstoul (szClsId+28, &endptr, 16);

    *(szClsId+28) = NULL;
    pclsguid->Data4[3] = wcstoul (szClsId+26, &endptr, 16);

    *(szClsId+26) = NULL;
    pclsguid->Data4[2] = wcstoul (szClsId+24, &endptr, 16);
    
    *(szClsId+23) = NULL;
    pclsguid->Data4[1] = wcstoul (szClsId+21, &endptr, 16);

    *(szClsId+21) = NULL;
    pclsguid->Data4[0] = wcstoul (szClsId+19, &endptr, 16);
    
    *(szClsId+18) = NULL;
    pclsguid->Data3 = wcstoul (szClsId+14, &endptr, 16);

    *(szClsId+13) = NULL;
    pclsguid->Data2 = wcstoul (szClsId+9, &endptr, 16);

    *(szClsId+8) = NULL;
    pclsguid->Data1 = wcstoul (szClsId, &endptr, 16);
}

BOOL  IsNullGuid(REFGUID rguid)
{
    UINT i;
    
    if (rguid.Data1)
        return FALSE;
    if (rguid.Data2)
        return FALSE;
    if (rguid.Data3)
        return FALSE;
    for (i=0; i < 8; ++i)
    {
        if (rguid.Data4[i])
            return FALSE;
    }
    return TRUE;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\enumapp.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-1999
//
//  File:       enumapp.cxx
//
//  Contents:   Per Class Container Package Enumeration
//
//
//  History:    09-09-96  DebiM   created
//              11-01-97  DebiM   modified, moved to cstore
//
//----------------------------------------------------------------------------

#include "cstore.hxx"

//IEnumPackage implementation.

HRESULT CEnumPackage::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumPackage)
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CEnumPackage::AddRef()
{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}

ULONG CEnumPackage::Release()
{
    ULONG dwRefCount=m_dwRefCount-1;
    if (InterlockedDecrement((long*) &m_dwRefCount)==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


//
// CEnumPackage::Next
// ------------------
//
//
//
//  Synopsis:       This method returns the next celt number of packages
//                  within the scope of the enumeration.
//                  Packages are returned in the alphabetical name order.
//
//  Arguments:      [in]  celt - Number of package details to fetch
//                  INSTALLINFO *rgelt - Package detail structure
//                  ULONG *pceltFetched - Number of packages returned
//
//  Returns:        S_OK or S_FALSE if short of packages
//
//
//

HRESULT CEnumPackage::Next(ULONG               celt,
                           PACKAGEDISPINFO    *rgelt,
                           ULONG              *pceltFetched)
                           
{
    ULONG          cgot = 0, i, j;
    HRESULT        hr = S_OK;
    
    if ((celt > 1) && (!pceltFetched))
        return E_INVALIDARG;
    
    if (pceltFetched)
        (*pceltFetched) = 0;
    
    //
    // Clear up this structure in case our fetch fails --
    // we don't want callers freeing invalid memory
    //
    memset(rgelt, 0, sizeof(*rgelt) * celt);
    
    hr = FetchPackageInfo (
        m_hADs,
        m_hADsSearchHandle,
        m_dwAppFlags,
        m_dwQuerySpec,                   
        m_pPlatform,
        celt,
        &cgot,
        rgelt,
        &m_fFirst,
        &m_PolicyId,
        m_szGpoPath,
        m_pRsopUserToken);

    if (FAILED(hr)) 
    {
        //
        // Clear up this structure so that callers don't
        // try to free invalid memory when this fails
        //
        memset(rgelt, 0, sizeof(*rgelt) * celt);
        cgot = 0;

        if ( ( ( APPQUERY_RSOP_ARP == m_dwQuerySpec ) || ( APPQUERY_USERDISPLAY == m_dwQuerySpec ) ) &&
             ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) ) )
        {
            hr = S_FALSE;
        }
    }

    ERROR_ON_FAILURE(hr);

    m_dwPosition += cgot;
    
    if (pceltFetched)
        *pceltFetched = cgot;

    if (cgot != celt)
        hr = S_FALSE;
    else
        hr = S_OK;

    return hr;
    
Error_Cleanup:
    return RemapErrorCode(hr, m_szPackageName);
}


HRESULT CEnumPackage::Skip(ULONG celt)
{
    ULONG               celtFetched = NULL, i;
    HRESULT             hr = S_OK;
    PACKAGEDISPINFO    *pIf = NULL;
    
    pIf = new PACKAGEDISPINFO[celt];
    hr = Next(celt, pIf, &celtFetched);
    for (i = 0; i < celtFetched; i++)
        ReleasePackageInfo(pIf+i);
    delete pIf;
    
    return hr;
}

HRESULT CEnumPackage::Reset()
{
    HRESULT    hr = S_OK;
    LPOLESTR*  ppszAttrs;
    DWORD      cAttrs;

    m_dwPosition = 0;
    m_fFirst = TRUE;

    // execute the search and keep the handle returned.

    if (m_hADsSearchHandle)
    {
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
        m_hADsSearchHandle = NULL;
    }

    ppszAttrs = GetAttributesFromQuerySpec(
        m_dwQuerySpec,
        &cAttrs);

    if ( ppszAttrs )
    {
        hr = ADSIExecuteSearch(
            m_hADs,
            m_szfilter,
            ppszAttrs,
            cAttrs,
            &m_hADsSearchHandle);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return RemapErrorCode(hr, m_szPackageName);
}

CEnumPackage::CEnumPackage(GUID PolicyId, LPOLESTR pszPolicyName, LPOLESTR pszClassStorePath, PRSOPTOKEN pRsopToken )
{
    m_dwRefCount = 0;
    m_fFirst = TRUE;
    m_szfilter = NULL;
    wcscpy(m_szPackageName, L"");
    m_dwPosition = 0;
    m_dwAppFlags = 0;
    m_pPlatform = NULL;
    m_hADs = NULL;
    m_hADsSearchHandle = NULL;
    memcpy (&m_PolicyId, &PolicyId, sizeof(GUID));
    m_szPolicyName[0] = NULL;
    m_pRsopUserToken = pRsopToken;

    if (pszPolicyName)
        wcscpy (&m_szPolicyName[0], pszPolicyName);

    //
    // Remember the path of the gpo from which we are originating
    // This information is needed for RSOP to determine where 
    // the package came from
    //
    m_szGpoPath = AllocGpoPathFromClassStorePath( pszClassStorePath );
}


HRESULT CEnumPackage::Initialize(WCHAR      *szPackageName,
                                 WCHAR      *szfilter,
                                 DWORD       dwAppFlags,
                                 BOOL        bPlanning,
                                 CSPLATFORM *pPlatform)
{
    HRESULT             hr = S_OK;
    ADS_SEARCHPREF_INFO SearchPrefs[3];
    LPOLESTR*           ppszAttrs;
    DWORD               cAttrs;
    LONG                lSecurityFlags;
    DWORD               cPrefs;

    cPrefs = 2;

    //
    // Be sure we're properly initialized
    //
    if ( ! m_szGpoPath )
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // Set the security of our communications based on the preference
    // of the caller
    //
    lSecurityFlags = GetDsFlags();

    m_szfilter = (LPOLESTR)CsMemAlloc (sizeof(WCHAR) * (wcslen(szfilter)+1));
    if (!m_szfilter)
        return E_OUTOFMEMORY;
    
    // copy the filters, package name, flags and locale.
    wcscpy(m_szfilter, szfilter);
    
    wcscpy(m_szPackageName, szPackageName);
    
    m_dwAppFlags = ClientSideFilterFromQuerySpec( dwAppFlags, bPlanning );
    m_dwQuerySpec = dwAppFlags;
        
    // open the package container.
    hr = ADSIOpenDSObject(szPackageName, NULL, NULL, lSecurityFlags,
        &m_hADs);
    ERROR_ON_FAILURE(hr);
    
    // set the search preference.
    SearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[0].vValue.Integer = ADS_SCOPE_ONELEVEL;
    
    SearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    SearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    SearchPrefs[1].vValue.Integer = SEARCHPAGESIZE;

    //
    // For RSOP, we need to add an extra search pref to obtain the security
    // descriptor
    //
    if ( ( APPQUERY_RSOP_ARP == dwAppFlags ) ||
         ( APPQUERY_RSOP_LOGGING == dwAppFlags ) )
    {
        SearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SECURITY_MASK;
        SearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;

        //
        // Request everything but the SACL
        //
        SearchPrefs[2].vValue.Integer =
            OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;

        cPrefs ++;
    }
	
    hr = ADSISetSearchPreference(m_hADs, SearchPrefs, cPrefs);
    ERROR_ON_FAILURE(hr);
    
    // copy platform
    if (pPlatform)
    {
        m_pPlatform = (CSPLATFORM *) CsMemAlloc(sizeof(CSPLATFORM));
        if (!m_pPlatform)
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);
        memcpy (m_pPlatform, pPlatform, sizeof(CSPLATFORM));
    }

    ppszAttrs = GetAttributesFromQuerySpec(
        m_dwQuerySpec,
        &cAttrs);    

    // execute the search and keep the handle returned.
    hr = ADSIExecuteSearch(
        m_hADs,
        szfilter,
        ppszAttrs,
        cAttrs,
        &m_hADsSearchHandle);

Error_Cleanup:
    return RemapErrorCode(hr, m_szPackageName);
}

CEnumPackage::~CEnumPackage()
{
    if (m_hADsSearchHandle)
        ADSICloseSearchHandle(m_hADs, m_hADsSearchHandle);
    
    if (m_hADs)
        ADSICloseDSObject(m_hADs);
    
    if (m_szfilter)
        CsMemFree(m_szfilter);
    
    if (m_pPlatform)
        CsMemFree(m_pPlatform);
    
    if (m_szGpoPath)
        CsMemFree(m_szGpoPath);
}

//--------------------------------------------------------------

CMergedEnumPackage::CMergedEnumPackage()
{
    m_pcsEnum = NULL;
    m_cEnum = 0;
    m_csnum = 0;
    m_dwRefCount = 0;
}

CMergedEnumPackage::~CMergedEnumPackage()
{
    ULONG    i;
    for (i = 0; i < m_cEnum; i++)
        m_pcsEnum[i]->Release();
    CsMemFree(m_pcsEnum);
}

HRESULT  __stdcall  CMergedEnumPackage::QueryInterface(REFIID riid,
                                            void  * * ppObject)
{
    *ppObject = NULL; //gd
    if ((riid==IID_IUnknown) || (riid==IID_IEnumPackage))
    {
        *ppObject=(IEnumPackage *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG  __stdcall  CMergedEnumPackage::AddRef()

{
    InterlockedIncrement((long*) &m_dwRefCount);
    return m_dwRefCount;
}



ULONG  __stdcall  CMergedEnumPackage::Release()
{
    ULONG dwRefCount;
    if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}


HRESULT  __stdcall CMergedEnumPackage::Next(
            ULONG             celt,
            PACKAGEDISPINFO   *rgelt,
            ULONG             *pceltFetched)
{
    ULONG count=0, total = 0;
    HRESULT hr;

    //
    // Clear everything
    //
    memset( rgelt, 0, sizeof(*rgelt) * celt );

    for (; m_csnum < m_cEnum; m_csnum++)
    {
        count = 0;
        
        hr = m_pcsEnum[m_csnum]->Next(celt, rgelt+total, &count);

        if (FAILED(hr))
        {
            //
            // Release everything on failure
            //
            ULONG iAllocated;

            for ( iAllocated = 0; iAllocated < total; iAllocated++ )
            {
                ReleasePackageInfo( rgelt+iAllocated );
            }

            return hr;
        }

        total += count;
        celt -= count;

        if (!celt)
            break;
    }
    if (pceltFetched)
        *pceltFetched = total;
    if (!celt)
        return S_OK;
    return S_FALSE;
}

HRESULT  __stdcall CMergedEnumPackage::Skip(
            ULONG             celt)
{
    PACKAGEDISPINFO *pPackageInfo = NULL;
    HRESULT          hr = S_OK;
    ULONG            cgot = 0, i;

    pPackageInfo = (PACKAGEDISPINFO *)CsMemAlloc(sizeof(PACKAGEDISPINFO)*celt);
    if (!pPackageInfo)
        return E_OUTOFMEMORY;

    hr = Next(celt, pPackageInfo, &cgot);

    for (i = 0; i < cgot; i++)
        ReleasePackageInfo(pPackageInfo+i);
    CsMemFree(pPackageInfo);
    
    return hr;
}

HRESULT  __stdcall CMergedEnumPackage::Reset()
{
    ULONG i;
    for (i = 0; ((i <= m_csnum) && (i < m_cEnum)); i++)
        m_pcsEnum[i]->Reset(); // ignoring all error values
    m_csnum = 0;
    return S_OK;
}

HRESULT  CMergedEnumPackage::Initialize(IEnumPackage **pcsEnum, ULONG cEnum)
{
    ULONG i;
    m_csnum = 0;
    m_pcsEnum = (IEnumPackage **)CsMemAlloc(sizeof(IEnumPackage *) * cEnum);
    if (!m_pcsEnum)
        return E_OUTOFMEMORY;
    for (i = 0; i < cEnum; i++)
        m_pcsEnum[i] = pcsEnum[i];
    m_cEnum = cEnum;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\idl\makefile.inc ===
#
# Build idl files.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

APP= $(O)\app.h $(O)\app_c.c $(O)\app_s.c
CS= $(O)\cs.h

TARGETS= $(APP) $(CS)

INCLUDE= -I$(SDK_INC_PATH) -I$(CRT_INC_PATH)
CPP= -cpp_cmd "$(MIDL_CPP)" $(C_DEFINES) $(INCLUDE) -DMIDL_PASS -DUNICODE
MIDL_FLAGS= $(MIDL_FLAGS) -no_stamp -Oicf -oldnames -error all -robust -c_ext -ms_ext -out .\$(O)


$(APP) : app.idl app.acf
        midl $(CPP) $(MIDL_FLAGS) -cstub app_c.c -sstub app_s.c app.idl

$(CS) : cs.idl
        midl $(CPP) $(MIDL_FLAGS) -client none -server none -h cs.h -iid cs_i.c cs.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\sample\appapi.cxx ===
#include <windows.h>
#include <ole2.h>
#include <appmgmt.h>
#include <stdlib.h>
#include <stdio.h>


void
GuidToString(
    GUID &  Guid,
    PWCHAR  pwszGuid
    )
{
    wsprintf(
        pwszGuid,
        L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
        Guid.Data1,
        Guid.Data2,
        Guid.Data3,
        Guid.Data4[0],
        Guid.Data4[1],
        Guid.Data4[2],
        Guid.Data4[3],
        Guid.Data4[4],
        Guid.Data4[5],
        Guid.Data4[6],
        Guid.Data4[7]
        );
}

void
StringToGuid(
    PCHAR  pszGuid,
    GUID * pGuid
    )
{
    WCHAR wszGuid[256];

    wsprintf((WCHAR*)wszGuid, L"%S", pszGuid);
    CLSIDFromString(wszGuid, pGuid);
}


void __cdecl main(int argc, char** argv)
{
    LONG Error;
    PMANAGEDAPPLICATION rgApps;
    DWORD               dwApps;
    GUID                CategoryGuid;
    GUID*               pCategory = NULL;

    if (argc >= 2) {
        
        StringToGuid(argv[1], &CategoryGuid);

        pCategory = &CategoryGuid;

        printf("Listed apps will come from category %s\n", argv[1]);
        
    }

    Error = GetManagedApplications(
        pCategory,
        pCategory ? MANAGED_APPS_FROMCATEGORY : MANAGED_APPS_USERAPPLICATIONS,
        MANAGED_APPS_INFOLEVEL_DEFAULT,
        &dwApps,
        &rgApps);

    if (ERROR_SUCCESS == Error) {

        printf("GetManagedApplications SUCCEEDED\n");

        printf("Returned %d Apps\n", dwApps);

        for (DWORD dwApp = 0; dwApp < dwApps; dwApp ++)
        {
            WCHAR wszGuid[256];
            PMANAGEDAPPLICATION pApp;

            pApp = &(rgApps[dwApp]);

            printf("\nApp: %ls\n", rgApps[dwApp].pszPackageName);

            printf("Publisher: %ls\n", pApp->pszPublisher);

            printf("Revison: %d.%d build %d\n", pApp->dwVersionHi, pApp->dwVersionLo, pApp->dwRevision);

            printf("Support URL: %ls\n", rgApps[dwApp].pszSupportUrl);
            
            printf("GPO Name: %ls\n", rgApps[dwApp].pszPolicyName);

            GuidToString(rgApps[dwApp].GpoId, wszGuid);
            printf("GPO: %ls\n", wszGuid);
            fflush(stdin);

            GuidToString(rgApps[dwApp].ProductId, wszGuid);
            printf("Product: %ls\n", wszGuid);
            fflush(stdin);

            printf("App Path Type ");

            switch (rgApps[dwApp].dwPathType)
            {
            case MANAGED_APPTYPE_WINDOWSINSTALLER:
                printf("Darwin\n");
                break;
            case MANAGED_APPTYPE_SETUPEXE:
                printf("Crappy ZAW\n");
                break;
            case MANAGED_APPTYPE_UNSUPPORTED:
                printf("Unsupported\n");
                break;
            default:
                printf("INVALID\n");
            }

            fflush(stdin);
        }

        LocalFree(rgApps);

    } else {
        printf("GetManagedApplications returned %x\n", Error);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\qry.cxx ===
//
//  Author: DebiM/UShaji
//  Date:   Jan 97 - Apr 98
//
//      Class Store Query and Fetch Implementation
//
//
//---------------------------------------------------------------------
//
#include "cstore.hxx"

//
// List of Attributes for On-Demand Package Lookup Query
//
LPOLESTR pszInstallInfoAttrNames[] =
{
    PKGFILEEXTNLIST,    LOCALEID,   ARCHLIST,   PACKAGEFLAGS,   SCRIPTPATH,         PKGCLSIDLIST,
    PACKAGETYPE,        PKGUSN,     VERSIONHI,  VERSIONLO,      UPGRADESPACKAGES,   UILEVEL,
    PACKAGENAME,        HELPURL,    PUBLISHER,  REVISION,       PRODUCTCODE,        OBJECTDN,
    OBJECTGUID,         MSIFILELIST,            SECURITYDESCRIPTOR
};
DWORD cInstallInfoAttr = sizeof(pszInstallInfoAttrNames) / sizeof(*pszInstallInfoAttrNames);

//
// List of Attributes for GetPackageDetail() method
//

LPOLESTR pszPackageDetailAttrNames[] =
{
    PACKAGEFLAGS,   PACKAGETYPE,    SCRIPTPATH,         SCRIPTSIZE,         SETUPCOMMAND,   HELPURL,        PKGUSN,
    VERSIONHI,      VERSIONLO,      UILEVEL,            UPGRADESPACKAGES,   ARCHLIST,       LOCALEID,       PKGCLSIDLIST,
    PKGFILEEXTNLIST,PACKAGENAME,    MSIFILELIST,        PKGCATEGORYLIST,    MVIPC,
    PRODUCTCODE,    REVISION,       OBJECTGUID
};
DWORD cPackageDetailAttr = sizeof(pszPackageDetailAttrNames) / sizeof(*pszPackageDetailAttrNames);


LPOLESTR pszDeleteAttrNames[] =
{
    PACKAGEFLAGS, OBJECTDN
};
DWORD cDeleteAttr = 2;

//
// List of Attributes for App Categories
//

LPOLESTR pszCategoryAttrNames[] =
{
    LOCALEDESCRIPTION, CATEGORYCATID
};
DWORD cCategoryAttr = 2;

void GetAttributesFromPackageFlags(
    DWORD          dwPackageFlags,
    UINT*          pUILevel,
    CLASSPATHTYPE* pClassType)
{
    *pUILevel = dwPackageFlags & ACTFLG_FullInstallUI ?
        INSTALLUILEVEL_BASIC :
        INSTALLUILEVEL_FULL;

    *pClassType = (CLASSPATHTYPE) (dwPackageFlags >>
                                   PATHTYPESHIFT);
}


BOOL MatchPlatform(
    CSPLATFORM *pReqPlatform,
    CSPLATFORM *pPkgPlatform,
    BOOL        fExcludeX86OnIA64,
    BOOL        fLegacy)
{
    //
    // Make sure this is the correct platform
    //
    if (pReqPlatform->dwPlatformId != pPkgPlatform->dwPlatformId)
    {
        return FALSE;
    }

    //
    // ProcessorArch must match
    //
    if (pReqPlatform->dwProcessorArch != pPkgPlatform->dwProcessorArch)
    {
        //
        // Reinterpret this flag based on whether this is a legacy deployment
        // or not -- we have the opposite semantics for this flag for
        // legacy deployments
        //
        if ( fLegacy )
        {
            fExcludeX86OnIA64 = ! fExcludeX86OnIA64;
        }

        //
        // If the caller is requesting to ignore  x86 on ia64, inequality between
        // architectures is automatic disqualification
        //
        if (fExcludeX86OnIA64)
        {
            return FALSE;
        }

        //
        // Caller specified that we should allow x86 packages on ia64 --
        // see if we are in that situation, and only disqualify the package if not
        //
        if ( ! ((PROCESSOR_ARCHITECTURE_IA64 == pReqPlatform->dwProcessorArch) &&
                (PROCESSOR_ARCHITECTURE_INTEL == pPkgPlatform->dwProcessorArch)) )
        {
            return FALSE;
        }
    }

    //
    // Check the OS version, hi part first -- this requested platform must be at least as
    // high as the package platform -- if not, it is disqualified
    //
    if (pReqPlatform->dwVersionHi < pPkgPlatform->dwVersionHi)
    {
        return FALSE;
    }

    //
    // If the hi version is the same, check the low part of the os version
    //
    if (pReqPlatform->dwVersionHi == pPkgPlatform->dwVersionHi)
    {

        //
        // If the requested platform is less than the package, it cannot
        // support that package, so the package is disqualified.
        //
        if (pReqPlatform->dwVersionLo < pPkgPlatform->dwVersionLo)
        {
            return FALSE;
        }
    }

    //
    // We passed all the tests -- the package matches the requested platform
    //

    return TRUE;
}


// this has to change if the Msi can give us a preferred list etc.
DWORD PlatformWt(
    CSPLATFORM *pReqPlatform,
    CSPLATFORM *pPkgPlatform,
    BOOL        fExcludeX86OnIA64,
    BOOL        fLegacy)
{
    //
    // See if we get an exact match
    //
    if (MatchPlatform(pReqPlatform,
                      pPkgPlatform,
                      TRUE,
                      FALSE))
    {
        return PRI_ARCH_PREF1;
    }

    //
    // If we don't match exactly, try matching
    // through by taking exclusion flag into account
    //
    if (MatchPlatform(pReqPlatform,
                      pPkgPlatform,
                      fExcludeX86OnIA64,
                      fLegacy))
    {
        return PRI_ARCH_PREF2;
    }


    return 0;
}


DWORD ClassContextWt(DWORD ClsCtx)
{
    if (ClsCtx & CLSCTX_INPROC_SERVER)
        return PRI_CLSID_INPSVR;

    if (ClsCtx & CLSCTX_LOCAL_SERVER)
        return PRI_CLSID_LCLSVR;

    if (ClsCtx & CLSCTX_REMOTE_SERVER)
        return PRI_CLSID_REMSVR;

    return 0;
}

//
//
void GetCurrentUsn(LPOLESTR pStoreUsn)
{
    //
    // Get the current time as USN for the Class Store container
    //
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    swprintf (pStoreUsn, L"%04d%02d%02d%02d%02d%02d",
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond);

}

void TimeToUsn (LPOLESTR szTimeStamp, CSUSN *pUsn)
{
    SYSTEMTIME SystemTime;

    if (szTimeStamp)
    {
        UINT l = wcslen(szTimeStamp) - 1;
        LPOLESTR pStr = szTimeStamp;

        for (UINT i=0; i < l; ++i)
        {
            if (*pStr == L' ')
                *pStr = L'0';
            ++pStr;
        }

        swscanf (szTimeStamp, L"%4d%2d%2d%2d%2d%2d",
            &SystemTime.wYear,
            &SystemTime.wMonth,
            &SystemTime.wDay,
            &SystemTime.wHour,
            &SystemTime.wMinute,
            &SystemTime.wSecond);

        SystemTimeToFileTime(&SystemTime, (LPFILETIME) pUsn);
    }
    else
        pUsn->dwHighDateTime = pUsn->dwLowDateTime = 0;
}


HRESULT UsnGet(ADS_ATTR_INFO Attr, CSUSN *pUsn)
{
    //
    // Read the USN for the Class Store container or Package
    //
    WCHAR *szTimeStamp=NULL;

    UnpackStrFrom(Attr, &szTimeStamp);

    TimeToUsn (szTimeStamp, pUsn);

    return S_OK;
}



// FetchInstallData
//-----------------
//
//
//  Gets the result set of the ondemand lookup query to locate an install package.
//  Returns the properties of the most likely Package in PackageInfo structure.
//
//  In case more than one package meets the criteria, their priorities are returned.
//

HRESULT FetchInstallData(HANDLE             hADs,
                         ADS_SEARCH_HANDLE  hADsSearchHandle,
                         QUERYCONTEXT      *pQryContext,
                         uCLSSPEC          *pclsspec,
                         LPOLESTR           pszFileExt,
                         ULONG              cRows,
                         ULONG             *pcRowsFetched,
                         PACKAGEDISPINFO   *pPackageInfo,
                         UINT              *pdwPriority,
                         BOOL               OnDemandInstallOnly,
                         GUID*              pGpoId,
                         WCHAR*             wszGpoPath
                         )
{
    HRESULT             hr = S_OK;
    UINT                i, j;
    LPOLESTR            szUsn = NULL;
    ULONG               cCount = 0;
    LPOLESTR          * pszList = NULL;
    DWORD             * pdwList = NULL;
    ADS_SEARCH_COLUMN   column;
    CSPLATFORM          PkgPlatform;

    //
    //  Get the rows
    //


    //
    // Clear the caller supplied buffer in case the call to
    // get the first row fails
    //
    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    *pcRowsFetched = 0;

    if (*pcRowsFetched == cRows)
        return S_OK;

    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
         ;
         hr = ADSIGetNextRow(hADs, hADsSearchHandle))
    {
        //
        // Get the data from each row
        //

        //
        // Clear the caller supplied buffer in case previous
        // trips through this loop have written data
        //
        ReleasePackageInfo(pPackageInfo);

        memset(pPackageInfo, 0, sizeof(*pPackageInfo));

        //
        // Stop iterating if there are no more rows
        //
        if (!((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_ROWS)))
        {
            break;
        }

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PACKAGENAME, &column);

        if (SUCCEEDED(hr))
        {
            hr = UnpackStrAllocFrom(column, &(pPackageInfo->pszPackageName));

            ADSIFreeColumn(hADs, &column);

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_EXAMINING,
                      pPackageInfo->pszPackageName));
        }
        else {

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PACKAGENAME,
                      hr));

            continue;
        }
        
        //
        // Determine the package flags -- this is used to interpret many
        // of the remaining attributes
        //
        if (SUCCEEDED(hr))
        {
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);
        }

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwActFlags));

            ADSIFreeColumn(hADs, &column);
        }
        else
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PACKAGEFLAGS,
                      hr));
            continue;
        }

        //
        // Ignore the following checks when looking for a specific application
        // object.  The caller knows what he's doing in this case and may be
        // searching for a removed application specifically.
        //
        if ( pclsspec->tyspec != TYSPEC_OBJECTID )
        {
            //
            // Does it support AutoInstall?
            //
            if ((OnDemandInstallOnly) && (!(pPackageInfo->dwActFlags & ACTFLG_OnDemandInstall)))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FLAG,
                          pPackageInfo->pszPackageName,
                          ACTFLG_OnDemandInstall));

                continue;
            }

            // If it is neither Published nor Assigned then skip it.

            if ((!(pPackageInfo->dwActFlags & ACTFLG_Published)) &&
                (!(pPackageInfo->dwActFlags & ACTFLG_Assigned)))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FLAG,
                          pPackageInfo->pszPackageName,
                          ACTFLG_Assigned));

                continue;
            }

            // If it is an Orphaned App OR Uninstalled App do not return.

            if ((pPackageInfo->dwActFlags & ACTFLG_Orphan) ||
                (pPackageInfo->dwActFlags & ACTFLG_Uninstall))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FLAG,
                          pPackageInfo->pszPackageName,
                          ACTFLG_Uninstall));

                continue;
            }
        }

        //
        // Packages using the NT 5.0 beta 3 schema are not 
        // supported in subsequent versions of Windows
        //
        if ( ! (pPackageInfo->dwActFlags & ACTFLG_POSTBETA3) )
        {
            CSDBGPrint((DM_WARNING,
                        IDS_CSTORE_BETA3_ERR));
            continue;
        }

        GetAttributesFromPackageFlags(
            pPackageInfo->dwActFlags,
            &(pPackageInfo->InstallUiLevel),
            &(pPackageInfo->PathType));

        //
        // If querying by file ext check match and priority
        // 
        *pdwPriority = 0;

        if (pszFileExt)
        {
            //Column = fileExtension

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGFILEEXTNLIST, &column);

            cCount = 0;

            if (SUCCEEDED(hr))
            {
                hr = UnpackStrArrFrom(column, &pszList, &cCount);
            }

            if (SUCCEEDED(hr))
            {
                UINT cLen = wcslen(pszFileExt);

                for (j=0; j < cCount; ++j)
                {
                    LPOLESTR pStr = NULL;
                    
                    if (wcslen(pszList[j]) != (cLen+3))
                        continue;
                    if (wcsncmp(pszList[j], pszFileExt, wcslen(pszFileExt)) != 0)
                        continue;
                    *pdwPriority = (wcstoul(pszList[j]+(cLen+1), &pStr, 10))*PRI_EXTN_FACTOR;
                    break;
                }

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                break;
            }

            CsMemFree(pszList); pszList = NULL;

            //
            // If none matched skip this package
            //
            if (j == cCount) {

                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_FILE,
                          pPackageInfo->pszPackageName));

                continue;
            }
        }

        //
        // Now check Locale and Platform -- only do this
        // if a locale was specified
        //


        if (0 != pQryContext->Locale)
        {
            DWORD Wt = 0, MaxWt = 0;
            LANGID DesiredLang;

            DesiredLang = LANGIDFROMLCID(pQryContext->Locale);

            //Column = localeID
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, LOCALEID, &column);

            cCount = 0;

            if (SUCCEEDED(hr))
            {
                DWORD dwCount;

                cCount = 0;
                dwCount = 0;

                //
                // We pass dwCount instead of cCount to avoid
                // type conversion problems.  Note that we know the list
                // to always be of length 1 from the fact that
                // the deployment code will only use one language, so we
                // will not overflow this buffer
                //
                UnpackDWArrFrom(column, &pdwList, &dwCount);

                cCount = dwCount;

                ADSIFreeColumn(hADs, &column);
            }

            {
                //
                // If the caller specifies LANG_SYSTEM_DEFAULT, we interpret this
                // to mean that the caller wants us to choose apps according
                // to the language precedence in GetLanguagePriority.  If some
                // other langid was given, we then only accept exact matches and
                // give those matches the highest priority, PRI_LANG_ALWAYSMATCH
                //
                if (LANG_SYSTEM_DEFAULT == DesiredLang)
                {
                    Wt = GetLanguagePriority (
                        LANGIDFROMLCID(pdwList[0]),
                        pPackageInfo->dwActFlags);
                }
                else
                {
                    Wt = (DesiredLang == LANGIDFROMLCID(pdwList[0])) ?
                        PRI_LANG_ALWAYSMATCH :
                        0;
                }

                if (Wt > MaxWt)
                    MaxWt = Wt;
            }
            //
            // If none matched skip this package
            //
            DWORD dwLocale;
            BOOL  fHasLocale;

            fHasLocale = FALSE;

            if (pdwList)
            {
                dwLocale = LANGIDFROMLCID(pdwList[0]);
                CsMemFree(pdwList);
                fHasLocale = TRUE;
            }

            pdwList = NULL;

            // if nothing matched, quit
            if (MaxWt == 0)
            {
                if ( ! fHasLocale ) 
                {
                    CSDBGPrint((DM_WARNING,
                              IDS_CSTORE_MISSING_ATTR,
                              LOCALEID,
                              hr));
                }

                continue;
            }

            *pdwPriority += MaxWt;

            pPackageInfo->LangId = (LANGID) dwLocale;
        }

        hr = GetRsopSpecificAttributes(
            hADs,
            hADsSearchHandle,
            NULL,
            pPackageInfo,
            NULL);

        if (FAILED(hr))
        {
            CSDBGPrint((DM_WARNING,
                        IDS_CSTORE_RSOPERROR,
                        hr));
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwCount;

            cCount = 0;
            dwCount = 0;

            DWORD Wt = 0, MaxWt = 0;

            dwCount = pPackageInfo->cArchitectures;

            pdwList = pPackageInfo->prgArchitectures;

            cCount = dwCount;

            pPackageInfo->MatchedArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

            for (j=0; j < cCount; ++j)
            {
                PackPlatform (pdwList[j], &PkgPlatform);

                Wt = PlatformWt (&(pQryContext->Platform),
                                 &PkgPlatform,
                                 pPackageInfo->dwActFlags & ACTFLG_ExcludeX86OnIA64,
                                 SetupNamePath == pPackageInfo->PathType);

                if (Wt > MaxWt)
                {
                    pPackageInfo->MatchedArchitecture = pdwList[j];
                    MaxWt = Wt;
                }
            }

            pdwList = NULL;

            //
            // If none matched skip this package
            //
            if (MaxWt == 0)
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_ARCH,
                          pPackageInfo->pszPackageName));

                continue;
            }

            *pdwPriority += MaxWt;
        }
        else
        {
            continue;
        }

        // passed all the filters.

        //Column = OBJECTGUID
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, OBJECTGUID, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR pStr = NULL;

            UnpackGUIDFrom(column, &(pPackageInfo->PackageGuid));

            ADSIFreeColumn(hADs, &column);
        }

        //Column = ScriptPath
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, SCRIPTPATH, &column);
        if (SUCCEEDED(hr))
        {
            hr = UnpackStrAllocFrom(column, &(pPackageInfo->pszScriptPath));

            ADSIFreeColumn(hADs, &column);

            if (FAILED(hr))
            {
                break;
            }
        }

        if (SUCCEEDED(hr) && (pclsspec->tyspec == TYSPEC_CLSID))
        {
            //Column = comClassID
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGCLSIDLIST, &column);
            cCount = 0;
            if (SUCCEEDED(hr))
            {
                hr = UnpackStrArrFrom(column, &pszList, &cCount);

                if (cCount)
                {
                    DWORD   i=0, Ctx = 0;
                    WCHAR   szClsid[STRINGGUIDLEN], *szPtr = NULL;

                    StringFromGUID(pclsspec->tagged_union.clsid, szClsid);
                    for (i = 0; i < cCount; i++)
                        if (wcsncmp(pszList[i], szClsid, STRINGGUIDLEN-1) == 0)
                            break;

                    //
                    // The below assert is only hit if there is bad data -- if we find the
                    // clsid, i will not be cCount, and cCount will never be 0.  Basically,
                    // we're asserting that the search should always succeed if the ds data
                    // is good.
                    //
                    ASSERT(i != cCount);

                    if (i == cCount)
                    {
                        CSDBGPrint((DM_WARNING,
                                  IDS_CSTORE_SKIP_CLSID,
                                  pPackageInfo->pszPackageName));

                        CsMemFree(pszList);
                        continue;
                    }

                    if (wcslen(pszList[i]) > (STRINGGUIDLEN-1))
                        Ctx = wcstoul(pszList[i]+STRINGGUIDLEN, &szPtr, 16);

                    if ( ( Ctx & pQryContext->dwContext ) == 0 )
                    {
                        CsMemFree(pszList);
                        ADSIFreeColumn(hADs, &column);

                        CSDBGPrint((DM_WARNING,
                                  IDS_CSTORE_SKIP_CLSID,
                                  pPackageInfo->pszPackageName));

                        // none of the class context matched.
                        continue;
                    }
                    else
                        *pdwPriority += ClassContextWt((Ctx & pQryContext->dwContext));

                    CsMemFree(pszList);
                }

                ADSIFreeColumn(hADs, &column);

                if (FAILED(hr))
                {
                    break;
                }
            }
        }

        //Column = lastUpdateSequence
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGUSN, &column);
        if (SUCCEEDED(hr))
        {
            hr = UnpackStrFrom(column, &szUsn);
            TimeToUsn (szUsn, (CSUSN *)(&(pPackageInfo->Usn)));
            ADSIFreeColumn(hADs, &column);

            if (FAILED(hr))
            {
                break;
            }
        }
        else {

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PKGUSN,
                      hr));

            continue;
        }

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, PRODUCTCODE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->ProductCode));
            ADSIFreeColumn(hADs, &column);
        }

        //Column = versionNumberHi
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, VERSIONHI, &column);
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionHi));

            ADSIFreeColumn(hADs, &column);
        }

        //Column = versionNumberLo
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, VERSIONLO, &column);

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwVersionLo));

            ADSIFreeColumn(hADs, &column);
        }

        //Column = revision
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, REVISION, &column);

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &(pPackageInfo->dwRevision));

            ADSIFreeColumn(hADs, &column);
        }

        // Column = url
        // This one is optional and will be unset in most cases.
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, HELPURL, &column);

        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

            ADSIFreeColumn(hADs, &column);
        }

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, UPGRADESPACKAGES, &column);
        if (SUCCEEDED(hr))
        {
            LPOLESTR *pProp = NULL;
            hr = UnpackStrArrAllocFrom(column, &pProp, (DWORD *)&(pPackageInfo->cUpgrades));

            if (pPackageInfo->cUpgrades)
                pPackageInfo->prgUpgradeInfoList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*
                                                        (pPackageInfo->cUpgrades));

            if (pPackageInfo->prgUpgradeInfoList)
            {
                memset(pPackageInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pPackageInfo->cUpgrades));

                for (j=0; j < ( pPackageInfo->cUpgrades); ++j)
                {
                    WCHAR *pStr = NULL;
                    LPOLESTR ptr = (pPackageInfo->prgUpgradeInfoList[j].szClassStore) = pProp[j];
                    UINT len = wcslen (ptr);
                    if (len <= 41)
                        continue;

                    *(ptr + len - 3) = NULL;
                    (pPackageInfo->prgUpgradeInfoList[j].Flag) = wcstoul(ptr+(len-2), &pStr, 16);

                    *(ptr + len - 3 - 36 - 2) = L'\0';
                            /*      -GUID-'::'*/
                    GUIDFromString(ptr+len-3-36, &(pPackageInfo->prgUpgradeInfoList[j].PackageGuid));
                }

                pPackageInfo->cUpgrades = j; // we might have skipped some.
            }

            ADSIFreeColumn(hADs, &column);

            if (FAILED(hr))
            {
                break;
            }
        }

        //
        // Now that we know we will use this package, 
        // copy the common gpo-related information
        //
        memcpy( &(pPackageInfo->GpoId), pGpoId, sizeof( *pGpoId ) );

        pPackageInfo->pszGpoPath = StringDuplicate( wszGpoPath );

        if ( ! pPackageInfo->pszGpoPath )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        ++pPackageInfo;
        ++pdwPriority;
        (*pcRowsFetched)++;

        if (*pcRowsFetched == cRows)
            break;

        memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));
    }

    //
    // If we couldn't even retrieve the first row, return the error
    //
    if ((0 == *pcRowsFetched) && FAILED(hr))
    {
        return hr;
    }

    //
    // Check if we found as many as asked for
    //
    if (*pcRowsFetched != cRows)
        return S_FALSE;
    return S_OK;

}

// FetchPackageInfo
//-----------------
//
//  Gets the result set of the query : List of Package objects.
//  Returns the properties in PackageInfo structure.
//
HRESULT FetchPackageInfo(HANDLE             hADs,
                         ADS_SEARCH_HANDLE  hADsSearchHandle,
                         DWORD              dwFlags,
                         DWORD              dwQuerySpec,
                         CSPLATFORM        *pPlatform,
                         ULONG              cRows,
                         ULONG             *pcRowsFetched,
                         PACKAGEDISPINFO   *pPackageInfo,
                         BOOL              *fFirst,
                         GUID*              pGpoId,
                         WCHAR*             wszGpoPath,
                         PRSOPTOKEN         pRsopUserToken
                         )

{
    HRESULT             hr = S_OK;
    UINT                i, j;
    ULONG               cPlatforms = 0;
    DWORD             * dwPlatformList=NULL;
    LCID              * dwLocaleList=NULL;
    DWORD               dwPackageFlags;
    ULONG               cFetched = 0;
    ULONG               cRowsLeft = 0;
    CSPLATFORM          PkgPlatform;
    ADS_SEARCH_COLUMN   column;
    LPOLESTR            szUsn = NULL;
    BOOL                fInclude;
    BOOL                bUserHasAccess;

    *pcRowsFetched = 0;
    cRowsLeft = cRows;

    if (!cRowsLeft)
        return S_OK;

    //
    // Clear the first package
    //
    memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    // The LDAP filter performs a part of the selection
    // The flag filters are interpreted on the client after obtaining the result set

    for (;;)
    {
        //
        // Leave if there are no more rows to retrieve
        //
        if (!cRowsLeft)
        {
            break;
        }

        //
        // Free any resources from a previous iteration
        //
        ReleasePackageInfo(pPackageInfo);

        memset(pPackageInfo, 0, sizeof(*pPackageInfo));

        if ((*fFirst) && (!(*pcRowsFetched))) {
            *fFirst = FALSE;
            hr = ADSIGetFirstRow(hADs, hADsSearchHandle);
        }
        else
            hr = ADSIGetNextRow(hADs, hADsSearchHandle);

        if ((FAILED(hr)) || (hr == S_ADS_NOMORE_ROWS))
            break;

        fInclude = dwFlags & APPFILTER_INCLUDE_ALL ? TRUE : FALSE;

        //Column = packageName.

        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PACKAGENAME, &column);

        if (SUCCEEDED(hr))
        {
            hr = UnpackStrAllocFrom(column, &(pPackageInfo->pszPackageName));

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_EXAMINING,
                      pPackageInfo->pszPackageName));

            ADSIFreeColumn(hADs, &column);
        }

        if (FAILED(hr))
        {
            continue;
        }

        dwPackageFlags = 0;

        // Get the Flag Value: Column = packageFlags
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGEFLAGS, &column);

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(column, &dwPackageFlags);

            ADSIFreeColumn(hADs, &column);
        }
        else
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MISSING_ATTR,
                      PACKAGEFLAGS,
                      hr));

            continue;
        }

        //
        // Check flag values to see if this package meets the filter
        //

        //
        // If it is an Orphaned App, we only return it for APPINFO_ALL.
        //
        if ((dwPackageFlags & ACTFLG_Orphan) && (dwFlags & APPFILTER_REQUIRE_NON_REMOVED))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_NON_REMOVED,
                      ACTFLG_Orphan));

            continue;
        }

        // If it is an Uninstalled App return it if asked for by APPINFO_ALL

        if ((dwPackageFlags & ACTFLG_Uninstall) && (dwFlags & APPFILTER_REQUIRE_NON_REMOVED))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_NON_REMOVED,
                      ACTFLG_Uninstall));

            continue;
        }

        if ((dwFlags & APPFILTER_REQUIRE_PUBLISHED) && (!(dwPackageFlags & ACTFLG_Published)))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_PUBLISHED,
                      ACTFLG_Published));

            continue;
        }

        if ((dwFlags & APPFILTER_INCLUDE_ASSIGNED) && (dwPackageFlags & ACTFLG_Assigned))
        {
            fInclude = TRUE;
        }

        if ((dwFlags & APPFILTER_INCLUDE_UPGRADES) && (dwPackageFlags & ACTFLG_HasUpgrades))
        {
            fInclude = TRUE;
        }

        if ((dwFlags & APPFILTER_REQUIRE_VISIBLE) && (!(dwPackageFlags & ACTFLG_UserInstall)))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_VISIBLE,
                      ACTFLG_UserInstall));

            continue;
        }

        if ((dwFlags & APPFILTER_REQUIRE_AUTOINSTALL) && (!(dwPackageFlags & ACTFLG_OnDemandInstall)))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_FILTER,
                      pPackageInfo->pszPackageName,
                      APPFILTER_REQUIRE_AUTOINSTALL,
                      ACTFLG_OnDemandInstall));

            continue;
        }

        //
        // Packages using the NT 5.0 beta 3 schema are not 
        // supported in subsequent versions of Windows
        //
        if ( ! (dwPackageFlags & ACTFLG_POSTBETA3) )
        {
            //
            // Only allow administrators to see beta 3 deployments for
            // administrative purposes (to delete the data).  In NT 6.0, we
            // should no longer support even this
            //
            if ( APPQUERY_ADMINISTRATIVE != dwQuerySpec )
            {
                CSDBGPrint((DM_WARNING,
                            IDS_CSTORE_BETA3_ERR));
                continue;
            }

            //Column = packageType
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, PACKAGETYPE, &column);

            if (SUCCEEDED(hr))
            {
                UnpackDWFrom(column, (DWORD *)&(pPackageInfo->PathType));

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                continue;
            }

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, UILEVEL, &column);

            if (SUCCEEDED(hr))
            {
                UnpackDWFrom(column, (DWORD *)&(pPackageInfo->InstallUiLevel));

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                continue;
            }
        }

        if ( dwPackageFlags & ACTFLG_POSTBETA3 )
        {
            GetAttributesFromPackageFlags(
                dwPackageFlags,
                &(pPackageInfo->InstallUiLevel),
                &(pPackageInfo->PathType));
        }

        if (( dwFlags & APPFILTER_REQUIRE_MSI) && (pPackageInfo->PathType != DrwFilePath))
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_MSI,
                      pPackageInfo->pszPackageName,
                      pPackageInfo->PathType));

            continue;
        }

        pPackageInfo->LangId = LANG_NEUTRAL;

        //
        // If the package flags specify that we should ignore locale, or the
        // caller specified that all locale's are acceptable, skip the language
        // checks
        //
        {
            LANGID PackageLangId;
            DWORD  cLanguages;

            PackageLangId = LANG_NEUTRAL;

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, LOCALEID, &column);

            dwLocaleList = NULL;

            if (SUCCEEDED(hr))
            {
                // type change. shouldn't affect anything.
                UnpackDWArrFrom(column, &dwLocaleList, &cLanguages);

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_MISSING_ATTR,
                          LOCALEID,
                          hr));

                continue;
            }

            //
            // We only care about the first language returned -- originally
            // the packages in the ds could support multiple locales, but
            // we now only support one language
            //
            if (cLanguages)
            {
                PackageLangId = LANGIDFROMLCID(dwLocaleList[0]);
            }

            CsMemFree(dwLocaleList);

            //
            // If the package flags specify that we should ignore locale, or the
            // caller specified that all locale's are acceptable, skip the language
            // checks
            //
            if ( (dwFlags & APPFILTER_REQUIRE_THIS_LANGUAGE) &&
                 ! ( dwPackageFlags & ACTFLG_IgnoreLanguage ) )
            {
                if (!cLanguages || !MatchLanguage(PackageLangId, dwPackageFlags))
                {
                    CSDBGPrint((DM_WARNING,
                              IDS_CSTORE_MISSING_ATTR,
                              LOCALEID,
                              hr));

                    continue;
                }
            }

            pPackageInfo->LangId = PackageLangId;
        }

        if (pPlatform != NULL)
        {

            //Column = machineArchitecture
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, ARCHLIST, &column);
            cPlatforms = 0;
            dwPlatformList = NULL;

            if (SUCCEEDED(hr))
            {
                UnpackDWArrFrom(column, &dwPlatformList, &cPlatforms);

                ADSIFreeColumn(hADs, &column);
            }
            else
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_MISSING_ATTR,
                          ARCHLIST,
                          hr));

                continue;
            }

            DWORD MaxPlatformWeight;

            MaxPlatformWeight = 0;

            pPackageInfo->MatchedArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

            for (j=0; j < cPlatforms; ++j)
            {
                DWORD PlatformWeight;

                PackPlatform (dwPlatformList[j], &PkgPlatform);
                PlatformWeight = PlatformWt (pPlatform,
                                             &PkgPlatform,
                                             dwPackageFlags & ACTFLG_ExcludeX86OnIA64,
                                             SetupNamePath == pPackageInfo->PathType);

                if ( PlatformWeight > MaxPlatformWeight )
                {
                    pPackageInfo->MatchedArchitecture = dwPlatformList[j];
                    MaxPlatformWeight = PlatformWeight;
                }
            }

            if (dwPlatformList)
                CsMemFree(dwPlatformList);
            //
            // If none matched skip this package
            //
            if ( 0 == MaxPlatformWeight )
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_SKIP_ARCH,
                          pPackageInfo->pszPackageName));

                continue;
            }
        }

        pPackageInfo->dwActFlags = dwPackageFlags;

        //Column = OBJECTGUID
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, OBJECTGUID, &column);

        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->PackageGuid));

            ADSIFreeColumn(hADs, &column);
        }

        if ( ! (APPFILTER_CONTEXT_ARP & dwFlags) ||
            (APPFILTER_CONTEXT_RSOP & dwFlags) )
        {
            //Column = ScriptPath
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, SCRIPTPATH, &column);

            if (SUCCEEDED(hr))
            {
                UnpackStrAllocFrom(column, &(pPackageInfo->pszScriptPath));

                ADSIFreeColumn(hADs, &column);
            }
        }

        if ( ! (APPFILTER_CONTEXT_ARP & dwFlags) ||
            (APPFILTER_CONTEXT_RSOP & dwFlags) )
        {
            //Column = lastUpdateSequence,
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, PKGUSN, &column);

            if (SUCCEEDED(hr))
            {
                UnpackStrFrom(column, &szUsn);
                TimeToUsn (szUsn, (CSUSN *)(&(pPackageInfo->Usn)));
                ADSIFreeColumn(hADs, &column);
            }
            else {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_MISSING_ATTR,
                          PKGUSN,
                          hr));

                continue;
            }
        }

        // ProductCode
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, PRODUCTCODE, &column);
        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &(pPackageInfo->ProductCode));
            ADSIFreeColumn(hADs, &column);
        }

        if ( ! (APPFILTER_CONTEXT_ARP & dwQuerySpec) ||
            (APPFILTER_CONTEXT_RSOP & dwFlags) )
        {
            //Column = revision
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_INTEGER, REVISION, &column);

            if (SUCCEEDED(hr))
            {
                UnpackDWFrom(column, &(pPackageInfo->dwRevision));

                ADSIFreeColumn(hADs, &column);
            }
        }

        // Column = url
        // This one is optional and will be unset in most cases.
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, HELPURL, &column);

        if (SUCCEEDED(hr))
        {
            UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

            ADSIFreeColumn(hADs, &column);
        }

        //
        // We need to grab additional attributes for rsop logging
        //
        if ( APPFILTER_CONTEXT_RSOP & dwFlags )
        {
            hr = GetRsopSpecificAttributes(
                hADs,
                hADsSearchHandle,
                pRsopUserToken,
                pPackageInfo,
                &bUserHasAccess);

            if (FAILED(hr))
            {
                CSDBGPrint((DM_WARNING,
                          IDS_CSTORE_RSOPERROR,
                          hr));
            }
            else
            {
                if ( pRsopUserToken && ( ! bUserHasAccess ) )
                {
                    continue;
                }
            }
        }

        if ( (APPFILTER_CONTEXT_RSOP & dwFlags) ||
             (APPFILTER_CONTEXT_ARP & dwFlags) )
        {
            hr = GetCategories(
                hADs,
                hADsSearchHandle,
                pPackageInfo);

            if ( FAILED(hr) )
            {
                CSDBGPrint((DM_WARNING,
                            IDS_CSTORE_MISSING_ATTR,
                            PKGCATEGORYLIST,
                            hr));

                continue;
            }

            // This one is optional and will be unset in most cases.
            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, HELPURL, &column);

            if (SUCCEEDED(hr))
            {
                UnpackStrAllocFrom(column, &(pPackageInfo->pszUrl));

                ADSIFreeColumn(hADs, &column);
            }
            hr = S_OK;
        }

        if ( dwPackageFlags & ACTFLG_HasUpgrades )
        {

            hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, UPGRADESPACKAGES, &column);
            if (SUCCEEDED(hr))
            {
                LPOLESTR *pProp = NULL;
                hr = UnpackStrArrAllocFrom(column, &pProp, (DWORD *)&(pPackageInfo->cUpgrades));

                if (pPackageInfo->cUpgrades)
                    pPackageInfo->prgUpgradeInfoList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*
                                                                                 (pPackageInfo->cUpgrades));

                if (pPackageInfo->prgUpgradeInfoList)
                {
                    memset(pPackageInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pPackageInfo->cUpgrades));

                    for (j=0; j < ( pPackageInfo->cUpgrades); ++j)
                    {
                        BOOL  fGotGPO;
                        WCHAR *pStr = NULL;
                        LPOLESTR ptr = (pPackageInfo->prgUpgradeInfoList[j].szClassStore) = pProp[j];
                        UINT len = wcslen (ptr);
                        if (len <= 41)
                            continue;

                        //
                        // Find the GPO for this upgrade
                        //
                        fGotGPO = GetGpoIdFromClassStorePath(
                            pPackageInfo->prgUpgradeInfoList[j].szClassStore,
                            &(pPackageInfo->prgUpgradeInfoList[j].GpoId));

                        if (!fGotGPO)
                        {
                            continue;
                        }


                        *(ptr + len - 3) = NULL;
                        (pPackageInfo->prgUpgradeInfoList[j].Flag) = wcstoul(ptr+(len-2), &pStr, 16);

                        *(ptr + len - 3 - 36 - 2) = L'\0';
                        /*      -GUID-'::'*/
                        GUIDFromString(ptr+len-3-36, &(pPackageInfo->prgUpgradeInfoList[j].PackageGuid));
                    }
                    pPackageInfo->cUpgrades = j; // we might have skipped some.

                    fInclude = TRUE;
                }
            }
        }

        if (!fInclude)
        {
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_SKIP_INCLUDE,
                      pPackageInfo->pszPackageName));

            continue;
        }

        //
        // Now that we know we will use this package, 
        // copy the common gpo-related information
        //
        memcpy( &(pPackageInfo->GpoId), pGpoId, sizeof( *pGpoId ) );

        pPackageInfo->pszGpoPath = StringDuplicate( wszGpoPath );

        if ( ! pPackageInfo->pszGpoPath )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        ++pPackageInfo;

        cRowsLeft--;

        (*pcRowsFetched)++;

        if (!cRowsLeft)
        {
            break;
        }

        //
        // Clear the data in the PackageInfo structure
        //
        memset(pPackageInfo, 0, sizeof(PACKAGEDISPINFO));

    }

    //
    // If we couldn't even retrieve the first row, return the error
    //
    if ((0 == *pcRowsFetched) && FAILED(hr))
    {
        return hr;
    }

    if (!cRowsLeft)
        return S_OK;
    return S_FALSE;
}

// FetchCategory
//--------------
//
// List of columns this routine fetches.
//

HRESULT FetchCategory(HANDLE                hADs,
                      ADS_SEARCH_HANDLE     hADsSearchHandle,
                      APPCATEGORYINFOLIST * pCategoryInfoList,
                      LCID                  Locale
                      )
{
    HRESULT                 hr = S_OK;
    ADS_SEARCH_COLUMN       column;
    LPOLESTR              * pszDesc = NULL;
    DWORD                   cdesc = 0, i = 0;
    LPOLESTR                szCatid = NULL;
    DWORD                   cMaxCategories;
    DWORD                   cCategories;

    cMaxCategories = 0;
    cCategories = 0;

    pCategoryInfoList->pCategoryInfo = NULL;

    for (hr = ADSIGetFirstRow(hADs, hADsSearchHandle), i = 0;
                   ((SUCCEEDED(hr)) && ((hr) != S_ADS_NOMORE_ROWS));
                   hr = ADSIGetNextRow(hADs, hADsSearchHandle), i++)
    {
        APPCATEGORYINFO*        pCurrentCategories;

        cCategories++;

        //
        // First, verify that we have enough space to store
        // the next category
        //
        if ( cCategories > cMaxCategories )
        {
            //
            // Get enough space for the current categories as well
            // as some extra since we still don't know how many more categories
            // we have
            //
            cMaxCategories += CATEGORY_RETRIEVAL_ALLOC_SIZE;
            
            pCurrentCategories = (APPCATEGORYINFO*) CsMemAlloc( cMaxCategories * sizeof(APPCATEGORYINFO) );

            if ( !pCurrentCategories )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if ( pCategoryInfoList->pCategoryInfo )
            {
                //
                // We have enough space, copy the existing entries -- 
                // note that the list engrties  are not self-referential, so we can
                // blindly copy them, but the list itself contains a pointer into itself,
                // so this must be adjusted after the copy
                //
                memcpy( pCurrentCategories, pCategoryInfoList->pCategoryInfo, i * sizeof(APPCATEGORYINFO) );

                //
                // Free the old list since it is no longer needed.  Note that
                // we do not user the ReleaseAppCategoryInfoList api to free 
                // the list since that would also free memory referenced by
                // members of elements of the category array -- we want to preserve
                // these references in the succeeding copy
                //
                if ( pCategoryInfoList->pCategoryInfo )
                {
                    CsMemFree( pCategoryInfoList->pCategoryInfo );

                    pCategoryInfoList->pCategoryInfo = NULL;
                }
            }

            //
            // Clear the newly added entries
            //
            memset( &(pCurrentCategories[i]), 0, sizeof(APPCATEGORYINFO) * CATEGORY_RETRIEVAL_ALLOC_SIZE );

            //
            // Set the list structure to refer to the successfully 
            // reallocated memory
            //
            pCategoryInfoList->pCategoryInfo = pCurrentCategories;
        }

        // Get the data from each row ignoring the error returned.

        //Column = description
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_CASE_IGNORE_STRING, LOCALEDESCRIPTION, &column);
        cdesc = 0; pszDesc = NULL;

        if (SUCCEEDED(hr))
            UnpackStrArrFrom(column, &pszDesc, &cdesc);

        (pCategoryInfoList->pCategoryInfo)[i].Locale = Locale;
        (pCategoryInfoList->pCategoryInfo)[i].pszDescription =
                            (LPOLESTR)CsMemAlloc( (CAT_DESC_MAX_LEN + 1) * sizeof(WCHAR));

        // The description has a maximum size.

        if ((pCategoryInfoList->pCategoryInfo)[i].pszDescription)
            GetCategoryLocaleDesc(pszDesc, cdesc, &((pCategoryInfoList->pCategoryInfo)[i].Locale),
                                        (pCategoryInfoList->pCategoryInfo)[i].pszDescription);

        if (SUCCEEDED(hr))
            ADSIFreeColumn(hADs, &column);

        if (pszDesc)
            CsMemFree(pszDesc);

        // catid
        hr = DSGetAndValidateColumn(hADs, hADsSearchHandle, ADSTYPE_OCTET_STRING, CATEGORYCATID, &column);

        if (SUCCEEDED(hr))
        {
            UnpackGUIDFrom(column, &((pCategoryInfoList->pCategoryInfo)[i].AppCategoryId));

            ADSIFreeColumn(hADs, &column);
        }
    }

    pCategoryInfoList->cCategory = i;

    //
    // On failure, clean up the category list so the caller
    // will not attempt to use invalid data
    //
    if (FAILED(hr))
    {
        ReleaseAppCategoryInfoList( pCategoryInfoList );
    }

    return hr;
}

HRESULT GetPackageDetail (HANDLE           hPackageADs, WCHAR *szClassContainerPath,
                          PACKAGEDETAIL   *pPackageDetail)
{
    HRESULT             hr = S_OK;
    GUID                PkgGuid;
    DWORD              *pdwArch = NULL, count = 0;
    PLATFORMINFO       *pPlatformInfo = NULL;
    INSTALLINFO        *pInstallInfo = NULL;
    ACTIVATIONINFO     *pActInfo = NULL;
    ADS_ATTR_INFO      *pAttr = NULL;
    DWORD               posn, cgot = 0;
    DWORD               cClasses = 0;
    LPOLESTR           *szClasses = NULL;
        DWORD                           dwUiLevel = 0;
    DWORD               cProgId = 0;
    LPOLESTR           *pszProgId = NULL;

    memset (pPackageDetail, 0, sizeof (PACKAGEDETAIL));

    hr = ADSIGetObjectAttributes(hPackageADs, pszPackageDetailAttrNames, cPackageDetailAttr,
                &pAttr, &cgot);
    RETURN_ON_FAILURE(hr);

    pInstallInfo = pPackageDetail->pInstallInfo = (INSTALLINFO *) CsMemAlloc(sizeof (INSTALLINFO));

    if (!pInstallInfo)
        ERROR_ON_FAILURE((hr=E_OUTOFMEMORY));

    memset(pInstallInfo, NULL, sizeof(INSTALLINFO));

    posn = GetPropertyFromAttr(pAttr, cgot,  PACKAGEFLAGS);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], (DWORD *)&(pInstallInfo->dwActFlags));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));

    posn = GetPropertyFromAttr(pAttr, cgot, SCRIPTPATH);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszScriptPath));

    posn = GetPropertyFromAttr(pAttr, cgot, SCRIPTSIZE);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn], &(pInstallInfo->cScriptLen));

    posn = GetPropertyFromAttr(pAttr, cgot, SETUPCOMMAND);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszSetupCommand));

    posn = GetPropertyFromAttr(pAttr, cgot, HELPURL);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn], &(pInstallInfo->pszUrl));

    posn = GetPropertyFromAttr(pAttr, cgot, PKGUSN);
    if (posn < cgot)
        UsnGet(pAttr[posn], (CSUSN *)&(pInstallInfo->Usn));
    else
        ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));

    posn = GetPropertyFromAttr(pAttr, cgot, PRODUCTCODE);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->ProductCode));

    //
    // Obtain the MVIPC, which is really just an upgrade code used on the server side UI
    // only to detect whether the ds contains upgrades that are mandated by a package
    //
    posn = GetPropertyFromAttr(pAttr, cgot, MVIPC);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->Mvipc));

    // doesn't matter if the property itself is multivalued.

    posn = GetPropertyFromAttr(pAttr, cgot, OBJECTGUID);
    if (posn < cgot)
        UnpackGUIDFrom(pAttr[posn], &(pInstallInfo->PackageGuid));

    posn = GetPropertyFromAttr(pAttr, cgot, VERSIONHI);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwVersionHi));

    posn = GetPropertyFromAttr(pAttr, cgot, VERSIONLO);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwVersionLo));

    posn = GetPropertyFromAttr(pAttr, cgot, REVISION);
    if (posn < cgot)
        UnpackDWFrom(pAttr[posn],   &(pInstallInfo->dwRevision));

    //
    // Packages deployed before NT 5.0 beta 3 are in a
    // format that will not be supported for subsequent versions
    // of Windows.  However, we must support it for NT 5.1 at least
    // from the admin UI so that the they can be un-deployed.  This
    // function is called in the context of the admin UI, so we
    // will interpret the beta 3 schema
    //
    if (pInstallInfo->dwActFlags & ACTFLG_POSTBETA3)
    {
        GetAttributesFromPackageFlags(
            pInstallInfo->dwActFlags,
            (UINT*) &dwUiLevel,
            &(pInstallInfo->PathType));
    }
    else
    {
        posn = GetPropertyFromAttr(pAttr, cgot, UILEVEL);
        if (posn < cgot)
            UnpackDWFrom(pAttr[posn], &dwUiLevel);

        posn = GetPropertyFromAttr(pAttr, cgot, PACKAGETYPE);
        if (posn < cgot)
            UnpackDWFrom(pAttr[posn], (DWORD *)&(pInstallInfo->PathType));
        else
            ERROR_ON_FAILURE((hr=CS_E_OBJECT_NOTFOUND));
    }

    pInstallInfo->InstallUiLevel = dwUiLevel;

    posn = GetPropertyFromAttr(pAttr, cgot, UPGRADESPACKAGES);
    if (posn < cgot)
    {
        LPOLESTR *pProp = NULL;
        UnpackStrArrAllocFrom(pAttr[posn], &pProp, (DWORD *)&(pInstallInfo->cUpgrades));

        if (pInstallInfo->cUpgrades)
            pInstallInfo->prgUpgradeInfoList = (UPGRADEINFO *)CsMemAlloc(sizeof(UPGRADEINFO)*
                                                                             pInstallInfo->cUpgrades);

        if (!(pInstallInfo->prgUpgradeInfoList))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        memset(pInstallInfo->prgUpgradeInfoList, 0, sizeof(UPGRADEINFO)*(pInstallInfo->cUpgrades));

        for (count = 0; (count < (pInstallInfo->cUpgrades)); count++)
        {
            WCHAR *pStr = NULL;
            LPOLESTR ptr = (pInstallInfo->prgUpgradeInfoList[count].szClassStore) = pProp[count];
            UINT len = wcslen (ptr);

            if (len <= 41)
                continue;

            *(ptr + len - 3) = NULL;
            pInstallInfo->prgUpgradeInfoList[count].Flag = wcstoul(ptr+(len-2), &pStr, 16);

            *(ptr + len - 3 - 36 - 2) = L'\0';
                    /*      -GUID-'::'*/
            GUIDFromString(ptr+len-3-36, &(pInstallInfo->prgUpgradeInfoList[count].PackageGuid));
        }
        pInstallInfo->cUpgrades = count; // we might have skipped some.
    }


    pPlatformInfo = pPackageDetail->pPlatformInfo =
        (PLATFORMINFO *) CsMemAlloc(sizeof (PLATFORMINFO));
    if (!pPlatformInfo)
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    memset(pPlatformInfo, NULL, sizeof(PLATFORMINFO));

    posn = GetPropertyFromAttr(pAttr, cgot, ARCHLIST);

    if (posn < cgot)
    {
        DWORD dwPlatforms;

        //
        // Note that since the UnpackDWArrFrom takes a DWORD*, we should
        // avoid passing the int directly and instead pass a DWORD
        //
        UnpackDWArrFrom(pAttr[posn], &pdwArch, &dwPlatforms);

        pPlatformInfo->cPlatforms = dwPlatforms;
    }

    pPlatformInfo->prgPlatform = (CSPLATFORM *)CsMemAlloc(sizeof(CSPLATFORM)*
        (pPlatformInfo->cPlatforms));

    if (!(pPlatformInfo->prgPlatform))
        ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

    for (count = 0; (count < (pPlatformInfo->cPlatforms)); count++)
        PackPlatform (pdwArch[count], (pPlatformInfo->prgPlatform)+count);

    CsMemFree(pdwArch);

    posn = GetPropertyFromAttr(pAttr, cgot, LOCALEID);
    if (posn < cgot)
    {
        DWORD dwLocales;

        //
        // Again, we typecast before getting the address that we
        // need to pass the count to the unpack function
        //

        UnpackDWArrFrom(pAttr[posn], &(pPlatformInfo->prgLocale),
                        &dwLocales);

        pPlatformInfo->cLocales = dwLocales;
    }

    //
    // fill in ActivationInfo.
    //

    pActInfo = pPackageDetail->pActInfo =
        (ACTIVATIONINFO *) CsMemAlloc(sizeof (ACTIVATIONINFO));

    if (!pActInfo) {
        hr = E_OUTOFMEMORY;
        ERROR_ON_FAILURE(hr);
    }

    memset(pActInfo, NULL, sizeof(ACTIVATIONINFO));

    //
    // Do not obtain clsid's, typelibid's, iid's  & progid's -- this data is never used.
    // However, we do check to see if there is any clsid data so that we can set the
    // member of the packagedetails which indicates that the package has com class information
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PKGCLSIDLIST);

    //
    // In order to be consistent with NT5, We assume that if we do not find the classes
    // attribute, that the administrator wanted the package to be deployed with classes,
    // but the package had no classes.  
    //
    pActInfo->bHasClasses = TRUE;

    //
    // If we searched the returned attribute list and found it before passing
    // the last attribute, this package has classes
    //
    if ( posn < cgot )
    {
        //
        // We have the attribute, but if it is set to an "empty" value,
        // this means that an NT 5.1 or higher system deployed this package without classes
        //
        if ( 1 == pAttr->dwNumValues )
        {
            LPOLESTR* ppwszClsid;
 
            hr = UnpackStrArrFrom(pAttr[posn], &ppwszClsid, &cClasses);

            ERROR_ON_FAILURE(hr);

            //
            // Check for the "empty" value
            //
            if ( 0 == lstrcmp( *ppwszClsid, PKG_EMPTY_CLSID_VALUE ) )
            {
                pActInfo->bHasClasses = FALSE;
            }
        }
    }

    //
    // Do obtain file extensions
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PKGFILEEXTNLIST);
    cClasses = 0;

    if (posn < cgot)
        UnpackStrArrAllocFrom(pAttr[posn], &(pActInfo->prgShellFileExt), &cClasses);
    pActInfo->cShellFileExt = cClasses;

    if (cClasses)
    {
        pActInfo->prgPriority = (UINT *)CsMemAlloc(cClasses * sizeof(UINT));
        if (!(pActInfo->prgPriority))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        for (count = 0; count < cClasses; count++)
        {
            LPOLESTR pStr=NULL;
            UINT cLen = wcslen((pActInfo->prgShellFileExt)[count]);
            *((pActInfo->prgShellFileExt)[count] + (cLen - 3)) = NULL;
            (pActInfo->prgPriority)[count] =
                wcstoul((pActInfo->prgShellFileExt)[count]+(cLen-2), &pStr, 10);
        }
    }

    //
    // fill in package misc info
    //
    posn = GetPropertyFromAttr(pAttr, cgot, PACKAGENAME);
    if (posn < cgot)
        UnpackStrAllocFrom(pAttr[posn],   &(pPackageDetail->pszPackageName));
    else
        ERROR_ON_FAILURE(hr=CS_E_OBJECT_NOTFOUND);

    posn = GetPropertyFromAttr(pAttr, cgot, MSIFILELIST);
    if (posn < cgot) {
        LPOLESTR *rpszSourceList = NULL, psz = NULL, pStr = NULL;
        DWORD     Loc = 0;

        UnpackStrArrFrom(pAttr[posn], &(rpszSourceList),
                                                         (DWORD *)&(pPackageDetail->cSources));

        // reorder and allocate spaces.
        if (pPackageDetail->cSources)
        {
            pPackageDetail->pszSourceList = (LPOLESTR *)CsMemAlloc(sizeof(LPOLESTR)*
                                                                        (pPackageDetail->cSources));
            if (!(pPackageDetail->pszSourceList))
                ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

            for (count = 0; count < (pPackageDetail->cSources); count++)
            {
                psz = wcschr(rpszSourceList[count], L':');
                *psz = L'\0';
                Loc = wcstoul(rpszSourceList[count], &pStr, 10);
                pPackageDetail->pszSourceList[Loc] = (LPOLESTR)CsMemAlloc(sizeof(WCHAR)*(wcslen(psz+1)+1));
                if (!(pPackageDetail->pszSourceList[Loc]))
                    ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

                swprintf(pPackageDetail->pszSourceList[Loc], L"%s", psz+1);
            }
        }

        CsMemFree(rpszSourceList);
    }

    posn = GetPropertyFromAttr(pAttr, cgot, PKGCATEGORYLIST);
    cClasses = 0; szClasses = NULL;

    if (posn < cgot)
        UnpackStrArrFrom(pAttr[posn], &szClasses, &cClasses);

    if (cClasses)
    {
        pPackageDetail->rpCategory = (GUID *)CsMemAlloc (sizeof(GUID) * cClasses);
        if (!(pPackageDetail->rpCategory))
            ERROR_ON_FAILURE(hr = E_OUTOFMEMORY);
        pPackageDetail->cCategories = cClasses;
        for (count = 0; count < cClasses; count++)
        {
            GUIDFromString(szClasses[count], (pPackageDetail->rpCategory + count));
        }
        CsMemFree(szClasses);
    }

    return S_OK;

Error_Cleanup:
    ReleasePackageDetail(pPackageDetail);
    memset(pPackageDetail, 0, sizeof(PACKAGEDETAIL));

    if (pAttr)
        FreeADsMem(pAttr);

    return hr;
}


// GetRsopSpecificAttributes
//--------------------------
//
// Retrieves attributes not normally gathered except for when
// diagnostic rsop logging is enabled.

HRESULT GetRsopSpecificAttributes(
    HANDLE            hAds,
    ADS_SEARCH_HANDLE hSearchHandle,
    PRSOPTOKEN        pRsopUserToken,
    PACKAGEDISPINFO*  pPackageInfo,
    BOOL*             pbUserHasAccess )
{
    HRESULT           hr;
    ADS_SEARCH_COLUMN ResultColumn;

    if ( pbUserHasAccess )
    {
        *pbUserHasAccess = TRUE;
    }

    pPackageInfo->rgSecurityDescriptor = NULL;
    pPackageInfo->cbSecurityDescriptor = 0;
    pPackageInfo->prgTransforms = NULL;
    pPackageInfo->prgArchitectures = NULL;

    pPackageInfo->cTransforms = 0;
    pPackageInfo->cArchitectures = 0;

    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_CASE_IGNORE_STRING,
        PUBLISHER,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {
        UnpackStrAllocFrom(ResultColumn, &(pPackageInfo->pszPublisher));

        ADSIFreeColumn(hAds, &ResultColumn);
    }

    //
    // Obtain the list of machine architectures
    //
    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_INTEGER,
        ARCHLIST,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {
        DWORD dwArchitectures;

        UnpackDWArrFrom(
            ResultColumn,
            &(pPackageInfo->prgArchitectures),
            &dwArchitectures);

        pPackageInfo->cArchitectures = dwArchitectures;

        ADSIFreeColumn(hAds, &ResultColumn);
    }

    //
    // Attempt to unmarshal the transform list
    //
    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_CASE_IGNORE_STRING,
        MSIFILELIST,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {
        //
        // Copy the transform list into a string -- note that this call
        // also allocates the array so we must free it later.
        //
        DWORD cTransforms;

        UnpackStrArrAllocFrom(ResultColumn,
                              &(pPackageInfo->prgTransforms),
                              &cTransforms);

        pPackageInfo->cTransforms = cTransforms;

        ADSIFreeColumn(hAds, &ResultColumn);
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // Get the app's major version number
        //
        hr = DSGetAndValidateColumn(
            hAds, 
            hSearchHandle,
            ADSTYPE_INTEGER,
            VERSIONHI,
            &ResultColumn);
        

        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(ResultColumn, &(pPackageInfo->dwVersionHi));
            
            ADSIFreeColumn(hAds, &ResultColumn);
        }
    }

    if ( SUCCEEDED(hr) )
    {
        //
        // Get the app's minor version number
        //
        hr = DSGetAndValidateColumn(
            hAds,
            hSearchHandle,
            ADSTYPE_INTEGER,
            VERSIONLO,
            &ResultColumn);
    
        if (SUCCEEDED(hr))
        {
            UnpackDWFrom(ResultColumn, &(pPackageInfo->dwVersionLo));
            
            ADSIFreeColumn(hAds, &ResultColumn);
        }
    }
     
    if ( SUCCEEDED(hr) )
    {
        //
        // Grab the security descriptor
        //
        (void) GetSecurityDescriptor(
            hAds,
            hSearchHandle,
            pRsopUserToken,
            pPackageInfo,
            pbUserHasAccess);
    }

    return hr;
}

HRESULT GetSecurityDescriptor(
    HANDLE            hAds,
    ADS_SEARCH_HANDLE hSearchHandle,
    PRSOPTOKEN        pRsopUserToken,
    PACKAGEDISPINFO*  pPackageInfo,
    BOOL*             pbUserHasAccess)
{
    HRESULT              hr;
    ADS_SEARCH_COLUMN    SecurityColumn;
    BOOL                 bFreeSecurityColumn;

    //
    // Now unmarshal the security descriptor
    //
    hr = DSGetAndValidateColumn(hAds, hSearchHandle, ADSTYPE_NT_SECURITY_DESCRIPTOR, SECURITYDESCRIPTOR, &SecurityColumn);

    if (SUCCEEDED(hr))
    {
        //
        // Allocate the security descriptor
        //
        hr = UnpackByteAllocFrom(
            SecurityColumn,
            (BYTE**) &(pPackageInfo->rgSecurityDescriptor),
            &(pPackageInfo->cbSecurityDescriptor));

        bFreeSecurityColumn = TRUE;
    }

    //
    // In planning mode, we must perform the access check ourselves
    //
    if ( SUCCEEDED(hr) && pbUserHasAccess && pRsopUserToken )
    {
        hr = DSAccessCheck(
            pPackageInfo->rgSecurityDescriptor,
            pRsopUserToken,
            pbUserHasAccess);
    }

    if ( bFreeSecurityColumn )
    {
        ADSIFreeColumn(hAds, &SecurityColumn);
    }

    return hr;
}


// GetCategories
//--------------------------
//
// Retrieves the categories attribute for an application
// in bracketed guid string format

HRESULT GetCategories(
    HANDLE            hAds,
    ADS_SEARCH_HANDLE hSearchHandle,
    PACKAGEDISPINFO*  pPackageInfo)
{
    HRESULT           hr;
    ADS_SEARCH_COLUMN ResultColumn;
    BOOL              bFreeCategoriesColumn;

    pPackageInfo->prgCategories = NULL;

    pPackageInfo->cCategories = 0;

    bFreeCategoriesColumn = FALSE;

    //
    // Unmarshal the category list -- this package may have no catgories,
    // in which case this call will return a failure
    //
    hr = DSGetAndValidateColumn(
        hAds,
        hSearchHandle,
        ADSTYPE_CASE_IGNORE_STRING,
        PKGCATEGORYLIST,
        &ResultColumn);

    if (SUCCEEDED(hr))
    {  
        DWORD cCategories;

        //
        // Convert this to an array of guids -- note that the array
        // is allocated and should be freed.
        //
        UnpackStrArrFrom(ResultColumn,
                         &(pPackageInfo->prgCategories),
                         &cCategories);

        pPackageInfo->cCategories = cCategories;

        bFreeCategoriesColumn = TRUE;
    } 

    //
    // Since the category guids stored in the ds lack the begin and end
    // braces, we must add them so that our callers, who expect such guids,
    // will get the correct information
    //
    DWORD iCategoryGuid;

    hr = S_OK;

    for ( iCategoryGuid = 0; iCategoryGuid < pPackageInfo->cCategories; iCategoryGuid++ )
    {
        WCHAR* wszNewGuid;

        wszNewGuid = (WCHAR*) CsMemAlloc( ( MAX_GUIDSTR_LEN + 1 ) * sizeof(WCHAR) );

        if ( ! wszNewGuid )
        {
            hr = E_OUTOFMEMORY;
            pPackageInfo->cCategories = iCategoryGuid;
            break;
        }

        wszNewGuid[0] = L'{';

        wszNewGuid++;

        lstrcpy(wszNewGuid, pPackageInfo->prgCategories[iCategoryGuid]);

        wszNewGuid--;

        wszNewGuid[ MAX_GUIDSTR_LEN - 1 ] = L'}';
        wszNewGuid[ MAX_GUIDSTR_LEN ] = L'\0';

        pPackageInfo->prgCategories[iCategoryGuid] = wszNewGuid;
    }

    if ( bFreeCategoriesColumn )
    {
        ADSIFreeColumn(hAds, &ResultColumn);
    }

    if (FAILED(hr))
    {
        //
        // On failure, we must free all allocated memory
        //
        DWORD iCategory;

        for ( iCategory = 0; iCategory < pPackageInfo->cCategories; iCategory++ )
        {
            CsMemFree(pPackageInfo->prgCategories[iCategory]);
        }

        CsMemFree(pPackageInfo->prgCategories);

        pPackageInfo->prgCategories = NULL;
        pPackageInfo->cCategories = 0;
    }

    if ( E_ADS_COLUMN_NOT_SET == hr )
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\filter.cxx ===
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Author: adamed
//  Date:   4/30/1999
//
//      Class Store filter generator
//
//
//---------------------------------------------------------------------
//
#include "cstore.hxx"
//
// List of Attributes for Enumeration of Packages (with Filters)
//

LPOLESTR gpszEnumerationAttributes_All[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    SCRIPTPATH,
    PKGUSN,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    VERSIONHI,
    VERSIONLO,
    UPGRADESPACKAGES,
    UILEVEL,
    PUBLISHER,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    OBJECTGUID,
    OBJECTDN,
    PKGCATEGORYLIST,
    MSIFILELIST,
    SECURITYDESCRIPTOR
};

LPOLESTR gpszEnumerationAttributes_Policy[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    SCRIPTPATH,
    PKGUSN,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    UPGRADESPACKAGES,
    UILEVEL,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    OBJECTGUID,
    OBJECTDN
};

LPOLESTR gpszEnumerationAttributes_Administrative[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    SCRIPTPATH,
    PKGUSN,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    VERSIONHI,
    VERSIONLO,
    UPGRADESPACKAGES,
    UILEVEL,
    PUBLISHER,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    PKGCLSIDLIST,
    OBJECTGUID,
    OBJECTDN
};

LPOLESTR gpszEnumerationAttributes_UserDisplay[] =
{
    PACKAGEFLAGS,
    PACKAGETYPE,
    LOCALEID,
    ARCHLIST,
    PACKAGENAME,
    UPGRADESPACKAGES,
    UILEVEL,
    HELPURL,
    REVISION,
    PRODUCTCODE,
    OBJECTGUID,
    OBJECTDN,
    PKGCATEGORYLIST
};



DWORD ClientSideFilterFromQuerySpec(
    DWORD dwQuerySpec,
    BOOL  bPlanning)
{
    DWORD dwFlags;

    dwFlags = 0;

    switch (dwQuerySpec)
    {
    case APPQUERY_ALL:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_ALL;
        break;

    case APPQUERY_ADMINISTRATIVE:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_ADMINISTRATIVE;
        break;

    case APPQUERY_POLICY:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_POLICY;
        break;

    case APPQUERY_USERDISPLAY:
        dwFlags = CLIENTSIDE_FILTER_FLAGS_USER_DISPLAY;
        break;

    case APPQUERY_RSOP_LOGGING:
        if ( bPlanning )
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_PLANNING;
        }
        else
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_LOGGING;
        }
        break;

    case APPQUERY_RSOP_ARP:
        if ( bPlanning )
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_ARP_PLANNING;
        }
        else
        {
            dwFlags = CLIENTSIDE_FILTER_FLAGS_RSOP_ARP;
        }
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return dwFlags;
}

void  ServerSideFilterFromQuerySpec(DWORD  dwQuerySpec,
                                    BOOL   bPlanning,
                                    WCHAR* wszFilterIn,
                                    WCHAR* wszFilterOut)
{
    WCHAR* wszQueryFilter;

    switch (dwQuerySpec)
    {
    case APPQUERY_ALL:
        wcscpy(wszFilterOut, wszFilterIn);
        return;

    case APPQUERY_ADMINISTRATIVE:
        wszQueryFilter = SERVERSIDE_FILTER_ADMINISTRATIVE;
        break;

    case APPQUERY_POLICY:
        wszQueryFilter = SERVERSIDE_FILTER_POLICY;
        break;

    case APPQUERY_USERDISPLAY:
    case APPQUERY_RSOP_ARP:
        wszQueryFilter = SERVERSIDE_FILTER_USER_DISPLAY;
        break;

    case APPQUERY_RSOP_LOGGING:
        wszQueryFilter = SERVERSIDE_FILTER_RSOP_LOGGING;
        wszQueryFilter = bPlanning ? SERVERSIDE_FILTER_POLICY_PLANNING : SERVERSIDE_FILTER_RSOP_LOGGING;
        break;

    default: 
        ASSERT(FALSE);
        return;
    }

    //
    // Join the two expressions with &
    //
    swprintf(wszFilterOut,
             L"(&%s%s)",
             wszFilterIn,
             wszQueryFilter);

}


LPOLESTR* GetAttributesFromQuerySpec(
    DWORD      dwQuerySpec,
    DWORD*     pdwAttrs,
    PRSOPTOKEN pRsopToken )
{
    switch (dwQuerySpec)
    {
    case APPQUERY_ALL:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_All) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_All;

    case APPQUERY_ADMINISTRATIVE:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_Administrative) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_Administrative;

    case APPQUERY_POLICY:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_Policy) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_Policy;

    case APPQUERY_USERDISPLAY:
        
        *pdwAttrs = sizeof(gpszEnumerationAttributes_UserDisplay) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_UserDisplay;

    case APPQUERY_RSOP_LOGGING:
    case APPQUERY_RSOP_ARP:

        *pdwAttrs = sizeof(gpszEnumerationAttributes_All) /
            sizeof(LPOLESTR);

        return gpszEnumerationAttributes_All;

    default:
        ASSERT(FALSE);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\appinfo.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Appinfo.cxx
//
//*************************************************************

#include "appmgext.hxx"


//
// CAppInfo
//

// Initialization from the Directory.
CAppInfo::CAppInfo(
    CManagedAppProcessor * pManApp,
    PACKAGEDISPINFO *   pPackageInfo,
    BOOL                bDemandInstall,
    BOOL &              bStatus
    ) 
{
    _pManApp = pManApp;
    _DemandInstall = bDemandInstall;

    _DeploymentId = pPackageInfo->PackageGuid;

    bStatus = Initialize( pPackageInfo );

    if ( ! bStatus )
        DebugMsg((DM_WARNING, IDS_APPINFO_FAIL, pPackageInfo->pszPackageName));
}

// Initialization from the registry.
CAppInfo::CAppInfo(
    CManagedAppProcessor * pManApp,
    WCHAR *             pwszDeploymentId,
    BOOL &              bStatus
    )
{
    _pManApp = pManApp;
    _DemandInstall = FALSE;

    StringToGuid( pwszDeploymentId, &_DeploymentId );

    _StatusList.Reset();

    bStatus = Initialize( NULL );

    if ( ! bStatus )
        DebugMsg((DM_WARNING, IDS_LOCALAPPINFO_FAIL, pwszDeploymentId));
}

// Initialization from a local script file.
CAppInfo::CAppInfo(
     WCHAR *             pwszDeploymentId
    )
{
    _pManApp = 0;
    StringToGuid( pwszDeploymentId, &_DeploymentId );
    (void) Initialize( NULL );
}

BOOL
CAppInfo::Initialize(
    PACKAGEDISPINFO *   pPackageInfo
    )
{
    HKEY    hkApp;
    WCHAR   wszDeploymentId[44];
    DWORD   Length;
    DWORD   Size;
    DWORD   n, i;
    DWORD   Status;
    WCHAR*  wszSomId;

    _pwszDeploymentName = 0;
    _pwszGPOId = 0;
    _pwszGPOName = 0;
    _pwszSOMId = 0;
    _pwszGPODSPath = 0;
    _pwszProductId = 0;
    _pwszLocalScriptPath = 0;
    _pwszGPTScriptPath = 0;
    _Upgrades = 0;
    _pUpgrades = 0;
    _Overrides = 0;
    _pOverrides = 0;
    _pwszSupercededIds = 0;
    _pwszPublisher = 0;
    _pwszSupportURL = 0;
    _VersionHi = 0;
    _VersionLo = 0;
    _PathType = DrwFilePath;
    memset( &_USN, 0, sizeof(_USN) );
    _LangId = LANG_NEUTRAL;
    _LanguageWeight = 0;
    _AssignCount = 0;
    _LocalRevision = 0;
    memset( &_ScriptTime, 0, sizeof(_ScriptTime) );
    _DirectoryRevision = 0;
    _InstallUILevel = INSTALLUILEVEL_DEFAULT;
    _ActFlags = 0;
    _InstallState = INSTALLSTATE_UNKNOWN;
    _State = 0;
    _Action = ACTION_NONE;
    _Status = ERROR_SUCCESS;
    _bNeedsUnmanagedRemove = FALSE;
    _rgSecurityDescriptor = 0;
    _cbSecurityDescriptor = 0;
    _bSuperseded = FALSE;
    _bRollback = FALSE;
    _bRemovalLogged = FALSE;
    _bTransformConflict = FALSE;
    _bRestored = FALSE;
    _rgwszTransforms = NULL;
    _rgwszCategories = NULL;
    _cTransforms = 0;
    _cCategories = 0;
    _pwszPackageLocation = 0;
    _pwszRemovingDeploymentId = 0;
    _cArchitectures = 0;
    _rgArchitectures = NULL;
    _PrimaryArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;
    _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_NONE;
    _bSupersedesAssigned = FALSE;
    _dwUserApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;
    _wszDemandSpec = NULL;
    _wszDemandProp = NULL;

    if ( ! _pManApp )
        return FALSE;

    Status = ERROR_SUCCESS;

    Length = lstrlen( _pManApp->LocalScriptDir() );

    _pwszLocalScriptPath = new WCHAR[Length + 44];
    if ( ! _pwszLocalScriptPath )
        return FALSE;

    lstrcpy( _pwszLocalScriptPath, _pManApp->LocalScriptDir() );
    GuidToString( _DeploymentId, &_pwszLocalScriptPath[Length] );
    lstrcpy( &_pwszLocalScriptPath[Length+GUIDSTRLEN], L".aas" );

    if ( CRsopAppContext::REMOVAL == _pManApp->GetRsopContext()->GetContext() )
    {
        _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_USER;
    }
    else if ( _pManApp->GetRsopContext()->RemoveGPOApps() )
    {
        _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS;
    }

    if ( pPackageInfo )
    {
        CGPOInfo*     pGpoInfo;
        CGPOInfoList& GpoInfoList = _pManApp->GPOList();

        _VersionHi = pPackageInfo->dwVersionHi;
        _VersionLo = pPackageInfo->dwVersionLo;

        _LangId = pPackageInfo->LangId;
        _LanguageWeight = GetLanguagePriority(LANGIDFROMLCID(pPackageInfo->LangId),pPackageInfo->dwActFlags);

        _pwszGPTScriptPath = StringDuplicate( pPackageInfo->pszScriptPath );
        if ( ! _pwszGPTScriptPath && !(_pManApp->ARPList()))
            return FALSE;

        _pwszDeploymentName = StringDuplicate( pPackageInfo->pszPackageName );
        GuidToString( pPackageInfo->ProductCode, &_pwszProductId );
        GuidToString( pPackageInfo->GpoId, &_pwszGPOId );

        if ( _pwszGPOId )
        {
            pGpoInfo = GpoInfoList.Find( _pwszGPOId );

            _pwszGPOName = StringDuplicate( pGpoInfo ? pGpoInfo->GetGPOName() : L"" );
        }

        _pwszPublisher = StringDuplicate( pPackageInfo->pszPublisher );
        _pwszSupportURL = StringDuplicate( pPackageInfo->pszUrl );

        if ( _pManApp->GetRsopContext()->IsRsopEnabled() || _pManApp->ARPList() )
            Status = InitializeCategoriesList( pPackageInfo );

        if ( (ERROR_SUCCESS == Status ) &&
             _pManApp->GetRsopContext()->IsRsopEnabled() )
        {
            //
            // We perform RSoP specific initialization here.  Note that if
            // any of these fails, we disable RSoP, but continue policy
            // application.  Any partial initialization due to an
            // error will be cleaned up by the destructor
            //
            _pwszSOMId = StringDuplicate( pGpoInfo ? pGpoInfo->GetSOMPath() : L"" );

            //
            // Make copies of RSoP specific simple string data
            //

            if ( pPackageInfo->cbSecurityDescriptor )
            {
                _rgSecurityDescriptor = new BYTE[ pPackageInfo->cbSecurityDescriptor ];

                if ( _rgSecurityDescriptor && pPackageInfo->rgSecurityDescriptor )
                {
                    _cbSecurityDescriptor = pPackageInfo->cbSecurityDescriptor;
                    memcpy( _rgSecurityDescriptor, pPackageInfo->rgSecurityDescriptor, pPackageInfo->cbSecurityDescriptor );
                }
            }

            _pwszGPODSPath = StringDuplicate( pPackageInfo->pszGpoPath );

            //
            // Check for memory allocation failures
            //
            if ( ! _pwszSOMId || ! _pwszGPODSPath )
            {
                Status = ERROR_OUTOFMEMORY;
            }

            //
            // Now make copies of the more complex RSoP information
            //
            if ( ERROR_SUCCESS == Status )
                Status = InitializeRSOPTransformsList( pPackageInfo );

            if ( ERROR_SUCCESS == Status )
                Status = InitializeRSOPArchitectureInfo( pPackageInfo );

            if ( ERROR_SUCCESS != Status )
            {
                HRESULT hr;

                hr = HRESULT_FROM_WIN32( Status );

                _pManApp->GetRsopContext()->DisableRsop( hr );                
            }
        }

        for ( n = 0; n < pPackageInfo->cUpgrades; n++ )
        {
            if ( pPackageInfo->prgUpgradeInfoList[n].Flag & (UPGFLG_Uninstall | UPGFLG_NoUninstall) )
                _Upgrades++;
        }

        if ( _Upgrades > 0 )
        {
            _pUpgrades = new UPGRADE_INFO[_Upgrades];

            if ( ! _pUpgrades )
                return FALSE;

            memset( _pUpgrades, 0, sizeof(UPGRADE_INFO) * _Upgrades );

            for ( n = 0, i = 0; n < pPackageInfo->cUpgrades; n++ )
            {
                if ( ! (pPackageInfo->prgUpgradeInfoList[n].Flag & (UPGFLG_Uninstall | UPGFLG_NoUninstall)) )
                    continue;

                _pUpgrades[i].DeploymentId = pPackageInfo->prgUpgradeInfoList[n].PackageGuid;
                _pUpgrades[i].Flags = UPGRADE_OVER;
                if ( pPackageInfo->prgUpgradeInfoList[n].Flag & UPGFLG_Uninstall )
                    _pUpgrades[i].Flags |= UPGRADE_UNINSTALL;
                else
                    _pUpgrades[i].Flags |= UPGRADE_NOUNINSTALL;
                i++;
            }
        }

        memcpy( &_USN, &pPackageInfo->Usn, sizeof(_USN) );
        _DirectoryRevision = pPackageInfo->dwRevision;
        _InstallUILevel = pPackageInfo->InstallUiLevel;
        _PathType = pPackageInfo->PathType;
        _ActFlags = pPackageInfo->dwActFlags;
    }

    GuidToString( _DeploymentId, wszDeploymentId );

    if ( ERROR_SUCCESS == Status )
    {
        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            //
            // Need to request set value access so that we may
            // delete the RemovedGPOState value if it exists -- because of this
            // we must revert since the user may not have write access
            // 
            (void) _pManApp->Revert();

            Status = RegOpenKeyEx(
                _pManApp->AppmgmtKey(),
                wszDeploymentId,
                0,
                KEY_READ | KEY_SET_VALUE, 
                &hkApp );

            (void) _pManApp->Impersonate();
        }
        else
        {
            Status = ERROR_FILE_NOT_FOUND;
        }
    }

    if (  ERROR_SUCCESS == Status )
    {
        Size = sizeof(DWORD);

        _State = APPSTATE_PUBLISHED | APPSTATE_POLICYREMOVE_ORPHAN;

        (void) RegQueryValueEx(
                    hkApp,
                    APPSTATEVALUE,
                    0,
                    NULL,
                    (LPBYTE) &_State,
                    &Size );

        Size = sizeof(DWORD);

        //
        // This is used to track the best case time when we could completely
        // delete an appmgmt key after an app is unassigned.
        //
        (void) RegQueryValueEx(
                    hkApp,
                    ASSIGNCOUNTVALUE,
                    0,
                    NULL,
                    (LPBYTE) &_AssignCount,
                    &Size );

        Size = sizeof(DWORD);

        //
        // Beta2 systems didn't write this value.  If it is not found we
        // just use the default value of 0.
        //
        (void) RegQueryValueEx(
                    hkApp,
                    REVISIONVALUE,
                    0,
                    NULL,
                    (LPBYTE) &_LocalRevision,
                    &Size );

        if ( _LocalRevision > 0 )
        {
            Size = sizeof(_ScriptTime);

            (void) RegQueryValueEx(
                        hkApp,
                        SCRIPTTIMEVALUE,
                        0,
                        NULL,
                        (LPBYTE) &_ScriptTime,
                        &Size );
        }

        if ( ! pPackageInfo )
        {
            //
            // This is needed so that if we are in a RemoveApp call in the service
            // we will get the proper UI level to write back for an assigned app.
            //
            Size = sizeof(DWORD);
            (void) RegQueryValueEx(
                        hkApp,
                        INSTALLUI,
                        0,
                        NULL,
                        (LPBYTE) &_InstallUILevel,
                        &Size );

            ReadStringValue( hkApp, DEPLOYMENTNAMEVALUE, &_pwszDeploymentName );
            ReadStringValue( hkApp, GPONAMEVALUE, &_pwszGPOName );
            ReadStringValue( hkApp, GPOIDVALUE, &_pwszGPOId );
            ReadStringValue( hkApp, PRODUCTIDVALUE, &_pwszProductId );
        }

        //
        // During policy refresh, we need to ensure that apps that went out of
        // scope on one machine don't come back on another
        //
        if ( (ERROR_SUCCESS == Status ) &&
             _pManApp->RegularPolicyRun() )
        {
            DWORD dwRemovedState;
            LONG  StatusRemovedState;

            Size = sizeof(DWORD);

            //
            // Check for an appstate saved if the app went out of scope
            //
            StatusRemovedState = RegQueryValueEx(
                hkApp,
                REMOVEDGPOSTATE,
                0,
                NULL,
                (LPBYTE) &dwRemovedState,
                &Size );

            if ( ERROR_SUCCESS == StatusRemovedState )
            {
                BOOL bDeleteRemovedState;

                bDeleteRemovedState = FALSE;

                //
                // We only restore the old app state if this app is currently
                // set to be uninstalled or orphaned -- if not, this removed state is invalid
                // so we will delete it
                //
                if ( ! ( ( APPSTATE_UNINSTALLED & _State ) || ( APPSTATE_ORPHANED & _State ) ) )
                {
                    bDeleteRemovedState = TRUE;
                }
                else if ( pPackageInfo || IsGpoInScope() )
                {
                    //
                    // The gpo for this app is back in scope, we will restore the state
                    // to the previous state before it went out of scope on the other machine
                    //
                    _State = dwRemovedState;

                    bDeleteRemovedState = TRUE;

                    Size = sizeof(DWORD);

                    //
                    // Set the state value back to the original state
                    //
                    (void) RegSetValueEx(
                        hkApp,
                        APPSTATEVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &dwRemovedState,
                        sizeof(DWORD) );

                    _bRestored = TRUE;

                    DebugMsg((DM_VERBOSE, IDS_ABORT_SCOPELOSS, _pwszDeploymentName ? _pwszDeploymentName : L"" , _pwszGPOName ? _pwszGPOName : L"", _State ));
                }
            
                if ( bDeleteRemovedState )
                {
                    (void) RegDeleteValue( hkApp, REMOVEDGPOSTATE );
                }
            }
        }

        //
        // If the app is currently assigned, treat that as the reason for it being applied.
        // This may be overridden later if this app upgrades another
        //
        if ( ! ( APPSTATE_UNINSTALLED & _State ) && ( APPSTATE_ASSIGNED & _State ) )
        {
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED;
        }

        ReadStringValue( hkApp, SUPERCEDEDIDS, &_pwszSupercededIds );

        RegCloseKey( hkApp );
    }

    CheckScriptExistence();

    if ( ! _pwszDeploymentName ||
         ! _pwszGPOId ||
         ! _pwszGPOName ||
         ! _pwszProductId )
        return FALSE;

    return TRUE;
}

CAppInfo::~CAppInfo()
{

    //
    // There are cases, like handling upgrades, where we copy the script
    // early on to ensure that we can access it.  Later however, the same
    // app may be reset to do nothing or may fail to apply.  This check here
    // deletes any script we copied which we don't need now.
    //
    if ( ((_Status != ERROR_SUCCESS) || (ACTION_NONE == _Action)) &&
         ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) &&
         ((_State & APPSTATE_SCRIPT_NOT_EXISTED) && (_State & APPSTATE_SCRIPT_PRESENT)) )
    {
        if ( _pwszLocalScriptPath )
            DeleteFile( _pwszLocalScriptPath );
    }

    DWORD iCategory;

    for ( iCategory = 0; iCategory < _cCategories; iCategory++ )
    {
        delete [] _rgwszCategories[ iCategory ];
    }

    DWORD iTransform;

    for ( iTransform = 0; iTransform < _cTransforms; iTransform++ )
    {
        delete [] _rgwszTransforms[ iTransform ];
    }

    CAppStatus* pAppStatus;

    //
    // Clean up failure statuses
    //
    for ( 
        _StatusList.Reset();
        pAppStatus = (CAppStatus*) _StatusList.GetCurrentItem();
        )
    {
        _StatusList.MoveNext();
        delete pAppStatus;
    }

    delete [] _pwszDeploymentName;
    delete [] _pwszGPOName;
    delete [] _pwszGPOId;
    delete [] _pwszSOMId;
    delete [] _pwszGPODSPath;
    delete [] _pwszProductId;
    delete [] _pwszLocalScriptPath;
    delete [] _pwszGPTScriptPath;
    delete [] _pUpgrades;
    delete [] _pOverrides;
    delete [] _pwszSupercededIds;
    delete [] _pwszPublisher;
    delete [] _pwszSupportURL;
    delete [] _rgSecurityDescriptor;
    delete [] _rgwszCategories;
    delete [] _rgwszTransforms;
    delete [] _pwszPackageLocation;
    delete [] _pwszRemovingDeploymentId;
    delete [] _rgArchitectures;
    delete [] _wszDemandSpec;
}

DWORD
CAppInfo::InitializePass0()
{
    UPGRADE_INFO *  pUpgradeInfo;

    if ( ! (_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) &&
         ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        return ERROR_SUCCESS;

    if ( ! _pManApp->ARPList() && (_State & APPSTATE_SCRIPT_EXISTED) )
        _InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );

    for ( DWORD n = 0; n < _Upgrades; n++ )
    {
        CAppInfo *  pBaseApp;

        if ( ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
            continue;

        //
        // Note that an apps' override list will include apps it really will not
        // upgrade because of policy precedence violation.  However, we keep these
        // in the list for our detection of upgrade relationships when doing
        // demand installs.
        //
        AddToOverrideList( &_pUpgrades[n].DeploymentId );

        pBaseApp = _pManApp->AppList().Find( _pUpgrades[n].DeploymentId );

        if ( ! pBaseApp )
            continue;

        pUpgradeInfo = new UPGRADE_INFO[pBaseApp->_Upgrades + 1];
        if ( ! pUpgradeInfo )
        {
            _Status = ERROR_OUTOFMEMORY;
            return ERROR_OUTOFMEMORY;
        }
        memcpy( pUpgradeInfo, pBaseApp->_pUpgrades, pBaseApp->_Upgrades * sizeof(UPGRADE_INFO) );

        _pUpgrades[n].pBaseApp = pBaseApp;

        if ( _pManApp->GPOList().Compare( _pwszGPOId, pBaseApp->_pwszGPOId ) >= 0 )
        {
            //
            // A valid upgrade of the base app.  We set a backlink upgrade entry
            // for the base app.
            //
            pUpgradeInfo[pBaseApp->_Upgrades].DeploymentId = _DeploymentId;
            pUpgradeInfo[pBaseApp->_Upgrades].Flags = (_pUpgrades[n].Flags & ~UPGRADE_OVER) | UPGRADE_BY;
            pUpgradeInfo[pBaseApp->_Upgrades].pBaseApp = this;
        }
        else
        {
            //
            // An invalid upgrade of the base app because it reverses policy
            // precedence.  We null out this' upgrade link and set a new
            // upgrade link for the base app.  The base app becomes the upgrade
            // app.  The upgrade is forced only if the base app is assigned.
            //
            // Note that the base app will set a backlink for 'this' in it's own
            // InitializePass0 since we process apps from least to highest
            // precedence.
            //
            
            //
            // We preserve the upgrade data for 'this', but remove the forward link flag
            // so that it will not be considered to upgrade anything else. We need to
            // preserve it so that RSoP logging will be able to log the fact that this
            // application upgrades another app
            //
            _pUpgrades[n].Flags &= ~UPGRADE_OVER;
            _pUpgrades[n].pBaseApp = NULL;

            pUpgradeInfo[pBaseApp->_Upgrades].DeploymentId = _DeploymentId;
            pUpgradeInfo[pBaseApp->_Upgrades].Flags = UPGRADE_UNINSTALL | UPGRADE_OVER | UPGRADE_REVERSED;
            if ( pBaseApp->_ActFlags & ACTFLG_Assigned )
                pUpgradeInfo[pBaseApp->_Upgrades].Flags |= UPGRADE_FORCE;
            pUpgradeInfo[pBaseApp->_Upgrades].pBaseApp = this;

            DebugMsg((DM_VERBOSE, IDS_UPGRADE_REVERSE, _pwszDeploymentName, _pwszGPOName, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName));
        }

        delete pBaseApp->_pUpgrades;
        pBaseApp->_pUpgrades = pUpgradeInfo;
        pBaseApp->_Upgrades++;
    }

    return ERROR_SUCCESS;
}

void
CAppInfo::SetActionPass1()
{
    //
    // First pass for setting this app's processing actions.  In pass1 we set
    // an initial state based solely on the individual app, disregarding at this
    // time any interaction with other apps being applied as part of the policy
    // run.
    //

    if ( _pManApp->ARPList() )
    {
        if ( (_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) && (_ActFlags & ACTFLG_UserInstall) )
        {        
            SetAction(
                ACTION_INSTALL,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                NULL);
        }
        return;
    }

    if ( _DemandInstall )
    {
        SetAction(
            ACTION_APPLY,
            APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
            NULL);
    }

    if ( _pManApp->NoChanges() )
    {
        if ( _State & APPSTATE_ASSIGNED )
        {
            //
            // User assigned apps are always readvertised.
            // Machine assigned apps get readvertised if uninstalled outside of the scope
            // of appmgmt (policy/ARP).
            //
            if ( _pManApp->IsUserPolicy() || ! AppPresent(_InstallState) )
            {
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                    NULL);

                _State |= APPSTATE_FULL_ADVERTISE;
            }
        }
        else if ( _State & APPSTATE_PUBLISHED )
        {
            if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
            {
                //
                // This is the roaming case where the app was installed on another
                // machine and the user is now logging onto a new machine.
                //
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE,
                    NULL);
            }
            else
            {
                if ( ( (INSTALLSTATE_UNKNOWN == _InstallState) || (INSTALLSTATE_ABSENT == _InstallState) ) && 
                     ! _bRestored )
                {
                    //
                    // This is the case where a published app was uninstalled via some
                    // non-mgmt mechanism like msiexec command line or the app's own
                    // configuration via ARP.  We respect this type of uninstall.
                    //
                    SetAction(
                        ACTION_ORPHAN,
                        APP_ATTRIBUTE_REMOVALCAUSE_PROFILE,
                        NULL);

                    DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION4, _pwszDeploymentName, _pwszGPOName));
                }
            }
        }
        return;
    }

    BOOL  bUninstalled;
    DWORD dwRemovalCause;

    bUninstalled = (_ActFlags & ACTFLG_Uninstall) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED));

    if ( bUninstalled )
    {
        dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_ADMIN;
    }
    else 
    {
        bUninstalled = (_State & APPSTATE_UNINSTALLED) && (_State & APPSTATE_SCRIPT_EXISTED);

        if ( bUninstalled )
        {
            dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_PROFILE;
        }
    }

    if ( bUninstalled )
    {
        SetAction(
            ACTION_UNINSTALL,
            dwRemovalCause,
            NULL);
        DebugMsg((DM_VERBOSE, IDS_UNINSTALL_ACTION1, _pwszDeploymentName, _pwszGPOName));
    }

    if ( ACTION_UNINSTALL == _Action )
        return;

    if ( ((_ActFlags & ACTFLG_Orphan) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED))) ||
         ((_State & APPSTATE_ORPHANED) && (_State & APPSTATE_SCRIPT_EXISTED)) )
    {
        SetAction(
            ACTION_ORPHAN,
            APP_ATTRIBUTE_REMOVALCAUSE_ADMIN,
            NULL);

        DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION1, _pwszDeploymentName, _pwszGPOName));
    }

    if ( ACTION_ORPHAN == _Action )
        return;

    //
    // Only look for apply actions if no one else has yet set our status
    // explicitly through an upgrade relationship or through the service.
    //
    // Our first check is for actions to take based on information coming
    // down from the directory.
    //
    if ( ACTION_NONE == _Action )
    {
        if ( _ActFlags & ACTFLG_Assigned )
        {
            if ( (_ActFlags & ACTFLG_InstallUserAssign) && 
                 ((_State & APPSTATE_SCRIPT_NOT_EXISTED) || ! (_State & APPSTATE_INSTALL)) )
            {
                 //
                 // This is the new user assigned install option added after Windows2000.
                 // We do an install just once at each computer.  Thereafter it is treated
                 // as a regular user assignment.
                 //
                SetAction(
                    ACTION_INSTALL,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_INSTALL_ACTION2, _pwszDeploymentName, _pwszGPOName));
            }
            else if ( _pManApp->IsUserPolicy() ||
                      ((_State & APPSTATE_ASSIGNED) && ! AppPresent(_InstallState)) )
            {
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                    NULL);
                _State |= APPSTATE_FULL_ADVERTISE;
                DebugMsg((DM_VERBOSE, IDS_ASSIGN1_ACTION, _pwszDeploymentName, _pwszGPOName));
            }
            else
            {
                //
                // We only do an install for a machine assigned app once.  After that
                // only a redeploy will cause any action.
                //
                if ( ! (_State & APPSTATE_ASSIGNED) )
                {
                    SetAction(
                        ACTION_INSTALL,
                        APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED,
                        NULL);

                    DebugMsg((DM_VERBOSE, IDS_INSTALL_ACTION1, _pwszDeploymentName, _pwszGPOName));
                }
            }
        }

        //
        // We only apply published apps if we're logging onto a machine where
        // the published app has not yet been applied.
        //
        // If the script for the published app exists on the machine then it
        // was likely uninstalled via a means we do not detect, so we now
        // orphan it.
        //
        if ( (_ActFlags & ACTFLG_Published) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
            {
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_ASSIGN3_ACTION, _pwszDeploymentName, _pwszGPOName));
            }
            else if ( _bRestored )
            {
                //
                // This is the roaming case where the app was uninstalled on another
                // machine because its gpo went out of scope, but on this machine
                // that gpo is in scope, so it needs to be readvertised since the
                // advertise data was removed on the other machine
                //
                
                //
                // Note that We set the apply cause value to none which will later force us
                // to generate an apply cause that takes into account the apply cause
                // currently in the rsop database.  Since we do not know at this time what is
                // stored in RSoP, we cannot know the correct apply cause so we defer this
                // to the time at which we're accessing the database for logging.
                //
                SetAction(
                    ACTION_APPLY,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_ASSIGN5_ACTION, _pwszDeploymentName, _pwszGPOName));
            }
            else
            {
                if ( (INSTALLSTATE_UNKNOWN == _InstallState) || (INSTALLSTATE_ABSENT == _InstallState) )
                {
                    //
                    // This is the case where a published app was uninstalled via some
                    // non-mgmt mechanism like msiexec command line or the app's own
                    // configuration via ARP.  We respect this type of uninstall.
                    //
                    SetAction(
                        ACTION_ORPHAN,
                        APP_ATTRIBUTE_REMOVALCAUSE_USER,
                        NULL);

                    DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION4, _pwszDeploymentName, _pwszGPOName));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, IDS_NONE_ACTION1, _pwszDeploymentName, _pwszGPOName));
                }
            }
        }
    }

    if ( ACTION_NONE == _Action )
    {
        //
        // Three types of apps will still be at ACTION_NONE here :
        //   + Published apps we already have on the machine
        //   + Disabled apps -> (ACTFLG_Assigned | ACTFLG_Published) is not set
        //   + Apps which "disappear" from our policy set because of ACLs
        //     on the app's deployment properties (not GPO ACLs, that would
        //     cause a removal of the entire GPO)
        //
        // We want to do appropriate orphaning actions only for the last
        // case.  The first two classes of apps are simply left alone.  Note
        // that if an app is explicitly removed-orphan, we know this
        // because it still comes down from the Directory with the
        // ACTFLG_Orphan flag set.
        //
        // We detect the third case with a zero _ActFlag, which means the app
        // was not found in the Directory.
        //
        if ( (0 == _ActFlags) && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            if ( _State & APPSTATE_POLICYREMOVE_UNINSTALL )
            {
                SetAction(
                    ACTION_UNINSTALL,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_UNINSTALL_ACTION2, _pwszDeploymentName, _pwszGPOName));
            }
            else
            {
                SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);
                
                DebugMsg((DM_VERBOSE, IDS_ORPHAN_ACTION3, _pwszDeploymentName, _pwszGPOName));
            }

            _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS;

            return;
        }
    }

    //
    // Check if we have to do a reinstall because of a patch on the install
    // image.  Note, we only go to this state if the app is already
    // installed on this machine.
    //
    // Note, the Darwin msi database is only cached at install time, so
    // if the app is only advertised, we will always pull down the most recent
    // msi when the install is invoked.
    //
    // Also, the INSTALLSTATE_DEFAULT covers both the INSTALLSTATE_LOCAL and
    // INSTALLSTATE_SOURCE.
    //
    if ( (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) &&
         (_State & APPSTATE_SCRIPT_EXISTED) &&
         (_DirectoryRevision > 0) )
    {
        CAppInfo *      pScriptInfo;

        if ( _LocalRevision < _DirectoryRevision )
        {
            SetAction(
                ACTION_REINSTALL,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_REDEPLOY,
                NULL);

            DebugMsg((DM_VERBOSE, IDS_REINSTALL_ACTION1, _pwszDeploymentName, _pwszGPOName));
        }
        else
        {
            pScriptInfo = _pManApp->ScriptList().Find( _DeploymentId );

            if ( CompareFileTime( &pScriptInfo->_ScriptTime, &_ScriptTime ) < 0 )
            {
                SetAction(
                    ACTION_REINSTALL,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_REDEPLOY,
                    NULL);

                if ( DebugLevelOn(DM_VERBOSE) )
                {
                    SYSTEMTIME  LocalTime;
                    SYSTEMTIME  SysvolTime;
                    WCHAR       wszLocalTime[32];
                    WCHAR       wszSysvolTime[32];

                    FileTimeToSystemTime( &pScriptInfo->_ScriptTime, &LocalTime );
                    FileTimeToSystemTime( &_ScriptTime, &SysvolTime );

                    swprintf(
                            wszLocalTime,
                            L"%02d-%02d %02d:%02d:%02d:%03d",
                            LocalTime.wMonth,
                            LocalTime.wDay,
                            LocalTime.wHour,
                            LocalTime.wMinute,
                            LocalTime.wSecond,
                            LocalTime.wMilliseconds );

                    swprintf(
                            wszSysvolTime,
                            L"%02d-%02d %02d:%02d:%02d:%03d",
                            SysvolTime.wMonth,
                            SysvolTime.wDay,
                            SysvolTime.wHour,
                            SysvolTime.wMinute,
                            SysvolTime.wSecond,
                            SysvolTime.wMilliseconds );

                    DebugMsg((DM_VERBOSE, IDS_REINSTALL_ACTION2, _pwszDeploymentName, _pwszGPOName, wszLocalTime, wszSysvolTime));
                }
            }
        }
    }
}

void
CAppInfo::SetActionPass2()
{
    //
    // In pass two we do product id filtering based on language and policy
    // precedence.
    //

    if ( (ACTION_UNINSTALL == _Action) || (ACTION_ORPHAN == _Action) )
        return;

    //
    // When creating the list of apps to show in ARP we want to include
    // the highest precedence assigned app (if one exists) and all
    // published apps from higher precedence policies then the one that
    // the (optional) assigned app has come from.  Thus if there are no
    // assigned apps with the product code, we would show the published
    // apps from all policies.
    //
    // This is done simply by not allowing published apps to filter out
    // any lower precedence apps.
    //
    if ( _pManApp->ARPList() && (_ActFlags & ACTFLG_Published) )
        return;

    //
    // Published apps which we already have on the machine will never be
    // set to apply again.  However, we still want them to override lower
    // precedence products (even assigned) that have the same product id.
    // So the below check causes the logic to continue as long as 'this'
    // app has already been applied on this machine.
    //
    // Note that we check for the assigned state as well because it could
    // be getting changed to published in this run of policy.
    //
    if ( (ACTION_NONE == _Action) && ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        return;

    //
    // If multiple apps of the same product id are set to be assigned or
    // installed, only assign/install the one in the closest GPO.  This is
    // usefull when the app is deployed with a different set of transforms
    // in the different GPOs.  Darwin will only honor one set of transforms.
    //

    //
    // We do this pass in the NoChanges case to enforce the product code
    // filtering logic.
    //

    CAppInfo *  pAppInfo;
    DWORD       n;
    BOOL        bPastThis;
    BOOL        bAnalyzeForRsopOnly;

    bPastThis = FALSE;
    bAnalyzeForRsopOnly = FALSE;

    for ( _pManApp->AppList().Reset(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem();
          pAppInfo;
          _pManApp->AppList().MoveNext(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem() )
    {
        if ( pAppInfo == this )
        {
            bPastThis = TRUE;
            continue;
        }


        //
        // Once we're past 'this' we need to start checking if we should
        // stop processing.  We don't want to supercede an app with the
        // same product id which is of higher precedence.
        //
        // When not constructing the ARP list of apps, we stop once
        // past 'this'.  The most recently deployed app will win ties in
        // that case.
        //
        // When constructing the ARP list of apps, we keep on looking at other
        // apps until we encounter a new policy or an assigned app.  That is
        // because we want to treat all published apps in a policy equally,
        // but an assigned app acts as a blocking point.
        //
        if ( bPastThis )
        {
            if ( lstrcmpi( pAppInfo->_pwszGPOId, _pwszGPOId ) != 0 )
                break;

            if ( ! _pManApp->ARPList() )
                break;
            else if ( pAppInfo->_ActFlags & ACTFLG_Assigned )
                bAnalyzeForRsopOnly = TRUE;
        }

        if ( (ACTION_ORPHAN == pAppInfo->_Action) || (ACTION_UNINSTALL == pAppInfo->_Action) )
            continue;

        if ( (ACTION_NONE == pAppInfo->_Action) &&
             ! (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) &&
             ! (pAppInfo->_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) )
            continue;

        if ( lstrcmpi( pAppInfo->_pwszProductId, _pwszProductId ) != 0 )
            continue;

        //
        // One important exception to product code filtering is when there are
        // upgrades.  We don't do any filtering in that case.  It doesn't matter
        // whether this is an "upgrade by" or "upgrade over" upgrade.
        //
        for ( n = 0; n < _Upgrades; n++ )
        {
            if ( _pUpgrades[n].pBaseApp == pAppInfo )
                break;
        }

        if ( n < _Upgrades )
            continue;

        //
        // Now we know we want to override the lower precedence app so we
        // set it to orphan.  We don't want to do an uninstall, if a
        // tranform conflict requires this, that will be detected later.
        // Note that if the lower precedence app is not already present on
        // the machine then it's action will be changed to ACTION_NONE in
        // Pass4.  But we still set it to ACTION_ORPHAN here so that none of
        // it's upgrade settings will be applied in it's Pass3.
        //
        // Within a single GPO, language match takes precedence over last
        // modified time.
        //
        if ( (pAppInfo->_LanguageWeight > _LanguageWeight) && (0 == lstrcmpi( pAppInfo->_pwszGPOId, _pwszGPOId )) )
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    pAppInfo);
                DebugMsg((DM_VERBOSE, IDS_UNDO3_ACTION, _pwszDeploymentName, _pwszGPOName, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
            }                

            (void) pAppInfo->UpdatePrecedence( this, APP_ATTRIBUTE_REASON_VALUE_LANGUAGE );

            bAnalyzeForRsopOnly = TRUE;
        }
        else
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                pAppInfo->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT,
                    this);

                DebugMsg((DM_VERBOSE, IDS_UNDO6_ACTION, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));
            }

            (void) UpdatePrecedence( pAppInfo, APP_ATTRIBUTE_REASON_VALUE_PRODUCT );
        }
    }

    _pManApp->AppList().ResetEnd();
}

void
CAppInfo::SetActionPass3()
{
    static const UCHAR PolicyForceBaseNone[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        {  NO,  NO,  NO,  NO },
        { SPECIAL1, SPECIAL1,  NO,  NO },
        {  NO,  NO,  NO,  NO },
        {  NO,  NO,  NO,  NO }
        };
    static const UCHAR PolicyForceUpgradeNone[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        {  NO,  NO,  NO,  NO },
        { SPECIAL2, SPECIAL2,  NO,  NO },
        { YES, SPECIAL2,  NO,  NO },
        { YES, SPECIAL2,  NO,  NO }         };
    static const UCHAR PolicyApplyUpgrade[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        {  NO,  NO,  NO,  NO },
        {  NO,  NO, YES, YES },
        {  NO,  SPECIAL1, YES, YES },
        {  NO,  SPECIAL1, YES, YES }
        };
    static const UCHAR ARPForceBaseNone[BASE_STATE_CHOICES][UPGRADE_STATE_CHOICES] =
        {
        { SPECIAL1, SPECIAL1, YES, YES },
        {  NO,  NO, YES, YES },
        {  NO,  NO, YES, YES },
        {  NO,  NO, YES, YES }
        };

    //
    // In pass two, we may modify this app's or other app's action based upon
    // upgrade relationships between the set of apps in a policy run.
    //

    if ( _pManApp->NoChanges() )
        return;

    if ( ! _Upgrades )
        return;

    BOOL bAnalyzeForRsopOnly;

    bAnalyzeForRsopOnly = FALSE;

    if ( (ACTION_UNINSTALL == _Action) || (ACTION_ORPHAN == _Action) )
    {
        //
        // Even if this app is not applied, we want to be sure that
        // it doesn't have some upgrades
        //
        if ( _pManApp->GetRsopContext()->IsRsopEnabled() )
        {
            bAnalyzeForRsopOnly = TRUE;
        }
        else
        {
            return;
        }
    }

    if ( ! (_ActFlags & (ACTFLG_Assigned | ACTFLG_Published)) )
        return;

    for ( DWORD n = 0; n < _Upgrades; n++ )
    {
        CAppInfo *  pBaseApp;
        DWORD       BaseIndex;
        DWORD       UpgradeIndex;
        BOOL        bBasePresent;
        BOOL        bBaseToApply;
        BOOL        bUpgradePresent;
        BOOL        bUpgradeForced;
        BOOL        bUpgradeToApply;
        BOOL        bApplyUpgrade;

        if ( ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
            continue;

        pBaseApp = _pUpgrades[n].pBaseApp;

        if ( ! pBaseApp )
            continue;

        //
        // Notes about the state settings :
        //
        // BasePresent should be set to FALSE if the app is set to be unmanaged and the
        // upgrade is not forced.  This is to ensure the if the upgrade app is assigned
        // it will be applied.  Likewise, if the upgrade is forced then we want to treat
        // the base app as present if it was currently managed.  That is to ensure that
        // the upgrade will apply even if the base app is already set to be removed.
        //

        // 
        // Four conditions under which an upgrade is forced :
        // 1. During an install from ARP or fileext/clsid activation.
        // 2. If the app is configured to force it's upgrades.
        // 3. If the upgrade link was reversed because of policy precedence (see InitializePass0)
        // 4. Whenever an app is restored after a profile sync problem (see CManagedAppProcessor::GetLostApps)
        //
        bUpgradeForced = _DemandInstall || 
                         (_ActFlags & ACTFLG_ForceUpgrade) || 
                         (_pUpgrades[n].Flags & UPGRADE_FORCE) ||
                         (_State & APPSTATE_RESTORED);

        bBasePresent = ( pBaseApp->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED) );

        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            if ( ! bUpgradeForced && ((ACTION_ORPHAN == pBaseApp->_Action) || (ACTION_UNINSTALL == pBaseApp->_Action)) )
                bBasePresent = FALSE;
        }
        else if ( CRsopAppContext::POLICY_REFRESH == _pManApp->GetRsopContext()->GetContext() ) 
        {
            if ( ! ( ( _ActFlags & ACTFLG_Assigned ) && ! ( pBaseApp->_ActFlags & ACTFLG_Assigned ) ) )
            {
                bBasePresent = TRUE;
            }
            else
            {
                bBasePresent = FALSE;
            }
        }

        if ( _pManApp->ARPList() )
            bBaseToApply = pBaseApp->_State & APPSTATE_ASSIGNED;
        else
            bBaseToApply = (ACTION_APPLY == pBaseApp->_Action) || (ACTION_INSTALL == pBaseApp->_Action);

        bUpgradePresent = _State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED);

        if ( _pManApp->ARPList() )
            bUpgradeToApply = _State & APPSTATE_ASSIGNED;
        else
            bUpgradeToApply = (ACTION_APPLY == _Action) || (ACTION_INSTALL == _Action);

        if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() &&
             ( CRsopAppContext::ARPLIST == _pManApp->GetRsopContext()->GetContext() ) )
        {
            if ( ( _ActFlags & ACTFLG_Assigned ) && ! ( pBaseApp->_ActFlags & ACTFLG_Assigned ) )
            {
                bUpgradeToApply = TRUE;
                bUpgradePresent = TRUE;
            }
        }

        DebugMsg((DM_VERBOSE, IDS_UPGRADE_INFO, _pwszDeploymentName, _pwszGPOName, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, bBasePresent, bBaseToApply, bUpgradePresent, bUpgradeToApply, bUpgradeForced));

        if ( bBasePresent )
            BaseIndex = bBaseToApply ? BASE_STATE_PRESENT_APPLY : BASE_STATE_PRESENT_NOTAPPLY;
        else
            BaseIndex = bBaseToApply ? BASE_STATE_ABSENT_APPLY : BASE_STATE_ABSENT_NOTAPPLY;

        if ( bUpgradeForced )
            UpgradeIndex = bUpgradeToApply ? UPGRADE_STATE_FORCED_APPLY : UPGRADE_STATE_FORCED_NOTAPPLY;
        else
            UpgradeIndex = bUpgradeToApply ? UPGRADE_STATE_NOTFORCED_APPLY : UPGRADE_STATE_NOTFORCED_NOTAPPLY;

        //
        // In the case where we are constructing the list to show in ARP, the
        // only decision is whether to hide the base app.
        //
        if ( _pManApp->ARPList() )
        {
            if ( (YES == ARPForceBaseNone[BaseIndex][UpgradeIndex]) ||
                 ((SPECIAL1 == ARPForceBaseNone[BaseIndex][UpgradeIndex]) && bUpgradePresent) )
            {
                if ( ! bAnalyzeForRsopOnly )
                {
                    DebugMsg((DM_VERBOSE, IDS_UNDO4_ACTION, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));

                    pBaseApp->SetAction(
                        ACTION_NONE,
                        APP_ATTRIBUTE_REMOVALCAUSE_NONE,
                        this);
                }

                (void) UpdatePrecedence( pBaseApp, APP_ATTRIBUTE_REASON_VALUE_UPGRADE );
            }
            continue;
        }

        //
        // The rest of this code executes when we are running policy in winlogon
        // or when doing a demand install.
        //

        if ( (YES == PolicyForceBaseNone[BaseIndex][UpgradeIndex]) ||
             ((SPECIAL1 == PolicyForceBaseNone[BaseIndex][UpgradeIndex]) && bUpgradePresent) )
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                DebugMsg((DM_VERBOSE, IDS_UNDO1_ACTION, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));
                
                pBaseApp->SetAction(
                    ACTION_NONE,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                    this);
            }
        }

        if ( (YES == PolicyForceUpgradeNone[BaseIndex][UpgradeIndex]) ||
             ((SPECIAL2 == PolicyForceUpgradeNone[BaseIndex][UpgradeIndex]) && ! bUpgradePresent) )
        {
            if ( ! bAnalyzeForRsopOnly )
            {
                DebugMsg((DM_VERBOSE, IDS_UNDO2_ACTION, _pwszDeploymentName, _pwszGPOName, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName));
                SetAction(
                    ACTION_NONE,
                    APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                    pBaseApp);
            }

            (void) pBaseApp->UpdatePrecedence( this, APP_ATTRIBUTE_REASON_VALUE_NONFORCEDUPGRADE );
        }

        bApplyUpgrade = (YES == PolicyApplyUpgrade[BaseIndex][UpgradeIndex]) ||
                        ((SPECIAL1 == PolicyApplyUpgrade[BaseIndex][UpgradeIndex]) && bUpgradePresent);

        if ( ! bApplyUpgrade )
        {
            if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() && 
                 ( CRsopAppContext::POLICY_REFRESH == _pManApp->GetRsopContext()->GetContext() ) &&
                 ( ( ACTION_APPLY == _Action ) || ( ACTION_INSTALL == _Action ) ) )
            {
                UpdatePrecedence( pBaseApp, APP_ATTRIBUTE_REASON_VALUE_UPGRADE );
            }

            continue;
        }

        //
        // At this point we know that this upgrade relationship is set to be
        // applied.
        //
        (void) UpdatePrecedence( pBaseApp, APP_ATTRIBUTE_REASON_VALUE_UPGRADE );

        if ( _pManApp->GetRsopContext()->IsRsopEnabled() )
        {
            if ( bBasePresent )
            {
                _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_UPGRADE;
            }
        }

        //
        // If we are only here to ensure that we get all the upgrades for RSoP,
        // we should leave now since we know that the upgrade is enforced
        //
        if ( bAnalyzeForRsopOnly )
        {
            return;
        }

        //
        // Make sure a full advertise is done for the new app during user policy
        // processing.  
        // We don't want this for machine policy, user assign full install option
        // nor ARP since the install action will follow in that case.
        //
        if ( _pManApp->IsUserPolicy() && ! (_ActFlags & ACTFLG_InstallUserAssign) && ! _DemandInstall )
            _State |= APPSTATE_FULL_ADVERTISE;

        //
        // This is for the case when the new upgrade app is published.
        //
        if ( ACTION_NONE == _Action )
        {
            SetAction(
                ACTION_APPLY,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_UPGRADE,
                NULL);

            DebugMsg((DM_VERBOSE, IDS_ASSIGN4_ACTION, _pwszDeploymentName, _pwszGPOName));
        }

        if ( ! bBasePresent )
        {

            DebugMsg((DM_VERBOSE, IDS_UNDO4_ACTION, pBaseApp->_pwszDeploymentName, pBaseApp->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));
            pBaseApp->_Action = ACTION_NONE;
            continue;
        }

        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            //
            // Before we start setting the upgrade apps' states, we need to make
            // sure that we can get the new app's script from the sysvol.  Because
            // of replication issues, it's possible the script may not be available
            // on the DC we bind to.  We don't want to undo the upgraded apps until
            // we know we'll be able to apply the new one.
            //
            _Status = CopyScriptIfNeeded();
            
            if ( _Status != ERROR_SUCCESS )
            {
                //
                // This may seem strange, but logging all three of these events provides
                // the proper context of the error.  This is how a failed upgrade would
                // normally be logged, but in this case the error occurs so early we
                // abort before the normal set of processing is performed that would log
                // the other events.  We want to stop early to prevent doing unnecessary
                // uninstalls.
                //
                gpEvents->Upgrade( this, pBaseApp, _pUpgrades[n].Flags & UPGRADE_UNINSTALL );
                gpEvents->Assign( _Status, this );
                gpEvents->UpgradeAbort( _Status, this, pBaseApp, FALSE );
            
                SetAction(
                    ACTION_NONE,
                    _dwApplyCause,
                    NULL);

                pBaseApp->_bRollback = TRUE;

                return;
            }
        }

        _pUpgrades[n].Flags |= UPGRADE_APPLIED;

        if ( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            if ( _pUpgrades[n].Flags & UPGRADE_UNINSTALL )
            {
                pBaseApp->SetAction(
                    ACTION_UNINSTALL,
                    APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE,
                    this);

                gpEvents->Upgrade( this, pBaseApp, TRUE );
            }
            else // _pUpgrades[n].Flags & UPGRADE_NOUNINSTALL
            {
                pBaseApp->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE,
                    this);

                gpEvents->Upgrade( this, pBaseApp, FALSE );
            }
        }
    }
}

void
CAppInfo::SetActionPass4()
{
    //
    // In pass four we look for various cases of simultaneous advertise and
    // unadvertise of the same product or other action states that need
    // slight changes based on all of the inter-deployment processing we've
    // finished.
    //

    //
    // If this product is to be assigned, check if the same product is being
    // uninstalled now as well.  If so, we switch this app to be applied async,
    // so that it will get assigned again after the uninstall action.
    //

    CAppInfo *  pAppInfo;

    //
    // If an app is set to orphan, but we don't even have it in the registry,
    // then we can just fall back to do nothing.
    // This can happen for upgrades of assigned apps that were previously
    // applied.
    //
    if ( ACTION_ORPHAN == _Action )
    {
        if ( ! (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED)) )
        {
            SetAction(
                ACTION_NONE,
                APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE,
                NULL);

            DebugMsg((DM_VERBOSE, IDS_NONE_ACTION2, _pwszDeploymentName, _pwszGPOName));
        }
    }

    for ( _pManApp->AppList().Reset(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem();
          pAppInfo;
          _pManApp->AppList().MoveNext(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem() )
    {
        if ( pAppInfo == this )
            break;

        if ( lstrcmpi( pAppInfo->_pwszProductId, _pwszProductId ) != 0 )
            continue;

        //
        // When the lower precedent app is set to be uninstalled, we switch it
        // to orphan if the higher precedent app is already on the machine.
        // This holds even if the higher precedent app is set to be orphaned
        // or uninstalled.
        //
        if ( ACTION_UNINSTALL == pAppInfo->_Action )
        {
            if ( _State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED) )
            {
                DebugMsg((DM_VERBOSE, IDS_UNDO5_ACTION, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, _pwszDeploymentName, _pwszGPOName));

                pAppInfo->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT,
                    this);
            }
        }
    }

    _pManApp->AppList().ResetEnd();
}


void
CAppInfo::SetAction(
    APPACTION AppAction,
    DWORD     Reason,
    CAppInfo* pAppCause
    )
{
    _Action = AppAction;

    if ( ( _Action == ACTION_APPLY ) ||
         ( _Action == ACTION_INSTALL ) ||
         ( _Action == ACTION_REINSTALL) )
    {
        _dwApplyCause = Reason;
    }
    else if ( ( _Action == ACTION_ORPHAN ) ||
              ( _Action == ACTION_UNINSTALL ) )
    {
        _dwRemovalCause = Reason;

        if ( pAppCause )
        {
            HRESULT hr;

            hr = SetRemovingDeploymentId( &(pAppCause->_DeploymentId) );

            if ( FAILED( hr ) )
            {
                _pManApp->GetRsopContext()->DisableRsop( hr );
            }
        }
    }
    else
    {
        _dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_NONE;
        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;
    }
}

DWORD
CAppInfo::ProcessApplyActions()
{
    DWORD   n;
    DWORD   ScriptFlags;

    if ( _Status != ERROR_SUCCESS )
        return _Status;

    switch ( _Action )
    {
    case ACTION_NONE :
        //
        // If policy has changed, then we want to rewrite our state even for apps
        // which we have but which are not set to apply.  This is to update any
        // settings like UI level or orphan/uninstall at policy removal.
        //
        if ( ! _pManApp->NoChanges() && (_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
            (void) Assign( 0, FALSE, TRUE );
        break;
    case ACTION_APPLY :
        //
        // Note that apply actions can be processed during an async refresh, as long as they
        // do not lead to an install
        //
    case ACTION_INSTALL :
    case ACTION_REINSTALL :
        BOOL bUpgradeComplete;

        bUpgradeComplete = FALSE;

        if ( ! _DemandInstall )
        {
            //
            // Before applying an app which is an upgrade of something
            // already on the machine, we make sure that all necessary actions
            // on the old apps completed successfully.  If there were any errors in
            // the uninstalls, then the upgrade app is not applied.
            // Upgrade processed through ARP actions are transacted differently
            // since they involve an install of the new app, so this does not
            // apply in that case.
            //
            for ( n = 0; n < _Upgrades; n++ )
            {
                if ( ! _pUpgrades[n].pBaseApp || ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
                    continue;

                // Abort and fail if any of the upgraded app removals failed.
                if ( _pUpgrades[n].pBaseApp->_Status != ERROR_SUCCESS )
                {
                    RollbackUpgrades();
                    return _pUpgrades[n].pBaseApp->_Status;
                }

                // Remember if any of the base apps were actually present.
                if ( _pUpgrades[n].pBaseApp->_State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED) )
                    bUpgradeComplete = TRUE;
            }
        }

        ScriptFlags = 0;

        //
        // Reinstalls require recopying the script file because the msi
        // data may have been modified in a way which changes the script
        // data.
        // Also check for a first time advertise where we need to update
        // the registry stored script time.
        //
        if ( (ACTION_REINSTALL == _Action) ||
             ((_DirectoryRevision > 0) && (0 == _ScriptTime.dwLowDateTime) && (0 == _ScriptTime.dwHighDateTime)) )
        {
            WIN32_FIND_DATA FindData;
            HANDLE  hFind;

            hFind = FindFirstFile( _pwszGPTScriptPath, &FindData );
            if ( INVALID_HANDLE_VALUE == hFind )
            {
                _Status = GetLastError();
                gpEvents->Reinstall( _Status, this );
                return _Status;
            }

            FindClose( hFind );
            _ScriptTime = FindData.ftLastWriteTime;

            if ( ACTION_REINSTALL == _Action )
            {
                // This will force the script to be recopied.
                _State &= ~APPSTATE_SCRIPT_PRESENT;

                //
                // Force a full readvertise for assigned apps.  This catches handles cases where the app
                // is only in an advertised state.
                //
                if ( _ActFlags & ACTFLG_Assigned )
                    ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO;
            }
        }

        //
        // Determine whether this app will require uninstall of an
        // existing unmanaged version of the same application -- note that
        // this call must be made while impersonating
        //
        _bNeedsUnmanagedRemove = RequiresUnmanagedRemoval();

        if ( _Action != ACTION_REINSTALL )
            _Status = Assign( ScriptFlags, TRUE, TRUE );
        else
            _Status = Assign( ScriptFlags, TRUE, FALSE );

        if ( ERROR_INSTALL_TRANSFORM_FAILURE == _Status )
        {
            DebugMsg((DM_VERBOSE, IDS_INSTALL_TRANSFORM, _pwszDeploymentName, _pwszGPOName));
            _State |= APPSTATE_TRANSFORM_CONFLICT;

            _bTransformConflict = TRUE;

            //
            // Though we are not really doing an install, the uninstall is an operation
            // we are performing in order to apply this new deployment of the app.  We
            // don't want to scare the user into thinking their app is being
            // totally nuked. So in this case we actually put up the install message.
            //
            _pManApp->LogonMsgInstall( _pwszDeploymentName );
            _Status = Uninstall();

            if ( ERROR_SUCCESS == _Status )
            {
                _Status = Assign();
            }

            _pManApp->LogonMsgApplying();
        }
        else if ( ERROR_SUCCESS != _Status )
        {
            //
            // Ensure that we record an event in this case
            // so RSoP will associate an error with this application
            //
            if ( _Action == ACTION_REINSTALL )
            {
                gpEvents->Assign( _Status, this );
            }
        }

        //
        // If a script is not present, we should check for an unmanaged version of the app if it's going to be applied,
        // since we will want to reinstall if this app is not configured to remove unmanaged installs
        // of the same app.
        //
        // This can also happen if the application temporarily goes out of scope on this machine
        // due to wql filtering or security group filtering, and then comes back into scope.
        //

        //
        // Note that we do this now rather than in SetActions because we want to wait until
        // all unapply actions have taken place before we make this decision
        //
        if ( ! _DemandInstall &&
             ( ACTION_APPLY == _Action || ACTION_INSTALL == _Action ) &&
             ( _State & APPSTATE_SCRIPT_NOT_EXISTED ) && 
             ! _bNeedsUnmanagedRemove )
        {
            DWORD InstallState;

            //
            // We must query the install state since we normally only query
            // the install state when the script exists
            //
            InstallState = gpfnMsiQueryProductState( _pwszProductId );

            if ( ( INSTALLSTATE_DEFAULT == InstallState )  || 
                 ( INSTALLSTATE_LOCAL == InstallState ) ) 
            {
                SetAction(
                    ACTION_REINSTALL,
                    _dwApplyCause,
                    NULL);

                DebugMsg((DM_VERBOSE, IDS_REINSTALL_ACTION3, _pwszDeploymentName, _pwszGPOName));
            }
        }

        if ( ERROR_SUCCESS == _Status )
        {
            if ( ACTION_INSTALL == _Action )
            {
                _pManApp->LogonMsgInstall( _pwszDeploymentName );
                _Status = Install();
                _pManApp->LogonMsgApplying();
            }
            else if ( ACTION_REINSTALL == _Action )
            {
                //
                // Note that in the redeploy case, the full reinstall is needed only if the app
                // has already been installed once on this machine.
                // We want to check for any unmanaged install instance, so don't use
                // _InstallState here.
                //
                if ( INSTALLSTATE_DEFAULT == (*gpfnMsiQueryProductState)( _pwszProductId ) )
                {
                    _pManApp->LogonMsgInstall( _pwszDeploymentName );
                    _Status = Reinstall();
                    _pManApp->LogonMsgApplying();
                }

                // 
                // Make sure to do this even if we didn't attempt a reinstall so that 
                // any new properites of the app get written to our local key.
                //
                if ( ERROR_SUCCESS == _Status )
                    _Status = Assign( 0, FALSE, TRUE );
            }
        }

        if ( (ACTION_INSTALL == _Action) && 
             (_Status != ERROR_SUCCESS) && 
             (_State & APPSTATE_SCRIPT_NOT_EXISTED) )
        {
            //
            // Try to rollback the failed install
            //
            Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO, TRUE );
        }

        if ( bUpgradeComplete )
        {
            if ( _Status != ERROR_SUCCESS )
            {
                RollbackUpgrades();
                break;
            }

            for ( n = 0; n < _Upgrades; n++ )
            {
                if ( ! _pUpgrades[n].pBaseApp || ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
                    continue;

                if ( _pUpgrades[n].pBaseApp->_State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED) )
                    gpEvents->UpgradeComplete( this, _pUpgrades[n].pBaseApp );
            }
        }
        break;
    case ACTION_UNINSTALL :
    case ACTION_ORPHAN :
        break;
    }

    return _Status;
}

DWORD
CAppInfo::ProcessUnapplyActions()
{
    if ( _Status != ERROR_SUCCESS )
        return _Status;

    switch ( _Action )
    {
    case ACTION_NONE :
    case ACTION_APPLY :
    case ACTION_INSTALL :
    case ACTION_REINSTALL :
        break;
    case ACTION_UNINSTALL :

        //
        // During async refreshes, we will not process any unapply actions as that
        // would be disruptive to the user.  This also prevents rip n replace upgrades,
        // since an unapply action is required for the base app and this will set the error
        // for the base app so that the upgrade app is not assigned.
        //
        if ( _pManApp->Async() )
        {
            DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));
        
            _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
            
            break;
        }

        if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
        {
            INSTALLSTATE InstallState;

            //
            // This is a bizarre scenario possible with a roaming profile.
            // It's possible we may be getting the uninstall action for the
            // first time while logging onto a machine where an assignment of
            // the app has never been done.
            // In that case we make our best effort to remove advertise data that
            // may be in the profile.  We don't want to do any uninstall action
            // here since we never performed an install action.  Note we don't
            // use SCRIPTFLAG_REGDATA_APPINFO because class registrations don't
            // roam.  If we can't get the script to do the unadvertise, we continue
            // and unmanage the app.
            //

            //
            // Note that we only want to unadvertise if the app is in the
            // advertised state or not present -- otherwise, we may trash
            // an unmanaged version of the app, or a managed version of the application
            // with the same product id.  We check the install state below -- we must 
            // call the api to do this since our _InstallState member is only initialized
            // when the script exists, and in this case we know it does not
            //
            InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );

            if ( ( INSTALLSTATE_ADVERTISED == InstallState ) ||
                 ( INSTALLSTATE_ABSENT == InstallState ) )
            {
                //
                // Artifically bump up the ref count since an assignment was never done
                // on this machine.
                //
                if ( _pManApp->IsUserPolicy() )
                    _AssignCount++;

                if ( ERROR_SUCCESS == CopyScriptIfNeeded() )
                    _Status = Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS, FALSE );
            }
        }
        else
        {
            _pManApp->LogonMsgUninstall( _pwszDeploymentName );
            _Status = Uninstall( FALSE );
            _pManApp->LogonMsgApplying();

            //
            // If an app is only advertised, then an uninstall will fail with
            // ERROR_INSTALL_SOURCE_ABSENT if the original package source (msi)
            // can not be accessed.  This is because the msi is not cached until
            // install time.
            // Uninstall will also fail if the package has been disallowed through
            // software restriction policies.
            // In these cases, we just need to undo the rest of the advertise that
            // we did originally.
            //
            if ( (INSTALLSTATE_ADVERTISED == _InstallState) && 
                 ((ERROR_INSTALL_SOURCE_ABSENT == _Status) ||
                  (ERROR_INSTALL_PACKAGE_REJECTED == _Status) ||
                  (ERROR_INSTALL_TRANSFORM_REJECTED == _Status) ||
                  (ERROR_INSTALL_TRANSFORM_FAILURE == _Status)) )
            {
                _Status = Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, FALSE );
            }

            if ( ERROR_SUCCESS != _Status )
            {
                gpEvents->Uninstall( _Status, this );
            }
        }

        //
        // On success we can finally remove our own internal state info
        // about this apps.
        //
        if ( ERROR_SUCCESS == _Status )
            _Status = Unassign();
        break;
    case ACTION_ORPHAN :

        //
        // Artifically bump up the ref count since an assignment was never done
        // on this machine.
        //
        if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) && _pManApp->IsUserPolicy() )
            _AssignCount++;

        _Status = Unassign();

        break;
    }

    return _Status;
}

DWORD
CAppInfo::ProcessTransformConflicts()
{
    //
    // For RSoP, we need to say which apps were uninstalled due
    // to transform conflicts
    //

    //
    // Since the uninstall was performed as part of installing an app
    // in PRocessApplyActions (upon receiving ERROR_INSTALL_TRANSFORM_FAILURE 
    // from MsiAdvertiseScript), any installed apps would have had the same
    // product id and therefore would have been marked to uninstall in a
    // previous pass
    //

    //
    // So first we check to see if this app encountered a transform
    // conflict when it was installed
    //
    if ( _bTransformConflict )
    {
        //
        // Now look for any application with the same product id marked
        // as being removed due to product conflict:
        //
        CAppInfo* pAppInfo;

        for ( _pManApp->AppList().Reset(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem();
              pAppInfo;
              _pManApp->AppList().MoveNext(), pAppInfo = (CAppInfo *) _pManApp->AppList().GetCurrentItem() )
        {
            //
            // Check to see if the current app was removed due to product conflict
            //
            if ( APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT != pAppInfo->_dwRemovalCause )
                continue;

            //
            // See if the current app's product id matches
            //
            if ( lstrcmpi( pAppInfo->_pwszProductId, _pwszProductId ) != 0 )
                continue;

            //
            // Since this app had a product conflict with the current app,
            // it had to have been uninstalled as part of installing this app,
            // so we note this
            //
            pAppInfo->_dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM;
        }

        _pManApp->AppList().ResetEnd();
    }

    return ERROR_SUCCESS;
}

DWORD
CAppInfo::CopyToManagedApplication(
    MANAGED_APP * pManagedApp
    )
{
    DWORD cbApplication;

    LONG Error;

    Error = ERROR_SUCCESS;

    //
    // Copy guid data
    //
    StringToGuid(_pwszGPOId, &(pManagedApp->GpoId));
    StringToGuid(_pwszProductId, &(pManagedApp->ProductId));

    //
    // Copy simple data
    //
    pManagedApp->dwVersionHi = _VersionHi;
    pManagedApp->dwVersionLo = _VersionLo;
    pManagedApp->dwRevision = _LocalRevision;
    pManagedApp->Language = _LangId;
    pManagedApp->pszOwner = NULL;
    pManagedApp->pszCompany = NULL;
    pManagedApp->pszComments = NULL;
    pManagedApp->pszContact = NULL;

    //
    // Copy information about the application type -- do
    // a translation from com pathtype constants to Win32
    // constants.
    //
    switch ( _PathType )
    {
    case DrwFilePath:
        pManagedApp->dwPathType = MANAGED_APPTYPE_WINDOWSINSTALLER;
        break;

    case SetupNamePath:
        pManagedApp->dwPathType = MANAGED_APPTYPE_SETUPEXE;
        break;

    default:
        pManagedApp->dwPathType = MANAGED_APPTYPE_UNSUPPORTED;
    }

    pManagedApp->bInstalled = ((_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) != 0);

    //
    // Copy string data
    //

    if (_pwszDeploymentName)
    {
        pManagedApp->pszPackageName = MidlStringDuplicate(_pwszDeploymentName);

        if (!(pManagedApp->pszPackageName))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (_pwszGPOName)
    {
        pManagedApp->pszPolicyName = MidlStringDuplicate(_pwszGPOName);

        if (!(pManagedApp->pszPolicyName))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (_pwszPublisher)
    {
        pManagedApp->pszPublisher = MidlStringDuplicate(_pwszPublisher);

        if (!(pManagedApp->pszPublisher))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (_pwszSupportURL)
    {
        pManagedApp->pszSupportUrl = MidlStringDuplicate(_pwszSupportURL);

        if (!(pManagedApp->pszSupportUrl))
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

cleanup:

    if (ERROR_SUCCESS != Error)
    {
        ClearManagedApp( pManagedApp );
    }

    return Error;
}

BOOL
CAppInfo::HasCategory(
    WCHAR * pwszCategory
    )
{
    for ( DWORD n = 0; n < _cCategories; n++ )
    {
        if ( 0 == lstrcmp( _rgwszCategories[n], pwszCategory ) )
            return TRUE;
    }

    return FALSE;
}

DWORD
CAppInfo::Assign(
    DWORD   ScriptFlags,    // = 0
    BOOL    bDoAdvertise,   // = TRUE
    BOOL    bAddAppData    // = TRUE
    )
{
    HKEY    hkApp;
    WCHAR   wszDeploymentId[40];
    DWORD   AppState;
    DWORD   Status;
    BOOL    bAdvertised;
    BOOL    bUnmanageUninstall;

    //
    // For async refreshes, We do not want to perform any assignments that are destined to
    // lead to installs since that would disrupt the user.  However, pure advertisements
    // are ok -- they cause minimal disruption and no loss of user functionality
    //
    if ( _pManApp->Async() )
    {
        if ( ( ACTION_INSTALL == _Action ) ||
             ( ACTION_REINSTALL == _Action ) )
        {
            DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

            _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
            
            Status = _Status;

            goto ReportStatus;
        }
    }

    Status = ERROR_SUCCESS;

    bAdvertised = FALSE;
    bUnmanageUninstall = FALSE;

    GuidToString( _DeploymentId, wszDeploymentId );

    if ( ! bDoAdvertise )
        goto SaveAppData;

    DebugMsg((DM_VERBOSE, IDS_ASSIGN, _pwszDeploymentName, _pwszGPOName));

    Status = CopyScriptIfNeeded();

    if ( (Status != ERROR_SUCCESS) && bDoAdvertise && bAddAppData )
    {
        gpEvents->Assign( Status, this );
        return Status;
    }

    //
    // Do this before determining script flags because an uninstall will cause
    // the app state to change.
    //
    Status = EnforceAssignmentSecurity( &bUnmanageUninstall );

    //
    // Note that we check the error status for the call above below -- we
    // do not overwrite the status if it is an error.  Better code arrangement
    // is called for here, but we are making the smallest change since an
    // issue with this was found at the end of xpsp1
    //

    if ( 0 == ScriptFlags )
    {
        //
        // Apps which are installed on demand (ARP, shell/com activation) only
        // have the Darwin product registry keys advertised.
        // This is all we need to make the MsiConfigureProduct call in the
        // client work and ensure that if the install must be rolled back, we
        // get back to the true previous state of the machine.
        //
        // The icons/transforms have to be included in any first time advertise
        // because of some bizarre design in Darwin.  If we don't advertise
        // it then the app's shorcuts will not have icons even after the install.
        // For subsequent advertises we don't include the icons/transforms because
        // this is a very expensive part of advertisement because it extracts and
        // re-creates icons from the script file.  [Removed 12/23/98, we'll see
        // if Darwin handles this correctly now].
        //
        // During policy runs we advertise shortcuts for previously advertised
        // assigned apps.
        //
        // For published apps which we're applying for the first time on a machine
        // we just advertise the config data.  Note that the only time a published
        // app is advertised as part of a policy run is for the roaming profile
        // scenario where the app has never been applied to the machine we're now on.
        // We don't want to advertise shorcuts nor class data in this case because
        // only a subset of the product's features may have been installed on the
        // original machine.  We want to preserve this feature state.
        //
        // The very first time an assigned app is assigned to a machine we will also
        // advertise the shell class data.  But since this is quite heavy
        // weight, we only do it the first time.  If it is ever lost somehow,
        // a miss on this info will result in a DS query and install anyway.
        //

        ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO;

        if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) || ! AppPresent(_InstallState) )
        {
            ScriptFlags |= SCRIPTFLAGS_CACHEINFO;

            //
            // Now we decide whether or not to validate the transform list
            //
            // MsiAdvertiseScript incorrectly detects transform conflicts between a user
            // and machine installed version of the same application, so we
            // only validate transforms for user policy if the application is already 
            // in a non absent state per-user.  A transform conflict cannot
            // be possible in that case despite what MsiAdvertiseScript claims.
            //
            // We check for the application's presence below -- note that we can't use
            // the _InstallState member since it is not guaranteed to be set when
            // we reach this point.
            //
            // Note : all this code was also added for a win2k-sp3, and xpsp1 fix.
            //
            BOOL    bValidateTransforms = TRUE;

            if ( _pManApp->IsUserPolicy() )
            {
                INSTALLSTATE    InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );
                WCHAR           wszBuffer[8];
                DWORD           Size = sizeof(wszBuffer) / sizeof(WCHAR);

                if ( AppPresent(InstallState) )
                {
                    //
                    // Be sure to use a new error status here so we don't
                    // overwrite the existing status which should be checked later
                    //

                    DWORD ProductInfoStatus;

                    ProductInfoStatus = (*gpfnMsiGetProductInfo)(
                                _pwszProductId,
                                INSTALLPROPERTY_ASSIGNMENTTYPE,
                                wszBuffer,
                                &Size );
                    
                    //
                    // Only if we don't already have a failure status should we overwrite
                    // the existing status -- otherwise, we will miss the failure in the
                    // call to EnforceAssignmentSecurity, which can happen when we need
                    // to uninstall an unmanaged app but we're in async refresh.  This issue
                    // was found at the end of xpsp1 and was caused when this new code was
                    // added to properly detect transform conflicts in xpsp1.  We are making
                    // the smallest change here to restore the failure path to what it was
                    // before the transform fix for xpsp1 was made.
                    //

                    if ( ERROR_SUCCESS == Status )
                    {
                        Status = ProductInfoStatus;
                    }

                    // '1' means installed per-machine
                    if ( (ERROR_SUCCESS == ProductInfoStatus) && (L'1' == wszBuffer[0]) )
                        bValidateTransforms = FALSE;
                }
            }

            //
            // The application is present, so we must tell Msi to guard against transform 
            // conflicts between the existing application and the one we are trying to install
            //
            if ( ! (_State & APPSTATE_TRANSFORM_CONFLICT) && bValidateTransforms )
                ScriptFlags |= SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST;
        }

        //
        // When an unmanaged instance of the product is uninstall we need to ensure
        // that shortcuts are always added back for the managed product.
        //
        if ( bUnmanageUninstall )
            ScriptFlags |= SCRIPTFLAGS_SHORTCUTS;

        if ( ( _State & APPSTATE_FULL_ADVERTISE ) || _bRestored )
        {
            //
            // This part here means we are in a policy run in winlogon, not
            // in the service doing a demand install.  We are advertising
            // an assigned app, a published app which is an upgrade,
            // or a published app which was removed on another logon (possibly
            // another machine) because its gpo went out of scope but has
            // now come back into scope.
            //
            ScriptFlags |= SCRIPTFLAGS_SHORTCUTS;

            //
            // The first time we apply an assigned app on a machine, we do a
            // full advertise.  Otherwise, we don't advertise shell class
            // registry data and icon/transform data.
            //
            if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) || ! AppPresent(_InstallState) )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;
        }
    }

    if ( ! _pManApp->IsUserPolicy() )
        ScriptFlags |= SCRIPTFLAGS_MACHINEASSIGN;

    if ( ERROR_SUCCESS == Status )
    {
        DebugMsg((DM_VERBOSE, IDS_ADVERTISE, _pwszDeploymentName, _pwszLocalScriptPath, ScriptFlags));

        Status = CallMsiAdvertiseScript(
                    _pwszLocalScriptPath,
                    ScriptFlags,
                    NULL,
                    FALSE );
    }

    if ( ERROR_SUCCESS == Status )
    {
        bAdvertised = TRUE;

        if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
            _AssignCount++;
    }
    else
    {
        DebugMsg((DM_WARNING, IDS_ADVERTISE_FAIL, _pwszDeploymentName, _pwszLocalScriptPath, Status));
    }

    //
    // Abort early in this case without deleting any management data.
    // The app will be reapplied asynchronously in this case.
    //
    if ( (ACTION_APPLY == _Action) &&
         (ERROR_INSTALL_ALREADY_RUNNING == Status) )
        return Status;

    //
    // If we have a transform conflict with this app, then abort the assign
    // now without removing the app.  Callers of this routine will fix up
    // the app state and retry if appropriate.
    //
    if ( ERROR_INSTALL_TRANSFORM_FAILURE == Status )
        return Status;

SaveAppData:

    //
    // Always set this, even when bAddAppData is FALSE.  This controls the
    // UI level used for descriptor based installs from shell & com.  The
    // last writer (highest precedence app for a product id) wins.
    //
    if ( ERROR_SUCCESS == Status )
    {
        Status = RegSetValueEx(
                    _pManApp->AppmgmtKey(),
                    _pwszProductId,
                    0,
                    REG_DWORD,
                    (LPBYTE) &_InstallUILevel,
                    sizeof(DWORD) );
    }

    //
    // We only write/update our registry state if we've gotten info back down
    // from the Directory.
    //
    if ( (ERROR_SUCCESS == Status) && bAddAppData && (_ActFlags != 0) )
    {
        _pManApp->Revert();

        hkApp = 0;

        Status = RegCreateKeyEx(
                    _pManApp->AppmgmtKey(),
                    wszDeploymentId,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hkApp,
                    NULL );

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        DEPLOYMENTNAMEVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszDeploymentName,
                        lstrlen( _pwszDeploymentName ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        GPONAMEVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszGPOName,
                        lstrlen( _pwszGPOName ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        GPOIDVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszGPOId,
                        lstrlen( _pwszGPOId ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        PRODUCTIDVALUE,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszProductId,
                        lstrlen( _pwszProductId ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( _pwszSupportURL && (ERROR_SUCCESS == Status) )
        {
            Status = RegSetValueEx(
                        hkApp,
                        SUPPORTURL,
                        0,
                        REG_SZ,
                        (LPBYTE) _pwszSupportURL,
                        lstrlen( _pwszSupportURL ) * sizeof(WCHAR) + sizeof(WCHAR) );
        }

        if ( (ERROR_SUCCESS == Status) && (_Overrides > 0) )
        {
            WCHAR * pwszSupercededIds;
            WCHAR * pwszString;

            pwszSupercededIds = new WCHAR[(_Overrides * (GUIDSTRLEN + 1)) + 1];

            if ( pwszSupercededIds )
            {
                pwszString = pwszSupercededIds;
                for ( DWORD n = 0; n < _Overrides; n++ )
                {
                    GuidToString( _pOverrides[n], pwszString );
                    pwszString += GUIDSTRLEN + 1;
                }
                *pwszString = 0;

                Status = RegSetValueEx(
                            hkApp,
                            SUPERCEDEDIDS,
                            0,
                            REG_MULTI_SZ,
                            (LPBYTE) pwszSupercededIds,
                            (_Overrides * (GUIDSTRLEN + 1) + 1) * sizeof(WCHAR) );
            }
            else
            {
                Status = ERROR_OUTOFMEMORY;
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        ASSIGNCOUNTVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &_AssignCount,
                        sizeof(DWORD) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        REVISIONVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &_DirectoryRevision,
                        sizeof(DWORD) );

            if ( (ERROR_SUCCESS == Status) && (_DirectoryRevision > 0) )
            {
                Status = RegSetValueEx(
                            hkApp,
                            SCRIPTTIMEVALUE,
                            0,
                            REG_BINARY,
                            (LPBYTE) &_ScriptTime,
                            sizeof(_ScriptTime) );
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegSetValueEx(
                        hkApp,
                        INSTALLUI,
                        0,
                        REG_DWORD,
                        (LPBYTE) &_InstallUILevel,
                        sizeof(DWORD) );
        }

        if ( ERROR_SUCCESS == Status )
        {
            if ( _ActFlags )
            {
                AppState = 0;

                //
                // If an app becomes disabled then is gets neither the assigned
                // nor the published state bit.
                //
                if ( _ActFlags & ACTFLG_Assigned )
                    AppState |= APPSTATE_ASSIGNED;
                else if ( _ActFlags & ACTFLG_Published )
                    AppState |= APPSTATE_PUBLISHED;

                AppState |= (_ActFlags & ACTFLG_UninstallOnPolicyRemoval) ? APPSTATE_POLICYREMOVE_UNINSTALL : APPSTATE_POLICYREMOVE_ORPHAN;
                if ( _bNeedsUnmanagedRemove )
                    AppState |= APPSTATE_UNINSTALL_UNMANAGED;
                if ( _ActFlags & ACTFLG_InstallUserAssign )
                    AppState |= APPSTATE_INSTALL;
            }
            else
            {
                AppState = _State;
            }

            AppState &= APPSTATE_PERSIST_MASK;

            Status = RegSetValueEx(
                        hkApp,
                        APPSTATEVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &AppState,
                        sizeof(DWORD) );
        }

        if ( hkApp )
            RegCloseKey( hkApp );

        (void) _pManApp->Impersonate();
    }

ReportStatus:

    if ( bDoAdvertise && bAddAppData )
        gpEvents->Assign( Status, this );

    //
    // If we hit an error then the destructor of this object will make sure we delete the script file so a full
    // advertise will be tried next time.
    //

    return Status;
}

DWORD
CAppInfo::Install()
{
    DWORD   Status;

    //
    // During async refreshes, we will not install an application as that
    // would be disruptive to the user
    //
    if ( ! _pManApp->Async() )
    {
        //
        // Installs can happen for machine assign apps or for user apps when there
        // are transform conflicts.
        //
        // Always set UI to NONE.
        //
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        DebugMsg((DM_VERBOSE, IDS_INSTALL, _pwszDeploymentName, _pwszGPOName));

        Status = CallMsiConfigureProduct(
            _pwszProductId,
            INSTALLLEVEL_DEFAULT,
            INSTALLSTATE_DEFAULT,
            NULL );
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        
        Status = _Status;
    }

    gpEvents->Install( Status, this );

    return Status;
}

DWORD
CAppInfo::Reinstall()
{
    DWORD   Status;

    //
    // For async refreshes, We do not want to reinstall an application
    // since that would disrupt the user
    //
    if ( ! _pManApp->Async() )
    {
        //
        // Reinstalls can happen when a redeploy action is specified in the SI UI.
        // This is normally done when a binary patch is applied to an application.
        //
        // Always set UI to NONE.
        //
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        DebugMsg((DM_VERBOSE, IDS_REINSTALL, _pwszDeploymentName));

        Status = CallMsiReinstallProduct( _pwszProductId );
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        
        Status = _Status;
    }

    gpEvents->Reinstall( Status, this );

    return Status;
}

DWORD
CAppInfo::Unassign(
    DWORD   ScriptFlags, // = 0
    BOOL    bRemoveAppData // = TRUE
    )
{
    HKEY    hkApp;
    WCHAR   wszDeploymentId[40];
    DWORD   AppState;
    DWORD   Status;

    ASSERT( ! _pManApp->GetRsopContext()->IsPlanningModeEnabled() );

    //
    // For async refreshes, We do not want to unassign an application
    // since that would disrupt the user
    //
    if ( _pManApp->Async() )
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;

        if ( bRemoveAppData )
            gpEvents->Unassign( _Status, this );
        
        return _Status;
    }

    GuidToString( _DeploymentId, wszDeploymentId );

    if ( bRemoveAppData )
        DebugMsg((DM_VERBOSE, IDS_UNMANAGE, _pwszDeploymentName));

    Status = STATUS_SUCCESS;

    if ( ScriptFlags != 0 )
    {
        if ( ! _pManApp->IsUserPolicy() )
            ScriptFlags |= SCRIPTFLAGS_MACHINEASSIGN;

        DebugMsg((DM_VERBOSE, IDS_UNADVERTISE, _pwszDeploymentName, _pwszLocalScriptPath));

        Status = CallMsiAdvertiseScript(
                    _pwszLocalScriptPath,
                    ScriptFlags,
                    NULL,
                    TRUE );

        // It's possible for the product to be uninstalled without us knowing.
        if ( ERROR_UNKNOWN_PRODUCT == Status )
            Status = ERROR_SUCCESS;

        if ( Status != ERROR_SUCCESS )
            DebugMsg((DM_WARNING, IDS_UNADVERTISE_FAIL, _pwszDeploymentName, _pwszLocalScriptPath, Status));
    }

    if ( (ERROR_SUCCESS == Status) && bRemoveAppData )
    {
        _pManApp->Revert();

        DeleteFile( _pwszLocalScriptPath );
        _State &= ~APPSTATE_SCRIPT_PRESENT;

        //
        // Do not delete the productid->installui hint value when a product is removed
        // because of productid or transform conflicts.  In both of these cases it means
        // an app with the same productid is still currently being managed.  
        // This is important because the unmanage calls are done last when handling ARP
        // requests and this will inadvertently delete the productid->installui hint value
        // for a product which is still being managed.
        //
        if ( (_dwRemovalCause != APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT) &&
             (_dwRemovalCause != APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM) )
            RegDeleteValue( _pManApp->AppmgmtKey(), _pwszProductId );

        _AssignCount--;

        if ( _AssignCount > 0 )
        {
            BOOL bUpdateState;
            
            bUpdateState = TRUE;

            if ( ACTION_ORPHAN == _Action )
            {
                DebugMsg((DM_VERBOSE, IDS_UNMANAGE_ORPHAN, _pwszDeploymentName));
                AppState = APPSTATE_ORPHANED;
            }
            else if ( ( ACTION_UNINSTALL == _Action ) || ( ACTION_NONE == _Action ) )
            {
                DebugMsg((DM_VERBOSE, IDS_UNMANAGE_UNINSTALL, _pwszDeploymentName));
                AppState = APPSTATE_UNINSTALLED;
            }
            else
            {
                bUpdateState = FALSE;
            }

            Status = RegOpenKeyEx(
                            _pManApp->AppmgmtKey(),
                            wszDeploymentId,
                            0,
                            KEY_ALL_ACCESS,
                            &hkApp );

            if ( ERROR_SUCCESS == Status )
            {
                DWORD RemovedState;

                RemovedState = _State & APPSTATE_PERSIST_MASK;

                if ( _pManApp->IsRemovingPolicies() )
                {
                    Status = RegSetValueEx(
                        hkApp,
                        REMOVEDGPOSTATE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &RemovedState,
                        sizeof(DWORD) );
                }
                
                if ( bUpdateState &&
                     ( ERROR_SUCCESS == Status ) )
                {
                    Status = RegSetValueEx(
                        hkApp,
                        APPSTATEVALUE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &AppState,
                        sizeof(DWORD) );
                }

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegSetValueEx(
                                hkApp,
                                ASSIGNCOUNTVALUE,
                                0,
                                REG_DWORD,
                                (LPBYTE) &_AssignCount,
                                sizeof(DWORD) );
                }

                RegCloseKey( hkApp );
            }

            if ( Status != ERROR_SUCCESS )
            {
                Status = ERROR_SUCCESS;
                RegDeleteKey( _pManApp->AppmgmtKey(), wszDeploymentId );
            }
        }
        else
        {
            RegDeleteKey( _pManApp->AppmgmtKey(), wszDeploymentId );
        }

        (void) _pManApp->Impersonate();
    }

    if ( bRemoveAppData )
        gpEvents->Unassign( Status, this );

    return Status;
}

DWORD
CAppInfo::Uninstall( 
    BOOL bLogFailure // = TRUE
    )
{
    DWORD   Status;

    //
    // For async refreshes, We do not want to uninstall an application
    // since that would disrupt the user
    //
    if ( ! _pManApp->Async() )
    {
        // Uninstalls happen in our background thread.  Always set UI to NONE.
        (*gpfnMsiSetInternalUI)( INSTALLUILEVEL_NONE, NULL );

        DebugMsg((DM_VERBOSE, IDS_UNINSTALL, _pwszDeploymentName, _pwszGPOName));

        Status = CallMsiConfigureProduct(
            _pwszProductId,
            INSTALLLEVEL_MAXIMUM,
            INSTALLSTATE_ABSENT,
            NULL );

        // It's possible for the product to be uninstalled without us knowing.
        if ( ERROR_UNKNOWN_PRODUCT == Status )
            Status = ERROR_SUCCESS;
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        _Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        
        Status = _Status;
    }

    if ( bLogFailure )
    {
        gpEvents->Uninstall( Status, this );
    }

    return Status;
}


HRESULT
CAppInfo::Write( CPolicyRecord* pRecord )
{
    HRESULT hr;
    LONG   EntryType;
    WCHAR  wszDeploymentId[ MAX_SZGUID_LEN ];

    EntryType = GetPublicRsopEntryType();

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ENTRYTYPE,
        EntryType);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pRecord->SetValue(
        RSOP_ATTRIBUTE_NAME,
        _pwszDeploymentName);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_NAME, hr )

    if (FAILED(hr))
    {
        goto cleanup;
    }

    GuidToString( _DeploymentId, wszDeploymentId );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_APPID,
        wszDeploymentId);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPID, hr );

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ENTRYTYPE,
        EntryType);
    
    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ENTRYTYPE, hr )

    if (FAILED(hr))
    {
        goto cleanup;
    }

    //
    // For the remaining attributes, we will ignore failures -- at this
    // point, they have the application name, which is useful in
    // and of itself.
    //

    //
    // These properties are only written for new records -- if we are creating
    // an instance from an existing record, will not write these properties since
    // the current instance already has them set correctly and the reason that we're
    // re-using this instance is that we do not have this information
    //
    if ( pRecord->AlreadyExists() )
    {
        return hr;
    }
     
    {
        SYSTEMTIME CurrentTime;

        //
        // This does not fail
        //
        GetSystemTime( &CurrentTime );

        hr = pRecord->SetValue(
            RSOP_ATTRIBUTE_CREATIONTIME,
            &CurrentTime);

        REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_CREATIONTIME, hr );
    }

    hr = pRecord->SetValue(
        RSOP_ATTRIBUTE_GPOID,
        _pwszGPODSPath);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_GPOID, hr )

    hr = pRecord->SetValue(
        RSOP_ATTRIBUTE_SOMID,
        _pwszSOMId);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_SOMID, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ENTRYTYPE,
        EntryType);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ENTRYTYPE, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_SECURITY_DESCRIPTOR,
        _rgSecurityDescriptor,
        _cbSecurityDescriptor);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_SECURITY_DESCRIPTOR, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_VERSIONLO,
        (LONG)_VersionLo);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_VERSIONLO, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_VERSIONHI,
        (LONG)_VersionHi);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_VERSIONHI, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_PRODUCT_ID,
        _pwszProductId);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PRODUCT_ID, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_SCRIPTFILE,
        _pwszGPTScriptPath);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_SCRIPTFILE, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_LANGUAGEID,
        (LONG) _LangId);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_LANGUAGEID, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_DEPLOY_TYPE,
        (_ActFlags & ACTFLG_Assigned ?
         APP_ATTRIBUTE_DEPLOY_VALUE_ASSIGNED :
         APP_ATTRIBUTE_DEPLOY_VALUE_PUBLISHED));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_DEPLOY_TYPE, hr )

    {
        LONG AssignmentType;
        
        if ( _ActFlags & ACTFLG_Published )
        {
            AssignmentType = APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_NOTASSIGNED;
        }
        else if ( _ActFlags & ACTFLG_InstallUserAssign )
        {
            AssignmentType = APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_INSTALL;
        }
        else
        {
            AssignmentType = APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_STANDARD;
        }
    
        hr = pRecord->SetValue(
            APP_ATTRIBUTE_ASSIGNMENT_TYPE,
            AssignmentType);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ASSIGNMENT_TYPE, hr )
    }

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_INSTALLATIONUI,
        ((INSTALLUILEVEL_FULL == _InstallUILevel) ?
             APP_ATTRIBUTE_INSTALLATIONUI_VALUE_MAXIMUM :
             APP_ATTRIBUTE_INSTALLATIONUI_VALUE_BASIC));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_INSTALLATIONUI, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ONDEMAND,
        (BOOL)(_ActFlags & ACTFLG_OnDemandInstall));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_LOSSOFSCOPEACTION,
        (BOOL)(_ActFlags & ACTFLG_OrphanOnPolicyRemoval) ?
            APP_ATTRIBUTE_SCOPELOSS_ORPHAN :
            APP_ATTRIBUTE_SCOPELOSS_UNINSTALL);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_LOSSOFSCOPEACTION, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_IGNORELANGUAGE,
        (BOOL)(_ActFlags & ACTFLG_IgnoreLanguage));

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_IGNORELANGUAGE, hr )

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_PACKAGELOCATION,
        _pwszPackageLocation);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PACKAGELOCATION, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_CATEGORYLIST,
        _rgwszCategories,
        _cCategories);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_CATEGORYLIST, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_TRANSFORMLIST,
        _rgwszTransforms,
        _cTransforms);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_TRANSFORMLIST, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ARCHITECTURES,
        _rgArchitectures,
        _cArchitectures);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ARCHITECTURES, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_PUBLISHER,
        _pwszPublisher ? _pwszPublisher : L"" );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PUBLISHER, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_REDEPLOYCOUNT,
        (LONG) _DirectoryRevision);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REDEPLOYCOUNT, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_UPGRADE_SETTINGS_MANDATORY,
        (BOOL) ( _ActFlags & ACTFLG_ForceUpgrade ) );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_UPGRADE_SETTINGS_MANDATORY, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_UNINSTALL_UNMANAGED,
        (BOOL) ( _bNeedsUnmanagedRemove ) );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_UNINSTALL_UNMANAGED, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_DISPLAYINARP,
        (BOOL) ( _ActFlags & ACTFLG_UserInstall ) );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_DISPLAYINARP, hr );

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_SUPPORTURL,
        _pwszSupportURL);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_SUPPORTURL, hr );

    if ( APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE == EntryType )
    {
        hr = WriteRemovalProperties( pRecord );
    }

    {
        BOOL bX86OnIA64;

        bX86OnIA64 = FALSE;

        //
        // If this is an x86 package, see if this applies to 64-bit clients
        //
        if ( PROCESSOR_ARCHITECTURE_INTEL == _PrimaryArchitecture )
        {
            //
            // If it has been excluded by the admin, it does not apply
            //
            if ( ! ( ACTFLG_ExcludeX86OnIA64 & _ActFlags ) )
            {
                bX86OnIA64 = TRUE;
            }
                
            //
            // The flag above is reversed if this is a ZAP app -- flip
            // the logic to support the reverse preference.
            //
            if ( SetupNamePath == _PathType )
            {
                bX86OnIA64 = ! bX86OnIA64;
            }
        }

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_X86OnIA64,
            bX86OnIA64);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_X86OnIA64, hr);
    }

    {
        SYSTEMTIME SystemTime;
        BOOL       bStatus;

        bStatus = FileTimeToSystemTime(
            (FILETIME*) &_USN,
            &SystemTime);

        if ( bStatus )
        {
            hr = pRecord->SetValue(
                APP_ATTRIBUTE_MODIFYTIME,
                &SystemTime);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_MODIFYTIME, hr);
        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    {
        LONG PackageType;

        switch ( _PathType )
        {
        case DrwFilePath:
            PackageType = APP_ATTRIBUTE_PACKAGETYPE_VALUE_WIN_INSTALLER;
            break;

        case SetupNamePath:
            PackageType = APP_ATTRIBUTE_PACKAGETYPE_VALUE_ZAP;
            break;

        default:
            ASSERT ( L"Invalid packagetype" && FALSE );
            break;
        }

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_PACKAGETYPE,
            (LONG) PackageType);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PACKAGETYPE, hr )
    }

    if ( ! _pManApp->ARPList() )
    {
        DWORD  dwInstallType;
        WCHAR* wszDemandSpec;
        WCHAR* wszProperty;

        dwInstallType = _pManApp->GetRsopContext()->GetDemandSpec( &wszDemandSpec );
        wszProperty = NULL;

        switch (dwInstallType)
        {
        case CRsopAppContext::DEMAND_INSTALL_FILEEXT:

            wszProperty = APP_ATTRIBUTE_ONDEMAND_FILEEXT;
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_FILEEXT;
            break;

        case CRsopAppContext::DEMAND_INSTALL_CLSID:

            wszProperty = APP_ATTRIBUTE_ONDEMAND_CLSID;
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_CLSID;
            break;

        case CRsopAppContext::DEMAND_INSTALL_PROGID:

            wszProperty = APP_ATTRIBUTE_ONDEMAND_PROGID;
            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROGID;
            break;

        case CRsopAppContext::DEMAND_INSTALL_NAME:

            _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_USER;
            wszProperty = NULL;
            break;

        case CRsopAppContext::DEMAND_INSTALL_NONE:

            //
            // We reach this case if we are in policy application 
            //
            wszProperty = NULL;

            if ( ( _dwApplyCause == APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE ) && ! IsSuperseded() ) 
            {
                if ( _ActFlags & ACTFLG_Assigned ) 
                {
                    _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED;
                }
                else if ( _ActFlags & ACTFLG_Published )
                {
                    if ( _State & APPSTATE_SCRIPT_NOT_EXISTED )
                    {
                        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE;
                    }
                    else if ( _State & APPSTATE_ASSIGNED )
                    { 
                        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED;
                    }
                    else
                    {
                        _dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_USER;

                        if ( ! _pManApp->GetRsopContext()->Transition() )
                        {
                            _dwApplyCause = _dwUserApplyCause;
                            wszProperty = _wszDemandProp;
                            wszDemandSpec = _wszDemandSpec;
                        }
                    }
                }
            }

            break;

        default:
            
            ASSERT( L"Invalid RSoP Install Context" && FALSE );
            break;

        }

        if ( wszProperty )
        {
            hr = pRecord->SetValue(
                wszProperty,
                wszDemandSpec);

            REPORT_ATTRIBUTE_SET_STATUS( wszProperty, hr )
        }
        else if ( APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE != EntryType )
        {
            //
            // Ensure that
            //
            hr = pRecord->ClearValue(
                APP_ATTRIBUTE_ONDEMAND_FILEEXT);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_FILEEXT, hr )

            hr = pRecord->ClearValue(
                APP_ATTRIBUTE_ONDEMAND_CLSID);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_CLSID, hr )

            hr = pRecord->ClearValue(
                APP_ATTRIBUTE_ONDEMAND_PROGID);

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_PROGID, hr )
        }
      
        if ( APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE != _dwApplyCause )
        {
            hr = pRecord->SetValue(
                APP_ATTRIBUTE_APPLY_CAUSE,
                (LONG) _dwApplyCause);
            
            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr )
        }
    }

    {
        LONG MatchType;

        switch(_LanguageWeight)
        {
        case PRI_LANG_ALWAYSMATCH:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_IGNORE;
            break;

        case PRI_LANG_SYSTEMLOCALE:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_SYSLOCALE;
            break;

        case PRI_LANG_ENGLISH:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_ENGLISH;
            break;

        case PRI_LANG_NEUTRAL:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_NEUTRAL;
            break;

        default:
            MatchType = APP_ATTRIBUTE_LANGMATCH_VALUE_NOMATCH;
            break;
        }

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_LANGMATCH,
            MatchType);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_LANGMATCH, hr )
    }

    hr = pRecord->SetValue(
        APP_ATTRIBUTE_ELIGIBILITY,
        GetEligibility() );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ELIGIBILITY, hr )

    LogUpgrades( pRecord );

cleanup:

    return hr;
}

HRESULT
CAppInfo::WriteRemovalProperties(
    CPolicyRecord* pRemovalRecord )
{
    HRESULT hr;
    LONG    RemovalType;
    LONG    RemovalCause;

    RemovalCause = (LONG) _dwRemovalCause;

    if ( CRsopAppContext::REMOVAL == _pManApp->GetRsopContext()->GetContext() )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
    }
    else if ( APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE == RemovalCause )
    {
        if ( ACTION_UNINSTALL == Action() )
        {
            RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
        }
        else
        {
            RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UPGRADED;
        }
    }
    else if ( APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM == RemovalCause )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
    }
    else if ( ACTION_ORPHAN == Action() )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_ORPHAN;
    }
    else if ( ACTION_UNINSTALL == Action() )
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED;
    }
    else 
    {
        RemovalType = APP_ATTRIBUTE_REMOVALTYPE_NONE;
    }

    if ( APP_ATTRIBUTE_REMOVALTYPE_NONE == RemovalType )
    {
        return S_OK;
    }
     
    hr = pRemovalRecord->SetValue(
            APP_ATTRIBUTE_REMOVAL_CAUSE,
            RemovalCause);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_CAUSE, hr );

    hr = pRemovalRecord->SetValue(
        APP_ATTRIBUTE_REMOVAL_TYPE,
        RemovalType);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_TYPE, hr );

    hr = pRemovalRecord->ClearValue(
        APP_ATTRIBUTE_PRECEDENCE_REASON);

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PRECEDENCE_REASON, hr );

    if ( _pwszRemovingDeploymentId )
    {
        hr = pRemovalRecord->SetValue(
            APP_ATTRIBUTE_REMOVING_APP,
            _pwszRemovingDeploymentId);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVING_APP, hr )
    }

    return hr;
}

HRESULT
CAppInfo::ClearRemovalProperties( CPolicyRecord* pRecord )
{
    HRESULT hr;

    hr = pRecord->ClearValue( APP_ATTRIBUTE_REMOVAL_CAUSE );

    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_CAUSE, hr )

    if ( SUCCEEDED( hr ) )
    {
        hr = pRecord->ClearValue( APP_ATTRIBUTE_REMOVAL_TYPE );

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVAL_TYPE, hr )
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = pRecord->ClearValue( APP_ATTRIBUTE_REMOVING_APP );

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REMOVING_APP, hr )
    }

    return hr;
}


LONG
CAppInfo::GetRsopEntryType()
{
    LONG EntryType;

    if ( _pManApp->ARPList() )
    {
         EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM;
    }
    else
    {
        if ( ( _Action == ACTION_APPLY )  ||
             ( _Action == ACTION_INSTALL ) ||
             ( _Action == ACTION_REINSTALL ) )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE;
        }
        else if ( ( _Action == ACTION_ORPHAN ) ||
                  ( _Action == ACTION_UNINSTALL ) )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE;
        }
        else if ( ( _State & APPSTATE_ASSIGNED ) |
                  ( _State & APPSTATE_PUBLISHED ) )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE;
        }
        else
        {
            EntryType = NO_RSOP_ENTRY;
        }
    }

    return EntryType;
}

LONG
CAppInfo::GetPublicRsopEntryType()
{
    LONG EntryType;

    if ( IsSuperseded() )
    {
        if ( _pManApp->ARPList() )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM;
        }
        else
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE;
        }
    }
    else
    {
        EntryType = GetRsopEntryType();
    }

    return EntryType;
}

LONG
CAppInfo::GetEligibility()
{
    LONG Eligibility;

    Eligibility = 0;

    if ( ! ( CRsopAppContext::ARPLIST == _pManApp->GetRsopContext()->GetContext() ) )
    {
        if ( ! ( CRsopAppContext::POLICY_REFRESH == _pManApp->GetRsopContext()->GetContext() ) && 
             ! IsSuperseded() )
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED;
        }
        else if ( ( _ActFlags & ACTFLG_Assigned ) || ( _State & APPSTATE_ASSIGNED ) ) 
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_ASSIGNED;
        }
        else if ( _ActFlags & ACTFLG_HasUpgrades )
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_UPGRADES;
        }
        else if ( ( _dwApplyCause == APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE ) ||
                  _DemandInstall ) 
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED;
        }
        else if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_PLANNING;
        }
        else
        {
            Eligibility = APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED;
        }
    }

    return Eligibility;
}

HRESULT
CAppInfo::SetRemovingDeploymentId( GUID* pDeploymentId )
{
    if ( ! _pwszRemovingDeploymentId )
    {
        _pwszRemovingDeploymentId = new WCHAR[ MAX_SZGUID_LEN ];
    }

    if ( ! _pwszRemovingDeploymentId )
    {
        return E_OUTOFMEMORY;
    }

    GuidToString( *pDeploymentId, _pwszRemovingDeploymentId );

    return S_OK;
}

void
CAppInfo::SetRsopFailureStatus(
    DWORD dwStatus,
    DWORD dwEventId)
{
    CAppStatus* pNewStatus;

    //
    // Allocate a new failure status for this application --
    // it will be freed by the destructor of this class
    //
    pNewStatus = new CAppStatus;

    if ( ! pNewStatus )
    {
        _pManApp->GetRsopContext()->DisableRsop( E_OUTOFMEMORY );
        return;
    }

    //
    // Set the status as specified by the caller
    //
    pNewStatus->SetRsopFailureStatus( dwStatus, dwEventId );

    //
    // Remember this new status --
    // keep track of multiple errors in the order they were logged
    //
    _StatusList.InsertFIFO( pNewStatus );

    //
    // Always reset this so that if someone calls GetCurrentItem,
    // they will get the first thing in the list -- if this is
    // never called, the list returns NULL
    //
    _StatusList.Reset();
}


LONG
CAppInfo::UpdatePrecedence(
    CAppInfo* pLosingApp,
    DWORD     dwConflict
    )
{
    LONG Status;

    Status = ERROR_SUCCESS;

    if ( ! _bSupersedesAssigned )
    {
        if ( pLosingApp->_bSupersedesAssigned )
        {
            _bSupersedesAssigned = pLosingApp->_bSupersedesAssigned;
        }
        else
        {
            _bSupersedesAssigned = ( ACTFLG_Assigned & pLosingApp->_ActFlags );
        }
    }

    //
    // If Rsop logging is enabled, we need to update
    // the precedence of this application according
    // to the conflict
    //
    if ( _pManApp->GetRsopContext()->IsRsopEnabled() )
    {
        Status = _SupersededApps.AddConflict( pLosingApp, this, dwConflict );

        //
        // Supersede the losing app -- that is, mark it as
        // superseded so that later on when writing the rsop
        // log we do not log it as a winning application
        //
        if ( ERROR_SUCCESS == Status )
        {
            pLosingApp->Supersede();

            DebugMsg((
                DM_VERBOSE,
                IDS_RSOP_SUPERSEDED,
                pLosingApp->_pwszDeploymentName,
                pLosingApp->_pwszGPOName,
                _pwszDeploymentName,
                _pwszGPOName,
                dwConflict));
        }
        else
        {
            HRESULT hr;

            hr = HRESULT_FROM_WIN32( Status );

            _pManApp->GetRsopContext()->DisableRsop( hr );
        }
    }

    return Status;
}


void
CAppInfo::LogUpgrades( CPolicyRecord* pRecord )
{
    if (!_Upgrades)
    {
        return;
    }

    WCHAR** rgwszUpgradeable;
    WCHAR** rgwszReplaceable;

    rgwszUpgradeable = NULL;
    rgwszReplaceable = NULL;

    rgwszUpgradeable = new WCHAR*[_Upgrades];

    if ( ! rgwszUpgradeable )
    {
        goto ExitAndCleanup_LogUpgrades;
    }

    rgwszReplaceable = new WCHAR*[_Upgrades];

    if ( ! rgwszUpgradeable )
    {
        goto ExitAndCleanup_LogUpgrades;
    }

    RtlZeroMemory(rgwszUpgradeable, _Upgrades * sizeof(*rgwszUpgradeable));
    RtlZeroMemory(rgwszReplaceable, _Upgrades * sizeof(*rgwszReplaceable));

    DWORD cUpgradeable;
    DWORD cReplaceable;

    cUpgradeable = 0;
    cReplaceable = 0;

    //
    // We will iterate through each upgrade so that we can log it
    //
    DWORD   iUpgrade;

    for (iUpgrade = 0; iUpgrade < _Upgrades; iUpgrade++)
    {
        WCHAR** ppwszUpgradeId;

        //
        // We only track the applications that we upgrade, not those
        // that we are upgraded by. Note that we do not check for the
        // converse flag, UPGRADE_OVER, since it can get cleared when
        // an upgrade relationship is reversed -- we still need to
        // log that as an upgrade for this app
        //
        if ( _pUpgrades[iUpgrade].Flags & UPGRADE_BY )
        {
            continue;
        }

        //
        // If this upgrade is the result of a reversed upgrade due to
        // a policy precedence violation, we should not log it as part
        // of this application's upgrades
        //
        if ( _pUpgrades[iUpgrade].Flags & UPGRADE_REVERSED )
        {
            continue;
        }

        if ( _pUpgrades[iUpgrade].Flags & UPGRADE_UNINSTALL )
        {
            ppwszUpgradeId = &(rgwszReplaceable[cReplaceable]);
            cReplaceable++;
        }
        else
        {
            ppwszUpgradeId = &(rgwszUpgradeable[cUpgradeable]);
            cUpgradeable++;
        }

        //
        // The RSoP schema requires the guids be in string form,
        // so we need to convert this guid to a string -- note that
        // this call allocates memory which must be freed later
        //
        GuidToString(
            _pUpgrades[iUpgrade].DeploymentId,
            ppwszUpgradeId);

        if ( ! *ppwszUpgradeId )
        {
            break;
        }
    }

    if (iUpgrade == _Upgrades)
    {
        HRESULT hr;

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_UPGRADEABLE_APPLICATIONS,
            rgwszUpgradeable,
            cUpgradeable);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_UPGRADEABLE_APPLICATIONS, hr )

        hr = pRecord->SetValue(
            APP_ATTRIBUTE_REPLACEABLE_APPLICATIONS,
            rgwszReplaceable,
            cReplaceable);

        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_REPLACEABLE_APPLICATIONS, hr )
    }

    //
    // Free the memory allocated in the GuidToString call for each upgrade guid
    //
    for (iUpgrade = 0; iUpgrade < cUpgradeable; iUpgrade++)
    {
        delete [] rgwszUpgradeable[iUpgrade];
    }

    for (iUpgrade = 0; iUpgrade < cReplaceable; iUpgrade++)
    {
        delete [] rgwszReplaceable[iUpgrade];
    }

ExitAndCleanup_LogUpgrades:

    delete [] rgwszUpgradeable;
    delete [] rgwszReplaceable;
}

BOOL
CAppInfo::IsLocal()
{
    return NULL == _pwszGPODSPath;
}

BOOL
CAppInfo::IsGpoInScope()
{
    BOOL bGpoInScope;

    bGpoInScope = FALSE;

    if ( _pwszGPOId )
    {
        CGPOInfoList& GpoInfoList = _pManApp->GPOList();

        bGpoInScope = ( NULL != GpoInfoList.Find( _pwszGPOId ) );
    }

    return bGpoInScope;
}

LONG
CAppInfo::InitializeRSOPTransformsList(
    PACKAGEDISPINFO* pPackageInfo
    )
{
    if ( ! pPackageInfo->cTransforms )
    {
        return ERROR_SUCCESS;
    }

    //
    // The first element of the transforms list is
    // actually the original package itself, so we don't count it
    //
    _cTransforms = pPackageInfo->cTransforms - 1;

    //
    // If we have transforms, get space for them
    //
    if ( 0 != _cTransforms )
    {
        //
        // The elements in the transform list are
        // the actual transforms, so we'll copy them to our own list -- first
        // allocate enough space for pointers to each path
        //
        _rgwszTransforms = new WCHAR* [ _cTransforms ];
        
        if ( ! _rgwszTransforms )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RtlZeroMemory( _rgwszTransforms, sizeof(*_rgwszTransforms) * _cTransforms );
    }

    //
    // Now place the transforms into the array
    //
    
    //
    // Each transform is of the form <index>:<path>.  The <index> is
    // an integer that is unique for each transform in this package and
    // less than or equal to the number of transforms.  The 0th transform
    // is actually not a transform, but the source package itself, and this
    // is special cased
    //

    //
    // Copy each transform path to an element in the array of strings.  We 
    // decide which element in the array based on the <index> indicated
    // in the transform string, shifted down 1 to skip the 0th (the source package).
    // For example, the transform with <index> 1 goes to array element 0, 
    // the transform with <index> 4 goes to 3, etc.  That way, no matter what
    // order the transforms are in (e.g. 3,2,0,4,1), because we are mapping
    // based on index, we end up with an ordered array (e.g. 1,2,3,4).
    //
    DWORD iTransform;
    BOOL  bFoundSource;

    bFoundSource = FALSE;

    for ( iTransform = 0; iTransform < pPackageInfo->cTransforms; iTransform++ )
    {
        WCHAR* wszTransform;
        DWORD  dwTransformIndex;

        //
        // First, we need the transform index -- look for the separator
        // so we can find it
        //
        wszTransform = wcschr( pPackageInfo->prgTransforms[ iTransform ], L':' );

        //
        // Check for bogus data
        //
        if ( ! wszTransform )
        {
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Truncate the string right after the index
        //
        *wszTransform = L'\0';

        //
        // The actual transform path starts one past the separator
        //
        wszTransform++;

        //
        // Now convert the index to integer
        //
        UNICODE_STRING TransformIndex;
        NTSTATUS       NtStatus;

        RtlInitUnicodeString( &TransformIndex, pPackageInfo->prgTransforms[ iTransform ] );

        NtStatus = RtlUnicodeStringToInteger( &TransformIndex, 10, &dwTransformIndex );

        //
        // This should only fail if the index string is corrupt ( i.e. the number is not in base 10 )
        //
        if ( ! NT_SUCCESS( NtStatus ) )
        {
            return RtlNtStatusToDosError( NtStatus );
        }

        //
        // The number is correct syntactically, now ensure that semantically it is correct --
        // the index cannot exceed the number of transforms.
        //
        if ( dwTransformIndex > _cTransforms )
        {
            return ERROR_INVALID_PARAMETER;
        }
        
        //
        // Check for the source package -- it is transform index 0
        //
        if ( 0 == dwTransformIndex )
        {
            //
            // Make sure the source is not listed twice
            //
            if ( bFoundSource )
            {
                return ERROR_INVALID_PARAMETER;
            }

            bFoundSource = TRUE;

            //
            // Copy the source package path, minus the prefix,
            // to the member reserved for this purpose -- it currently
            // points to the separator, so we need to go 1 past it
            //
            _pwszPackageLocation = StringDuplicate( wszTransform );
            
            if ( ! _pwszPackageLocation )
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            continue;
        }

        //
        // Shift it down since this index's value includes the source package's
        // occupation of zero, and we want to exclude it
        //
        dwTransformIndex--;

        //
        // Make sure we don't already have a transform at this index -- if we do, this
        // is an ill-formed transform list
        //
        if ( _rgwszTransforms [ dwTransformIndex ] )
        {
            return ERROR_INVALID_PARAMETER;
        }

        _rgwszTransforms[ dwTransformIndex ] = StringDuplicate( wszTransform );

        if ( ! _rgwszTransforms[ dwTransformIndex ] )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // If we did not find a source, this is not a valid transform list
    //
    if ( ! bFoundSource )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return S_OK;
}

LONG
CAppInfo::InitializeRSOPArchitectureInfo( PACKAGEDISPINFO* pPackageInfo )
{
    DWORD iArchitecture;

    _rgArchitectures = new LONG [ pPackageInfo->cArchitectures ];

    if ( ! _rgArchitectures )
    {
        return ERROR_OUTOFMEMORY;
    }

    _cArchitectures = pPackageInfo->cArchitectures;
        
    for ( 
        iArchitecture = 0;
        iArchitecture < _cArchitectures;
        iArchitecture ++ )
    {
        //
        // We need to extract the Win32 processor architecture --
        // the element in the PACKAGEDISPINFO is actually a combination
        // of several other attributes -- the processor architecture is
        // in highest 8 bits, so we'll shift everything right to get it.
        //
        _rgArchitectures[ iArchitecture ] =
            pPackageInfo->prgArchitectures[ iArchitecture ] >> 24;

        //
        // In planning mode, we determine architecture by seeing if it lists 64-bit --
        // if so, we mark it as 64 bit.  If it doesn't list 64-bit, it will be marked 32-bit 
        // if it lists 32-bit.  If it doesn't list either of those, it will be
        // marked as unknown.
        //
        if ( PROCESSOR_ARCHITECTURE_IA64 != _PrimaryArchitecture ) 
        {
            if ( ( PROCESSOR_ARCHITECTURE_INTEL == _rgArchitectures[ iArchitecture ] ) ||
                 ( PROCESSOR_ARCHITECTURE_IA64 == _rgArchitectures[ iArchitecture ] ) )
            {
                _PrimaryArchitecture = _rgArchitectures[ iArchitecture ];
            }
        }
    }

    if ( _pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
    {
        _PrimaryArchitecture = pPackageInfo->MatchedArchitecture >> 24;
    }

    return ERROR_SUCCESS;
}


LONG
CAppInfo::InitializeCategoriesList(
    PACKAGEDISPINFO* pPackageInfo
    )
{
    if ( ! pPackageInfo->cCategories )
    {
        return ERROR_SUCCESS;
    }

    //
    // Reserve enough space so that we can have a pointer
    // to each category guid string
    //
    _cCategories = pPackageInfo->cCategories;

    _rgwszCategories = new WCHAR* [ pPackageInfo->cCategories ];

    if ( ! _rgwszCategories )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( _rgwszCategories, sizeof( *_rgwszCategories ) * _cCategories );

    //
    // Now reserve enough space for each copy of the category
    // guid strings
    //
    DWORD iCategory;

    for ( iCategory = 0; iCategory < _cCategories; iCategory++ )
    {
        _rgwszCategories[ iCategory ] = StringDuplicate( pPackageInfo->prgCategories[ iCategory ] );

        if ( ! _rgwszCategories[ iCategory ] )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return S_OK;
}

WCHAR* CAppInfo::GetRsopAppCriteria()
{
    //
    // We will want to specify an instance that has the conflict id unique
    // to this package and its conflicts, and has an "installed" entry type.
    //

    //
    // First, we calculate the length -- this is actually a constant based
    // on the maximum sizes of the 2 criteria mentioned above: the conflict id
    // is a guid string, and thus has a fixed maximum.  The entry type is a
    // 32 bit quantities, which of course has a maximum string length
    // in decimal notation
    //
    DWORD cCriteriaLen;

    cCriteriaLen =
        MAXLEN_RSOPREMOVAL_QUERY_CRITERIA +
        MAXLEN_RSOPENTRYTYPE_DECIMAL_REPRESENTATION +
        MAXLEN_RSOPPACKAGEID_GUID_REPRESENTATION;

    WCHAR* wszCriteria = new WCHAR [ cCriteriaLen ];

    if ( wszCriteria )
    {
        WCHAR wszDeploymentId [ MAX_SZGUID_LEN ];

        GuidToString( _DeploymentId, wszDeploymentId );

        swprintf(
            wszCriteria,
            RSOP_REMOVAL_QUERY_CRITERIA,
            APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE,
            wszDeploymentId);
    }

    return wszCriteria;
}


DWORD
CAppInfo::CopyScriptIfNeeded()
{
    WCHAR * pwszTempScript;
    DWORD   Length;
    DWORD   Status;

    if ( _State & APPSTATE_SCRIPT_PRESENT )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;

    //
    // It is remotely possible that we could hit this.  For instance, during
    // an ARP readvertise of an uninstalled assigned app.  When using roaming
    // profiles & with policy failing to run at the last logon, we might not
    // have the local script, so we get this far, but this member will not be
    // set when run in the service.
    //
    if ( ! _pwszGPTScriptPath )
        return ERROR_BAD_PATHNAME;

    //
    // When doing user policy we have to do two copies to get the script in the
    // right place.  First we copy to a temp file while impersonating.  This is
    // so our sysvol access is done as the user.  Then we copy from the temp file
    // to the ACLed script dir under %systemroot% while reverted as LocalSystem.
    //
    if ( _pManApp->IsUserPolicy() )
    {
        pwszTempScript = 0;

        Length = GetTempPath( 0, NULL );

        if ( Length > 0 )
        {
            pwszTempScript = new WCHAR[Length + 1 + GUIDSTRLEN + 1];

            if ( pwszTempScript )
            {
                if ( 0 == GetTempPath( Length, pwszTempScript ) )
                    Status = GetLastError();
            }
            else
            {
                Status = ERROR_OUTOFMEMORY;
            }
        }
        else
            Status = GetLastError();

        if ( ERROR_SUCCESS == Status )
        {
            if ( pwszTempScript[lstrlen(pwszTempScript)-1] != L'\\' )
                lstrcat( pwszTempScript, L"\\" );
            GuidToString( _DeploymentId, &pwszTempScript[lstrlen(pwszTempScript)] );

            //
            // CopyFile does not use the thread impersonation token for access checks,
            // so we are ok copying into the system temp dir.
            //
            if ( ! CopyFile(_pwszGPTScriptPath, pwszTempScript, FALSE) )
            {
                Status = GetLastError();
                DebugMsg((DM_WARNING, IDS_SCRIPT_COPY_FAIL, _pwszDeploymentName, _pwszGPOName, _pwszGPTScriptPath, pwszTempScript, Status));
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            _pManApp->Revert();

            if ( ! CopyFile(pwszTempScript, _pwszLocalScriptPath, FALSE) )
            {
                Status = GetLastError();
                DebugMsg((DM_WARNING, IDS_SCRIPT_COPY_FAIL, _pwszDeploymentName, _pwszGPOName, pwszTempScript, _pwszLocalScriptPath, Status));
            }

            DeleteFile( pwszTempScript );

            _pManApp->Impersonate();
        }

        delete pwszTempScript;
    }
    else
    {
        if ( ! CopyFile(_pwszGPTScriptPath, _pwszLocalScriptPath, FALSE) )
        {
            Status = GetLastError();
            DebugMsg((DM_WARNING, IDS_SCRIPT_COPY_FAIL, _pwszDeploymentName, _pwszGPOName, _pwszGPTScriptPath, _pwszLocalScriptPath, Status));
        }
    }

    if ( ERROR_SUCCESS == Status )
        _State |= APPSTATE_SCRIPT_PRESENT;

    return Status;
}

void
CAppInfo::CheckScriptExistence()
{
    if ( _State & (APPSTATE_SCRIPT_EXISTED | APPSTATE_SCRIPT_NOT_EXISTED) )
        return;

    if ( _pManApp->ScriptList().Find( _DeploymentId ) != NULL )
        _State |= APPSTATE_SCRIPT_EXISTED | APPSTATE_SCRIPT_PRESENT;
    else
        _State |= APPSTATE_SCRIPT_NOT_EXISTED;
}

DWORD
CAppInfo::EnforceAssignmentSecurity(
    BOOL * pbDidUninstall
    )
{
    INSTALLSTATE    InstallState;
    WCHAR           wszBuffer[8];
    DWORD           Size;
    DWORD           Status;
    BOOL            bPerMachine;
    BOOL            bUninstall;

    *pbDidUninstall = FALSE;

    if ( ! _bNeedsUnmanagedRemove )
        return ERROR_SUCCESS;

    DebugMsg((DM_VERBOSE, IDS_ENFORCE_SECURE_ON, _pwszDeploymentName, _pwszGPOName));

    InstallState = (*gpfnMsiQueryProductState)( _pwszProductId );

    //
    // If the app is not installed for the user/machine then we are done.
    // Note that if only advertised, our subsequent advertise will update
    // the source path, so we return in that case.
    //
    if ( ! AppPresent( InstallState) || (INSTALLSTATE_ADVERTISED == InstallState) )
        return ERROR_SUCCESS;

    Size = sizeof(wszBuffer) / sizeof(WCHAR);

    Status = (*gpfnMsiGetProductInfo)(
                _pwszProductId,
                INSTALLPROPERTY_ASSIGNMENTTYPE,
                wszBuffer,
                &Size );

    if ( Status != ERROR_SUCCESS )
    {
        DebugMsg((DM_WARNING, IDS_ENFORCE_SECURE_FAIL, _pwszDeploymentName, Status));
        return Status;
    }

    bPerMachine = (L'1' == wszBuffer[0]);

    //
    // For user policy we only care about user installed apps and for machine
    // policy we only care about machine installed apps.
    //
    if ( (_pManApp->IsUserPolicy() && bPerMachine) ||
         (! _pManApp->IsUserPolicy() && ! bPerMachine) )
        return ERROR_SUCCESS;

    //
    // If the app is present for the user and we've previously
    // assigned it, we are safe if the product is marked for elevated
    // install.
    // 
    // If we've previously installed a machine assigned app then it's ok,
    // because by definition all machine installed apps are elevated
    // (because they require admin priviledge to install), so we 
    // don't need this extra check for them.
    //
    if ( _State & APPSTATE_SCRIPT_EXISTED )
    {
        BOOL    bElevated;

        if ( _pManApp->IsUserPolicy() )
        {
            Status = (*gpfnMsiIsProductElevated)( _pwszProductId, &bElevated );
    
            if ( Status != ERROR_SUCCESS )
            {
                DebugMsg((DM_WARNING, IDS_ENFORCE_SECURE_FAIL, _pwszDeploymentName, Status));
                return Status;
            }
        }
        else
        {
            bElevated = TRUE;
        }

        if ( bElevated )
            return ERROR_SUCCESS;
    }

    gpEvents->RemoveUnmanaged( this );
    _pManApp->LogonMsgInstall( _pwszDeploymentName );
    Status = Uninstall();
    _pManApp->LogonMsgApplying();

    if ( ERROR_SUCCESS == Status )
    {
        _InstallState = INSTALLSTATE_ABSENT;
        *pbDidUninstall = TRUE;
    }
    else
    {
        DebugMsg((DM_WARNING, IDS_ENFORCE_SECURE_FAIL, _pwszDeploymentName, Status));
    }

    return Status;
}

BOOL
CAppInfo::RequiresUnmanagedRemoval()
{
    BOOL bRequiresUnmanagedRemoval = FALSE;
    
    if ( _pManApp->ARPList() )
    {
        return FALSE;
    }

    //
    // We remove unmanaged installs as a security precaution to
    // prevent elevation of privileges --
    // this means that we do not need to do it for machine assigned apps
    // or per-user apps for admins, since since system and admins
    // already have the highest privileges
    //
    // Note that we could do this for all apps (whether or not they 
    // are machine assigned or user assigned / published to an admin),
    // but the unmanaged removal is a less enjoyable user experience,
    // so we only want to do this in the case where it is required --
    // the per-user, non admin case
    //

    //
    // Verify that this is a per-user app
    //
    if ( _pManApp->UserToken() )
    {
        //
        // If this user is not an admin, we may require
        // the removal of an unmanaged install of this app
        // if one exists
        //
        if ( ! IsMemberOfAdminGroup( _pManApp->UserToken() ) )
        {
            BOOL  bIsProductElevated = FALSE;
            DWORD StatusElevated;

            //
            // The last check -- is this app present as an elevated install?  If not,
            // we should require its uninstall.  Elevated apps were placed here by some
            // admin user, so we do not consider these a threat to the system.
            //
            // Note that this call requires that the caller is impersonating
            //
            StatusElevated = gpfnMsiIsProductElevated( _pwszProductId, &bIsProductElevated );

            //
            // If this unmanaged install is not elevated, or if we were unable to determine whether
            // or not it was elevated, we will require that the application is removed if it
            // exists on the machine
            //
            if ( ( ERROR_SUCCESS != StatusElevated ) ||
                ! bIsProductElevated )
            {
                bRequiresUnmanagedRemoval = TRUE;
            }
        }
    }

    return bRequiresUnmanagedRemoval;
}

void
CAppInfo::RollbackUpgrades()
{
    DWORD   Status;

    for ( DWORD n = 0; n < _Upgrades; n++ )
    {
        Status = ERROR_SUCCESS;

        if ( ! _pUpgrades[n].pBaseApp || ! (_pUpgrades[n].Flags & UPGRADE_OVER) )
            continue;

        // Skip it if the app didn't exist here to begin with.
        if ( ! (_pUpgrades[n].pBaseApp->_State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED)) )
            continue;

        if ( _Status != ERROR_SUCCESS )
            Status = _Status;
        else
            Status = _pUpgrades[n].pBaseApp->_Status;

        gpEvents->UpgradeAbort( Status, this, _pUpgrades[n].pBaseApp, ERROR_SUCCESS == _Status );

        // Re-apply any app which was successfully removed.
        if ( ERROR_SUCCESS == _pUpgrades[n].pBaseApp->_Status )
        {
            DWORD ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS;
            DWORD AssignStatus;

            if ( _pUpgrades[n].pBaseApp->_State & APPSTATE_ASSIGNED )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;

            AssignStatus = _pUpgrades[n].pBaseApp->Assign( ScriptFlags, TRUE, TRUE );

            //
            // Here we are checking for any assigned apps which are configured for 
            // default install.  If such an app was previously in an install state
            // before the upgrade attempt, then we put it back into this state by 
            // doing a default install again.
            //
            if ( (ERROR_SUCCESS == AssignStatus) &&
                 (! _pManApp->IsUserPolicy() || (_pUpgrades[n].pBaseApp->_State & APPSTATE_INSTALL)) &&
                 (AppPresent(_pUpgrades[n].pBaseApp->_InstallState) && (_pUpgrades[n].pBaseApp->_InstallState != INSTALLSTATE_ADVERTISED)) )
            {
                (void) _pUpgrades[n].pBaseApp->Install();
            }

            if ( ERROR_SUCCESS == AssignStatus )
            {
                _pUpgrades[n].pBaseApp->_bRollback = TRUE;
            }
        }
    }

    if ( (_State & APPSTATE_SCRIPT_NOT_EXISTED) && (_State & APPSTATE_SCRIPT_PRESENT) && _pwszLocalScriptPath )
    {
        //
        // Remove the local script for the upgrade app since this app is not currently applied --
        // we need to revert since the user does not have rights in this directory.
        // 

        _pManApp->Revert();     

        DeleteFile( _pwszLocalScriptPath );

        _pManApp->Impersonate();
    }
}

BOOL
CAppInfo::CopyToApplicationInfo(
    APPLICATION_INFO * pApplicationInfo
    )
{
    GuidToString( _DeploymentId, &pApplicationInfo->pwszDeploymentId );
    pApplicationInfo->pwszDeploymentName = StringDuplicate( _pwszDeploymentName );
    pApplicationInfo->pwszGPOName = StringDuplicate( _pwszGPOName );
    pApplicationInfo->pwszProductCode = StringDuplicate( _pwszProductId );
    pApplicationInfo->pwszDescriptor = 0;
    pApplicationInfo->pwszSetupCommand = 0;
    pApplicationInfo->Flags = 0;

    if ( INSTALLUILEVEL_FULL == _InstallUILevel )
        pApplicationInfo->Flags = APPINFOFLAG_FULLUI;
    else
        pApplicationInfo->Flags = APPINFOFLAG_BASICUI;

    if ( _State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED) )
        pApplicationInfo->Flags |= APPINFOFLAG_ALREADYMANAGED;

    if ( ACTION_UNINSTALL == _Action )
        pApplicationInfo->Flags |= APPINFOFLAG_UNINSTALL;
    else if ( ACTION_ORPHAN == _Action )
        pApplicationInfo->Flags |= APPINFOFLAG_ORPHAN;

    if ( ! pApplicationInfo->pwszDeploymentId ||
         ! pApplicationInfo->pwszDeploymentName ||
         ! pApplicationInfo->pwszGPOName ||
         ! pApplicationInfo->pwszProductCode )
        return FALSE;

    return TRUE;
}

void
CAppInfo::AddToOverrideList(
    GUID * pDeploymentId
    )
{
    GUID * pOldList;

    if ( _pManApp->ARPList() )
        return;

    pOldList = _pOverrides;

    _pOverrides = new GUID[_Overrides+1];
    if ( ! _pOverrides )
    {
        _pOverrides = pOldList;
        return;
    }

    if ( _Overrides > 0 )
    {
        memcpy( _pOverrides, pOldList, _Overrides * sizeof(GUID) );
        delete pOldList;
    }

    memcpy( &_pOverrides[_Overrides++], pDeploymentId, sizeof(GUID) );
}

DWORD
CallMsiConfigureProduct(
    WCHAR *         pwszProduct,
    int             InstallLevel,
    INSTALLSTATE    InstallState,
    WCHAR *         pwszCommandLine
    )
{
    DWORD   Status;

    Status = (*gpfnMsiConfigureProductEx)( pwszProduct, InstallLevel, InstallState, pwszCommandLine );

    REMAP_DARWIN_STATUS( Status );

    return Status;
}

DWORD
CallMsiReinstallProduct(
    WCHAR * pwszProduct
    )
{
    DWORD   Status;

    Status = (*gpfnMsiReinstallProduct)(
                pwszProduct,
                REINSTALLMODE_FILEOLDERVERSION | REINSTALLMODE_PACKAGE | REINSTALLMODE_MACHINEDATA | REINSTALLMODE_USERDATA | REINSTALLMODE_SHORTCUT );

    REMAP_DARWIN_STATUS( Status );

    return Status;
}

DWORD
CallMsiAdvertiseScript(
    WCHAR *         pwszScriptFile,
    DWORD           Flags,
    PHKEY           phkClasses,
    BOOL            bRemoveItems
    )
{
    return (*gpfnMsiAdvertiseScript)( pwszScriptFile, Flags, phkClasses, bRemoveItems );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\cstore\user.cxx ===
//
//  Author: DebiM
//  Date:   September 1996
//
//  File:   csuser.cxx
//
//      Maintains a list of class containers per User SID.
//      Looks up this list for every IClassAccess call from OLE32/SCM.
//
//
//---------------------------------------------------------------------

#include "cstore.hxx"

//
// Link list pointer for Class Containers Seen
//
extern CLASSCONTAINER *gpContainerHead;

//
// Link list pointer for User Profiles Seen
//
extern USERPROFILE *gpUserHead;


// Initialzed in InitializeClassStore at startup

extern CRITICAL_SECTION    ClassStoreBindList;

//-------------------------------------------------------------------------
//
// OpenUserRegKey
//
//  Opens a key under a user's HKEY_CLASSES_ROOT registry key.  On NT5
//  HKCR is equivalent to HKEY_USERS\{sid string}\Software\Classes.
//
//  A SID string is used to create
//  the proper registry key name to open.
//
//-------------------------------------------------------------------------
DWORD
OpenUserRegKey(
               IN  PSID        pSid,
               IN  WCHAR *     pwszSubKey,
               OUT HKEY *      phKey
               )
{
    UNICODE_STRING  UnicodeString;
    WCHAR *         pwszKey;
    DWORD           AllocSize;
    NTSTATUS        Status;
    
    UnicodeString.Length = UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = 0;
    
    Status = RtlConvertSidToUnicodeString(
        &UnicodeString,
        pSid,
        (BOOLEAN)TRUE // Allocate
        );
    
    //
    // Don't return a raw NT status code.  This is the only possible error
    // condition presuming our sid is valid.
    //
    if ( Status != STATUS_SUCCESS )
        return ERROR_OUTOFMEMORY;
    
    //
    // Your friendly reminder, unicode string length is in bytes and doesn't include
    // null terminator, if any.
    // Add byte for '\\' and end null.
    //
    AllocSize = UnicodeString.Length + ((1 + lstrlen(pwszSubKey) + 1) * sizeof(WCHAR));
    pwszKey = (WCHAR *) alloca( AllocSize );
    
    if ( pwszKey )
    {
        memcpy( pwszKey, UnicodeString.Buffer, UnicodeString.Length );
        pwszKey[UnicodeString.Length / 2] = L'\\';
        lstrcpyW( &pwszKey[(UnicodeString.Length / 2) + 1], pwszSubKey );
    }
    
    RtlFreeUnicodeString( &UnicodeString );
    
    if ( ! pwszKey )
        return ERROR_OUTOFMEMORY;
    
    Status = RegOpenKeyEx(
        HKEY_USERS,
        pwszKey,
        0,
        KEY_READ,
        phKey );
        
    return Status;
}

//
// GetUserSid
// ----------
//
//  Synopsis:       return the user SID of the caller.
//
//  Arguments:      &PSID       -       Where to store the caller's PSID
//
//  Returns:        HRESULT     -       S_OK if successful
//                                      E_FAIL otherwise
//
SID     LocalSystemSid = { SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };


HRESULT GetUserSid(PSID *ppUserSid, UINT *pCallType)
{
    BYTE            achBuffer[100];
    PTOKEN_USER     pUser = (PTOKEN_USER) &achBuffer;
    PSID            pSid;
    DWORD           dwBytesRequired;
    BOOL            fAllocatedBuffer = FALSE;
    HRESULT         hr = S_OK;
    HANDLE          hUserToken = NULL;
    BOOL            fImpersonated = TRUE;
    
    
    *pCallType = CS_CALL_USERPROCESS;
    
    // Initialize
    *ppUserSid = NULL;
    
    dwBytesRequired = 0;

    // Get caller's token while impersonating
    
    if (!OpenThreadToken(GetCurrentThread(),
        TOKEN_DUPLICATE | TOKEN_QUERY,
        TRUE,
        &hUserToken))
    {
        fImpersonated = FALSE;
        if (ERROR_NO_TOKEN != GetLastError())
            return HRESULT_FROM_WIN32(GetLastError());
        
        if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_DUPLICATE | TOKEN_QUERY,
            &hUserToken))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    
    if (SUCCEEDED(hr))
    {
        if (!GetTokenInformation(
            hUserToken,                // Handle
            TokenUser,                 // TokenInformationClass
            pUser,                     // TokenInformation
            sizeof(achBuffer),         // TokenInformationLength
            &dwBytesRequired           // ReturnLength
            ))
        {
            
            //
            // Need to handle the case of insufficient buffer size.
            //
            
            if (sizeof(achBuffer) >= dwBytesRequired)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            
            
            if (SUCCEEDED(hr))
            {
                //
                // Allocate space for the user info
                //
                
                pUser = (PTOKEN_USER) CsMemAlloc(dwBytesRequired);
                if (pUser == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            
            if (SUCCEEDED(hr))
            {
                fAllocatedBuffer = TRUE;
                
                //
                // Read in the UserInfo
                //
                
                
                if (!GetTokenInformation(
                    hUserToken,                // Handle
                    TokenUser,                 // TokenInformationClass
                    pUser,                     // TokenInformation
                    dwBytesRequired,           // TokenInformationLength
                    &dwBytesRequired           // ReturnLength
                    ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
        
    }
    
    if (hUserToken)
    {
        CloseHandle( hUserToken );
        hUserToken = NULL;
    }
    
    if (SUCCEEDED(hr))
    {
        
        //
        // Distinguish between
        //            a) LOCAL_SYSTEM,
        //            b) Impersonated Call from a LOCAL_SYSTEM
        // and        c) In_proc call from a user process
        //
        // For case (c) make the SID null.
        //
        
        if (EqualSid(pUser->User.Sid, &LocalSystemSid))
        {
            *pCallType = CS_CALL_LOCALSYSTEM;
        }
        else
        {
            if (fImpersonated)
            {
                *pCallType = CS_CALL_IMPERSONATED;
            }
            else
            {
                *pCallType = CS_CALL_USERPROCESS;
            }
        }
        
        // Alloc buffer for copy of SID
        
        dwBytesRequired = GetLengthSid(pUser->User.Sid);
        *ppUserSid = CsMemAlloc(dwBytesRequired);
        if (*ppUserSid == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Copy SID
            
            if (!CopySid(dwBytesRequired, *ppUserSid, pUser->User.Sid))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CsMemFree(*ppUserSid);
                *ppUserSid = NULL;
            }
        }
    }
    
    if (fAllocatedBuffer == TRUE)
    {
        CsMemFree(pUser);
    }
    
    return hr;
}

PCLASSCONTAINER
GetClassStore (LPOLESTR pszPath)
{
    
    PCLASSCONTAINER pCS = NULL;
    
    pCS = (CLASSCONTAINER *) CsMemAlloc (sizeof(CLASSCONTAINER));
    if (!pCS)
        return NULL;

    pCS->pszClassStorePath = (LPOLESTR)CsMemAlloc
        (sizeof(WCHAR) * (wcslen(pszPath)+1));
    if (!(pCS->pszClassStorePath))
    {
        CsMemFree(pCS);
        return NULL;
    }

    wcscpy (pCS->pszClassStorePath, pszPath);
    
    return pCS;
}


extern WCHAR pwszDebugPath [];
extern BOOL  fDebugPath;

//
// GetPerUserClassStore
// ---------------------
//
//  Synopsis:       Gets the ADT Class Store List from the
//                  per-user Registry.
//                  Returns error if none defined,
//
//  Arguments:
//                  [out] ppStoreList : where to store list of class container
//                                      serial numbers
//                  [out] pcStores    : where to store number of class containers
//
//  Returns:        S_OK,
//
//  History:        Changed by (DebiM)
//                  2/24/97
//                  return a NULL list of Class Stores when none defined.
//

HRESULT GetPerUserClassStore(
                             LPOLESTR  pszClassStorePath,
                             PSID      pSid,
                             UINT      CallType,
                             LPOLESTR  **ppStoreList,
                             DWORD     *pcStores)
                             
{
    LONG    lErrorCode;
    DWORD    dwDataLen = 0;
    DWORD    dwType;
    HKEY    hKey = NULL;
    HRESULT hr = S_OK;
    LPOLESTR pszPath, pszStart;
    LPOLESTR *ppszPath;
    LPWSTR pszPathList=NULL;
    
    *pcStores = 0;
    *ppStoreList = NULL;
    
    {
        switch (CallType)
        {
        case CS_CALL_LOCALSYSTEM :

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_MACHINE));
            break;
            
        case CS_CALL_IMPERSONATED :
            
            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_IMPERSONATED));
            break;
            
        case CS_CALL_USERPROCESS :

            CSDBGPrint((DM_WARNING,
                      IDS_CSTORE_USER));
            break;

        default:
            return E_FAIL;
        }
        
        HRESULT hrCSPath;

        if ( ! pszClassStorePath )
        {
            hrCSPath = ReadClassStorePath(
                CallType != CS_CALL_LOCALSYSTEM ? pSid : NULL,
                &pszPathList);
        }
        else
        {
            hrCSPath = S_OK;

            pszPathList = pszClassStorePath;

            if ( ! *pszPathList )
            {
                hrCSPath = E_FAIL;
            }
        }

        if ( FAILED(hrCSPath) )
        {
            // treat as NULL list of Class Stores
            if ( ! pszClassStorePath )
            {
                delete [] pszPathList;
            }

            return S_OK;
        }
    }
 
    // counting the number of ';'s and the number of class stores.
    // assuming that it ends with a ;

    DWORD cTentativeStores = 0;

    for (pszPath = pszPathList, cTentativeStores = 0;
            (pszPath = wcschr(pszPath, L';'));)
    {
        ++(cTentativeStores); pszPath++;
    }
    
    ++(cTentativeStores);

    pszPath = pszPathList;
    
    ppszPath = *ppStoreList = (LPOLESTR *) CsMemAlloc
        (sizeof(LPOLESTR) * (cTentativeStores));
    
    if (*ppStoreList == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    memset (*ppStoreList, 0, sizeof(LPOLESTR) * (cTentativeStores));

    //
    // Parse the list to separate different class containers
    //

    while (*pszPath)
    {
        while (*pszPath == L' ')
            ++pszPath;
        pszStart = pszPath;
        
        if (!*pszPath)
            break;
        if (*pszPath == L';')
        {
            ++pszPath;
            continue;
        }
        
        while (*pszPath && (*pszPath != L';'))
            ++pszPath;
        
        //
        // got one. save it.
        //
        *ppszPath = (LPOLESTR) CsMemAlloc (sizeof(WCHAR) * (ULONG) (pszPath - pszStart + 1));

        if (!(*ppszPath))
            ERROR_ON_FAILURE(hr=E_OUTOFMEMORY);

        memcpy (*ppszPath, pszStart, sizeof (WCHAR) * (ULONG) (pszPath - pszStart));
        *((*ppszPath)+(pszPath - pszStart)) = NULL;

        (ppszPath)++;
        
        if (*pszPath == L';')
        {
            ++pszPath;
        }

        (*pcStores)++;

        if ((*pcStores) == cTentativeStores)
            break;
    }
    
    if (!pszClassStorePath)
    {
        delete [] pszPathList;
    }

    return S_OK;

Error_Cleanup:
    DWORD i;
    for (i = 0; i < (*pcStores); i++) 
    {
        if (ppszPath[i])
            CsMemFree(ppszPath[i]);
    }
    CsMemFree(ppszPath);
        
    ppStoreList = NULL;

    (*pcStores) = 0;
    if (pszPathList && !pszClassStorePath)
        CsMemFree(pszPathList);

    return hr;
}


//
// GetUserClassStores
// ------------------
//
//  Synopsis:       This routine reads the Class Store list and parses it.
//                  If it has prior knowledge it reurns the parsed list.
//  Arguments:
//                  [out]  pcStores: Number of Class Stores
//                  [out]  ppStoreIdList: Class Store Id List,
//
//  Returns:        S_OK
//                  May return a NULL list of Class Stores.
//
//


HRESULT GetUserClassStores(
                           LPOLESTR              pszClassStorePath,
                           PCLASSCONTAINER     **ppStoreList,
                           DWORD                *pcStores,
                           BOOL                 *pfCache,
                           PSID                 *ppUserSid)
{
    HRESULT          hr = S_OK;
    UINT             CallType;
    PCLASSCONTAINER *pList = NULL;
    DWORD            i;

    //
    // Get the SID of the calling process
    //
    
    hr = GetUserSid(ppUserSid, &CallType);

    if (FAILED(hr))
    {
        *ppUserSid = NULL;
        hr = S_OK;
    }

    *pfCache = (CallType == CS_CALL_IMPERSONATED);

    EnterCriticalSection (&ClassStoreBindList);
    
    //
    // Get the Class Store List
    //
    LPOLESTR *ppStoreNameList = NULL;
    
    hr = GetPerUserClassStore(
        pszClassStorePath,
        *ppUserSid, CallType, &ppStoreNameList, pcStores);
    
    //
    // Note that the above may return a NULL list of Class Stores
    //

    CSDBGPrint((DM_WARNING,
              IDS_CSTORE_STORE_COUNT,
              (*pcStores)));
    
    if (SUCCEEDED(hr)) 
    {
        *ppStoreList = pList = (PCLASSCONTAINER *)
                        CsMemAlloc (sizeof(PCLASSCONTAINER) * (*pcStores));

        if (!(*ppStoreList))
            hr = E_OUTOFMEMORY;
        else
            memset(pList, 0, sizeof(PCLASSCONTAINER) * (*pcStores));
    }

    if (SUCCEEDED(hr))
    {    
        for (i=0; i < (*pcStores); i++)
        {
            *pList = GetClassStore (ppStoreNameList[i]);
            if (!(*pList))
            {
                // free all the ones that have been allocated.
                DWORD j;
                for (j = 0; j < (*pcStores); j++)
                    if (*pList)
                    {
                        if ((*pList)->pszClassStorePath)
                            CsMemFree((*pList)->pszClassStorePath);
                        CsMemFree(*pList);    
                    }

                hr = E_OUTOFMEMORY;
                (*pcStores) = 0;
                break;
            }

            pList++;
        }
    }

    if (ppStoreNameList)
    {
        for (i=0; i < (*pcStores); ++i)
        {
            if (ppStoreNameList[i])
                CsMemFree (ppStoreNameList[i]);
        }
    }
    
    if (ppStoreNameList)
        CsMemFree (ppStoreNameList);
    
    LeaveCriticalSection (&ClassStoreBindList);
    
    return hr;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\applist.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Applist.cxx
//
//*************************************************************

#include "appmgext.hxx"


//
// CAppList
//

CAppList::CAppList(
    CManagedAppProcessor * pManApp,
    CRsopAppContext *      pRsopContext ) :
    _pManApp( pManApp ),
    _bRsopInitialized( FALSE ),
    _hrRsopInit( E_FAIL ),
    _pRsopContext( pRsopContext )
{}


CAppList::~CAppList()
{
    CAppInfo * pAppInfo;

    Reset();

    while ( pAppInfo = (CAppInfo *) GetCurrentItem() )
    {
        MoveNext();

        pAppInfo->Remove();
        delete pAppInfo;
    }

    ResetEnd();
}

DWORD
CAppList::SetAppActions()
{
    CAppInfo *  pAppInfo;
    DWORD       Pass;
    DWORD       Status;

    for ( Pass = 0; Pass <= 5; Pass++ )
    {
        Reset();

        for (;;)
        {
            pAppInfo = (CAppInfo *) GetCurrentItem();

            if ( ! pAppInfo )
                break;

            //
            // Apps get applied from lowest priority to highest priority.
            // Thus if one app fails to apply there is nothing of interest that
            // we can really do.  We don't know which lower priority apps
            // may need to be "undone", and we shouldn't abort and thereby
            // prevent higher priority apps from being processed.
            //
            // Therefore, other than logging events, we ignore any errors in
            // the processing and continuing applying all apps.
            //

            switch ( Pass )
            {
            case 0 :
                Status = pAppInfo->InitializePass0();
                if ( Status != ERROR_SUCCESS )
                    return Status;
                break;
            case 1 :
                pAppInfo->SetActionPass1();
                break;
            case 2 :
                pAppInfo->SetActionPass2();
                break;
            case 3 :
                pAppInfo->SetActionPass3();
                break;
            case 4 :
                pAppInfo->SetActionPass4();
                break;
            case 5 :
                if ( pAppInfo->_Status != ERROR_SUCCESS )
                    return pAppInfo->_Status;
                break;
            }

            MoveNext();
        }

        ResetEnd();
    }

    return ERROR_SUCCESS;
}

DWORD
CAppList::ProcessPolicy()
{
    CAppInfo *  pAppInfo;
    DWORD       Pass;
    DWORD       Status;
    DWORD       FinalStatus;
    HRESULT     hr;

    FinalStatus = ERROR_SUCCESS;

    Status = _pManApp->Impersonate();

    if ( ERROR_SUCCESS == Status )
        Status = SetAppActions();

    if ( Status != ERROR_SUCCESS )
    {
        //
        // Ensure that we log an event in this case so that RSoP
        // failed view at the extension level has enough information
        // to allow the administrator to diagnose the problem
        //
        gpEvents->PolicyAbort();

        _pManApp->Revert();

        _pManApp->GetRsopContext()->SetPolicyAborted( Status );

        return Status;
    }

    if ( _pManApp->GetRsopContext()->IsPlanningModeEnabled() )
    {
        return Status;
    }

    for ( Pass = 0; Pass <= 2; Pass++ )
    {
        for ( Reset();;MoveNext() )
        {
            pAppInfo = (CAppInfo *) GetCurrentItem();

            if ( ! pAppInfo )
                break;

            switch ( Pass )
            {
            case 0 :
                Status = pAppInfo->ProcessUnapplyActions();
                break;
            case 1 :
                Status = pAppInfo->ProcessApplyActions();
                break;
            case 2 :
                if ( _pRsopContext->IsRsopEnabled() && _pRsopContext->IsDiagnosticModeEnabled() )
                    Status = pAppInfo->ProcessTransformConflicts();
                break;
            }

            if ( (FinalStatus == ERROR_SUCCESS) && (Status != ERROR_SUCCESS) )
                FinalStatus = Status;

            //
            // If we are returning an error of some sort, we should force a synchronous
            // refresh if we are not already returning the error to request one.  This is 
            // needed because some errors require a sync refresh to fix (such as
            // install / uninstall errors), and gp will not give us a sync refresh
            // unless we ask for it. 
            //
            if ( ! _pManApp->NoChanges() &&
                 ( ERROR_SUCCESS != FinalStatus ) &&
                 ( ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED != FinalStatus ) )
            {
                _pManApp->Revert();

                (void) ForceSynchronousRefresh( _pManApp->UserToken() );

                _pManApp->Impersonate();
            }
        }

        ResetEnd();
    }

    _pManApp->Revert();

    return FinalStatus;
}

DWORD
CAppList::ProcessARPList()
{
    DWORD   Status;

    Status = _pManApp->Impersonate();

    if ( ERROR_SUCCESS == Status )
        Status = SetAppActions();

    _pManApp->Revert();

    return Status;
}

DWORD
CAppList::Count(
    DWORD   Flags
    )
{
    CAppInfo *  pAppInfo;
    DWORD       Count;

    Count = 0;

    Reset();

    for ( ;; )
    {
        pAppInfo = (CAppInfo *) GetCurrentItem();

        if ( ! pAppInfo )
            break;

        if ( pAppInfo->_ActFlags & Flags )
            Count++;

        MoveNext();
    }

    ResetEnd();

    return Count;
}

CAppInfo *
CAppList::Find(
    GUID    DeploymentId
    )
{
    CAppInfo *  pAppInfo;

    Reset();

    for (;;)
    {
        pAppInfo = (CAppInfo *) GetCurrentItem();

        if ( ! pAppInfo )
            break;

        if ( memcmp( &pAppInfo->_DeploymentId, &DeploymentId, sizeof(GUID) ) == 0 )
            break;

        MoveNext();
    }

    ResetEnd();

    return pAppInfo;
}

HRESULT
CAppList::WriteLog( DWORD dwFilter )
{
    CAppInfo *  pAppInfo;
    DWORD       Status;
    HRESULT     hr;

    hr = InitRsopLog();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( ( CRsopAppContext::POLICY_REFRESH == _pRsopContext->GetContext() ) &&
         _pRsopContext->IsDiagnosticModeEnabled() && ! _pManApp->IsRemovingPolicies() )
    {
        hr = PurgeEntries();
    }

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    Reset();

    for (;;)
    {
        BOOL bLogApp;

        pAppInfo = (CAppInfo *) GetCurrentItem();

        if ( ! pAppInfo )
            break;

        //
        // Check to see if this app is applied to the user and should be logged
        //
        bLogApp = ( RSOP_FILTER_ALL == dwFilter ) ||
          ( ( ACTION_UNINSTALL == pAppInfo->Action() ) || ( ACTION_ORPHAN == pAppInfo->Action() ) );

        //
        // Check to see if this app would have been in the ARP list if not for the
        // fact that the administrator chose to conceal it
        //
        if ( CRsopAppContext::ARPLIST == _pRsopContext->GetContext() )
        {
            if ( ( ACTION_NONE == pAppInfo->Action() ) &&
                 ( (pAppInfo->_ActFlags & (ACTFLG_Assigned | ACTFLG_Published) ) && 
                   !(pAppInfo->_ActFlags & ACTFLG_UserInstall) ) )
            {
                bLogApp = TRUE;

                pAppInfo->SetAction(
                    ACTION_INSTALL,
                    0,
                    NULL);
            }
        }

        if ( bLogApp )
        {
            hr = WriteAppToRsopLog( pAppInfo );

            if (FAILED(hr))
            {
                break;
            }
        }

        MoveNext();
    }

    ResetEnd();

    return hr;
}

HRESULT
CAppList::WriteAppToRsopLog( CAppInfo* pAppInfo )
{
    HRESULT   hr;
    CConflict WinningConflict( pAppInfo );

    //
    // If this is a rolled-back upgrade, the instance
    // is already written and we do not need to do anything
    //
    if ( pAppInfo->_bRollback )
    {
        return S_OK;
    }

    //
    // Do not log entries for applications that will be removed
    // in the next sync refresh
    //
    if ( ( ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == pAppInfo->_Status ) &&
         ( ACTION_APPLY != pAppInfo->_Action ) && ( ACTION_INSTALL != pAppInfo->_Action ) &&
         ( ACTION_REINSTALL != pAppInfo->_Action ) )
    {
        return S_OK;
    }

    hr = InitRsopLog();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // If this app failed to be applied, we must log it anyway
    //
    if ( pAppInfo->_StatusList.GetCurrentItem() )
    {
        if ( ACTION_NONE == pAppInfo->Action() )
        {
            pAppInfo->SetAction(
                ACTION_APPLY,
                pAppInfo->_dwApplyCause,
                NULL);
        }
    }
    else if ( _pRsopContext->HasPolicyAborted() )
    {
        //
        // If policy aborted before even trying to apply the app
        // then we shouldn't log this setting unless it has a failure -- 
        // apps without failures haven't been applied, and apps with
        // failures are known to not apply, so we can safely log those
        //
        return S_OK;
    }

    switch ( pAppInfo->GetRsopEntryType() )
    {
    case APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE:

        WCHAR* wszCriteria;
       
        wszCriteria = pAppInfo->GetRsopAppCriteria();

        hr = ClearLog( wszCriteria, TRUE );

        delete [] wszCriteria;

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // In planning mode, we only apply published apps if they upgrade
        // an assigned app
        //
        if ( _pRsopContext->IsPlanningModeEnabled() )
        {
            if ( ( ACTFLG_Published & pAppInfo->_ActFlags ) && ! pAppInfo->_bSupersedesAssigned )
            {
                break;
            }
        }
        
        //
        // Fall through to the next case
        //

    case APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM:

        //
        // In the arplist case, we require the action
        // set to ACTION_INSTALL in order to log the app
        //
        if ( _pManApp->ARPList() && 
             ( ACTION_INSTALL != pAppInfo->Action() ) )
        {
            break;
        }

        //
        // If this is a winning application, create a new entry for the winner
        // and then log its conflicts
        //
        if ( ! pAppInfo->IsSuperseded() )
        {
            WCHAR wszDeploymentId[ MAX_SZGUID_LEN ];

            pAppInfo->GetDeploymentId( wszDeploymentId );

            hr = WinningConflict.SetConflictId( wszDeploymentId );

            if ( SUCCEEDED(hr) )
            {
                hr = WriteNewRecord ( &WinningConflict );
            }

            if (FAILED(hr))
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_FAIL, hr));
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                (void) WinningConflict.LogFailure();
            }

            (void) WriteConflicts ( pAppInfo );
        }
        break;

    case APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE:

        BOOL        bDeleteInstalledEntry;
        CAppStatus* pCurrentStatus;

        bDeleteInstalledEntry = TRUE;

        pCurrentStatus = (CAppStatus*) pAppInfo->_StatusList.GetCurrentItem();

        //
        // Do not delete the installed entry if it was never 
        // successfully removed
        //
        if ( pCurrentStatus && 
             ( RSOPFailed == pCurrentStatus->_SettingStatus ) )
        {
            bDeleteInstalledEntry = FALSE;
        }
        
        //
        // For removed applications, we do not create a new entry,
        // just change the existing entry to indicate that
        // it has been removed
        //
        hr = MarkRSOPEntryAsRemoved(
            pAppInfo,
            bDeleteInstalledEntry);

        if ( SUCCEEDED( hr ) )
        {
            pAppInfo->_bRemovalLogged = TRUE;
        }

        break;

    default:
        break;
    }

    return hr;
}


HRESULT
CAppList::WriteConflicts( CAppInfo* pAppInfo )
{
    HRESULT       hr;
    CConflictList Conflicts;
    CConflict*    pCurrentConflict;

    hr = pAppInfo->GetConflictTable()->GenerateResultantConflictList( &Conflicts );

    if (SUCCEEDED(hr))
    {
        Conflicts.Reset();

        while ( pCurrentConflict = (CConflict*) Conflicts.GetCurrentItem() )
        {
            WCHAR wszDeploymentId[ MAX_SZGUID_LEN ];

            pAppInfo->GetDeploymentId( wszDeploymentId );

            hr = pCurrentConflict->SetConflictId( wszDeploymentId );

            if ( FAILED(hr) )
            {
                break;
            }

            HRESULT hrWrite;

            if ( ! pCurrentConflict->GetApp()->IsLocal() )
            {
                hrWrite = WriteNewRecord( pCurrentConflict );
            }
            else
            {
                hrWrite = OpenExistingRecord( pCurrentConflict );

                if ( SUCCEEDED( hrWrite ) )
                {
                    hrWrite = pCurrentConflict->Write();
                }

                if ( SUCCEEDED( hrWrite ) )
                {
                    hrWrite = pCurrentConflict->GetApp()->ClearRemovalProperties( pCurrentConflict );
                }

                if ( SUCCEEDED( hrWrite ) )
                {
                    hrWrite = CommitRecord( pCurrentConflict );
                }
            }

            if ( SUCCEEDED( hrWrite ) )
            {
                (void) DeleteStatusRecords( pCurrentConflict );
            }

            if (FAILED(hrWrite))
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_FAIL, hrWrite));
            }

            Conflicts.MoveNext();
        }
    }

    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, IDS_RSOP_CONFLICTS_FAIL, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, hr));
    }

    return hr;
}


HRESULT CAppList::InitRsopLog()
{
    if ( _bRsopInitialized )
    {
        return _hrRsopInit;
    }

    _bRsopInitialized = TRUE;

    _hrRsopInit = InitLog(
        _pRsopContext,
        RSOP_MANAGED_SOFTWARE_APPLICATION);

    if (FAILED(_hrRsopInit))
    {
        DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_INIT_FAIL, _hrRsopInit));
        return _hrRsopInit;
    }

    if ( _pRsopContext->Transition() )
    {
        _hrRsopInit = ClearLog( NULL, TRUE );
    }
    else if ( ! _pRsopContext->ForcedRefresh() )
    {
        BOOL bPolicy;

        bPolicy = FALSE;

        //
        // In the forced refresh case, we need to preserve the
        // state of policy since it actually has not changed,
        // so we skip the purge below
        //

        //
        // In the policy refresh case, we need to clear everything
        // that does not apply to the user as well as removal entries
        //
        switch ( _pRsopContext->GetContext() )
        {
        case CRsopAppContext::POLICY_REFRESH:

            bPolicy = TRUE;

            if ( ! _pRsopContext->PurgeRemovalEntries() )
            {
                break;
            }

            _pRsopContext->ResetRemovalPurge();

            //
            // Purposefully fall through
            //

        case CRsopAppContext::ARPLIST:

            _hrRsopInit = ClearLog( GetRsopListCriteria(), bPolicy );

            if ( FAILED( _hrRsopInit ) )
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_INIT_FAIL, _hrRsopInit));
            }
            break;
            
        default:
            break;
        }
    }

    return _hrRsopInit;
}

HRESULT
CAppList::PurgeEntries()
{
    HRESULT hr;

    hr = GetEnum( RSOP_PURGE_QUERY );

    if ( SUCCEEDED(hr) )
    {
        HRESULT       hrEnum;

        hrEnum = S_OK;

        for (;;)
        {
            CPolicyRecord CurrentApplication;
            LONG          EntryType;

            hrEnum = GetNextRecord( &CurrentApplication );

            if ( S_OK != hrEnum )
            {
                if ( FAILED(hrEnum) )
                {
                    hr = hrEnum;
                }

                break;
            }

            GUID      DeploymentId;
            WCHAR     wszDeploymentId[ MAX_SZGUID_LEN ];
            LONG      cchSize;
            CAppInfo* pAppliedApp;

            cchSize = sizeof( wszDeploymentId ) / sizeof( *wszDeploymentId );

            hrEnum = CurrentApplication.GetValue(
                RSOP_ATTRIBUTE_ID,
                wszDeploymentId,
                &cchSize);

            if ( FAILED( hrEnum ) )
            {
                break;
            }

            if ( S_OK != hrEnum )
            {
                break;
            }

            StringToGuid( wszDeploymentId, &DeploymentId );
            
            pAppliedApp = Find( DeploymentId );
            
            if ( pAppliedApp )
            {
                if ( pAppliedApp->_State & ( APPSTATE_ASSIGNED | APPSTATE_PUBLISHED ) )
                {
                    if ( ACTFLG_Published & pAppliedApp->_ActFlags )
                    {
                        (void) GetUserApplyCause(
                            &CurrentApplication,
                            pAppliedApp);
                    }

                    continue;
                }
                     
                if ( ( ACTION_NONE != pAppliedApp->Action() ) ||
                     pAppliedApp->_bRollback )
                {
                    continue;
                }
            }

            hrEnum = DeleteRecord( &CurrentApplication, TRUE );
            
            if ( FAILED( hrEnum ) )
            {
                hr = hrEnum;
            }
        }

        FreeEnum();
    }

    return hr;
}

HRESULT
CAppList::GetUserApplyCause(
    CPolicyRecord* pRecord,
    CAppInfo*      pAppInfo
    )
{
    HRESULT hr;
    LONG    ApplyCause;

    hr = pRecord->GetValue( 
        APP_ATTRIBUTE_APPLY_CAUSE,
        &ApplyCause);

    if ( SUCCEEDED( hr) && 
         ( APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE != ApplyCause ) &&
         ! pAppInfo->_wszDemandProp )
    {
        pAppInfo->_dwUserApplyCause = ApplyCause;

        switch ( ApplyCause )
        {
        case APP_ATTRIBUTE_APPLYCAUSE_VALUE_FILEEXT:
            pAppInfo->_wszDemandProp = APP_ATTRIBUTE_ONDEMAND_FILEEXT;
            break;

        case APP_ATTRIBUTE_APPLYCAUSE_VALUE_CLSID:
            pAppInfo->_wszDemandProp = APP_ATTRIBUTE_ONDEMAND_CLSID;
            break;

        case APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROGID:
            pAppInfo->_wszDemandProp = APP_ATTRIBUTE_ONDEMAND_PROGID;
            break;

        default:
            pAppInfo->_wszDemandProp = NULL;
            break;
        }

        if ( pAppInfo->_wszDemandProp && ! pAppInfo->_wszDemandSpec )
        {
            LONG cchSize;

            cchSize = 0;

            hr = pRecord->GetValue(
                pAppInfo->_wszDemandProp,
                pAppInfo->_wszDemandSpec,
                &cchSize);

            if ( S_FALSE == hr )
            {
                pAppInfo->_wszDemandSpec = new WCHAR [ cchSize ];

                if ( pAppInfo->_wszDemandSpec )
                {
                    hr = pRecord->GetValue(
                        pAppInfo->_wszDemandProp,
                        pAppInfo->_wszDemandSpec,
                        &cchSize);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

    }

    return hr;
}


HRESULT CAppList::MarkRSOPEntryAsRemoved(
    CAppInfo* pAppInfo,
    BOOL      bRemoveInstances)
{
    HRESULT hr;
    WCHAR*  wszRemovalCriteria;

    wszRemovalCriteria = NULL;

    DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_INFO, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));

    //
    // If this is a removed app that was reapplied as part of upgrade rollback,
    // we do not want to remove the instances
    //
    if ( pAppInfo->_bRollback )
    {
        bRemoveInstances = FALSE;
    }

    //
    // Set up this list's rsop enumerator to enumerate instances of this application
    //
    hr = FindRsopAppEntry( 
        pAppInfo,
        &wszRemovalCriteria );

    if ( SUCCEEDED( hr ) )
    {
        for (;;)
        {
            CConflict RemovedApplication( pAppInfo );
            LONG      Precedence;

            hr = GetNextRecord( &RemovedApplication );
            
            if ( S_OK != hr )
            {
                break;
            }

            hr = RemovedApplication.GetValue( 
                RSOP_ATTRIBUTE_PRECEDENCE,
                &Precedence);

            if ( FAILED (hr) )
            {
                break;
            }

            //
            // If this is a removal of an assigned application, then we should
            // change the apply cause of the installed application to assigned
            // rather than user
            //
            if ( 1 == Precedence )
            {
                if ( ( pAppInfo->_State & APPSTATE_ASSIGNED ) &&
                     ( CRsopAppContext::REMOVAL == _pRsopContext->GetContext() ) )
                {
                    LONG CurrentApplyCause;
                    LONG CurrentEligibility;

                    //
                    // First, we must find out the current apply cause so
                    // that we can propagate that to the removal entry
                    //
                    hr = RemovedApplication.GetValue( 
                        APP_ATTRIBUTE_APPLY_CAUSE,
                        &CurrentApplyCause);

                    if ( SUCCEEDED(hr) )
                    {
                        hr = RemovedApplication.GetValue( 
                            APP_ATTRIBUTE_ELIGIBILITY,
                            &CurrentEligibility);
                    }
                
                    if ( SUCCEEDED(hr) ) 
                    {
                        //
                        // Now set the current apply cause to assigned
                        //
                        hr = RemovedApplication.SetValue(
                            APP_ATTRIBUTE_APPLY_CAUSE,
                            APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr );

                        if ( SUCCEEDED(hr) )
                        {
                            //
                            // Also set the eligibility to assigned
                            //
                            hr = RemovedApplication.SetValue(
                                APP_ATTRIBUTE_ELIGIBILITY,
                                APP_ATTRIBUTE_ELIGIBILITY_VALUE_ASSIGNED);

                            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ELIGIBILITY, hr );
                        }

                        //
                        // Clear out any attributes that should not be set for applications
                        // applied due to assignment
                        //
                        hr = RemovedApplication.ClearValue(
                            APP_ATTRIBUTE_ONDEMAND_FILEEXT);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_FILEEXT, hr )

                        hr = RemovedApplication.ClearValue(
                            APP_ATTRIBUTE_ONDEMAND_CLSID);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_CLSID, hr )

                        hr = RemovedApplication.ClearValue(
                            APP_ATTRIBUTE_ONDEMAND_PROGID);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ONDEMAND_PROGID, hr )
                    }

                    //
                    // Commit the record for the installed application
                    //
                    if ( SUCCEEDED(hr) )
                    {
                        hr = CommitRecord( &RemovedApplication );
                    }

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Now set the removal entry's install cause to
                        // that of the original install
                        //
                        hr = RemovedApplication.SetValue(
                            APP_ATTRIBUTE_APPLY_CAUSE,
                            CurrentApplyCause);

                        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr );

                        if ( SUCCEEDED(hr) )
                        {
                            //
                            // Also set the eligibility to assigned
                            //
                            hr = RemovedApplication.SetValue(
                                APP_ATTRIBUTE_ELIGIBILITY,
                                CurrentEligibility);
                            
                            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ELIGIBILITY, hr );
                        }
                    }
                }

                //
                // We must mark the highest precedence entry
                // (the currently applied entry) as removed --
                // see if this has the highest precedence (1)
                //
                if ( bRemoveInstances &&
                     ( ( pAppInfo->_State & APPSTATE_PUBLISHED ) || 
                       ( CRsopAppContext::POLICY_REFRESH != _pRsopContext->GetContext() ) ) )
                {
                    hr = DeleteRecord ( &RemovedApplication, TRUE );
                }
                else 
                {
                    hr = DeleteStatusRecords( &RemovedApplication );
                }
                
                if ( SUCCEEDED( hr ) )
                {
                    hr = RemovedApplication.SetValue(
                        APP_ATTRIBUTE_ENTRYTYPE,
                        APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE);

                    REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_ENTRYTYPE, hr );
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = RemovedApplication.SetValue(
                        RSOP_ATTRIBUTE_PRECEDENCE, 
                        0L);

                    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_PRECEDENCE, hr );
                }
                
                if ( SUCCEEDED( hr ) )
                {
                    hr = pAppInfo->WriteRemovalProperties( &RemovedApplication );
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = CommitRecord( &RemovedApplication );

                    if ( SUCCEEDED(hr) )
                    {
                        (void) DeleteStatusRecords( &RemovedApplication );
                        (void) RemovedApplication.LogFailure();
                    }
                }
            }
            else
            {
                hr = DeleteRecord ( &RemovedApplication, TRUE );
            }

            if ( FAILED(hr) )
            {
                break;
            }
        }
    }

    FreeEnum();

    if ( bRemoveInstances &&
         SUCCEEDED(hr) )
    {
        //
        // We've already found the highest precedence entry
        // and copied it as a removal entry --
        // if the caller specified to remove the original
        // instances for this app's conflict id, do so
        //
        hr = ClearLog( wszRemovalCriteria, TRUE );
    }

    delete [] wszRemovalCriteria;

    return hr;
}


HRESULT
CAppList::FindRsopAppEntry( 
    CAppInfo* pAppInfo,
    WCHAR**   ppwszAppCriteria )
{
    HRESULT hr;

    hr = InitRsopLog();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = E_OUTOFMEMORY;

    *ppwszAppCriteria = pAppInfo->GetRsopAppCriteria();

    if ( *ppwszAppCriteria )
    {
        hr = GetEnum( *ppwszAppCriteria );
    }

    if ( FAILED(hr) )
    {
        delete [] *ppwszAppCriteria;
        *ppwszAppCriteria = NULL;
    }

    return hr;
}

WCHAR*
CAppList::GetRsopListCriteria()
{
    WCHAR* wszCriteria;

    switch ( _pRsopContext->GetContext() )
    {
    case CRsopAppContext::ARPLIST:
        wszCriteria = RSOP_ARP_CONTEXT_QUERY;
        break;

    case CRsopAppContext::POLICY_REFRESH:
        wszCriteria = RSOP_POLICY_CONTEXT_QUERY;
        break;

    default:
        ASSERT(FALSE);
        return NULL;
    }

    return wszCriteria;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\apis.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  apis.cxx
//
//*************************************************************

#include "appmgext.hxx"

typedef struct
{
    CManagedAppProcessor *  pManApp;
    CAppInfo *              pAppInfo;
    BOOL                    bUninstallsCompleted;
    CLoadMsi *              pLoadMsi;
    CLoadSfc *              pLoadSfc;
    boolean                 bStatus;
    INT64                   SRSequence;
} APPCONTEXT, * PAPPCONTEXT;

CRITICAL_SECTION  gAppCS;

static BOOL
SetSystemRestorePoint(
    IN  WCHAR * pwszApplicationName,
    IN OUT  PAPPCONTEXT pAppContext
    );

static void
CheckLocalCall(
    IN  handle_t hRpc
    );

WCHAR*
GetGpoNameFromGuid( 
    IN PGROUP_POLICY_OBJECT pGpoList,
    IN GUID* pGpoGuid
    );

DWORD
GetPlatformCompatibleCOMClsCtx( 
    DWORD Architecture,
    DWORD dwClsCtx
    );

void
LogRsopInstallData(
    CManagedAppProcessor* pManApp,
    CAppInfo*             pAppInfo
    );

DWORD
WINAPI
GetManagedAppsProc(
    LPVOID pvArpContext
    );

error_status_t
InstallBegin(
    IN  handle_t            hRpc,
    IN  APPKEY *            pAppType,
    OUT PINSTALLCONTEXT *   ppInstallContext,
    OUT APPLICATION_INFO *  pInstallInfo,
    OUT UNINSTALL_APPS *    pUninstallApps
    )
{
    CManagedAppProcessor * pManApp;
    CAppList        LocalApps( NULL );
    HANDLE          hUserToken;
    HKEY            hkRoot;
    uCLSSPEC        ClassSpec;
    QUERYCONTEXT    QueryContext;
    PACKAGEDISPINFO PackageInfo;
    PAPPCONTEXT     pAppContext;
    GUID            DeploymentId;
    CAppInfo *      pAppInfo;
    CAppInfo *      pUpgradedApp;
    CAppInfo *      pLocalApp;
    WCHAR           wszGuid[40];
    WCHAR           wszProductId[40];
    WCHAR *         pwszDeploymentId;
    DWORD           Size;
    DWORD           UninstallApps;
    DWORD           n;
    DWORD           Status;
    HRESULT         hr;
    BOOL            bEnterCritSec;
    BOOL            bStatus;

    CRsopAppContext RsopContext( CRsopAppContext::INSTALL, NULL, pAppType );
    
    PGROUP_POLICY_OBJECT pGPOList;

    *ppInstallContext = 0;
    memset( pInstallInfo, 0, sizeof(APPLICATION_INFO) );
    memset( pUninstallApps, 0, sizeof(UNINSTALL_APPS) );

    CheckLocalCall( hRpc );

    pManApp = 0;
    pAppInfo = 0;
    hUserToken = 0;
    hkRoot = 0;
    pAppContext = 0;

    bEnterCritSec = FALSE;

    pGPOList = NULL;

    Status = RpcImpersonateClient( NULL );

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( ERROR_SUCCESS == Status )
    {
        bStatus = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                        TRUE,
                        &hUserToken );

        if ( ! bStatus )
            Status = GetLastError();
    }

    if ( ERROR_SUCCESS == Status )
        Status = RegOpenCurrentUser( GENERIC_ALL, &hkRoot );

    if ( Status != ERROR_SUCCESS )
    {
        CloseHandle( hUserToken );
        RevertToSelf();
        return Status;
    }

    gpEvents->SetToken( hUserToken );

    LogTime();

    //
    // Set the query context -- the LANG_SYSTEM_DEFAULT value
    // tells CsGetAppInfo that we should use our built-in language precedence
    // algorithm in filtering packages -- otherwise, it will only consider
    // packages that match exactly the locale specified in the .Locale member
    //
    QueryContext.Locale = LANG_SYSTEM_DEFAULT;

    //
    // For architecture, we use the architecture of the calling process to override
    // the architecture of this process
    //
    GetDefaultPlatform( &QueryContext.Platform, TRUE, pAppType->ProcessorArchitecture );

    QueryContext.dwContext = CLSCTX_ALL;

    QueryContext.dwVersionHi = -1;
    QueryContext.dwVersionLo = -1;

    switch ( pAppType->Type )
    {
    case APPNAME :
        ClassSpec.tyspec = TYSPEC_PACKAGENAME;
        ClassSpec.tagged_union.ByName.pPackageName = pAppType->uType.AppName.Name;
        ClassSpec.tagged_union.ByName.PolicyId = pAppType->uType.AppName.PolicyId;
        DebugMsg((DM_VERBOSE, IDS_INSTALL_APPNAME, pAppType->uType.AppName.Name));
        break;
    case FILEEXT :
        ClassSpec.tyspec = TYSPEC_FILEEXT;
        ClassSpec.tagged_union.pFileExt = pAppType->uType.FileExt;
        DebugMsg((DM_VERBOSE, IDS_INSTALL_FILEEXT, pAppType->uType.FileExt));
        break;
    case PROGID :
        ClassSpec.tyspec = TYSPEC_PROGID;
        ClassSpec.tagged_union.pProgId = pAppType->uType.ProgId;
        DebugMsg((DM_VERBOSE, IDS_INSTALL_PROGID, pAppType->uType.ProgId));
        break;
    case COMCLASS :
        ClassSpec.tyspec = TYSPEC_CLSID;
        ClassSpec.tagged_union.clsid = pAppType->uType.COMClass.Clsid;
        QueryContext.dwContext = GetPlatformCompatibleCOMClsCtx( pAppType->ProcessorArchitecture, pAppType->uType.COMClass.ClsCtx );
        GuidToString( pAppType->uType.COMClass.Clsid, wszGuid );
        DebugMsg((DM_VERBOSE, IDS_INSTALL_COMCLASS, wszGuid, QueryContext.dwContext));
        break;
    }

    hr = CsGetAppInfo( &ClassSpec, &QueryContext, &PackageInfo );

    RevertToSelf();

    if ( S_OK == hr )
    {
        WCHAR* pszPolicyName;

        Status = RpcImpersonateClient( NULL );

        if ( ERROR_SUCCESS == Status )
        {
            Status = GetCurrentUserGPOList( &pGPOList );

            RevertToSelf();
        }

        if ( ERROR_SUCCESS != Status )
            goto InstallAppExit;

        pszPolicyName = GetGpoNameFromGuid( 
            pGPOList,
            &(PackageInfo.GpoId) );

        //
        // We've seen instance where getting the policy names fails because the gpo
        // history key for appmgmt in hklm was missing.  This is remotely possible 
        // if some registry api fails.  In this instance we can't just let every
        // install from ARP fail, so we'll just have to chug along with an empty
        // policy name.
        //
        if ( ! pszPolicyName )
            pszPolicyName = L"";

        switch ( PackageInfo.PathType )
        {
        case DrwFilePath :
            DebugMsg((DM_VERBOSE, IDS_INSTALL_DARWIN, PackageInfo.pszPackageName, pszPolicyName));
            break;
        case SetupNamePath :
            DebugMsg((DM_VERBOSE, IDS_INSTALL_SETUP, PackageInfo.pszPackageName, pszPolicyName));
            pInstallInfo->pwszDeploymentName = StringDuplicate( PackageInfo.pszPackageName );
            pInstallInfo->pwszGPOName = StringDuplicate( pszPolicyName );
            pInstallInfo->pwszSetupCommand = StringDuplicate( PackageInfo.pszScriptPath );
            goto InstallAppExit;
        default :
            DebugMsg((DM_VERBOSE, IDS_INSTALL_UNKNOWN, PackageInfo.PathType, PackageInfo.pszPackageName, pszPolicyName));
            Status = CS_E_PACKAGE_NOTFOUND;
            goto InstallAppExit;
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_GETAPPINFO_FAIL, hr));
        memset( &PackageInfo, 0, sizeof(PackageInfo) );
        Status = (DWORD) hr;
    }

    if ( ERROR_SUCCESS == Status )
    {
        pAppContext = new APPCONTEXT;
        if ( pAppContext )
        {
            pAppContext->pManApp = 0;
            pAppContext->pAppInfo = 0;
            pAppContext->bUninstallsCompleted = FALSE;
            pAppContext->pLoadMsi = new CLoadMsi( Status );
            pAppContext->pLoadSfc = 0;
            pAppContext->bStatus = FALSE;
            pAppContext->SRSequence = 0;

            if ( Status != ERROR_SUCCESS )
            {
                delete pAppContext->pLoadMsi;
                pAppContext->pLoadMsi = 0;
            }

            if ( ! pAppContext->pLoadMsi )
            {
                delete pAppContext;
                pAppContext = 0;
            }
        }

        if ( ! pAppContext )
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }

    if ( Status != ERROR_SUCCESS )
        goto InstallAppExit;

    RtlEnterCriticalSection( &gAppCS );
    bEnterCritSec = TRUE;

    pManApp = new CManagedAppProcessor( 0, hUserToken, hkRoot, NULL, TRUE, FALSE, &RsopContext, Status );

    if ( ! pManApp )
        Status = ERROR_OUTOFMEMORY;

    if ( ERROR_SUCCESS == Status )
        Status = pManApp->SetPolicyListFromGPOList( pGPOList );

    if ( ERROR_SUCCESS == Status )
    {
        pAppInfo = new CAppInfo( pManApp, &PackageInfo, TRUE, bStatus );

        if ( ! pAppInfo || ! bStatus )
            Status = ERROR_OUTOFMEMORY;
    }

    if ( ERROR_SUCCESS == Status )
    {
        GuidToString( PackageInfo.ProductCode, wszProductId );

        Status = pManApp->GetOrderedLocalAppList( LocalApps );
    }

    if ( ERROR_SUCCESS == Status )
        Status = pManApp->Impersonate();

    if ( Status != ERROR_SUCCESS )
        goto InstallAppExit;

    pAppContext->pManApp = pManApp;
    pAppContext->pAppInfo = pAppInfo;

    //
    // When servicing a demand install outside of ARP we prevent faulting in
    // any deployment of a particular product different from what is already
    // on the machine (if any) and we also prevent faulting in any app which
    // upgrades another app already on the machine.  This is to prevent a
    // subsequent upgrade, transform conflict, or language mismatch from
    // occuring while the app is likely in use.
    //
    // So below we are checking these cases plus, in the case of an ARP install,
    // adding any such apps to an additional list for processing of orphan and
    // uninstall actions.
    //

    for ( LocalApps.Reset(), pLocalApp = (CAppInfo *) LocalApps.GetCurrentItem();
          pLocalApp;
          pLocalApp = (CAppInfo *) LocalApps.GetCurrentItem() )
    {
        if ( ! (pLocalApp->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            LocalApps.MoveNext();
            continue;
        }

        //
        // This is the check for a similar product id but a different
        // deployment instance.
        //
        if ( (0 == lstrcmpi( pLocalApp->_pwszProductId, wszProductId )) &&
             (memcmp( &pLocalApp->_DeploymentId, &PackageInfo.PackageGuid, sizeof(GUID) ) != 0) )
        {
            if ( pAppType->Type != APPNAME )
            {
                // Abort if not doing an ARP install.
                Status = CS_E_PACKAGE_NOTFOUND;
                DebugMsg((DM_VERBOSE, IDS_DEMAND_BLOCK1, pAppInfo->_pwszDeploymentName));
                break;
            }
            else
            {
                LocalApps.MoveNext();
                pLocalApp->Remove();
                pManApp->AppList().InsertFIFO( pLocalApp );
                continue;
            }
        }

        //
        // This is the check to see if this new package is set to upgrade any
        // existing app we have.
        //
        for ( n = 0; n < PackageInfo.cUpgrades; n++ )
        {
            if ( (PackageInfo.prgUpgradeInfoList[n].Flag & (UPGFLG_Uninstall | UPGFLG_NoUninstall)) &&
                 (0 == memcmp( &pLocalApp->_DeploymentId, &PackageInfo.prgUpgradeInfoList[n].PackageGuid, sizeof(GUID) )) )
            {
                if ( pAppType->Type != APPNAME )
                {
                    // Abort if not doing an ARP install.
                    Status = CS_E_PACKAGE_NOTFOUND;
                    DebugMsg((DM_VERBOSE, IDS_DEMAND_BLOCK2, pAppInfo->_pwszDeploymentName));
                }
                else
                {
                    LocalApps.MoveNext();
                    pLocalApp->Remove();
                    pManApp->AppList().InsertFIFO( pLocalApp );
                }
                break;
            }
        }

        if ( CS_E_PACKAGE_NOTFOUND == Status )
            break;

        if ( n < PackageInfo.cUpgrades )
            continue;

        //
        // This is the check to see if this app is superceded by an app which is
        // already installed.  Note that in some instances this may actually be
        // a case where the new app upgrades the local app because of
        // policy precedence upgrade reversal.  The result is the same for demand
        // installs, but slightly different for ARP installs where we must ensure
        // that the upgrade logic is invoked.
        //
        for ( pwszDeploymentId = pLocalApp->_pwszSupercededIds;
              pwszDeploymentId && *pwszDeploymentId;
              pwszDeploymentId += GUIDSTRLEN + 1 )
        {
            StringToGuid( pwszDeploymentId, &DeploymentId );
            if ( 0 == memcmp( &DeploymentId, &PackageInfo.PackageGuid, sizeof(GUID) ) )
            {
                if ( pAppType->Type != APPNAME )
                {
                    // Abort if not doing an ARP install.
                    Status = CS_E_PACKAGE_NOTFOUND;
                    DebugMsg((DM_VERBOSE, IDS_DEMAND_BLOCK2, pAppInfo->_pwszDeploymentName));
                }
                else
                {
                    //
                    // There is an app already installed which has the new package
                    // in it's override list.  Either a previous upgrade setting is no
                    // longer set or this is a policy precedence violation case where
                    // the upgrade needs to be reversed.
                    // Not the prettiest solution, trading a late product change for least
                    // invasive code change.
                    //
                    if ( pManApp->GPOList().Compare( pLocalApp->_pwszGPOId, pAppInfo->_pwszGPOId ) < 0 )
                    {
                        PACKAGEDISPINFO LocalAppPackageInfo;
                        CAppInfo *      pNewApp = 0;

                        memset( &LocalAppPackageInfo, 0, sizeof(LocalAppPackageInfo) );

                        ClassSpec.tyspec = TYSPEC_OBJECTID;
                        memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, &pLocalApp->_DeploymentId, sizeof(GUID) );
                        StringToGuid( pLocalApp->_pwszGPOId, &ClassSpec.tagged_union.ByObjectId.PolicyId );

                        hr = CsGetAppInfo( &ClassSpec, NULL, &LocalAppPackageInfo );

                        if ( S_OK == hr )
                        {
                            pNewApp = new CAppInfo( pManApp, &LocalAppPackageInfo, FALSE, bStatus );
                            if ( ! bStatus )
                            {
                                delete pNewApp;
                                pNewApp = 0;
                            }
                            ReleasePackageInfo( &LocalAppPackageInfo );
                        }

                        if ( pNewApp )
                        {
                            pManApp->AppList().InsertFIFO( pAppInfo );
                            Status = pNewApp->InitializePass0();
                            pAppInfo->Remove();
                            pManApp->AppList().InsertFIFO( pNewApp );
                        }

                        if ( ! pNewApp || (Status != ERROR_SUCCESS) )
                            Status = CS_E_PACKAGE_NOTFOUND;
                    }
                }
                break;
            }
        }

        if ( CS_E_PACKAGE_NOTFOUND == Status )
            break;

        LocalApps.MoveNext();
    }

    LocalApps.ResetEnd();

    if ( ERROR_SUCCESS == Status )
    {
        // 
        // When doing a fileext/progid/clsid demand install, we don't want to 
        // set the full install state bit for the first time.  This will enable 
        // the full install option to still be applied at the next foreground 
        // policy processing.
        //
        if ( (pAppType->Type != APPNAME) && ! (pAppInfo->_State & APPSTATE_INSTALL) )
            pAppInfo->_ActFlags &= ~ACTFLG_InstallUserAssign;

        pAppInfo->InitializePass0();
        pAppInfo->SetActionPass1();
        pAppInfo->SetActionPass2();
        pAppInfo->SetActionPass3();
        pAppInfo->SetActionPass4();

        Status = pAppInfo->_Status;
    }

    pManApp->Revert();

    if ( ERROR_SUCCESS == Status )
    {
        bStatus = pAppInfo->CopyToApplicationInfo( pInstallInfo );
        if ( ! bStatus )
            Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
        goto InstallAppExit;

    for ( pManApp->AppList().Reset(), pUpgradedApp = (CAppInfo *) pManApp->AppList().GetCurrentItem();
          pUpgradedApp;
          pManApp->AppList().MoveNext(), pUpgradedApp = (CAppInfo *) pManApp->AppList().GetCurrentItem() )
    {
        APPLICATION_INFO * pOldApplicationInfo;

        bStatus = FALSE;

        if ( (pUpgradedApp->_Action != ACTION_UNINSTALL) && (pUpgradedApp->_Action != ACTION_ORPHAN) )
            continue;

        pOldApplicationInfo = pUninstallApps->ApplicationInfo;
        pUninstallApps->ApplicationInfo = (APPLICATION_INFO *) LocalAlloc( 0, (pUninstallApps->Products + 1) * sizeof(APPLICATION_INFO) );

        if ( pUninstallApps->ApplicationInfo )
        {
            if ( pOldApplicationInfo )
                memcpy( pUninstallApps->ApplicationInfo, pOldApplicationInfo, pUninstallApps->Products * sizeof(APPLICATION_INFO) );
            bStatus = pUpgradedApp->CopyToApplicationInfo( &pUninstallApps->ApplicationInfo[pUninstallApps->Products] );
        }

        LocalFree( pOldApplicationInfo );

        if ( ! bStatus )
        {
            pUninstallApps->Products = 0;
            Status = ERROR_OUTOFMEMORY;
            goto InstallAppExit;
        }
        else
        {
            pUninstallApps->Products++;
        }
    }

    pManApp->AppList().ResetEnd();

    //
    // If we're doing a progid, file extension, or clsid based activation, we search
    // for the specific Darwin identifier.
    //
    if ( pAppType->Type != APPNAME )
    {
        HKEY        hkPolicy;
        HKEY        hkClasses;
        HKEY        hkProgId;
        HKEY        hkScratch;
        WCHAR       wszScratch[128];
        WCHAR       wszDarwinId[128];
        WCHAR *     pwszProgId;
        DWORD       ScriptFlags;

        hkPolicy = 0;
        hkClasses = 0;

        wszDarwinId[0] = 0;

        Status = RegOpenKeyEx(
                        hkRoot,
                        POLICYKEY,
                        0,
                        KEY_ALL_ACCESS,
                        &hkPolicy );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We can use a fixed temp name since we are in a crit sec here.  This
            // key must be non volatile since that is how Darwin will do all of
            // their creates under this key.
            //
            Status = RegCreateKeyEx(
                            hkPolicy,
                            L"TempClasses",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkClasses,
                            NULL );
        }

        if ( ERROR_SUCCESS == Status )
        {
            Status = pManApp->Impersonate();
            if ( ERROR_SUCCESS == Status )
            {
                Status = pAppInfo->CopyScriptIfNeeded();
                pManApp->Revert();
            }
        }

        if ( ERROR_SUCCESS == Status )
        {
            //
            // Must include the MACHINEASSIGN flag since we are not impersonating.
            // That's a little quirk in the semantics of the Msi API.
            //
            ScriptFlags = SCRIPTFLAGS_MACHINEASSIGN;

            //
            // In the progid case we need to advertise both extension and class data.
            // This is because different progids are registered in these two
            // cases and we want to catch both.  In the former case they are progids
            // associated with file extensions and in the latter case with clsids.
            //
            if ( (FILEEXT == pAppType->Type) || (PROGID == pAppType->Type) )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;

            if ( (PROGID == pAppType->Type) || (COMCLASS == pAppType->Type) )
                ScriptFlags |= SCRIPTFLAGS_REGDATA_CLASSINFO;

            Status = (*gpfnMsiAdvertiseScript)(
                        pAppInfo->LocalScriptPath(),
                        ScriptFlags,
                        &hkClasses,
                        FALSE );
        }

        if ( Status != ERROR_SUCCESS )
        {
            gpEvents->Install(
                Status,
                pAppInfo);

            goto InstallAppDescriptorAbort;
        }

        //
        // Now we grovel our temporary registry dump for a darwin id under the
        // class info that was requested.
        //

        if ( pAppType->Type != COMCLASS )
        {
            //
            // Looking for a shell-open command verb.  First figure out the
            // ProgID.
            //
            if ( FILEEXT == pAppType->Type )
            {
                Status = RegOpenKeyEx(
                            hkClasses,
                            pAppType->uType.FileExt,
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                Size = sizeof(wszScratch);

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegQueryValueEx(
                                hkScratch,
                                L"",
                                NULL,
                                NULL,
                                (PBYTE) wszScratch,
                                &Size );

                    RegCloseKey( hkScratch );
                }

                pwszProgId = wszScratch;
            }
            else
            {
                pwszProgId = pAppType->uType.ProgId;
            }

            if ( ERROR_SUCCESS == Status )
            {
                Status = RegOpenKeyEx(
                            hkClasses,
                            pwszProgId,
                            0,
                            KEY_ALL_ACCESS,
                            &hkProgId );
            }

            if ( ERROR_SUCCESS == Status )
            {
                Status = RegOpenKeyEx(
                            hkProgId,
                            L"shell\\open\\command",
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                RegCloseKey( hkProgId );
            }

            Size = sizeof(wszDarwinId);

            if ( ERROR_SUCCESS == Status )
            {
                Status = RegQueryValueEx(
                            hkScratch,
                            L"command",
                            NULL,
                            NULL,
                            (PBYTE) wszDarwinId,
                            &Size );

                if ( (ERROR_SUCCESS == Status) && DebugLevelOn( DM_VERBOSE ) )
                {
                    DebugMsg((DM_VERBOSE, IDS_PROGID_FOUND, pwszProgId));
                }

                RegCloseKey( hkScratch );
            }
        }
        else // COMCLASS == pAppType->Type
        {
            //
            // Looking for a com clsid.  We check both the inproc & localserver
            // keys if those clsctx bits are set.
            //

            lstrcpy( wszScratch, L"CLSID\\" );
            lstrcpy( &wszScratch[6], wszGuid );

            if ( pAppType->uType.COMClass.ClsCtx & CLSCTX_INPROC_SERVER )
            {
                lstrcpy( &wszScratch[6+GUIDSTRLEN], L"\\InprocServer32" );

                Status = RegOpenKeyEx(
                            hkClasses,
                            wszScratch,
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                Size = sizeof(wszDarwinId);

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegQueryValueEx(
                                hkScratch,
                                L"InprocServer32",
                                NULL,
                                NULL,
                                (PBYTE) wszDarwinId,
                                &Size );

                    if ( ERROR_SUCCESS == Status )
                        DebugMsg((DM_VERBOSE, IDS_CLSID_INPROC_FOUND));

                    RegCloseKey( hkScratch );
                }
            }

            if ( (0 == wszDarwinId[0]) && (pAppType->uType.COMClass.ClsCtx & CLSCTX_LOCAL_SERVER) )
            {
                lstrcpy( &wszScratch[6+GUIDSTRLEN], L"\\LocalServer32" );

                Status = RegOpenKeyEx(
                            hkClasses,
                            wszScratch,
                            0,
                            KEY_ALL_ACCESS,
                            &hkScratch );

                Size = sizeof(wszDarwinId);

                if ( ERROR_SUCCESS == Status )
                {
                    Status = RegQueryValueEx(
                                hkScratch,
                                L"LocalServer32",
                                NULL,
                                NULL,
                                (PBYTE) wszDarwinId,
                                &Size );

                    if ( ERROR_SUCCESS == Status )
                        DebugMsg((DM_VERBOSE, IDS_CLSID_LOCAL_FOUND));

                    RegCloseKey( hkScratch );
                }
            }
        }

        //
        // We're done with the temp reg data, so blow it away now.
        //
        // Must include the MACHINEASSIGN flag since we are not impersonating.
        //
        (void) (*gpfnMsiAdvertiseScript)(
                    pAppInfo->LocalScriptPath(),
                    ScriptFlags,
                    &hkClasses,
                    TRUE );

InstallAppDescriptorAbort:

        if ( hkClasses )
        {
            RegCloseKey( hkClasses );
            RegDeleteKey( hkPolicy, L"TempClasses" );
        }

        if ( hkPolicy )
            RegCloseKey( hkPolicy );

        if ( ERROR_SUCCESS == Status )
        {
            pInstallInfo->pwszDescriptor = (PWCHAR) LocalAlloc( 0, (lstrlen(wszDarwinId) + 1) * sizeof(WCHAR) );
            if ( pInstallInfo->pwszDescriptor )
                lstrcpy( pInstallInfo->pwszDescriptor, wszDarwinId );
            else
                Status = ERROR_OUTOFMEMORY;
        }

        //
        // If we fail to find a darwin id under the specific class data that
        // was requested, then we fall back to doing a full product based
        // install.  Since the DS query succeeded, we have a valid app, but
        // there just isn't any darwin id registered for the specific class
        // data in the advertisement data.
        //
        // This could be a packaging problem, limitation, or design.
        //
    } // if ( pAppType->Type != APPNAME )

    if ( (ERROR_SUCCESS == Status) && (pAppInfo->_State & APPSTATE_SCRIPT_NOT_EXISTED) )
    {
        SetSystemRestorePoint( pAppInfo->_pwszDeploymentName, pAppContext );
    }

InstallAppExit:

    if ( bEnterCritSec )
        RtlLeaveCriticalSection( &gAppCS );

    if ( Status != ERROR_SUCCESS )
    {
        for ( ; pUninstallApps->Products; )
            FreeApplicationInfo( &pUninstallApps->ApplicationInfo[--pUninstallApps->Products] );
        LocalFree( pUninstallApps->ApplicationInfo );
        pUninstallApps->Products = 0;
        pUninstallApps->ApplicationInfo = 0;

        FreeApplicationInfo( pInstallInfo );
        memset( pInstallInfo, 0, sizeof(APPLICATION_INFO) );

        if ( pManApp )
        {
            if ( pAppInfo )
            {
                //
                // Since this call has failed, the client will not call
                // the InstallEnd method to log the failure, so we must
                // log the failure in this call
                //
                (void) LogRsopInstallData( pManApp, pAppInfo );
            }
            delete pManApp;
        }

        if ( pAppInfo )
            delete pAppInfo;

        if ( pAppContext )
        {
            delete pAppContext->pLoadMsi;
            delete pAppContext;
        }
    }
    else
    {
        *ppInstallContext = pAppContext;
    }

    if ( ((long)Status) > 0 )
        DebugMsg((DM_VERBOSE, IDS_INSTALL_STATUS1, Status));
    else
        DebugMsg((DM_VERBOSE, IDS_INSTALL_STATUS2, Status));

    gpEvents->ClearToken();

    if ( hUserToken )
        CloseHandle( hUserToken );

    if ( hkRoot )
        RegCloseKey( hkRoot );

    if ( pGPOList )
        FreeGPOList( pGPOList );

    ReleasePackageInfo( &PackageInfo );

    return Status;
}

error_status_t
InstallManageApp(
    IN  PINSTALLCONTEXT     pInstallContext,
    IN  PWSTR               pwszDeploymentId,
    IN  DWORD               RollbackStatus,
    OUT boolean *           pbInstall
    )
{
    PAPPCONTEXT pAppContext;
    CAppInfo *  pAppInfo;
    GUID        DeploymentId;
    DWORD       Status;

    *pbInstall = FALSE;

    pAppContext = (PAPPCONTEXT) pInstallContext;
    StringToGuid( pwszDeploymentId, &DeploymentId );

    Status = pAppContext->pManApp->Impersonate();
    if ( Status != ERROR_SUCCESS )
        return Status;

    gpEvents->SetToken( pAppContext->pManApp->UserToken() );

    if ( memcmp( &DeploymentId, &pAppContext->pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
    {
        pAppContext->bUninstallsCompleted = TRUE;
        Status = pAppContext->pAppInfo->ProcessApplyActions();

        if ( ERROR_SUCCESS == Status )
        {
            if ( pAppContext->pManApp->GetRsopContext()->IsRsopEnabled() && pAppContext->pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
                Status = pAppContext->pAppInfo->ProcessTransformConflicts();
        }

        goto InstallManageAppEnd;
    }

    for ( pAppContext->pManApp->AppList().Reset();
          pAppInfo = (CAppInfo *) pAppContext->pManApp->AppList().GetCurrentItem();
          pAppContext->pManApp->AppList().MoveNext() )
    {
        if ( memcmp( &DeploymentId, &pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
            break;
    }

    if ( ! pAppInfo )
    {
        Status = ERROR_NOT_FOUND;
        goto InstallManageAppEnd;
    }

    //
    // Re-assigning one of the upgraded apps because of a failed upgrade.  Not needed for
    // apps orphaned during the upgrade.
    //
    if ( ACTION_UNINSTALL == pAppInfo->_Action )
    {
        DWORD ScriptFlags = SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS;

        *pbInstall = (pAppInfo->_State & APPSTATE_INSTALL) ? 1 : 0;

        if ( pAppInfo->_State & APPSTATE_ASSIGNED )
            ScriptFlags |= SCRIPTFLAGS_REGDATA_EXTENSIONINFO;
        Status = pAppInfo->Assign( ScriptFlags, TRUE, FALSE );

        //
        // Record an event so that we can track this as an RSoP failed setting if
        // necessary
        //
        if ( ERROR_SUCCESS != Status )
        {
            gpEvents->Assign( Status, pAppInfo );
        }
    }

    //
    // Remember that this application was rolled back
    //
    pAppInfo->_bRollback = TRUE;

    gpEvents->UpgradeAbort( RollbackStatus, pAppContext->pAppInfo, pAppInfo, ! pAppContext->bUninstallsCompleted );

InstallManageAppEnd:

    gpEvents->ClearToken();
    pAppContext->pManApp->Revert();
    return Status;
}

error_status_t
InstallUnmanageApp(
    IN  PINSTALLCONTEXT     pInstallContext,
    IN  PWSTR               pwszDeploymentId,
    IN  boolean             bUnadvertiseOnly
    )
{
    PAPPCONTEXT pAppContext;
    CAppInfo *  pAppInfo;
    GUID        DeploymentId;
    DWORD       Status;

    pAppContext = (PAPPCONTEXT) pInstallContext;
    StringToGuid( pwszDeploymentId, &DeploymentId );

    Status = pAppContext->pManApp->Impersonate();
    if ( Status != ERROR_SUCCESS )
        return Status;

    gpEvents->SetToken( pAppContext->pManApp->UserToken() );

    if ( memcmp( &DeploymentId, &pAppContext->pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
    {
        Status = pAppContext->pAppInfo->Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO, TRUE );

        //
        // Record an event so that we can track this as an RSoP failed setting if
        // necessary
        //
        if ( ERROR_SUCCESS != Status )
        {
            gpEvents->Unassign( Status, pAppContext->pAppInfo );
        }

        goto InstallUnmanageAppEnd;
    }

    for ( pAppContext->pManApp->AppList().Reset();
          pAppInfo = (CAppInfo *) pAppContext->pManApp->AppList().GetCurrentItem();
          pAppContext->pManApp->AppList().MoveNext() )
    {
        if ( memcmp( &DeploymentId, &pAppInfo->_DeploymentId, sizeof(GUID) ) == 0 )
            break;
    }

    if ( ! pAppInfo )
    {
        Status = ERROR_NOT_FOUND;
        goto InstallUnmanageAppEnd;
    }

    //
    // Unassigning one of the upgraded apps.
    //
    if ( bUnadvertiseOnly )
    {
        Status = pAppInfo->Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, FALSE );
    }
    else
    {
        Status = pAppInfo->Unassign( 0, TRUE );

        //
        // Record an event so that we can track this as an RSoP failed setting if
        // necessary
        //
        if ( ERROR_SUCCESS != Status )
        {
            gpEvents->Unassign( Status, pAppInfo );
        }
	
        gpEvents->UpgradeComplete( pAppContext->pAppInfo, pAppInfo );
    }

InstallUnmanageAppEnd:

    gpEvents->ClearToken();
    pAppContext->pManApp->Revert();
    return Status;
}

error_status_t
InstallEnd(
    IN  boolean   bStatus,
    IN OUT PINSTALLCONTEXT * ppInstallContext
    )
{
    //
    // We are done installing -- now log the results
    //
    if ( *ppInstallContext )
    {
        PAPPCONTEXT           pAppContext;
        CManagedAppProcessor* pManApp;
    
        pAppContext = (PAPPCONTEXT) *ppInstallContext;
        if ( pAppContext )
            pAppContext->bStatus = (boolean) bStatus;

        pManApp = pAppContext->pManApp;

        if ( pManApp && pAppContext )
        {
            (void) LogRsopInstallData( pManApp, pAppContext->pAppInfo );
        }
    }

    PINSTALLCONTEXT_rundown( *ppInstallContext );
    *ppInstallContext = 0;
    return ERROR_SUCCESS;
}

void
PINSTALLCONTEXT_rundown(
    IN  PINSTALLCONTEXT pInstallContext
    )
{
    PAPPCONTEXT pAppContext;

    pAppContext = (PAPPCONTEXT) pInstallContext;

    if ( pAppContext && (pAppContext->SRSequence != 0) )
    {
        RESTOREPOINTINFO    RestoreInfo;
        STATEMGRSTATUS      SRStatus;

        RestoreInfo.dwEventType = END_NESTED_SYSTEM_CHANGE;
        RestoreInfo.dwRestorePtType = pAppContext->bStatus ? 0 : CANCELLED_OPERATION;
        RestoreInfo.llSequenceNumber = pAppContext->SRSequence;
        RestoreInfo.szDescription[0] = 0;

        (void) (*gpfnSRSetRetorePointW)( &RestoreInfo, &SRStatus );
    }

    delete pAppContext->pManApp;
    delete pAppContext->pAppInfo;
    delete pAppContext->pLoadMsi;
    if ( pAppContext->pLoadSfc )
        delete pAppContext->pLoadSfc;
    delete pAppContext;
}

DWORD
RemoveAppHelper(
    IN  WCHAR * ProductCode,
    IN  HANDLE  hUserToken,
    IN  HKEY    hKeyRoot,
    IN  DWORD   ARPStatus,
    OUT BOOL *  pbProductFound
    )
{
    CAppInfo *  pAppInfo;
    CAppInfo *  pHighestAssignedApp;
    CAppInfo *  pRemovedApp;
    DWORD       Status;

    *pbProductFound = FALSE;

    CRsopAppContext RsopContext( CRsopAppContext::REMOVAL );

    CManagedAppProcessor ManApps( hUserToken ? 0 : GPO_INFO_FLAG_MACHINE,
                                  hUserToken,
                                  hKeyRoot,
                                  NULL,
                                  FALSE,
                                  FALSE,
                                  &RsopContext,
                                  Status );

    if ( ERROR_SUCCESS != Status )
        return Status;

    CAppList    LocalApps( NULL, ManApps.GetRsopContext() );

    Status = ManApps.LoadPolicyList();

    if ( ERROR_SUCCESS != Status )
        return Status;

    Status = ManApps.GetOrderedLocalAppList( LocalApps );

    if ( ERROR_SUCCESS == Status )
        Status = ManApps.Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    pHighestAssignedApp = 0;
    pRemovedApp = 0;

    LocalApps.Reset();

    for ( pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem();
          pAppInfo;
          LocalApps.MoveNext(), pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem() )
    {
        if ( (lstrcmpi( pAppInfo->_pwszProductId, ProductCode ) != 0) ||
             ! (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED)) )
        {
            continue;
        }

        pRemovedApp = pAppInfo;

        *pbProductFound = TRUE;

        if ( pAppInfo->_State & APPSTATE_PUBLISHED ) 
        {
            //
            // We perform no actual unassignments unless ARP actually uninstalled the app
            //

            //
            // We unassign using the same scriptflags we do during assignment
            // to handle cases where the initial install action fails and
            // we are called to undo the original assigment.  In normal success
            // cases this is redundant.
            //
            if ( ERROR_SUCCESS == ARPStatus )
            {
                DebugMsg((DM_VERBOSE, IDS_REMOVEAPP_MATCH1, pAppInfo->_pwszDeploymentName, ProductCode));
                pAppInfo->Unassign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, TRUE );
            }

            //
            // Set this action for RSOP as a way to remember to log a removal entry for this app
            //
            pAppInfo->SetAction( 
                ACTION_UNINSTALL,
                APP_ATTRIBUTE_REMOVALCAUSE_USER,
                NULL);
        }
        else
        {
            //
            // We only reassign if ARP was able to uninstall the app
            //
            if ( ERROR_SUCCESS == ARPStatus )
            {
                DebugMsg((DM_VERBOSE, IDS_REMOVEAPP_MATCH2, pAppInfo->_pwszDeploymentName, ProductCode));
            }

            pHighestAssignedApp = pAppInfo;
        }
    }
     
    if ( ( ERROR_SUCCESS != ARPStatus ) && 
         pRemovedApp )
    {
        //
        // If ARP failed to uninstall the highest app, log a failure status
        //
        gpEvents->Uninstall(
            ARPStatus,
            pRemovedApp);
    }

    //
    // Reassign the highest priority assigned app with this product id if
    // one exists.
    //
    BOOL bRsopLogReassign;

    bRsopLogReassign = FALSE;

    if ( pHighestAssignedApp )
    {
        //
        // We only reassign the app if it was successfully uninstalled
        //
        if ( ERROR_SUCCESS == ARPStatus )
        {
            Status = pHighestAssignedApp->Assign( SCRIPTFLAGS_REGDATA_CNFGINFO | SCRIPTFLAGS_CACHEINFO | SCRIPTFLAGS_SHORTCUTS | SCRIPTFLAGS_REGDATA_EXTENSIONINFO, TRUE, FALSE );
            if ( Status != ERROR_SUCCESS )
                gpEvents->Assign( Status, pHighestAssignedApp );
        }

        if ( ManApps.GetRsopContext()->IsRsopEnabled() )
        {
            //
            // Remember to write a removal entry for this reassigned app if it 
            // was the app that was removed
            //
            bRsopLogReassign = ( pHighestAssignedApp == pRemovedApp );
        }
    }

    ManApps.Revert();

    //
    // We must log rsop data after we revert because the user may not have
    // access to her own rsop namespace
    //

    //
    // Obtain exclusive access to log data -- this will disable rsop
    // if implicit access cannot be obtained
    //
    (void) ManApps.GetRsopContext()->GetExclusiveLoggingAccess( NULL == hUserToken );

    if ( ManApps.GetRsopContext()->IsRsopEnabled() )
    {  
        //
        // Now log all the uninstalled published apps which would have been marked above
        // as having the action to uninstall
        //
        (void) LocalApps.WriteLog( CAppList::RSOP_FILTER_REMOVALSONLY );
    
        //
        // Now log the highest reassigned app
        //
        if ( bRsopLogReassign )
        {
            //
            // Log the actual uninstall entry
            //
            (void) LocalApps.MarkRSOPEntryAsRemoved( pHighestAssignedApp, FALSE );
        }
        else if ( pHighestAssignedApp )
        {
            //
            // We need to write a new entry for the assigned app that was not previously
            // applied but is now due to the fact that the higher precedence application
            // was removed
            //
            (void) LocalApps.WriteAppToRsopLog( pHighestAssignedApp );
        }
    }

    (void) ManApps.GetRsopContext()->ReleaseExclusiveLoggingAccess();
     
    //
    // Whenever the user does an app uninstall, we force a full run of policy
    // during the next logon to pick up any app that should now apply.  Note that
    // later we use a gp engine api to do this due to the NT 5.1 foreground async 
    // gp refresh feature, but for compatibility with NT 5.0 (roaming), we must
    // continue to set our own registry value
    //
    if ( *pbProductFound && hUserToken )
    {
        Status = RegSetValueEx(
            ManApps.AppmgmtKey(),
            FULLPOLICY,
            0,
            REG_DWORD,
            (LPBYTE) pbProductFound,
            sizeof(*pbProductFound) );

        //
        // Ensure that if async policy is enabled, we get a synchronous refresh at
        // the next logon 
        //
        if ( ERROR_SUCCESS == Status )
        {
            Status = ForceSynchronousRefresh( ManApps.UserToken() );
        }
    }

    return Status;
}

error_status_t
ARPRemoveApp(
    IN  handle_t   hRpc,
    IN  WCHAR *    pwszProductCode,
    IN  DWORD      ARPStatus
    )
{
    HANDLE      hUserToken;
    HKEY        hKeyRoot;
    DWORD       Status;
    BOOL        bStatus;
    BOOL        bProductFound;

    CheckLocalCall( hRpc );

    hUserToken = NULL;
    hKeyRoot = NULL;

    bProductFound = FALSE;

    CLoadMsi    LoadMsi( Status );

    if ( ERROR_SUCCESS == Status )
        Status = RpcImpersonateClient( NULL );

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegOpenCurrentUser( GENERIC_ALL, &hKeyRoot );

        if ( ERROR_SUCCESS == Status )
        {
            bStatus = OpenThreadToken(
                            GetCurrentThread(),
                            TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                            TRUE,
                            &hUserToken );

            if ( ! bStatus )
            {
                Status = GetLastError();
                RegCloseKey( hKeyRoot );
            }
        }

        RevertToSelf();
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    gpEvents->SetToken( hUserToken );

    LogTime();

    DebugMsg((DM_VERBOSE, IDS_REMOVEAPP, pwszProductCode));

    Status = RemoveAppHelper( pwszProductCode, hUserToken, hKeyRoot, ARPStatus, &bProductFound );

    if ( ! bProductFound )
    {
        if ( IsMemberOfAdminGroup( hUserToken ) )
            Status = RemoveAppHelper( pwszProductCode, NULL, HKEY_LOCAL_MACHINE, ARPStatus, &bProductFound );
    }

    DebugMsg((DM_VERBOSE, IDS_REMOVEAPP_STATUS, Status));
    gpEvents->ClearToken();

    if ( hUserToken )
        CloseHandle( hUserToken );

    if ( hKeyRoot )
        RegCloseKey( hKeyRoot );

    return Status;
}

error_status_t
GetManagedApps(
    IN  handle_t            hRpc,
    IN  GUID *              pCategory,
    IN  DWORD               dwQueryFlags,
    IN  DWORD               dwInfoLevel,
    OUT MANAGED_APPLIST *   pAppList
    )
{
    HANDLE          hUserToken;
    HANDLE          hEventAppsEnumerated;
    error_status_t  Status;
    BOOL            bStatus;

    CheckLocalCall( hRpc );

    hUserToken = NULL;
    hEventAppsEnumerated = NULL;

    if ( ! pAppList )
        return ERROR_INVALID_PARAMETER;

    //
    // Clear this structure so that random
    // garbage doesn't get marshalled back.
    //
    memset(pAppList, 0, sizeof(*pAppList));

    //
    // Validate the parameters passed in by the client.
    //
    if ( dwInfoLevel != MANAGED_APPS_INFOLEVEL_DEFAULT )
        return ERROR_INVALID_PARAMETER;

    switch (dwQueryFlags)
    {

    case MANAGED_APPS_USERAPPLICATIONS:
        if (pCategory)
            return ERROR_INVALID_PARAMETER;
        break;

    case MANAGED_APPS_FROMCATEGORY:
        if (!pCategory)
            return ERROR_INVALID_PARAMETER;
        break;

    default:
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Now prepare to initiate the query -- first
    // we need to get some user specific information
    // to build the object which performs the query,
    // so we impersonate.
    //
    Status = RpcImpersonateClient( NULL );
    if ( Status != ERROR_SUCCESS )
        return Status;

    bStatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                    TRUE,
                    &hUserToken );

    if ( ! bStatus )
        Status = GetLastError();

    RevertToSelf();

    if ( Status != ERROR_SUCCESS )
        goto GetManagedAppsExit;

    //
    // We will create a separate thread to retrieve the ARP apps -- this allows
    // this thread to wait for a signal from the ARP thread that app enumeration is done,
    // and we can return the list at that point.  The second thread will continue to
    // execute since it needs to log rsop data -- this approach frees us from having to
    // wait for rsop logging, which can take 10 times longer than it took us to retrieve
    // the apps from the ds
    //

    //
    // Below we create the event that the enumeration thread will use to signal this
    // thread that enumeration is finished.
    //

    hEventAppsEnumerated = CreateEvent(
        NULL,
        TRUE,  // manual reset
        FALSE, // initially nonsignaled
        NULL);

    if ( ! hEventAppsEnumerated )
    {
        Status = GetLastError();
        goto GetManagedAppsExit;
    }

    //
    // We allocate a structure to pass to the enumeration thread containing all the
    // context it needs to enumerate apps.  Note that this structure is stack allocated,
    // so the enumeration thread may only access it as long as this thread lives -- once
    // it signals us that enumeration is complete, it may no longer access this structure
    //

    ARPCONTEXT ArpContext;

    ArpContext.pCategory = pCategory;
    ArpContext.pAppList = pAppList;
    ArpContext.hUserToken = hUserToken;
    ArpContext.hEventAppsEnumerated = hEventAppsEnumerated;
    ArpContext.Status = ERROR_SUCCESS; // out parameter for the second thread to indicate status

    HANDLE hThread;

    hThread = CreateThread(
        NULL,
        0,
        GetManagedAppsProc,
        &ArpContext,
        0,
        NULL);

    if ( ! hThread )
        Status = GetLastError();

    if ( ERROR_SUCCESS != Status )
        goto GetManagedAppsExit;

    //
    // Wait for enumeration in the second thread to complete
    //
    (void) WaitForSingleObject( hEventAppsEnumerated, INFINITE );

    //
    // Retrieve the enumeration thread's status
    //
    Status = ArpContext.Status;

    //
    // Because tests assume they can check RSoP data as soon as
    // the api has completed, if the tests are waiting for policy 
    // events to be signaled already, we'll also wait for rsop to finish
    //
    if ( gDebugLevel & DL_EVENT )
    {
        (void) WaitForSingleObject( hThread, INFINITE );
    }

    CloseHandle( hThread );

GetManagedAppsExit:

    if ( hUserToken )
        CloseHandle( hUserToken );

    if ( hEventAppsEnumerated )
        CloseHandle( hEventAppsEnumerated );

    return Status;
}

error_status_t
RsopReportInstallFailure(
    IN PINSTALLCONTEXT pInstallContext,
    IN PWSTR           pwszDeploymentId,
    IN DWORD           dwEventId
    )
{
    GUID                  DeploymentId;
    PAPPCONTEXT           pAppContext;
    CManagedAppProcessor* pManApp;
    CAppInfo*             pAppInfo;

    pAppContext = (PAPPCONTEXT) pInstallContext;

    pManApp = pAppContext->pManApp;

    if ( ! pManApp || ! pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    //
    // Assume that the failure happened in the app that
    // we're trying to install
    //
    pAppInfo = pAppContext->pAppInfo;

    if ( ! pAppInfo )
    {
        return ERROR_SUCCESS;
    }

    StringToGuid( pwszDeploymentId, &DeploymentId );

    //
    // Check to see if the failure was in the app that we're
    // trying to install
    //
    if ( ! IsEqualGUID( pAppInfo->DeploymentId(), DeploymentId ) )
    {
        //
        // If not, see if the requested app is one of the apps
        // that was uninstalled before trying to apply the
        // target app, or was reinstalled as part of a rollback
        // from failure
        //
        pAppInfo = pManApp->AppList().Find( DeploymentId );

        if ( pAppInfo )
        {
            //
            // The failure happened during an uninstall for
            // a rip and replace upgrade, so we need to
            // log a failure for the upgrade as well
            //
            pAppContext->pAppInfo->SetRsopFailureStatus(
                ERROR_GEN_FAILURE,
                dwEventId);
        }
    }
    
    //
    // If we found the app requested by the caller, log a failure
    // status for it -- the error we pass to the method is only
    // used as a check against ERROR_SUCCESS, so we do not
    // need to pass the actual error that occurred
    //
    if ( pAppInfo ) 
    {
        pAppInfo->SetRsopFailureStatus(
            ERROR_GEN_FAILURE,
            dwEventId);
    }

    return ERROR_SUCCESS;
}


error_status_t
GetManagedAppCategories(
    IN        handle_t          hRpc,
    IN OUT    APPCATEGORYLIST*  pCategoryList
    )
{
    DWORD               Status;
    HRESULT             hr;
    APPCATEGORYINFOLIST AppCategories;
    HANDLE              hUserToken;
    HKEY                hkRoot;
    
    CheckLocalCall( hRpc );

    hr = S_OK;

    hUserToken = NULL;

    hkRoot = NULL;

    memset( pCategoryList, 0, sizeof( *pCategoryList ) );
    memset( &AppCategories, 0, sizeof( AppCategories ) );

    //
    // Now prepare to initiate the query -- first
    // we need to get some user specific information
    // to build the object which performs the query,
    // so we impersonate.
    //
    Status = RpcImpersonateClient( NULL );
    if ( ERROR_SUCCESS != Status )
        return Status;

    BOOL bStatus;

    bStatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                    TRUE,
                    &hUserToken );

    if ( ! bStatus )
        Status = GetLastError();

    if ( ERROR_SUCCESS == Status )
        Status = RegOpenCurrentUser( GENERIC_ALL, &hkRoot );

    if ( ERROR_SUCCESS == Status )
        hr = CsGetAppCategories( &AppCategories );

    RevertToSelf();

    if ( ( ERROR_SUCCESS != Status ) || FAILED( hr ) )
        goto GetManagedAppCategoriesExit;

    gpEvents->SetToken( hUserToken );

    //
    // The rpc interface is such that our out parameter is just
    // one allocation -- references within each array element are allocated
    // within the block, so we must first calculate how big the block is
    //
    if ( SUCCEEDED( hr ) )
    {
        DWORD        cbSize;
        DWORD        iCat;

        cbSize = sizeof( APPCATEGORY ) *  AppCategories.cCategory;

        for (iCat = 0; iCat < AppCategories.cCategory; iCat++)
        {
            cbSize += ( lstrlen( AppCategories.pCategoryInfo[iCat].pszDescription ) + 1 ) * 
                sizeof( WCHAR );
        }

        pCategoryList->pCategoryInfo = (APPCATEGORY*) midl_user_allocate( cbSize );

        if ( ! pCategoryList->pCategoryInfo )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Now that we have sufficient memory, we can copy the data
    //
    if ( SUCCEEDED( hr ) )
    {
        WCHAR* wszDescriptions;
        DWORD  iCat;

        wszDescriptions = (WCHAR*) &( pCategoryList->pCategoryInfo[ AppCategories.cCategory ] );

        pCategoryList->cCategory = AppCategories.cCategory;

        for (iCat = 0; iCat < AppCategories.cCategory; iCat++)
        {
            pCategoryList->pCategoryInfo[ iCat ].Locale = AppCategories.pCategoryInfo[iCat].Locale;
            pCategoryList->pCategoryInfo[ iCat ].AppCategoryId = AppCategories.pCategoryInfo[iCat].AppCategoryId;
            pCategoryList->pCategoryInfo[ iCat ].pszDescription = wszDescriptions;

            lstrcpy( wszDescriptions, AppCategories.pCategoryInfo[iCat].pszDescription );

            wszDescriptions += lstrlen( wszDescriptions ) + 1;
        }
    }

    //
    // If we have successfully generated results to return to the caller, log
    // those results
    //
    if ( SUCCEEDED( hr ) )
    {
        HRESULT              hrLog;
        DWORD                StatusLog;

        CRsopAppContext      RsopContext( CRsopAppContext::ARPLIST );

        CManagedAppProcessor AppProcessor(
            0,
            hUserToken,
            hkRoot,
            NULL,
            TRUE,
            FALSE,
            &RsopContext,
            StatusLog );

        if ( ERROR_SUCCESS == StatusLog )
        {
            CCategoryInfoLog CategoryLog( AppProcessor.GetRsopContext(), &AppCategories );

            Status = AppProcessor.GetRsopContext()->GetExclusiveLoggingAccess( NULL == hUserToken );

            if ( ERROR_SUCCESS == Status )
            {
                hrLog = CategoryLog.WriteLog();
            }

            AppProcessor.GetRsopContext()->ReleaseExclusiveLoggingAccess();
        }
        else
        {
            hrLog = HRESULT_FROM_WIN32( StatusLog );
        }

        if ( FAILED(hrLog) )
        {
            RsopContext.DisableRsop( hrLog );
        }
    }

    Status = GetWin32ErrFromHResult( hr );

    //
    // Free the internal version of the category list
    //
    ReleaseAppCategoryInfoList( &AppCategories );

 GetManagedAppCategoriesExit:

    if ( hUserToken )
    {
        CloseHandle( hUserToken );
    }

    if ( hkRoot )
    {
        RegCloseKey( hkRoot );
    }

    return Status;
}

DWORD
WINAPI
GetManagedAppsProc(
    LPVOID pvArpContext
    )
{
    ARPCONTEXT* pArpContext;

    pArpContext = (ARPCONTEXT*) pvArpContext;

    HANDLE          hUserToken;
    error_status_t  Status;
    BOOL            bStatus;
    HKEY            hkRoot;

    hUserToken = NULL;
    hkRoot = NULL;

    Status = ERROR_SUCCESS;

    bStatus = DuplicateTokenEx(
        pArpContext->hUserToken,
        TOKEN_DUPLICATE | TOKEN_QUERY | TOKEN_IMPERSONATE,
        NULL,
        SecurityImpersonation,
        TokenImpersonation,
        &hUserToken);

    if ( ! bStatus )
        Status = GetLastError();

    if ( bStatus )
    {
        bStatus = ImpersonateLoggedOnUser( hUserToken );
        
        if ( ! bStatus )
            Status = GetLastError();
    }

    if ( ERROR_SUCCESS == Status )
        Status = RegOpenCurrentUser( GENERIC_ALL, &hkRoot );

    RevertToSelf();

    if ( Status != ERROR_SUCCESS )
        goto GetManagedAppsProcExit;

    gpEvents->SetToken( hUserToken );

    LogTime();

    //
    // Now that we have a valid GPOInfo object, we can construct
    // an app processor object to do the query
    //
    {
        CRsopAppContext RsopContext( CRsopAppContext::ARPLIST, pArpContext->hEventAppsEnumerated );

        CManagedAppProcessor AppProcessor( 0,
                                           hUserToken,
                                           hkRoot,
                                           NULL,
                                           TRUE,
                                           FALSE,
                                           &RsopContext,
                                           Status );

        if ( ERROR_SUCCESS == Status )
        {
            Status = AppProcessor.GetManagedApplications( pArpContext->pCategory, pArpContext );
        }
    }

GetManagedAppsProcExit:

    gpEvents->ClearToken();

    if ( hkRoot )
        RegCloseKey( hkRoot );

    if ( hUserToken )
        CloseHandle( hUserToken );

    return 0;
}

BOOL
SetSystemRestorePoint(
    IN  WCHAR * pwszApplicationName,
    IN OUT  PAPPCONTEXT pAppContext
    )
{
    RESTOREPOINTINFO    RestoreInfo;
    STATEMGRSTATUS      SRStatus;
    HKEY    hkInstallerPolicy;
    DWORD   CheckpointPolicy;
    DWORD   CheckpointPolicySize;
    DWORD   InstallLen, NameLen;
    DWORD   Status;
    BOOL    bStatus;

    Status = RegOpenKeyEx( 
                HKEY_LOCAL_MACHINE, 
                L"Software\\Policies\\Microsoft\\Windows\\Installer",
                0, 
                KEY_READ,
                &hkInstallerPolicy );

    if ( Status != ERROR_SUCCESS )
        return FALSE;

    CheckpointPolicy = 0;
    CheckpointPolicySize = sizeof(CheckpointPolicy);

    (void) RegQueryValueEx( 
                hkInstallerPolicy,
                L"LimitSystemRestoreCheckpointing",
                NULL, 
                NULL,
                (LPBYTE) &CheckpointPolicy,
                &CheckpointPolicySize );

    RegCloseKey( hkInstallerPolicy );

    if ( CheckpointPolicy != 0 )
        return FALSE;

    if ( ! LoadLoadString() )
        return FALSE;

    Status = (*pfnLoadStringW)( ghDllInstance, IDS_INSTALLED, RestoreInfo.szDescription, sizeof(RestoreInfo.szDescription) / sizeof(WCHAR) );
    if ( 0 == Status )
        return FALSE;

    pAppContext->pLoadSfc = new CLoadSfc( Status );

    if ( Status != ERROR_SUCCESS )
    {
        delete pAppContext->pLoadSfc;
        pAppContext->pLoadSfc = 0;
    }

    if ( ! pAppContext->pLoadSfc )
        return FALSE;

    RestoreInfo.dwEventType = BEGIN_NESTED_SYSTEM_CHANGE;
    RestoreInfo.dwRestorePtType = APPLICATION_INSTALL;
    RestoreInfo.llSequenceNumber = 0;

    InstallLen = lstrlen(RestoreInfo.szDescription);
    NameLen = lstrlen(pwszApplicationName);

    if ( InstallLen + NameLen >= MAX_DESC_W )
    {
        lstrcpyn( &RestoreInfo.szDescription[InstallLen], pwszApplicationName, MAX_DESC_W - InstallLen - 1 );
        RestoreInfo.szDescription[MAX_DESC_W - 1] = 0;
    }
    else 
    {
        lstrcpy( &RestoreInfo.szDescription[InstallLen], pwszApplicationName );
    }

    bStatus = (*gpfnSRSetRetorePointW)( &RestoreInfo, &SRStatus );

    if ( bStatus )
        pAppContext->SRSequence = SRStatus.llSequenceNumber;

    return bStatus;
}

void
CheckLocalCall(
    IN  handle_t hRpc
    )
{
    UINT    Type;
    DWORD   Status;

    Status = I_RpcBindingInqTransportType( hRpc, &Type);

    if ( (Status != RPC_S_OK) ||
         (Type != TRANSPORT_TYPE_LPC) )
        RpcRaiseException( ERROR_ACCESS_DENIED );
}


WCHAR*
GetGpoNameFromGuid( 
    IN PGROUP_POLICY_OBJECT pGpoList,
    IN GUID* pGpoGuid
    )
{
    PGROUP_POLICY_OBJECT pNextGpo;
    WCHAR                wszTargetGuid[MAX_SZGUID_LEN];
    WCHAR*               pszPolicyName;
    
    pszPolicyName = NULL;

    (void) GuidToString(
        *pGpoGuid,
        wszTargetGuid);

    while (pGpoList) 
    {
        pNextGpo = pGpoList->pNext;
    
        if ( lstrcmpi(
            pGpoList->szGPOName,
            wszTargetGuid) == 0 )
        {
            pszPolicyName = pGpoList->lpDisplayName;
            break;
        }

        pGpoList = pNextGpo;
    }

    return pszPolicyName;
}

DWORD
GetPlatformCompatibleCOMClsCtx( 
    DWORD Architecture,
    DWORD dwClsCtx
    )
{
    if ( PROCESSOR_ARCHITECTURE_IA64 == Architecture )
    {
        //
        // On 64-bit, if we have any inproc server contexts, we need to
        // ensure that we specifically ask for 64-bit inproc servers
        //
        if ( dwClsCtx & CLSCTX_INPROC )
        {
            DWORD dwInproc64;

            dwInproc64 = 0;
                
            if ( dwClsCtx & CLSCTX_INPROC_SERVER )
            {
                dwInproc64 |= CLSCTX64_INPROC_SERVER;
            }

            if ( dwClsCtx & CLSCTX_INPROC_HANDLER )
            {
                dwInproc64 |= CLSCTX64_INPROC_HANDLER;
            }

            //
            // Now remove the standard inproc bits, which are interpreted
            // as 32-bit inproc
            //
            dwClsCtx &= ~CLSCTX_INPROC;

            //
            // Add in the 64-bit inproc bits that we support
            //
            dwClsCtx |= dwInproc64;
        }
    }
    
    return dwClsCtx;
}

    
void
LogRsopInstallData( 
    CManagedAppProcessor* pManApp,
    CAppInfo*             pAppInfo
    )
{
    HRESULT hr;

    if ( ! pManApp->GetRsopContext()->IsRsopEnabled() )
    {
        return;
    }

    hr = pManApp->GetRsopContext()->GetExclusiveLoggingAccess( NULL == pManApp->UserToken() );

    //
    // If the call above failed, rsop will be disabled so we have nothing to do
    //
    if ( FAILED(hr) )
    {
        return;
    }

    //
    // First log the installed application
    //
    pManApp->AppList().WriteAppToRsopLog( pAppInfo );

    //
    // Now write all the removal entries
    //
    pManApp->AppList().WriteLog( CAppList::RSOP_FILTER_REMOVALSONLY );

    //
    // Since we have installed an app, the resultant set has changed, so
    // update the RSoP version to ensure that we detect the change if 
    // we roam to another machine
    //
    (void) pManApp->GetRsopContext()->WriteCurrentRsopVersion( pManApp->AppmgmtKey() );

    (void) pManApp->GetRsopContext()->ReleaseExclusiveLoggingAccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\app_server.c ===
#include <app_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\appmgext.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  appmgext.cxx
//
//*************************************************************

#include "appmgext.hxx"

BOOL gbInitialized = FALSE;
HINSTANCE ghInst = NULL;


extern "C" DWORD WINAPI
ProcessGroupPolicyObjectsEx(
    IN DWORD dwFlags,
    IN HANDLE hUserToken,
    IN HKEY hKeyRoot,
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,
    IN ASYNCCOMPLETIONHANDLE pHandle,
    IN BOOL *pbAbort,
    IN PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
    IN IWbemServices *pWbemServices,
    OUT HRESULT      *phrRsopStatus
    )
{
    DWORD   Status;

    *phrRsopStatus = S_OK;

    Status = ERROR_SUCCESS;

    //
    // It is not appropriate for appmgmt to function in safe mode --
    // detect this case and exit if we are in safe mode
    //
    if ( dwFlags & GPO_INFO_FLAG_SAFEMODE_BOOT )
        return ERROR_GEN_FAILURE;

    if ( ! gbInitialized )
        Initialize();

    InitDebugSupport( DEBUGMODE_POLICY );
    CreatePolicyEvents();

    if ( dwFlags & GPO_INFO_FLAG_VERBOSE )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    ConditionalBreakIntoDebugger();

    //
    // Before NT 5.1, appmgmt was never applied in the background. Starting
    // with NT 5.1 however, it gets called for background refresh when asynchronous
    // foreground refreshes are enabled so that it can detect the need for a synchronous refresh.

    //
    // Normally, it will not be called for a slow link, but that behavior
    // can be modified by policy on group policy.
    //

    //
    // Note that during the asynchronous foreground refresh, the background refresh flag is
    // also set in order to maintain compatibility with earlier extensions, so when detecting
    // a true background refresh case below, we need to make sure the asynchronous foreground flag
    // is not enabled
    //
    if ( ( dwFlags & GPO_INFO_FLAG_BACKGROUND ) && ! ( dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND ) )
    {
        DebugMsg((DM_VERBOSE, IDS_BACKGROUND_REFRESH));

        //
        // For background refreshes, we will notify the policy engine that we
        // need to be called in the synchronous foreground refresh if there are changes
        //
        if ( ! ( dwFlags & GPO_INFO_FLAG_NOCHANGES ) )
        {
            DebugMsg((DM_VERBOSE, IDS_CHANGES_DETECTED));

            Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
        }

        DebugMsg((DM_VERBOSE, IDS_PROCESSGPT_RETURN, Status));

        return Status;
    }

    gpEvents->SetToken( hUserToken );

    LogTime();

    SignalPolicyStart( ! (dwFlags & GPO_INFO_FLAG_MACHINE) );

    CRsopAppContext DiagnosticModeContext(
        pWbemServices,
        ( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION ) && ! ( dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND ), 
        phrRsopStatus );

    if ( pDeletedGPOList )
    {
        DiagnosticModeContext.SetGPOAppRemoval();

        Status = ProcessGPOList(
                    pDeletedGPOList,
                    dwFlags,
                    hUserToken,
                    hKeyRoot,
                    pfnStatusCallback,
                    PROCESSGPOLIST_DELETED,
                    &DiagnosticModeContext
                    );
    }

    if ( pChangedGPOList && (ERROR_SUCCESS == Status) )
    {
        DiagnosticModeContext.SetGPOAppAdd();

        Status = ProcessGPOList(
                    pChangedGPOList,
                    dwFlags,
                    hUserToken,
                    hKeyRoot,
                    pfnStatusCallback,
                    PROCESSGPOLIST_CHANGED,
                    &DiagnosticModeContext);
    }

    DebugMsg((DM_VERBOSE, IDS_PROCESSGPT_RETURN, Status));

    SignalPolicyEnd( ! (dwFlags & GPO_INFO_FLAG_MACHINE) );

    gpEvents->ClearToken();

    return Status;
}


DWORD
ProcessGPOList(
    PGROUP_POLICY_OBJECT   pGPOList,
    DWORD                  dwFlags,
    HANDLE                 hUserToken,
    HKEY                   hKeyRoot,
    PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
    DWORD                  dwListType,
    CRsopAppContext*       pRsopContext
    )
{
    CManagedAppProcessor * pManApps;
    PGROUP_POLICY_OBJECT   pCurrentGPO;

    DWORD   Status;
    BOOL    bDeletedGPOs;

    CLoadMsi    LoadMsi( Status );

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = ERROR_OUTOFMEMORY;

    bDeletedGPOs = (PROCESSGPOLIST_DELETED == dwListType);

    pManApps = new CManagedAppProcessor(
        dwFlags,
        hUserToken,
        hKeyRoot,
        pfnStatusCallback,
        FALSE,
        ! bDeletedGPOs,
        pRsopContext,
        Status);

    if ( ERROR_SUCCESS != Status )
    {
        if ( pManApps )
            delete pManApps;

        pManApps = 0;
    }

    if ( ! pManApps )
        return Status;

    if ( bDeletedGPOs )
    {
        DebugMsg((DM_VERBOSE, IDS_POLICY_REMOVED, dwFlags));
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_POLICY_APPLY, dwFlags));
    }

    Status = pManApps->SetPolicyListFromGPOList( pGPOList );
    if ( ERROR_SUCCESS != Status )
        return Status;

    if ( bDeletedGPOs )
        Status = pManApps->Delete();
    else
        Status = pManApps->Process();

    //
    // Write any Rsop logs -- this is a no op if
    // rsop logging is not enabled
    //
    pManApps->WriteRsopLogs();

    if ( ! pManApps->NoChanges() &&
         ((Status != ERROR_SUCCESS) || ! bDeletedGPOs) )
    {
        gpEvents->PolicyStatus( Status, pManApps->ErrorReason() );
    }

    if ( ! pManApps->GetRsopContext()->PurgeRemovalEntries() )
    {
        pRsopContext->ResetRemovalPurge();
    }

    HRESULT hrRsopStatus;

    hrRsopStatus = pManApps->GetRsopContext()->GetRsopStatus();

    if ( FAILED( hrRsopStatus ) )
    {
        gpEvents->RsopLoggingStatus( hrRsopStatus );
    }

    delete pManApps;

    return Status;
}

extern "C" BOOL WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        ghDllInstance = hInstance;
        gSystemLangId = GetSystemDefaultLangID();
        DisableThreadLibraryCalls(hInstance);
        InitDebugSupport( DEBUGMODE_CLIENT );
        InitializeClassStore(FALSE);

        //
        // Init our event logging -- this is used
        // by both server and cstore subcomponents
        //
        gpEvents = new CEvents();

        if (!gpEvents)
            return FALSE;

        break;
    case DLL_PROCESS_DETACH :
        Uninitialize();
        break;
    }

    return TRUE;
}

void
Initialize()
{
    ghInst = LoadLibrary( L"appmgmts.dll" );
    gbInitialized = ghInst != NULL;
}

extern "C" DWORD WINAPI
GenerateGroupPolicy(
                   IN DWORD dwFlags,
                   IN BOOL  *pbAbort,
                   IN WCHAR *pwszSite,
                   IN PRSOP_TARGET pComputerTarget,
                   IN PRSOP_TARGET pUserTarget )
{
    DWORD   Status;

    Status = ERROR_SUCCESS;

    if ( ! gbInitialized )
        Initialize();

    InitDebugSupport( DEBUGMODE_POLICY );

    if ( dwFlags & GPO_INFO_FLAG_VERBOSE )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    ConditionalBreakIntoDebugger();

    LogTime();

    if ( pComputerTarget && pComputerTarget->pGPOList )
    {
        CRsopAppContext MachinePlanningModeContext( pComputerTarget );

        Status = ProcessGPOList(
                    pComputerTarget->pGPOList,
                    dwFlags,
                    NULL,
                    NULL,
                    NULL,
                    PROCESSGPOLIST_CHANGED,
                    &MachinePlanningModeContext);
    }

    if ( pUserTarget && pUserTarget->pGPOList )
    {
        CRsopAppContext UserPlanningModeContext( pUserTarget );

        Status = ProcessGPOList(
                    pUserTarget->pGPOList,
                    dwFlags,
                    NULL,
                    NULL,
                    NULL,
                    PROCESSGPOLIST_CHANGED,
                    &UserPlanningModeContext);

        if ( ERROR_SUCCESS == Status )
        {
            CRsopAppContext UserPlanningModeARPContext( pUserTarget );

            Status = GenerateManagedApplications( 
                pUserTarget->pGPOList,
                dwFlags,
                &UserPlanningModeARPContext);
        }
    }

    //
    // In planning mode, Need to undo the extra reference count
    // that normally occurs in regular policy execution mode.
    //
    if ( ghInst )
    {
        FreeLibrary( ghInst );
    }

    DebugMsg((DM_VERBOSE, IDS_PROCESSGPT_RETURN, Status));

    return Status;
}


DWORD
GenerateManagedApplications(
    PGROUP_POLICY_OBJECT  pGPOList,
    DWORD                 dwFlags,
    CRsopAppContext*      pRsopContext 
    )
{
    DWORD   Status;
    HRESULT hr;

    hr = pRsopContext->SetARPContext();

    if ( FAILED(hr) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    CManagedAppProcessor ApplicationProcessor(
        dwFlags,
        NULL,
        NULL,
        NULL,
        TRUE,
        FALSE,
        pRsopContext,
        Status);

    if ( ERROR_SUCCESS == Status )
    {
        Status = ApplicationProcessor.SetPolicyListFromGPOList(
            pGPOList);

        if ( ERROR_SUCCESS == Status )
        {
            Status = ApplicationProcessor.GetManagedApplications(
                NULL,
                NULL);
        }
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\appschem.h ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998 - 2000
//  All rights reserved
//
//  appschem.h
//
//  This file contains declarations related to the wmi schema
//  for software management policy objects
//
//*************************************************************

//
// WMI class names for the software management classes
//

#define RSOP_MANAGED_SOFTWARE_APPLICATION L"RSOP_ApplicationManagementPolicySetting"
#define RSOP_MANAGED_SOFTWARE_CATEGORY    L"RSOP_ApplicationManagementCategory"


//
// Attribute names for the RSOP_ApplicationManagementPolicyObject class
//


// Describes the contents of the instance
#define APP_ATTRIBUTE_ENTRYTYPE                   L"EntryType"
//
// Enumerated values for EntryType
//
#define APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE 1L
#define APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE   2L
#define APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM      3L


// A unique id for this deployed package
#define APP_ATTRIBUTE_APPID                       L"ApplicationId"

// This describes the type of the package to be installed
#define APP_ATTRIBUTE_PACKAGETYPE                 L"PackageType"
//
// Enumerated values for PackageType
//
#define APP_ATTRIBUTE_PACKAGETYPE_VALUE_WIN_INSTALLER   1L
#define APP_ATTRIBUTE_PACKAGETYPE_VALUE_ZAP             2L

// Windows Installer Product ID.
#define APP_ATTRIBUTE_PRODUCT_ID                  L"ProductId"

// Name of the vendor of the software    
#define APP_ATTRIBUTE_PUBLISHER                   L"Publisher"

// PackageLocation
#define APP_ATTRIBUTE_PACKAGELOCATION             L"PackageLocation"

// Script File.
#define APP_ATTRIBUTE_SCRIPTFILE                  L"ScriptFile"

// SupportUrl
#define APP_ATTRIBUTE_SUPPORTURL                  L"SupportURL"

// Categories of applications in Add/Remove Programs
#define APP_ATTRIBUTE_CATEGORYLIST                L"Categories"

// The reason this application defeated another 
#define APP_ATTRIBUTE_PRECEDENCE_REASON           L"PrecedenceReason"
//
// Enumerated values for PrecedenceReason
//
#define APP_ATTRIBUTE_REASON_VALUE_LANGUAGE         1L
#define APP_ATTRIBUTE_REASON_VALUE_PRODUCT          2L
#define APP_ATTRIBUTE_REASON_VALUE_UPGRADE          4L
#define APP_ATTRIBUTE_REASON_VALUE_WINNING          5L
#define APP_ATTRIBUTE_REASON_VALUE_NONFORCEDUPGRADE 6L

// Minor version number of the application
#define APP_ATTRIBUTE_VERSIONLO                   L"VersionNumberLo"

// Major version number of the application
#define APP_ATTRIBUTE_VERSIONHI                   L"VersionNumberHi"

// The number of times the app has been redeployed
#define APP_ATTRIBUTE_REDEPLOYCOUNT               L"RedeployCount"

// The last modification time of this application by the administrator
#define APP_ATTRIBUTE_MODIFYTIME                  L"DeploymentLastModifyTime"


// Security Descriptor
#define APP_ATTRIBUTE_SECURITY_DESCRIPTOR         L"SecurityDescriptor"

// Machine architectures
#define APP_ATTRIBUTE_ARCHITECTURES               L"MachineArchitectures"

// language id from the package
#define APP_ATTRIBUTE_LANGUAGEID                  L"LanguageId"


// Package Deployment Type
#define APP_ATTRIBUTE_DEPLOY_TYPE                 L"DeploymentType"
//
// Enumerated values for the DeploymentType attribute
//
#define APP_ATTRIBUTE_DEPLOY_VALUE_ASSIGNED  1L
#define APP_ATTRIBUTE_DEPLOY_VALUE_PUBLISHED 2L

// Type of assignment: none, advertised, or default install
#define APP_ATTRIBUTE_ASSIGNMENT_TYPE             L"AssignmentType"
//
// Enumerated values for the AssignmentType attribute
//
#define APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_NOTASSIGNED  1L
#define APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_STANDARD     2L
#define APP_ATTRIBUTE_ASSIGNMENTTYPE_VALUE_INSTALL      3L

// Installation UI
#define APP_ATTRIBUTE_INSTALLATIONUI              L"InstallationUI"
//
// Enumerated values for the InstallatuionUI attribute
//
#define APP_ATTRIBUTE_INSTALLATIONUI_VALUE_BASIC   1L
#define APP_ATTRIBUTE_INSTALLATIONUI_VALUE_MAXIMUM 2L

// Installable on demand
#define APP_ATTRIBUTE_ONDEMAND                    L"DemandInstallable"

// Behavior to take on loss of scope
#define APP_ATTRIBUTE_LOSSOFSCOPEACTION           L"LossOfScopeAction"
//
// Enumerated values for the LossOfScopeAction
//
#define APP_ATTRIBUTE_SCOPELOSS_UNINSTALL 1L
#define APP_ATTRIBUTE_SCOPELOSS_ORPHAN    2L

// Whether this application uninstalls unmanaged versions
#define APP_ATTRIBUTE_UNINSTALL_UNMANAGED         L"UninstallUnmanaged"

// Whethier this x86 package is available on ia64
#define APP_ATTRIBUTE_X86OnIA64                   L"AllowX86OnIA64"

// If TRUE, this application may be displayed in ARP
#define APP_ATTRIBUTE_DISPLAYINARP                L"DisplayInARP"

// Ignore language when deploying this package
#define APP_ATTRIBUTE_IGNORELANGUAGE              L"IgnoreLanguage"

// Chained list of applications that were upgraded
#define APP_ATTRIBUTE_TRANSFORMLIST               L"Transforms"


// Packages that this package will upgrade
#define APP_ATTRIBUTE_UPGRADEABLE_APPLICATIONS    L"UpgradeableApplications"
// Packages that are upgrading this package
#define APP_ATTRIBUTE_REPLACEABLE_APPLICATIONS    L"ReplaceableApplications"

// Whether this application is a required upgrade
#define APP_ATTRIBUTE_UPGRADE_SETTINGS_MANDATORY  L"UpgradeSettingsMandatory"


// Apply Cause
#define APP_ATTRIBUTE_APPLY_CAUSE                 L"ApplyCause"
//
// Enumerated Values for ApplyCause
//
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE     0L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_ASSIGNED 1L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_USER     2L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROFILE  3L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_FILEEXT  4L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_CLSID    5L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_UPGRADE  6L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_PROGID   7L
#define APP_ATTRIBUTE_APPLYCAUSE_VALUE_REDEPLOY 8L

// Eligibility
#define APP_ATTRIBUTE_ELIGIBILITY                 L"Eligibility"
//
// Enumerated values for Eligibility
//
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_ASSIGNED 1L
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_APPLIED  2L
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_UPGRADES 3L
#define APP_ATTRIBUTE_ELIGIBILITY_VALUE_PLANNING 4L


// An enumerated type that describes the rule used to choose package
#define APP_ATTRIBUTE_LANGMATCH                   L"LanguageMatch"
//
// Enumerated values for the LanguageMatch attribute
//
#define APP_ATTRIBUTE_LANGMATCH_VALUE_SYSLOCALE 1L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_ENGLISH   2L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_IGNORE    3L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_NEUTRAL   4L
#define APP_ATTRIBUTE_LANGMATCH_VALUE_NOMATCH   5L

// File extension used for on-demand install
#define APP_ATTRIBUTE_ONDEMAND_FILEEXT            L"OnDemandFileExtension"

// Clsid used for on-demand install
#define APP_ATTRIBUTE_ONDEMAND_CLSID              L"OnDemandClsid"

// ProgId used for on-demand install
#define APP_ATTRIBUTE_ONDEMAND_PROGID             L"OnDemandProgid"


// Removal Cause
#define APP_ATTRIBUTE_REMOVAL_CAUSE               L"RemovalCause"
//
// Enumerated values for RemovalCause
//
#define APP_ATTRIBUTE_REMOVALCAUSE_NONE           1L
#define APP_ATTRIBUTE_REMOVALCAUSE_UPGRADE        2L
#define APP_ATTRIBUTE_REMOVALCAUSE_ADMIN          3L
#define APP_ATTRIBUTE_REMOVALCAUSE_USER           4L
#define APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS      5L
#define APP_ATTRIBUTE_REMOVALCAUSE_TRANSFORM      6L
#define APP_ATTRIBUTE_REMOVALCAUSE_PRODUCT        7L
#define APP_ATTRIBUTE_REMOVALCAUSE_PROFILE        8L

// Removal Type
#define APP_ATTRIBUTE_REMOVAL_TYPE                L"RemovalType"
//
// Enumerated values for Removal type
//
#define APP_ATTRIBUTE_REMOVALTYPE_NONE            1L
#define APP_ATTRIBUTE_REMOVALTYPE_UPGRADED        2L
#define APP_ATTRIBUTE_REMOVALTYPE_UNINSTALLED     3L
#define APP_ATTRIBUTE_REMOVALTYPE_ORPHAN          4L

// The application that caused this application to be removed
#define APP_ATTRIBUTE_REMOVING_APP                L"RemovingApplication"


//
// Attribute names for the RSOP_ARPCategories class
//

// Category id
#define CAT_ATTRIBUTE_ID                          L"CategoryId"

// Category name.
#define CAT_ATTRIBUTE_NAME                        L"Name"

// Time this instance was created
#define CAT_ATTRIBUTE_CREATIONTIME                L"CreationTime"


//
// Miscellaneous definitions
//
#define MAX_SZGUID_LEN      39
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\catlog.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  catlog.cxx
//
//*************************************************************

#include "appmgext.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfo::CCategoryInfo
//
// Purpose: Constructor for category encapsulation class --
//          initializes state with information about a category
//
// Params: pCategoryInfo -- structure containing information
//         about this category
//
// Return value: none
//
// Notes:  The class maintains the reference to the passed
//         in structure -- therefore, the memory for that
//         structure should not be freed before this object
//         is used.  This class does not own the reference --
//         caller should free the pCategoryInfo memory after
//         this class is no longer in use.
//
//------------------------------------------------------------
CCategoryInfo::CCategoryInfo(
    APPCATEGORYINFO*     pCategoryInfo) :
    _pCategoryInfo( pCategoryInfo )
{}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfo::Write
//
// Purpose: Write information regarding this category into
//          a database record
//
// Params: 
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfo::Write()
{
    HRESULT hr;
    WCHAR   wszUniqueId[MAX_SZGUID_LEN];

    //
    // Get our unique id
    //
    GuidToString(
        _pCategoryInfo->AppCategoryId,
        wszUniqueId);

    //
    // The category guid is the unique id for this record --
    //
    hr = SetValue(
        CAT_ATTRIBUTE_ID,
        wszUniqueId);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set the time stamp on the record
    //
    {
        SYSTEMTIME CurrentTime;
        
        //
        // This does not fail
        //
        GetSystemTime( &CurrentTime );

        hr = SetValue(
            CAT_ATTRIBUTE_CREATIONTIME,
            &CurrentTime);

        REPORT_ATTRIBUTE_SET_STATUS( CAT_ATTRIBUTE_CREATIONTIME, hr );
    }

    //
    // Set the name of the category
    //
    hr = SetValue(
        CAT_ATTRIBUTE_NAME,
        _pCategoryInfo->pszDescription);

    REPORT_ATTRIBUTE_SET_STATUS( CAT_ATTRIBUTE_NAME, hr );

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::CCategoryInfoLog
//
// Purpose: Initialize the domain app categories to log object
//
// Params: 
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CCategoryInfoLog::CCategoryInfoLog(
    CRsopContext*        pRsopContext,
    APPCATEGORYINFOLIST* pCategoryList ) :
    _bRsopEnabled( FALSE ),
    _pRsopContext( pRsopContext ),
    _pCategoryList( pCategoryList )
{
    if ( ! pCategoryList )
    {
        _pCategoryList = & _AppCategoryList;
    }

    //
    // Zero the list of apps so the destructor never mistakes
    // unitialized data for real data that it would attempt to free
    //
    RtlZeroMemory(&_AppCategoryList, sizeof(_AppCategoryList));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::~CCategoryInfoLog
//
// Purpose: Initialize the domain app categories to log object
//
// Params: 
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CCategoryInfoLog::~CCategoryInfoLog()
{
    //
    // If the members of this function are NULL, this is
    // just a noop.  Otherwise, it clears all memory
    // references by this structure and its members.
    //
    (void) ReleaseAppCategoryInfoList( &_AppCategoryList );
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::WriteLog
//
// Purpose: Log domain categories to the policy database
//
// Params: none
//
// Return value: S_OK if all categories logged, S_FALSE if
//               one or more categories could not be logged,
//               other error otherwise
//
// Notes: Does nothing if the rsop logging is disabled
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::WriteLog()
{
    HRESULT hr;

    //
    // Make sure logging is enabled -- if not, this function
    // will just be a noop. Logging is disabled if we have
    // any sort of initialization errors.
    //
    if ( !_pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Initialize the log so that we can write into it -- if this
    // doesn't succeed, we can't log anything.
    //
    hr = InitCategoryLog();

    if (FAILED(hr))
    {
        return hr;
    }

    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        //
        // Now that log support is set, we need to obtain the categories
        // which we are going to log
        //
        hr = GetCategoriesFromDirectory();

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We have the categories we wish to log, now we should write 
    // all the categories to the log
    //
    return WriteCategories();
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::InitCategoryLog
//
// Purpose: Initialize the logging support, including 
//          establishing a connection to the policy database
//
// Params: none
//
// Return value: S_OK if successful, other error otherwise
//
// Notes: If this fails, categories cannot be logged
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::InitCategoryLog()
{
    HRESULT hr;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Initialize the base logging functions to allow logging
    // to the policy database of the class of policy
    // in which we're interested: software categories.  We
    // supply a flag indicating whether this is machine or user
    // policy since machine and user policy records are logged
    // in separate namespaces (i.e. we maintain separate logs).
    //
    hr = InitLog( _pRsopContext,
                  RSOP_MANAGED_SOFTWARE_CATEGORY);

    //
    // If this init fails, we should disable logging so
    // subsequent method calls on this object will
    // not attempt to write to an inaccessible database
    //
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We have access to the database, we should clear previous
    // logs in this namespace
    //
    hr = ClearLog();

    //
    // If we couldn't clear the log, we will not attempt to write
    // any more records -- we make sure of this by resetting the
    // disable flag
    //
    if (SUCCEEDED(hr))
    {
        _bRsopEnabled = TRUE;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::AddBlankCategory
//
// Purpose: Adds an empty category record to the log
//
// Params: none
//
// Return value: S_OK if successful, other error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::AddBlankCategory(CCategoryInfo* pCategoryInfo)
{
    return AddBlankRecord(pCategoryInfo);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::GetCategories()
//
// Purpose: Obtains the list of app categories from the domain
//
// Params: none
//
// Return value: S_OK if successful, other error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::GetCategoriesFromDirectory()
{
    HRESULT hr;

    //
    // Call the internal api to the directory service software
    // management interface to obtain the list of categories
    //
    hr = CsGetAppCategories( &_AppCategoryList );

    if (FAILED(hr))
    {
        return hr;
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CCategoryInfoLog::WriteLog
//
// Purpose: Write domain categories as records 
//          to the policy database
//
// Params: none
//
// Return value: S_OK if all categories logged, S_FALSE if
//               one or more categories could not be logged,
//               other error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CCategoryInfoLog::WriteCategories()
{
    DWORD   iCat;
    HRESULT hr;

    hr = S_OK;

    //
    // Iterate through the list of categories so that we
    // can log each one.
    //
    for (iCat = 0; iCat < _pCategoryList->cCategory; iCat++)
    {
        HRESULT hrWrite;

        DebugMsg((DM_VERBOSE, IDS_RSOP_CAT_INFO, _pCategoryList->pCategoryInfo[iCat].pszDescription));

        //
        // Place this code in a new scope so that the constructor
        // and destructor for CCategoryInfo are called each time (we
        // need to get a new record object for each iteration in the loop)
        //
        {
            //
            // Create a record object with information about the current
            // category in this iteration
            //
            CCategoryInfo CategoryInfo( &(_pCategoryList->pCategoryInfo[iCat]) );

            //
            // Now write the record into the database.
            //
            hrWrite = WriteNewRecord( &CategoryInfo );

            //
            // Set our return value to S_FALSE if we failed in any way to log this category
            //
            if (FAILED(hrWrite))
            {
                DebugMsg((DM_VERBOSE, IDS_RSOP_CAT_WRITE_FAIL, _pCategoryList->pCategoryInfo->pszDescription, hr));
                hr = S_FALSE;
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\cspath.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  cspath.cxx
//
//  Class for building and setting the ClassStore path in the
//  registry.
//
//*************************************************************

#include "appmgext.hxx"

CSPath::CSPath()
{
    _pwszPath = 0;
}

CSPath::~CSPath()
{
    if ( _pwszPath )
        LocalFree( _pwszPath );
}

DWORD
CSPath::AddComponent(
    WCHAR * pwszDSPath,
    WCHAR * pwszDisplayName
    )
{
    WCHAR * pwszCSPath;
    WCHAR * pwszNewPath;
    DWORD   Size;
    HRESULT hr;
    DWORD   Status;

    if ( ! pwszDSPath )
        return ERROR_SUCCESS;

    hr = CsGetClassStorePath( pwszDSPath, &pwszCSPath );

    if ( hr != S_OK )
    {
        //
        // This call was simply a string manipulation, it should 
        // only fail due to out of memory
        //
        DebugMsg((DM_VERBOSE, IDS_NO_CLASSSTORE, pwszDisplayName, hr));
        return (DWORD) hr;
    }

    Size = 0;

    if ( _pwszPath )
        Size += lstrlen(_pwszPath) * sizeof(WCHAR);

    Size += (lstrlen(pwszCSPath) + 2) * sizeof(WCHAR);

    pwszNewPath = (WCHAR *) LocalAlloc( 0, Size );

    if ( ! pwszNewPath )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        lstrcpy( pwszNewPath, pwszCSPath );
        lstrcat( pwszNewPath, L";" );
        if ( _pwszPath )
            lstrcat( pwszNewPath, _pwszPath );

        LocalFree( _pwszPath );
        _pwszPath = pwszNewPath;

        Status = ERROR_SUCCESS;
    }

    LocalFree( pwszCSPath );

    return Status;
}

DWORD
CSPath::Commit(
    HANDLE hToken
    )
{
    DWORD   Status;

    if ( _pwszPath )
    {
        Status = WriteClassStorePath(hToken, _pwszPath);

        DebugMsg((DM_VERBOSE, IDS_CSPATH, _pwszPath));
    }
    else
    {
        (void) WriteClassStorePath(hToken, L"");
        Status = CS_E_NO_CLASSSTORE;

        DebugMsg((DM_VERBOSE, IDS_NOCSPATH));
    }

    return Status;
}

DWORD
CSPath::WriteClassStorePath(
    HANDLE hToken,
    LPWSTR pwszClassStorePath
    )
{
    DWORD   err;
    LPWSTR  wszIniFilePath;

    err = GetScriptDirPath(
        hToken,
        sizeof(APPMGMT_INI_FILENAME) / sizeof(WCHAR),
        &wszIniFilePath);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

    lstrcat(wszIniFilePath, APPMGMT_INI_FILENAME);

    err = WriteClassStorePathToFile(
        wszIniFilePath,
        pwszClassStorePath);

    delete [] wszIniFilePath;

    return err;
}


LONG
CSPath::WriteClassStorePathToFile(
    WCHAR* wszIniFilePath,
    WCHAR* wszClassStorePath
    )
{
    HANDLE hFile;
    BOOL   bStatus;
    DWORD  dwWritten;

    //
    // This method attempts to write the class store path
    // into a file in a non-roaming portion of the user's profile.
    //
    // The format of the file is simple: it is a sequence of unicode
    // characters terminated by a null unicode character -- i.e.,
    // its contents are simply the exact bytes of the wszClassStorePath
    // parameter, including the terminating character.
    //
    // Clients reading the file should verify that the very last character
    // of the file is a null terminator in order to detect corrupt files.
    //

    //
    // First, attempt to open the file, creating it if it does not exist
    //
    hFile = CreateFile(
        wszIniFilePath,
        GENERIC_WRITE,
        0,    // do not allow anyone else access while we are modifying the file
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_SYSTEM,
        NULL);

    //
    // If we can't create the file, we have failed
    //
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return GetLastError();
    }

    LONG Status;

    Status = ERROR_SUCCESS;

    //
    // Now erease the data in it -- truncate the file to the current file pointer,
    // which is at the beginning of the file
    //
    bStatus = SetEndOfFile( hFile );

    //
    // If we cannot erase the current contents, this is a failure
    //
    if ( ! bStatus )
    {
        Status = GetLastError();
        goto cleanup_and_exit;
    }

    //
    // Now write the class store path into the file -- we simply do a memory copy
    // of the string into the file
    //
    bStatus = WriteFile(
        hFile,
        wszClassStorePath,
        ( lstrlen(wszClassStorePath) + 1 ) * sizeof(*wszClassStorePath),
        &dwWritten,
        NULL);

    //
    // If the write failed, find out why and return that status
    //
    if ( ! bStatus )
    {
        Status = GetLastError();
    }

cleanup_and_exit:

    //
    // Free our file resource since its no longer needed
    //
    CloseHandle( hFile );

    //
    // Everything worked, we return a success code
    //
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\logonmsg.h ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  logonmsg.h
//
//*************************************************************

#define IDS_STATUS_APPLY            1000
#define IDS_STATUS_ADVERTISE        1001
#define IDS_STATUS_INSTALL          1002
#define IDS_STATUS_UNINSTALL        1003

#define IDS_STATUS_COMPUTER_SETTINGS    1100
#define IDS_STATUS_USER_SETTINGS        1101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\events.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  events.cxx
//
//*************************************************************

#include "appmgext.hxx"

void
CEvents::Assign(
    DWORD       ErrorStatus,
    CAppInfo *  pAppInfo
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_ASSIGN_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName,
            wszStatus );

        SetRsopFailureStatus(
            pAppInfo,
            ErrorStatus,
            EVENT_APPMGMT_ASSIGN_FAILED);
    }
    else
    {
        Report(
            EVENT_APPMGMT_ASSIGN,
            FALSE,
            2,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName );
    }
}

void
CEvents::Reinstall(
    DWORD       ErrorStatus,
    CAppInfo *  pAppInfo
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_REINSTALL_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName,
            wszStatus );

        SetRsopFailureStatus(
            pAppInfo,
            ErrorStatus,
            EVENT_APPMGMT_REINSTALL_FAILED);
    }
    else
    {
        Report(
            EVENT_APPMGMT_REINSTALL,
            FALSE,
            2,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName );
    }
}

void
CEvents::Unassign(
    DWORD       ErrorStatus,
    CAppInfo *  pAppInfo
    )
{
    WCHAR   wszStatus[12];

    if ( ErrorStatus != ERROR_SUCCESS )
    {
        DwordToString( ErrorStatus, wszStatus );

        Report(
            EVENT_APPMGMT_UNASSIGN_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            3,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName,
            wszStatus );

        SetRsopFailureStatus(
            pAppInfo,
            ErrorStatus,
            EVENT_APPMGMT_UNASSIGN_FAILED);
    }
    else
    {
        Report(
            EVENT_APPMGMT_UNASSIGN,
            FALSE,
            2,
            pAppInfo->_pwszDeploymentName,
            pAppInfo->_pwszGPOName );
    }
}

void
CEvents::Upgrade(
    CAppInfo *  pNewApp,
    CAppInfo *  pOldApp,
    BOOL        bForceUninstall
    )
{
    DWORD   EventId;

    EventId = bForceUninstall ? EVENT_APPMGMT_HARD_UPGRADE : EVENT_APPMGMT_SOFT_UPGRADE;

    Report(
        EventId,
        FALSE,
        4,
        pNewApp->_pwszDeploymentName,
        pNewApp->_pwszGPOName,
        pOldApp->_pwszDeploymentName,
        pOldApp->_pwszGPOName );
}

void
CEvents::UpgradeAbort(
    DWORD       ErrorStatus,
    CAppInfo *  pNewApp,
    CAppInfo *  pOldApp,
    BOOL        bOldFailed
    )
{
    WCHAR   wszStatus[12];

    DwordToString( ErrorStatus, wszStatus );

    Report(
        bOldFailed ? EVENT_APPMGMT_UPGRADE_ABORT : EVENT_APPMGMT_UPGRADE_ABORT2,
        ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
        5,
        pNewApp->_pwszDeploymentName,
        pNewApp->_pwszGPOName,
        pOldApp->_pwszDeploymentName,
        pOldApp->_pwszGPOName,
        wszStatus );

    SetRsopFailureStatus(
        pNewApp,
        ErrorStatus,
        bOldFailed ? EVENT_APPMGMT_UPGRADE_ABORT : EVENT_APPMGMT_UPGRADE_ABORT2);
}

void
CEvents::UpgradeComplete(
    CAppInfo *  pNewApp,
    CAppInfo *  pOldApp
    )
{
    Report(
        EVENT_APPMGMT_UPGRADE_COMPLETE,
        FALSE,
        4,
        pNewApp->_pwszDeploymentName,
        pNewApp->_pwszGPOName,
        pOldApp->_pwszDeploymentName,
        pOldApp->_pwszGPOName );
}

void
CEvents::RemoveUnmanaged(
    CAppInfo *  pAppInfo
    )
{
    Report(
        EVENT_APPMGMT_REMOVE_UNMANAGED,
        FALSE,
        2,
        pAppInfo->_pwszDeploymentName,
        pAppInfo->_pwszGPOName );
}

void
CEvents::PolicyStatus(
    DWORD       ErrorStatus,
    DWORD       ErrorReason
    )
{
    WCHAR   wszStatus[12];
    WCHAR   wszReason[192];
    DWORD   Size;
    int     Status;

    if ( ErrorStatus != ERROR_SUCCESS )
    {
		if ( ! LoadLoadString() )
			return;

        DwordToString( ErrorStatus, wszStatus );

        wszReason[0] = 0;
        Size = sizeof(wszReason) / sizeof(WCHAR);

        switch ( ErrorReason )
        {
        case ERRORREASON_CSPATH :
            (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_CSPATH, wszReason, Size );
            break;
        case ERRORREASON_ENUM :
            (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_ENUM, wszReason, Size );
            break;
        case ERRORREASON_LOCAL :
            (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_LOCAL, wszReason, Size );
            break;
        case ERRORREASON_PROCESS :
            if ( ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED != ErrorStatus )
            {
                (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_PROCESS, wszReason, Size );
            }
            else
            {
                //
                // When we fail due to the need for a sync foreground refresh, we log
                // a special warning event that makes the situation very clear
                //

                //
                // The message depends on whether this is user or machine policy, so we
                // load different messages in those cases
                //
                if ( _hUserToken )
                {
                    (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_ASYNC_USER, wszReason, Size );
                }
                else
                {
                    (*pfnLoadStringW)( ghDllInstance, IDS_ERRORREASON_ASYNC_MACHINE, wszReason, Size );                    
                }
            }
            break;
        }

        Report(
            EVENT_APPMGMT_POLICY_FAILED,
            ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED == ErrorStatus,
            2,
            wszReason,
            wszStatus);
    }
    else
    {
        Report( EVENT_APPMGMT_POLICY, FALSE, 0 );
    }
}

void
CEvents::PolicyAbort()
{
    Report( EVENT_APPMGMT_POLICY_ABORT, FALSE, 0 );
}


void
CEvents::Install(
        DWORD                 ErrorStatus,
        CAppInfo*             pAppInfo
        )
{
    ( (CEventsBase*) this)->Install(
        ErrorStatus,
        pAppInfo->_pwszDeploymentName,
        pAppInfo->_pwszGPOName);

    SetRsopFailureStatus(
        pAppInfo,
        ErrorStatus,
        EVENT_APPMGMT_INSTALL_FAILED);
}

void
CEvents::Uninstall(
    DWORD                 ErrorStatus,
    CAppInfo*             pAppInfo
    )
{
    ( (CEventsBase*) this)->Uninstall(
        ErrorStatus,
        pAppInfo->_pwszDeploymentName,
        pAppInfo->_pwszGPOName);

    SetRsopFailureStatus(
        pAppInfo,
        ErrorStatus,
        EVENT_APPMGMT_UNINSTALL_FAILED);
}


void
CEvents::RsopLoggingStatus( HRESULT hrStatus )
{
    WCHAR   wszStatus[12];

    DwordToString( (DWORD) hrStatus, wszStatus );    

    Report( EVENT_APPMGMT_RSOP_FAILED, FALSE, 1, wszStatus );
}


void
CEvents::SetRsopFailureStatus(
    CAppInfo* pAppInfo,
    DWORD     dwStatus,
    DWORD     dwEventId)
{
    //
    // We only log failure status in logging (diagnostic) mode
    //
    if ( ! pAppInfo->_pManApp->GetRsopContext()->IsDiagnosticModeEnabled() )
    {
        return;
    }

    //
    // Now set the app's failure status
    //
    pAppInfo->SetRsopFailureStatus(
        dwStatus,
        dwEventId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\conflict.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 2000-2001
//  All rights reserved
//
//  conflict.cxx
//
//*************************************************************

#include "appmgext.hxx"


CConflict::CConflict( 
    CAppInfo* pAppInfo,
    CAppInfo* pWinner,
    DWORD     dwReason,
    LONG      Precedence ) :
    _pAppInfo( pAppInfo ),
    _pwszConflictId( NULL ),
    _Precedence( Precedence ),
    _PrecedenceReason( dwReason ),
    _pWinner( pWinner )
{}

CConflict::~CConflict()
{
    delete [] _pwszConflictId;
}

HRESULT 
CConflict::Write() 
{
    HRESULT hr;

    DebugMsg((DM_VERBOSE, IDS_RSOP_LOG_WRITE_INFO, GetApp()->_pwszDeploymentName, GetApp()->_pwszGPOName));

    hr = SetValue(
        RSOP_ATTRIBUTE_ID,
        _pwszConflictId);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_ID, hr )

    if (FAILED(hr))
    {
        goto CConflict_Write_cleanup;
    }

    hr = SetValue(
        RSOP_ATTRIBUTE_PRECEDENCE,
        _Precedence);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_PRECEDENCE, hr )

    if (FAILED(hr))
    {
        goto CConflict_Write_cleanup;
    }

    if ( 1 == _Precedence )
    {
        _PrecedenceReason = APP_ATTRIBUTE_REASON_VALUE_WINNING;
    }

    if ( 0 != _PrecedenceReason ) 
    {
        hr = SetValue(
            APP_ATTRIBUTE_PRECEDENCE_REASON,
            (LONG) _PrecedenceReason);
        
        REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_PRECEDENCE_REASON, hr )
    }

    if ( 0 != _Precedence )
    {
        if ( _Precedence > 1 || AlreadyExists() )
        {
            GetApp()->_dwApplyCause = APP_ATTRIBUTE_APPLYCAUSE_VALUE_NONE;

            hr = ClearValue( APP_ATTRIBUTE_APPLY_CAUSE );

            REPORT_ATTRIBUTE_SET_STATUS( APP_ATTRIBUTE_APPLY_CAUSE, hr )
        }
    }
    else
    {
        GetApp()->_dwRemovalCause = APP_ATTRIBUTE_REMOVALCAUSE_NONE;
    }
            
    hr = GetApp()->Write( this );        

CConflict_Write_cleanup:

    return S_OK;
}

HRESULT
CConflict::GetPath( WCHAR* wszPath, DWORD* pchLength )
{
    //
    // A relative path to an instance of RSOP_ApplicationManagementPolicySetting
    // looks like:
    //
    // RSOP_ApplicationManagementPolicySetting.EntryType=<entrytype>,id="<id-guid>",applicationid="<appid-guid>",precedence=<precedence>
    //
    DWORD cchRequired;

    ASSERT( ( GetApp()->GetPublicRsopEntryType() <= APP_ATTRIBUTE_ENTRYTYPE_VALUE_ARPLIST_ITEM ) &&
            ( GetApp()->GetPublicRsopEntryType() >= APP_ATTRIBUTE_ENTRYTYPE_VALUE_INSTALLED_PACKAGE ) );

    cchRequired = sizeof( RELATIVE_PATH_FORMAT ) / sizeof( WCHAR ) + // Fixed length portion
                    1 +                                              // Entry type
                    MAX_SZGUID_LEN * 2 +                             // 2 guids
                    9;                                               // Precedence = 1

    if ( cchRequired <= *pchLength )
    {
        WCHAR  wszDeploymentId[ MAX_SZGUID_LEN ];
        WCHAR* wszApplicationId;

        LONG  lPrecedence;
        LONG  EntryType;

        if ( GetApp()->_bRemovalLogged )
        {
            EntryType = APP_ATTRIBUTE_ENTRYTYPE_VALUE_REMOVED_PACKAGE;
            lPrecedence = 0;
        }
        else
        {
            EntryType = GetApp()->GetPublicRsopEntryType();
            lPrecedence = 1;
        }

        GuidToString( GetApp()->_DeploymentId, wszDeploymentId );

        //
        // Since we are only using precedence 1 applications, the application id
        // happens to be the same as the id
        //
        wszApplicationId = wszDeploymentId;

        swprintf( 
            wszPath,
            RELATIVE_PATH_FORMAT, 
            EntryType,
            wszDeploymentId,
            wszApplicationId,
            lPrecedence);
    }
    else
    {
        *pchLength = cchRequired;

        return S_FALSE;
    }
            
    return S_OK;
}



HRESULT
CConflict::SetConflictId( WCHAR* pwszConflictId )
{
    HRESULT hr;

    hr = ERROR_SUCCESS;

    ASSERT ( ! _pwszConflictId );

    _pwszConflictId = StringDuplicate( pwszConflictId );

    if ( ! _pwszConflictId )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


CConflictList::~CConflictList()
{
    CConflict* pConflict;

    Reset();
    
    for ( Reset(); pConflict = (CConflict*) GetCurrentItem(); )
    {
        MoveNext();

        pConflict->Remove();

        delete pConflict;
    }
}

LONG
CConflictList::AddConflict( CAppInfo* pAppInfo, CAppInfo* pWinner, DWORD dwReason, LONG Precedence )
{
    CConflict* pNewConflict;

    pNewConflict = new CConflict( pAppInfo, pWinner, dwReason, Precedence );

    if ( ! pNewConflict )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InsertFIFO( pNewConflict );

    return ERROR_SUCCESS;
}

CConflictTable::CConflictTable() :
    _pLastConflict( NULL )
{}

void
CConflictTable::Reset()
{
    _pLastConflict = NULL;

    _SupersededApps.Reset();
}


LONG
CConflictTable::AddConflict(
    CAppInfo* pAppInfo,
    CAppInfo* pWinner,
    DWORD     dwReason,
    LONG      Prececence )
{
    return _SupersededApps.AddConflict( pAppInfo, pWinner, dwReason );
}

CConflict*
CConflictTable::GetNextConflict( LONG* pCurrentPrecedence )
{
    CConflict* pNextConflict;

    pNextConflict = NULL;       

    //
    // If we're at the end, leave
    //
    if ( ! _pLastConflict && ! _SupersededApps.GetCurrentItem() )
    {
        return NULL;
    }

    //
    // Try to traverse the last conflict to find the next conflict
    //
    if ( _pLastConflict )
    {
        //
        // The precedence of the next application should be one more
        // than the last conflict
        //
        pNextConflict = _pLastConflict->GetApp()->GetConflictTable()->GetNextConflict( pCurrentPrecedence );

        if ( pNextConflict )
        {
            (*pCurrentPrecedence)++; 
        }
    }

    if ( ! pNextConflict )
    {
        //
        // If we did not find a conflict as a result of the previous conflict,
        // let's try the next item in our conflict list
        //
        pNextConflict = (CConflict*) ( _SupersededApps.GetCurrentItem() );

        _SupersededApps.MoveNext();

        if ( pNextConflict )
        {
            pNextConflict->GetApp()->GetConflictTable()->Reset();
        }
    }

    _pLastConflict = pNextConflict;

    //
    // We are finished calculating the precedence and may now
    // set the final precedence value
    //
    if ( pNextConflict )
    {
        pNextConflict->_Precedence = *pCurrentPrecedence;
    }

    return pNextConflict;
}

LONG
CConflictTable::GenerateResultantConflictList( CConflictList* pConflictList )
{
    CConflict* pConflict;
    LONG       Status;
    LONG       Precedence;

    Precedence = 2;

    Status = ERROR_SUCCESS;

    Reset();

    while ( pConflict = GetNextConflict( &Precedence ) )
    {
        Status = pConflictList->AddConflict( 
            pConflict->GetApp(),
            pConflict->_pWinner,
            pConflict->_PrecedenceReason,
            pConflict->_Precedence);

        if ( ERROR_SUCCESS != Status )
            break;

        Precedence = pConflict->_Precedence;
    }
     
    return Status;
}

HRESULT
CConflict::LogFailure()
{
    //
    // We only log status for settings
    // with failures
    //
    CAppStatus* pAppStatus;

    //
    // First, see if this setting (app) has a status
    //
    pAppStatus = (CAppStatus*) GetApp()->_StatusList.GetCurrentItem();

    if ( ! pAppStatus )
    {
        return S_FALSE;
    }

    //
    // Advance the list to the next failure so
    // that the next caller will log a different failure
    //
    GetApp()->_StatusList.MoveNext();

    //
    // Skip this status if this is not a failure
    //
    if ( RSOPFailed != pAppStatus->_SettingStatus )
    {
        return S_OK;
    }

    HRESULT        hr;
    IWbemServices* pWbemServices;

    //
    // Bind to WMI -- this is essentially no op in policy refresh
    //
    hr = GetApp()->_pManApp->GetRsopContext()->Bind( &pWbemServices );

    if ( SUCCEEDED(hr) )
    {
        POLICYSETTINGSTATUSINFO SettingStatus;
        
        memset( &SettingStatus, 0, sizeof( SettingStatus ) );

        SettingStatus.szEventSource = APPMGMT_EVENT_SOURCE;
        SettingStatus.szEventLogName = L"Application";
        SettingStatus.dwEventID = pAppStatus->_dwEventId;
        SettingStatus.dwErrorCode = ERROR_SUCCESS;
        SettingStatus.status = pAppStatus->_SettingStatus;
        SettingStatus.timeLogged = pAppStatus->_StatusTime;
        
        hr = RsopSetPolicySettingStatus(
            0,
            pWbemServices,
            GetRecordInterface(),
            1,
            &SettingStatus);
    }

    if ( FAILED(hr) )
    {
        REPORT_ATTRIBUTE_SET_STATUS( L"Policy Setting Status", hr )
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\manapp.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  manapp.cxx
//
//*************************************************************

#include "appmgext.hxx"

#pragma warning(disable:4355)

CManagedAppProcessor::CManagedAppProcessor(
        DWORD             dwFlags,
        HANDLE            hUserToken,
        HKEY              hKeyRoot,
        PFNSTATUSMESSAGECALLBACK pfnStatusCallback,
        BOOL              bIncludeLegacy,
        BOOL              bRegularPolicyRun,
        CRsopAppContext*  pRsopContext,
        DWORD &           Status
    ) : _Apps( this, &_RsopContext ), _LocalScripts( this ), _pfnStatusCallback(pfnStatusCallback)
{
    DWORD   Size;
    DWORD   LastArchLang;
    BOOL    bFullPolicy;
    HRESULT hr;

    _bUser = ! (dwFlags & GPO_INFO_FLAG_MACHINE);
    _bNoChanges = (dwFlags & GPO_INFO_FLAG_NOCHANGES) && ! (gDebugLevel & DL_APPLY) && ! ( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION );
    _bAsync = (dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND) && ! (gDebugLevel & DL_APPLY) && ! ( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION );
    _bARPList = FALSE;
    _hkRoot = 0;
    _hkClasses = 0;
    _hkPolicy = 0;
    _hkAppmgmt = 0;
    _hUserToken = 0;
    _NewUsn = 0;
    _ArchLang = 0;
    
    _pwszLocalPath = 0;
    
    _bIncludeLegacy = bIncludeLegacy;
    _bDeleteGPOs = FALSE;
    _bRegularPolicyRun = bRegularPolicyRun;
    _ErrorReason = 0;

    //
    // In the case of gpo removal, we cannot apply this during an async refresh
    //
    if ( _bAsync  && ! bRegularPolicyRun )
    {
        _ErrorReason = ERRORREASON_PROCESS;
        
        DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));

        Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;

        return;
    }
    
    if ( CRsopAppContext::POLICY_REFRESH == pRsopContext->GetContext() )
    {
        if ( _bAsync )
        {
            DebugMsg((DM_VERBOSE, IDS_ASYNC_REFRESH));
        }
        else
        {
            DebugMsg((DM_VERBOSE, IDS_SYNC_REFRESH));
        }
    }

    hr = GetRsopContext()->MoveAppContextState( pRsopContext );

    if ( FAILED( hr ) )
    {
        Status = GetWin32ErrFromHResult( hr );
        goto CManagedAppProcessor__CManagedAppProcessor_Exit;
    }

    if ( _bUser && ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( ! DuplicateToken( hUserToken, SecurityImpersonation, &_hUserToken ) )
        {
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;
        }
    }

    //
    // Act as if there are changes when planning mode is enabled
    //
    if ( GetRsopContext()->IsPlanningModeEnabled() )
    {
        _bNoChanges = FALSE;
    }

    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        Status = RegOpenKeyEx(
            hKeyRoot,
            NULL,
            0,
            KEY_READ | KEY_WRITE,
            &_hkRoot );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;

        Status = RegCreateKeyEx(
            _hkRoot,
            POLICYKEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &_hkPolicy,
            NULL );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;

        Status = RegCreateKeyEx(
            _hkPolicy,
            APPMGMTSUBKEY,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &_hkAppmgmt,
            NULL );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;

        Status = RegOpenKeyEx(
            _hkRoot,
            L"Software\\Classes",
            0,
            KEY_READ | KEY_WRITE,
            &_hkClasses );

        if ( Status != ERROR_SUCCESS )
            goto CManagedAppProcessor__CManagedAppProcessor_Exit;
    }

    BOOL        bForcedRefresh;

    bForcedRefresh = FALSE;

    if ( bRegularPolicyRun )
    {
        SYSTEM_INFO SystemInfo;

        //
        // The service sets the FULLPOLICY value when the user does an uninstall.
        // This forces us to do a full policy run to pick up any new app that may
        // need to be applied now.
        //

        bFullPolicy = FALSE;
        Size = sizeof( bFullPolicy );

        if (!GetRsopContext()->IsPlanningModeEnabled())
        {
            (void) RegQueryValueEx(
                _hkAppmgmt,
                FULLPOLICY,
                NULL,
                NULL,
                (LPBYTE) &bFullPolicy,
                &Size );
            (void) RegDeleteValue( _hkAppmgmt, FULLPOLICY );

            if ( _bNoChanges )
            {
                bForcedRefresh = bFullPolicy;
            }
        }
        else
        {
            bFullPolicy = TRUE;
        }

        if ( bFullPolicy )
            _bNoChanges = FALSE;

        _ArchLang = GetSystemDefaultLangID();
        GetSystemInfo( &SystemInfo );
        _ArchLang |= (SystemInfo.wProcessorArchitecture << 16);

        if (!GetRsopContext()->IsPlanningModeEnabled())
        {
            Size = sizeof( LastArchLang );

            Status = RegQueryValueEx(
                _hkAppmgmt,
                LASTARCHLANG,
                NULL,
                NULL,
                (LPBYTE) &LastArchLang,
                &Size );

            if ( (ERROR_SUCCESS == Status) && _bNoChanges && (_ArchLang != LastArchLang) )
            {
                if ( _bNoChanges )
                {
                    bForcedRefresh = TRUE;
                }

                _bNoChanges = FALSE;

                if ( Async() )
                {
                    DebugMsg((DM_VERBOSE, IDS_ABORT_OPERATION));
                }
            }
        }
    }

    Status = GetScriptDirPath( _bUser ? _hUserToken : NULL, 0, &_pwszLocalPath );

    if ( ERROR_SUCCESS == Status && ! GetRsopContext()->IsPlanningModeEnabled() )
        Status = CreateAndSecureScriptDir();

    if ( (ERROR_SUCCESS == Status) && ! GetRsopContext()->IsPlanningModeEnabled() )
        Status = GetLocalScriptAppList( _LocalScripts );

    if ( Status != ERROR_SUCCESS )
    {
        DebugMsg((DM_WARNING, IDS_CREATEDIR_FAIL, Status));
        goto CManagedAppProcessor__CManagedAppProcessor_Exit;
    }

    if ( _bNoChanges )
    {
        if ( DetectLostApps() )
        {
            bForcedRefresh = TRUE;
            _bNoChanges = FALSE;
        }
    }

    //
    // Ensure that the rsop context is properly initialized, even if the
    // group policy engine did not give us a context but we need to log data
    //
    (void) GetRsopContext()->InitializeRsopContext(
        UserToken(),
        AppmgmtKey(),
        bForcedRefresh,
        &_bNoChanges);
    
CManagedAppProcessor__CManagedAppProcessor_Exit:

    return;
}

#pragma warning(default:4355)

CManagedAppProcessor::~CManagedAppProcessor()
{
    if ( _hkPolicy )
        RegCloseKey( _hkPolicy );

    if ( _hkAppmgmt )
        RegCloseKey( _hkAppmgmt );

    if ( _hkClasses )
        RegCloseKey( _hkClasses );

    if ( _hkRoot )
        RegCloseKey( _hkRoot );

    if ( _hUserToken )
        CloseHandle( _hUserToken );

    delete _pwszLocalPath;
}

BOOL
CManagedAppProcessor::AddGPO(
    PGROUP_POLICY_OBJECT pGPOInfo
    )
{
    CGPOInfo *  pGPO;
    BOOL        bStatus;

    //
    // Prevent duplicates in the list.  A GPO could be linked to multiple
    // OUs, so only keep the last instance of a policy.
    //
    pGPO = _GPOs.Find( pGPOInfo->szGPOName );
    if ( pGPO )
    {
        pGPO->Remove();
        delete pGPO;
    }

    return _GPOs.Add( pGPOInfo );
}

DWORD
CManagedAppProcessor::Delete()
{
    DWORD Status;

    _bDeleteGPOs = TRUE;

    ASSERT( ! Async() );

    Status = GetRemovedApps();

    if ( Status != ERROR_SUCCESS )
    {
        _ErrorReason = ERRORREASON_LOCAL;
        return Status;
    }

    _CSPath.Commit(_hUserToken);

    Status = _Apps.ProcessPolicy();

    if ( Status != ERROR_SUCCESS )
        _ErrorReason = ERRORREASON_PROCESS;

    return Status;
}

DWORD
CManagedAppProcessor::GetRemovedApps()
{
    CAppList    LocalApps( NULL );
    CGPOInfo *  pGPOInfo;
    CAppInfo *  pAppInfo;
    DWORD       Status;

    Status = GetOrderedLocalAppList( LocalApps );

    if ( ERROR_SUCCESS == Status )
        Status = Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    _GPOs.Reset();

    for ( pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem();
          pGPOInfo;
          _GPOs.MoveNext(), pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem() )
    {
        DebugMsg((DM_VERBOSE, IDS_REMOVE_POLICY, pGPOInfo->_pwszGPOName));

        LocalApps.Reset();

        for ( pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem();
              pAppInfo;
              pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem() )
        {
            //
            // Look for apps in the removed policy.
            //
            // Ignore apps which are not currently assigned or published from the removed
            // policy except for apps which have been uninstalled from machines other
            // than this one.  This is what the second logic check is doing.  In this case
            // we have to uninstall it at this machine as well.
            //
            if ( ! (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_UNINSTALLED)) ||
                 ((pAppInfo->_State & APPSTATE_UNINSTALLED) && ! (pAppInfo->_State & APPSTATE_SCRIPT_PRESENT)) ||
                 (lstrcmpi( pAppInfo->_pwszGPOId, pGPOInfo->_pwszGPOId ) != 0) )
            {
                LocalApps.MoveNext();
                continue;
            }

            //
            // On very rare occasion, a policy could be removed at the same time a
            // first time logon to a machine is made.  In this case we will need
            // to copy scripts for uninstalled apps.  We attempt to get the script
            // path here.  This may fail for permission reasons, if the policy
            // is being removed, it's likely it will not be accessible for this
            // user/machine.
            //
            if ( (pAppInfo->_State & APPSTATE_POLICYREMOVE_UNINSTALL) &&
                 ! (pAppInfo->_State & APPSTATE_SCRIPT_PRESENT) )
            {
                PACKAGEDISPINFO PackageInfo;
                HRESULT         hr;

                hr = GetDsPackageFromGPO(
                    pGPOInfo,
                    &(pAppInfo->_DeploymentId),
                    &PackageInfo);

                if ( S_OK == hr )
                {
                    pAppInfo->_pwszGPTScriptPath = StringDuplicate( PackageInfo.pszScriptPath );
                    ReleasePackageInfo( &PackageInfo );
                    if ( ! pAppInfo->_pwszGPTScriptPath )
                    {
                        Revert();
                        return ERROR_OUTOFMEMORY;
                    }
                }
            }

            if ( pAppInfo->_State & APPSTATE_POLICYREMOVE_UNINSTALL )
            {
                pAppInfo->SetAction( 
                    ACTION_UNINSTALL,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);
            }
            else
            {
                pAppInfo->SetAction(
                    ACTION_ORPHAN,
                    APP_ATTRIBUTE_REMOVALCAUSE_SCOPELOSS,
                    NULL);
            }

            LocalApps.MoveNext();
            pAppInfo->Remove();
            _Apps.InsertFIFO( pAppInfo );
        }

        LocalApps.ResetEnd();
    }

    _GPOs.ResetEnd();

    Revert();

    return Status;
}

DWORD
CManagedAppProcessor::Process()
{
    CGPOInfo *  pGPOInfo;
    DWORD       Status;

    Status = Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    for ( _GPOs.Reset(); pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem(); _GPOs.MoveNext() )
    {
        Status = _CSPath.AddComponent( pGPOInfo->_pwszGPOPath, pGPOInfo->_pwszGPOName );
        if ( Status != ERROR_SUCCESS )
            break;
    }

    Revert();

    _GPOs.ResetEnd();
        
    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( ERROR_SUCCESS == Status ) 
        {
            Status = _CSPath.Commit( _hUserToken );
        }

        if ( Status != ERROR_SUCCESS )
        {
            if ( CS_E_NO_CLASSSTORE == Status )
            {
                return ERROR_SUCCESS;
            }
            else
            {
                _ErrorReason = ERRORREASON_CSPATH;
                return Status;
            }
        }
    }

    if ( _bNoChanges )
    {
        DebugMsg((DM_VERBOSE, IDS_NOCHANGES));
    }
    else
    {
        if ( ! GetRsopContext()->IsPlanningModeEnabled() )
        {
            LogonMsgApplying();
        }

        // Really returns an HRESULT.
        Status = (DWORD) GetAppsFromDirectory();

        if ( Status != ERROR_SUCCESS )
            _ErrorReason = ERRORREASON_ENUM;
    }

    if ( ERROR_SUCCESS == Status )
        Status = GetAppsFromLocal();

    if ( ERROR_SUCCESS == Status )
        Status = CommitPolicyList();

    if ( ERROR_SUCCESS == Status )
        Status = GetLostApps();

    if ( Status != ERROR_SUCCESS )
        _ErrorReason = ERRORREASON_LOCAL;

    if ( ERROR_SUCCESS == Status )
        Status = _Apps.ProcessPolicy();

    if ( Status != ERROR_SUCCESS )
        _ErrorReason = ERRORREASON_PROCESS;

    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( (ERROR_SUCCESS == Status) && (_ArchLang != 0) )
        {
            (void) RegSetValueEx(
                _hkAppmgmt,
                LASTARCHLANG,
                0,
                REG_DWORD,
                (LPBYTE) &_ArchLang,
                sizeof(_ArchLang) );
        }

        if ( ! _bNoChanges )
            LogonMsgDefault();
    }

    //
    // If we are processing asynchronously and changes are detected,
    // we should ensure that a synchronous refresh occurs next time
    //
    if ( ( ERROR_SUCCESS == Status ) && Async() &&
         ! _bNoChanges ) 
    {
        Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
    }

    return Status;
}

void
CManagedAppProcessor::WriteRsopLogs()
{
    HRESULT hr;
    BOOL    ResultantSetChanged;
    
    hr = S_OK;

    //
    // By default, the resultant set changes only if policy has changed
    //
    ResultantSetChanged = ! _bNoChanges;

#if DBG
    DWORD   DebugStatus;
#endif // DBG

    //
    // If we're in diagnostic mode, make sure we reset
    // the diagnostic namespace if policy has changed
    //
    if ( 
        ( GetRsopContext()->IsDiagnosticModeEnabled() && ResultantSetChanged ) &&
         ( CRsopAppContext::POLICY_REFRESH == GetRsopContext()->GetContext() ) )
    {
        if ( ! GetRsopContext()->IsPlanningModeEnabled() && ! GetRsopContext()->ForcedRefresh() )
        {
            //
            // Reset the namespace
            //
            GetRsopContext()->DeleteSavedNameSpace();
        }
    }

    //
    // For ARP, ensure that no one tries to read the namespace to
    // which we are logging until we are finished. 
    //
    if ( ARPList() )
    {
        hr = GetRsopContext()->GetExclusiveLoggingAccess( NULL == UserToken() );
    }

    //
    // First, make sure rsop logging is enabled
    //
    if ( SUCCEEDED(hr) && GetRsopContext()->IsRsopEnabled() )
    {
        if ( ResultantSetChanged )
        {
            hr = _Apps.WriteLog();

            if (FAILED(hr))
            {
                GetRsopContext()->DisableRsop( hr );
            }
        }
        else
        {
            //
            // Disable rsop if there are no changes -- there is nothing
            // to log
            //
            GetRsopContext()->DisableRsop( S_OK );
        }
    }

    if ( GetRsopContext()->IsRsopEnabled() && 
         GetRsopContext()->IsPlanningModeEnabled() &&
         ARPList() )
    {
        CCategoryInfoLog CategoryLog( GetRsopContext(), NULL); 

        hr = CategoryLog.WriteLog();

        if (FAILED(hr))
        {
            GetRsopContext()->DisableRsop( hr );
        }
    }

    //
    // We will not set ARP's logging namespace if logging is not enabled
    //
    if ( GetRsopContext()->IsRsopEnabled() && ! GetRsopContext()->ForcedRefresh() )
    {
        //
        // First, record the namespace so that app management
        // service can perform rsop logging
        //
        if ( ! ARPList() && ! GetRsopContext()->IsPlanningModeEnabled() )
        {
            (void) GetRsopContext()->SaveNameSpace();

            //
            // For users, whose apps will roam if they have a user profile,
            // write a version into the profile so we can determine if their 
            // profile is in sync with the machine's current rsop data -- this
            // gets updated at each policy run and each time an app is installed
            //
            if ( IsUserPolicy() )
            {
                (void) GetRsopContext()->WriteCurrentRsopVersion( AppmgmtKey() );
            }
        }
    }

    //
    // For ARP, we are now finished logging and users may read
    // the logged data now -- release our lock
    //
    if ( ARPList() )
    {
        (void) GetRsopContext()->ReleaseExclusiveLoggingAccess();
    }
}

HRESULT
CManagedAppProcessor::GetAppsFromDirectory()
{
    IEnumPackage *  pEnumPackage;
    DWORD           Size;
    DWORD           Type;
    DWORD           AppFlags;
    DWORD           Status;
    HRESULT         hr;

    Status = Impersonate();
    if ( Status != ERROR_SUCCESS )
        return HRESULT_FROM_WIN32( Status );

    //
    // Determine what apps to ask the Diretory for
    //
    AppFlags = GetDSQuery();

    if ( DebugLevelOn( DM_VERBOSE ) )
    {
        WCHAR Name[32];
        DWORD NameLength =  sizeof(Name) / sizeof(WCHAR);

        Name[0] = 0;

        if ( _bUser )
        {
            if ( ! GetUserName( Name, &NameLength) )
            {   
                if ( LoadLoadString() )
                    (*pfnLoadStringW)( ghDllInstance, IDS_UNKNOWN, Name, NameLength );
            }

            DebugMsg((DM_VERBOSE, IDS_USERAPPS_NOCAT, Name, AppFlags));
        }
        else
        {
            if ( ! GetComputerName( Name, &NameLength) )
            {
                if ( LoadLoadString() )
                    (*pfnLoadStringW)( ghDllInstance, IDS_UNKNOWN, Name, NameLength );
            }

            DebugMsg((DM_VERBOSE, IDS_MACHINEAPPS, Name, AppFlags));
        }
    }

    //
    // If we are not in planning mode, we can use a function that uses
    // the cached class store ds paths to determine which parts of the
    // ds to query -- this function obtains an enumerator that returns
    // query results from the cached ds paths
    //
    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        hr = CsEnumApps(
            NULL,
            NULL,
            NULL,
            AppFlags,
            &pEnumPackage );
    }
    else
    {
        //
        // In planning mode, we have no cached ds paths and must explicitly
        // specify it in order to obtain an enumerator
        //
        hr = GetPackageEnumeratorFromPath(
            _CSPath.GetPath(),
            NULL,
            AppFlags,
            &pEnumPackage);
    }

    if ( S_OK == hr )
    {
        hr = EnumerateApps(pEnumPackage);
        pEnumPackage->Release();
    }
    else
    {
        DebugMsg((DM_WARNING, IDS_CSENUMAPPS_FAIL, hr));
    }

    Revert();

    return hr;
}

HRESULT
CManagedAppProcessor::EnumerateApps(
    IEnumPackage * pEnumPackages
    )
{
    PACKAGEDISPINFO rgPackages[PACKAGEINFO_ALLOC_COUNT];
    ULONG       cRetrieved;
    CAppList    AppList( this );
    CAppInfo *  pAppInfo;
    CAppInfo *  pAppInfoOldest;
    CGPOInfo *  pGPOInfo;
    WCHAR *     pwszGPOName;
    DWORD       AppCount;
    HRESULT     hr;
    BOOL        bStatus;

    memset( rgPackages, 0, sizeof(rgPackages) );

    for (;;)
    {
        hr = pEnumPackages->Next(
            PACKAGEINFO_ALLOC_COUNT,
            rgPackages,
            &cRetrieved);

        if ( FAILED(hr) )
            return hr;

        // This call only fails on out of memory.
        bStatus = AddAppsFromDirectory( cRetrieved, rgPackages, AppList );

        for ( DWORD n = 0; n < cRetrieved; n++ )
            ReleasePackageInfo( &rgPackages[n] );

        if ( ! bStatus )
            return E_OUTOFMEMORY;

        if ( hr == S_FALSE )
            break;
    }

    //
    // Now that we have all the packages from the DS, we sort them within each policy
    // from oldest to newest deployment time and put them in our final app list.
    //
    for ( _GPOs.Reset(); pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem(); _GPOs.MoveNext() )
    {
        pwszGPOName = 0;
        AppCount = 0;

        for (;;)
        {
            pAppInfoOldest = 0;

            for ( AppList.Reset(); pAppInfo = (CAppInfo *) AppList.GetCurrentItem(); AppList.MoveNext() )
            {
                if ( lstrcmpi( pGPOInfo->_pwszGPOId, pAppInfo->_pwszGPOId ) != 0 )
                    break;

                if ( ! pAppInfoOldest ||
                     (CompareFileTime( &pAppInfo->_USN, &pAppInfoOldest->_USN ) < 0) )
                {
                    pAppInfoOldest = pAppInfo;
                }
            }

            AppList.ResetEnd();

            if ( ! pAppInfoOldest )
                break;

            if ( 0 == AppCount )
            {
                pwszGPOName = pAppInfoOldest->_pwszGPOName;
                DebugMsg((DM_VERBOSE, IDS_GPOAPPS, pwszGPOName));
            }

            AppCount++;

            if ( DebugLevelOn( DM_VERBOSE ) )
            {
                if ( pAppInfoOldest->_ActFlags & ACTFLG_Assigned )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDASSIGNED, pAppInfoOldest->_pwszDeploymentName, pAppInfoOldest->_ActFlags));
                }
                else if ( pAppInfoOldest->_ActFlags & ACTFLG_Published )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDPUBLISHED, pAppInfoOldest->_pwszDeploymentName, pAppInfoOldest->_ActFlags));
                }
                else if ( pAppInfoOldest->_ActFlags & ACTFLG_Orphan )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDORPHANED, pAppInfoOldest->_pwszDeploymentName));
                }
                else if ( pAppInfoOldest->_ActFlags & ACTFLG_Uninstall )
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDUNINSTALLED, pAppInfoOldest->_pwszDeploymentName));
                }
                else
                {
                    DebugMsg((DM_VERBOSE, IDS_ADDUNKNOWN, pAppInfoOldest->_pwszDeploymentName));
                }
            }

            pAppInfoOldest->Remove();
            _Apps.InsertFIFO( pAppInfoOldest );
        }

        if ( AppCount > 0 )
            DebugMsg((DM_VERBOSE, IDS_NUMAPPS, AppCount, pwszGPOName));
    }
    _GPOs.ResetEnd();

    return S_OK;
}

BOOL
CManagedAppProcessor::AddAppsFromDirectory(
    ULONG               cApps,
    PACKAGEDISPINFO *   rgPackageInfo,
    CAppList &          AppList
    )
{
    CAppInfo *  pAppInfo;
    BOOL        bStatus;

    for ( DWORD App = 0; App < cApps; App++)
    {
        switch ( rgPackageInfo[App].PathType )
        {
        case DrwFilePath :
            break;
        case SetupNamePath :
            if ( ! _bIncludeLegacy )
                continue;
            break;
        default :
            continue;
        }

    bStatus = FALSE;

        pAppInfo = new CAppInfo( this, &(rgPackageInfo[App]), FALSE, bStatus );

        if ( ! bStatus )
        {
            if ( pAppInfo )
                delete pAppInfo;
            pAppInfo = 0;
        }

        if ( ! pAppInfo )
            return FALSE;

        AppList.InsertLIFO( pAppInfo );
    }

    return TRUE;
}

DWORD
CManagedAppProcessor::GetDSQuery()
{
    DWORD AppFlags;

    //
    // We perform different queries depending on whether or not RSoP
    // is enabled as well as whether we are doing a query for the
    // ARP list of apps or for a policy run
    //
    if ( GetRsopContext()->IsRsopEnabled() )
    {
        if (ARPList())
        {
            AppFlags = APPQUERY_RSOP_ARP;
        }
        else
        {
            AppFlags = APPQUERY_RSOP_LOGGING;
        }
    }
    else
    {
        if (ARPList())
        {
            AppFlags = APPQUERY_USERDISPLAY;
        }
        else
        {
            AppFlags = APPQUERY_POLICY;
        }
    }

    return AppFlags;
}

DWORD
CManagedAppProcessor::GetManagedApplications(
    GUID *              pCategory,
    ARPCONTEXT*         pArpContext /* allocated on separate waiting thread */
    )
{
    WCHAR                wszCategoryGuid[40];
    DWORD                Status;
    BOOL                 bStatus;
    MANAGED_APPLIST *    pAppList;

    _bARPList = TRUE;

    //
    // *********IMPORTANT********
    // Note that we should not access the pArpContext structure after we've signaled
    // that enumeration is complete using the hEventAppsEnumerated member --
    // otherwise, the stack on which this structure is allocated will disappear
    // once its thread unblocks waiting for us
    //

    pAppList = pArpContext->pAppList;

    Status = ERROR_SUCCESS;

    //
    // GPO precedence list is needed for sorting the apps based on USN
    // and because the upgrade processing logic requires having the GPO
    // precedence list.
    //
    if ( ! GetRsopContext()->IsPlanningModeEnabled() )
    {
        Status = LoadPolicyList();
    }
    else
    {
        CGPOInfo* pGPOInfo;

        for ( _GPOs.Reset(); pGPOInfo = (CGPOInfo *) _GPOs.GetCurrentItem(); _GPOs.MoveNext() )
        {
            Status = _CSPath.AddComponent( pGPOInfo->_pwszGPOPath, pGPOInfo->_pwszGPOName );
            if ( Status != ERROR_SUCCESS )
                break;
        }
    }

    if ( ERROR_SUCCESS == Status )
        Status = GetAppsFromDirectory();

    //
    // Not all managed applications should be visible to the caller --
    // filter out the ones the caller doesn't want
    //
    if ( ERROR_SUCCESS == Status )
        Status = _Apps.ProcessARPList();

    if ( ( Status != ERROR_SUCCESS ) || 
         GetRsopContext()->IsPlanningModeEnabled() )
    {
        goto GetManagedApplications_WriteLogsAndExit;
    }

    if ( pCategory )
    {
        GuidToString( *pCategory, wszCategoryGuid );
        DebugMsg((DM_VERBOSE, IDS_USERAPPS_CAT, wszCategoryGuid));
    }

    //
    // Now that we have the correct list of apps,
    // we need to allocate space for all the apps
    // and copy the data for each app to give back to the user
    //

    //
    // First we must count the number of apps we're giving back.
    //
    // We also determine which apps have common display names and tag them
    // to have their policy name catenated to their display names.
    //

    DWORD dwCount;
    CAppInfo * pAppInfo;
    CAppInfo * pAppInfoOther;

    dwCount = 0;
    _Apps.Reset();

    for ( pAppInfo = (CAppInfo *) _Apps.GetCurrentItem();
          pAppInfo;
          _Apps.MoveNext(), pAppInfo = (CAppInfo *) _Apps.GetCurrentItem() )
    {
        if ( (pAppInfo->_Action != ACTION_INSTALL) )
            continue;
        if ( pCategory && ! pAppInfo->HasCategory( wszCategoryGuid ) )
        {
            pAppInfo->SetAction(
                ACTION_UNINSTALL,
                0,
                NULL);

            continue;
        }

        dwCount++;
    }

    _Apps.ResetEnd();

    //
    // Now that we know how many apps we have, we can allocate
    // space for them.
    //

    pAppList->rgApps = (MANAGED_APP*) midl_user_allocate( sizeof(MANAGED_APP) * dwCount);

    if (!(pAppList->rgApps))
        return ERROR_NOT_ENOUGH_MEMORY;

    memset(pAppList->rgApps, 0, dwCount * sizeof(MANAGED_APP));

    //
    // Now we do the copying
    //
    DWORD dwApp;

    dwApp = 0;
    _Apps.Reset();

    for (;;)
    {
        CAppInfo* pAppInfo;

        pAppInfo = (CAppInfo *) _Apps.GetCurrentItem();

        if ( ! pAppInfo )
            break;

        _Apps.MoveNext();

        if ( ACTION_INSTALL == pAppInfo->_Action) 
        {
            Status = pAppInfo->CopyToManagedApplication(&(pAppList->rgApps[dwApp]));

            if ( Status != ERROR_SUCCESS )
                break;

            dwApp++;
        }
    }

    _Apps.ResetEnd();

    if ( Status != ERROR_SUCCESS )
    {
        DWORD dwCopiedApp;

        //
        // On failure, we need to clear any apps we allocated
        // before the failure occurred
        //
        for ( dwCopiedApp = 0; dwCopiedApp < dwApp; dwCopiedApp++ )
        {
            ClearManagedApp( & ( pAppList->rgApps[ dwCopiedApp ] ) );
        }

        midl_user_free( pAppList->rgApps );
        pAppList->rgApps = 0;
        return Status;
    }

    pAppList->Applications = dwApp;

GetManagedApplications_WriteLogsAndExit:

    //
    // Store the status of this operation in the waiting thread's context --
    // note that this is the last time we can safely access this structure
    // since we will next signal its thread to unblock, and the stack
    // frame in which this structure is allocated will disappear
    //
    pArpContext->Status = Status;

    //
    // Signal the waiting thread that we are finished enumerating
    //
    GetRsopContext()->SetAppsEnumerated();

    //
    // Write any Rsop logs -- this is a no op if
    // rsop logging is not enabled
    //
    WriteRsopLogs();

    return Status;
}

DWORD
CManagedAppProcessor::GetAppsFromLocal()
{
    CAppList        LocalApps( NULL );
    CAppInfo *      pAppInfo;
    CAppInfo *      pAppInfoInsert;
    CAppInfo *      pScriptInfo;
    int             GPOCompare;
    DWORD           Count;
    DWORD           Status;
    HRESULT         hr;
    BOOL            bStatus;

    if ( GetRsopContext()->IsPlanningModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    Status = GetOrderedLocalAppList( LocalApps );

    if ( ERROR_SUCCESS == Status )
        Status = Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    Count = 0;

    LocalApps.Reset();

    for ( pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem();
          pAppInfo;
          pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem() )
    {
        //
        // Remember which scripts are associated with app entries we find 
        // in the registry.  We'll use this later as a hint to detect roaming 
        // profile merge problems with our app entries in hkcu.
        //
        pScriptInfo = _LocalScripts.Find( pAppInfo->_DeploymentId );
        if ( pScriptInfo )
            pScriptInfo->_State = APPSTATE_SCRIPT_PRESENT;

        if ( _Apps.Find( pAppInfo->_DeploymentId ) != NULL )
        {
            LocalApps.MoveNext();
            continue;
        }

        if ( pAppInfo->_State & APPSTATE_ASSIGNED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALASSIGN_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( pAppInfo->_State & APPSTATE_PUBLISHED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALPUBLISHED_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( pAppInfo->_State & APPSTATE_ORPHANED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALORPHAN_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( pAppInfo->_State & APPSTATE_UNINSTALLED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALUNINSTALL_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }

        LocalApps.MoveNext();
        pAppInfo->Remove();
        Count++;

        //
        // If this app is currently applied, check it's real state in the DS.  We
        // didn't get in the query results either because it didn't match the search
        // criteria or because it really did go out of scope.  Currently applied apps include
        // those listed in the registry as published or assigned, as well as those listed
        // in the registry as unmanaged or uninstalled that currently have a script present
        // on this machine.
        // In the case of no-changes, we have to query for published apps which we
        // don't have scripts for so that we can retrieve the proper sysvol path to
        // get the script.
        //
        if ( (! _bNoChanges && (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED))) ||
             (_bNoChanges && (pAppInfo->_State & APPSTATE_PUBLISHED) && (pAppInfo->_State & APPSTATE_SCRIPT_NOT_EXISTED)) )
        {
            uCLSSPEC        ClassSpec;
            PACKAGEDISPINFO PackageInfo;

            memset( &PackageInfo, 0, sizeof(PackageInfo) );

            ClassSpec.tyspec = TYSPEC_OBJECTID;
            memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, &pAppInfo->_DeploymentId, sizeof(GUID) );
            StringToGuid( pAppInfo->_pwszGPOId, &ClassSpec.tagged_union.ByObjectId.PolicyId );

            DebugMsg((DM_VERBOSE, IDS_CHECK_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));

            hr = CsGetAppInfo( &ClassSpec, NULL, &PackageInfo );

            if ( S_OK == hr )
            {
                BOOL bRestored;

                bRestored = pAppInfo->_bRestored;

                DebugMsg((DM_VERBOSE, IDS_CHECK_APP_FOUND, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, PackageInfo.dwActFlags));
                delete pAppInfo;
                pAppInfo = new CAppInfo( this, &PackageInfo, FALSE, bStatus );
                if ( ! bStatus )
                {
                    delete pAppInfo;
                    pAppInfo = 0;
                }
                if ( ! pAppInfo )
                    Status = ERROR_OUTOFMEMORY;
                ReleasePackageInfo( &PackageInfo );

                if ( pAppInfo )
                    pAppInfo->_bRestored = bRestored;
            }
            else if ( CS_E_PACKAGE_NOTFOUND == hr )
            {
                DebugMsg((DM_VERBOSE, IDS_CHECK_APP_NOTFOUND, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
            }
            else
            {
                Status = (DWORD) hr;
            }

            if ( Status != ERROR_SUCCESS )
            {
                DebugMsg((DM_VERBOSE, IDS_CHECK_APP_FAIL, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, Status));
                Revert();
                return Status;
            }
        }

        pAppInfoInsert = 0;

        //
        // Now we insert the locally discovered app into the proper sorted spot in
        // our master list generated from the initial DS query.
        //
        for ( _Apps.Reset(); pAppInfoInsert = (CAppInfo *) _Apps.GetCurrentItem(); _Apps.MoveNext() )
        {
            GPOCompare = _GPOs.Compare( pAppInfoInsert->_pwszGPOId, pAppInfo->_pwszGPOId );

            if ( -1 == GPOCompare )
                continue;

            if ( 1 == GPOCompare )
                break;

            // Smallest USN is oldest.  We sort from oldest to newest.
            if ( CompareFileTime( &pAppInfoInsert->_USN, &pAppInfo->_USN ) >= 0 )
                break;
        }

        // FIFO insert handles both the empty list and end of list conditions.
        if ( ! pAppInfoInsert )
            _Apps.InsertFIFO( pAppInfo );
        else
            pAppInfoInsert->InsertBefore( pAppInfo );
    }

    LocalApps.ResetEnd();

    Revert();

    DebugMsg((DM_VERBOSE, IDS_LOCALAPP_COUNT, Count));
    return ERROR_SUCCESS;
}


BOOL
CManagedAppProcessor::DetectLostApps()
{
    HKEY        hkApp;
    WCHAR       wszDeploymentId[GUIDSTRLEN+1];
    CAppInfo *  pScriptInfo;
    DWORD       Size;
    DWORD       State;
    DWORD       Status;

    if ( GetRsopContext()->IsPlanningModeEnabled() || ! _bUser )
        return FALSE;

    for ( _LocalScripts.Reset(); pScriptInfo = (CAppInfo *) _LocalScripts.GetCurrentItem(); _LocalScripts.MoveNext() )
    {
        GuidToString( pScriptInfo->_DeploymentId, wszDeploymentId );

        Status = RegOpenKeyEx( 
                    _hkAppmgmt, 
                    wszDeploymentId, 
                    0,
                    KEY_READ,
                    &hkApp );

        if ( Status != ERROR_SUCCESS )
        {
            _LocalScripts.ResetEnd();
            DebugMsg((DM_VERBOSE, IDS_DETECTED_LOST_APPS)); 
            return TRUE;
        }
        else
        {
            Size = sizeof(DWORD);
            State = 0;

            Status = RegQueryValueEx( 
                        hkApp, 
                        APPSTATEVALUE,
                        0,
                        NULL,
                        (LPBYTE) &State,
                        &Size );

            RegCloseKey( hkApp );

            //
            // This isn't a lost app, but rather an app which was orphaned or
            // uninstalled on another computer.  We will force a full policy
            // run in this case as well to process the removal.  This is similar
            // to the case where we find the FullPolicy value set.
            //
            if ( ! (State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED)) )
                return TRUE;
        }
    }

    _LocalScripts.ResetEnd();

    return FALSE;
}

DWORD
CManagedAppProcessor::GetLostApps()
{
    uCLSSPEC        ClassSpec;
    PACKAGEDISPINFO PackageInfo;
    CAppInfo *      pScriptInfo;
    CAppInfo *      pAppInfo;
    CAppInfo *      pAppInfoInsert;
    GUID            GPOId;
    int             GPOCompare;
    LONG            RedeployCount;
    DWORD           Status;
    HRESULT         hr;
    BOOL            bStatus;
    BOOL            bInsertNew;

    if ( GetRsopContext()->IsPlanningModeEnabled() || ! _bUser )
        return ERROR_SUCCESS;

    // 
    // In this routine we are detecting app entries which are erroneously
    // missing from our hkcu data.  This can occur in various scenarios
    // involving roaming profiles.  An unassociated script file and our 
    // rsop data is used for the detection.
    //
    // Note: 
    // There is quite a bit of duplicated code here and in the above routine
    // ::GetAppsFromLocal.  That is because this change was added late in 
    // WindowsXP and we wanted to isolate it from existing functionality.  
    // In future this could be cleaned up if this codebase is taken forward.
    //

    Status = ERROR_SUCCESS;

    for ( _LocalScripts.Reset(); pScriptInfo = (CAppInfo *) _LocalScripts.GetCurrentItem(); _LocalScripts.MoveNext() )
    {
        if ( pScriptInfo->_State != 0 )
            continue;

        DebugMsg((DM_VERBOSE, IDS_UNMATCHED_SCRIPT));

        pAppInfo = 0;

        hr = FindAppInRSoP( pScriptInfo, &GPOId, &RedeployCount );

        if ( ! SUCCEEDED(hr) )
        {
            if ( WBEM_E_NOT_FOUND == hr )
            {
                DebugMsg((DM_VERBOSE, IDS_SCRIPTNOTINRSOP1));
                DeleteScriptFile( pScriptInfo->_DeploymentId );
                continue;
            }
            else
            {
                Status = (DWORD) hr;
                DebugMsg((DM_VERBOSE, IDS_SCRIPTNOTINRSOP2, hr));
                break;
            }
        }

        DebugMsg((DM_VERBOSE, IDS_SCRIPTINRSOP));
            
        pAppInfo = _Apps.Find( pScriptInfo->_DeploymentId );

        if ( pAppInfo )
        {
            bInsertNew = FALSE;
            DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_INDS2, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
            goto GetLostAppsInsert;
        }

        memset( &PackageInfo, 0, sizeof(PackageInfo) );
        ClassSpec.tyspec = TYSPEC_OBJECTID;
        memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, &pScriptInfo->_DeploymentId, sizeof(GUID) );
        memcpy( &ClassSpec.tagged_union.ByObjectId.PolicyId, &GPOId, sizeof(GUID) );

        Status = Impersonate();
        if ( ERROR_SUCCESS == Status )
        {
            hr = CsGetAppInfo( &ClassSpec, NULL, &PackageInfo );
            Revert();
        }
        else
        {
            hr = HRESULT_FROM_WIN32( Status );
        }

        if ( S_OK == hr )
        {
            bStatus = TRUE;
            pAppInfo = new CAppInfo( this, &PackageInfo, FALSE, bStatus );
            ReleasePackageInfo( &PackageInfo );
            bInsertNew = TRUE;

            if ( ! bStatus )
            {
                delete pAppInfo;
                pAppInfo = 0;
            }
            if ( ! pAppInfo )
                Status = ERROR_OUTOFMEMORY;
            else
                DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_INDS, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( CS_E_PACKAGE_NOTFOUND == hr )
        {
            DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_NODS));

            //
            // Since the app is not visible to this user, delete the 
            // orphaned script.
            //
            DeleteScriptFile( pScriptInfo->_DeploymentId );
        }
        else
        {
            Status = (DWORD) hr;
        }

        if ( Status != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_ERRORDS, Status));
            break;
        }

        if ( ! pAppInfo )
            continue;

GetLostAppsInsert:
        //
        // Because we're restoring this app, much of the persisted state is lost.
        // We artifically re-create the key aspects here.
        //
        pAppInfo->_State |= APPSTATE_PUBLISHED | APPSTATE_RESTORED;
        pAppInfo->_AssignCount = 1;
        pAppInfo->_LocalRevision = (DWORD) RedeployCount;
        pAppInfo->_ScriptTime = pScriptInfo->_ScriptTime;

        // Switch to full policy mode whenever we force a lost app back into scope.
        _bNoChanges = FALSE;

        if ( ! bInsertNew )
            continue;

        // 
        // Our newly discovered app now needs to be added to our processing list.
        //
        for ( _Apps.Reset(); pAppInfoInsert = (CAppInfo *) _Apps.GetCurrentItem(); _Apps.MoveNext() )
        {
            GPOCompare = _GPOs.Compare( pAppInfoInsert->_pwszGPOId, pAppInfo->_pwszGPOId );

            if ( -1 == GPOCompare )
                continue;

            if ( 1 == GPOCompare )
                break;

            // Smallest USN is oldest.  We sort from oldest to newest.
            if ( CompareFileTime( &pAppInfoInsert->_USN, &pAppInfo->_USN ) >= 0 )
                break;
        }

        // FIFO insert handles both the empty list and end of list conditions.
        if ( ! pAppInfoInsert )
            _Apps.InsertFIFO( pAppInfo );
        else
            pAppInfoInsert->InsertBefore( pAppInfo );
    }

    _LocalScripts.ResetEnd();

    return Status;
}

HRESULT
CManagedAppProcessor::FindAppInRSoP(
    CAppInfo *  pScriptInfo,
    GUID *      pGPOId,
    LONG *      pRedeployCount
    )
{
    WCHAR       wszGPOId[128];
    WCHAR *     pwszGPOId;
    LONG        ValueLen;
    HRESULT     hr;

    hr = _Apps.InitRsopLog();

    if ( ! SUCCEEDED(hr) )
        return hr;

    pwszGPOId = wszGPOId;
    ValueLen = sizeof(wszGPOId) / sizeof(wszGPOId[0]);

    // 
    // Close your eyes, this is ugly.  The CAppInfo which is only used to track
    // script files only have the _DeploymentId member set.  However, OpenExistingRecord
    // needs a couple of other fields to operate correctly.  We feed those here.
    //
    pScriptInfo->_pManApp = this;
    pScriptInfo->_State = APPSTATE_PUBLISHED;

    CConflict   ScriptRecord( pScriptInfo );
         
    hr = _Apps.OpenExistingRecord( &ScriptRecord );

    if ( SUCCEEDED(hr) )
    {
        hr = ScriptRecord.GetValue( RSOP_ATTRIBUTE_GPOID, pwszGPOId, &ValueLen );
        if ( S_FALSE == hr )
        {
            pwszGPOId = new WCHAR[ValueLen];
            if ( pwszGPOId )
                hr = ScriptRecord.GetValue( RSOP_ATTRIBUTE_GPOID, pwszGPOId, &ValueLen );
            else 
                hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED(hr) )
            hr = ScriptRecord.GetValue( APP_ATTRIBUTE_REDEPLOYCOUNT, pRedeployCount );
    }

    if ( SUCCEEDED(hr) )
    {
        WCHAR * pwszNull;

        // The GPOId comes back from GetValue like CN={gpoguid},CN=Policies,...

        pwszNull = wcschr( pwszGPOId, L'}' );
        if ( pwszNull )
        {
            pwszNull[1] = 0;
            StringToGuid( &pwszGPOId[3], pGPOId );
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    if ( pwszGPOId != wszGPOId )
        delete pwszGPOId;

    return hr;
}

void
CManagedAppProcessor::DeleteScriptFile(
    GUID & DeploymentId
    )
{
    DWORD   Length;
    WCHAR * pwszLocalScriptPath;

    Length = lstrlen( LocalScriptDir() );
    
    pwszLocalScriptPath = new WCHAR[Length + GUIDSTRLEN + 5];
    if ( ! pwszLocalScriptPath )
        return;

    lstrcpy( pwszLocalScriptPath, LocalScriptDir() );
    GuidToString( DeploymentId, &pwszLocalScriptPath[Length] );
    lstrcpy( &pwszLocalScriptPath[Length+GUIDSTRLEN], L".aas" );
    DeleteFile( pwszLocalScriptPath );

    delete pwszLocalScriptPath;
}

HRESULT
CManagedAppProcessor::GetPackageEnumeratorFromPath(
        WCHAR*         wszClassStorePath,
        GUID*          pCategory,
        DWORD          dwAppFlags,
        IEnumPackage** ppIEnumPackage)
{
    HRESULT         hr;
    IClassAccess  * pIClassAccess = NULL;

    //
    // Get an IClassAccess
    //
    hr = GetClassAccessFromPath(
        wszClassStorePath,
        &pIClassAccess);

    if (SUCCEEDED(hr))
    {
        //
        // Get the enumerator
        //
        hr = pIClassAccess->EnumPackages(
            NULL,
            pCategory,
            NULL,
            dwAppFlags,
            ppIEnumPackage
            );

        pIClassAccess->Release();
    }

    return hr;
}

HRESULT
CManagedAppProcessor::GetDsPackageFromGPO(
    CGPOInfo*        pGpoInfo,
    GUID*            pDeploymentId,
    PACKAGEDISPINFO* pPackageInfo)
{
    HRESULT         hr;

    memset( pPackageInfo, 0, sizeof(*pPackageInfo) );

    //
    // Determine the class store path for this gpo
    //
    WCHAR* pwszClassStorePath;

    pwszClassStorePath = NULL;

    //
    // The path returned is allocated by the callee so we must
    // free it later
    //
    hr = CsGetClassStorePath( pGpoInfo->GetGPOPath(), &pwszClassStorePath );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Terminate the class store path list with a delimiter to satisfy
    // class store syntax requirements
    //
    WCHAR* pwszTerminatedClassStorePath;

    pwszTerminatedClassStorePath = new WCHAR[ lstrlen( pwszClassStorePath ) + 1 + 1 ];

    if ( pwszTerminatedClassStorePath )
    {
        IClassAccess  * pIClassAccess = NULL;
        uCLSSPEC        ClassSpec;

        ClassSpec.tyspec = TYSPEC_OBJECTID;
        memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, pDeploymentId, sizeof(GUID) );
        StringToGuid( pGpoInfo->_pwszGPOId, &ClassSpec.tagged_union.ByObjectId.PolicyId );

        //
        // Perform the actual termination
        //
        lstrcpy( pwszTerminatedClassStorePath, pwszClassStorePath );
        lstrcat( pwszTerminatedClassStorePath, L";" );

        //
        // Get an IClassAccess using this class store path
        //
        hr = GetClassAccessFromPath(
            pwszTerminatedClassStorePath,
            &pIClassAccess);

        if (SUCCEEDED(hr))
        {
            //
            // Perform the search for the requested deployment
            //
            hr = pIClassAccess->GetAppInfo(
                &ClassSpec,
                NULL,
                pPackageInfo);
            
            pIClassAccess->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if ( pwszClassStorePath )
    {
        LocalFree( pwszClassStorePath );
    }

    delete [] pwszTerminatedClassStorePath;

    return hr;
}


HRESULT
CManagedAppProcessor::GetClassAccessFromPath(
    WCHAR*          wszClassStorePath,
    IClassAccess**  ppIClassAccess)
{
    HRESULT         hr;
    PRSOP_TARGET    pRsopTarget;
    
    *ppIClassAccess = NULL;

    pRsopTarget = GetRsopContext()->_pRsopTarget;

    //
    // Get an IClassAccess
    //
    hr = CsGetClassAccess(ppIClassAccess);

    //
    // Set the IClassAccess to use the class stores
    // corresponding to the class store path passed in
    //
    if (SUCCEEDED(hr))
    {
        hr = (*ppIClassAccess)->SetClassStorePath(
            wszClassStorePath,
            pRsopTarget ? pRsopTarget->pRsopToken : NULL );
    }

    return hr;
}

DWORD
CManagedAppProcessor::CommitPolicyList()
{
    CGPOInfo *  pGPO;
    WCHAR *     pwszGPOList;
    DWORD       Length;
    DWORD       Status;

    if ( GetRsopContext()->IsPlanningModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    Length = 1;
    _GPOs.Reset();

    for ( pGPO = (CGPOInfo *) _GPOs.GetCurrentItem();
          pGPO;
          _GPOs.MoveNext(), pGPO = (CGPOInfo *) _GPOs.GetCurrentItem() )
    {
        Length += lstrlen( pGPO->_pwszGPOId ) + 1;
    }

    _GPOs.ResetEnd();

    pwszGPOList = new WCHAR[Length];
    if ( ! pwszGPOList )
        return ERROR_OUTOFMEMORY;
    pwszGPOList[0] = 0;

    _GPOs.Reset();

    for ( pGPO = (CGPOInfo *) _GPOs.GetCurrentItem();
          pGPO;
          _GPOs.MoveNext(), pGPO = (CGPOInfo *) _GPOs.GetCurrentItem() )
    {
        lstrcat( pwszGPOList, pGPO->_pwszGPOId );
        lstrcat( pwszGPOList, L";" );
    }

    _GPOs.ResetEnd();

    Status = RegSetValueEx(
               _hkAppmgmt,
               POLICYLISTVALUE,
               0,
               REG_SZ,
               (LPBYTE) pwszGPOList,
               Length * sizeof(WCHAR) );

    delete pwszGPOList;

    return Status;
}

DWORD
CManagedAppProcessor::LoadPolicyList()
{
    PGROUP_POLICY_OBJECT pGPOList = NULL;
    DWORD                Status;

    Status = Impersonate();

    if ( ERROR_SUCCESS == Status )
    {
        Status = GetCurrentUserGPOList( &pGPOList );

        Revert();
    }

    if (ERROR_SUCCESS == Status)
    {
        Status = SetPolicyListFromGPOList( pGPOList );
    }

    if ( pGPOList )
    {
        FreeGPOList( pGPOList );
    }

    if ( ERROR_SUCCESS == Status )
    {
        MergePolicyList();
    }

    return Status;
}

DWORD
CManagedAppProcessor::SetPolicyListFromGPOList(
    PGROUP_POLICY_OBJECT pGPOList
    )
{
    DWORD       Status;
    WCHAR *     pwszGPOList;
    WCHAR *     pwszGPO;
    WCHAR *     pwszGPOEnd;
    DWORD       Size;
    BOOL        bStatus;

    Status = ERROR_SUCCESS;
    pwszGPOList = 0;
    Size = 0;

    PGROUP_POLICY_OBJECT pCurrentGPO;

    for (pCurrentGPO = pGPOList; NULL != pCurrentGPO; pCurrentGPO = pCurrentGPO->pNext)
    {
        BOOL bStatus;

        DebugMsg((DM_VERBOSE, IDS_GPO_NAME, pCurrentGPO->lpDisplayName, pCurrentGPO->szGPOName));
        DebugMsg((DM_VERBOSE, IDS_GPO_FILESYSPATH, pCurrentGPO->lpFileSysPath));
        DebugMsg((DM_VERBOSE, IDS_GPO_DSPATH, pCurrentGPO->lpDSPath));

        bStatus = AddGPO( pCurrentGPO );

        if ( ! bStatus )
        {
            Status = ERROR_OUTOFMEMORY;
            break;
        }
    }

    return Status;
}

DWORD
CManagedAppProcessor::MergePolicyList()
{
    WCHAR *     pwszGPOList;
    WCHAR *     pwszGPO;
    WCHAR *     pwszGPOEnd;
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    pwszGPOList = 0;
    Size = 0;

    Status = RegQueryValueEx(
                _hkAppmgmt,
                POLICYLISTVALUE,
                0,
                NULL,
                (LPBYTE) NULL,
                &Size );

    if ( ERROR_FILE_NOT_FOUND == Status )
        return ERROR_SUCCESS;

    if ( ERROR_SUCCESS == Status )
    {
        pwszGPOList = new WCHAR[Size/2];
        if ( ! pwszGPOList )
            return ERROR_OUTOFMEMORY;

        Status = RegQueryValueEx(
                    _hkAppmgmt,
                    POLICYLISTVALUE,
                    0,
                    NULL,
                    (LPBYTE) pwszGPOList,
                    &Size );
    }

    if ( ERROR_SUCCESS == Status )
    {
        GROUP_POLICY_OBJECT GPOInfo;

        memset( &GPOInfo, 0, sizeof( GPOInfo ) );

        for ( pwszGPO = pwszGPOList; *pwszGPO; pwszGPO = pwszGPOEnd + 1 )
        {
            pwszGPOEnd = wcschr( pwszGPO, L';' );

            if ( ! pwszGPOEnd )
            {
                Status = ERROR_INVALID_PARAMETER;
                break;
            }

            *pwszGPOEnd = 0;

            if ( ! _GPOs.Find( pwszGPO ) )
            {
                lstrcpy( GPOInfo.szGPOName, pwszGPO );
                GPOInfo.lpDisplayName = L"";
                GPOInfo.lpDSPath = L"";
                GPOInfo.lpLink = L"";

                bStatus = _GPOs.Add( &GPOInfo );

                if ( ! bStatus )
                {
                    Status = ERROR_OUTOFMEMORY;
                    break;
                }
            }
        }
    }

    delete pwszGPOList;

    return Status;
}


DWORD
CManagedAppProcessor::CreateAndSecureScriptDir()
{
    SECURITY_DESCRIPTOR SecDesc;
    SECURITY_ATTRIBUTES SecAttr;
    SID_IDENTIFIER_AUTHORITY AuthorityNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthorityEveryone = SECURITY_WORLD_SID_AUTHORITY;
    PSID        pSidUser;
    PSID        pSidEveryone;
    PSID        pSidSystem;
    PSID        pSidAdmin;
    PACL        pAcl;
    ACE_HEADER * pAceHeader;
    PSID        pSid;
    DWORD       AclSize;
    DWORD       AceIndex;
    DWORD       Length;
    DWORD       Attributes;
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    Status = ERROR_SUCCESS;

    //
    // The following check is used to determine if the appmgmt directories
    // for this user/machine exist in the proper win2001 format.  If so we
    // can quickly exit.
    // When the directories exist but without the system bit set, this means
    // we need to migrate to the new win2001 ACL format.
    //
    Attributes = GetFileAttributes( _pwszLocalPath );

    if ( (Attributes != (DWORD) -1) && (Attributes & FILE_ATTRIBUTE_SYSTEM) )
        return ERROR_SUCCESS;

    //
    // If a user object is moved within a domain forest the SID will change.
    // Here we check for that case and rename the previous SID dir to the
    // new SID.  This is only a necessary check if a script dir by the current
    // SID name does not exist.
    //
    if ( ((DWORD) -1 == Attributes) && _bUser )
    {
        WCHAR * pwszPreviousSid = 0;

        Status = GetPreviousSid( _hUserToken, _pwszLocalPath, &pwszPreviousSid );

        if ( (ERROR_SUCCESS == Status) && pwszPreviousSid )
        {
            Status = RenameScriptDir( pwszPreviousSid, _pwszLocalPath );
            delete pwszPreviousSid;
            return Status;
        }

        if ( Status != ERROR_SUCCESS )
            return Status;
    }

    pSidEveryone = 0;
    pSidSystem = 0;
    pSidAdmin = 0;
    pSidUser = 0;
    pAcl = 0;

    if ( _bUser )
    {
        pSidUser = AppmgmtGetUserSid( _hUserToken );
        if ( ! pSidUser )
            return ERROR_OUTOFMEMORY;
    }

    bStatus = AllocateAndInitializeSid( &AuthorityEveryone, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidEveryone );

    if ( bStatus )
        bStatus = AllocateAndInitializeSid( &AuthorityNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem );

    if ( bStatus )
        bStatus = AllocateAndInitializeSid( &AuthorityNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSidAdmin );

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SecureScriptDirEnd;
    }

    AclSize = GetLengthSid(pSidSystem) +
              GetLengthSid(pSidAdmin) +
              sizeof(ACL) + (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    if ( _bUser )
        AclSize += GetLengthSid(pSidUser);
    else
        AclSize += GetLengthSid(pSidEveryone);

    pAcl = (PACL) LocalAlloc( 0, AclSize );

    if ( pAcl )
    {
        bStatus = InitializeAcl( pAcl, AclSize, ACL_REVISION );
        if ( ! bStatus )
            Status = GetLastError();
    }
    else
    {
        Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
        goto SecureScriptDirEnd;

    //
    // Access is as follows :
    //  %systemroot%\system32
    //      appmgmt - LocalSystem (Full), Admin Group (Full), Everyone (Read/Execute, this folder only)
    //      appmgmt\machine - LocalSystem (Full), Admin Group (Full)
    //      appmgmt\<usersid> - LocalSystem (Full), Admin Group (Full), <usersid> (Read/Execute)
    //

    AceIndex = 0;

    bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem);

    if ( bStatus )
    {
        bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
        if ( bStatus )
            pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
    }

    if ( bStatus )
    {
        AceIndex++;
        bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin);

        if ( bStatus )
        {
            bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
            if ( bStatus )
                pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        }
    }

    if ( bStatus )
    {
        AceIndex++;
        bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE, pSidEveryone);
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SecureScriptDirEnd;
    }

    bStatus = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );

    if ( bStatus )
        bStatus = SetSecurityDescriptorDacl( &SecDesc, TRUE, pAcl, FALSE );

    if ( bStatus )
    {
        PWCHAR  pwszSlash1, pwszSlash2;

        //
        // We are always creating dirs of the form "%systemroot%\system32\appmgmt\<sid>\".
        //

        pwszSlash1 = wcsrchr( _pwszLocalPath, L'\\' );
        *pwszSlash1 = 0;
        pwszSlash2 = wcsrchr( _pwszLocalPath, L'\\' );
        *pwszSlash2 = 0;

        SecAttr.nLength = sizeof( SecAttr );
        SecAttr.lpSecurityDescriptor = &SecDesc;
        SecAttr.bInheritHandle = FALSE;

        // This creates the root appmgmt dir.
        bStatus = CreateDirectory( _pwszLocalPath, &SecAttr );

        if ( ! bStatus && (ERROR_ALREADY_EXISTS == GetLastError()) )
        {
            bStatus = SetFileSecurity( _pwszLocalPath, DACL_SECURITY_INFORMATION, &SecDesc );
        }

        *pwszSlash1 = L'\\';
        *pwszSlash2 = L'\\';

        if ( bStatus )
        {
            //
            // We always remove the Everyone ACE, but only in the case of a user
            // (rather then the machine) subdir do we then add in a user specific
            // ACE to replace it below.
            //
            bStatus = DeleteAce( pAcl, AceIndex );

            if ( _bUser )
            {
                if ( bStatus )
                    bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE, pSidUser);

                if ( bStatus )
                {
                    bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
                    if ( bStatus )
                        pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
                }
            }

            // This now creates the user specific subdir.
            if ( bStatus )
                bStatus = CreateDirectory( _pwszLocalPath, &SecAttr );
        }

        if ( ! bStatus && (ERROR_ALREADY_EXISTS == GetLastError()) )
        {
            bStatus = SetFileSecurity( _pwszLocalPath, DACL_SECURITY_INFORMATION, &SecDesc );
            if ( bStatus )
                bStatus = SetFileAttributes( _pwszLocalPath, FILE_ATTRIBUTE_SYSTEM );
        }
    }

    if ( ! bStatus )
        Status = GetLastError();

SecureScriptDirEnd:

    FreeSid( pSidUser );
    FreeSid( pSidEveryone );
    FreeSid( pSidSystem );
    FreeSid( pSidAdmin );
    LocalFree( pAcl );

    return Status;
}

DWORD
CManagedAppProcessor::GetOrderedLocalAppList(
    CAppList & AppList
    )
{
    CAppList        RegAppList( NULL );
    CAppInfo *      pAppInfo;
    WCHAR           wszDeploymentId[44];
    WCHAR *         pwszGPOList;
    WCHAR *         pwszGPO;
    WCHAR *         pwszGPOEnd;
    DWORD           Index;
    DWORD           Size;
    DWORD           Status;
    BOOL            bStatus;

    DebugMsg((DM_VERBOSE, IDS_GET_LOCAL_APPS));

    pwszGPOList = 0;
    Size = 0;

    Status = ERROR_FILE_NOT_FOUND;

    if ( !GetRsopContext()->IsPlanningModeEnabled() )
    {
        Status = RegQueryValueEx(
            _hkAppmgmt,
            POLICYLISTVALUE,
            0,
            NULL,
            (LPBYTE) NULL,
            &Size );

    }

    if ( ERROR_SUCCESS == Status )
    {
        pwszGPOList = new WCHAR[Size/2];
        if ( ! pwszGPOList )
        {
            Status = ERROR_OUTOFMEMORY;
            goto GetOrderedLocalAppListEnd;
        }

        Status = RegQueryValueEx(
                    _hkAppmgmt,
                    POLICYLISTVALUE,
                    0,
                    NULL,
                    (LPBYTE) pwszGPOList,
                    &Size );
    }
    else
    {
        //
        // The policylist named value will not exist the first time policy
        // runs.  Therefor there will be no apps already on the machine if
        // this value is not present.
        //
        // Note however, that because this is a new value for NT5 beta3,
        // beta2+ clients may have apps, but won't have this value.  For
        // those machines, this new value will be written during the first
        // full policy run.  That will not pose any problems.
        //
        return ERROR_SUCCESS;
    }

    if ( Status != ERROR_SUCCESS )
        goto GetOrderedLocalAppListEnd;

    Index = 0;

    for (;;)
    {
        Status = RegEnumKey(
                    _hkAppmgmt,
                    Index++,
                    wszDeploymentId,
                    sizeof(wszDeploymentId) / sizeof(WCHAR) );

        if ( ERROR_NO_MORE_ITEMS == Status )
        {
            Index--;
            Status = ERROR_SUCCESS;
            break;
        }

        if ( Status != ERROR_SUCCESS )
            break;

        pAppInfo = new CAppInfo( this, wszDeploymentId, bStatus );

        if ( ! pAppInfo || ! bStatus )
            Status = ERROR_OUTOFMEMORY;

        if ( Status != ERROR_SUCCESS )
        {
            if ( pAppInfo )
                delete pAppInfo;
            break;
        }

        RegAppList.InsertFIFO( pAppInfo );
    }

    if ( Status != ERROR_SUCCESS )
        goto GetOrderedLocalAppListEnd;

    if ( 0 == Index )
    {
        DebugMsg((DM_VERBOSE, IDS_NO_LOCAL_APPS));
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_LOCAL_APP_COUNT, Index));
    }

    //
    // We first gather all apps for policies we know about and order them
    // according to the policy precedences.
    //
    for ( pwszGPO = pwszGPOList; *pwszGPO; pwszGPO = pwszGPOEnd + 1 )
    {
        pwszGPOEnd = wcschr( pwszGPO, L';' );
        *pwszGPOEnd = 0;

        RegAppList.Reset();

        for ( pAppInfo = (CAppInfo *) RegAppList.GetCurrentItem();
              pAppInfo;
              pAppInfo = (CAppInfo *) RegAppList.GetCurrentItem() )
        {
            if ( lstrcmpi( pAppInfo->_pwszGPOId, pwszGPO ) != 0 )
            {
                RegAppList.MoveNext();
                continue;
            }

            DebugMsg((DM_VERBOSE, IDS_LOCAL_APP_DUMP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, pAppInfo->_State, pAppInfo->_AssignCount));

            RegAppList.MoveNext();
            pAppInfo->Remove();
            AppList.InsertFIFO( pAppInfo );
        }

        RegAppList.ResetEnd();
    }

    //
    // In some instances we will still have apps in the registry that are not in the
    // current list of policies.  We add them to the front of the final list.
    //
    for ( RegAppList.Reset(); pAppInfo = (CAppInfo *) RegAppList.GetCurrentItem(); )
    {
        DebugMsg((DM_VERBOSE, IDS_LOCAL_APP_DUMP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, pAppInfo->_State, pAppInfo->_AssignCount));

        RegAppList.MoveNext();
        pAppInfo->Remove();
        AppList.InsertLIFO( pAppInfo );
    }

    RegAppList.ResetEnd();

GetOrderedLocalAppListEnd:

    delete pwszGPOList;

    if ( Status != ERROR_SUCCESS )
        DebugMsg((DM_WARNING, IDS_GETLOCALAPPS_FAIL, Status));

    return Status;
}

DWORD
CManagedAppProcessor::GetLocalScriptAppList(
    CAppList & AppList
    )
{
    WIN32_FIND_DATA FindData;
    CAppInfo *  pAppInfo;
    WCHAR *     pwszPath;
    HANDLE      hFind;
    DWORD       Status;

    pwszPath = new WCHAR[lstrlen(_pwszLocalPath) + 7];
    if ( ! pwszPath )
        return ERROR_OUTOFMEMORY;
    lstrcpy( pwszPath, _pwszLocalPath );
    lstrcat( pwszPath, L"\\*.aas" );

    hFind = FindFirstFile( pwszPath, &FindData );

    delete pwszPath;

    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    do
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            continue;

        pwszPath = wcschr( FindData.cFileName, L'.' );
        if ( ! pwszPath )
            continue;
        *pwszPath = 0;

        pAppInfo = new CAppInfo( FindData.cFileName );
        if ( ! pAppInfo )
            return ERROR_OUTOFMEMORY;
        pAppInfo->_ScriptTime = FindData.ftLastWriteTime;

        AppList.InsertFIFO( pAppInfo );
    } while ( FindNextFile( hFind, &FindData ) );

    FindClose( hFind );
    return ERROR_SUCCESS;
}

DWORD
GetScriptDirPath(
    HANDLE      hToken,
    DWORD       ExtraPathChars,
    
    WCHAR **    ppwszPath
    )
{
    WCHAR           wszPath[MAX_PATH];
    WCHAR *         pwszSystemDir;
    DWORD           AllocLength;
    DWORD           Length;
    DWORD           Status;
    UNICODE_STRING  SidString;

    Status = ERROR_SUCCESS;
    *ppwszPath = 0;

    pwszSystemDir = wszPath;
    AllocLength = sizeof(wszPath) / sizeof(WCHAR);

    RtlInitUnicodeString( &SidString, NULL );

    for (;;)
    {
        Length = GetSystemDirectory(
                    pwszSystemDir,
                    AllocLength );

        if ( 0 == Length )
            return GetLastError();

        if ( Length >= AllocLength )
        {
            AllocLength = Length + 1;
            pwszSystemDir = (WCHAR *) LocalAlloc( 0, AllocLength * sizeof(WCHAR) );
            if ( ! pwszSystemDir )
                return ERROR_OUTOFMEMORY;
            continue;
        }

        break;
    }

    if ( hToken )
    {
        Status = GetSidString( hToken, &SidString );
    }
    else
    {
        RtlInitUnicodeString( &SidString, L"MACHINE" );
    }

    if ( ERROR_SUCCESS == Status )
    {
        // System dir + \appmgmt\ + Sid + \ + null
        *ppwszPath = new WCHAR[Length + 11 + (SidString.Length / 2) + ExtraPathChars];

        if ( *ppwszPath )
        {
            lstrcpy( *ppwszPath, pwszSystemDir );
            if ( pwszSystemDir[lstrlen(pwszSystemDir)-1] != L'\\' )
                lstrcat( *ppwszPath, L"\\" );
            lstrcat( *ppwszPath, L"appmgmt\\" );
            lstrcat( *ppwszPath, SidString.Buffer );
            lstrcat( *ppwszPath, L"\\" );
        }
        else
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }

    if ( hToken )
        RtlFreeUnicodeString( &SidString );

    if ( pwszSystemDir != wszPath )
        LocalFree( pwszSystemDir );

    return Status;
}

void
CManagedAppProcessor::LogonMsg(
    DWORD   MsgId,
    ...
    )
{
    WCHAR   wszMsg[80];
    WCHAR   wszBuffer[256];
    va_list VAList;
    int     Status;

    if ( ! _pfnStatusCallback || ! LoadLoadString() )
        return;

    Status = (*pfnLoadStringW)( ghDllInstance, MsgId, wszMsg, sizeof(wszMsg) / sizeof(WCHAR) );

    if ( 0 == Status )
        return;

    va_start( VAList, MsgId );
    _vsnwprintf( wszBuffer, sizeof(wszBuffer)/sizeof(wszBuffer[0]), wszMsg, VAList);
    va_end( VAList );

    _pfnStatusCallback( FALSE, wszBuffer );
}

//
// CGPOInfoList
//

CGPOInfoList::~CGPOInfoList()
{
    CGPOInfo * pGPO;

    Reset();

    while ( pGPO = (CGPOInfo *) GetCurrentItem() )
    {
        MoveNext();

        pGPO->Remove();
        delete pGPO;
    }

    ResetEnd();
}

BOOL
CGPOInfoList::Add(
    PGROUP_POLICY_OBJECT pGPOInfo
    )
{
    CGPOInfo *  pGPO;
    BOOL        bStatus = FALSE;

    pGPO = new CGPOInfo( pGPOInfo, bStatus );

    if ( ! bStatus )
    {
        if ( pGPO )
            delete pGPO;
        pGPO = 0;
    }

    if ( ! pGPO )
        return FALSE;

    InsertFIFO( pGPO );

    return TRUE;
}


CGPOInfo *
CGPOInfoList::Find(
    WCHAR * pwszGPOId
    )
{
    CGPOInfo *  pGPO;

    pGPO = NULL;

    for ( Reset(); pGPO = (CGPOInfo *) GetCurrentItem(); MoveNext() )
    {
        if ( lstrcmpi( pwszGPOId, pGPO->_pwszGPOId ) == 0 )
            break;
    }

    ResetEnd();

    return pGPO;
}

int
CGPOInfoList::Compare(
    WCHAR * pwszGPOId1,
    WCHAR * pwszGPOId2
    )
{
    CGPOInfo *  pGPO;
    int         Index;
    int         Index1;
    int         Index2;

    Index1 = Index2 = -1;

    Reset();

    Index = 0;

    while ( pGPO = (CGPOInfo *) GetCurrentItem() )
    {
        if ( lstrcmpi( pGPO->_pwszGPOId, pwszGPOId1 ) == 0 )
            Index1 = Index;

        if ( lstrcmpi( pGPO->_pwszGPOId, pwszGPOId2 ) == 0 )
            Index2 = Index;

        MoveNext();
        Index++;
    }

    ResetEnd();

    if ( Index1 == Index2 )
        return 0;

    if ( Index1 < Index2 )
        return -1;
    else
        return 1;
}

//
// CGPOInfo
//

CGPOInfo::CGPOInfo(
    PGROUP_POLICY_OBJECT pGPOInfo,
    BOOL &      bStatus
    )
{
    bStatus = TRUE;

    _pwszGPOId = StringDuplicate( (PWCHAR) pGPOInfo->szGPOName );
    _pwszGPOName = StringDuplicate( (PWCHAR) pGPOInfo->lpDisplayName );
    _pwszGPOPath = StringDuplicate( (PWCHAR) pGPOInfo->lpDSPath );

    if ( pGPOInfo->lpLink )
    {
        _pwszSOMPath = StringDuplicate( StripLinkPrefix(pGPOInfo->lpLink) );
    }
    else
    {
        _pwszSOMPath = NULL;
    }

    if ( ! _pwszGPOId || ! _pwszGPOName || ! _pwszGPOPath || ! _pwszSOMPath )
        bStatus = FALSE;
}

CGPOInfo::~CGPOInfo()
{
    delete [] _pwszGPOId;
    delete [] _pwszGPOName;
    delete [] _pwszGPOPath;
    delete [] _pwszSOMPath;
}


CRsopAppContext::CRsopAppContext(
    DWORD   dwContext,
    HANDLE  hEventAppsEnumerated, // = NULL
    APPKEY* pAppType) :           // = NULL
    CRsopContext( APPMGMTEXTENSIONGUID ),
    _dwContext( dwContext ),
    _wszDemandSpec( NULL ),
    _bTransition( FALSE ),
    _dwInstallType( DEMAND_INSTALL_NONE ),
    _bRemovalPurge( FALSE ),
    _bRemoveGPOApps( FALSE ),
    _bForcedRefresh( FALSE ),
    _dwCurrentRsopVersion( 0 ),
    _hEventAppsEnumerated( hEventAppsEnumerated ),
    _StatusAbort( ERROR_SUCCESS )
{
    WCHAR  wszClsid[ MAX_SZGUID_LEN ];
    WCHAR* wszDemandSpec;

    if ( pAppType )
    {
        switch (pAppType->Type)
        {
        case FILEEXT :
            _dwInstallType = DEMAND_INSTALL_FILEEXT;
            wszDemandSpec = pAppType->uType.FileExt;
            break;

        case PROGID :
            _dwInstallType = DEMAND_INSTALL_PROGID;
            wszDemandSpec = pAppType->uType.ProgId;
            break;

        case COMCLASS :
            _dwInstallType = DEMAND_INSTALL_CLSID;
            GuidToString( pAppType->uType.COMClass.Clsid, wszClsid );
            wszDemandSpec = wszClsid;
            break;

        case APPNAME :
            _dwInstallType = DEMAND_INSTALL_NAME;
            wszDemandSpec = NULL;
            break;
        
        default:
            wszDemandSpec = NULL;
        }
        
        _wszDemandSpec = StringDuplicate( wszDemandSpec );
    }
}

CRsopAppContext::~CRsopAppContext()
{
    //
    // If policy was aborted before we attempted to apply it,
    // we will have logged only the applications that caused us to
    // abort.  So in this case, the rsop data is incomplete
    //
    if ( ERROR_SUCCESS != _StatusAbort )
    {
        HRESULT hr;

        hr = HRESULT_FROM_WIN32( _StatusAbort );

        //
        // The rsop data is incomplete, so disable rsop with the
        // error code below so that the administrator will know 
        // that the data are not complete.
        //
        (void) DisableRsop( hr );
    }
}


void
CRsopAppContext::InitializeRsopContext( 
    HANDLE hUserToken,
    HKEY   hkUser,
    BOOL   bForcedRefresh,
    BOOL*  pbNoChanges)
{
    //
    // In planning mode, all initialization is
    // already done, there is nothing to do here
    //
    if ( IsPlanningModeEnabled() )
    {
        return;
    }

    //
    // To get an rsop namespace, we need to know the user's sid
    //
    PSID pSid;
    BOOL bProfileConsistent;

    pSid = NULL;
    bProfileConsistent = TRUE;

    //
    // The token will only be non-NULL if we are in user policy
    //
    if ( hUserToken )
    {
        pSid = AppmgmtGetUserSid( hUserToken );

        if ( ! pSid )
        {
            (void) DisableRsop( ERROR_OUTOFMEMORY );
            
            return;
        }
    }

    //
    // Perform the base context initialization -- pSid will be NULL
    // here if we are in machine policy, which is ok.
    //
    (void) InitializeContext( pSid );

    if ( pSid )
    {
        (void) FreeSid( pSid );

        DWORD dwMachineVersion;
        DWORD dwUserVersion;
        DWORD dwSize;

        dwMachineVersion = 0;
        dwUserVersion = 0;

        dwSize = sizeof( dwMachineVersion );
    
        //
        // Read machine version
        //
        (void) RegQueryValueEx(
            GetNameSpaceKey(),
            RSOPVERSION,
            NULL,
            NULL,
            (LPBYTE) &dwMachineVersion,
            &dwSize);
        
        dwSize = sizeof( dwUserVersion );

        //
        // Read user version
        //
        (void) RegQueryValueEx(
            hkUser,
            RSOPVERSION,
            NULL,
            NULL,
            (LPBYTE) &dwUserVersion,
            &dwSize);

        //
        // Always sync the current version for this machine to the profile's version
        //
        _dwCurrentRsopVersion = dwUserVersion;
            
        bProfileConsistent = dwUserVersion == dwMachineVersion;
   }

    //
    // In the policy refresh case, we are done initializing if
    // a forced refresh isn't demanded
    //
    if ( ( CRsopAppContext::POLICY_REFRESH == GetContext() ) && ! bForcedRefresh )
    {
        //
        // Force a refresh if the profile is not consitent with the machine's rsop
        //
        if ( *pbNoChanges && ! bProfileConsistent )
        {
            bForcedRefresh = TRUE;
            *pbNoChanges = FALSE;

            DebugMsg((DM_VERBOSE, IDS_CHANGES_RSOP_CHANGE));
        }
        else
        {
            return;
        }
    }

    _bForcedRefresh = bForcedRefresh;

    //
    // In this case, the gp engine did not pass in a 
    // namespace for logging, either because we are executing outside of
    // policy refresh context or because there were no changes and
    // we decided to reapply policy regardless.  Since the gp engine did
    // not give us a namespace, we must initialize from a saved namespace
    //
    (void) InitializeSavedNameSpace();
}

HRESULT
CRsopAppContext::MoveAppContextState( CRsopAppContext* pRsopContext )
{
    HRESULT hr;

    hr = S_OK;

    if ( pRsopContext->_wszDemandSpec )
    {
        _wszDemandSpec = StringDuplicate( pRsopContext->_wszDemandSpec );

        if ( ! _wszDemandSpec )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = MoveContextState( pRsopContext );
    }

    _dwContext = pRsopContext->_dwContext;
    _dwInstallType = pRsopContext->_dwInstallType;
    _bTransition = pRsopContext->_bTransition;
    _bRemovalPurge = pRsopContext->_bRemovalPurge;
    _bRemoveGPOApps = pRsopContext->_bRemoveGPOApps;
    _bForcedRefresh = pRsopContext->_bForcedRefresh;
    _dwCurrentRsopVersion = pRsopContext->_dwCurrentRsopVersion;
    _hEventAppsEnumerated = pRsopContext->_hEventAppsEnumerated;
    _StatusAbort = pRsopContext->_StatusAbort;

    return hr;
}


HRESULT
CRsopAppContext::SetARPContext()
{
    if ( ! IsPlanningModeEnabled() )
    {
        return E_INVALIDARG;
    }

    _dwContext = ARPLIST;

    return S_OK;
}

DWORD
CRsopAppContext::WriteCurrentRsopVersion( HKEY hkUser )
{
    if ( ! IsRsopEnabled() || IsPlanningModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    DWORD dwCurrentVersion;
    LONG  Status;

    dwCurrentVersion = _dwCurrentRsopVersion + 1;

    //
    // Write the machine version
    //
    Status = RegSetValueEx(
        GetNameSpaceKey(),
        RSOPVERSION,
        0,
        REG_DWORD,
        (LPBYTE) &dwCurrentVersion,
        sizeof( DWORD ) );

    LONG  StatusUser;
        
    //
    // Read user version
    //
    StatusUser = RegSetValueEx(
        hkUser,
        RSOPVERSION,
        0,
        REG_DWORD,
        (LPBYTE) &dwCurrentVersion,
        sizeof( DWORD ) );

    if ( ERROR_SUCCESS == Status )
    {
        Status = StatusUser;
    }

    return Status;
}

void
CRsopAppContext::SetPolicyAborted( DWORD Status )
{
    if ( ERROR_SUCCESS == _StatusAbort )
    {
        _StatusAbort = Status;
    }
}

BOOL
CRsopAppContext::HasPolicyAborted()
{
    return ERROR_SUCCESS != _StatusAbort;
}

void
CRsopAppContext::SetAppsEnumerated()
{
    if ( _hEventAppsEnumerated )
    {
        (void) SetEvent( _hEventAppsEnumerated );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\main.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  main.cxx
//
//*************************************************************

#include "appmgext.hxx"

static SERVICE_STATUS gServiceStatus;
static SERVICE_STATUS_HANDLE ghServiceHandle;
static HINSTANCE ghInstAppmgmt;

extern "C" void
ServiceHandler(
    DWORD   OpCode
    );

void
UpdateState(
    DWORD   NewState
    );

extern "C" void
ServiceMain(
    DWORD               argc,
    LPWSTR              argv[]
    )
{
    DWORD   Status;
    BOOL    bStatus;

    Status = ERROR_SUCCESS;

    if ( ! gbInitialized )
        Initialize();

    InitDebugSupport( DEBUGMODE_SERVICE );

    VerboseDebugDump( L"Entering ServiceMain" );

    gServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    gServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    gServiceStatus.dwControlsAccepted = 0;
    gServiceStatus.dwWin32ExitCode = 0;
    gServiceStatus.dwServiceSpecificExitCode = 0;
    gServiceStatus.dwCheckPoint = 0;
    gServiceStatus.dwWaitHint = 10000L;

    ghServiceHandle = RegisterServiceCtrlHandler( L"APPMGMT", ServiceHandler );

    if ( ! ghServiceHandle )
        Status = GetLastError();

    if ( ERROR_SUCCESS == Status )
    {
        //
        // SD is null indicating that RPC should pick a default DACL.
        // which should be everybody can call and nobody can change this
        // permission
        //
        Status = RpcServerUseProtseqEp(
                    L"ncalrpc",
                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                    L"appmgmt",
                    NULL );
    }

    if ( ERROR_SUCCESS == Status )
        Status = RpcServerRegisterIf( appmgmt_ServerIfHandle, NULL, NULL );

    if ( Status != ERROR_SUCCESS )
    {
        gServiceStatus.dwWin32ExitCode = Status;
        UpdateState( SERVICE_STOPPED );
        return;
    }

    InitializeCriticalSection( &gAppCS );

    UpdateState( SERVICE_RUNNING );
}

extern "C" void
ServiceHandler(
    DWORD   OpCode
    )
{
    RPC_STATUS status;

    switch( OpCode )
    {
    case SERVICE_CONTROL_STOP:
        // Not registered for this control.
        break;

    case SERVICE_CONTROL_INTERROGATE:
        // Service controller wants us to call SetServiceStatus.
        UpdateState( gServiceStatus.dwCurrentState );
        break ;

    case SERVICE_CONTROL_SHUTDOWN:
        // Not registered for this control.
        break;

    // case SERVICE_CONTROL_PAUSE:
    // case SERVICE_CONTROL_CONTINUE:
    default:
        break;
    }

    return;
}

void
UpdateState(
    DWORD   NewState
    )
{
    DWORD Status = ERROR_SUCCESS;

    switch ( NewState )
    {
    case SERVICE_RUNNING:
    case SERVICE_STOPPED:
        gServiceStatus.dwCheckPoint = 0;
        gServiceStatus.dwWaitHint = 0;
        break;

    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:
        ++gServiceStatus.dwCheckPoint;
        gServiceStatus.dwWaitHint = 30000L;
        break;

    default:
        ASSERT(0);
        return;
    }

    gServiceStatus.dwCurrentState = NewState;
    SetServiceStatus( ghServiceHandle, &gServiceStatus );

    // We could return a status but how would we recover?  Ignore it, the
    // worst thing is that services will kill us and there's nothing
    // we can about it if this call fails.
}

void * midl_user_allocate( size_t len )
{
    return (void *) LocalAlloc( 0, len );
}

void midl_user_free( void * ptr )
{
    LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\debug.cxx ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "appmgext.hxx"

//
// Policy finish events for test code.  Only used if DL_EVENT debug
// level is on.
//
HANDLE ghUserPolicyEvent = 0;
HANDLE ghMachinePolicyEvent = 0;

void
CreatePolicyEvents()
{
    SECURITY_ATTRIBUTES SecAttr;
    SECURITY_DESCRIPTOR SecDesc;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PSID psidAdmin = NULL;
    PSID psidSystem = NULL;
    PSID psidEveryOne = NULL;
    PACL pAcl = NULL;
    DWORD cbMemSize;
    DWORD cbAcl;



    if ( ! (gDebugLevel & DL_EVENT) )
        return;

    if ( ghUserPolicyEvent && ghMachinePolicyEvent )
        return;

    
    //
    // Create an SD with following permissions
    //      LocalSystem:F
    //      Administrators:F
    //      EveryOne:Synchronize
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0, &psidSystem)) 
    {
         goto Exit;
    }

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) 
    {
        goto Exit;
    }

    if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) 
    {
        goto Exit;
    }
     
    cbAcl = (GetLengthSid (psidSystem)) +
            (GetLengthSid (psidAdmin))  +
            (GetLengthSid (psidEveryOne))  +
            sizeof(ACL) +
            (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    pAcl = (PACL) LocalAlloc(LPTR, cbAcl);
    
    if (!pAcl)
    {
       goto Exit;
    }

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) 
    {
        goto Exit;
    }

    if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, 0, GENERIC_ALL, psidSystem)) 
    {
        goto Exit;
    }

    if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, 0, GENERIC_ALL, psidAdmin)) 
    {
        goto Exit;
    }

    if (!AddAccessAllowedAceEx(pAcl, ACL_REVISION, 0, SYNCHRONIZE, psidEveryOne)) 
    {
        goto Exit;
    }

    if (!InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION )) 
    {
        goto Exit;
    }

    if (!SetSecurityDescriptorDacl( &SecDesc, TRUE, pAcl, FALSE )) 
    {
        goto Exit;
    }


    SecAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecAttr.lpSecurityDescriptor = &SecDesc;
    SecAttr.bInheritHandle = FALSE;

    if ( ! ghUserPolicyEvent )
    {
        ghUserPolicyEvent = CreateEvent(
                                &SecAttr,
                                TRUE,
                                FALSE,
                                L"AppMgmtUserPolicyEvent" );
    }

    if ( ! ghMachinePolicyEvent )
    {
        ghMachinePolicyEvent = CreateEvent(
                                &SecAttr,
                                TRUE,
                                FALSE,
                                L"AppMgmtMachinePolicyEvent" );
    }

Exit:
    if (psidSystem) 
    {
        FreeSid(psidSystem);
    }
    
    if (psidAdmin) 
    {
        FreeSid(psidAdmin);
    }
    
    if (psidEveryOne) 
    {
        FreeSid(psidEveryOne);
    }

    if (pAcl) 
    {
       LocalFree (pAcl);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\appmgmt\server\util.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  util.cxx
//
//*************************************************************

#include "appmgext.hxx"

SRSETRESTOREPOINTW * gpfnSRSetRetorePointW = 0;

BOOL
IsMemberOfAdminGroup(
    HANDLE hUserToken
    )
{
    SID_IDENTIFIER_AUTHORITY AuthorityNT = SECURITY_NT_AUTHORITY;
    PSID            pSidAdmin;
    BOOL            bStatus;
    BOOL            bIsAdmin;

    bIsAdmin = FALSE;
    pSidAdmin = 0;

    bStatus = AllocateAndInitializeSid( &AuthorityNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSidAdmin );

    if ( bStatus )
        bStatus = CheckTokenMembership( hUserToken, pSidAdmin, &bIsAdmin );

    FreeSid( pSidAdmin );

    return bIsAdmin;
}

DWORD
GetPreviousSid(
    HANDLE      hUserToken,
    WCHAR *     pwszCurrentScriptPath,
    WCHAR **    ppwszPreviousSid
    )
{
    HANDLE      hFind;
    WIN32_FIND_DATA FindData;
    PSID        pSid;
    WCHAR *     pwszSlash1;
    WCHAR *     pwszSlash2;
    WCHAR *     pwszSearchPath;
    DWORD       Length;
    DWORD       Status;
    BOOL        bMember;
    BOOL        bStatus;

    *ppwszPreviousSid = 0;

    //
    // Script dir paths created by GetScriptDirPath have '\' at the end.
    //
    pwszSlash1 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash1 = 0;
    pwszSlash2 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash2 = 0;

    Length = lstrlen(pwszCurrentScriptPath);
    pwszSearchPath = new WCHAR[Length + 3];

    if ( pwszSearchPath )
    {
        memcpy( pwszSearchPath, pwszCurrentScriptPath, Length * sizeof(WCHAR) );
        pwszSearchPath[Length] = L'\\';
        pwszSearchPath[Length+1] = L'*';
        pwszSearchPath[Length+2] = 0;
    }

    *pwszSlash1 = *pwszSlash2 = L'\\';
    
    if ( ! pwszSearchPath )
        return ERROR_OUTOFMEMORY;

    //
    // We've constructed a search path of %systemroot%\system32\appmgmt\*.
    //
    hFind = FindFirstFile( pwszSearchPath, &FindData );

    delete pwszSearchPath;

    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;

    do
    {
        if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
            continue;

        if ( (0 == lstrcmp( FindData.cFileName, L"." )) ||
             (0 == lstrcmp( FindData.cFileName, L".." )) ||
             (0 == lstrcmpi( FindData.cFileName, L"MACHINE" )) )
            continue;

        bMember = FALSE;
        pSid = 0;
        bStatus = ConvertStringSidToSid( FindData.cFileName, &pSid );

        if ( bStatus )
        {
            bStatus = CheckTokenMembership( hUserToken, pSid, &bMember );

            if ( bStatus && bMember )
                bStatus = ConvertSidToStringSid( pSid, ppwszPreviousSid );

            LocalFree( pSid );
        }

        if ( ! bStatus )
        {
            Status = GetLastError();
            break;
        }

        if ( bMember )
            break;
    } while ( FindNextFile( hFind, &FindData ) );

    FindClose( hFind );

    return Status;
}

DWORD
RenameScriptDir(
    WCHAR *     pwszPreviousSid,
    WCHAR *     pwszCurrentScriptPath
    )
{
    WCHAR * pwszSlash1;
    WCHAR * pwszSlash2;
    WCHAR * pwszOldScriptPath;
    DWORD   Length;
    BOOL    bStatus;

    //
    // Script dir paths created by GetScriptDirPath have '\' at the end.
    //
    pwszSlash1 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash1 = 0;
    pwszSlash2 = wcsrchr( pwszCurrentScriptPath, L'\\' );
    *pwszSlash2 = 0;

    Length = lstrlen( pwszCurrentScriptPath );

    pwszOldScriptPath = new WCHAR[Length + 1 + lstrlen(pwszPreviousSid) + 1];
    
    if ( pwszOldScriptPath )
    {
        memcpy( pwszOldScriptPath, pwszCurrentScriptPath, Length * sizeof(WCHAR) );
        pwszOldScriptPath[Length] = L'\\';
        lstrcpy( &pwszOldScriptPath[Length+1], pwszPreviousSid );
    }

    *pwszSlash1 = *pwszSlash2 = L'\\';

    if ( ! pwszOldScriptPath )
        return ERROR_OUTOFMEMORY;

    bStatus = MoveFileEx( pwszOldScriptPath, pwszCurrentScriptPath, 0 );

    delete pwszOldScriptPath;

    if ( ! bStatus )
        return GetLastError();

    return ERROR_SUCCESS;
}

DWORD
GetCurrentUserGPOList( 
    OUT PGROUP_POLICY_OBJECT* ppGpoList // Free this with the FreeGPOList API
    )
{
    GUID  AppmgmtExtension = {0xc6dc5466, 0x785a, 0x11d2, 
                              0x84, 0xd0,
                              0x00, 0xc0, 0x4f, 0xb1, 0x69, 0xf7};

    return GetAppliedGPOList(
        0,
        NULL,
        NULL,
        &AppmgmtExtension,
        ppGpoList);
} 


DWORD GetWin32ErrFromHResult( HRESULT hr )
{
    DWORD   Status = ERROR_SUCCESS;

    if (S_OK != hr)
    {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            Status = GetLastError();
            if (ERROR_SUCCESS == Status)
            {
                //an error had occurred but nobody called SetLastError
                //should not be mistaken as a success.
                Status = (DWORD) hr;
            }
        }
    }

    return Status;
}

void  ClearManagedApp( MANAGED_APP* pManagedApp )
{
    if (pManagedApp->pszPackageName)
    {
        midl_user_free(pManagedApp->pszPackageName);
    }

    if (pManagedApp->pszSupportUrl)
    {
        midl_user_free(pManagedApp->pszSupportUrl);
    }

    if (pManagedApp->pszPolicyName)
    {
        midl_user_free(pManagedApp->pszPolicyName);
    }

    if (pManagedApp->pszPublisher)
    {
        midl_user_free(pManagedApp->pszPublisher);
    }

    //
    // Make sure to clear the structure if there is a failure
    // so we won't try to marshal bogus data
    //
    memset(pManagedApp, 0, sizeof(*pManagedApp));
}

CLoadSfc::CLoadSfc( DWORD &Status )
{
    hSfc = LoadLibrary( L"sfc.dll" );

    if ( ! hSfc )
    {
        Status = GetLastError();
        return;
    }

    gpfnSRSetRetorePointW = (SRSETRESTOREPOINTW *) GetProcAddress( hSfc, "SRSetRestorePointW" );

    if ( ! gpfnSRSetRetorePointW )
    {
        Status = ERROR_PROC_NOT_FOUND;
        return;
    }

    Status = ERROR_SUCCESS;
}

CLoadSfc::~CLoadSfc()
{
    if ( hSfc )
        FreeLibrary( hSfc );
}

//
// Force policy to be synchronous at next refresh --
// use a token for user policy, NULL for machine policy
//
DWORD ForceSynchronousRefresh( HANDLE hUserToken )
{
    LONG           Status;
    UNICODE_STRING SidString;

    Status = GetSidString( hUserToken, &SidString );

    if ( ERROR_SUCCESS == Status )
    {
        //
        // Inform the gp engine to give us a sync refresh
        //
        Status = ForceSyncFgPolicy( SidString.Buffer );

        RtlFreeUnicodeString( &SidString );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\inc\schema.h ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998 - 2000
//  All rights reserved
//
//  schema.h
//
//  This file contains declarations related to the wmi schema
//  for rsop policy objects
//
//*************************************************************

//
// WMI intrinsic properties
//
#define WMI_PATH_PROPERTY                          L"__PATH"


//
// Rsop base properties
//

#define RSOP_POLICY_SETTING                        L"RSOP_PolicySetting"

// Unique id
#define RSOP_ATTRIBUTE_ID                          L"id"

// A user friendly name.
#define RSOP_ATTRIBUTE_NAME                        L"name"

// The scope of management links to the gpo
// of this policy object 
#define RSOP_ATTRIBUTE_SOMID                       L"SOMID"

// The creation time of this instance
#define RSOP_ATTRIBUTE_CREATIONTIME                L"creationTime"

// The GPO Identifier for this PO.  Using this and the policy class you
// can get back to the GPO Object of which this is an identifier
#define RSOP_ATTRIBUTE_GPOID                       L"GPOID"

// This is the order in which the policy is applied when 
// considering only its class.
#define RSOP_ATTRIBUTE_PRECEDENCE                  L"precedence"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\rsop\dllload.cxx ===
//*************************************************************
//
//  DLL loading functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995 - 2000
//  All rights reserved
//
//*************************************************************

#include "rsop.hxx"

//
// file global variables containing pointers to APIs and
// loaded modules
//

OLE32_API       g_Ole32Api;

CRITICAL_SECTION g_ApiDLLCritSec;

//*************************************************************
//
//  InitializeAPIs()
//
//  Purpose:    initializes API structures for delay loaded
//              modules
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void InitializeAPIs( void )
{
    ZeroMemory( &g_Ole32Api,    sizeof( OLE32_API ) );
}

//*************************************************************
//
//  InitializeApiDLLsCritSec()
//
//  Purpose:    initializes a CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void InitializeApiDLLsCritSec( void )
{
    InitializeCriticalSection( &g_ApiDLLCritSec );
}

//*************************************************************
//
//  CloseApiDLLsCritSec()
//
//  Purpose:    clean up CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void CloseApiDLLsCritSec( void )
{
    DeleteCriticalSection( &g_ApiDLLCritSec );
}

//*************************************************************
//
//  LoadOle32Api()
//
//  Purpose:    Loads ole32.dll
//
//  Parameters: none
//
//  Return:     pointer to OLE32_API
//
//*************************************************************

POLE32_API LoadOle32Api()
{
    BOOL bResult = FALSE;
    OLE32_API *pOle32Api = &g_Ole32Api;

    if ( pOle32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        return pOle32Api;
    }

    pOle32Api->hInstance = LoadLibrary (TEXT("ole32.dll"));

    if (!pOle32Api->hInstance) {
        goto Exit;
    }

    pOle32Api->pfnCoCreateInstance = (PFNCOCREATEINSTANCE) GetProcAddress (pOle32Api->hInstance,
                                                                           "CoCreateInstance");
    if (!pOle32Api->pfnCoCreateInstance) {
        goto Exit;
    }

    pOle32Api->pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress (pOle32Api->hInstance,
                                                                       "CoInitializeEx");
    if (!pOle32Api->pfnCoInitializeEx) {
        goto Exit;
    }

    pOle32Api->pfnCoUnInitialize = (PFNCOUNINITIALIZE) GetProcAddress (pOle32Api->hInstance,
                                                                        "CoUninitialize");
    if (!pOle32Api->pfnCoUnInitialize) {
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        if ( pOle32Api->hInstance ) {
            FreeLibrary( pOle32Api->hInstance );
        }

        ZeroMemory( pOle32Api, sizeof( OLE32_API ) );
        pOle32Api = 0;
    }

    return pOle32Api;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\rsop\polbase.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  polbase.cxx
//
//*************************************************************

#include "rsop.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::CPolicyDatabase
//
// Purpose: Constructor for CPolicyDatabase
//
// Params: 
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
CPolicyDatabase::CPolicyDatabase() :
    _hrInit(E_OUTOFMEMORY)
{}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::~CPolicyDatabase
//
// Purpose: destructor for CPolicyDatabase -- uninitializes
//     COM
//
// Params: 
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
CPolicyDatabase::~CPolicyDatabase()
{
    //
    // Clean up COM state
    //
    if ( SUCCEEDED(_hrInit) )
    {
        _pOle32Api->pfnCoUnInitialize();
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::InitializeCOM
//
// Purpose: Initializes the calling thread for COM, loading
//          necessary dll's and function entry points
//
// Params: none
//
//
// Return value: S_OK if successful, other facility error if
//         the function fails.
//
// Notes:  State initialized by this call is cleaned up by
//         the destructor
//
//------------------------------------------------------------
HRESULT CPolicyDatabase::InitializeCOM()
{
    //
    // Need to dynamically load the the COM api's since
    // the policy database is accessed through COM.
    //
    _pOle32Api = LoadOle32Api();
    
    if ( _pOle32Api ) 
    {
        //
        // If we successfully loaded COM, initialize it
        //
        _hrInit = _pOle32Api->pfnCoInitializeEx( NULL, COINIT_MULTITHREADED );
    }
    else
    {
        _hrInit = HRESULT_FROM_WIN32(GetLastError());   
    }

    return _hrInit;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::Bind
//
// Purpose: Bind to a policy database and return an interface
//          for the user or machine namespace
//
// Params:
//
//
// Return value: S_OK if successful, other facility error if
//         the function fails.
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyDatabase::Bind(
    WCHAR*          wszRequestedNameSpace,
    IWbemServices** ppWbemServices)
{
    HRESULT       hr;

    hr = InitializeCOM();

    if ( FAILED(hr) )
    {
        return hr;
    }

    XInterface<IWbemLocator> xLocator; // Interface used to locate classes

    //
    // To bind, we use COM to request the COM interface to
    // the database
    //
    hr = _pOle32Api->pfnCoCreateInstance( CLSID_WbemLocator,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IWbemLocator,
                                          (LPVOID *) &xLocator );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Refer to the namespace with an automation type so that
    // we can make use of the locator interface, which takes bstr's.
    //
    XBStr xNameSpace( wszRequestedNameSpace );

    //
    // Verify the initialization of the bstr
    //
    if ( !xNameSpace )
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Now connect to the namespace requested by the caller
        //
        hr = xLocator->ConnectServer( xNameSpace,
                                       NULL,
                                       NULL,
                                       0L,
                                       0L,
                                       NULL,
                                       NULL,
                                       ppWbemServices );
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetUnknown
//
// Purpose: retrieves an IUnknown for this policy record --
//    useful if this policy record itself needs to be nested
//    inside another record and we want to use VT_UNKNOWN to
//    do this.
//
// Params: ppUnk -- out param for IUnknown
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::GetUnknown(IUnknown** ppUnk)
{
    HRESULT hr;

    hr = GetRecordInterface()->QueryInterface(
        IID_IUnknown,
        (LPVOID*) ppUnk);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::InitRecord
//
// Purpose: Initializes a policy record with the database's
//     record interface, thereby connecting this record object
//     with the database record abstraction.
//
// Params: pRecordInterface -- the database's record interface
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
void CPolicyRecord::InitRecord(IWbemClassObject* pRecordInterface)
{
    _xRecordInterface = pRecordInterface;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         wszValue -- unicode value to which to set it
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR* wszValueName,
    WCHAR* wszValue)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! wszValue )
    {
        return S_OK;
    }

    //
    // Set up a variant for the value itself
    //
    hr = varValue.SetStringValue(wszValue);    

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         lzValue -- long value to which to set it
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR* wszValueName,
    LONG   Value)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Set up a variant for the value itself
    //
    varValue.SetLongValue(Value);    

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         bValue -- boolean value to which to set it
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR* wszValueName,
    BOOL   bValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Set up a variant for the value itself
    //
    varValue.SetBoolValue(bValue);    

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         pTime -- time to which to set the value
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*      wszValueName,
    SYSTEMTIME* pTimeValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Set up a variant for the value itself
    //
    XBStr xTimeString;

    hr = SystemTimeToWbemTime( *pTimeValue, xTimeString );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = varValue.SetStringValue( xTimeString );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Adds an element to an array value (column)
//     of a database record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         rgwszValues -- string array to which to set this value
//         cMaxElements -- number of elements in the array
//
// Return value: S_OK if successful, S_FALSE if successful
//         and the array is now full, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*  wszValueName,
    WCHAR** rgwszValues,
    DWORD   cMaxElements)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! cMaxElements )
    {
        return S_OK;
    }

    DWORD iElement;

    for (iElement = 0; iElement < cMaxElements; iElement++)
    {
        //
        // Now set up a variant for the value itself
        //
        hr = varValue.SetNextStringArrayElement(
            rgwszValues[iElement],
            cMaxElements);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We will only write this once we have all the data --
    // The set function above will return S_FALSE if the
    // array is full, so we check for that below
    //
    ASSERT( (S_FALSE == hr) || ! cMaxElements );

    //
    // Now that we have all the data, call the method
    // to set it
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Adds an element to an array value (column)
//     of a database record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         rgValues -- LONG array to which to set this value
//         cMaxElements -- number of in the array 
//
// Return value: S_OK if successful, S_FALSE if successful
//         and the array is now full, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*  wszValueName,
    LONG*   rgValues,
    DWORD   cMaxElements)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! cMaxElements )
    {
        return S_OK;
    }

    DWORD iElement;

    for (iElement = 0; iElement < cMaxElements; iElement++)
    {
        //
        // Now set up a variant for the value itself
        //
        hr = varValue.SetNextLongArrayElement(
            rgValues[iElement],
            cMaxElements);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We will only write this once we have all the data --
    // The set function above will return S_FALSE if the
    // array is full, so we check for that below
    //
    ASSERT( (S_FALSE == hr) || ! cMaxElements );

    //
    // Now that we have all the data, call the method
    // to set it
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a record's value to that of the specified byte array
//
// Params: wszValueName -- name of value (column) to set
//         rgValues  -- byte array to which to set this value
//         cMaxElements -- number of elements in the array
//
// Return value: S_OK if successful, S_FALSE if successful
//         and the array is now full, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*  wszValueName,
    BYTE*   rgValues,
    DWORD   cMaxElements)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! cMaxElements )
    {
        return S_OK;
    }

    DWORD iElement;

    for (iElement = 0; iElement < cMaxElements; iElement++)
    {
        //
        // Now set up a variant for the value itself
        //
        hr = varValue.SetNextByteArrayElement(
            rgValues[iElement],
            cMaxElements);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We will only write this once we have all the data --
    // The set function above will return S_FALSE if the
    // array is full, so we check for that below
    //
    ASSERT( (S_FALSE == hr) || ! cMaxElements );

    //
    // Now that we have all the data, call the method
    // to set it
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearValue
//
// Purpose: Sets a value to VT_NULL
//
// Params: wszValueName -- name of value (column) to set
//
// Return value: S_OK if successful, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::ClearValue(
        WCHAR*  wszValueName)
{
    CVariant varValue;
    HRESULT  hr;

    ( (VARIANT*) varValue )->vt = VT_NULL;

    //
    // Set this to an empty value by passing it an
    // empty variant
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0L,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetValue
//
// Purpose: Reads the named column of the record into a LONG
//
// Params: wszValueName -- name of value (column) to get
//         pValue -- pointer to LONG for contents of column
//
// Return value: S_OK if successful, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::GetValue(
    WCHAR*        wszValueName,
    LONG*         pValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Now that we have the value name, call the method
    // to set it
    //
    hr = _xRecordInterface->Get(
        wszValueName,
        0L,
        (VARIANT*) &varValue,
        NULL,
        NULL);

    if ( SUCCEEDED(hr) )
    {
        if ( varValue.IsLongValue() )
        {
            *pValue = ((VARIANT*)varValue)->lVal;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetValue
//
// Purpose: Reads the named column of the record into a WCHAR*
//
// Params: wszValueName -- name of value (column) to get
//         pwszValue -- pointer to caller allocated buffer for
//         data
//         pcchValue -- on success, the length of the string in chars
//         written to pwszValue.  If the function returns
//         S_FALSE, this is the length in chars required to
//         write the string including the zero terminator
//
// Return value: S_OK if successful, S_FALSE if insufficient
//         buffer, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::GetValue(
    WCHAR*        wszValueName,
    WCHAR*        wszValue,
    LONG*         pcchValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Now that we have the value name, call the method
    // to set it
    //
    hr = _xRecordInterface->Get(
        wszValueName,
        0L,
        (VARIANT*) &varValue,
        NULL,
        NULL);

    if ( SUCCEEDED(hr) )
    {
        if ( varValue.IsStringValue() )
        {
            LONG Required;
        
            Required = ( SysStringLen( ((VARIANT*)varValue)->bstrVal ) + 1 );

            if ( Required <= *pcchValue )
            {
                lstrcpy( wszValue, ((VARIANT*)varValue)->bstrVal );
            }
            else
            {
                *pcchValue = Required;
                hr = S_FALSE;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetRecordInterface
//
// Purpose: private method to allow the log class to
//     manipulate this record object through the
//     record object's encapsulated database record
//     interface.
//
// Params:
//
// Return value: a database record interface
//
// Notes:  Should never fail unless called in 
//     inappropriate circumstances (e.g. unit'ed object)
//
//------------------------------------------------------------
IWbemClassObject* CPolicyRecord::GetRecordInterface()
{
    return _xRecordInterface;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecordStatus::CPolicyRecordStatus
//
// Purpose: constructore for CPolicyRecordStatus
//
//------------------------------------------------------------
CPolicyRecordStatus::CPolicyRecordStatus() :
    _SettingStatus( RSOPIgnored )
{}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecordStatus::SetRsopFailureStatus
//
// Purpose: set a record's failure status data
//
// Params: dwStatus -- os error code for the setting represented by this record
//         dwEventId -- event log id for the attempt to apply this setting
//
// Return value: none
//
// Notes:  Does not fail -- should only be called in diagnostic (logging) mode
//
//------------------------------------------------------------
void CPolicyRecordStatus::SetRsopFailureStatus(
    DWORD     dwStatus,
    DWORD     dwEventId)
{
    SETTINGSTATUS       SettingStatus;

    //
    // Setting status is based on the error code
    //
    SettingStatus = ( ERROR_SUCCESS != dwStatus ) ? RSOPFailed : RSOPApplied;

    //
    // Get the current time -- this does not fail
    //
    GetSystemTime( &_StatusTime );

    //
    // Now set the record's failure status data
    //
    _SettingStatus = SettingStatus;
    _dwEventId = dwEventId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\rsop\context.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  context.cxx
//
//*************************************************************

#include "rsop.hxx"

CRsopContext::CRsopContext(
    PRSOP_TARGET pRsopTarget,
    WCHAR*       wszExtensionGuid
    ) : 
    _pWbemServices( pRsopTarget->pWbemServices ),
    _wszNameSpace( NULL ),
    _pRsopTarget( pRsopTarget ),
    _bEnabled( TRUE ),
    _dwMode( MODE_PLANNING ),
    _phrLoggingStatus ( NULL ),
    _hPolicyAccess( NULL ),
    _wszExtensionGuid( wszExtensionGuid ),
    _hkRsop( NULL )
{
    _pWbemServices->AddRef();
}


CRsopContext::CRsopContext(
    IWbemServices* pWbemServices,
    HRESULT*       phrLoggingStatus,
    WCHAR*         wszExtensionGuid
    ) :
    _pWbemServices( pWbemServices ),
    _wszNameSpace( NULL ),
    _pRsopTarget( NULL ),
    _bEnabled( pWbemServices != NULL ),
    _dwMode( MODE_DIAGNOSTIC ),
    _phrLoggingStatus ( phrLoggingStatus ),
    _hPolicyAccess( NULL ),
    _wszExtensionGuid( wszExtensionGuid ),
    _hkRsop( NULL )
{
    if ( _bEnabled )
    {
        _pWbemServices->AddRef();
    }
}

CRsopContext::CRsopContext(
    WCHAR* wszExtensionGuid
    ) : 
    _pWbemServices( NULL ),
    _wszNameSpace( NULL ),
    _pRsopTarget( NULL ),
    _bEnabled( FALSE ),
    _dwMode( MODE_DIAGNOSTIC ),
    _phrLoggingStatus ( NULL ),
    _hPolicyAccess( NULL ),
    _wszExtensionGuid( wszExtensionGuid ),
    _hkRsop( NULL )
{}


CRsopContext::~CRsopContext()
{
    ASSERT( ! _hPolicyAccess );

    //
    // Set the final logging status
    //
    if ( _bEnabled && _phrLoggingStatus )
    {
        *_phrLoggingStatus = S_OK;
    }

    if ( _pWbemServices )
    {
        _pWbemServices->Release();
    }

    delete [] _wszNameSpace;

    if ( _hkRsop )
    {
        RegCloseKey( _hkRsop );
    }
}

BOOL CRsopContext::IsRsopEnabled()
{
    return _bEnabled;
}

BOOL CRsopContext::IsPlanningModeEnabled()
{
    return _dwMode == MODE_PLANNING;
}

BOOL CRsopContext::IsDiagnosticModeEnabled()
{
    return _dwMode == MODE_DIAGNOSTIC;
}

HRESULT CRsopContext::GetRsopStatus()
{
    HRESULT hr;

    hr = S_OK;

    if ( _phrLoggingStatus )
    {
        hr = *_phrLoggingStatus;
    }

    return hr;
}

void CRsopContext::SetNameSpace ( WCHAR* wszNameSpace )
{
    _wszNameSpace = wszNameSpace;

    if ( _wszNameSpace )
    {
        EnableRsop();
    }
}

void CRsopContext::EnableRsop()
{
    _bEnabled = (NULL != _pWbemServices) || 
        ( NULL != _wszNameSpace );
}

void CRsopContext::DisableRsop( HRESULT hrReason )
{
    if ( _bEnabled && _phrLoggingStatus )
    {
        *_phrLoggingStatus = hrReason;
    }

    _bEnabled = FALSE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRsopContext::Bind
//
// Purpose: Bind to a policy database and return an interface
//          for the user or machine namespace
//
// Params:
//
//
// Return value: S_OK if successful, S_FALSE if already init'd,
//         other facility error if, the function fails.
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CRsopContext::Bind( IWbemServices** ppWbemServices )
{
    HRESULT       hr;

    ASSERT ( _bEnabled );

    hr = S_OK;

    //
    // Only bind to the database if we don't already have an interface
    //
    if ( ! _pWbemServices )
    {
        //
        // If we don't have one, we'll have to bind
        // using the namespace path
        //
        hr = _PolicyDatabase.Bind(
            _wszNameSpace,
            &_pWbemServices);
    }

    //
    // If we already have an interface, return that
    //
    if ( _pWbemServices )
    {
        *ppWbemServices = _pWbemServices;
        hr = S_FALSE;
    }

    if ( FAILED(hr) )
    {
        DisableRsop( hr );
    }

    return hr;
}
   

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRsopContext::GetNameSpace
//
// Purpose: Gets the namespace to which this context  is bound
//
// Params: ppwszNameSpace -- out parameter that will point
//     to the address of a string that has the namespace --
//     this memory should be freed by the caller
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CRsopContext::GetNameSpace( WCHAR** ppwszNameSpace )
{
    LPWSTR            wszNamespaceEnd;
    LPWSTR            wszNameSpace;
    CVariant          var;
    IWbemClassObject* pWbemClassObject;

    XBStr             xbstrPath( L"__PATH" );
    XBStr             xbstrClass( RSOP_POLICY_SETTING );

    if ( ! xbstrPath || ! xbstrClass )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT  hr;

    pWbemClassObject = NULL;

    //
    // Get the class
    //
    hr = _pWbemServices->GetObject(
        xbstrClass,
        0L,
        NULL,
        &pWbemClassObject,
        NULL );

    if ( SUCCEEDED( hr ) )
    {
        
        //
        // Read the path property of the class from the class object
        //
        hr = pWbemClassObject->Get(
            xbstrPath,
            0L,
            (VARIANT*) &var,
            NULL,
            NULL);

        pWbemClassObject->Release();
    }

    //
    // Now parse the path to obtain the parent namespace of 
    // the class, which is the namespace in which the
    // IWbemServices pointer resides
    //

    //
    // Find the end of the class name so we can null-terminate it
    //
    if ( SUCCEEDED( hr ) )
    {
        //
        // Look for the delimiter that terminates the class name
        //
        wszNamespaceEnd = wcschr( ((VARIANT*) &var)->bstrVal, L':' );

        //
        // If we found the delimiter, terminate the string there
        //
        if ( wszNamespaceEnd )
        {
            *wszNamespaceEnd = L'\0';
        }
                        
        //
        // Allocate space for the namespace string
        //
        wszNameSpace = new WCHAR [ wcslen( ((VARIANT*) &var)->bstrVal ) + 1 ];
        
        //
        // If we got space for the namespace, copy it
        //
        if ( wszNameSpace )
        {
            wcscpy( wszNameSpace, ((VARIANT*) &var)->bstrVal );
            *ppwszNameSpace = wszNameSpace;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT
CRsopContext::MoveContextState( CRsopContext* pRsopContext )
{
    _pWbemServices = pRsopContext->_pWbemServices;

    if ( _pWbemServices )
    {
        _pWbemServices->AddRef();
    }

    _bEnabled = pRsopContext->_bEnabled;

    _dwMode = pRsopContext->_dwMode;

    _phrLoggingStatus = pRsopContext->_phrLoggingStatus;

    pRsopContext->_phrLoggingStatus = NULL;

    _wszNameSpace = pRsopContext->_wszNameSpace;

    pRsopContext->_wszNameSpace = NULL;

    _pRsopTarget = pRsopContext->_pRsopTarget;

    _wszExtensionGuid = pRsopContext->_wszExtensionGuid;

    _hkRsop = pRsopContext->_hkRsop;

    pRsopContext->_hkRsop = NULL;

    return S_OK;
}

HRESULT
CRsopContext::GetExclusiveLoggingAccess( BOOL bMachine )
{
    HRESULT hr;

    hr = S_OK;

    ASSERT( ! _hPolicyAccess );

    //
    // We require exclusive access in diagnostic mode only --
    // in planning mode, we have implicit exclusive access
    //
    if ( IsRsopEnabled() && IsDiagnosticModeEnabled() )
    {
        _hPolicyAccess = EnterCriticalPolicySection( bMachine );

        //
        // On failure, disable logging
        //
        if ( ! _hPolicyAccess )
        {
            LONG Status;

            Status = GetLastError();

            hr = HRESULT_FROM_WIN32( Status );

            if ( SUCCEEDED( hr ) )
            {
                hr = E_FAIL;
            }

            DisableRsop( hr );
        }
    }
    
    return hr;
}
 
void
CRsopContext::ReleaseExclusiveLoggingAccess()
{
    if ( _hPolicyAccess )
    {
        LeaveCriticalPolicySection( _hPolicyAccess );
        
        _hPolicyAccess = NULL;
    }
}


LONG
CRsopContext::GetRsopNamespaceKeyPath(
    PSID    pUserSid,
    WCHAR** ppwszDiagnostic )
{
    LONG           Status;
    UNICODE_STRING SidString;
    WCHAR*         wszUserSubkey;

    *ppwszDiagnostic = NULL;

    RtlInitUnicodeString( &SidString, NULL );

    wszUserSubkey = NULL;

    Status = ERROR_SUCCESS;

    //
    // First, get the subkey
    //
    if ( pUserSid )
    {
        NTSTATUS NtStatus;

        if ( pUserSid )
        {
            NtStatus = RtlConvertSidToUnicodeString(
                &SidString,
                pUserSid,
                TRUE);

            if ( NT_SUCCESS( NtStatus ) )
            {
                wszUserSubkey = SidString.Buffer;
            }
            else
            {
                Status = RtlNtStatusToDosError( NtStatus );
            }
        }
        else
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        wszUserSubkey = MACHINESUBKEY;
    }

    //
    // If we have obtained the full subkey, we can now
    // generate the path for it
    //
    if ( ERROR_SUCCESS == Status )
    {
        DWORD cchLen;

        //
        // Space for the user sid string + the pathsep
        //
        cchLen = lstrlen ( wszUserSubkey ) + 1;

        //
        // Space for the gp extension state parent + extension list key (includes both pathseps and null terminator) +
        // + the cse subkey
        //
        cchLen += ( sizeof( GPSTATEKEY ) + sizeof( EXTENSIONLISTKEY ) ) / sizeof( *wszUserSubkey ) + 
            lstrlen( _wszExtensionGuid );

        *ppwszDiagnostic = new WCHAR[ cchLen ];

        if ( *ppwszDiagnostic )
        {
            lstrcpy( *ppwszDiagnostic, GPSTATEKEY L"\\" );
            lstrcat( *ppwszDiagnostic, wszUserSubkey );
            lstrcat( *ppwszDiagnostic, EXTENSIONLISTKEY );
            lstrcat( *ppwszDiagnostic, _wszExtensionGuid );
        }
        else
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }

    //
    // Free allocated resources
    //
    if ( SidString.Buffer )
    {
        RtlFreeUnicodeString( &SidString );
    }

    return Status;
}

void
CRsopContext::InitializeContext( PSID pUserSid )
{
    LONG   Status;
    WCHAR* wszNameSpace;
    WCHAR* wszNameSpaceKeyPath;

    //
    // In planning mode, all initialization is
    // already done, there is nothing to do here
    //
    if ( IsPlanningModeEnabled() )
    {
        return;
    }

    //
    // Return successfully if we already have our key.
    //
    if ( _hkRsop )
        return;
    
    Status = ERROR_SUCCESS;

    //
    // First, we need to get the rsop subkey -- we must ensure that it exists
    //
    Status = GetRsopNamespaceKeyPath(
        pUserSid,
        &wszNameSpaceKeyPath);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We create a key under the user's per machine policy
        // subtree.  This key must be persistent so that extensions
        // that process policy outside of the policy engine context
        // or in no changes when the policy engine does not pass
        // a namepsace to the extension can know whether RSoP is enabled
        // or not and where to log the data
        //
        Status = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            wszNameSpaceKeyPath,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &_hkRsop,
            NULL );

        delete [] wszNameSpaceKeyPath;
    }

    if ( ERROR_SUCCESS != Status )
    {
        HRESULT hr;

        hr = HRESULT_FROM_WIN32( Status );

        DisableRsop( hr );
    }
}

void
CRsopContext::InitializeSavedNameSpace()
{
    LONG   Status;
 
    if ( ! _hkRsop )
    {
        return;
    }

    //
    // In planning mode, all initialization is
    // already done, there is nothing to do here
    //
    if ( IsPlanningModeEnabled() )
    {
        return;
    }
    
    Status = ERROR_SUCCESS;
 
    //
    // If we already have a namespace, there is no need to use the saved
    // namespace, so we can leave since we've ensured the existence of the namespace key
    //
    if ( HasNameSpace() )
    {
        return;
    }
    
    //
    // The rsop namespace for this user is stored in the registry -- 
    // we query this below
    //
    DWORD  Size;

    Size = 0;

    Status = RegQueryValueEx(
        _hkRsop,
        RSOPNAMESPACE,
        NULL,
        NULL,
        NULL,
        &Size);

    if ( ERROR_SUCCESS == Status )
    {
        WCHAR* wszNameSpace;

        wszNameSpace = (WCHAR*) new BYTE [ Size ];

        if ( ! wszNameSpace )
        {
            Status = ERROR_OUTOFMEMORY;

            goto CRsopContext__InitializeSavedNameSpace__Exit;
        }

        Status = RegQueryValueEx(
            _hkRsop,
            RSOPNAMESPACE,
            NULL,
            NULL,
            (LPBYTE) wszNameSpace,
            &Size);

        if ( ERROR_SUCCESS != Status )
        {
            delete [] wszNameSpace;
            wszNameSpace = NULL;
        }
        else
        {
            SetNameSpace( wszNameSpace );
        }
    }

 CRsopContext__InitializeSavedNameSpace__Exit:
    
    if ( ERROR_SUCCESS != Status )
    {
        HRESULT hr;

        hr = HRESULT_FROM_WIN32( Status );

        DisableRsop( hr );
    }
}


void
CRsopContext::SaveNameSpace()
{
    WCHAR*  wszNameSpace;
    HRESULT hr;

    if ( ! IsRsopEnabled() )
    {
        return;
    }

    if ( IsPlanningModeEnabled() )
    {
        return;
    }
    
    wszNameSpace = NULL;

    //
    // Retrieve the rsop namespace -- note that the retrieved
    // string should be freed
    //
    hr = GetNameSpace( &wszNameSpace );

    if ( SUCCEEDED( hr ) )
    {
#if DBG
        DWORD
        DebugStatus =
#endif // DBG
            RegSetValueEx( _hkRsop,
                           RSOPNAMESPACE,
                           0,
                           REG_SZ,
                           (LPBYTE) wszNameSpace,
                           lstrlen( wszNameSpace ) * sizeof(WCHAR) );
    }

    delete [] wszNameSpace;
}

void
CRsopContext::DeleteSavedNameSpace()
{
    if ( IsPlanningModeEnabled() )
    {
        return;
    }
    
#if DBG
    DWORD
    DebugStatus =
#endif // DBG
        RegDeleteValue( _hkRsop,
                        RSOPNAMESPACE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\rsop\pollog.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  pollog.cxx
//
//*************************************************************

#include "rsop.hxx"

#define RECORD_ENUMERATION_TIMEOUT -1

XBStr CPolicyLog::_xbstrQueryLanguage( L"WQL" );

#define WSZGENERAL_CRITERIA_TEMPLATE L"select * from %s"
#define WSZSPECIFIC_CRITERIA_TEMPLATE WSZGENERAL_CRITERIA_TEMPLATE L" where %s"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::CPolicyLog
//
// Purpose: Constructor for CPolicyLog class
//
// Params: none
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
CPolicyLog::CPolicyLog() :
    _pRsopContext(NULL )
{}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::InitLog
//
// Purpose: Initializes the logging class so that it
//     can create / delete / edit record in the database
//
// Params:
//     pRsopContext -- context used to bind to the namespace
//     wszPolicyType -- string corresponding to the record
//     (policy) type -- this is the name of a class defined
//     in the database schema.
//
// Return value: S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::InitLog(
    CRsopContext* pRsopContext,
    WCHAR*        wszPolicyType)
{
    HRESULT          hr;

    _pRsopContext = pRsopContext;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Set our internal automation compatible version
    // of the policy type with the caller's specification --
    // return if we cannot set this value
    //
    _wszClass = wszPolicyType;

    XBStr xbstrClass;

    xbstrClass = wszPolicyType;

    if ( ! xbstrClass )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Now, bind the context to get the correct namespace
    //
    hr = pRsopContext->Bind( &_xWbemServices );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Be sure to AddRef it, since we don't want it to
    // go away when we're done
    //
    _xWbemServices->AddRef();

    //
    // Now we attempt to get an interface to the class of policy
    // requested by the caller
    //
    hr = GetRecordCreator(
        &xbstrClass,
        &_xRecordCreator);

    if (FAILED(hr))
    {
        return hr;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::UninitLog
//
// Purpose: Uninitializes the logging class so that all
//     its resources are freed
//
// Params: none
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
void CPolicyLog::UninitLog()
{
    _xEnum = NULL;
  
    _xWbemServices = NULL;

    _xRecordCreator = NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::AddBlankRecord
//
// Purpose: Creates a blank record in the policy database,
//     and connects the supplied CPolicyRecord with the
//     newly created record
//
// Params: pRecord -- reference to a CPolicyRecord which will
//     be associated with the new record if this funciton
//    succeeds.
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::AddBlankRecord(CPolicyRecord* pRecord)
{
    HRESULT           hr;
    IWbemClassObject* pRecordInterface;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    pRecordInterface = NULL;

    //
    // Use the record creator interface to create 
    // an instance of the class of record associated
    // with this log
    //
    hr = _xRecordCreator->SpawnInstance(
        0,
        &pRecordInterface);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Initialize the CPolicyRecord so that it is
    // associated with the newly created record
    //
    pRecord->InitRecord(pRecordInterface);

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::CommitRecord
//
// Purpose: Commits an edited policy record to the database
//
// Params: pRecord -- the record to commit
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::CommitRecord(CPolicyRecord* pRecord)
{
    return _xWbemServices->PutInstance(
        pRecord->GetRecordInterface(),
        WBEM_FLAG_CREATE_OR_UPDATE,
        NULL,
        NULL);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::WriteNewRecord
//
// Purpose: Creates a new record in the database, populates
//     that record with information specific to the CPolicyRecord
//     object, and commits the record.
//
// Params: pRecord -- reference to a CPolicyRecord which contains
//     information that should be written to the database
//
// Return S_OK if success, error otherwise
//
// Notes:  The pRecord object may not be passed to this
//         method more than once
//
//------------------------------------------------------------
HRESULT CPolicyLog::WriteNewRecord(CPolicyRecord* pRecord)
{
    HRESULT hr;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Now, let's attempt to add a blank entry for this record to the database
    //
    hr = AddBlankRecord( pRecord );

    if (FAILED(hr)) 
    {
        return hr;
    }

    //
    // Write the information for this record into the blank log record 
    //
    hr = pRecord->Write();

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We've written the record, now commit it permanently to the log
    // in the database
    //
    hr = CommitRecord( pRecord );

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetRecordCreator
//
// Purpose: Returns an interface that allows for the creation
//     of records of a specified class in the database
//
// Params: pStrClass -- a string named with a class as defined
//     by the database schema that indicates the class for
//     which we require an interface
//
//     ppClass -- out param returning an interface to the
//     record creator for a given class
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::GetRecordCreator(
    XBStr*             pxStrClass,
    IWbemClassObject** ppClass)
{
    HRESULT          hr;

    //
    // Call the method of the namespace interface to return
    // an instance of the specified class defined in that namespace
    //
    hr = _xWbemServices->GetObject(
        *pxStrClass,
        0L,
        NULL,
        ppClass,
        NULL );

    return hr;
} 


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetNextRecord
//
// Purpose: Associates a CPolicyRecord with a database
//     record that's next in the current enumeration
//
// Params: pRecord -- CPolicyRecord to be associated with
//     the next db record in the enumeration
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::GetNextRecord( CPolicyRecord* pRecord )
{
    ULONG             ulReturned;
    IWbemClassObject* pInstance;
    HRESULT           hr;

    ulReturned = 1;

    //
    // Use the enumeration interface to return a record interface
    // to the next item in the enumeration -- we choose
    // here to enumerate one at a time as this is not
    // optimzed for speed currently.
    //
    hr = _xEnum->Next( 
        RECORD_ENUMERATION_TIMEOUT,
        1,
        &pInstance,
        &ulReturned );

    //
    // If we received one item back with a success code,
    // we have retrieved an interface -- associate
    // the retrieved interface with the caller-specified
    // pRecord
    //
    if ( (S_OK == hr) && (1 == ulReturned) )
    {
        pRecord->InitRecord( pInstance );
    }
    else
    {
        ASSERT(FAILED(hr) || (S_FALSE == hr));
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::OpenExistingRecord
//
// Purpose: Associates a CPolicyRecord with a database
//     record that corresponds to a path emitted by
//     CPolicyRecord's GetPath method
//
// Params: pRecord -- CPolicyRecord to be associated with
//     the existing database item
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT
CPolicyLog::OpenExistingRecord( CPolicyRecord* pRecord )
{
    HRESULT hr;

    WCHAR   wszPathBuf[ _MAX_PATH ];
    DWORD   cchLength;
    BSTR    PathName;

    PathName = NULL;

    cchLength = sizeof( wszPathBuf ) / sizeof( *wszPathBuf );

    hr = pRecord->GetPath( wszPathBuf, &cchLength );

    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( S_OK == hr )
    {
        PathName = SysAllocString( wszPathBuf );
    }
    else
    {
        PathName = SysAllocStringLen( NULL, cchLength );

        if ( PathName )
        {
            hr = pRecord->GetPath( PathName, &cchLength );
        }
    }
      
    if ( ! PathName )
    {
        return E_OUTOFMEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        IWbemClassObject* pInstance;
        
        pInstance = NULL;

        if ( _xWbemServices )
        {
            hr = _xWbemServices->GetObject(
                PathName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pInstance,
                NULL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED( hr ) )
        {
            pRecord->InitRecord( pInstance );
        }
    }

    SysFreeString( PathName );

    if ( SUCCEEDED( hr ) )
    {
       pRecord->_bNewRecord = FALSE;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::DeleteRecord
//
// Purpose: Deletes the record associated with this CPolicyRecord
//     from the database
//
// Params: pRecord -- CPolicyRecord associated with
//     the record to delete
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::DeleteRecord(
    CPolicyRecord* pRecord,
    BOOL           bDeleteStatus)
{
    CVariant var;
    HRESULT  hr;

    //
    // If specified by the caller, delete any associated status records
    //
    if ( bDeleteStatus )
    {
        hr = DeleteStatusRecords( pRecord );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Retrieve the database path of the record to delete
    //
    hr = pRecord->GetRecordInterface()->Get( 
        WMI_PATH_PROPERTY,
        0L,
        (VARIANT*) &var,
        NULL,
        NULL);

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Now that we have the path, we can use it to delete the record
    // by supplying it to the namespace's delete instance method --
    // this will delete the record from the namespace
    //
    hr = _xWbemServices->DeleteInstance( 
        ((VARIANT*) &var)->bstrVal,
        0L,
        NULL,
        NULL );

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::DeleteRecord
//
// Purpose: Deletes the record associated with this CPolicyRecord
//     from the database
//
// Params: pRecord -- CPolicyRecord associated with
//     the record to delete
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::DeleteStatusRecords( CPolicyRecord* pRecord )
{
    HRESULT hr;

    //
    // If there is a setting status associated with
    // this error, delete it
    //
    hr = RsopResetPolicySettingStatus(
        0,
        _xWbemServices,
        pRecord->GetRecordInterface());

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearLog
//
// Purpose: Clears all records of this log's class (policy type)
//     from the log's associated namespace
//
// Params: none
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::ClearLog(
    WCHAR* wszSpecifiedCriteria,
    BOOL   bDeleteStatus)
{
    HRESULT hr;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Retrieve an enumerator for the specified criteria
    //
    hr = GetEnum( wszSpecifiedCriteria );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We will iterate through all existing records
    //
    for (;;)
    {
        CPolicyRecord CurrentRecord;

        //
        // Retrieve the current record from the
        // namespace
        //
        hr = GetNextRecord(&CurrentRecord);
        
        if (FAILED(hr))
        {
            return hr;
        }
     
        //
        // If there are no more records to retrieve,
        // we are done and can exit the loop.
        //
        if (S_FALSE == hr)
        {
            break;
        }
       
        //
        // Delete the current record from the namespace
        //
        hr = DeleteRecord( &CurrentRecord, bDeleteStatus );
    }

    FreeEnum();

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearLog
//
// Purpose: Deletes all instances of this class from the namespace
//
// Params: none
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::GetEnum( WCHAR* wszSpecifiedCriteria )
{
    HRESULT               hr;

    if ( _xEnum )
    {
        return E_FAIL;
    }

    //
    // Generate criteria from the caller's specification
    //
    WCHAR* wszCriteria;

    wszCriteria = new WCHAR [ ( wszSpecifiedCriteria ? lstrlen(wszSpecifiedCriteria) : 0 ) +
                            sizeof( WSZSPECIFIC_CRITERIA_TEMPLATE ) / sizeof(WCHAR) +
                            lstrlen( _wszClass ) + 1 ];

    if ( ! wszCriteria )
    {
        return E_OUTOFMEMORY;
    }

    //
    // This creates a query for instances of the class supported by this log
    // that adhere to the caller's specifications (usually asserts the value of some property)
    //
    if ( wszSpecifiedCriteria )
    {
        //
        // Include the user's criteria if specified
        //
        swprintf(
            wszCriteria,
            WSZSPECIFIC_CRITERIA_TEMPLATE,
            _wszClass,
            wszSpecifiedCriteria);
    }
    else
    {
        //
        // If the user specified no criteria, do not attempt to include it
        //
        swprintf(
            wszCriteria,
            WSZGENERAL_CRITERIA_TEMPLATE,
            _wszClass);
    }

    hr = E_OUTOFMEMORY;

    XBStr  Query( wszCriteria );

    if ( Query )
    {
        //
        // Use this method to obtain an enumerator for instances
        // satisfying the specified criteria
        //
        hr = _xWbemServices->ExecQuery(
            _xbstrQueryLanguage,
            Query,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &_xEnum );
    }

    delete [] wszCriteria;

    if ( FAILED(hr) )
    {
        return hr;
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearLog
//
// Purpose: Deletes all instances of this class from the namespace
//
// Params: none
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
void CPolicyLog::FreeEnum()
{
    //
    // This will release the interface and set it to NULL so
    // that we know that it is released;
    //
    _xEnum = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\rsop\util.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  util.cxx
//
//  Contains definitions for utility functions related to
//  rsop for use by client side extensions
//
//  Created: 10-11-1999 adamed 
//
//*************************************************************/

#include "rsop.hxx"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  StripPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to Gpo
//
//  Parameters: pwszPath - full path to the ds object linked 
//                  to the gpo
//
//  Returns:    Pointer to suffix
//
//-------------------------------------------------------------
WCHAR *StripLinkPrefix( WCHAR *pwszPath )
{
    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\debug.cxx ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "fdeploy.hxx"

//
// Global Variable containing the debugging level.  The debug level can be
// modified by both the debug init routine and the event logging init
// routine.  Debugging can be enabled even on retail systems through
// registry settings.
//

DWORD   gDebugLevel = DL_NONE;
DWORD   gDebugBreak = 0;

//
// Debug strings
//

const WCHAR cwszTitle[] = L"FDEPLOY (%x) ";
const WCHAR cwszTime[] = L"%02d:%02d:%02d:%03d ";
const WCHAR cwszLogfile[] = L"%SystemRoot%\\Debug\\UserMode\\fdeploy.log";
const WCHAR cwszCRLF[] = L"\r\n";

//
// Registry debug information
//

#define DEBUG_REG_LOCATION  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics"
#define DEBUG_KEY_NAME      L"FDeployDebugLevel"
#define DEBUGBREAK_KEY_NAME L"FDeployDebugBreak"

//*************************************************************
//
//  InitDebugSupport()
//
//  Sets the debugging level.
//  Also checks the registry for a debugging level.
//
//*************************************************************
void InitDebugSupport()
{
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;
    BOOL    bVerbose;
    DWORD   Status;

#if DBG
    gDebugLevel = DL_NORMAL;
#else
    gDebugLevel = DL_NONE;
#endif

    gDebugBreak = 0;

    Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DIAGNOSTICS_KEY,
                    0,
                    KEY_READ,
                    &hKey );

    bVerbose = FALSE;
    Size = sizeof(bVerbose);

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegQueryValueEx(
                        hKey,
                        DIAGNOSTICS_POLICY_VALUE,
                        NULL,
                        &Type,
                        (LPBYTE) &bVerbose,
                        &Size );

        if ( (ERROR_SUCCESS == Status) && (Type != REG_DWORD) )
            bVerbose = FALSE;

        RegCloseKey(hKey);
    }

    Status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                DEBUG_REG_LOCATION,
                &hKey );

    if ( ERROR_SUCCESS == Status )
    {
        Size = sizeof(gDebugLevel);
        RegQueryValueEx(
                hKey,
                DEBUG_KEY_NAME,
                NULL,
                &Type,
                (LPBYTE)&gDebugLevel,
                &Size );

        Size = sizeof(gDebugBreak);
        RegQueryValueEx(
                hKey,
                DEBUGBREAK_KEY_NAME,
                NULL,
                &Type,
                (LPBYTE)&gDebugBreak,
                &Size );

        RegCloseKey(hKey);
    }

    if ( bVerbose )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;
}

void ConditionalBreakIntoDebugger()
{
    if (gDebugBreak)
    {
        DebugBreak();
    }
}

BOOL DebugLevelOn( DWORD mask )
{
    BOOL bOutput = FALSE;

    if ( gDebugLevel & DL_VERBOSE )
        bOutput = TRUE;
    else if ( gDebugLevel & DL_NORMAL )
        bOutput = ! (mask & DM_VERBOSE);
#if DBG
    else // DL_NONE
        bOutput = (mask & DM_ASSERT);
#endif

    return bOutput;
}

//*************************************************************
//
//  _DebugMsg()
//
//  Displays debug messages based on the debug level
//  and type of debug message.
//
//  Parameters :
//      mask    -   debug message type
//      MsgID   -   debug message id from resource file
//      ...     -   variable number of parameters
//
//*************************************************************
void _DebugMsg(DWORD mask, DWORD MsgID, ...)
{
    BOOL bEventLogOK;
    WCHAR wszDebugTitle[30];
    WCHAR wszDebugTime [30];
    WCHAR wszDebugBuffer[4*MAX_PATH];
    WCHAR wszMsg[MAX_PATH];
    va_list VAList;
    DWORD dwErrCode;
    SYSTEMTIME systime;

    bEventLogOK = ! (mask & DM_NO_EVENTLOG);

    if ( ! DebugLevelOn( mask ) )
        return;

    //
    // Save the last error code (so the debug output doesn't change it).
    //
    dwErrCode = GetLastError();

    va_start(VAList, MsgID);

    //
    // Event log message ids start at 101.  For these we must call
    // FormatMessage.  For other verbose debug output, we use
    // LoadString to get the string resource.
    //
    if ( MsgID < 100 )
    {
        if ( ! LoadString( ghDllInstance, MsgID, wszMsg, MAX_PATH) )
        {
            SetLastError(dwErrCode);
            return;
        }
        wvsprintf(wszDebugBuffer, wszMsg, VAList);
    }
    else
    {
        DWORD   CharsWritten;

        CharsWritten = FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    ghDllInstance,
                    MsgID,
                    0,
                    wszDebugBuffer,
                    sizeof(wszDebugBuffer) / sizeof(WCHAR),
                    &VAList );

        if ( 0 == CharsWritten )
        {
            SetLastError(dwErrCode);
            return;
        }
    }

    va_end(VAList);

    GetLocalTime( &systime );
    wsprintf( wszDebugTitle, cwszTitle, GetCurrentProcessId() );
    wsprintf( wszDebugTime, cwszTime, systime.wHour, systime.wMinute,
              systime.wSecond, systime.wMilliseconds);

    OutputDebugString( wszDebugTitle );
    OutputDebugString( wszDebugTime );
    OutputDebugString( wszDebugBuffer );
    OutputDebugString( cwszCRLF );

    if ( gDebugLevel & DL_LOGFILE )
    {
        HANDLE  hFile;
        TCHAR   cwszExpLogfile [MAX_PATH + 1];

        DWORD   dwRet = ExpandEnvironmentStrings (cwszLogfile, cwszExpLogfile,
                                                  MAX_PATH + 1);

        if (0 != dwRet && dwRet <= MAX_PATH)
        {
            hFile = CreateFile(cwszExpLogfile,
                               FILE_WRITE_DATA | FILE_APPEND_DATA,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if ( hFile != INVALID_HANDLE_VALUE )
            {
                if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
                {
                    WCHAR * wszBuffer;
                    DWORD   Size;

                    Size = lstrlen(wszDebugBuffer) + lstrlen (wszDebugTime) + 1;
                    wszBuffer = (WCHAR *) alloca (Size * sizeof (WCHAR));

                    if (wszBuffer)
                    {
                        wcscpy (wszBuffer, wszDebugTime);
                        wcscat (wszBuffer, wszDebugBuffer);
                        WriteFile(
                                hFile,
                                (LPCVOID) wszBuffer,
                                lstrlen(wszBuffer) * sizeof(WCHAR),
                                &Size,
                                NULL );
                        WriteFile(
                                hFile,
                                (LPCVOID) cwszCRLF,
                                lstrlen(cwszCRLF) * sizeof(WCHAR),
                                &Size,
                                NULL );
                    }
                }

                CloseHandle (hFile);
            }
        }
    }

    if ( bEventLogOK &&  gpEvents && (gDebugLevel & DL_EVENTLOG) )
        gpEvents->Report( EVENT_FDEPLOY_VERBOSE, 1, wszDebugBuffer );

    //
    // Restore the last error code
    //
    SetLastError(dwErrCode);

#if DBG
    if ( mask & DM_ASSERT )
        DebugBreak();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\common\rsop\variant.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  variant.hxx
//
//*************************************************************

#include "rsop.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::CVariant
//
// Purpose: Constructor for CVariant class.  Initializes the
//     storage of the variant data.
//
// Params: none
//
// Return value: none
//
// Notes:
//
//------------------------------------------------------------
CVariant::CVariant() :
    _iCurrentArrayIndex(0),
    _cMaxArrayElements(0)
{
    VariantInit(&_var);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::~CVariant
//
// Purpose: Denstructor for CVariant class.  Frees any data
//     allocated to store variant data.
//
// Params: none
//
// Return value: none
//
// Notes:
//
//------------------------------------------------------------
CVariant::~CVariant()
{
    HRESULT hr;

    hr = VariantClear(&_var);

    ASSERT(SUCCEEDED(hr));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetStringValue
//
// Purpose: Sets the type of the variant to VT_BSTR and creates
//     a bstr to store the string.
//
// Params: wszValue -- this unicode string is the value to
//     which we want to set this variant
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  The variant should not be set to a value after
//     this is called -- otherwise, you may lose reference
//     to allocated memory -- the value is meant to be set
//     only once.  
//
//------------------------------------------------------------
HRESULT CVariant::SetStringValue(WCHAR* wszValue)
{
    XBStr xString;

    ASSERT(VT_EMPTY == _var.vt); 

    xString = wszValue;

    if (!xString)
    {
        return E_OUTOFMEMORY;
    }
    
    _var.vt = VT_BSTR;
    _var.bstrVal = xString.Acquire();

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetLongValue
//
// Purpose: Sets the type of the variant to VT_I4 and creates
//     a bstr to store the string.
//
// Params: lValue -- this LONG value is the value to
//     which we want to set this variant
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  The variant should not be set to a value after
//     this is called -- otherwise, you may lose reference
//     to allocated memory -- the value is meant to be set
//     only once.  
//
//------------------------------------------------------------
HRESULT CVariant::SetLongValue(LONG lValue)
{
    ASSERT(VT_EMPTY == _var.vt); 

    _var.vt = VT_I4;
    _var.lVal = lValue;

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetBoolValue
//
// Purpose: Sets the type of the variant to VT_BOOL and stores the value
//
// Params: bValue -- this boolean value is the value to
//     which we want to set this variant
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  The variant should not be set to a value after
//     this is called -- otherwise, you may lose reference
//     to allocated memory -- the value is meant to be set
//     only once.  
//
//------------------------------------------------------------
HRESULT CVariant::SetBoolValue(BOOL bValue)
{
    ASSERT(VT_EMPTY == _var.vt); 

    _var.vt = VT_BOOL;
    _var.boolVal = bValue ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextLongArrayElement
//
// Purpose: Adds an element in an array of strings to a 
//     specified string
//
// Params: Value -- the value to which to add as an element
//         cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextLongArrayElement(
    LONG  Value,
    DWORD cMaxElements)
{
    HRESULT hr;
    
    //
    // Add the long to the correct index
    // in the array
    //
    hr = SetNextArrayElement(
        VT_I4,
        cMaxElements,
        &Value);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextStringArrayElement
//
// Purpose: Adds an element to an array of strings
//
// Params: wszValue -- the value to which to add as an element
//         cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextStringArrayElement(
    WCHAR* wszValue,
    DWORD  cMaxElements)
{
    HRESULT hr;
    XBStr   xString;

    //
    // Create a bstr from the supplied unicode string
    //
    xString = wszValue;

    if (!xString)
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // Now add the unicode string to the correct index
    // in the array
    //
    hr = SetNextArrayElement(
        VT_BSTR,
        cMaxElements,
        xString);

    //
    // If we've succeeded in setting the element, it now
    // owns the reference, so we release our reference
    //
    if (SUCCEEDED(hr))
    {
        (void) xString.Acquire();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextByteArrayElement
//
// Purpose: Adds an element in an array of bytes to a byte array 
//
// Params: byteValue -- the value to which to add as an element
//         cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextByteArrayElement(
    BYTE  byteValue,
    DWORD cMaxElements)
{
    HRESULT hr;
    
    //
    // Add the long to the correct index
    // in the array
    //
    hr = SetNextArrayElement(
        VT_UI1,
        cMaxElements,
        &byteValue);

    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::IsStringValue
//
// Purpose: Determines whether this variant represents a string
//
// Params: 
//
// Return value: returns TRUE if this is a string, FALSE if not
//
//------------------------------------------------------------
BOOL CVariant::IsStringValue()
{
    return VT_BSTR == _var.vt;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::IsLongValue
//
// Purpose: Determines whether this variant represents a long
//
// Params: 
//
// Return value: returns TRUE if this is a long, FALSE if not
//
//------------------------------------------------------------
BOOL CVariant::IsLongValue()
{
    return VT_I4 == _var.vt;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::operator VARIANT*()
//
// Purpose: Casts this object into a VARIANT structure pointer
//
// Params: 
//
// Return value: returns a pointer to a VARIANT structure
//
// Notes:  
//
//------------------------------------------------------------
CVariant::operator VARIANT*()
{
    return &_var;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextArrayElement
//
// Purpose: Adds an element to an array of objects of arbitrary
//     type
//
// Params: wszValue -- the value to which to set the element
//     cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextArrayElement(
        VARTYPE varType,
        DWORD   cMaxElements,
        LPVOID  pvData)
{
    HRESULT hr;

    //
    // If this array contains no elements, return the hr
    // that lets the caller know that this array is full
    //
    if ( 0 == cMaxElements )
    {
        return S_FALSE;
    }

    //
    // The first time this method is called on this object,
    // we should allocate space for the array
    //
    if ( !_iCurrentArrayIndex )
    {
        ASSERT( cMaxElements );
        ASSERT( VT_EMPTY == _var.vt );

        //
        // Allocate space for the array with elements
        // of the caller specifed type and number
        //
        hr = InitializeArray(
            varType,
            cMaxElements);

        if (FAILED(hr)) 
        {
            return hr;
        }

        _cMaxArrayElements = cMaxElements;
    } 

    ASSERT( ((DWORD) _iCurrentArrayIndex) < _cMaxArrayElements );

    //
    // Now add the polymorphic object's IUnknown
    // into the array
    //
    hr = SafeArrayPutElement(
        _var.parray,
        &_iCurrentArrayIndex,
        pvData);

    //
    // If we've filled up the array, return S_FALSE to
    // signal that no more elements can be added
    //
    if (SUCCEEDED(hr))
    {
        //
        // Increment our cursor into the array to the
        // next element 
        //
        _iCurrentArrayIndex++;

        //
        // Check our current index -- if it's the same
        // as our maximum, we're full
        //
        if ( ((DWORD) _iCurrentArrayIndex) == _cMaxArrayElements)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::InitializeArray
//
// Purpose: Private method that allocates space for an array
//     of a specified size and element type
//
// Params: varType -- type of elements that will be in the array
//     cMaxElements -- the size, in elements, of the array
//
// Return value: returns ERROR_SUCCESS if successful, other
//     win32 error code if not
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CVariant::InitializeArray(
    VARTYPE varType,
    DWORD   cMaxElements)
{
    SAFEARRAY*     pSafeArray;
    SAFEARRAYBOUND arrayBound;

    //
    // Set the bounds of the array to be zero-based
    //
    arrayBound.lLbound = 0;
    arrayBound.cElements = cMaxElements;

    //
    // Allocate the array
    //
    pSafeArray = SafeArrayCreate(
        varType,
        1, // 1 dimension
        &arrayBound);

    if (!pSafeArray) 
    {
        return E_OUTOFMEMORY;
    }

    //
    // Set our state to refer to the allocated memory
    // with the specified type
    //
    _var.vt = VT_ARRAY | varType;
    _var.parray = pSafeArray;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\events.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  events.cxx
//
//*************************************************************

#include "fdeploy.hxx"

CEvents * gpEvents = 0;

CEvents::CEvents()
{
    _hEventLog = NULL;
    _pUserSid = NULL;
    _Refs = 0;
}

CEvents::~CEvents()
{
    if ( _hEventLog )
        CloseEventLog( _hEventLog );

    if ( _pUserSid )
        LocalFree( _pUserSid );
}

DWORD
CEvents::Init()
{
    DWORD       Size;
    DWORD       Type;
    DWORD       Status;
    HKEY        hKey;

    Status = ERROR_SUCCESS;

    if ( ! _hEventLog )
        _hEventLog = OpenEventLog( NULL, FDEPLOY_EVENT_SOURCE );

    if ( ! _hEventLog )
        return GetLastError();

    return ERROR_SUCCESS;
}

PSID
CEvents::UserSid()
{
    GetUserSid();

    // The caller does not own this sid and should not attempt to free it
    return _pUserSid;
}

void
CEvents::GetUserSid()
{
    DWORD       Size;
    DWORD       Status;
    HANDLE      hToken;
    PTOKEN_USER pTokenUserData;
    BOOL        bStatus;

    if ( _pUserSid )
        return;

    bStatus = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

    if ( ! bStatus )
        return;

    Size = sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG));
    pTokenUserData = (PTOKEN_USER) alloca( Size );

    bStatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    pTokenUserData,
                    Size,
                    &Size );

    CloseHandle( hToken );

    if ( ! bStatus )
        return;

    Size = GetLengthSid( pTokenUserData->User.Sid );

    _pUserSid = (PSID) LocalAlloc( 0, Size );

    if ( _pUserSid )
    {
        bStatus = CopySid( Size, _pUserSid, pTokenUserData->User.Sid );

        if ( ! bStatus )
        {
            LocalFree( _pUserSid );
            _pUserSid = NULL;
        }
    }
}

void
CEvents::Report(
    DWORD       EventID,
    WORD        Strings,
    ...
    )
{
    va_list     VAList;
    WCHAR **    ppwszStrings;
    WORD        Type;
    DWORD       DbgMsgLevel;

    switch ( EventID >> 30 )
    {
    case 3:
        Type = EVENTLOG_ERROR_TYPE;
        DbgMsgLevel = DM_WARNING;
        break;
    case 2:
        Type = EVENTLOG_WARNING_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    case 1:
    case 0:
        Type = EVENTLOG_INFORMATION_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    default:
        return;
    }

    ppwszStrings = 0;

    if ( Strings > 0 )
    {
        ppwszStrings = (WCHAR **) alloca( Strings * sizeof(WCHAR *) );
        if ( ! ppwszStrings )
            return;

        va_start( VAList, Strings );
        for ( DWORD n = 0; n < Strings; n++ )
            ppwszStrings[n] = va_arg( VAList, WCHAR * );
        va_end( VAList );
    }

    GetUserSid();

    (void) ReportEvent(
                    _hEventLog,
                    Type,
                    0,
                    EventID,
                    _pUserSid,
                    Strings,
                    0,
                    (LPCWCH *) ppwszStrings,
                    NULL );

    //
    // Also make sure the event messages get sent to the debugger and log file.
    // Kind of hacky method, but makes it so every caller to ::Report doesn't
    // have to call _DebugMsg as well.
    // However, don't do this for the verbose messages otherwise it will be
    // dumped to the debugger twice.
    //
    if ( EVENT_FDEPLOY_VERBOSE == EventID )
        return;

    switch ( Strings )
    {
    case 0 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID );
        break;
    case 1 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0] );
        break;
    case 2 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1] );
        break;
    case 3 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2] );
        break;
    case 4 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2], ppwszStrings[3] );
        break;
    case 5 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0],
                   ppwszStrings[1], ppwszStrings[2], ppwszStrings[3],
                   ppwszStrings[4]);
        break;
    case 6 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0],
                   ppwszStrings[1], ppwszStrings[2], ppwszStrings[3],
                   ppwszStrings[4], ppwszStrings[5]);
        break;
    case 7 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0],
                   ppwszStrings[1], ppwszStrings[2], ppwszStrings[3],
                   ppwszStrings[4], ppwszStrings[5], ppwszStrings[6]);
        break;
    default :
        VerboseDebugDump( L"CEvents::Report called with more params then expected\n" );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\fdeploy.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  fdeploy.cxx
//
//*************************************************************

#include "fdeploy.hxx"
#include "rsopdbg.h"

#define ABORT_IF_NECESSARY      if (*pbAbort)   \
                                {               \
                                    Status = ERROR_REQUEST_ABORTED; \
                                    goto ProcessGPOCleanup;         \
                                }

#define FLUSH_AND_ABORT_IF_NECESSARY    if (*pbAbort)   \
                                        {               \
                                            Status = ERROR_REQUEST_ABORTED; \
                                            goto ProcessGPOFlush;         \
                                        }

CDebug dbgRsop(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 TRUE );



//status callback function
PFNSTATUSMESSAGECALLBACK gpStatusCallback;

//saved per user per machine settings
CSavedSettings gSavedSettings[(int)EndRedirectable];

//if CSC is enabled or not
BOOL    g_bCSCEnabled;

// Used for LoadString.
HINSTANCE   ghDllInstance = 0;
HINSTANCE   ghFileDeployment = 0;
WCHAR       gwszStatus[12];
WCHAR       gwszNumber[20];

// User info.
CUsrInfo        gUserInfo;
const WCHAR *   gwszUserName = NULL;


//+--------------------------------------------------------------------------
//
//  Function:	ReinitGlobals
//
//  Synopsis:	Reinitializes the global variables that should not carry
//				over to the next run of folder redirection.
//
//  Arguments:	none.
//
//  Returns:	nothing.
//
//  History:	12/17/2000  RahulTh  created
//
//  Notes:		static members of classes and other global variables are
//				initialized only when the dll is loaded. So if this dll
//				stays loaded across logons, then the fact that the globals
//				have been initialized based on a previous logon can cause
//				problems. Therefore, this function is used to reinitialize
//				the globals.
//
//---------------------------------------------------------------------------
void ReinitGlobals (void)
{
	DWORD		i;
	
	// First reset the static members of various classes.
	CSavedSettings::ResetStaticMembers();
	
	// Now reset members of various global objects.
	gUserInfo.ResetMembers();
    for (i = 0; i < (DWORD) EndRedirectable; i++)
	{
		gSavedSettings[i].ResetMembers();
		gPolicyResultant[i].ResetMembers();
		gAddedPolicyResultant[i].ResetMembers();
		gDeletedPolicyResultant[i].ResetMembers();
	}
	
	return;
}

extern "C" DWORD WINAPI
ProcessGroupPolicyEx (
    DWORD   dwFlags,
    HANDLE  hUserToken,
    HKEY    hKeyRoot,
    PGROUP_POLICY_OBJECT   pDeletedGPOList,
    PGROUP_POLICY_OBJECT   pChangedGPOList,
    ASYNCCOMPLETIONHANDLE   pHandle,
    BOOL*   pbAbort,
    PFNSTATUSMESSAGECALLBACK pStatusCallback,
    IN IWbemServices *pWbemServices,
    HRESULT          *phrRsopStatus )
{
	// Reinitialize all globals that should not get carried over from
	// a previous run of folder redirection. This is necessary just in
	// case this dll is not unloaded by userenv after each run. Also, we should
	// do this before any other processing is done to ensure correct behavior.
	ReinitGlobals();
	
    *phrRsopStatus = S_OK;

    CRsopContext DiagnosticModeContext( pWbemServices, phrRsopStatus, FDEPLOYEXTENSIONGUID );

    return ProcessGroupPolicyInternal (
        dwFlags,
        hUserToken,
        hKeyRoot,
        pDeletedGPOList,
        pChangedGPOList,
        pHandle,
        pbAbort,
        pStatusCallback,
        &DiagnosticModeContext );
}

extern "C" DWORD WINAPI
GenerateGroupPolicy (
    IN DWORD dwFlags,
    IN BOOL  *pbAbort,
    IN WCHAR *pwszSite,
    IN PRSOP_TARGET pComputerTarget,
    IN PRSOP_TARGET pUserTarget )
{
    DWORD Status;

	// Reinitialize all globals that should not get carried over from
	// a previous run of folder redirection. This is necessary just in
	// case this dll is not unloaded by userenv after each run. Also, we should
	// do this before any other processing is done to ensure correct behavior.
	ReinitGlobals();
	
    CRsopContext PlanningModeContext( pUserTarget, FDEPLOYEXTENSIONGUID );

    Status = ERROR_SUCCESS;

    //
    // There is no machine policy, only user --
    // process only user policy
    //
    if ( pUserTarget && pUserTarget->pGPOList )
    {
        gUserInfo.SetPlanningModeContext( &PlanningModeContext );

        Status = ProcessGroupPolicyInternal(
            dwFlags,
            NULL,
            NULL,
            NULL,
            pUserTarget->pGPOList,
            NULL,
            pbAbort,
            NULL,
            &PlanningModeContext);
    }

    return Status;
}


DWORD ProcessGroupPolicyInternal (
    DWORD   dwFlags,
    HANDLE  hUserToken,
    HKEY    hKeyRoot,
    PGROUP_POLICY_OBJECT   pDeletedGPOList,
    PGROUP_POLICY_OBJECT   pChangedGPOList,
    ASYNCCOMPLETIONHANDLE   pHandle,
    BOOL*   pbAbort,
    PFNSTATUSMESSAGECALLBACK pStatusCallback,
    CRsopContext* pRsopContext )
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   RedirStatus;
    CFileDB CurrentDB;
    DWORD   i;
    PGROUP_POLICY_OBJECT   pCurrGPO = NULL;
    HANDLE  hDupToken = NULL;
    BOOL    fUpdateMyPicsLinks = FALSE;
    BOOL    fPlanningMode;
    BOOL    fWriteRsopLog = FALSE;
    BOOL    bForcedRefresh = FALSE;

    gpStatusCallback = pStatusCallback;

    fPlanningMode = pRsopContext->IsPlanningModeEnabled();

    //
    // Even though this extension has indicated its preference for not
    // handling machine policies, the admin. might still override these 
    // preferences through policy. Since, this extension is not designed to 
    // handled this situation, we need to explicitly check for these cases and 
    // quit at this point.
    //
    if (dwFlags & GPO_INFO_FLAG_MACHINE)
    {
        DebugMsg((DM_VERBOSE, IDS_INVALID_FLAGS));
        Status = ERROR_INVALID_FLAGS;
        goto ProcessGPOCleanup;
    }

    //some basic initializations first.
    InitDebugSupport();

    if ( dwFlags & GPO_INFO_FLAG_VERBOSE )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    gpEvents = new CEvents();
    if (!gpEvents)
    {
        DebugMsg((DM_VERBOSE, IDS_INIT_FAILED));
        Status = ERROR_OUTOFMEMORY;
        goto ProcessGPOCleanup;
    }
    gpEvents->Init();
    gpEvents->Reference();

    DebugMsg((DM_VERBOSE, IDS_PROCESSGPO));
    DebugMsg((DM_VERBOSE, IDS_GPO_FLAGS, dwFlags));

    ConditionalBreakIntoDebugger();

    if ( ! fPlanningMode )
    {
        bStatus = DuplicateToken (hUserToken,
                                  SecurityImpersonation,
                                  &hDupToken);
        if (!bStatus)
        {
            Status = GetLastError();
            gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
            goto ProcessGPOCleanup;
        }

        //impersonate the logged on user,
        bStatus = ImpersonateLoggedOnUser( hDupToken );
        //bail out if impersonation fails
        if (!bStatus)
        {
            gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
            Status = GetLastError();
            goto ProcessGPOCleanup;
        }

        g_bCSCEnabled = CSCIsCSCEnabled ();

        //try to get set ownership privileges. These will be required
        //when we copy over ownership information
        GetSetOwnerPrivileges (hDupToken);

        //get the user name -- this is used for tracking name changes.
        gwszUserName = gUserInfo.GetUserName (Status);
        if (ERROR_SUCCESS != Status)
        {
            DebugMsg ((DM_VERBOSE, IDS_GETNAME_FAILED, Status));
            gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
            goto ProcessGPOCleanup;
        }
    }

    //load the localized folder names and relative paths. (also see
    //notes before the function LoadLocalizedNames()
    Status = LoadLocalizedFolderNames ();
    if (ERROR_SUCCESS != Status)
    {
        gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
        goto ProcessGPOCleanup;
    }

    //now initialize those values for the CFileDB object that are going to
    //be the same across all the policies
    if (ERROR_SUCCESS != (Status = CurrentDB.Initialize(hDupToken, hKeyRoot, pRsopContext )))
    {
        gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
        goto ProcessGPOCleanup;
    }

    if ( ! fPlanningMode )
    {

        //now load the per user per machine settings saved during the last logon
        for (i = 0; i < (DWORD) EndRedirectable; i++)
        {
            Status = gSavedSettings[i].Load (&CurrentDB);
            if (ERROR_SUCCESS != Status)
            {
                gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
                goto ProcessGPOCleanup;
            }
        }
    }

    //now if the GPO_NOCHANGES flag has been specified, make sure that it is
    //okay not to do any processing
    bStatus = TRUE;
    if ( (dwFlags & GPO_INFO_FLAG_NOCHANGES) &&
         !fPlanningMode &&
        !( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION ) )
    {
        for (bStatus = FALSE, i = 0;
             i < (DWORD)EndRedirectable && (!bStatus);
             i++)
        {
            bStatus = fPlanningMode ? TRUE : gSavedSettings[i].NeedsProcessing();
        }
    }

    if (!bStatus)   //we are in good shape. No processing is required.
	{
        Status = ERROR_SUCCESS;
        DebugMsg ((DM_VERBOSE, IDS_NOCHANGES));
        goto ProcessGPOCleanup;
	}
    else
    {
        if ((dwFlags & GPO_INFO_FLAG_BACKGROUND) ||
            (dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND))
        {
            //
            // Log an event only in the async. foreground case. In all other
            // cases just output a debug message. Note: The Background flag
            // will be set even in the async. foreground case. So we must
            // explicitly make this check against the async. foreground
            // flag.
            //
            if (dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND)
            {
                gpEvents->Report (EVENT_FDEPLOY_POLICY_DELAYED, 0);
            }
            else
            {
                DebugMsg ((DM_VERBOSE, IDS_POLICY_DELAYED));
            }
            Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
            goto ProcessGPOCleanup;
        }

        if ( ! fPlanningMode &&
             (dwFlags & GPO_INFO_FLAG_NOCHANGES))
        {
            // a user name or homedir change has occured and no gpo changes occurred,
            // so in order to perform RSoP logging, we will need to get our own
            // RSoP namespace since the GP engine does not give us the namespace
            // if no changes occurred -- we note this below

            bForcedRefresh = TRUE;
            fWriteRsopLog = TRUE;
        }
    }

    //
    // If we have changes or we are in planning mode, enable logging
    //
    if ( pChangedGPOList || pDeletedGPOList || fPlanningMode )
    {
        fWriteRsopLog = TRUE;
    }

    if ( fWriteRsopLog )
    {
        //
        // If RSoP logging should occur in logging mode, initialize
        // the rsop context -- this is not necessary in planning mode
        //
        if ( pRsopContext->IsDiagnosticModeEnabled() )
        {
            PSID pUserSid;

            pUserSid = gpEvents->UserSid();

            if ( pUserSid )
            {
                // This call requires elevated privileges to succeed.
                RevertToSelf();
                (void) pRsopContext->InitializeContext( pUserSid );
                // Re-impersonate the logged on user,
                bStatus = ImpersonateLoggedOnUser( hDupToken );
                // Bail out if impersonation fails
                if (!bStatus)
                {
                    gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
                    Status = GetLastError();
                    goto ProcessGPOCleanup;
                }
            }
            else
            {
                pRsopContext->DisableRsop( ERROR_OUTOFMEMORY );
            }
        }

        CurrentDB.InitRsop( pRsopContext, bForcedRefresh );
    }

    //first process any user name changes.
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        Status = gSavedSettings[i].HandleUserNameChange(
                                            &CurrentDB,
                                            &(gPolicyResultant[i]));
        if (ERROR_SUCCESS != Status)
        {
            // Failure events will be reported while processing the name change
            goto ProcessGPOCleanup;
        }
    }

    //first process the deleted GPOs
    //we need to do this in reverse, because removed policies are sent
    //in reverse, that is the closest policy is sent last. So if you have
    //two policies that redirect the same folder and both of them are removed
    //simultaneously, then, the code gets the wrong value for the redirection
    //destination of the resultant set of removed policies and therefore
    //assumes that someone else must have modified it and therefore leaves it
    //alone
    if (pDeletedGPOList)
    {
        //go all the way to the end
        for (pCurrGPO = pDeletedGPOList; pCurrGPO->pNext; pCurrGPO = pCurrGPO->pNext)
            ;
        //now pCurrGPO points to the last policy in the removed list, so go at
        //it in the reverse order.
        for (; pCurrGPO; pCurrGPO = pCurrGPO->pPrev)
        {
            DebugMsg((DM_VERBOSE, IDS_GPO_NAME, pCurrGPO->szGPOName));
            DebugMsg((DM_VERBOSE, IDS_GPO_FILESYSPATH, pCurrGPO->lpFileSysPath));
            DebugMsg((DM_VERBOSE, IDS_GPO_DSPATH, pCurrGPO->lpDSPath));
            DebugMsg((DM_VERBOSE, IDS_GPO_DISPLAYNAME, pCurrGPO->lpDisplayName));

            //if we are unable to process even a single policy, we must abort
            //immediately otherwise we may end up with an incorrect resultant
            //policy.
            if (ERROR_SUCCESS != (Status = CurrentDB.Process (pCurrGPO, TRUE)))
                goto ProcessGPOCleanup;

            ABORT_IF_NECESSARY
        }
    }

    //update the descendants
    gDeletedPolicyResultant[(int) MyPics].UpdateDescendant ();

    //now process the other GPOs
    for (pCurrGPO = pChangedGPOList; pCurrGPO; pCurrGPO = pCurrGPO->pNext)
    {
        DebugMsg((DM_VERBOSE, IDS_GPO_NAME, pCurrGPO->szGPOName));
        DebugMsg((DM_VERBOSE, IDS_GPO_FILESYSPATH, pCurrGPO->lpFileSysPath));
        DebugMsg((DM_VERBOSE, IDS_GPO_DSPATH, pCurrGPO->lpDSPath));
        DebugMsg((DM_VERBOSE, IDS_GPO_DISPLAYNAME, pCurrGPO->lpDisplayName));

        //if we are unable to process even a single policy, we must abort
        //immediately otherwise we may end up with an incorrect resultant
        //policy.
        if (ERROR_SUCCESS != (Status = CurrentDB.Process (pCurrGPO, FALSE)))
        {
            goto ProcessGPOCleanup;
        }

        ABORT_IF_NECESSARY
    }

    if ( fPlanningMode )
    {
        goto ProcessGPOCleanup;
    }

    //now update the My Pics data. UpdateDescendant will derive the settings for
    //My Pics from My Docs if it is set to derive its settings from My Docs.
    gAddedPolicyResultant[(int) MyPics].UpdateDescendant ();

    //now merge the deleted policy resultant and added policy resultants
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        gPolicyResultant[i] = gDeletedPolicyResultant[i];
        gPolicyResultant[i] = gAddedPolicyResultant[i];
        //check to see if any group membership change has caused a policy to
        //be effectively removed for this user.
        gPolicyResultant[i].ComputeEffectivePolicyRemoval (pDeletedGPOList,
                                                           pChangedGPOList,
                                                           &CurrentDB);
    }

    //do the final redirection
    //we ignore errors that might occur in redirection
    //so that redirection of other folders is not hampered.
    //however, if there is a failure, we save that information
    //so that we can inform the group policy engine

    if (ERROR_SUCCESS == Status)
    {
        for (int i = 0; i < (int)EndRedirectable; i++)
        {
            RedirStatus= gPolicyResultant[i].Redirect(hDupToken, hKeyRoot,
                                                      &CurrentDB);

            if ((ERROR_SUCCESS != RedirStatus) && (ERROR_SUCCESS == Status))
                Status = RedirStatus;

            FLUSH_AND_ABORT_IF_NECESSARY    //abort if necessary, but first, flush the shell's special folder cache
                                            ///as we may have redirected some folders already.
        }

        //update shell links to MyPics within MyDocuments if policy specified
        //the location of at least one of MyDocs and MyPics and succeeded in
        //redirection. For additional details see comments at the beginning of
        //the function UpdateMyPicsShellLinks.
        if (
            (
             (!(gPolicyResultant[(int)MyDocs].GetFlags() & REDIR_DONT_CARE)) &&
             (ERROR_SUCCESS == gPolicyResultant[(int)MyDocs].GetRedirStatus())
            )
            ||
            (
             (!(gPolicyResultant[(int)MyPics].GetFlags() & REDIR_DONT_CARE)) &&
             (ERROR_SUCCESS == gPolicyResultant[(int)MyPics].GetRedirStatus())
            )
           )
        {
            fUpdateMyPicsLinks = TRUE;
            //note:we do not invoke the shell link update function here since
            //we need to flush the shell special folder cache or we may not
            //get the true current location of MyDocs or MyPics. Therefore,
            //the function is actually invoked below.
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_PROCESSREDIRECTS, Status));
    }

    //
    // Do not try to update the link (shell shortcut) in planning mode since
    // planning mode takes no real action, just records results
    //
    if ( fPlanningMode )
    {
        fUpdateMyPicsLinks = FALSE;
    }


    //flush the shell's special folder cache. we may have successfully redirected
    //some folders by the time we reach here. So it is always a good idea to let
    //the shell know about it.

ProcessGPOFlush:
    if (fUpdateMyPicsLinks)
        UpdateMyPicsShellLinks(hDupToken,
                               gPolicyResultant[(int)MyPics].GetLocalizedName());

ProcessGPOCleanup:  //don't leave any turds behind.

    if ( (ERROR_SUCCESS == Status) && !fPlanningMode )
    {
        //we have successfully applied all the policies, so remove any cached
        //ini files for removed policies.
        //any errors in deletion are ignored.
        DeleteCachedConfigFiles (pDeletedGPOList, &CurrentDB);
    }

    //we are done, so we stop running as the user
    if ( ! fPlanningMode )
    {
        RevertToSelf();
    }
    
    // In logging (aka diagnostic) mode, we need to ensure that
    // we reset the saved namespace before logging so that in the
    // no changes case where we need to log ( i.e. username / homedir change ),
    // we only log rsop data if RSoP was enabled at the last change

    if ( fWriteRsopLog )
    {
        (void) pRsopContext->DeleteSavedNameSpace();

        if ( pRsopContext->IsRsopEnabled() )
        {
            HRESULT hrLog;
            
            hrLog = CurrentDB.WriteRsopLog();
            
            if ( SUCCEEDED( hrLog ) )
            {
                (void) pRsopContext->SaveNameSpace();
            }
        }
    }

    if ( ! fPlanningMode )
    {
        if (hDupToken)
            CloseHandle (hDupToken);
    }

    if (gpEvents)
        gpEvents->Release();

    //restore the status message
    DisplayStatusMessage (IDS_DEFAULT_CALLBACK);

    // CPolicyDatabase::FreeDatabase();

    return Status;
}


extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        ghDllInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        break;
    case DLL_PROCESS_DETACH :
        break;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    DWORD   dwDisp;
    LONG    lResult;
    HKEY    hKey;
    TCHAR   EventFile[]    = TEXT("%SystemRoot%\\System32\\fdeploy.dll");
    TCHAR   ParamFile[]    = TEXT("%SystemRoot%\\System32\\kernel32.dll");
    WCHAR   EventSources[] = TEXT("(Folder Redirection,Application)\0" );
    DWORD   dwTypes        = 0x7;
    DWORD   dwSet          = 1;
    DWORD   dwReset        = 0;

    //register the dll as an extension of the policy engine
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{25537BA6-77A8-11D2-9B6C-0000F8080861}"),
                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE) TEXT("Folder Redirection"),
                   (lstrlen (TEXT("Folder Redirection")) + 1) * sizeof (TCHAR));

    RegSetValueEx (hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicyEx"),
                   (lstrlen(TEXT("ProcessGroupPolicyEx")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("fdeploy.dll"),
                   (lstrlen(TEXT("fdeploy.dll")) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NoMachinePolicy"), 0, REG_DWORD,
                   (LPBYTE)&dwSet, sizeof (dwSet));

    RegSetValueEx (hKey, TEXT("NoSlowLink"), 0, REG_DWORD,
                   (LPBYTE)&dwSet, sizeof (dwSet));

    RegSetValueEx (hKey, TEXT("PerUserLocalSettings"), 0, REG_DWORD,
                   (LPBYTE)&dwSet, sizeof (dwSet));

    //we want the folder redirection extension to get loaded each time.
    RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD,
                   (LPBYTE)&dwReset, sizeof (dwReset));

    //
    // New perf. stuff. We also want to get called in the background and
    // async. foreground case.
    //
    RegSetValueEx (hKey, TEXT("NoBackgroundPolicy"), 0, REG_DWORD,
                   (LPBYTE)&dwReset, sizeof (dwReset));

    RegSetValueEx (hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("GenerateGroupPolicy"),
                   (lstrlen (TEXT("GenerateGroupPolicy")) + 1) * sizeof(TCHAR));

    // Need to register event sources for RSoP
    RegSetValueEx (hKey, TEXT("EventSources"), 0, REG_MULTI_SZ, (LPBYTE)EventSources,
                   sizeof(EventSources) );

    RegCloseKey (hKey);

    //register the dll as a source for event log messages
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Folder Redirection"),
                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("EventMessageFile"), 0, REG_EXPAND_SZ, (LPBYTE) EventFile,
                   (lstrlen(EventFile) + 1) * sizeof (TCHAR));

    RegSetValueEx (hKey, TEXT("ParameterMessageFile"), 0, REG_EXPAND_SZ, (LPBYTE) ParamFile,
                   (lstrlen(ParamFile) + 1) * sizeof (TCHAR));

    RegSetValueEx (hKey, TEXT("TypesSupported"), 0, REG_DWORD, (LPBYTE) &dwTypes,
                   sizeof(DWORD));

    RegCloseKey (hKey);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    RegDelnode (HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{25537BA6-77A8-11D2-9B6C-0000F8080861}"));
    RegDelnode (HKEY_LOCAL_MACHINE,
                     TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Folder Redirection"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\rdrschem.h ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998 - 2000
//  All rights reserved
//
//  appschem.h
//
//  This file contains declarations related to the wmi schema
//  for folder redirection policy objects
//
//*************************************************************

//
// WMI class names for the folder redirection classes
//

#define RSOP_REDIRECTED_FOLDER L"RSOP_FolderRedirectionPolicySetting"


//
// Attribute names for the RSOP_FolderRedirectionPolicyObject class
//

// Unique id
#define RDR_ATTRIBUTE_ID                           L"id"

// Path to which folder is redirected
#define RDR_ATTRIBUTE_RESULT                       L"resultantPath"

// Groups - Array of security groups
#define RDR_ATTRIBUTE_GROUPS                       L"securityGroups"

// Paths - Array of redirection paths 
#define RDR_ATTRIBUTE_PATHS                        L"redirectedPaths"

// Installation Type: 1 = basic, 2 = maximum
#define RDR_ATTRIBUTE_INSTALLATIONTYPE             L"installationType"
//
// Enumerated values for installation type attribute
//
#define RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_BASIC 1L
#define RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_MAX   2L

// Grant Type - Grant user exclusive access
#define RDR_ATTRIBUTE_GRANTTYPE                    L"grantType"

// Move Type - true = moce contents of directory
#define RDR_ATTRIBUTE_MOVETYPE                     L"moveType"

// Policy Removal - 1 = leave folder in new location, 2 = redirect the folder back to the user profile location
#define RDR_ATTRIBUTE_POLICYREMOVAL                L"policyRemoval"
//
// Enumerated values for policyremoval attribute
//
#define RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REMAIN   1L
#define RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REDIRECT 2L

// Redirecting group
#define RDR_ATTRIBUTE_REDIRECTING_GROUP            L"redirectingGroup"


//
// Miscellaneous definitions
//

#define MAX_SZGUID_LEN 39
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\log.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  log.cxx
//
//  Contains definitions for classes related to rsop logging
//  for the folder redirection client-side extension
//
//  Created: 8-01-1999 adamed
//
//*************************************************************

#include "fdeploy.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::CRedirectionPolicy
//
// Purpose: Constructor for CRedirectionPlicy
//
// Params:
//     pGpoData -- structure containing information
//         from the gpo
//     pRdirect -- structure containing redireciton information
//         Precedence -- the precedence this redirection candidate
//         should have.  Lower values are least signifcant, higher
//         values have higher precedence.
// 
// Return value: none
//
// Notes: This constructor allocates memory and performs
//     other complex operations -- if it fails,
//     this fact is tracked internally and operations on the
//     object will fail as well with the error code
//
//------------------------------------------------------------
CRedirectionPolicy::CRedirectionPolicy(
    CFileDB*       pGpoData,
    CRedirectInfo* pRedirect,
    LONG           Precedence,
    HRESULT*       phr) :
    _rgwszGroups(NULL),
    _rgwszRedirectedPaths(NULL),
    _cGroups(0),
    _Precedence(Precedence),
    _dwFlags(pRedirect->m_dwFlags),
    _wszDisplayName(NULL),
    _wszLocalizedName(NULL),
    _wszGPODSPath(NULL),
    _wszSOMId(NULL),
    _pNext(NULL),
    _iFolderIndex(pRedirect->m_rID),
    _iAncestorIndex(0),
    _bHasAncestor(FALSE),
    _pGpoData( pGpoData ),
    _bMissingAncestor( FALSE ),
    _wszRedirectedPath( NULL )
{
    RtlInitUnicodeString( &_RedirectedSid, NULL );

    //
    // If this folder has a parent folder, remember that fact,
    // and record the id of the parent folder
    //
    if (pRedirect->m_pParent)
    {
        _iAncestorIndex = pRedirect->m_pParent->m_rID;
        _bHasAncestor = TRUE;
    }

    //
    // Retrieve security group / redirected folder information
    //
    _hrInit = GetGroupInformation(pRedirect->m_szGroupRedirectionData);

    if (FAILED(_hrInit))
    {
        *phr = _hrInit;
        return;
    }

    //
    // Copy the gpo's ds path for use as a gpo id -- we want only the part
    // of the path after the link prefix and user or computer container
    //
    WCHAR* wszGPOPrefixEnd;

    wszGPOPrefixEnd = wcschr( StripLinkPrefix( pGpoData->_pwszGPODSPath ), L',' );

    //
    // At this point, we are one charcter in front of the gpo container --
    // copy everything after this position
    //
    if ( wszGPOPrefixEnd )
    {
        _wszGPODSPath = StringDuplicate( wszGPOPrefixEnd + 1 );
    }

    if ( ! _wszGPODSPath )
    {
        goto exit_on_memory_allocation_failure;
    }
   
    //
    // Copy the scope of management path and use it as an id,
    // copying only the path after the ds prefix
    //
    _wszSOMId = StringDuplicate( StripLinkPrefix(pGpoData->_pwszGPOSOMPath) );

    if ( ! _wszSOMId )
    {
        goto exit_on_memory_allocation_failure;
    }

    //
    // Copy the friendly name of the redirected folder
    //
    _wszDisplayName = StringDuplicate(pRedirect->m_szDisplayName);

    if ( ! _wszDisplayName )
    {
        goto exit_on_memory_allocation_failure;
    }

    //
    // Copy the localized file system name of the folder
    //
    _wszLocalizedName = StringDuplicate(pRedirect->m_szLocDisplayName);

    if ( ! _wszLocalizedName )
    {
        goto exit_on_memory_allocation_failure;
    }

    //
    // Copy the redirected sid in string format -- the sid
    // will not be present if this folder inherits from the parent,
    // so do not copy it in that case -- this will be dealt with later
    // when the final parent is known.
    //
    if ( pRedirect->m_pSid )
    {
        NTSTATUS       Status;

        //
        // Copy the path to which this folder is redirected
        //
        _wszRedirectedPath = StringDuplicate( _rgwszRedirectedPaths[ pRedirect->m_iRedirectingGroup ] );
        
        if ( ! _wszRedirectedPath )
        {
            goto exit_on_memory_allocation_failure;
        }

        Status = RtlConvertSidToUnicodeString(
            &_RedirectedSid,
            pRedirect->m_pSid,
            TRUE);

        if (STATUS_SUCCESS != Status)
        {
            LONG Error;

            Error = RtlNtStatusToDosError(Status);

            _hrInit = HRESULT_FROM_WIN32(Error);
        }
        else
        {
            _hrInit = S_OK;
        }
    }

    *phr = _hrInit;

    return;

exit_on_memory_allocation_failure:

    //
    // Set our internal state to error so that methods
    // know that our internal state is bad and will fail
    // safely
    //
    _hrInit = E_OUTOFMEMORY;
    *phr = _hrInit;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::~CRedirectionPolicy
//
// Purpose: Destructor for CRedirectionPolicy.  Frees resources
//     allocated by this object
//
// Params: none
// 
// Return value: none
//
// Notes:
//
//------------------------------------------------------------
CRedirectionPolicy::~CRedirectionPolicy()
{
    LONG iGroup;

    //
    // Iterate through the groups / paths strings
    // and destroy each one
    //
    for (iGroup = 0; iGroup < _cGroups; iGroup++)
    {
        delete [] _rgwszGroups[iGroup];
        delete [] _rgwszRedirectedPaths[iGroup];
    }

    //
    // Free all the other allocated strings
    //
    delete [] _rgwszGroups;
    delete [] _rgwszRedirectedPaths;

    delete [] _wszGPODSPath;
    delete [] _wszSOMId;
    delete [] _wszDisplayName;
    delete [] _wszLocalizedName;
    delete [] _wszRedirectedPath;

    RtlFreeUnicodeString(&_RedirectedSid);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::Write
//
// Purpose: implementation of pure virtual Write method required
//     by all policy records.  It writes policy information 
//     for the redirection candidate to the log in the database
//
// Params: none
// 
// Return value: S_OK if successful, error otherwise
//
// Notes:
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::Write()
{
    HRESULT hr;
        
    //
    // Set the unique id
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_ID,
        _wszDisplayName);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_ID, hr )

    //
    // If we cannot make a unique id, we must exit because this is a key
    //
    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, IDS_RSOP_ATTEMPT_WRITE, _wszDisplayName));
        return hr;
    }

    //
    // Set the precedence for the setting -- this is also a key
    // so we must exit if we cannot set this
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_PRECEDENCE,
        _Precedence);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_PRECEDENCE, hr )

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set the time stamp on the record
    //
    {
        SYSTEMTIME CurrentTime;
        
        //
        // This does not fail
        //
        GetSystemTime( &CurrentTime );

        hr = SetValue(
            RSOP_ATTRIBUTE_CREATIONTIME,
            &CurrentTime);
        
        REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_CREATIONTIME, hr );
    }

    //
    // Set the installationtype -- basic or advanced in the UI
    //
    {
        LONG InstallationType;

        if ( _dwFlags & REDIR_SCALEABLE )
        {
            InstallationType = RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_MAX;
        }
        else
        {
            InstallationType = RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_BASIC;
        }

        hr = SetValue(
            RDR_ATTRIBUTE_INSTALLATIONTYPE,
            InstallationType);

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_INSTALLATIONTYPE, hr )
    }
    
    //
    // Set unique id for the gpo
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_GPOID,
        _wszGPODSPath);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_GPOID, hr )

    //
    // Set the friendly name of the redirected folder
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_NAME,
        _wszDisplayName);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_NAME, hr )

    //
    // Set the scope of management that caused this
    // policy to be applied
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_SOMID,
        _wszSOMId);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_SOMID, hr )

    //
    // The path to which the folder would be redirected
    //
    if ( _wszRedirectedPath )
    {
        hr = SetValue(
            RDR_ATTRIBUTE_RESULT,
            _wszRedirectedPath);
        
        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_RESULT, hr )
    }

    //
    // In the case of a child setting with a missing parent, none of the
    // other information can be logged, since it cannot be inferred
    // from the parent (there is none)
    //
    if ( ! _bMissingAncestor )
    {
        //
        // List of security groups
        //
        hr = SetValue(
            RDR_ATTRIBUTE_GROUPS,
            _rgwszGroups,
            _cGroups);

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_GROUPS, hr )

        //
        // List of redirected paths parallel to the security group list
        //
        hr = SetValue(
            RDR_ATTRIBUTE_PATHS,
            _rgwszRedirectedPaths,
            _cGroups);

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_PATHS, hr )

        //
        // Access grant type
        //
        hr = SetValue(
            RDR_ATTRIBUTE_GRANTTYPE,
            (BOOL) (_dwFlags & REDIR_SETACLS));

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_GRANTTYPE, hr )

        //
        // Move Type
        //
        hr = SetValue(
            RDR_ATTRIBUTE_MOVETYPE,
            (BOOL) (_dwFlags & REDIR_MOVE_CONTENTS));

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_MOVETYPE, hr )

        //
        // Redirecting group
        //
        hr = SetValue(
            RDR_ATTRIBUTE_REDIRECTING_GROUP,
            _RedirectedSid.Buffer);

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_REDIRECTING_GROUP, hr )
    }
    else
    {
        WCHAR* wszLocalInheritedPath;

        wszLocalInheritedPath = NULL;

        //
        // If this folder is set to follow its ancestor but no ancestor
        // was specified, we can still set the resulting path by
        // looking at the path to which we are redirected
        //
        hr = GenerateLocalInheritedPath(
            &wszLocalInheritedPath);

        if ( SUCCEEDED( hr ) )
        {
            hr = SetValue(
                RDR_ATTRIBUTE_RESULT,
                _rgwszGroups,
                _cGroups);

            REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_RESULT, hr )
        }
    }

    //
    // Policy Removal
    //
    hr = SetValue(
        RDR_ATTRIBUTE_POLICYREMOVAL,
        (_dwFlags & REDIR_RELOCATEONREMOVE) ?
            RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REDIRECT :
            RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REMAIN);

    REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_POLICYREMOVAL, hr )

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GetGroupInformation
//
// Purpose: Gets gorup information from the redirection ini 
//     file data concerning the list of security groups and
//     the redirected folder for each group
//
// Params: wszGroupRedirectionData -- this data was retrieved
//     from an ini file and contains group and folder lists
// 
// Return value: S_OK if successful, error otherwise
//
// Notes:
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::GetGroupInformation(
    WCHAR* wszGroupRedirectionData)
{
    HRESULT hr;

    //
    // First, parse the file in order to count the groups.  No 
    // memory allocation is done when counting, so this should
    // always succeed
    //
    hr = ParseGroupInformation(
        wszGroupRedirectionData,
        &_cGroups);

    ASSERT(S_OK == hr);

    //
    // Allocate space for references to each group and folder
    // based on the count returned above
    //
    _rgwszGroups = new WCHAR* [_cGroups];

    _rgwszRedirectedPaths = new WCHAR* [_cGroups];

    if (!_rgwszGroups || !_rgwszRedirectedPaths)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Initialize newly allocated references
    //
    RtlZeroMemory(_rgwszGroups, sizeof(*_rgwszGroups) * _cGroups);
    RtlZeroMemory(_rgwszRedirectedPaths, sizeof(*_rgwszRedirectedPaths) * _cGroups);

    //
    // Now perform the actual copy of parsed information.  Note that this
    // will allocate space for strings for each folder and group and
    // set our vectors of references to refer to those strings.  An out of
    // memory error could occur here, so we return any error we get
    //
    hr = ParseGroupInformation(
                wszGroupRedirectionData,
                &_cGroups,
                _rgwszGroups,
                _rgwszRedirectedPaths);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::ParseGroupInformation
//
// Purpose: parses the redirection ini file data to retrieve
//     the list of security groups and the redirected folder for
//     each group
//
// Params:
//     wszGroupRedirectionData -- this data was retrieved
//         from an ini file and contains group and folder lists
//     pCount -- in, out param indicating # of groups / paths to retrieve.
//         on output, only has meaning if the folder and group arrays
//         are not specified -- in this case, it contains the count
//         of groups / paths so you can determine how many exist
//         before allocation.
//     rgwszGroups -- on input, contains an array of pointers
//         to c-strings.  If NULL, only a count of groups / paths
//         is performed and there is no output. 
//         On output, an allocation is made and data is copied
//         for each group. Each entry in the array
//         will be set to point to the appropriate allocated
//         string
//     rgwszPaths -- similar to above, except for target paths
// 
// Return value: S_OK if successful, error otherwise
//
// Notes: IMPORTANT: rgwszGroups and rgwszPaths are parallel
//     arrays and should be accessed as such.
//     In the case of partial allocations below due to out of memory,
//     allocated memory is cleared by the destructor.
//     The basic algorithm for the parsing is taken from another location
//     in this extension -- if that changes, so must this.
//
//     Current data format:
//
//     <group-sid1>=<redirected-filesyspath1>
//     <group-sid2>=<redirected-filesyspath2>
//     <group-sid3>=<redirected-filesyspath3>
//     ...
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::ParseGroupInformation(
    WCHAR*         wszGroupRedirectionData,
    LONG*          pCount,
    WCHAR**        rgwszGroups,
    WCHAR**        rgwszPaths)
{
    WCHAR*  wszCurrent;
    DWORD   cchCurrent;
    DWORD   cGroups;
    HRESULT hr;

    //
    // Init locals
    //
    cGroups = 0;
    hr = S_OK;

    //
    // First, find out how many paths there are, and separate
    // the path entry into its constituents
    //
    wszCurrent = wszGroupRedirectionData;

    if (wszCurrent)
    {
        //
        // Move through the data
        //
        for (wszCurrent;
             *wszCurrent;
             wszCurrent += cchCurrent)
        {
            WCHAR* wszPath;

            //
            // Find out the length of the current entry
            //
            cchCurrent = lstrlen(wszCurrent) + 1;

            //
            // Get the path so we can validate it
            //
            wszPath = wcschr(wszCurrent, L'=');

            //
            // If no path is specified, this is an invalid entry
            //
            if (!wszPath)
            {
                continue;
            }

            //
            // Terminate the pathname, but only if we're doing copying
            //
            if (rgwszGroups)
            {
                *wszPath = L'\0';
            }

            //
            // Advance to the path past the delimiter
            //
            wszPath++;

            //
            // A blank path -- skip this
            //
            if (!*wszPath)
            {
                continue;
            }

            //
            // If the group array is specified, we need to copy the
            // group and folder information, not just count groups / paths
            //
            if (rgwszGroups)
            {
                DWORD Status;

                //
                // Copy this group
                //
                rgwszGroups[cGroups] = StringDuplicate(wszCurrent);

                if ( ! rgwszGroups[cGroups] )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                
                //
                // Copy this path
                //
                Status = GetExpandedPath(
                    _pGpoData,
                    wszPath,
                    _iFolderIndex,
                    _bHasAncestor,
                    &(rgwszPaths[cGroups]));

                if ( ERROR_SUCCESS != Status )
                {
                    hr = HRESULT_FROM_WIN32( Status );
                    break;
                }
            }

            cGroups++;
        }
    }

    //
    // Record the number of groups counted
    //
    *pCount = cGroups;

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GenerateInheritedPath
//
// Purpose: Return the name of the path that results from
//     treating this folder as a subfolder of a specific path
//
// Params:
//     pwszAncestorPath -- in parameter indicating parent folder in 
//         in which this folder should be placed
// 
//     ppwszInheritedPath -- out parameter for resulting path
// 
// Return value: S_OK if successful, error otherwise
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::GenerateInheritedPath(
    WCHAR*  pwszAncestorPath,
    WCHAR** ppwszInheritedPath)
{
    HRESULT hr;
    DWORD   cchParent;
    DWORD   cchRelative;
    
    hr = E_OUTOFMEMORY;

    //
    // Construct the folder path by adding the relative path of this
    // child to its ancestor's path
    //

    //
    // First, determine the length of the path of this folder
    // relative to its ancestor's path -- this is just the
    // localized name of the folder
    //
    cchRelative = lstrlen( _wszLocalizedName );

    cchParent = lstrlen( pwszAncestorPath );
    
    *ppwszInheritedPath = new WCHAR[ cchParent + 1 + cchRelative + 1 ];
    
    if ( *ppwszInheritedPath )
    {
        //
        // Now, copy the ancestor's path
        //
        lstrcpy( *ppwszInheritedPath, pwszAncestorPath );

        //
        // Add on the path separator if one does not already exist at the end of the ancestor path
        //
        if ( ( cchParent != 0 ) && 
             ( L'\\' != pwszAncestorPath[ cchParent - 1] ) )
        {
            lstrcat( *ppwszInheritedPath, L"\\" );
        }

        //
        // Now append this child's relative path to its ancestor
        //
        lstrcat( *ppwszInheritedPath, _wszLocalizedName );

        hr = S_OK;
    }
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GenerateInheritedPath
//
// Purpose: Return the name of the path that results from
//     treating this folder as a subfolder of the path
//     to which this folder's parent is redirected
//
// Params:
//
//     ppwszInheritedPath -- out parameter for resulting path
// 
// Return value: S_OK if successful, error otherwise
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::GenerateLocalInheritedPath(
    WCHAR** ppwszInheritedPath )
{
    HRESULT        hr;
    int            iAncestor;
    CRedirectInfo* pAncestorInfo;
    WCHAR          wszFolderKey [ TARGETPATHLIMIT ];
    WCHAR          wszInheritedFolder [ TARGETPATHLIMIT ];

    hr = S_OK;

    iAncestor = GetAncestorIndex();

    pAncestorInfo = & ( gPolicyResultant[ iAncestor ] );

    lstrcpy( wszFolderKey, pAncestorInfo->m_szFolderRelativePath );
    lstrcat( wszFolderKey, L"\\" );

    if ( _pGpoData->GetRsopContext()->IsDiagnosticModeEnabled() )
    { 
        DWORD Status;

        Status = _pGpoData->GetLocalFilePath(
            wszFolderKey,
            wszInheritedFolder);

        hr = HRESULT_FROM_WIN32( Status );
    }
    else
    {
        lstrcpy( wszInheritedFolder, L"%USERPROFILE%\\" );
        lstrcat( wszInheritedFolder, wszFolderKey );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = GenerateInheritedPath(
            wszInheritedFolder,
            ppwszInheritedPath);
    }
    
    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::CopyInheritedData
//
// Purpose: Copies data that should be inherited from an ancestor
//          to the object
//
// Params:
//     pAncestralPolicy -- pointer to CRedirectionPolicy representing
//         the policy for the ancestor folder
// 
// Return value: S_OK if successful, error otherwise.
//
// Notes: 
//
//     If a folder is set to inherit from its parent, the
//     following attributes must be copied from the parent:
//
//         - Security Groups
//         - Redirection target paths
//         - The number of groups / paths
//         - Flags
//
//     This method copies those attributes from an ancestor
//     to this object
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::CopyInheritedData( CRedirectionPolicy* pAncestralPolicy )
{
    LONG    iGroup;
    LONG    cGroups;
    HRESULT hr;

    //
    // If we have no ancestor, then the only ancestral information
    // we can copy is the redirected path
    //
    if ( ! pAncestralPolicy )
    {
        _bMissingAncestor = TRUE;

        hr = GenerateLocalInheritedPath(
            &_wszRedirectedPath);

        return hr;
    }

    //
    // Copy the redirecting group information first -- it 
    // will only be there if the user would have gotten
    // this folder, so do not try to copy it if it is not there
    //
    if ( pAncestralPolicy->_RedirectedSid.Buffer )
    {
        BOOLEAN fAllocatedString;

        fAllocatedString = RtlCreateUnicodeString(
            &_RedirectedSid,
            pAncestralPolicy->_RedirectedSid.Buffer);

        if ( !fAllocatedString )
        {
            return E_OUTOFMEMORY;
        }

        RtlCopyUnicodeString(
            &_RedirectedSid,
            &(pAncestralPolicy->_RedirectedSid));

        hr = GenerateInheritedPath(
            pAncestralPolicy->_wszRedirectedPath,
            &_wszRedirectedPath);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Find out how many groups / paths there are
    //
    cGroups = pAncestralPolicy->_cGroups;

    //
    // Allocate space for the security groups
    //
    _rgwszGroups = new WCHAR* [ cGroups ];

    hr = E_OUTOFMEMORY;

    if ( _rgwszGroups )
    {
        //
        // Now allocate space for the target paths
        //
        _rgwszRedirectedPaths = new WCHAR* [ cGroups ];

        if ( _rgwszRedirectedPaths )
        {
            hr = S_OK;

            //
            // Now allocate copies of each security group and
            // redirected target path
            //
            for ( iGroup = 0; iGroup < cGroups; iGroup ++ )
            {
                DWORD cchParent;

                //
                // Construct the folder path by adding the relative path of this
                // child to its ancestor's path
                //

                //
                // First, copy the ancestor's path
                //
                hr = GenerateInheritedPath(
                    pAncestralPolicy->_rgwszRedirectedPaths[ iGroup ],
                    &( _rgwszRedirectedPaths[ iGroup ] )
                    );
                
                if ( FAILED( hr ) )
                {
                    break;
                }

                //
                // Security group is much simpler -- just copy it
                //
                _rgwszGroups[ iGroup ] = StringDuplicate(
                    pAncestralPolicy->_rgwszGroups[ iGroup ]);

                if ( ! _rgwszGroups[ iGroup ] )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
        }
    }

    //
    // Copy the flags
    //
    _dwFlags = pAncestralPolicy->_dwFlags;

    //
    // If we're successful, set the # of groups. We only set this on
    // success so that we don't write out an incomplete set
    //
    if ( SUCCEEDED( hr ) )
    {
        _cGroups = cGroups;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GetFolderIndex
//
// Purpose: Retrieves a numeric index representing the folder
//          (startup, mydocs, etc)
//
// Params: none
// 
// Return value: index of the folder redirected by this policy
//
// Notes: 
//
//------------------------------------------------------------
int CRedirectionPolicy::GetFolderIndex()
{
    return _iFolderIndex;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GetAncestorIndex
//
// Purpose: Retrieves a numeric index representing the ancestor
//          of this folder
//
// Params: none
// 
// Return value: index of the ancestor of the folder redirected
//     by this policy
//
// Notes: 
//
//------------------------------------------------------------
int CRedirectionPolicy::GetAncestorIndex()
{
    return _iAncestorIndex;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::HasAncestor
//
// Purpose: Indicates whether or not the folder redirected by
//     this policy has an ancestor folder
//
// Params: none
// 
// Return value: TRUE if the folder redirected by this policy
//     has an ancestor, FALSE if not
//
// Notes: 
//
//------------------------------------------------------------
BOOL CRedirectionPolicy::HasAncestor()
{
    return _bHasAncestor;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::HasInheritedData
//
// Purpose: Indicates whether or not the folder redirected by
//     this policy should inherit data from its ancestor
//
// Params: none
// 
// Return value: TRUE if the folder redirected by this policy
//     shoud inherit data from an ancestor, FALSE if not
//
// Notes: 
//
//------------------------------------------------------------
BOOL CRedirectionPolicy::HasInheritedData()
{
    //
    // If the policy lists no groups / targat paths,
    // 
    //
    return 0 != _cGroups;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::NormalizePrecedence
//
// Purpose: Normalize precedence according the scale passed in
//
// Params: 
//     lScale - indicates what value should be considered the 
//     highest priority, and then priority is reversed based on this --
//     e.g. if 5 is the scale, an object with precedence 5
//     will become precedence 1 (the most important) when this
//     function is called.  The object with precedence 1
//     will have value 5, the least significant, and intervening
//     values will behave accordingly
// 
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionPolicy::NormalizePrecedence( LONG Scale )
{
    //
    // Reverse the precedence -- switch it from highest values
    // are most important to the reverse
    //
    _Precedence = Scale - _Precedence + 1;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::IsRedirected()
//
// Purpose: Normalize precedence according the scale passed in
//
// Params: 
//     none
// 
// Return value: TRUE if the folder is currently 
//     successfully redirected, FALSE if not
//
// Notes: 
//
//------------------------------------------------------------
BOOL CRedirectionPolicy::IsRedirected()
{
    DWORD Status;

    //
    // Check the global state to see if this folder
    // has been successfully redirected
    //
    Status = gPolicyResultant[ _iFolderIndex ].m_StatusRedir;

    return ERROR_SUCCESS == Status;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPrecedenceState::CPrecedenceState
//
// Purpose: Constructor for CPrecedenceState class
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CPrecedenceState::CPrecedenceState()
{
    RtlZeroMemory(_rgFolderPrecedence, sizeof(_rgFolderPrecedence));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPrecedenceState::UpdateFolderPrecedence
//
// Purpose: Changes the precedence of the winning folder specified by
//     the index
//
// Params:
//     iFolder -- index of folder whose precedence we are updating
//
// Return value: returns the new precedence of the folder
//
// Notes: 
//
//------------------------------------------------------------
LONG CPrecedenceState::UpdateFolderPrecedence( int iFolder )
{
    //
    // Increase the precedence of the winning folder
    //
    return ++ ( _rgFolderPrecedence[ iFolder ] );
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPrecedenceState::GetFolderPrecedence
//
// Purpose: Retrieves the precedence of the folder specified by
//     the index
//
// Params:
//     iFolder -- index of folder whose precedence we are
//     retrieving
//
// Return value: returns the current precedence of the folder
//
// Notes: 
//
//------------------------------------------------------------
LONG CPrecedenceState::GetFolderPrecedence( int iFolder )
{
    return _rgFolderPrecedence[ iFolder ];
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::AddRedirectionPolicies
//
// Purpose: Appends candidate policies to the list of
//     redirection candidates
//
// Params:
//     pGpoData -- pointer to information concerning the gpo
//     from which the redirection candidate came
//     pRedirectionInfo -- pointer to array candidate policies 
//     (one for each folder that can be redirected) to
//     append to the list
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//      IMPORTANT: this method is designed to be called
//      multiple times and aggregate state across calls.  The 
//      order in which calls occur is important -- each gpo
//      passed in must be greater than the gpo passed
//      in the previous call.  Or put another way, this
//      method should be called in order of least precedent gpo
//      to most.  This is necessary in order for the precedence
//      calculations to be correct
//
//------------------------------------------------------------
HRESULT CRedirectionLog::AddRedirectionPolicies(
    CFileDB*          pGpoData,
    CRedirectInfo*    pRedirectionInfo)
{
    DWORD               iRedirect;

    ASSERT( _pRsopContext->IsRsopEnabled() );

    //
    // For each folder that could be redirected, we'll check to see
    // if it gets redirected, and add it to the list if so
    //
    for (iRedirect = 0 ; iRedirect < EndRedirectable; iRedirect++)
    {
        LONG                Precedence;
        CRedirectionPolicy* pNewRedirection;

        //
        // Check to see if this is redirected
        //
        if ( pRedirectionInfo[ iRedirect ].HasPolicy() )
        {
            HRESULT hr;

            //
            // Update the folder's precedence since we found a candidate
            //
            Precedence = _PrecedenceState.UpdateFolderPrecedence( iRedirect );

            //
            // Create an abstraction of the redirection candidate policy
            //
            pNewRedirection = new CRedirectionPolicy(
                pGpoData,
                &(pRedirectionInfo[iRedirect]),
                Precedence,
                &hr);

            if ( ! pNewRedirection )
            {
                hr = E_OUTOFMEMORY;
            }

            if ( FAILED(hr) )
            {
                _pRsopContext->DisableRsop( hr );
                return hr;
            }

            //
            // Add it to the list of redirections
            //
            *_ppNextRedirection = pNewRedirection;
            _ppNextRedirection = &(pNewRedirection->_pNext);
        }
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::NormalizePrecedence
//
// Purpose: Normalize a redirection's precedence according
//     to its relationship with redirections from other gpo's
//
// Params:
//     pRedirectionPolicy -- redirection policy candidate to
//     be normalized
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionLog::NormalizePrecedence( CRedirectionPolicy* pRedirectionPolicy )
{
    int iFolder;

    //
    // Find the folder index for the redirected candidate
    //
    iFolder = pRedirectionPolicy->GetFolderIndex();

    //
    // Now use the winning precedence as the scale to normalize
    // this candidate
    //
    pRedirectionPolicy->NormalizePrecedence(
        _PrecedenceState.GetFolderPrecedence( iFolder ) );
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::WriteRsopLog
//
// Purpose: Creates an rsop log of all the redirection information
//     for the current user
//
// Params: none
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CRedirectionLog::WriteRsopLog()
{
    CRedirectionPolicy* pCurrent;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Clear any existing log before writing out redirection results
    //
    ClearRsopLog();

    //
    // Iterate trhough the list of redirection candidates
    //
    for (pCurrent = _pRedirectionList;
         pCurrent;
         pCurrent = (CRedirectionPolicy*) pCurrent->_pNext)
    {
        //
        // Normalize the precedence of this candidate with
        // respect to other redirections
        //
        NormalizePrecedence( pCurrent );

        //
        // Add in any ancestral policy data
        //
        (void) AddAncestralPolicy( pCurrent );    

        //
        // Write the record to the database
        //
        if ( pCurrent->IsRedirected() )
        {
            WriteNewRecord(pCurrent);
        }
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::GetAncestor
//
// Purpose: returns the candidate redirection that is redirecting
//     the folder that is the ancestor of the specified redirection
//     candidate
//
// Params: pRedirectionPolicy -- redirection whose candidate
//     redirection ancestor we wish to retrieve
//
// Return value: reference to redirection policy candidate
//
// Notes: 
//
//------------------------------------------------------------
CRedirectionPolicy* CRedirectionLog::GetAncestor(
    CRedirectionPolicy* pRedirectionPolicy )
{
    int                 iFolder;
    CRedirectionPolicy* pAncestor;
    CRedirectionPolicy* pCurrent;

    pAncestor = NULL;

    //
    // First, determine which folder is the ancestor of the
    // specified redirection
    //
    iFolder = pRedirectionPolicy->GetAncestorIndex();

    //
    // Iterate trhough the list -- it is sorted, with
    // the highest gpo last, and ancestors always
    // appear before children -- we want to find the
    // highest ancestor 
    //
    for (pCurrent = _pRedirectionList;
         pCurrent;
         pCurrent = (CRedirectionPolicy*) pCurrent->_pNext)
    {
        //
        // Remember the last ancestor we've seen
        //
        if ( iFolder == pCurrent->GetFolderIndex() )
        {
            pAncestor = pCurrent;
        }
    }

    //
    // Now return the ancestor that is currently highest
    // without violating the gpo precedence of the child setting
    //
    return pAncestor;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::AddAncestralPolicy
//
// Purpose: causes a redirection candidate to inherit settings
//     from an ancestor folder (if it has one) if inheritance
//     is specified in the policy
//
// Params: pRedirectionPolicy -- redirection to which we want
//     to which we want to add ancestor's policy settings
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CRedirectionLog::AddAncestralPolicy( CRedirectionPolicy* pRedirectionPolicy)
{
    HRESULT hr;

    CRedirectionPolicy* pAncestorPolicy;

    //
    // See if this redirection has inherited data
    //
    if ( pRedirectionPolicy->HasInheritedData() )
    {
        return S_OK;
    }

    //
    // If this policy doesn't have an ancestor, then we're done
    //
    if ( ! pRedirectionPolicy->HasAncestor() )
    {
        return S_OK;
    }

    //
    // This policy has an ancestor -- retrieve it
    //
    pAncestorPolicy = GetAncestor( pRedirectionPolicy );

    //
    // Inherit settings from the ancestor
    //
    hr = pRedirectionPolicy->CopyInheritedData( pAncestorPolicy );

    return hr;
}


HRESULT CRedirectionLog::AddPreservedPolicy( WCHAR* wszFolderName )
{
    DWORD   cchLen;
    WCHAR*  wszNewQuery;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    cchLen = lstrlen( wszFolderName );

    cchLen += sizeof( WQL_INSTANCE ) / sizeof( WCHAR ) +
        sizeof( WQL_AND ) / sizeof( WCHAR );

    if ( _wszDeletionQuery )
    {
        cchLen += lstrlen( _wszDeletionQuery );
    }
    
    wszNewQuery = new WCHAR [ cchLen ];

    if ( ! wszNewQuery )
    {
        return E_OUTOFMEMORY;
    }

    if ( _wszDeletionQuery )
    {
        lstrcpy( wszNewQuery, _wszDeletionQuery );
        lstrcat( wszNewQuery, WQL_AND );
    }
    else
    {
        *wszNewQuery = L'\0';
    }

    wsprintf( wszNewQuery + lstrlen( wszNewQuery ), 
              WQL_INSTANCE,
              wszFolderName );

    delete [] _wszDeletionQuery;

    _wszDeletionQuery = wszNewQuery;
    
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::CRedirectionLog
//
// Purpose: constructor for class CRedirectionLog
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CRedirectionLog::CRedirectionLog() :
    _pRedirectionList(NULL),
    _ppNextRedirection(&_pRedirectionList),
    _wszDeletionQuery( NULL )
{}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::~CRedirectionLog
//
// Purpose: destructor for class CRedirectionLog.
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CRedirectionLog::~CRedirectionLog()
{
    CRedirectionPolicy* pCurrent;
    CRedirectionPolicy* pNext;

    for (pCurrent = _pRedirectionList;
         pCurrent;
         pCurrent = pNext)
    {
        pNext = (CRedirectionPolicy*) pCurrent->_pNext;

        delete pCurrent;
    }

    delete [] _wszDeletionQuery;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::InitRsop
//
// Purpose: Initializes rsop logging
//
// Params: pRsopContext -- logging contxt
//         bForceRsop -- TRUE if we should bind to a namespace
//             in the absence of an existing namespace in this context
//
//
// Return value: none
//
// Notes: 
//
//    Success of initialization is stored internally -- rsop
//    is disabled if there's a failure
//
//------------------------------------------------------------
void CRedirectionLog::InitRsop( CRsopContext* pRsopContext, BOOL bForceRsop )
{
    HRESULT    hr;

    //
    // If the caller needs us to bind to a saved namespace because
    // the gp engine did not pass one in and we need to log new data,
    // do so.
    //
    if ( bForceRsop )
    {
        (void) pRsopContext->InitializeSavedNameSpace();
    }

    //
    // Initialize Rsop logging
    //
    hr = InitLog( pRsopContext, RSOP_REDIRECTED_FOLDER );

    if (FAILED(hr))
    {
        pRsopContext->DisableRsop( hr );
        return;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::ClearRsopLog
//
// Purpose: Clears the namespace of records
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionLog::ClearRsopLog()
{
    HRESULT hr;

    //
    // Nothing to do if logging is not enabled
    //
    if (! _pRsopContext->IsRsopEnabled() )
    {
        return;
    }

    //
    // Attempt to clear the log
    //
    hr = ClearLog( _wszDeletionQuery );

    //
    // If we cannot clear it, disable logging
    //
    if (FAILED(hr))
    {
        _pRsopContext->DisableRsop( hr );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: StringDuplicate
//
// Purpose: Simple duplication of a c-string
//
// Params: wszOriginal -- string to be duplicated
//
// Return value: reference to allocated duplicate string if 
//     successful, NULL on failure
//
// Notes:  returned string should be freed by caller with
//     vector delete
//
//------------------------------------------------------------
WCHAR* StringDuplicate(WCHAR* wszOriginal)
{
    WCHAR* wszNew;
    DWORD  cchSize;

    ASSERT(wszOriginal);

    //
    // Determine original size
    //
    cchSize = lstrlen(wszOriginal) + 1;

    //
    // Allocate the space for the duplicate
    //
    wszNew = new WCHAR[ cchSize ];

    //
    // Duplicate to the new allocation if
    // the allocation was successful
    //
    if (wszNew) 
    {
        lstrcpy(wszNew, wszOriginal);
    }

    return wszNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\resource.h ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Resource.h
//
//  Header file for fdeploy.rc
//
//*************************************************************

#define IDS_STRING              0
#define IDS_PROCESSGPO          1
#define IDS_GPO_FLAGS           2
#define IDS_GPO_NAME            3
#define IDS_GPO_FILESYSPATH     4
#define IDS_GPO_DSPATH          5
#define IDS_GPO_DISPLAYNAME     6
#define IDS_NOCHANGES           7
#define IDS_PROCESSREDIRECTS    8
#define IDS_REDIRECT            9
#define IDS_REDIRECT_DEL_FAIL   10
#define IDS_REDIRECT_INSYNC     11
#define IDS_REDIRECT_PREVPATH   12
#define IDS_REDIRECT_NEWPATH    13
#define IDS_REDIRECT_COPYON     14
#define IDS_REDIRECT_COPYOFF    15
#define IDS_MYDOCSRESTRICT_ON   16
#define IDS_MYDOCSRESTRICT_OFF  17
#define IDS_FOLDERPATH_FAIL     18
#define IDS_NO_LOCALAPPDATA     19
#define IDS_REDIRECT_NO_LOCAL   20
#define IDS_REDIRECT_EXP_FAIL   21
#define IDS_HASADD_POLICY       22
#define IDS_HASREMOVE_POLICY    23
#define IDS_PROCESS_GATHER_OK   24
#define IDS_REDIRECT_DELETE     25
#define IDS_DIRDEL_FAIL         26
#define IDS_FILEDEL_FAIL        27
#define IDS_DIRCREATE_FAIL      28
#define IDS_FILECOPY_FAIL       29
#define IDS_SETSECURITY_FAIL    30
#define IDS_REDIR_NOTSUPPORTED  31
#define IDS_COLLECT_REDIRINFO   32
#define IDS_DERIVEINFO_ERROR    33
#define IDS_ACL_MISMATCH        34
#define IDS_CSCPIN_FAIL         35
#define IDS_GROUP_MEMBER        36
#define IDS_MERGE_FAILURE       37
#define IDS_GATHER_FAILURE      38
#define IDS_INIT_FAILED         39
#define IDS_INVALID_FLAGS       40
#define IDS_DESKTOP             41
#define IDS_MYDOCS              42
#define IDS_MYPICS              43
#define IDS_STARTMENU           44
#define IDS_PROGRAMS            45
#define IDS_STARTUP             46
#define IDS_APPDATA             47
#define IDS_MYPICS_REL          48
#define IDS_PROGRAMS_REL        49
#define IDS_STARTUP_REL         50
#define IDS_DEFAULT_CALLBACK    51
#define IDS_REDIR_CALLBACK      52
#define IDS_IGNORE_DELETEDGPO   53
#define IDS_EFFECTIVE_REMOVE_POLICY     54
#define IDS_CSCDELETE_FAIL      55
#define IDS_CSCRENAME_FAIL      56
#define IDS_UPN_CHANGE          57
#define IDS_GETNAME_FAILED      58
#define IDS_RSOP_ATTRIBUTE_FAIL 59
#define IDS_RSOP_ATTEMPT_WRITE  60
#define IDS_HOMEDIR_EXPANDED    61
#define IDS_HOMEDIR_EXPAND_FAIL 62
#define IDS_QUERYDSFORHOMEDIR   63
#define IDS_OBTAINED_HOMEDIR    64
#define IDS_FAILED_GETHOMEDIR   65
#define IDS_MYPICSLINK_FAILED   66
#define IDS_MYPICSLINK_SUCCEEDED 67
#define IDS_POLICY_DELAYED      68
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\redir.cxx ===
/*++




Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    redir.cxx

Abstract:
    This module contains the implementation for the members of the class
    CRedirInfo which is used to consolidate redirection information from all
    the policies applied to a particular GPO and then finally do the redirection
    for the policy with the highest precedence.

Author:

    Rahul Thombre (RahulTh) 8/11/1998

Revision History:

    8/11/1998   RahulTh         Created this module.

--*/

#include "fdeploy.hxx"

//initialize some global variables
WCHAR * g_szRelativePathNames[] =
{
    L"Desktop",
    L"My Documents",
    L"My Documents\\My Pictures",
    L"Start Menu",
    L"Start Menu\\Programs",
    L"Start Menu\\Programs\\Startup",
    L"Application Data"
};

WCHAR * g_szDisplayNames[] =
{
    L"Desktop",
    L"My Documents",
    L"My Pictures",
    L"Start Menu",
    L"Programs",
    L"Startup",
    L"Application Data"
};
//above: use the same order and elements as in REDIRECTABLE

//global variables.
const int g_lRedirInfoSize = (int) EndRedirectable;
//static members of the class
int CRedirectInfo::m_idConstructor = 0;

CRedirectInfo gPolicyResultant [g_lRedirInfoSize];
CRedirectInfo gDeletedPolicyResultant [g_lRedirInfoSize];
CRedirectInfo gAddedPolicyResultant [g_lRedirInfoSize];

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::CRedirectInfo
//
//  Synopsis:   Constructor for the class
//
//  Arguments:
//
//  Returns:
//
//  History:    8/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CRedirectInfo::CRedirectInfo ()
{
    m_rID = (REDIRECTABLE)(m_idConstructor);   //assign IDs sequentially.
    m_idConstructor = (m_idConstructor + 1) %  ((int)EndRedirectable);
    
    m_pSid = NULL;
    m_szLocation = NULL;
    m_cbLocSize = 0;
    m_szGroupRedirectionData = NULL;

    ResetMembers ();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::~CRedirectInfo
//
//  Synopsis:   destructor
//
//  Arguments:
//
//  Returns:
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CRedirectInfo::~CRedirectInfo ()
{
    FreeAllocatedMem ();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::FreeAllocatedMem
//
//  Synopsis:   frees memory allocated for member vars.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirectInfo::FreeAllocatedMem (void)
{
    if (m_szLocation)
    {
        delete [] m_szLocation;
        m_szLocation = NULL;
        m_cbLocSize = 0;
    }

    if (m_pSid)
    {
        delete [] ((BYTE *)m_pSid);
        m_pSid = NULL;
    }

    if (m_szGroupRedirectionData)
    {
        delete [] m_szGroupRedirectionData;
        m_szGroupRedirectionData = NULL;        
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::ResetMembers
//
//  Synopsis:   resets the members of the class to their default values.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      static members of a class, like other global variables are
//              initialized only when the dll is loaded. So if this dll
//              stays loaded across logons, then the fact that the globals
//              have been initialized based on a previous logon can cause
//              problems. Therefore, this function is used to reinitialize
//              the globals.
//
//---------------------------------------------------------------------------
void CRedirectInfo::ResetMembers(void)
{
    FreeAllocatedMem ();
    
    m_iRedirectingGroup = 0;
    
    //defaults. are changed later on based on the state of this object.
    m_bFollowsParent = FALSE;
    m_bRedirectionAttempted = FALSE;
    m_StatusRedir = ERROR_SUCCESS;
    m_bValidGPO = FALSE;
    m_szGPOName[0] = L'\0';

    lstrcpy (m_szFolderRelativePath, g_szRelativePathNames [(int) m_rID]);
    lstrcpy (m_szDisplayName, g_szDisplayNames [(int) m_rID]);

    m_fDataValid = FALSE;
    m_cbLocSize = 256;   //start with a random amount
    m_szLocation = new WCHAR [m_cbLocSize];
    if (m_szLocation)
    {
        m_szLocation[0] = '\0';
    }
    else
    {
        m_cbLocSize = 0; //don't worry right now if memory cannot be allocated here, we will fail later
    }
    //set the parent and child pointers for the special parent/descendants
    m_pChild = NULL;    //start with defaults
    m_pParent = NULL;
    switch (m_rID)
    {
    case MyDocs:
        m_pChild = this - (int) m_rID + (int) MyPics;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case MyPics:
        m_pParent = this - (int) m_rID + (int) MyDocs;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case StartMenu:
        m_pChild = this - (int) m_rID + (int) Programs;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case Programs:
        m_pParent = this - (int) m_rID + (int) StartMenu;
        m_pChild = this - (int) m_rID + (int) Startup;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case Startup:
        m_pParent = this - (int) m_rID + (int) Programs;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case Desktop:
        m_pChild = NULL;
        m_pParent = NULL;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case AppData:
        m_pChild = NULL;
        m_pParent = NULL;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    }

    //as a safety mechanism, load localized folder names if ghDllInstance
    //has been set. note: ghDllInstance won't be set for global variables
    //since their constructors before DllMain. For such variables, the
    //localized names have to be called explicitly from some other function
    //which is called after DllMain.
    if (ghDllInstance)
        LoadLocalizedNames();

    //
    // No need to modify m_rID or m_idConstructor. The construct has already
    // taken care of it and touching them might cause undesirable results if
    // not done in the proper order. Besides, these don't change across multiple
    // sessions.
    //
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetFolderIndex
//
//  Synopsis:   a static member function that, given the name of a special
//              folder, returns its id which can be used to locate the
//              redirection info. for that particular folder.
//
//  Arguments: [in][szFldrName : the name of the folder as stored in fdeploy.ini
//
//  Returns: the id of the folder. If the folder is not redirectable, the
//           function returns EndRedirectable.
//
//  History:    8/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
REDIRECTABLE CRedirectInfo::GetFolderIndex (LPCTSTR szFldrName)
{
    int i;
    for (i = 0; i < (int)EndRedirectable; i++)
    {
        if (0 == lstrcmpi (szFldrName, g_szDisplayNames[i]))
            break;  //we have found a match
    }

    return (REDIRECTABLE)i;   //if a match was not found above, i == EndRedirectable
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::LoadLocalizedNames
//
//  Synopsis:   loads the localized folder display names and folder relative
//              paths from the resources.
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS if the names were successfully loaded.
//              an error code describing the cause of the failure otherwise.
//
//  History:    5/6/1999  RahulTh  created
//
//  Notes:      we cannot do this in the constructor because ghDllInstance
//              is not initialized at that time and therefore LoadString will
//              fail. This is because DllMain is called after the constructors.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::LoadLocalizedNames (void)
{
    UINT    DisplayID;
    UINT    RelpathID;

    switch (m_rID)
    {
    case MyDocs:
        DisplayID = RelpathID = IDS_MYDOCS;
        break;
    case MyPics:
        DisplayID = IDS_MYPICS;
        RelpathID = IDS_MYPICS_REL;
        break;
    case StartMenu:
        DisplayID = RelpathID = IDS_STARTMENU;
        break;
    case Programs:
        DisplayID = IDS_PROGRAMS;
        RelpathID = IDS_PROGRAMS_REL;
        break;
    case Startup:
        DisplayID = IDS_STARTUP;
        RelpathID = IDS_STARTUP_REL;
        break;
    case Desktop:
        DisplayID = RelpathID = IDS_DESKTOP;
        break;
    case AppData:
        DisplayID = RelpathID = IDS_APPDATA;
        break;
    }

    //now get the localized name of the folder and the localized relative
    //path names (w.r.t. the userprofile directory)
    m_szLocDisplayName[0] = m_szLocFolderRelativePath[0] = '\0';   //safety

    if (!LoadString (ghDllInstance, DisplayID, m_szLocDisplayName, 80))
        return GetLastError();

    if (DisplayID == RelpathID)
    {
        lstrcpy (m_szLocFolderRelativePath, m_szLocDisplayName);    //top level folders
    }
    else
    {
        if (!LoadString (ghDllInstance, RelpathID, m_szLocFolderRelativePath, 80))   //special descendant folders
            return GetLastError();
    }

    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GatherRedirectionInfo
//
//  Synopsis:   this function gathers redirection info. from the ini file
//
//  Arguments:  [in] pFileDB : pointer to the CFileDB object that called it
//              [in] dwFlags : the flags as obtained from the ini file
//              [in] bRemove : whether this is a policy that is being removed
//
//  Returns:    STATUS_SUCCESS if successful. An error code otherwise.
//
//  History:    8/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::GatherRedirectionInfo (CFileDB * pFileDB, DWORD dwFlags, BOOL bRemove)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   len;
    BOOL    bStatus;
    WCHAR * pwszSection = 0;
    BOOL    bFoundGroup;
    WCHAR * pwszString = 0;
    WCHAR * pwszSid = 0;
    WCHAR * pwszPath = 0;
    PSID    Sid = NULL;

    if (bRemove &&
        (!gSavedSettings[m_rID].m_bValidGPO ||
         (0 != _wcsicmp (pFileDB->_pwszGPOUniqueName, gSavedSettings[m_rID].m_szGPOName))
        )
       )
    {
        DebugMsg((DM_VERBOSE, IDS_IGNORE_DELETEDGPO, pFileDB->_pwszGPOName, pFileDB->_pwszGPOUniqueName, m_szLocDisplayName));
        Status = ERROR_SUCCESS;
        //set default values on the members just to be on the safe side.
        m_fDataValid = FALSE;
        m_dwFlags = REDIR_DONT_CARE;
        m_bValidGPO = FALSE;
        m_szGPOName[0] = L'\0';
        goto GatherInfoEnd;
    }

    //the data is valid. This function is only called when something relevant is found in the ini file.
    m_fDataValid = TRUE;

    //store the flags
    m_dwFlags = dwFlags;

    //store the GPO's unique name
    if (bRemove)
    {
        m_bValidGPO = FALSE;    //for redirection resulting from a removed GPO, we do not store the GPO name to avoid processing a removal twice
        m_szGPOName[0] = L'\0';
    }
    else
    {
        m_bValidGPO = TRUE;
        wcscpy (m_szGPOName, pFileDB->_pwszGPOUniqueName);
    }

    //there is nothing to do if policy is not specified for this folder
    if (m_dwFlags & REDIR_DONT_CARE)
        goto GatherInfoSuccess;

    m_bRemove = bRemove;

    //also, we can do nothing right now if this is a special descendant folder
    //following its parent
    if (m_dwFlags & REDIR_FOLLOW_PARENT)
        goto GatherInfoSuccess;

    //a location has been specified by this policy

    if ( ! pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
    {
        //we must have a list of groups to which the user belongs
        //each user must at least have everyone as one of his groups
        if (! pFileDB->_pGroups)
            goto GatherInfoErr;
    }

    DWORD cchSectionLen;

    bStatus = pFileDB->ReadIniSection (m_szDisplayName, &pwszSection, &cchSectionLen);

    if (!bStatus)
        goto GatherInfoErr;

    bFoundGroup = FALSE;

    //
    // For rsop, we need to know the list of security groups
    // and redirected paths -- we'll copy this information for
    // use by the rsop logging code
    //
    if (pFileDB->GetRsopContext()->IsRsopEnabled())
    {
        //
        // Note that when we do the copy, the size returned
        // by ReadIniSection above does not include the null terminator,
        // even though thaft character is present, so we must add that character
        // to the count ourselves. 
        //
        m_szGroupRedirectionData = new WCHAR[cchSectionLen + 1];

        if (m_szGroupRedirectionData)
        {
            RtlCopyMemory(m_szGroupRedirectionData,
                          pwszSection,
                          ( cchSectionLen + 1 ) * sizeof(*pwszSection));
        }
        else
        {
            pFileDB->GetRsopContext()->DisableRsop( E_OUTOFMEMORY );
        }
    }

    DWORD iGroup;

    iGroup = 0;

    for (pwszString = pwszSection;
         *pwszString;
         pwszString += lstrlen(pwszString) + 1)
    {
        pwszSid = pwszString;
        pwszPath = wcschr (pwszString, L'=');
        if (!pwszPath)
            continue;   //skip any invalid entries

        //temporarily break up the sid and the path
        *pwszPath++ = L'\0';

        if (! *pwszPath)
        {
            //again an invalid path. restore the = sign and move on
            pwszPath[-1] = L'=';    //note: we had advanced the pointer above
            continue;
        }

        //the entry is valid
        bFoundGroup = GroupInList (pwszSid, pFileDB->_pGroups);

        if (bFoundGroup)
        {
            m_iRedirectingGroup = iGroup;

            break;      //we have found a group, so break out of the loop
        }
        else
        {
            //restore the '=' sign, and try the next group
            pwszPath[-1] = L'='; //note: we had advanced the pointer above
        }

        iGroup++;
    }

    if (!bFoundGroup)
    {
        //no group was found, so treat this as a don't care
        m_dwFlags = REDIR_DONT_CARE;
    }
    else
    {
        //first store the sid
        if (m_pSid)
            delete [] ((BYTE*) m_pSid);     //m_pSid is always allocated from our heap, so never use RtlFreeSid

        m_pSid = NULL;

        if (!m_bRemove)
            Status = AllocateAndInitSidFromString (pwszSid, &Sid);
        else
            Status = AllocateAndInitSidFromString (L"S-1-1-0", &Sid);    //if this is a removed policy, we set the SID to Everyone -- so that when we look at the saved settings at a later time, we shouldn't have to process the policy again (see code for NeedsProcessing)

        if (ERROR_SUCCESS != Status)
            goto GatherInfoEnd;

        if (m_pSid)
            delete [] ((BYTE*) m_pSid);
        Status = MySidCopy (&m_pSid, Sid);  //we want to always allocate memory for this sid from our heap
        RtlFreeSid (Sid);   //cleanup. must take place before the following check

        if (ERROR_SUCCESS != Status)
            goto GatherInfoEnd;

        //we have found a group
        DebugMsg ((DM_VERBOSE, IDS_GROUP_MEMBER, pwszSid, pwszPath));
        SimplifyPath (pwszPath);
        
        //
        // Copy the location
        // Use X:\ for paths of the form X: to avoid problems during the file
        // copy phase.
        //
        BOOL bAppendSlash = FALSE;
        len = lstrlen (pwszPath);
        if (2 == len && L':' == pwszPath[1])
        {
            bAppendSlash = TRUE;
            len++;  // Ensure that the extra backslash at the end is accounted for in length calculations.
        }
        
        if (m_cbLocSize <= len)
        {    
            //we need to reallocate memory for the location
            if (m_cbLocSize)
                delete [] m_szLocation;

            m_cbLocSize = len + 1;  // Add one for the terminating null.
            m_szLocation = new TCHAR [m_cbLocSize];
            if (!m_szLocation)
            {
                m_cbLocSize = 0;
                goto GatherInfoErr;
            }
        }
        lstrcpy (m_szLocation, pwszPath);
        if (bAppendSlash)
            lstrcat (m_szLocation, L"\\");
    }


GatherInfoSuccess:
    DebugMsg ((DM_VERBOSE, IDS_COLLECT_REDIRINFO, m_szLocDisplayName, m_dwFlags));
    Status = STATUS_SUCCESS;
    goto GatherInfoEnd;

GatherInfoErr:
    Status = ERROR_OUTOFMEMORY;
    m_fDataValid = FALSE;
    m_dwFlags = REDIR_DONT_CARE;    //so that these settings will be ignored while merging into global data
    DebugMsg ((DM_VERBOSE, IDS_GATHER_FAILURE, Status, m_szLocDisplayName));

GatherInfoEnd:
    if (pwszSection)
        delete [] pwszSection;
    
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::WasRedirectionAttempted
//
//  Synopsis:   indicates whether redirection has already been attempted on
//              this folder.
//
//  Arguments:  none.
//
//  Returns:    a bool indicating the required status
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const BOOL CRedirectInfo::WasRedirectionAttempted (void)
{
    return m_bRedirectionAttempted;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetFlags
//
//  Synopsis:   returns the redirection flags for the folder represented by
//              this object
//
//  Arguments:  none
//
//  Returns:    the value of the flags
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const DWORD CRedirectInfo::GetFlags (void)
{
    return m_dwFlags;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetRedirStatus
//
//  Synopsis:   retrieves the return code of the redirection operation
//
//  Arguments:  none
//
//  Returns:    the member m_StatusRedir
//
//  History:    5/3/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const DWORD CRedirectInfo::GetRedirStatus (void)
{
    return m_StatusRedir;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetLocation
//
//  Synopsis:   returns the redirection location for the folder represented
//              by this object
//
//  Arguments:  none
//
//  Returns:    a pointer to the buffer containing the path
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
LPCTSTR CRedirectInfo::GetLocation (void)
{
    return m_szLocation;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetLocalizedName
//
//  Synopsis:   returns the localized name of the folder
//
//  Arguments:  none
//
//  Returns:    a pointer to the buffer containing the localized name
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
LPCTSTR CRedirectInfo::GetLocalizedName (void)
{
    return m_szLocDisplayName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::Redirect
//
//  Synopsis:   this function performs the actual redirection for the
//              folder represented by this object.
//
//  Arguments:  [in] hUserToken : handle to the user token
//              [in] hKeyRoot : handle to HKCU
//              [in] pFileDB : pointer to the CFileDB object from which this
//                             function was called.
//
//  Returns:    a DWORD indicating the success/failure code in redirection
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//           It is very important to record the return code in m_StatusRedir
//           before returning from this function. If we don't do that
//           we might end up returning the wrong value to the policy engine
//           while attempting to redirect special descendant folders which
//           can affect the list of policies obtained at a subsequent logon
//           session.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::Redirect (HANDLE   hUserToken,
                               HKEY     hKeyRoot,
                               CFileDB* pFileDB)
{
    SHARESTATUS SourceStatus = NoCSC;
    SHARESTATUS DestStatus = NoCSC;
    DWORD       PinStatus = ERROR_SUCCESS;
    WCHAR   *   wszProcessedPath = NULL;

    if (m_bRedirectionAttempted)
    {
        goto Redir_CleanupAndQuit;  //redirection has already been attempted
                                    //and the success / failure code has been
                                    //recorded in m_StatusRedir. Use the same
                                    //error code as the return value as this
                                    //value may not yet have been recorded in
                                    //ProcessGroupPolicy
    }

    //we shall now attempt to redirect...
    m_bRedirectionAttempted = TRUE;

    if (m_dwFlags & REDIR_FOLLOW_PARENT)
    {
        //this is possible only if UpdateDescendant ran out of memory
        //which means that we could not derive the folder's redirection
        //info. No point trying to log an event since we are out of memory
        //anyway. we just try to quit as gracefully as we can.
        m_StatusRedir = ERROR_OUTOFMEMORY;
        goto Redir_KillChildAndLeave;
    }

    WCHAR       wszExpandedNewPath [TARGETPATHLIMIT];
    WCHAR       wszExpandedCurrentPath [TARGETPATHLIMIT];
    WCHAR       wszHackedName [TARGETPATHLIMIT];
    WCHAR       wszExpandedSavedFolderPath [TARGETPATHLIMIT];
    WCHAR       wszExpandedNewFolderPath [TARGETPATHLIMIT];
    CSavedSettings * pLocalSettings;
    BOOL        bCurrentPathValid;  //indicates if we have been successful in obtaining the current path of the folder.
    UNICODE_STRING  Path;
    UNICODE_STRING  ExpandedPath;

    //set some defaults.
    m_StatusRedir = ERROR_SUCCESS;
    bCurrentPathValid = TRUE;

    //if the policy cares about the location of the folder, then we must
    //expand the path

    if (! (m_dwFlags & REDIR_DONT_CARE))
    {
        //show additional status messages if the verbose status is on.
        DisplayStatusMessage (IDS_REDIR_CALLBACK);

        if (!m_cbLocSize)
        {
            m_StatusRedir = ERROR_OUTOFMEMORY;
            //we had run out of memory so no point trying to log an event
            //we just quit as gracefully as we can.
            goto Redir_KillChildAndLeave;
        }

        if (m_bRemove)
        {
            wcscpy ( m_szLocation, L"%USERPROFILE%\\");
            wcscat ( m_szLocation, m_szLocFolderRelativePath);
        }

        // Get the expanded destination path.
        // First expand the homedir component, if applicable.
        m_StatusRedir = ExpandHomeDirPolicyPath (m_rID,
                                                 m_szLocation,
                                                 m_bFollowsParent,
                                                 &wszProcessedPath);
        if (ERROR_SUCCESS == m_StatusRedir)
        {
            Path.Length = (wcslen (wszProcessedPath) + 1) * sizeof (WCHAR);
            Path.MaximumLength = sizeof (wszProcessedPath);
            Path.Buffer = wszProcessedPath;

            ExpandedPath.Length = 0;
            ExpandedPath.MaximumLength = sizeof (wszExpandedNewFolderPath);
            ExpandedPath.Buffer = wszExpandedNewFolderPath;

            m_StatusRedir = RtlExpandEnvironmentStrings_U (
                               pFileDB->_pEnvBlock,
                               &Path,
                               &ExpandedPath,
                               NULL
                               );

            if (STATUS_BUFFER_TOO_SMALL == m_StatusRedir)
            {
                gpEvents->Report (
                        EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                        3,
                        m_szLocDisplayName,
                        m_szLocation,
                        NumberToString ( TARGETPATHLIMIT )
                        );

                goto Redir_KillChildAndLeave;
            }
        }

        if (ERROR_SUCCESS != m_StatusRedir)
        {
            DebugMsg ((DM_WARNING, IDS_REDIRECT_EXP_FAIL, m_szLocation, m_StatusRedir));
            gpEvents->Report (
                    EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                    2,
                    m_szLocDisplayName,
                    StatusToString ( m_StatusRedir )
                    );

            goto Redir_KillChildAndLeave;
        }
    }

    pLocalSettings = & (gSavedSettings[(int) m_rID]);

    if (pLocalSettings->m_dwFlags & REDIR_DONT_CARE)
    {
        if (m_dwFlags & REDIR_DONT_CARE)
        {
            pLocalSettings->Save (pLocalSettings->m_szCurrentPath, m_dwFlags, NULL, NULL);
            if (MyDocs == m_rID)
                RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);

            m_StatusRedir = ERROR_SUCCESS;
            goto Redir_CleanupAndQuit;
        }

        DebugMsg ((DM_VERBOSE, IDS_REDIRECT, m_szLocDisplayName, m_szLocation));

        //the policy cares about the location of this doc.

        //must get the correct syntax for GetLocalFilePath
        lstrcpy (wszHackedName, m_szFolderRelativePath);
        lstrcat (wszHackedName, L"\\");
        m_StatusRedir = pFileDB->GetLocalFilePath (wszHackedName, wszExpandedCurrentPath);

        //
        // Expand the homedir if necessary. Note: GetLocalFilePath will not
        // do it because it calls SHGetFolderPath and HOMESHARE and HOMEPATH
        // are not defined at that point.
        //
        if (ERROR_SUCCESS == m_StatusRedir)
        {
            m_StatusRedir = ExpandHomeDir (m_rID,
                                           wszExpandedCurrentPath,
                                           TRUE,
                                           &wszProcessedPath,
                                           pLocalSettings->m_bHomedirChanged ? pLocalSettings->m_szLastHomedir : NULL
                                          );
            if (ERROR_SUCCESS != m_StatusRedir ||
                ! wszProcessedPath ||
                TARGETPATHLIMIT <= lstrlen (wszProcessedPath))
            {
                m_StatusRedir = (ERROR_SUCCESS == m_StatusRedir) ? ERROR_BUFFER_OVERFLOW : m_StatusRedir;
            }
            else
            {
                lstrcpy (wszExpandedCurrentPath, wszProcessedPath);
            }
        }

        //GetLocalFilePath might fail if SHGetFolderPath fails. SHGetFolderPath
        //fails if the registry keys for the folder point to an invalid path and
        //there is nothing in the CSC cache for it either. So in this particular
        //case, we ignore the failure and treat it as a NO_MOVE. In NO_MOVE, we
        //do not require the current path of the folder.
        if ((ERROR_SUCCESS != m_StatusRedir) &&
            ERROR_INVALID_NAME != m_StatusRedir)    //the only possible error from GetLocalFilePath not generated by SHGetFolderPath
        {
            m_dwFlags &= ~REDIR_MOVE_CONTENTS;
            m_StatusRedir = ERROR_SUCCESS;
            bCurrentPathValid = FALSE;
            wcscpy (wszExpandedCurrentPath, L"???");    //if bCurrentPathValid is FALSE, this string will only be used in logs
        }

        if (m_StatusRedir != ERROR_SUCCESS)
        {
            DebugMsg ((DM_WARNING, IDS_REDIRECT_NO_LOCAL, m_szLocDisplayName, m_StatusRedir));
            gpEvents->Report (
                     EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                     2,
                     m_szLocDisplayName,
                     StatusToString ( m_StatusRedir )
                     );
            goto Redir_KillChildAndLeave;
        }

        //make sure that it is not already redirected
        if (bCurrentPathValid && (0 == _wcsicmp (wszExpandedCurrentPath, wszExpandedNewFolderPath)))
        {
            pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : NULL);
            if (MyDocs == m_rID)
                RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                           (m_bRemove || (m_dwFlags & REDIR_DONT_CARE))?FALSE:TRUE);

            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       wszExpandedNewFolderPath));
            //however, it is possible that the folders have not been pinned.
            //e.g. a roaming user who has already been redirected on one machine
            //and now logs on to another machine for the first time.
            DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
            if (ShareOnline == DestStatus)
            {

                PinStatus = PinIfNecessary (wszExpandedNewFolderPath, DestStatus);
                if ( ERROR_SUCCESS != PinStatus )
                    DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                              m_szLocDisplayName, PinStatus));

                CacheDesktopIni (wszExpandedNewFolderPath, DestStatus, PinFile);
            }
            m_StatusRedir = ERROR_SUCCESS;
            goto Redir_CleanupAndQuit;
        }

        if (g_bCSCEnabled)
        {
            SourceStatus = bCurrentPathValid ? GetCSCStatus (wszExpandedCurrentPath) : PathLocal;
            DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
            if (ShareOffline == DestStatus ||
                ((m_dwFlags & REDIR_MOVE_CONTENTS) && ShareOffline == SourceStatus))
            {
                m_StatusRedir = ERROR_CSCSHARE_OFFLINE;
                gpEvents->Report (
                        EVENT_FDEPLOY_FOLDER_OFFLINE,
                        3,
                        m_szLocDisplayName,
                        wszExpandedCurrentPath,
                        wszExpandedNewFolderPath
                        );
                goto Redir_KillChildAndLeave;
            }
        }

        DebugMsg (( DM_VERBOSE, IDS_REDIRECT_PREVPATH,
                    pLocalSettings->m_szCurrentPath,
                    wszExpandedCurrentPath));
        DebugMsg (( DM_VERBOSE, IDS_REDIRECT_NEWPATH, m_szLocation,
                    wszExpandedNewFolderPath));

        m_StatusRedir = PerformRedirection (
                           pFileDB,
                           bCurrentPathValid,
                           wszExpandedCurrentPath,
                           wszExpandedNewFolderPath,
                           SourceStatus,
                           DestStatus,
                           hUserToken
                           );

        if (ERROR_SUCCESS == m_StatusRedir)
        {
            if (m_bRemove)
            {
                if (MyDocs == m_rID)
                    RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);
                pLocalSettings->Save (m_szLocation, REDIR_DONT_CARE, NULL, NULL);
            }
            else
            {
                if (MyDocs == m_rID)
                    RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                               (m_dwFlags & REDIR_DONT_CARE) ? FALSE : TRUE);
                pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : 0);
            }
        }
        else if (m_pChild && m_pChild->m_bFollowsParent)  //if this is a parent whose redirection was unsuccessful, do not redirect the child if it is supposed to follow
        {
            PreventDescendantRedirection (m_StatusRedir);
        }

        goto Redir_CleanupAndQuit;
    }

    //if we are here, it means that the saved settings don't have the
    //REDIR_DONT_CARE flag set
    if (m_dwFlags & REDIR_DONT_CARE)
    {
        //the original settings cared about the location of the folder,
        //but now no one cares. So remove any redirection restrictions.
        if (MyDocs == m_rID)
            RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);

        pLocalSettings->Save (pLocalSettings->m_szCurrentPath, m_dwFlags, NULL, NULL);
        m_StatusRedir = ERROR_SUCCESS;
        goto Redir_CleanupAndQuit;
    }

    DebugMsg((DM_VERBOSE, IDS_REDIRECT, m_szLocDisplayName, m_szLocation));

    // This policy cares about where this folder goes.

    //
    // So first expand the homedir part if applicable
    // use the last value of homedir if the value of homedir has changed.
    //
    m_StatusRedir = ExpandHomeDir(m_rID,
                                  pLocalSettings->m_szLastRedirectedPath,
                                  TRUE,
                                  &wszProcessedPath,
                                  pLocalSettings->m_bHomedirChanged ? pLocalSettings->m_szLastHomedir : NULL);

    if (ERROR_SUCCESS == m_StatusRedir)
    {
        // Now first expand the saved path, we will use that for redirection
        Path.Length = (wcslen (wszProcessedPath) + 1) * sizeof (WCHAR);
        Path.MaximumLength = Path.Length;
        Path.Buffer = wszProcessedPath;

        ExpandedPath.Length = 0;
        ExpandedPath.MaximumLength = sizeof (wszExpandedSavedFolderPath);
        ExpandedPath.Buffer = wszExpandedSavedFolderPath;

        m_StatusRedir = RtlExpandEnvironmentStrings_U (
                                pFileDB->_pEnvBlock,
                                &Path,
                                &ExpandedPath,
                                NULL
                                );

        if (STATUS_BUFFER_TOO_SMALL == m_StatusRedir)
        {
            gpEvents->Report (
                    EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                    3,
                    m_szLocDisplayName,
                    pLocalSettings->m_szLastRedirectedPath,
                    NumberToString ( TARGETPATHLIMIT )
                    );

            goto Redir_KillChildAndLeave;
        }
    }

    if (ERROR_SUCCESS != m_StatusRedir)
    {
        DebugMsg ((DM_WARNING, IDS_REDIRECT_EXP_FAIL, pLocalSettings->m_szLastRedirectedPath, m_StatusRedir));
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                2,
                m_szLocDisplayName,
                StatusToString ( m_StatusRedir )
                );

        goto Redir_KillChildAndLeave;
    }

    //make sure that it is not already redirected to the location.
    if (0 == _wcsicmp (wszExpandedSavedFolderPath, wszExpandedNewFolderPath))
    {
        //the cached path and the path specified by the policy is the same
        //but someone may have messed with the registry, if that is the case
        //we use the path in the registry as the base path
        //must get the correct syntax for GetLocalFilePath
        lstrcpy (wszHackedName, m_szFolderRelativePath);
        lstrcat (wszHackedName, L"\\");
        m_StatusRedir = pFileDB->GetLocalFilePath (wszHackedName, wszExpandedCurrentPath);

        //
        // Expand the homedir if necessary. Note: GetLocalFilePath will not
        // do it because it calls SHGetFolderPath and HOMESHARE and HOMEPATH
        // are not defined at that point.
        //
        if (ERROR_SUCCESS == m_StatusRedir)
        {
            m_StatusRedir = ExpandHomeDir (m_rID,
                                           wszExpandedCurrentPath,
                                           TRUE,
                                           &wszProcessedPath,
                                           pLocalSettings->m_bHomedirChanged ? pLocalSettings->m_szLastHomedir : NULL
                                          );
            if (ERROR_SUCCESS != m_StatusRedir ||
                ! wszProcessedPath ||
                TARGETPATHLIMIT <= lstrlen (wszProcessedPath))
            {
                m_StatusRedir = (ERROR_SUCCESS == m_StatusRedir) ? ERROR_BUFFER_OVERFLOW : m_StatusRedir;
            }
            else
            {
                lstrcpy (wszExpandedCurrentPath, wszProcessedPath);
            }
        }

        //GetLocalFilePath may fail if SHGetFolderPath fails. This
        //would mean that the registry is messed up anyway. Also, move contents
        //no longer makes sense, since the path to which the reg. points to
        //is invalid or worse, the registry key is missing. also, it would
        //imply that there is nothing in the CSC cache
        if ((ERROR_SUCCESS != m_StatusRedir) &&
            ERROR_INVALID_NAME != m_StatusRedir)    //the only possible error from GetLocalFilePath not generated by SHGetFolderPath
        {
            m_StatusRedir = ERROR_SUCCESS;
            bCurrentPathValid = FALSE;
            m_dwFlags &= ~REDIR_MOVE_CONTENTS;
        }

        if (m_StatusRedir != ERROR_SUCCESS)
        {
            DebugMsg ((DM_WARNING, IDS_REDIRECT_NO_LOCAL, m_szLocDisplayName, m_StatusRedir));
            gpEvents->Report (
                     EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                     2,
                     m_szLocDisplayName,
                     StatusToString ( m_StatusRedir )
                     );
            goto Redir_KillChildAndLeave;
        }
        //we have found out the path stored in the registry, so compare it with
        //the saved path
        if (bCurrentPathValid && (0 == _wcsicmp (wszExpandedSavedFolderPath, wszExpandedCurrentPath)))
        {
            //all the paths are identical, so we are fine. save and quit
            pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : 0);
            if (MyDocs == m_rID)
                RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                           (m_bRemove || (m_dwFlags & REDIR_DONT_CARE))?FALSE:TRUE);

            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       wszExpandedNewFolderPath));
            //however, it is possible that the folders have not been pinned.
            //e.g. a roaming user who has already been redirected on one machine
            //and now logs on to another machine for the first time.
            DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
            if (ShareOnline == DestStatus)
            {

                PinStatus = PinIfNecessary (wszExpandedNewFolderPath, DestStatus);
                if ( ERROR_SUCCESS != PinStatus )
                    DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                              m_szLocDisplayName, PinStatus));

                CacheDesktopIni (wszExpandedNewFolderPath, DestStatus, PinFile);
            }
            m_StatusRedir = ERROR_SUCCESS;
            goto Redir_CleanupAndQuit;
        }
        else //somebody has been messing with the registry
        {
            //use the path in the registry as the source path
            //and perform redirection again
            if (bCurrentPathValid)
                wcscpy (wszExpandedSavedFolderPath, wszExpandedCurrentPath);
            else
                wcscpy(wszExpandedSavedFolderPath, L"???"); //to be on the safe side, since we don't want to use the saved path as the source for redirection
                                                               //if bCurrentPathValid is FALSE, this string will only be used in debug messages and error logs
        }
    }

    if (g_bCSCEnabled)
    {
        SourceStatus = bCurrentPathValid ? GetCSCStatus (wszExpandedSavedFolderPath) : PathLocal;
        DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
        if (ShareOffline == DestStatus ||
            ((m_dwFlags & REDIR_MOVE_CONTENTS) && ShareOffline == SourceStatus))
        {
            m_StatusRedir = ERROR_CSCSHARE_OFFLINE;
            gpEvents->Report (
                    EVENT_FDEPLOY_FOLDER_OFFLINE,
                    3,
                    m_szLocDisplayName,
                    wszExpandedSavedFolderPath,
                    wszExpandedNewFolderPath
                    );
            goto Redir_KillChildAndLeave;
        }
    }

    DebugMsg (( DM_VERBOSE, IDS_REDIRECT_PREVPATH,
                pLocalSettings->m_szLastRedirectedPath,
                wszExpandedSavedFolderPath));
    DebugMsg (( DM_VERBOSE, IDS_REDIRECT_NEWPATH, m_szLocation,
                wszExpandedNewFolderPath));


    m_StatusRedir = PerformRedirection (
                       pFileDB,
                       bCurrentPathValid,
                       wszExpandedSavedFolderPath,
                       wszExpandedNewFolderPath,
                       SourceStatus,
                       DestStatus,
                       hUserToken
                       );

    if (ERROR_SUCCESS == m_StatusRedir)
    {
        if (m_bRemove)
        {
            if (MyDocs == m_rID)
                RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);
            pLocalSettings->Save (m_szLocation, REDIR_DONT_CARE, NULL, NULL);
        }
        else
        {
            if (MyDocs == m_rID)
                RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                           (m_dwFlags & REDIR_DONT_CARE)?FALSE:TRUE);

            pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : 0);
        }
    }
    else if (m_pChild && m_pChild->m_bFollowsParent)  //if redirection was unsuccessful and this folder has children, prevent the redirection of the children if they are supposed to follow
    {
        PreventDescendantRedirection (m_StatusRedir);
    }

    goto Redir_CleanupAndQuit;

//the following code is executed whenever some fatal error occurs
//and we want to make sure that if this is a dir with a special
//descendant and the descendant is supposed to follow the parent,
//then we don't want to attempt redirection for the child.
Redir_KillChildAndLeave:
    if (ERROR_SUCCESS != m_StatusRedir &&
            (m_pChild && m_pChild->m_bFollowsParent))
        PreventDescendantRedirection (m_StatusRedir);

Redir_CleanupAndQuit:
    if (wszProcessedPath)
        delete [] wszProcessedPath;

    if ( ERROR_SUCCESS != m_StatusRedir )
    {
        HRESULT hrRsop;

        hrRsop = pFileDB->AddPreservedPolicy( (WCHAR*) m_szDisplayName );

        if ( FAILED( hrRsop ) )
        {
            pFileDB->GetRsopContext()->DisableRsop( hrRsop );
        }
    }

    return m_StatusRedir;
}
        
//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::ShouldSaveExpandedPath
//
//  Synopsis:   Determines whether we need to store the expanded path in the
//              registry or the unexpanded paths. See notes for additional
//              details.
//
//  Arguments:  none.
//
//  Returns:    TRUE : if the expanded path should be stored.
//              FALSE : otherwise.
//
//  History:    5/1/2001  RahulTh  created
//
//  Notes:
//      If the destination path is a homedir path, store the expanded path
//      in the registry so that if msgina is unable to set the homedir
//      variables and uses the local defaults instead, the shell doesn't 
//      end up thinking that MyDocs is local.
//
//      If the destination path is a different kind of path, then store the
//      expanded path if it has the %username% variable in it. Because if we
//      don't then when a user's UPN changes and the user logs on with the new
//      username, then the shell will expand the path using the new username.
//      Now, normally this won't be a problem because we would have already
//      done the rename operation. However, if for some reason we are
//      not successful in that rename operation (say because we are
//      invoked in limited foreground or because the server is offline)
//      then the rename will not succeed. In this case, the shell will
//      end up creating a new empty folder in that location whenever the
//      user tries to access it. So the next time the user logs on,
//      the new folder is already present and the rename fails with
//      ERROR_ALREADY_EXISTS and we just end up pointing to the new
//      location. The files stay in the old location. Therefore, we must
//      not use the unexpanded path in SHSetFolderPath. However, we must
//      store the unexpanded path in our local cache in order to
//      successfully detect UPN changes.
//
//      We do not want to store the expanded path unconditionally because
//      in situations where the user is going back to a local location,
//      especially the local userprofile location, we do not want to store
//      the expanded path because it is not device independent and will cause
//      problems for roaming users (e.g. a certain drive may not be available
//      on all the machines so we should keep the path as %userprofile%\...
//      rather than something like E:\Documents & Settings\...)
//
//---------------------------------------------------------------------------
BOOL CRedirectInfo::ShouldSaveExpandedPath(void)
{
    if (! m_szLocation || L'\0' == m_szLocation[0])
        return FALSE;
    
    // Detect the homedir case
    if (IsHomedirPolicyPath(m_rID, m_szLocation, TRUE))
        return TRUE;
    
    //
    // Check if the path contains the username variable.
    // If it does then we should store the expanded paths. However regardless
    // of everything else, if the path begins with %userprofile%, we should
    // never store the expanded path because we will never be guaranteed a
    // device independent path in that case and will run into all sorts of
    // problems.
    //
    _wcslwr (m_szLocation);
    // Compare the beginning of the two strings (the -1 is required to prevent comparing the terminating NULL)
    if (0 == wcsncmp (m_szLocation, L"%userprofile%", sizeof(L"%userprofile%")/sizeof(WCHAR) - 1))
        return FALSE;
    if (wcsstr (m_szLocation, L"%username%"))
        return TRUE;
    
    //
    // If we are here, we did not meet any of the conditions required for
    // storing the expanded paths. So we should just store the unexpanded paths
    //
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::PerformRedirection
//
//  Synopsis:   performs the nitty gritty of redirection including copying
//              files, updating the registry, logging events etc.
//
//  Arguments:  [in] pFileDB    : the CFileDB structure that is used throughout
//              [in] bSourceValid : if pwszSource contains a valid path
//              [in] pwszSource : source path
//              [in] pwszDest   : Destination path
//              [in] StatusFrom : CSC status of the source share
//              [in] StatusTo   : CSC status of the destination share
//
//  Returns:    ERROR_SUCCESS if everything was successful. An error code
//              otherwise.
//
//  History:    11/21/1998  RahulTh  created
//              12/13/2000  RahulTh  Special cased homedir redirection to
//                                   prevent security checks and store expanded
//                                   paths in the registry (see comments within the function)
//
//  Notes:      this functions expects both shares to be online when it is
//              invoked.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::PerformRedirection (CFileDB     *  pFileDB,
                                         BOOL           bSourceValid,
                                         WCHAR       *  pwszSource,
                                         WCHAR       *  pwszDest,
                                         SHARESTATUS    StatusFrom,
                                         SHARESTATUS    StatusTo,
                                         HANDLE         hUserToken
                                         )
{
    BOOL    bCheckOwner;
    BOOL    bMoveContents;
    BOOL    bIsHomeDirRedirection = FALSE;  // Tracks if this is a homedir redirection policy
    DWORD   Status;
    int     iResultCompare;
    WCHAR * pwszSkipSubdir;
    int     csidl;
    BOOL    bStatus;
    DWORD   PinStatus;
    HRESULT hResult = S_OK;
    CCopyFailData   CopyFailure;
    
    //
    // We need to track if this is a homedir redirection policy because
    // of 2 reasons:
    //      1) In homedir redirection, security checks are skipped.
    //      2) In homedir redirection, the expanded path is stored in the registry. This is 
    //          to prevent problems that might occur if the homedir variables cannot be
    //          set by msgina and end up pointing to the local userprofile. In this case,
    //          we do not want the shell to start pointing MyDocs to the local location.
    // 
    bIsHomeDirRedirection = IsHomedirPolicyPath(m_rID, m_szLocation, TRUE);
    
    csidl = pFileDB->RegValueCSIDLFromFolderName (m_szFolderRelativePath);

    // Skip security check for homedir redirection.
    bCheckOwner = ((m_dwFlags & REDIR_SETACLS) && (!bIsHomeDirRedirection)) ? TRUE : FALSE;
    bMoveContents = m_dwFlags & REDIR_MOVE_CONTENTS ? TRUE : FALSE;

    if (bSourceValid)
    {
        Status = ComparePaths (pwszSource, pwszDest, &iResultCompare);

        if (ERROR_SUCCESS != Status)
        {
            //this is very unlikely
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_FAIL,
                    4,
                    m_szLocDisplayName,
                    StatusToString (Status),
                    pwszSource,
                    pwszDest
                    );
            return Status;
        }

        if (0 == iResultCompare)
        {
            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       pwszDest));
            //however, it is possible that the folders have not been pinned.
            //e.g. a roaming user who has already been redirected on one machine
            //and now logs on to another machine for the first time.
            if (ShareOnline == StatusTo)
            {

                PinStatus = PinIfNecessary (pwszDest, StatusTo);
                if ( ERROR_SUCCESS != PinStatus )
                    DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                              m_szLocDisplayName, PinStatus));

                CacheDesktopIni (pwszDest, StatusTo, PinFile);
            }
            return ERROR_SUCCESS;
        }

        //it is okay to redirect to a path that is a descendant of the current
        //path if we are not moving contents
        if (bMoveContents && (-1 == iResultCompare))
        {
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_RECURSE,
                    4,
                    m_szLocDisplayName,
                    m_szLocation,
                    pwszSource,
                    pwszDest
                    );

            return ERROR_REQUEST_ABORTED;
        }
    }

    Status = pFileDB->CreateRedirectedFolderPath (pwszSource, pwszDest,
                                                  bSourceValid,
                                                  bCheckOwner, bMoveContents);

    if (ERROR_SUCCESS != Status)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_CREATE_FAIL,
                4,
                m_szLocDisplayName,
                StatusToString (Status),
                m_szLocation,
                pwszDest
                );
        return Status;
    }

    //now we know that both the source and destinations paths exist
    //so make sure that they are not the same path in different formats
    //this is an expensive function as it involves creation and deletion of
    //multiple files over the network. so we invoke it only if absolutely
    //necessary
    if (bSourceValid && bMoveContents)
    {
        Status = CheckIdenticalSpecial (pwszSource, pwszDest, &iResultCompare);

        if (ERROR_SUCCESS != Status)
        {
            //this is very unlikely...
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_FAIL,
                    4,
                    m_szLocDisplayName,
                    StatusToString (Status),
                    pwszSource,
                    pwszDest
                    );
            return Status;
        }

        if (0 == iResultCompare)
        {
            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       pwszDest));

            //
            // The paths are the same but in different formats (or perhaps
            // through different shares. So at least update the registry to
            // point to the new path.
            //
            hResult = SHSetFolderPath(csidl | CSIDL_FLAG_DONT_UNEXPAND,
                                      hUserToken,
                                      0,
                                      ShouldSaveExpandedPath() ? pwszDest : m_szLocation);
            Status = GetWin32ErrFromHResult (hResult);

            //
            // This basically should never fail.  But do we want to try to delete the
            // copied files if it does? Or the wacked CSC database?
            //
            if ( Status != ERROR_SUCCESS )
            {
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_REGSET_FAIL,
                        2,
                        m_szLocDisplayName,
                        StatusToString( Status ) );

                return Status;
            }
            else
            {
                //we were successul.
                //first, rename the local CSC cache.
                if (m_pChild)
                    pwszSkipSubdir = m_pChild->m_szLocDisplayName;
                else
                    pwszSkipSubdir = NULL;
                MoveDirInCSC (pwszSource, pwszDest, pwszSkipSubdir,
                              StatusFrom, StatusTo, TRUE, TRUE);
                if (g_bCSCEnabled && ShareOnline == StatusFrom)
                {
                    DeleteCSCFileTree (pwszSource, pwszSkipSubdir, TRUE);
                    DeleteCSCShareIfEmpty (pwszSource, StatusFrom);
                }

                //Also, it is possible that the folders have not been pinned.
                //e.g. a roaming user who has already been redirected on one
                //machine and now logs on to another machine for the first time.
                if (ShareOnline == StatusTo)
                {

                    PinStatus = PinIfNecessary (pwszDest, StatusTo);
                    if ( ERROR_SUCCESS != PinStatus )
                        DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                                  m_szLocDisplayName, PinStatus));

                    CacheDesktopIni (pwszDest, StatusTo, PinFile);
                }

                //report this event and return. there is
                //nothing more to be done here.
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_REDIRECT,
                        3,
                        m_szLocDisplayName,
                        bSourceValid ? pwszSource : L"???",
                        pwszDest );
                return ERROR_SUCCESS;
            }
        }
    }

    if (bSourceValid && bMoveContents)
    {
        DebugMsg ((DM_VERBOSE, IDS_REDIRECT_COPYON, m_szLocDisplayName));

        //
        // Exclude any special descendants when
        // doing file copies and deletes. Similarly for Programs and
        // Startup
        //

        if (m_pChild)
            pwszSkipSubdir = m_pChild->m_szLocDisplayName;
        else
            pwszSkipSubdir = NULL;

        Status = pFileDB->CopyFileTree( pwszSource,
                                        pwszDest,
                                        pwszSkipSubdir,
                                        StatusFrom,
                                        StatusTo,
                                        TRUE,
                                        &CopyFailure );

        //it is necessary to do the following for 2 reasons:
        //(a) the user may have dirty files in the cache. these don't get
        //    moved above.
        //(b) the files may have already been moved on the network by the
        //    the extension when the user logged on from another machine
        //    therefore, the cache on the second machine never gets updated
        //
        //we only try our best to move the files here. Errors are ignored.
        if (ERROR_SUCCESS == Status)
        {
            MoveDirInCSC (pwszSource, pwszDest,
                          pwszSkipSubdir,
                          StatusFrom, StatusTo, FALSE, TRUE);
        }
        else
        {
            //the copy failed. We might have failed halfway and left the cache
            //in an inconsistent state, so rollback all the cached entries
            MoveDirInCSC (pwszDest, pwszSource, pwszSkipSubdir,
                          StatusTo, StatusFrom, TRUE, TRUE);
        }



        if ( ERROR_SUCCESS != Status )
        {
            if (! CopyFailure.IsCopyFailure())
            {
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_MOVE_FAIL,
                        5,
                        m_szLocDisplayName,
                        StatusToString( Status ),
                        m_szLocation,
                        pwszSource,
                        pwszDest );
            }
            else
            {
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_COPY_FAIL,
                        7,
                        m_szLocDisplayName,
                        StatusToString( Status ),
                        m_szLocation,
                        pwszSource,
                        pwszDest,
                        CopyFailure.GetSourceName(),
                        CopyFailure.GetDestName() );
            }

            return Status;
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_REDIRECT_COPYOFF, m_szLocDisplayName));
    }

    //
    // Look at the comments for ShouldSaveExpandedPath() for details on why we
    // sometimes need to store expanded paths.
    //
    hResult = SHSetFolderPath(csidl | CSIDL_FLAG_DONT_UNEXPAND,
                              hUserToken,
                              0,
                              ShouldSaveExpandedPath() ? pwszDest : m_szLocation);
    Status = GetWin32ErrFromHResult (hResult);


    if ( Status != ERROR_SUCCESS )
    {
        gpEvents->Report(
                EVENT_FDEPLOY_FOLDER_REGSET_FAIL,
                2,
                m_szLocDisplayName,
                StatusToString( Status ) );

        return Status;
    }

    if (!m_bRemove)
    {
        //
        // hack to work around a shell problem.
        //
        // Pin the folder so that the shell never gets an error when
        // trying to resolve this path.  This will prevent it from
        // reverting to a temporary local path.
        //
        // For now just call pin/unpin APIs for any unc style path.  Not
        // really much value in checking first to see if the share is
        // cacheable.
        //

        if ( bSourceValid &&
             (L'\\' == pwszSource[0]) &&
             (L'\\' == pwszSource[1]) )
        {
            CSCUnpinFile( pwszSource,
                          FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                          NULL, NULL, NULL );
            CacheDesktopIni (pwszSource, StatusFrom, UnpinFile);
        }

        if ( (L'\\' == pwszDest[0]) &&
             (L'\\' == pwszDest[1]) )
        {
            PinStatus = PinIfNecessary (pwszDest, StatusTo);

            if ( ERROR_SUCCESS != PinStatus )
                DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                          m_szLocDisplayName, PinStatus));

            CacheDesktopIni (pwszDest, StatusTo, PinFile);
        }
    }

    //the contents were moved. now redirect any special children
    //this ensures that deletions (if any) in the child folders,
    //are performed first. thus deletion of this folder won't fail
    //due to existence of its children within it.
    //should not check for m_pChild->m_bFollowsParent here as
    //the child may currently lie under this folder and if we do
    //not perform the redirection of the child here, we might have
    //problems deleting this folder even when we should not have any
    //problems
    if (m_pChild)
    {
        Status = m_pChild->Redirect (pFileDB->_hUserToken,
                                     pFileDB->_hkRoot, pFileDB);

    }

    //note : contents of the source should not be deleted if this is a
    //       policy removal
    if ( bSourceValid && bMoveContents)
    {
        Status = ERROR_SUCCESS;

        //leave the contents on the server if this is a policy removal.
        //also leave the contents on the server when moving from
        //a network to a local location, so that subsequent redirections
        //from other workstations will get all the contents back to local.
        if (!m_bRemove && (!IsPathLocal(pwszDest) || IsPathLocal(pwszSource)))
        {
            //
            // This could fail because of ACLing.  We ignore any failures here.
            //
            DebugMsg((DM_VERBOSE, IDS_REDIRECT_DELETE,
                      m_szLocDisplayName, pwszSource));

            Status = pFileDB->DeleteFileTree( pwszSource,
                                                 pwszSkipSubdir
                                                );
            if ( ERROR_SUCCESS == Status )
            {
                //DeleteFileTree does not remove the top level node passed to it.
        // Delete the top level node only if it is not the user's home
        // directory
        const WCHAR * pwszHomeDir = NULL;
        DWORD dwHomeDirStatus = ERROR_SUCCESS;
        
        pwszHomeDir = gUserInfo.GetHomeDir(dwHomeDirStatus);
        
        if (NULL == pwszHomeDir || 0 != lstrcmpi (pwszHomeDir, pwszSource))
        {
            //clear the attributes before deleting.
            SetFileAttributes (pwszSource,
                       FILE_ATTRIBUTE_NORMAL);
            if ( ! RemoveDirectory( pwszSource ) )
            {
            Status = GetLastError();
            DebugMsg((DM_VERBOSE, IDS_DIRDEL_FAIL,
                  pwszSource, Status));
            }
        }
            }

            if ( Status != ERROR_SUCCESS )
                DebugMsg((DM_WARNING, IDS_REDIRECT_DEL_FAIL,
                          pwszSource, m_szLocDisplayName,
                          m_szLocation, Status));
        }

        //but we always clean up the CSC cache irrespective of whether it is a
        //policy removal or not because folder redirection should be as transparent
        //to the user as possible and it would be annoying for the user to get
        //CSC notifications for shares that are no longer used as redirection
        //targets.
        if (g_bCSCEnabled && ShareOnline == StatusFrom)
        {
            DeleteCSCFileTree (pwszSource, pwszSkipSubdir, TRUE);
            DeleteCSCShareIfEmpty (pwszSource, StatusFrom);
        }

    }

    gpEvents->Report(
            EVENT_FDEPLOY_FOLDER_REDIRECT,
            3,
            m_szLocDisplayName,
            bSourceValid ? pwszSource : L"???",
            pwszDest );

    return ERROR_SUCCESS;
}


//+--------------------------------------------------------------------------
//
//  Member:     PreventRedirection
//
//  Synopsis:   this function prevents the redirection code from attempting
//              redirection. Also prevents redirection of any of the child
//              folders.
//
//  Arguments:  [in] Status : the error code indicating the cause of failure.
//
//  Returns:    nothing. It will always succeed.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:      if the pre-processing step that handles the user name change
//              fails for some reason, this function is invoked so that
//              any attempt at applying simultaneous policy changes is thwarted
//
//---------------------------------------------------------------------------
void CRedirectInfo::PreventRedirection (DWORD Status)
{
    m_bRedirectionAttempted = TRUE;
    m_StatusRedir = Status;

    if (m_pChild)
        PreventDescendantRedirection (Status);

    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     PreventDescendantRedirection
//
//  Synopsis:   this function invalidates the data in the children so that
//              the client extension will not try to redirect them
//              this is necessary to prevent redirection of children if the
//              redirection of the parents failed.
//
//  Arguments:  [in] Status : the error code indicating the cause of failure
//
//  Returns:    nothing. it will always succeed.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirectInfo::PreventDescendantRedirection (DWORD Status)
{
    if (! m_pChild) //nothing to do if this is not a parent
        return;

    m_pChild->m_bRedirectionAttempted = TRUE;
    m_pChild->m_StatusRedir = Status;

    //disable Startup too if start menu failed.
    if (StartMenu == m_rID)
    {
        m_pChild->m_pChild->m_bRedirectionAttempted = TRUE;
        m_pChild->m_pChild->m_StatusRedir = Status;
    }

    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::UpdateDescendant
//
//  Synopsis:   fills up the internal variables of a descendant object
//              if it is supposed to follow the parent by using the
//              data stored in the parent object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirectInfo::UpdateDescendant (void)
{
    DWORD   len;
    WCHAR * szLoc = NULL;

    if (!m_pParent)     //this is not a special descendant
        goto UpdateEnd;

    if (!(m_dwFlags & REDIR_FOLLOW_PARENT))
        goto UpdateEnd; //nothing to do. this descendant is not supposed to follow the parent

    if (!m_pParent->m_fDataValid || (m_pParent->m_dwFlags & REDIR_DONT_CARE))
    {
        m_fDataValid = m_pParent->m_fDataValid;
        m_dwFlags = REDIR_DONT_CARE;
        goto UpdateEnd;
    }

    m_fDataValid = m_pParent->m_fDataValid;

    m_bFollowsParent = TRUE;

    //if we are here, policy has been specified for the parent
    len = lstrlen (m_szLocDisplayName) + lstrlen (m_pParent->m_szLocation) + 2;    //one extra for the backslash
    if (m_cbLocSize < len)
    {
        //we need to allocate memory
        szLoc = new WCHAR [len];
        if (!szLoc)
        {
            //out of memory. cannot derive info. from parent. will have to ignore this GPO
            DebugMsg((DM_VERBOSE, IDS_DERIVEINFO_ERROR, m_szLocDisplayName));
            m_dwFlags = REDIR_DONT_CARE;
            m_fDataValid = FALSE;
            goto UpdateEnd;
        }
        if (m_cbLocSize)
            delete [] m_szLocation;
        m_szLocation = szLoc;
        m_cbLocSize = len;
    }

    if (m_pSid)
        delete [] ((BYTE*) m_pSid);
    MySidCopy (&m_pSid, m_pParent->m_pSid);

    //copy the data
    //first get the settings
    m_dwFlags = m_pParent->m_dwFlags & (REDIR_SETACLS | REDIR_MOVE_CONTENTS | REDIR_RELOCATEONREMOVE);
    lstrcpy (m_szLocation, m_pParent->m_szLocation);
    len = lstrlen (m_szLocation);
    if (len > 0 && L'\\' != m_szLocation[len - 1])
        lstrcat (m_szLocation, L"\\");  //add a \ only if the parent's path is not
                                        //terminated with a \. Otherwise, we will
                                        //end up with 2 \ in the child's path which
                                        //will land SHGetFolderPath into trouble
                                        //after the redirection is done.
    lstrcat (m_szLocation, m_szLocDisplayName); //use the localized folder name
    m_bRemove = m_pParent->m_bRemove;

UpdateEnd:
    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::operator=
//
//  Synopsis:   overloaded assignment operator used for merging
//
//  Arguments:  standard
//
//  Returns:    standard
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:      DO NOT copy the values of m_bRedirectionAttempted and
//              m_StatusRedir in this function.
//
//---------------------------------------------------------------------------
CRedirectInfo& CRedirectInfo::operator= (const CRedirectInfo& ri)
{
    WCHAR * szLoc = 0;
    DWORD   Status;
    PSID    Sid;

    ASSERT (m_rID == ri.m_rID);

    if (!ri.m_fDataValid)
        goto AssignEnd;

    if ((ri.m_dwFlags & REDIR_FOLLOW_PARENT) && MyPics == m_rID)
    {
        m_fDataValid = ri.m_fDataValid;
        m_dwFlags = REDIR_FOLLOW_PARENT;
        m_bRemove = ri.m_bRemove;
        if (m_bValidGPO = ri.m_bValidGPO)   //note:this IS an assignment -- not a comparison
            wcscpy (m_szGPOName, ri.m_szGPOName);
        else
            m_szGPOName[0] = L'\0';

        goto AssignEnd;
    }
    else if ((ri.m_dwFlags & (REDIR_DONT_CARE | REDIR_FOLLOW_PARENT)))
    {
        //REDIR_FOLLOW_PARENT will be set only if UpdateDescendant ran out of memory
        //in any case, we will have to ignore the policy

        //note that we have to special case My Pics above because UpdateDescendant
        //is called for My Pics after all the policies have been looked at
        //thus it has not been called at this point yet.

        //the reason we call UpdateDescendant for My Pictures after looking at
        //all the policies because it is possible to specify "Follow My Docs"
        //in one policy and specify the location of My Docs in another policy
        if (!m_fDataValid)
        {
            m_fDataValid = ri.m_fDataValid;
            m_dwFlags = REDIR_DONT_CARE;
            m_bRemove = ri.m_bRemove;
            if (m_bValidGPO = ri.m_bValidGPO)   //note: this IS an assignment -- not a comparison
                wcscpy (m_szGPOName, ri.m_szGPOName);
            else
                m_szGPOName[0] = L'\0';
        }

        goto AssignEnd; //ignore. no policy settings for the GPO being merged.
    }

    //note: in the following code... before modifying any of the data
    //we must make sure that we can get memory for all of the members
    //if we fail for even one of them and we have already changed the rest
    //we can run into an inconsistent state. Therefore, we first allocate
    //all the required memory and then actually proceed with the copy.
    Sid = 0;
    Status = MySidCopy (&Sid, ri.m_pSid);
    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_MERGE_FAILURE, m_szLocDisplayName));
        goto AssignEnd;
    }

    if (m_cbLocSize < ri.m_cbLocSize)
    {
        szLoc = new WCHAR [ri.m_cbLocSize];
        if (!szLoc)
        {
            //we could not obtain memory to store the new path.
            //we will have to ignore this policy
            DebugMsg ((DM_VERBOSE, IDS_MERGE_FAILURE, m_szLocDisplayName));
            delete [] ((BYTE*) Sid);    //do not do this at the end. The same memory will be used by m_pSid.
            goto AssignEnd;
        }
        if (m_cbLocSize) delete [] m_szLocation;
        m_szLocation = szLoc;
        m_cbLocSize = ri.m_cbLocSize;
    }

    //now we have the required memory, so we won't fail.
    //fill in the data.
    if (m_pSid)
        delete [] ((BYTE*) m_pSid);
    m_pSid = Sid;
    lstrcpy (m_szLocation, ri.m_szLocation);
    m_dwFlags = ri.m_dwFlags & (REDIR_SETACLS | REDIR_MOVE_CONTENTS | REDIR_RELOCATEONREMOVE);
    m_bRemove = ri.m_bRemove;
    m_bFollowsParent = ri.m_bFollowsParent;
    m_fDataValid = ri.m_fDataValid;
    if (m_bValidGPO = ri.m_bValidGPO)   //note: this IS an assignment not a comparison
        wcscpy (m_szGPOName, ri.m_szGPOName);
    else
        m_szGPOName[0] = L'\0';

AssignEnd:
    return *this;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::ComputeEffectivePolicyRemoval
//
//  Synopsis:   tries to find out if the removal of a user from a group
//              has caused a particular policy to be effectively removed
//              for a particular user.
//
//  Arguments:  [pGPOList] : a list of GPOs still in effect for this user.
//                           if a GPO is effectively removed for this user, it
//                           has to figure in this list.
//              [pFileDB] : pointer to the file DB structure
//
//  Returns:
//
//  History:    2/18/1999  RahulTh  created
//
//  Notes:      this also detects cases where a user's group membership may
//              not have changed but the policy no longer specifies any
//              target for this group.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::ComputeEffectivePolicyRemoval (
                           PGROUP_POLICY_OBJECT pDeletedGPOList,
                           PGROUP_POLICY_OBJECT pChangedGPOList,
                           CFileDB * pFileDB)
{
    WCHAR                   pwszLocalPath[MAX_PATH];
    WCHAR *                 pwszLocalIniFile = NULL;
    PGROUP_POLICY_OBJECT    pGPO;
    WCHAR *                 pwszGPTIniFilePath = NULL;
    DWORD                   Length = 0;
    DWORD                   Status = ERROR_SUCCESS;
    BOOL                    bStatus;
    HANDLE                  hFind;
    WIN32_FIND_DATA         FindData;
    WCHAR                   pwszDefault[] = L"*";
    DWORD                   dwFlags;
    WCHAR *                 pwszReturnedString = NULL;
    DWORD                   Size = 0;
    UNICODE_STRING          StringW;
    DWORD                   i;
    PTOKEN_GROUPS           pGroups;
    WCHAR                   pwszSid[MAX_PATH];  //more than enough to store a sid.
    BOOL                    bGPOInChangedList = FALSE;

    //if the policy resultant is not set to DONT_CARE, it means that even if a
    //policy has been effectively removed due to a group change or removal of a
    //group from the advanced settings, some other policy has taken precedence
    //and as a result, the policy resultant should remain the way it is.
    if (! (m_dwFlags & REDIR_DONT_CARE))
    {
        Status = ERROR_SUCCESS;
        goto CmpEffPolRem_End;
    }

    //there is no valid GPO stored in the per user per machine cache.
    //so we cannot do much.
    if (!gSavedSettings[m_rID].m_bValidGPO)
    {
        Status = ERROR_SUCCESS;
        goto CmpEffPolRem_End;
    }

    //if the location of this folder was not specified by policy at last logon
    //a group change cannot result in an effective policy removal for this folder.
    if (gSavedSettings[m_rID].m_dwFlags & REDIR_DONT_CARE)
    {
        Status = ERROR_SUCCESS;
        goto CmpEffPolRem_End;
    }

    //if we are here, then the folder was last redirected through policy and now
    //either policy does not care, or a group change makes it seem so. If it is
    //the latter, then we have to compute effective policy removal. Also, it is
    //possible that the last policy application was a partial success and
    //therefore a GPO that got deleted did not show up in either the changed
    //GPO list or the deleted GPO list. We have to take into account that case
    //too.

    //first check if the GPO is present in the deleted GPO list.
    for (pGPO = pDeletedGPOList; pGPO; pGPO = pGPO->pNext)
    {
        if (0 == _wcsicmp (gSavedSettings[m_rID].m_szGPOName, pGPO->szGPOName))
            break;
    }

    if (!pGPO)
    {
        //if the policy isn't in the deleted GPO list, check if it is in the
        //changed GPO list. If it isn't then this is a GPO that got deleted but did
        //not show up in any of the lists because it never got fully applied.
        //if it is, then either this is actually a don't care situation or it
        //should be treated as policy removal because there was a group change.

        for (pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext)
        {
            if (0 == _wcsicmp (gSavedSettings[m_rID].m_szGPOName, pGPO->szGPOName))
                break;
        }

        if (NULL != pGPO)   //it is in the changed GPO list.
        {
            bGPOInChangedList = TRUE;
            //get the path to the ini file on the sysvol.
            Length = wcslen(pGPO->lpFileSysPath) + wcslen(GPT_SUBDIR) + wcslen (INIFILE_NAME) + 1;
            pwszGPTIniFilePath = (WCHAR *) alloca( Length * sizeof(WCHAR) );
            if ( ! pwszGPTIniFilePath )
            {
                Status = ERROR_OUTOFMEMORY;
                goto CmpEffPolRem_End;
            }
            wcscpy( pwszGPTIniFilePath, pGPO->lpFileSysPath );
            wcscat( pwszGPTIniFilePath, GPT_SUBDIR );
            wcscat( pwszGPTIniFilePath, INIFILE_NAME );
        }
    }


    //get the path to the locally cached copy of the ini file.
    Length = wcslen (pFileDB->_pwszLocalPath) + wcslen (gSavedSettings[m_rID].m_szGPOName) + 6;
    pwszLocalIniFile = (WCHAR *) alloca (Length * sizeof (WCHAR));
    if (!pwszLocalIniFile)
    {
        Status = ERROR_OUTOFMEMORY;
        goto CmpEffPolRem_End;
    }
    wcscpy( pwszLocalIniFile, pFileDB->_pwszLocalPath );
    wcscat( pwszLocalIniFile, L"\\" );
    wcscat( pwszLocalIniFile, gSavedSettings[m_rID].m_szGPOName );
    wcscat( pwszLocalIniFile, L".ini" );

    Status = ERROR_SUCCESS;
    bStatus = FALSE;
    if (bGPOInChangedList)
    {
        bStatus = CopyFile( pwszLocalIniFile, pwszGPTIniFilePath, FALSE );
    }
    if ( ! bStatus )    // Work off of the locally cached copy.
    {
        //try to use the cached version if any.
        hFind = FindFirstFile( pwszLocalIniFile, &FindData );
        if ( INVALID_HANDLE_VALUE != hFind )
        {
            Status = ERROR_SUCCESS;
            FindClose( hFind );
        }
        else
        {
            Status = GetLastError();
        }
    }

    //we don't have an ini file to work with, so we can't do much but quit.
    if (ERROR_SUCCESS != Status)
        goto CmpEffPolRem_End;

    //now we have an ini file. so read the relevant info. from it.
    //first grab the flags
    Status = SafeGetPrivateProfileStringW (
                  L"FolderStatus",
                  m_szDisplayName,
                  pwszDefault,
                  &pwszReturnedString,
                  &Size,
                  pwszLocalIniFile
                  );

    if (ERROR_SUCCESS != Status)
        goto CmpEffPolRem_End;

    if (L'*' == *pwszReturnedString)
    {
        //there are no settings for this folder. Possibly because
        //someone changed the settings on the server.
        //Treat it as a don't care.
        goto CmpEffPolRem_End;
    }

    //now grab the hex flags
    StringW.Buffer = pwszReturnedString;
    StringW.Length = wcslen (pwszReturnedString) * sizeof (WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof(WCHAR);
    RtlUnicodeStringToInteger( &StringW, 16, &dwFlags );

    //if this is a special descendant folder and it is supposed to follow
    //the parent, we might first have to derive its settings from the
    //parent and then proceed.
    if (m_pParent && (dwFlags & REDIR_FOLLOW_PARENT))
    {
        //the check for m_pParent is redundant since non-descendant folders
        //can never have this flag. but this has been added as a safety mechanism
        //against ini file corruption
        //we will have to derive the settings from the parent later on.
        m_dwFlags = REDIR_FOLLOW_PARENT;
        m_fDataValid = TRUE;
        m_bFollowsParent = TRUE;
        m_bRemove = TRUE;
        m_bValidGPO = FALSE;    //since this is a removal
        m_szGPOName[0] = L'\0';
        UpdateDescendant(); //derive the settings from the parent
        goto CmpEffPolRem_End;
    }

    if ((dwFlags & REDIR_DONT_CARE) ||
        (m_bFollowsParent && (m_dwFlags & REDIR_DONT_CARE)))
    {
        //the policy has been changed to Don't Care. so it is not a removal.
        //leave everything as is.
        goto CmpEffPolRem_End;
    }

    if (!(dwFlags & REDIR_RELOCATEONREMOVE))
    {
        //the choice is to orphan. so let it stay as don't care.
        goto CmpEffPolRem_End;
    }
    
    //
    // If the GPO that was used for redirection the last time is not in the
    // changed GPO list, then this is surely a policy removal.
    // otherwise, it can either be a policy removal due to a group change (or
    // a group's policy getting removed from the GPO or it can be just that
    // the policy was changed to Don't care.
    //
    if (bGPOInChangedList)
    {
        //
        // Check if the user is still a member of the group that was used for
        // redirection.
        //
        pGroups = pFileDB->_pGroups;
        for (i = 0, bStatus = FALSE;
             i < pGroups->GroupCount && !bStatus;
             i++
            )
        {
            bStatus = RtlEqualSid (gSavedSettings[m_rID].m_psid, pGroups->Groups[i].Sid);
        }

        if (bStatus)    //the user still belongs to that group.
        {
            //so perhaps the policy for this group was removed.
            //make sure that this is the case.
            Status = ERROR_INVALID_SID;
            if (gSavedSettings[m_rID].m_psid)
            {
                pwszSid [0] = L'\0';
                StringW.Length = 0;
                StringW.MaximumLength = sizeof (pwszSid);
                StringW.Buffer = pwszSid;
                Status = RtlConvertSidToUnicodeString (&StringW, gSavedSettings[m_rID].m_psid, FALSE);
            }

            if (ERROR_SUCCESS != Status)
                goto CmpEffPolRem_End;

            Status = SafeGetPrivateProfileStringW (
                          m_szDisplayName,
                          StringW.Buffer,
                          pwszDefault,
                          &pwszReturnedString,
                          &Size,
                          pwszLocalIniFile
                          );

            if (ERROR_SUCCESS != Status)
                goto CmpEffPolRem_End;

            if (0 != _wcsicmp(pwszReturnedString, pwszDefault))
            {
                //
                // Policy exists for this folder so leave things the way they are.
                // Ideally this is not possible and one should never enter this
                // code path
                //
                goto CmpEffPolRem_End;
            }
        }
    }

    //
    // If the user is no longer a member of the group, then this is clearly
    // a case where the policy is effectively removed because the user was
    // removed from a group that was used for redirection.
    //
    // At any rate, if we are here, then this is a policy removal so make the
    // appropriate settings
    //
    if (m_cbLocSize && (m_cbLocSize < (Size = wcslen(L"%USERPROFILE%\\") + wcslen(m_szLocFolderRelativePath) + 1)))
    {
        delete [] m_szLocation;
        m_cbLocSize = 0;
        m_szLocation = new WCHAR [Size];
        if (!m_szLocation)
        {
            Status = ERROR_OUTOFMEMORY;
            goto CmpEffPolRem_End;
        }
        m_cbLocSize = Size;
    }
    wcscpy (m_szLocation, L"%USERPROFILE%\\");
    wcscat (m_szLocation, m_szLocFolderRelativePath);
    m_fDataValid = TRUE;
    m_dwFlags = dwFlags;
    m_bRemove = TRUE;
    m_bValidGPO = FALSE;    //since this is a removal.
    m_szGPOName[0] = '\0';
    DebugMsg((DM_VERBOSE, IDS_EFFECTIVE_REMOVE_POLICY, pGPO?pGPO->lpDisplayName:gSavedSettings[m_rID].m_szGPOName, m_szLocDisplayName));

CmpEffPolRem_End:
    if (pwszReturnedString)
        delete [] pwszReturnedString;
    return Status;
}

CRedirectInfo::HasPolicy()
{
    return ! ( m_dwFlags & REDIR_DONT_CARE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\filedb.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  filedb.cxx
//
//*************************************************************

#include "fdeploy.hxx"

#define SAVED_SETTINGS_FILE     L"{25537BA6-77A8-11D2-9B6C-0000F8080861}.ini"

HRESULT RsopSidsFromToken(PRSOPTOKEN     pRsopToken,
                          PTOKEN_GROUPS* ppGroups);

FOLDERINFO gUserShellFolders[] =
{
  {CSIDL_APPDATA, 17, L"Application Data\\", L"AppData"},
  // {CSIDL_COOKIES, 8, L"Cookies\\", L"Cookies"},
  {CSIDL_DESKTOPDIRECTORY, 8, L"Desktop\\", L"Desktop"},
  {CSIDL_FAVORITES, 10, L"Favorites\\", L"Favorites"},
  // {CSIDL_HISTORY, 8, L"History\\", L"History"},
  // {0, 15, L"Local Settings\\", NULL}, Has no reg key, no CSIDL
  {CSIDL_MYPICTURES, 25, L"My Documents\\My Pictures\\", L"My Pictures"},
  {CSIDL_PERSONAL, 13, L"My Documents\\", L"Personal"},
  {CSIDL_NETHOOD, 8, L"NetHood\\", L"NetHood"},
  {CSIDL_PRINTHOOD, 10, L"PrintHood\\", L"PrintHood"},
  // {CSIDL_RECENT, 7, L"Recent\\", L"Recent"},
  {CSIDL_SENDTO,  7, L"SendTo\\", L"SendTo"},
  {CSIDL_STARTUP, 28, L"Start Menu\\Programs\\Startup\\", L"Startup"},
  {CSIDL_PROGRAMS, 20, L"Start Menu\\Programs\\", L"Programs"},
  {CSIDL_STARTMENU, 11, L"Start Menu\\", L"Start Menu"},
  {CSIDL_TEMPLATES, 10, L"Templates\\", L"Templates"},
  // {CSIDL_INTERNET_CACHE, 25, L"Temporary Internet Files\\", L"Cache"},
  {0, 0, NULL, NULL }
};

FOLDERINFO gMachineShellFolders[] =
{
  {CSIDL_COMMON_APPDATA, 17, L"Application Data\\", L"Common AppData"},
  {CSIDL_COMMON_DESKTOPDIRECTORY, 8, L"Desktop\\", L"Common Desktop"},
  // {0, 10, L"Documents\\", L"Common Documents\\"}, No shell support
  {CSIDL_COMMON_STARTUP, 28, L"Start Menu\\Programs\\Startup\\", L"Common Startup"},
  {CSIDL_COMMON_PROGRAMS, 20, L"Start Menu\\Programs\\", L"Common Programs"},
  {CSIDL_COMMON_STARTMENU, 11, L"Start Menu\\", L"Common Start Menu"},
  {0, 0, NULL, NULL }
};

static DWORD gSchema = 1;

CFileDB::CFileDB()
{
    _hUserToken = 0;
    _hkRoot = 0;
    _pEnvBlock = 0;
    _pGroups = 0;
    _pwszProfilePath = 0;
    _pwszGPTPath = 0;
    _GPTPathLen = 0;
    _pwszIniFilePath = 0;
    _IniFileLen = 0;
    _pwszGPOName = 0;
    _pwszGPOUniqueName = 0;
    _pwszGPOSOMPath = 0;
    _pRsopContext = 0;
}

CFileDB::~CFileDB()
{
    if ( _pEnvBlock )
        DestroyEnvironmentBlock( _pEnvBlock );
    if (_pwszProfilePath)
        delete _pwszProfilePath;
    if (_pwszGPTPath)
        delete _pwszGPTPath;
    if (_pwszIniFilePath)
        delete _pwszIniFilePath;

    //
    // Note that _pGroups must be freed with LocalFree --
    // we are able to free it with delete because we
    // have redefined delete to be LocalFree
    //
    if (_pGroups)
        delete (BYTE*) _pGroups;

    // _pwszGPOName is not allocated
    // _pwszGPOUniqueName is not allocated
    // _pwszGPODSPath is not allocated
}

DWORD CFileDB::Initialize (
    HANDLE        hUserToken,
    HKEY          hkRoot,
    CRsopContext* pRsopContext)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    ULONG   Size;
    int     CSidl;
    WCHAR * pwszSlash;
    HRESULT hr;
    HANDLE  hFind;
    WIN32_FIND_DATA FindData;

    //set the token
    _hUserToken = hUserToken;

    //set the root key
    _hkRoot = hkRoot;

    // set the rsop logging context
    _pRsopContext = pRsopContext;

    //create an environment block for the user. we need this for expanding
    //variables.
    if (! _pEnvBlock)
    {
        if (!CreateEnvironmentBlock ( &_pEnvBlock, _hUserToken, FALSE))
        {
            Status = GetLastError();
            goto InitializeEnd;
        }
    }

    //get the list of group to which the user belongs
    _pGroups = 0;
    Size = 0;

    //
    // We may only use the Nt security subsystem api below
    // to retrieve groups when we are not in planning mode
    //
    for (; ! _pRsopContext->IsPlanningModeEnabled() ;)
    {
        Status = NtQueryInformationToken(
                     _hUserToken,
                     TokenGroups,
                     _pGroups,
                     Size,
                     &Size );

        if ( STATUS_BUFFER_TOO_SMALL == Status )
        {
            _pGroups = (PTOKEN_GROUPS) new BYTE [ Size ];
            if ( ! _pGroups )
                break;

            continue;
        }

        if ( Status != STATUS_SUCCESS )
        {
            if (_pGroups)
                delete [] ((BYTE*) _pGroups);
            _pGroups = 0;
        }

        break;
    }

    //
    // In planning mode, we get our security groups from
    // the policy engine's simulated token, not from a real token
    //
    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        DWORD        cbSize;
        PRSOP_TARGET pRsopTarget;
        HRESULT      hr;

        pRsopTarget = _pRsopContext->_pRsopTarget;

        //
        // The call below uses RSoP's planning mode "simulated"
        // security subsystem to retrieve the sids from the simulated
        // token.  The function allocates memory in _pGroups that
        // must be freed with LocalFree.
        //
        hr = RsopSidsFromToken(pRsopTarget->pRsopToken, &_pGroups);

        Status = HRESULT_CODE(hr);
    }


    if (ERROR_SUCCESS != Status)
        goto InitializeEnd;

    //
    // Retrieve the local path -- note that we do not need this in planning mode
    //

    if ( ! _pRsopContext->IsPlanningModeEnabled() )
    {
        //get the path to our directory under Local Settings.
        CSidl = CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE;

        hr = SHGetFolderPath( NULL, CSidl, _hUserToken, 0, _pwszLocalPath );

        if ( hr != S_OK )
        {
            //try to get the last error.
            if (FACILITY_WIN32 == HRESULT_FACILITY (hr))
            {
                Status = HRESULT_CODE(hr);
            }
            else
            {
                Status = GetLastError();
                if (ERROR_SUCCESS == Status)
                {
                    //an error had occurred but nobody called SetLastError
                    //should not be mistaken as a success.
                    Status = (DWORD) hr;
                }
            }
            DebugMsg((DM_WARNING, IDS_NO_LOCALAPPDATA, Status));
            goto InitializeEnd;
        }

        pwszSlash = _pwszLocalPath + wcslen( _pwszLocalPath );
        wcscat( _pwszLocalPath, L"\\Microsoft\\Windows\\File Deployment" );

        Status = ERROR_SUCCESS;
        //now create directories as necessary
        // Quick check to see if we have necessary local dirs.
        hFind = FindFirstFile( _pwszLocalPath, &FindData );

        if ( INVALID_HANDLE_VALUE == hFind )
        {
            do
            {
                pwszSlash = wcschr( &pwszSlash[1], L'\\' );

                if ( pwszSlash )
                    *pwszSlash = 0;

                bStatus = CreateDirectory( _pwszLocalPath, NULL );
                if ( ! bStatus && (GetLastError() != ERROR_ALREADY_EXISTS) )
                {
                    Status = GetLastError();
                    break;
                }

                if ( pwszSlash )
                    *pwszSlash = L'\\';
            } while ( pwszSlash );
        }
        else
        {
            FindClose( hFind );
        }
    }


InitializeEnd:
    return Status;
}


DWORD
CFileDB::Process(
    PGROUP_POLICY_OBJECT pGPO,
    BOOL    bRemove
    )
{
    WCHAR * pwszGPTIniFilePath;
    DWORD   Length;
    DWORD   Status;
    DWORD   ProcessStatus;
    BOOL    bStatus;
    BOOL    bPolicyApplied;
    HANDLE  hFind;
    WIN32_FIND_DATA FindData;

    if ( bRemove && _pRsopContext->IsPlanningModeEnabled() )
    {
        return ERROR_INVALID_PARAMETER;
    }

    bPolicyApplied = FALSE;
    Status = ERROR_SUCCESS;

    //first initialize the variables that vary with policies
    _bRemove = bRemove;
    if ( ! _bRemove )
    {
        Length = wcslen(pGPO->lpFileSysPath) + wcslen(GPT_SUBDIR) + 1;
        if (Length > _GPTPathLen)
        {
            //we need more memory than has been allocated.
            //so get that before proceeding
            if (_pwszGPTPath)
                delete _pwszGPTPath;
            _GPTPathLen = 0;    //make sure that this always reflects the correct value
            _pwszGPTPath = new WCHAR [Length];
            if ( ! _pwszGPTPath )
            {
                Status = ERROR_OUTOFMEMORY;
                goto ProcessEnd;
            }
            _GPTPathLen = Length;   //make sure that this always reflects the correct value
        }

        wcscpy( _pwszGPTPath, pGPO->lpFileSysPath );
        wcscat( _pwszGPTPath, GPT_SUBDIR );

        Length += wcslen( INIFILE_NAME );
        pwszGPTIniFilePath = (WCHAR *) alloca( Length * sizeof(WCHAR) );
        if ( ! pwszGPTIniFilePath )
        {
            Status = ERROR_OUTOFMEMORY;
            goto ProcessEnd;
        }

        wcscpy( pwszGPTIniFilePath, _pwszGPTPath );
        wcscat( pwszGPTIniFilePath, INIFILE_NAME );

        //
        // Do a quick check to see if we have any file deployment
        // for this policy.
        //
        hFind = FindFirstFile( pwszGPTIniFilePath, &FindData );

        if ( INVALID_HANDLE_VALUE == hFind )
        {
            Status = GetLastError();
            goto ProcessEnd;
        }
        else
        {
            bPolicyApplied = TRUE;
            DebugMsg((DM_VERBOSE, IDS_HASADD_POLICY, pGPO->lpDisplayName));
            FindClose( hFind );
        }
    }

    Status = ERROR_SUCCESS;

    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        Length = wcslen( pwszGPTIniFilePath ) + 1;
    }
    else
    {
        Length = wcslen( _pwszLocalPath ) + wcslen( pGPO->szGPOName ) + 6;
    }

    if (Length > _IniFileLen)
    {
        //we need more memory than has been allocated
        if (_pwszIniFilePath)
            delete _pwszIniFilePath;
        _IniFileLen = 0;    //make sure that this always reflects the current value
        _pwszIniFilePath = new WCHAR[Length];
        if ( ! _pwszIniFilePath )
        {
            Status = ERROR_OUTOFMEMORY;
            goto ProcessEnd;
        }
        _IniFileLen = Length;   //make sure that this always reflects the current value
    }

    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        wcscpy( _pwszIniFilePath, pwszGPTIniFilePath );
    }
    else
    {
        wcscpy( _pwszIniFilePath, _pwszLocalPath );
        wcscat( _pwszIniFilePath, L"\\" );
        wcscat( _pwszIniFilePath, pGPO->szGPOName );
        wcscat( _pwszIniFilePath, L".ini" );
    }

    if ( _bRemove )
    {
        hFind = FindFirstFile( _pwszIniFilePath, &FindData );

        if ( INVALID_HANDLE_VALUE == hFind )
        {
            //this error should be ignored since there is nothing we can do.
            //the policy has been deleted and the local settings are missing
            //so we have no choice but to treat these as if the settings were
            //to orphan the folder upon policy removal.
            goto ProcessEnd;
        }
        else
        {
            bPolicyApplied = TRUE;
            DebugMsg((DM_VERBOSE, IDS_HASREMOVE_POLICY, pGPO->lpDisplayName));
            FindClose( hFind );
        }
    }
    else if ( ! _pRsopContext->IsPlanningModeEnabled() )
    {
        bStatus = CopyFile( pwszGPTIniFilePath, _pwszIniFilePath, FALSE );
        if ( ! bStatus )
            Status = GetLastError();
    }

    if ( Status != ERROR_SUCCESS )
        goto ProcessEnd;

    _pwszGPOName = (WCHAR *) pGPO->lpDisplayName;
    _pwszGPOUniqueName = (WCHAR *) pGPO->szGPOName;
    _pwszGPOSOMPath = ( WCHAR *) pGPO->lpLink;
    _pwszGPODSPath = ( WCHAR *) pGPO->lpDSPath;

    ProcessStatus = ProcessRedirects();

    if ( (ProcessStatus != ERROR_SUCCESS) && (ERROR_SUCCESS == Status) )
        Status = ProcessStatus;

ProcessEnd:

    if ( Status != ERROR_SUCCESS )
    {
        gpEvents->Report (
                   EVENT_FDEPLOY_POLICYPROCESS_FAIL,
                   2,
                   pGPO->lpDisplayName,
                   StatusToString (Status)
                   );
    }
    else if ( bPolicyApplied )
    {
        DebugMsg((DM_VERBOSE, IDS_PROCESS_GATHER_OK, pGPO->lpDisplayName));
    }

    return Status;
}


DWORD
CFileDB::ProcessRedirects(void)
{
    WCHAR *         pwszString = 0;
    WCHAR *         pwszSectionStrings = 0;
    WCHAR *         pwszRedirection = 0;
    WCHAR           wszFolderName[80];
    UNICODE_STRING  String;
    DWORD           Flags;
    DWORD           RedirectStatus;
    DWORD           Status;
    BOOL            bStatus;
    REDIRECTABLE    index;
    DWORD           RedirStatus;
    CRedirectInfo   riPolicy [(int) EndRedirectable];   //the redirection info. for this policy
    DWORD           i;

    //first load the localized folder names
    for (i = 0, Status = ERROR_SUCCESS; i < (DWORD)EndRedirectable; i++)
    {
        Status = riPolicy[i].LoadLocalizedNames();
        if (ERROR_SUCCESS != Status)
            return Status;  //bail out if the resource names cannot be loaded.
    }

    pwszSectionStrings = 0;

    bStatus = ReadIniSection( L"FolderStatus", &pwszSectionStrings );

    if ( ! bStatus )
    {
        Status = ERROR_OUTOFMEMORY;
        goto ProcessRedirectsEnd;
    }

    Status = ERROR_SUCCESS;

    for ( pwszString = pwszSectionStrings;
          *pwszString != 0;
          pwszString += lstrlen(pwszString) + 1 )
    {
        //
        // The syntax for each line is :
        //   foldername=FLAGS
        //

        //
        // First extract the foldername.
        //

        pwszRedirection = wcschr( pwszString, L'=' );
        *pwszRedirection = 0;
        wcscpy( wszFolderName, pwszString );
        *pwszRedirection++ = L'=';

        //
        // Now grab the hex FLAGS.
        //

        String.Buffer = pwszRedirection;

        pwszRedirection = wcschr( pwszRedirection, L' ' );
        if ( pwszRedirection )
            *pwszRedirection = 0;

        String.Length = wcslen( String.Buffer ) * sizeof(WCHAR);
        String.MaximumLength = String.Length + sizeof(WCHAR);

        RtlUnicodeStringToInteger( &String, 16, &Flags );

        //just gather the information here.
        //actual redirections are performed in ProcessGPO after all the policies
        //have been processed.
        if (EndRedirectable ==
            (index = CRedirectInfo::GetFolderIndex (wszFolderName)))
        {
            //redirection of this folder is not supported
            DebugMsg ((DM_VERBOSE, IDS_REDIR_NOTSUPPORTED, wszFolderName));
        }
        else
        {
            //if this is a policy that has been removed and it was decided to
            //orphan the contents, we don't even look at it
            if (!_bRemove || (Flags & (REDIR_RELOCATEONREMOVE | REDIR_FOLLOW_PARENT)))
            {
                //if there is a problem in gathering redirection info. for a folder
                //quit immediately, or we might end up computing an incorrect
                //resultant policy
                if (ERROR_SUCCESS != (Status = riPolicy [(int) index].GatherRedirectionInfo (this, Flags, _bRemove)))
                    goto ProcessRedirectsEnd;
            }
        }
    }

    Status = ERROR_SUCCESS;

    //now update the data stored in the descendant objects
    //this is required because if the descendants follow the parent
    //then the settings need to be obtained from the parent
    //note that we do not call UpdateDescendant for MyPics here, but in fdeploy.cxx
    //for details on why we do this, look at comments in operator= in redir.cxx
    riPolicy[(int) Programs].UpdateDescendant();
    riPolicy[(int) Startup].UpdateDescendant(); //this call must be made after Programs has been updated

    //merge info into the global redirection store
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        if (_bRemove)
            gDeletedPolicyResultant[i] = riPolicy[i];
        else
            gAddedPolicyResultant[i] = riPolicy[i];
    }

ProcessRedirectsEnd:
    delete pwszSectionStrings;

    if ( ERROR_SUCCESS != Status )
    {
        DebugMsg((DM_VERBOSE, IDS_PROCESSREDIRECTS, Status));
    }
    else
    {
        if ( ! _bRemove && _pRsopContext->IsRsopEnabled() )
        {
            (void) AddRedirectionPolicies(
                this,
                riPolicy);
        }
    }

    return Status;
}


BOOL
CFileDB::ReadIniSection(
    WCHAR *     pwszSectionName,
    WCHAR **    ppwszStrings,
    DWORD *     pcchLen
    )
{
    DWORD   Length;
    DWORD   ReturnLength;

    *ppwszStrings = 0;
    Length = 256;

    for (;;)
    {
        delete *ppwszStrings;
        *ppwszStrings = new WCHAR[Length];

        if ( ! *ppwszStrings )
            return FALSE;

        ReturnLength = GetPrivateProfileSection(
                            pwszSectionName,
                            *ppwszStrings,
                            Length,
                            _pwszIniFilePath );

        if ( ReturnLength != (Length - 2) )
        {
            if (pcchLen)
            {
                *pcchLen = ReturnLength;
            }

            return TRUE;
        }

        Length *= 2;
    }
}

DWORD
CFileDB::GetLocalFilePath(
    WCHAR *         pwszFolderPath,
    WCHAR *         wszFullPath
    )
{
    int CSidl;
    DWORD Status;
    HRESULT hr;
    WCHAR * pwszFolderName;

    CSidl = CSIDL_FLAG_MASK;    //use a value that is not a valid CSIDL value for any folder.

    for (DWORD n = 0; gUserShellFolders[n].FolderName; n++)
    {
        if (0 == _wcsicmp (pwszFolderPath, gUserShellFolders[n].FolderName))
        {
            pwszFolderName = gUserShellFolders[n].FolderName;
            CSidl = gUserShellFolders[n].CSidl;
            break;
        }
    }

    if ( CSIDL_FLAG_MASK != CSidl )
    {
        hr = SHGetFolderPath( 0, CSidl | CSIDL_FLAG_DONT_VERIFY,
                              _hUserToken, 0, wszFullPath );
        Status = GetWin32ErrFromHResult (hr);

        if ( ERROR_SUCCESS != Status )
        {
            DebugMsg((DM_WARNING, IDS_FOLDERPATH_FAIL, pwszFolderName, Status));
            return Status;
        }
    }
    else
        return ERROR_INVALID_NAME;

    return ERROR_SUCCESS;
}

DWORD
CFileDB::GetPathFromFolderName(
    WCHAR *     pwszFolderName,
    WCHAR *     wszFullPath
    )
{
    int CSidl;
    DWORD Status;
    HRESULT hr;

    CSidl = CSIDL_FLAG_MASK;    //use a csidl value that is not valid for any folder

    for (DWORD n = 0; gUserShellFolders[n].FolderName; n++)
    {
        //we subtract 1 from the length because one of the paths is \ terminated
        //and the other is not.
        if ( _wcsnicmp( pwszFolderName, gUserShellFolders[n].FolderName, gUserShellFolders[n].FolderNameLength - 1 ) == 0 )
        {
            CSidl = gUserShellFolders[n].CSidl;
            break;
        }
    }

    if ( CSIDL_FLAG_MASK != CSidl )
    {
        hr = SHGetFolderPath( 0, CSidl | CSIDL_FLAG_DONT_VERIFY,
                              _hUserToken, 0, wszFullPath );

        if ( S_OK != hr )
        {
            DebugMsg((DM_WARNING, IDS_FOLDERPATH_FAIL, pwszFolderName, hr));
            return (DWORD) hr;
        }
    }
    else
        return ERROR_INVALID_NAME;

    return ERROR_SUCCESS;
}

DWORD
CFileDB::CopyGPTFile(
    WCHAR * pwszLocalPath,
    WCHAR * pwszGPTPath
    )
{
    DWORD   FileAttr;
    DWORD   Status;
    BOOL    bStatus;

    if ( L'\\' == pwszLocalPath[wcslen(pwszLocalPath)-1] )
    {
        bStatus = CreateDirectory( pwszLocalPath, NULL );

        //
        // Note, we leave attributes & security as is if the dir
        // already exits.
        //
        if ( ! bStatus && (ERROR_ALREADY_EXISTS == GetLastError()) )
            return ERROR_SUCCESS;
    }
    else
    {
        FileAttr = GetFileAttributes( pwszLocalPath );
        if ( 0xFFFFFFFF == FileAttr )
            return GetLastError();

        SetFileAttributes( pwszLocalPath, FileAttr & ~FILE_ATTRIBUTE_READONLY );

        bStatus = CopyFile(
                    pwszGPTPath,
                    pwszLocalPath,
                    FALSE );

        //
        // By default, we set the read only attribute on deployed files.  We
        // combine this with any existing file attributes on the GPT file.
        //

        if ( bStatus )
        {
            FileAttr = GetFileAttributes( pwszGPTPath );
            bStatus = (FileAttr != 0xFFFFFFFF);
        }
        else
        {
            SetFileAttributes( pwszLocalPath, FileAttr );
        }

        if ( bStatus )
        {
            FileAttr |= FILE_ATTRIBUTE_READONLY;
            bStatus = SetFileAttributes( pwszLocalPath, FileAttr );
        }
    }

    if ( ! bStatus )
        return GetLastError();

    return ERROR_SUCCESS;
}

const FOLDERINFO*
CFileDB::FolderInfoFromFolderName(
    WCHAR *     pwszFolderName
    )
{
    //
    // This method returns the index into global array.
    //

    if ( _hUserToken )
    {
        for ( DWORD n = 0; gUserShellFolders[n].FolderName; n++ )
        {
            if ( _wcsnicmp( pwszFolderName, gUserShellFolders[n].FolderName, gUserShellFolders[n].FolderNameLength - 1 ) == 0 )
                return &gUserShellFolders[n];
        }
    }
    else
    {
        for ( DWORD n = 0; gMachineShellFolders[n].FolderName; n++ )
        {
            if ( _wcsnicmp( pwszFolderName, gMachineShellFolders[n].FolderName, gMachineShellFolders[n].FolderNameLength - 1 ) == 0 )
                return &gMachineShellFolders[n];
        }
    }

    return NULL;
}

int
CFileDB::RegValueCSIDLFromFolderName(
    WCHAR *     pwszFolderName
    )
{
    const FOLDERINFO    *pFI;

    pFI = FolderInfoFromFolderName(pwszFolderName);
    if (pFI != NULL)
        return pFI->CSidl;
    else
        return -1;      // invalid CSIDL
}

WCHAR *
CFileDB::RegValueNameFromFolderName(
    WCHAR * pwszFolderName
    )
{
    //
    // This is used by folder redirection logic.  In this case the folder
    // name is not '\' terminated, so we subtract one from the folder
    // name length.
    //
    const FOLDERINFO    *pFI;

    pFI = FolderInfoFromFolderName(pwszFolderName);
    if (pFI != NULL)
        return pFI->RegValue;
    else
        return NULL;
}

const WCHAR *
CFileDB::GetLocalStoragePath ()
{
    return (LPCWSTR) _pwszLocalPath;
}

DWORD
CFileDB::CopyFileTree(
    WCHAR * pwszExistingPath,
    WCHAR * pwszNewPath,
    WCHAR * pwszIgnoredSubdir,
    SHARESTATUS StatusFrom,
    SHARESTATUS StatusTo,
    BOOL        bAllowRdrTimeout,
    CCopyFailData * pCopyFailure
    )
{
    HANDLE      hFind;
    WIN32_FIND_DATA FindData;
    WIN32_FILE_ATTRIBUTE_DATA   SourceAttr;
    WIN32_FILE_ATTRIBUTE_DATA   DestAttr;
    WCHAR *     wszSource = NULL;
    WCHAR *     pwszSourceEnd = 0;
    WCHAR *     wszDest = NULL;
    WCHAR *     pwszDestEnd = 0;
    WCHAR *     pwszTempFilename = 0;
    DWORD       FileAttributes;
    DWORD       Status;
    BOOL        bStatus;
    BOOL        bReuseTempName = FALSE;
    int         lenSource;
    int         lenDest;
    DWORD       StatusCSCDel = ERROR_SUCCESS;
    DWORD       dwAttr = INVALID_FILE_ATTRIBUTES;


    if (! pwszExistingPath || ! pwszNewPath)
        return ERROR_PATH_NOT_FOUND;

    lenSource = wcslen (pwszExistingPath);
    lenDest = wcslen (pwszNewPath);

    if (! lenSource || ! lenDest)
        return ERROR_PATH_NOT_FOUND;

    wszSource = (WCHAR *) alloca (sizeof (WCHAR) * (lenSource + MAX_PATH + 2));
    if (NULL == wszSource)
        return ERROR_OUTOFMEMORY;
    lstrcpy( wszSource, pwszExistingPath );
    pwszSourceEnd = wszSource + lenSource;
    if (L'\\' != pwszSourceEnd[-1])
        *pwszSourceEnd++ = L'\\';
    pwszSourceEnd[0] = L'*';
    pwszSourceEnd[1] = 0;

    wszDest = (WCHAR *) alloca (sizeof (WCHAR) * (lenDest + MAX_PATH + 2));
    if (NULL == wszDest)
        return ERROR_OUTOFMEMORY;
    lstrcpy( wszDest, pwszNewPath );
    pwszDestEnd = wszDest + lenDest;
    if (L'\\' != pwszDestEnd[-1])
        *pwszDestEnd++ = L'\\';
    *pwszDestEnd = 0;

    hFind = FindFirstFile( wszSource, &FindData );

    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;

    do
    {
        lstrcpy( pwszSourceEnd, FindData.cFileName );
        lstrcpy( pwszDestEnd, FindData.cFileName );

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( FindData.cFileName, L"." ) == 0 ||
                 lstrcmp( FindData.cFileName, L".." ) == 0 ||
                 (pwszIgnoredSubdir && lstrcmpi( FindData.cFileName, pwszIgnoredSubdir ) == 0) )
                continue;

            Status = FullDirCopyW (wszSource, wszDest, FALSE);

            if ( ERROR_SUCCESS == Status )
            {
                if (ERROR_SUCCESS == StatusCSCDel)
                {
                    Status = CopyFileTree( wszSource, wszDest, NULL, StatusFrom, StatusTo, bAllowRdrTimeout, pCopyFailure );
                }
                else
                {
                    //no point delaying CSCDeletes anymore since we have already failed once.
                    Status = CopyFileTree (wszSource, wszDest, NULL, StatusFrom, StatusTo, FALSE, pCopyFailure);
                }
                //copy over the pin info. too
                if (ERROR_SUCCESS == Status)
                    MergePinInfo (wszSource, wszDest, StatusFrom, StatusTo);
            }
            else
            {
                pCopyFailure->RegisterFailure (wszSource, wszDest);
                DebugMsg((DM_VERBOSE, IDS_DIRCREATE_FAIL, wszDest, Status));
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
            // First check if it is necessary to copy the file over.
            bStatus = GetFileAttributesEx( wszSource, GetFileExInfoStandard, &SourceAttr );
            if ( bStatus )
            {
                bStatus = GetFileAttributesEx( wszDest, GetFileExInfoStandard, &DestAttr );
                if (bStatus)
                {
                    if (CompareFileTime( &SourceAttr.ftLastWriteTime, &DestAttr.ftLastWriteTime ) <= 0)
                    {
                        // The destination is newer or at least as old as the source.
                        // There is no need to copy. However, we should delete
                        // the locally cached copy of the file if any since the
                        // destination is newer.
                        if (ERROR_SUCCESS == StatusCSCDel)
                            StatusCSCDel = DeleteCSCFile ( wszSource, bAllowRdrTimeout);
                        else
                            DeleteCSCFile ( wszSource, FALSE);
                        continue;
                    }

                }
                else
                {
                    Status = GetLastError();
                    if (ERROR_PATH_NOT_FOUND == Status ||
                        ERROR_FILE_NOT_FOUND == Status)
                    {
                        // The destination was not found. So we must proceed with the copy.
                        bStatus = TRUE;
                        Status = ERROR_SUCCESS;
                    }
                }
            }
            else
            {
                // We failed to get the attributes of the source file.
                Status = GetLastError();
            }

            if (ERROR_SUCCESS == Status)
            {
                //
                // If we are here, we need to copy the file over.
                // In order to avoid loss of data, we must first copy the file
                // over to a temporary file at the destination and then rename
                // the file at the destination. This is because if the network
                // connection gets dropped during the filecopy operation, then
                // we are left with an incomplete file at the destination.
                // If we use the real name on the destination directly, then
                // the file will be skipped at the next redirection attempt
                // because of our last writer wins algorithm. As a result, when
                // the redirection succeeds subsequently, we end up with a loss
                // of user data. Copying to a temp name and then renaming the
                // file prevents this problem from happening because the rename
                // operation is atomic.
                //
                // First check if we need to generate a new temporary filename
                // Note: We try to minimize the number of calls to GetTempFilename
                // because it can be a very expensive call as it can result in
                // multiple CreateFile calls over the network which can be
                // especially slow for EFS shares.
                //
                bReuseTempName = FALSE;
                if (NULL != pwszTempFilename && L'\0' != *pwszTempFilename)
                {
                    dwAttr = GetFileAttributes (pwszTempFilename);
                    if (INVALID_FILE_ATTRIBUTES == dwAttr)
                    {
                        Status = GetLastError();
                        if (ERROR_PATH_NOT_FOUND == Status ||
                            ERROR_FILE_NOT_FOUND == Status)
                        {
                            Status = ERROR_SUCCESS;
                            bReuseTempName = TRUE;
                        }
                    }
                }
                if (ERROR_SUCCESS == Status && FALSE == bReuseTempName)
                {
                    // We need to generate a new temporary filename.
                    if (NULL == pwszTempFilename)
                    {
                        pwszTempFilename = new WCHAR [MAX_PATH + 1];
                        if (NULL == pwszTempFilename)
                            Status = ERROR_OUTOFMEMORY;
                    }
                    if (ERROR_SUCCESS == Status)
                    {
                        *pwszTempFilename = 0;
                        *pwszDestEnd = 0;
                        bStatus = GetTempFileName(wszDest, TEXT("frd"), 0, pwszTempFilename);
                        *pwszDestEnd = FindData.cFileName[0];
                        if (!bStatus)
                        {
                            Status = GetLastError();
                        }
                    }
                }
                if (ERROR_SUCCESS == Status)
                {
                    // Now we have a temp. filename and we are ready to copy.
                    Status = FullFileCopyW (wszSource, pwszTempFilename, FALSE);

                    if (ERROR_SUCCESS == Status)
                    {
                        // Now we rename the file at the destination in one atomic
                        // step. Note however that if the destination file exists
                        // and has readonly/hidden/system attributes, the MoveFileEx
                        // API will fail with ERROR_ACCESS_DENIED. So we slap on normal
                        // attributes on the file before doing the Move. If we fail,
                        // we restore the attributes.
                        dwAttr = GetFileAttributes (wszDest);
                        // Change attributes only if we managed to figure out the 
                        // actual attributes.
                        if (INVALID_FILE_ATTRIBUTES != dwAttr)
                            SetFileAttributes (wszDest, FILE_ATTRIBUTE_NORMAL);
                        if (!MoveFileEx(pwszTempFilename, wszDest, MOVEFILE_REPLACE_EXISTING))
                        {
                            Status = GetLastError();
                            // Restore the attributes of the destination file.
                            // Provided we changed those in the first place.
                            if (INVALID_FILE_ATTRIBUTES != dwAttr)
                                SetFileAttributes (wszDest, dwAttr);
                            // Also try to delete the temp file because we might still
                            // be able to do it. But ignore any failures. We are just
                            // trying to be nice by removing turds.
                            DeleteFile(pwszTempFilename);
                            
                        }
                    }
                }
            }

            if ( Status != ERROR_SUCCESS )
            {
                pCopyFailure->RegisterFailure (wszSource, wszDest);

                switch (Status)
                {
                case ERROR_INVALID_SECURITY_DESCR:
                    DebugMsg((DM_VERBOSE, IDS_SETSECURITY_FAIL, wszSource, wszDest));
                    break;
                default:
                    DebugMsg((DM_VERBOSE, IDS_FILECOPY_FAIL, wszSource, wszDest, Status));
                    break;
                }
            }
        }

        if ( Status != ERROR_SUCCESS )
            break;

    } while ( FindNextFile( hFind, &FindData ) );

    // Some final cleanup before we return.

    FindClose( hFind );

    if (pwszTempFilename)
    {
        delete [] pwszTempFilename;
        pwszTempFilename = NULL;
    }

    return Status;
}

DWORD
CFileDB::DeleteFileTree(
    WCHAR * pwszPath,
    WCHAR * pwszIgnoredSubdir
    )
{
    HANDLE      hFind;
    WIN32_FIND_DATA FindData;
    WCHAR *     wszSource = NULL;
    WCHAR *     pwszSourceEnd = 0;
    DWORD       Status;
    BOOL        bStatus;
    int         len;

    if (!pwszPath)
        return ERROR_PATH_NOT_FOUND;

    len = wcslen (pwszPath);

    if (!len)
        return ERROR_PATH_NOT_FOUND;

    wszSource = (WCHAR *) alloca (sizeof (WCHAR) * (len + MAX_PATH + 2));
    if (NULL == wszSource)
        return ERROR_OUTOFMEMORY;
    lstrcpy( wszSource, pwszPath );
    pwszSourceEnd = wszSource + lstrlen( wszSource );
    if (L'\\' != pwszSourceEnd[-1])
        *pwszSourceEnd++ = L'\\';
    pwszSourceEnd[0] = L'*';
    pwszSourceEnd[1] = 0;

    hFind = FindFirstFile( wszSource, &FindData );

    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    Status = ERROR_SUCCESS;

    for (;;)
    {
        lstrcpy( pwszSourceEnd, FindData.cFileName );

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( FindData.cFileName, L"." ) != 0 &&
                 lstrcmp( FindData.cFileName, L".." ) != 0 &&
                 (! pwszIgnoredSubdir || lstrcmpi( FindData.cFileName, pwszIgnoredSubdir ) != 0) )
            {
                SetFileAttributes( wszSource, FILE_ATTRIBUTE_NORMAL );
                Status = DeleteFileTree( wszSource, NULL);

                if ( ERROR_SUCCESS == Status )
                {
                    if ( ! RemoveDirectory( wszSource ) )
                    {
                        Status = GetLastError();
                        DebugMsg((DM_VERBOSE, IDS_DIRDEL_FAIL, wszSource, Status));
                    }
                }
            }
        }
        else
        {
            SetFileAttributes( wszSource, FILE_ATTRIBUTE_NORMAL );
            bStatus = DeleteFile( wszSource );
            if ( ! bStatus )
            {
                Status = GetLastError();
                DebugMsg((DM_VERBOSE, IDS_FILEDEL_FAIL, wszSource, Status));
            }
        }

        if ( Status != ERROR_SUCCESS )
            break;

        bStatus = FindNextFile( hFind, &FindData );

        if ( ! bStatus )
        {
            Status = GetLastError();
            if ( ERROR_NO_MORE_FILES == Status )
                Status = ERROR_SUCCESS;
            break;
        }
    }

    FindClose( hFind );

    return Status;
}

//note: the bCheckOwner flag: if set to true, then if the directory in question
//      already exists, the function Fails with an ERROR_INVALID_OWNER if the
//      the owner of the existing directory is not the user.
//      bSourceValid indicates if there is a valid path in pwszSource
DWORD
CFileDB::CreateRedirectedFolderPath(
    const WCHAR * pwszSource,
    const WCHAR * pwszDest,
    BOOL    bSourceValid,
    BOOL    bCheckOwner,
    BOOL    bMoveContents
    )
{
    WCHAR * pwszSlash = 0;
    WCHAR * pwszPath = NULL;
    DWORD   Status = ERROR_SUCCESS;
    int     len;
    WCHAR * pwszSuccess = NULL;
    DWORD   dwAttributes;

    //first make a local copy of the destination path to work with.
    //while copying, we actually convert it into an absolute path so
    //that we eliminate any problems with weird paths like
    //\\server\share\..\hello\..\there
    len = wcslen (pwszDest) + 1;
    pwszPath = (WCHAR*) alloca (len * sizeof(WCHAR));
    if (!pwszPath)
        return ERROR_OUTOFMEMORY;
    pwszSuccess = _wfullpath (pwszPath, pwszDest, len);
    if (!pwszSuccess)
        return ERROR_BAD_PATHNAME;  //actually _wfullpath rarely fails

    //
    // Will only accept drive based or UNC based paths.
    //
    // A redirect path of just <drive>:\ or \\server\share will be accepted
    // even though this would be a strange choice for redirection.
    //
    // IMPORTANT: also see notes at the beginning of the function

    if ( L':' == pwszPath[1] && L'\\' == pwszPath[2] )
    {
        pwszSlash = &pwszPath[2];
    }
    else if ( L'\\' == pwszPath[0] && L'\\' == pwszPath[1] )
    {
        pwszSlash = wcschr( &pwszPath[2], L'\\' );
        if ( pwszSlash )
        {
            //watch out for '\' terminated paths
            if (L'\0' == pwszSlash[1])
            {
                pwszSlash = 0;
            }
            else    //it is at least of the form \\server\share
            {
                pwszSlash = wcschr( &pwszSlash[1], L'\\' );
                //if it is of the form \\server\share, then we allow this path
                //based depending on the ownership checks if any
                if (!pwszSlash)
                    return bCheckOwner ? IsUserOwner(pwszPath) : ERROR_SUCCESS;
                //note: we do not have to watch out for the '\' terminated
                //paths here (e.g. \\server\share\) because that will be
                //taken care of below : in -> if (!pwszSlash[1])
            }
        }
    }
    else
    {
        pwszSlash = 0;
    }

    if ( ! pwszSlash )
        return ERROR_BAD_PATHNAME;

    //if it is the root directory of a drive or root of a UNC share
    //we succeed based on ownership checks, if any...
    //but before that, we also need to make sure that the specified path
    //exists or we may end up redirecting to a non-existent location.
    if ( !pwszSlash[1])
    {
        if (0xFFFFFFFF != (dwAttributes = GetFileAttributes(pwszPath)))
        {
            //it exists
            if (! (FILE_ATTRIBUTE_DIRECTORY & dwAttributes))
            {
                return ERROR_DIRECTORY;
            }

            //it exists and is a directory
            return bCheckOwner ? IsUserOwner (pwszPath) : ERROR_SUCCESS;
        }
        else
        {
            return GetLastError();
        }
    }

    //if we are here, it is not the root of a drive or a share.
    //so we might have to do create the destination.
    //First do a quick check to see if the path exists already. this
    //is not only an optimization, but is also necessary for cases
    //where an admin. may want to lock down access to certain folders
    //by pre-creating the folders and putting highly resitrictive ACLs on them
    //in that case, CreateDirectory (later in the code) would fail with
    //ACCESS_DENIED rather than ERROR_ALREADY_EXISTS and the redirection code
    //will bail out even though it is not necessary to.
    if (0xFFFFFFFF != (dwAttributes = GetFileAttributes(pwszPath)))
    {
        //it exists
        if (! (FILE_ATTRIBUTE_DIRECTORY & dwAttributes))
        {
            return ERROR_DIRECTORY;
        }

        //it exists and is a directory
        return bCheckOwner ? IsUserOwner (pwszPath) : ERROR_SUCCESS;

    }

    //the destination has not been pre-created, so we need to do that
    //ourselves

    do
    {
        pwszSlash = wcschr( &pwszSlash[1], L'\\' );

        // Watch out for '\' terminated paths.
        if ( pwszSlash && (L'\0' == pwszSlash[1]) )
            pwszSlash = 0;

        if ( pwszSlash )
        {
            *pwszSlash = 0;
            CreateDirectory( pwszPath, NULL );
            *pwszSlash = L'\\';

            //ignore all errors in the intermediate folders not just
            //ERROR_ALREADY_EXISTS because of folders like
            //\\server\share\dir1\dir2\%username% where the user may not
            //have write access in dir1 but might have so in dir2
            //if the path is invalid we will either discover it at the last
            //dir in the chain or while trying to redirect to the destination
            //retaining the code here just in case...
            //
            /*if ( ! bStatus && (GetLastError() != ERROR_ALREADY_EXISTS) )
                return GetLastError();*/
        }
        else
        {
            //
            // Last dir in the chain.  We set security on the last dir in
            // the path to only allow the user & system access if
            // the directory did not already exist.
            //

            if (bCheckOwner)
            {
                Status = CreateFolderWithUserFileSecurity( pwszPath );
            }
            else 
            {
                Status = ERROR_SUCCESS;
                
                if (!CreateDirectory( pwszPath, NULL ))
                    Status = GetLastError();
            }

            if ( ERROR_SUCCESS == Status )
            {
                //the extension created the directory, so try to set the user as
                //the owner explicitly because if a member of the local administrators
                //group creates a directory/file, the Administrators group becomes
                //the owner by default. This can cause problems with quota accounting
                //and also if the settings on the redirection policy are changed
                //at a later date. However, since it is not necessary that the
                //we will succeed in setting the owner here, we ignore any failures
                SetUserAsOwner (pwszPath);

                //
                // We want to skip the DACL if we want to apply exclusive ACLs
                // i.e., bCheckOwner is true. Otherwise, we should just copy
                // over all the metadata.
                //
                if (bSourceValid && bMoveContents)
                    FullDirCopyW (pwszSource, pwszPath, bCheckOwner);

                return ERROR_SUCCESS;
            }
            else if ( ERROR_ALREADY_EXISTS != Status)
            {
                return Status;
            }
            else
            {
                //the directory already exists
                //start anti-spoofing agent
                //do the ownership check only on the last dir in chain and only
                //if the flags in the ini file tell you to.
                if (bCheckOwner &&
                    (ERROR_SUCCESS != (Status = IsUserOwner(pwszPath))))
                {
                    DebugMsg ((DM_VERBOSE, IDS_ACL_MISMATCH, pwszPath, Status));
                    return Status;
                }
                else
                    return ERROR_SUCCESS;
            }
        }

    } while ( pwszSlash );

    return ERROR_SUCCESS;
}

DWORD
CFileDB::SetUserAsOwner(
    WCHAR * pwszPath
    )
{
    SECURITY_DESCRIPTOR SecDesc;
    PSID        pSidUser = 0;
    PTOKEN_USER pTokenUser = 0;
    DWORD       Size = 0;
    DWORD       Status = ERROR_SUCCESS;
    BOOL        bStatus;

    if ( ! _hUserToken )
        return ERROR_SUCCESS;

    for (;;)
    {
        Status = NtQueryInformationToken(
                     _hUserToken,
                     TokenUser,
                     pTokenUser,
                     Size,
                     &Size );

        if ( STATUS_BUFFER_TOO_SMALL == Status )
        {
            pTokenUser = (PTOKEN_USER) alloca( Size );
            if ( ! pTokenUser )
                return ERROR_OUTOFMEMORY;
            continue;
        }

        break;
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    Size = RtlLengthSid( pTokenUser->User.Sid );
    pSidUser = (PSID) alloca( Size );

    if ( pSidUser )
        Status = RtlCopySid( Size, pSidUser, pTokenUser->User.Sid );
    else
        Status = ERROR_OUTOFMEMORY;

    if ( Status != ERROR_SUCCESS )
        return Status;

    bStatus = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );

    if ( bStatus )
        bStatus = SetSecurityDescriptorOwner (&SecDesc, pSidUser, 0);

    if (bStatus)
        bStatus = SetFileSecurity( pwszPath, OWNER_SECURITY_INFORMATION, &SecDesc);

    if ( ! bStatus )
        Status = GetLastError();

    return Status;
}

DWORD
CFileDB::CreateFolderWithUserFileSecurity(
    WCHAR * pwszPath
    )
{
    SECURITY_DESCRIPTOR SecDesc;
    SID_IDENTIFIER_AUTHORITY AuthorityNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID        pSidUser = 0;
    PSID        pSidSystem = 0;
    PACL        pAcl = 0;
    ACE_HEADER * pAceHeader;
    PTOKEN_USER pTokenUser = 0;
    PSID        pSid = 0;
    DWORD       AclSize;
    DWORD       AceIndex;
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    if ( ! _hUserToken )
        return ERROR_SUCCESS;

    pSidSystem = 0;

    pTokenUser = 0;
    Size = 0;

    for (;;)
    {
        Status = NtQueryInformationToken(
                     _hUserToken,
                     TokenUser,
                     pTokenUser,
                     Size,
                     &Size );

        if ( STATUS_BUFFER_TOO_SMALL == Status )
        {
            pTokenUser = (PTOKEN_USER) alloca( Size );
            if ( ! pTokenUser )
                return ERROR_OUTOFMEMORY;
            continue;
        }

        break;
    }

    if ( Status != ERROR_SUCCESS )
        return Status;

    Size = RtlLengthSid( pTokenUser->User.Sid );
    pSidUser = (PSID) alloca( Size );

    if ( pSidUser )
        Status = RtlCopySid( Size, pSidUser, pTokenUser->User.Sid );
    else
        Status = ERROR_OUTOFMEMORY;

    if ( Status != ERROR_SUCCESS )
        return Status;

    bStatus = AllocateAndInitializeSid( &AuthorityNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem);

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SetUserFileSecurityEnd;
    }

    //
    // Allocate space for the ACL
    //

    AclSize = (GetLengthSid(pSidUser)) +
              (GetLengthSid(pSidSystem)) +
              sizeof(ACL) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) alloca( AclSize );

    if ( pAcl )
    {
        bStatus = InitializeAcl( pAcl, AclSize, ACL_REVISION );
        if ( ! bStatus )
            Status = GetLastError();
    }
    else
    {
        Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
        goto SetUserFileSecurityEnd;

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidUser);

    if ( bStatus )
    {
        bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
        if ( bStatus )
            pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
    }

    if ( bStatus )
    {
        AceIndex++;
        bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem);

        if ( bStatus )
        {
            bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
            if ( bStatus )
                pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        }
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SetUserFileSecurityEnd;
    }

    bStatus = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );

    if (bStatus)
        SetSecurityDescriptorControl (&SecDesc, SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED);
    //SE_DACL_PROTECTED is supported by NTFS5 but not by NTFS4, therefore
    //we ignore any failures in SetSecurityDesciptorControl

    if ( bStatus )
        bStatus = SetSecurityDescriptorDacl( &SecDesc, TRUE, pAcl, FALSE );

    //set the owner explicitly. This is required because if the user is an
    //admin, then when the directory is created, the owner is set to the group
    //administrators, rather than the user

    if ( bStatus )
    {
        bStatus = SetSecurityDescriptorOwner (&SecDesc, pSidUser, 0);
    }

    if ( bStatus )
    {
        SECURITY_ATTRIBUTES sa;
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = &SecDesc;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    
        bStatus = CreateDirectory(pwszPath, &sa);
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
    }

SetUserFileSecurityEnd:

    // The user Sid was allocated on the stack, so there is no need to Free it.

    if (pSidSystem)
        FreeSid( pSidSystem );

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileDB::IsUserOwner
//
//  Synopsis:   given a path. this function determines if the user is the
//              the owner of the file/folder
//
//  Arguments:  [in] pwszPath
//
//  Returns:    ERROR_SUCCESS if user is owner
//              otherwise an error code
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CFileDB::IsUserOwner (const WCHAR * pwszPath)
{
    BOOL            bStatus;
    DWORD           Status;
    BOOL            bIsMember;
    DWORD           dwLengthNeeded;
    PSECURITY_DESCRIPTOR    pSecDesc = 0;
    PSID            pOwnerSid = 0;
    BOOL            bDaclDefaulted;

    //first check if we are on FAT. if we are on FAT, then we simply let
    //succeed since FAT cannot have any ACLs anyway
    Status = IsOnNTFS (pwszPath);
    if (ERROR_NO_SECURITY_ON_OBJECT == Status)
    {
        Status = ERROR_SUCCESS;     //we are on FAT
        goto UserOwnerEnd;
    }
    else if (ERROR_SUCCESS != Status)
        goto UserOwnerEnd;         //there was some other error
    //else we are on NTFS and ready to rumble!

    //get the owner sid from the folder.
    for (dwLengthNeeded = 0;;)
    {
        bStatus = GetFileSecurity (pwszPath, OWNER_SECURITY_INFORMATION,
                                   pSecDesc, dwLengthNeeded,
                                   &dwLengthNeeded);
        if (bStatus)
            break;      //we have the security descriptor. we are free to leave.

        //GetFileSecurity failed if we are here
        Status = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != Status)
            goto UserOwnerEnd;

        //GetFileSecurity failed due to insufficient memory if we are here.
        pSecDesc = NULL;
        pSecDesc = (PSECURITY_DESCRIPTOR) alloca (dwLengthNeeded);

        if (NULL == pSecDesc)
        {
            Status = ERROR_OUTOFMEMORY;
            goto UserOwnerEnd;
        }
    }

    //now get the owner sid
    bStatus = GetSecurityDescriptorOwner (
                    pSecDesc,
                    &pOwnerSid,
                    &bDaclDefaulted);
    if (!bStatus)
    {
        Status = GetLastError();
    }
    else
    {
        if (!pOwnerSid)
        {
            Status = ERROR_INVALID_OWNER;
        }
        else
        {
            bStatus = CheckTokenMembership (_hUserToken, pOwnerSid, &bIsMember);
            if (!bStatus)
                Status = GetLastError();
            else
            {
                if (bIsMember)
                    Status = ERROR_SUCCESS;
                else
                    Status = ERROR_INVALID_OWNER;
            }
        }
    }

UserOwnerEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileDB::GetEnvBlock
//
//  Synopsis:   gets a pointer to the user's environment block
//
//  Arguments:  none.
//
//  Returns:    pointer to the user's environment block.
//              NULL if it is not created yet
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
PVOID CFileDB::GetEnvBlock (void)
{
    return _pEnvBlock;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileDB::GetRsopContext
//
//  Synopsis:   gets a pointer to the rsop logging context
//
//  Arguments:  none.
//
//  Returns:    pointer to the rsop logging context -- never null
//
//
//  History:    12/8/1999  adamed  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CRsopContext*
CFileDB::GetRsopContext()
{
    return _pRsopContext;
}

//member functions and data for class CSavedSettings

//initialize the class's static variables.
int CSavedSettings::m_idConstructor = 0;
CFileDB * CSavedSettings::m_pFileDB = NULL;
WCHAR * CSavedSettings::m_szSavedSettingsPath = NULL;

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::ResetStaticMembers
//
//  Synopsis:   resets the static members to their default values.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      static members of a class, like other global variables are
//              initialized only when the dll is loaded. So if this dll
//              stays loaded across logons, then the fact that the globals
//              have been initialized based on a previous logon can cause
//              problems. Therefore, this function is used to reinitialize
//              the globals.
//
//---------------------------------------------------------------------------
void CSavedSettings::ResetStaticMembers(void)
{
    //
    // No need to delete it. This usually points to a local variable in
    // ProcessGroupPolicyInternal. So the actual object gets deleted when
    // after each processing. We just need to make sure that it is reflected
    // here.
    //
    m_pFileDB = NULL;
    
    if (m_szSavedSettingsPath)
    {
        delete [] m_szSavedSettingsPath;
        m_szSavedSettingsPath = NULL;
    }
    
    // No need to do anything about m_idConstructor
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings
//
//  Synopsis:   default constructor for the class.
//
//  Arguments:
//
//  Returns:
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CSavedSettings::CSavedSettings ()
{
    m_rID = (REDIRECTABLE) m_idConstructor;
    m_idConstructor = (m_idConstructor + 1) % ((int) EndRedirectable);
    m_szLastRedirectedPath = NULL;
    m_szCurrentPath = NULL;
    m_szLastUserName = NULL;
    m_szLastHomedir = NULL;
    m_bIsHomedirRedir = FALSE;
    m_bHomedirChanged = FALSE;
    m_dwFlags = REDIR_DONT_CARE;    //this is always a safe default
    m_psid = 0;
    m_bValidGPO = FALSE;
    m_bUserNameChanged = FALSE;
    m_szGPOName[0] = L'\0';
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::ResetMembers
//
//  Synopsis:   Resets the member variables.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      see ResetStaticMembers.
//
//---------------------------------------------------------------------------
void CSavedSettings::ResetMembers(void)
{
    if (m_szLastRedirectedPath)
    {
        delete [] m_szLastRedirectedPath;
        m_szLastRedirectedPath = NULL;
    }
    
    if (m_szCurrentPath)
    {
        delete [] m_szCurrentPath;
        m_szCurrentPath = NULL;
    }

    if (m_szLastUserName)
    {
        delete [] m_szLastUserName;
        m_szLastUserName = NULL;
    }

    if (m_szLastHomedir)
    {
        delete [] m_szLastHomedir;
        m_szLastHomedir = NULL;
    }

    if (m_psid)
    {
        RtlFreeSid (m_psid);
        m_psid = NULL;
    }
    
    m_bHomedirChanged = FALSE;
    m_dwFlags = REDIR_DONT_CARE;    //this is always a safe default
    m_bValidGPO = FALSE;
    m_bUserNameChanged = FALSE;
    m_szGPOName[0] = L'\0';
    
    // No need to do anything about m_rID.
}

//+--------------------------------------------------------------------------
//
//  Member:     ~CSavedSettings
//
//  Synopsis:   default destructor
//
//  Arguments:
//
//  Returns:
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CSavedSettings::~CSavedSettings ()
{
    //free static members if necessary
    if (m_szSavedSettingsPath)
    {
        delete [] m_szSavedSettingsPath;
        m_szSavedSettingsPath = NULL;    //this is necessary so that the
                                        //destructor of the next object does
                                        //not try to free it again
    }

    //
    // Free other memory allocated for members of this object
    // and reset them.
    //
    ResetMembers();
}

//+--------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   loads the saved settings into the object for its corresponding
//              folder
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if successful. otherwise an error code
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::Load (CFileDB * pFileDB)
{
    DWORD   Status;
    BOOL    bStatus;
    DWORD   len;

    //first set the FileDB object if it has not already been set
    if (!m_pFileDB)
        m_pFileDB = pFileDB;

    ASSERT (m_pFileDB);

    //get the name of the file where the last settings have been saved
    //if we haven't already done so.
    if (!m_szSavedSettingsPath)
    {
        len = wcslen (pFileDB->_pwszLocalPath) +
            wcslen (SAVED_SETTINGS_FILE) + 2;

        m_szSavedSettingsPath = (WCHAR *) new WCHAR [len];
        if (!m_szSavedSettingsPath)
        {
            Status = ERROR_OUTOFMEMORY;
            goto LoadEnd;
        }
        wcscpy (m_szSavedSettingsPath, pFileDB->_pwszLocalPath);
        wcscat (m_szSavedSettingsPath, L"\\");
        wcscat (m_szSavedSettingsPath, SAVED_SETTINGS_FILE);
    }

    //do a quick check to see if the file exists
    if (0xFFFFFFFF == GetFileAttributes(m_szSavedSettingsPath))
        Status = LoadDefaultLocal ();
    else
        Status = LoadFromIniFile ();

LoadEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     GetCurrentPath
//
//  Synopsis:   gets the current path of the folder.
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if successful
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::GetCurrentPath (void)
{
    DWORD   Status = ERROR_SUCCESS;
    WCHAR * pwszValueName = 0;
    DWORD   Size;
    WCHAR * pwszProcessedPath = NULL;

    if (m_szCurrentPath)
    {
        delete [] m_szCurrentPath;
        m_szCurrentPath = NULL;
    }

    m_szCurrentPath = new WCHAR [MAX_PATH];
    if (!m_szCurrentPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto GetCurrentPathEnd;
    }
    m_szCurrentPath[0] = L'\0';
    Status = m_pFileDB->GetPathFromFolderName (
                g_szRelativePathNames[(int)m_rID],
                m_szCurrentPath
                );
    if (((DWORD) S_OK != Status) &&  //if SHGetFolderPath failed, use the local userprofile path
        ERROR_INVALID_NAME != Status)   //the only error from GetPathFromFolderName that is not generated by SHGetFolderPath
    {
        Status = ERROR_SUCCESS;
        wcscpy (m_szCurrentPath, L"%USERPROFILE%\\");
        wcscat (m_szCurrentPath, g_szRelativePathNames[(int)m_rID]);
    }
    else
    {
        // expand the homedir path if applicable.
        if (IsHomedirPath (m_rID, m_szCurrentPath, TRUE))
        {
            Status = ExpandHomeDir (m_rID, m_szCurrentPath, TRUE, &pwszProcessedPath);
            delete [] m_szCurrentPath;
            m_szCurrentPath = NULL;
            if (ERROR_SUCCESS == Status)
            {
                m_szCurrentPath = pwszProcessedPath;
                pwszProcessedPath = NULL;
            }
        }
    }

    if (m_szCurrentPath)
        RemoveEndingSlash( m_szCurrentPath );

GetCurrentPathEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     ResetLastUserName
//
//  Synopsis:   sets the last user name to the current username
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS : if there is no error.
//              an error code otherwise.
//
//  History:    9/15/1999  RahulTh  created
//
//  Notes:      the most likely cause of failure for this function -- if at all
//              it happens, will be an out of memory condition.
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::ResetLastUserName (void)
{
    if (m_szLastUserName)
    {
        delete [] m_szLastUserName;
        m_szLastUserName = NULL;
    }

    m_szLastUserName = new WCHAR [wcslen(gwszUserName) + 1];
    if (!m_szLastUserName)
        return ERROR_OUTOFMEMORY;


    wcscpy (m_szLastUserName, gwszUserName);
    m_bUserNameChanged = FALSE;

    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Member:     LoadDefaultLocal
//
//  Synopsis:   loads the default local userprofile path and default
//              flags into the object
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if successful an error code otherwise
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:      the security group is set to Everyone as you can never
//              cease being a member of the group
//
//              this function is usually invoked when one can't find
//              the ini file that contains the last saved settings or
//              if the ini file does not contain the corresponding section
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::LoadDefaultLocal (void)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   len;

    // The default case cannot be homedir redirection.
    // Just make sure that our bool has been properly set.
    m_bIsHomedirRedir = FALSE;

    //set the default flags
    m_dwFlags = REDIR_DONT_CARE;

    //to be on the safe side -- set the default values for all members.
    m_bValidGPO = FALSE;
    m_szGPOName[0] = L'\0';

    //set the last username to be the same as the current username
    //since we load the defaults only when we do not have any data about the
    //last logon (i.e., no per user per machine FR cache
    Status = ResetLastUserName ();
    if (ERROR_SUCCESS != Status)
        goto LoadDefaultsEnd;

    //allocate the sid
    //to be on the safe side, free the sid if it has already been allocated
    if (m_psid)
    {
        RtlFreeSid (m_psid);
        m_psid = NULL;
    }
    Status = AllocateAndInitSidFromString (L"S-1-1-0", &m_psid);

    if (ERROR_SUCCESS != Status)
    {
        m_psid = 0;
        goto LoadDefaultsEnd;
    }

    //get the last redirected path
    //again, to be on the safe side, free any used memory first
    if (m_szLastRedirectedPath)
    {
        delete [] m_szLastRedirectedPath;
        m_szLastRedirectedPath = NULL;
    }
    len = wcslen (L"%USERPROFILE%\\") +
        wcslen (g_szRelativePathNames[(int)m_rID]) + 1;
    m_szLastRedirectedPath = new WCHAR [len];
    if (!m_szLastRedirectedPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto LoadDefaultsEnd;
    }
    wcscpy (m_szLastRedirectedPath, L"%USERPROFILE%\\");
    wcscat (m_szLastRedirectedPath, g_szRelativePathNames[(int)m_rID]);

    //get the current path
    Status = GetCurrentPath();

LoadDefaultsEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     LoadFromIniFile
//
//  Synopsis:   this function loads redirection info. from the ini file
//              that contains the last saved settings.
//              file.
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if everything is successful. an error code otherwise
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:      if this function cannot find the corresponding section in the
//              ini file, it loads the default local path
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::LoadFromIniFile (void)
{
    DWORD   Status = ERROR_SUCCESS;
    WCHAR   pwszDefault[] = L"*";
    WCHAR * pwszReturnedString = NULL;
    WCHAR * pwszProcessedPath = NULL;
    DWORD   retVal;
    DWORD   Size;
    UNICODE_STRING  StringW;
    GUID    GPOGuid;

    //
    // If this object contains the MyDocs settings, get the last value
    // of homedir
    //
    if (MyDocs == m_rID || MyPics == m_rID)
    {
        Status = SafeGetPrivateProfileStringW (
                       g_szDisplayNames [(int) m_rID],
                       L"Homedir",
                       pwszDefault,
                       &m_szLastHomedir,
                       &Size,
                       m_szSavedSettingsPath);
        if (ERROR_SUCCESS != Status)
            goto LoadIniEnd;

        if (L'*' == *m_szLastHomedir)
        {
            // The value of homedir at the last redirection was not found.
            delete [] m_szLastHomedir;
            m_szLastHomedir = NULL;
        }
    }

    //first try to get the user name when the user had last logged on.
    Status = SafeGetPrivateProfileStringW (
                   g_szDisplayNames [(int) m_rID],
                   L"Username",
                   pwszDefault,
                   &m_szLastUserName,
                   &Size,
                   m_szSavedSettingsPath);

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *m_szLastUserName)
    {
        //the username field was not found in the ini file. must be an older
        //cache. since we do not have the information, we just use the defaults,
        //i.e. set the current user name as the last user name
        Status = ResetLastUserName();
        if (ERROR_SUCCESS != Status)
            goto LoadIniEnd;
    }
    else
    {
        //we found a user name in the local cache.
        //update the member variable which indicates whether the user name
        //has changed since the last logon.
        if (0 == _wcsicmp (m_szLastUserName, gwszUserName))
            m_bUserNameChanged = FALSE;
        else
            m_bUserNameChanged = TRUE;
    }

    //then try to get the path
    Status = SafeGetPrivateProfileStringW (
                   g_szDisplayNames [(int) m_rID],
                   L"Path",
                   pwszDefault,
                   &m_szLastRedirectedPath,
                   &Size,
                   m_szSavedSettingsPath);

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *m_szLastRedirectedPath) //we could not find the required data.
    {
        //so we go with the defaults
        Status = LoadDefaultLocal();
        goto LoadIniEnd;
    }
    else if (IsHomedirPath (m_rID, m_szLastRedirectedPath, TRUE))
    {
        Status = ExpandHomeDir (m_rID,
                                m_szLastRedirectedPath,
                                TRUE,
                                &pwszProcessedPath,
                                m_szLastHomedir
                                );
        delete [] m_szLastRedirectedPath;
        if (ERROR_SUCCESS != Status)
        {
            m_szLastRedirectedPath = NULL;
            goto LoadIniEnd;
        }
        else
        {
            m_bIsHomedirRedir = TRUE;
            m_szLastRedirectedPath = pwszProcessedPath;
            pwszProcessedPath = NULL;
        }
    }

    //next try to get the security group
    Status = SafeGetPrivateProfileStringW (
                   g_szDisplayNames[(int)m_rID],
                   L"Group",
                   pwszDefault,
                   &pwszReturnedString,
                   &Size,
                   m_szSavedSettingsPath
                   );

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *pwszReturnedString)
    {
        //data was missing, so go with the defaults
        Status = LoadDefaultLocal();
        goto LoadIniEnd;
    }

    if (m_psid)
    {
        RtlFreeSid (m_psid);
        m_psid = NULL;
    }

    Status = AllocateAndInitSidFromString (pwszReturnedString, &m_psid);

    if (ERROR_SUCCESS != Status)
    {
        m_psid = 0;
        goto LoadIniEnd;
    }

    //now get the flags
    Status = SafeGetPrivateProfileStringW (
                  g_szDisplayNames[(int)m_rID],
                  L"Flags",
                  pwszDefault,
                  &pwszReturnedString,
                  &Size,
                  m_szSavedSettingsPath
                  );

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *pwszReturnedString)
    {
        Status = LoadDefaultLocal();
        goto LoadIniEnd;
    }

    //now grab the hex flags
    StringW.Buffer = pwszReturnedString;
    StringW.Length = wcslen (pwszReturnedString) * sizeof (WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof(WCHAR);
    RtlUnicodeStringToInteger( &StringW, 16, &m_dwFlags );

    //now get the unique name of the GPO (if any) that was used to redirect the folder
    Status = SafeGetPrivateProfileStringW (
                 g_szDisplayNames[(int) m_rID],
                 L"GPO",
                 pwszDefault,
                 &pwszReturnedString,
                 &Size,
                 m_szSavedSettingsPath
                 );
    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    StringW.Length = sizeof (WCHAR) * wcslen (pwszReturnedString);
    StringW.MaximumLength = (USHORT)(sizeof(WCHAR) * Size);
    StringW.Buffer = pwszReturnedString;

    if ((L'*' == *pwszReturnedString) ||    //there is no valid GPO info., or
        (sizeof(m_szGPOName) <= wcslen(pwszReturnedString)) || //the file has been corrupted. the length of a valid unique name cannot exceed the size of m_szGPO, or
        (STATUS_INVALID_PARAMETER == RtlGUIDFromString (&StringW, &GPOGuid))  //it is not a valid GUID
        )
    {
        //there is no valid GPO info.
        m_bValidGPO = FALSE;
        m_szGPOName[0] = L'\0';
    }
    else
    {
        m_bValidGPO = TRUE;
        wcscpy (m_szGPOName, pwszReturnedString);
    }

    //get the current path.
    Status = GetCurrentPath ();

LoadIniEnd:
    if (pwszReturnedString)
        delete [] pwszReturnedString;
    if (pwszProcessedPath)
        delete [] pwszProcessedPath;

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Member:     NeedsProcessing
//
//  Synopsis:   once the saved settings and the registry values have been
//              loaded, this function determines if we need to look at all the
//              policies. Note that this assumes that the GPO_NOCHANGES flag
//              has already been set by the policy engine
//
//  Arguments:  none
//
//  Returns:    TRUE / FALSE
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CSavedSettings::NeedsProcessing (void)
{
    BOOL            bStatus;
    DWORD           i;
    DWORD           Status;
    PTOKEN_GROUPS   pGroups;
    WCHAR           wszExpandedPath [TARGETPATHLIMIT + 1];
    UNICODE_STRING  Path;
    UNICODE_STRING  ExpandedPath;
    const WCHAR *   pwszCurrentHomedir = NULL;
    WCHAR           wszProcessedSource [TARGETPATHLIMIT + 1];
    WCHAR           wszProcessedDest [TARGETPATHLIMIT + 1];
    int             len;

    //if policy didn't care about the location of the folder at last logon
    //then even if the last redirected path is not the same as the current
    //path, it should not mean that that we need to reprocess the policy
    //when the GPO_NOCHANGES flag has been provided
    if (m_dwFlags & REDIR_DONT_CARE)
        return FALSE;

    //if we are here, policy specified the location of the folder at the
    //the last logon. make sure that the user name has not changed since
    //last logon. If so, we need to process the policies again and move
    //the user's folders accordingly.
    if (m_bUserNameChanged)
        return TRUE;

    //
    // If we are here, the username had not changed, but if the homedir
    // changed, that can affect the path.
    // Note: Here, we cannot use the IsHomedirPath function to determine
    // if this is a homedir redirection since we would have already expanded
    // the path in LoadFromIniFile. Therefore, we must use m_bIsHomedirRedir
    //
    if (m_bIsHomedirRedir)
    {
        //
        // Note: GetHomeDir is an expensive call since it can result
        // in a call to the DS to get the user's home directory. So we try to
        // be as lazy as possible about executing it.
        //
        pwszCurrentHomedir = gUserInfo.GetHomeDir (Status);
        if (ERROR_SUCCESS != Status ||
            ! pwszCurrentHomedir ||
            ! m_szLastHomedir ||
            0 != lstrcmpi (m_szLastHomedir, pwszCurrentHomedir))
        {
            m_bHomedirChanged = TRUE;
            return TRUE;
        }
    }

    //check if the last redirected path and current path are identical
    if (0 != _wcsicmp(m_szLastRedirectedPath, m_szCurrentPath))
    {
        //the paths are different. we need to do processing
        //even if the policy engine thinks otherwise
        //but sometimes we may have an expanded path in m_szCurrentPath
        //e.g. if some User Shell Folder values are missing. So expand
        //the last redirected path and compare it with the current path
        Path.Length = (wcslen (m_szLastRedirectedPath) + 1) * sizeof (WCHAR);
        Path.MaximumLength = sizeof (m_szLastRedirectedPath);
        Path.Buffer = m_szLastRedirectedPath;

        ExpandedPath.Length = 0;
        ExpandedPath.MaximumLength = sizeof (wszExpandedPath);
        ExpandedPath.Buffer = wszExpandedPath;

        Status = RtlExpandEnvironmentStrings_U (
                      m_pFileDB->_pEnvBlock,
                      &Path,
                      &ExpandedPath,
                      NULL
                      );
        if (ERROR_SUCCESS != Status)
            return TRUE;        //that's our best bet in case of failure

        //
        // Now process the paths so that they do not contain any redundant
        // slashes etc.
        //
        if (NULL == _wfullpath (wszProcessedSource, m_szCurrentPath, MAX_PATH))
        {
            return TRUE;
        }
        else
        {
            //
            // Eliminate any trailing slashes. Note: after going through
            // _wfullpath, there can be at the most one trailing slash
            //
            len = lstrlen (wszProcessedSource);
            if (L'\\' == wszProcessedSource[len-1])
                wszProcessedSource[len - 1] = L'\0';
        }

        if (NULL == _wfullpath (wszProcessedDest, wszExpandedPath, MAX_PATH))
        {
            return TRUE;
        }
        else
        {
            //
            // Eliminate any trailing slashes. Note: after going through
            // _wfullpath, there can be at the most one trailing slash
            //
            len = lstrlen (wszProcessedDest);
            if (L'\\' == wszProcessedDest[len-1])
                wszProcessedDest[len - 1] = L'\0';
        }

        // Now that we have the nice compact paths, we compare them.
        if (0 != _wcsicmp (wszProcessedSource, wszProcessedDest))
            return TRUE;
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   saves settings back to the local settings
//
//  Arguments:  [in] pwszPath : the path to which the folder was redirected
//              [in] dwFlags  : the flags that were used for redirection
//              [in] pSid     : the Sid of the group that was used for
//                              redirection. If this is NULL, then we
//                              default to the Sid for everyone : S-1-1-0
//
//  Returns:    ERROR_SUCCESS if everything was successful or an error code.
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::Save (const WCHAR * pwszPath, DWORD dwFlags, PSID pSid, const WCHAR * pszGPOName)
{
    WCHAR *         pwszSection = NULL;
    UNICODE_STRING  StringW;
    WCHAR           pwszFlags [ MAX_PATH ];
    UINT            len;
    int             homedirInfoLen = 0;
    WCHAR *         pszCurr;
    WCHAR           pwszSid [ MAX_PATH ];
    DWORD           Status;
    BOOL            bStatus;
    ULONG           ulUserNameInfoLen;
    const WCHAR *   wszHomedir = NULL;
    BOOL            bSaveHomedir = FALSE;

    //
    // First determine if the homedir value needs to be saved.
    // We need to do this first so that we can add the necessary value to the
    // buffer.
    if (IsHomedirPath (m_rID, pwszPath, TRUE) ||
        IsHomedirPolicyPath (m_rID, pwszPath, TRUE))
    {
        wszHomedir = gUserInfo.GetHomeDir (Status);
        if (ERROR_SUCCESS != Status ||
            ! wszHomedir ||
            L'\0' == *wszHomedir)
        {
            Status = (ERROR_SUCCESS == Status) ? ERROR_BAD_PATHNAME : Status;
            goto SaveSettings_End;
        }

        // If we are here, then we need to save the homedir value
        bSaveHomedir = TRUE;
        homedirInfoLen = wcslen (wszHomedir) + 9;   // 8 chars for Homedir=
                                                    // + 1 for the terminating NULL
    }

    //caclulate the # of characters required to store UserName=<username>
    //including the terminating NULL character.
    ulUserNameInfoLen = wcslen (gwszUserName) + 10; //9 chars for Username=
                                                    //+ 1 terminating NULL

    //don't need to calculate the exact length, this will be more than enough
    pwszSection = new WCHAR[sizeof(WCHAR) * ((len = wcslen(pwszPath)) +
                                             homedirInfoLen +
                                             2 * MAX_PATH +
                                             ulUserNameInfoLen +
                                             50)];

    if (NULL == pwszSection)
    {
        Status = ERROR_OUTOFMEMORY;
        goto SaveSettings_End;
    }

    pwszFlags[0] = L'\0';
    StringW.Length = 0;
    StringW.MaximumLength = sizeof (pwszFlags);
    StringW.Buffer = pwszFlags;

    RtlIntegerToUnicodeString (dwFlags, 16, &StringW);

    wcscpy (pwszSection, L"Username=");
    wcscat (pwszSection, gwszUserName);
    pszCurr = pwszSection + ulUserNameInfoLen;
    // Save the homedir value only if the redirection destination is the homedir.
    if (bSaveHomedir)
    {
        wcscpy (pszCurr, L"Homedir=");
        wcscat (pszCurr, wszHomedir);
        pszCurr += homedirInfoLen;
    }
    wcscpy (pszCurr, L"Path=");
    if (IsHomedirPolicyPath (m_rID, pwszPath, TRUE))
    {
        wcscat (pszCurr, &pwszPath[2]);
        pszCurr += 6 + (len - 2);
    }
    else
    {
        wcscat (pszCurr, pwszPath);
        pszCurr += 6 + len;
    }
    wcscpy (pszCurr, L"Flags=");
    wcscat (pszCurr, pwszFlags);
    pszCurr += (7 + StringW.Length/sizeof(WCHAR));
    wcscpy (pszCurr, L"Group=");

    //now we set the sid to everyone (that is the safest) if no sid has been
    //specified or if we are unable to convert the supplied sid into a string.
    Status = ERROR_INVALID_SID; //just some error code
    if (pSid)
    {
        pwszSid [0] = L'\0';
        StringW.Length = 0;
        StringW.MaximumLength = sizeof (pwszSid);
        StringW.Buffer = pwszSid;

        Status = RtlConvertSidToUnicodeString (&StringW, pSid, FALSE);
    }

    if (ERROR_SUCCESS != Status)
        wcscpy (pwszSid, L"S-1-1-0");   //use the sid for everyone if we can't find anything else

    wcscat (pszCurr, pwszSid);
    //add an extra terminating NULL
    pszCurr += (7 + wcslen (pwszSid));

    //add the GPO if there is a valid one.
    if (pszGPOName)
    {
        wcscpy (pszCurr, L"GPO=");
        wcscat (pszCurr, pszGPOName);
        pszCurr += (5 + wcslen (pszGPOName));
    }

    //add an extra null character at the end.
    *pszCurr = L'\0';

    //before writing to the ini file, we must pre-create it in Unicode,
    //otherwise, the WritePrivate* APIs will write the file in ANSI, which
    //will break folder redirection in international/ML builds.
    PrecreateUnicodeIniFile (m_szSavedSettingsPath);

    Status = ERROR_SUCCESS;
    //now we can go ahead and save the section
    //first empty the section
    bStatus = WritePrivateProfileSection (
                   g_szDisplayNames[(int) m_rID],
                   NULL,
                   m_szSavedSettingsPath
                   );
    //now write the actual section
    if (bStatus)
        bStatus = WritePrivateProfileSection (
                       g_szDisplayNames[(int) m_rID],
                       pwszSection,
                       m_szSavedSettingsPath
                       );

    if (!bStatus)
        Status = GetLastError();

SaveSettings_End:
    if (pwszSection)
        delete [] pwszSection;

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::HandleUserNameChange
//
//  Synopsis:   this function handles any changes in the user name that
//              have occurred since the last logon. in case the username has
//              changed since the last logon, this function renames any
//              folders redirected earlier using the %username% variable so
//              that the path that the redirected folder points to is continues
//              to be valid.
//
//  Arguments:  [in] pFileDB : point to the CFileDB object.
//
//  Returns:    ERROR_SUCCESS if everything worked properly
//              an error code otherwise.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:      a failed rename is not considered a failure. in this case,
//              an event is logged and the code ensures that redirection
//              is not attempted if there is a simultaneous change in the
//              redirection policies.
//
//              in this way a failed rename for one folder does not hold up
//              the redirection of other folders which might be independent of
//              this particular folder.
//---------------------------------------------------------------------------
DWORD CSavedSettings::HandleUserNameChange (CFileDB * pFileDB,
                                            CRedirectInfo * pRedir)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   RedirStatus = ERROR_SUCCESS;
    WCHAR   wszLastPath [TARGETPATHLIMIT];
    WCHAR   wszExpandedSource [TARGETPATHLIMIT];
    WCHAR   wszExpandedDest [TARGETPATHLIMIT];
    WCHAR   wszRenamePart [TARGETPATHLIMIT];
    WCHAR   wszExpandedRenameSource [TARGETPATHLIMIT];
    WCHAR   wszExpandedRenameDest [TARGETPATHLIMIT];
    WCHAR * wszTemp = NULL;
    WCHAR * wszEnd = NULL;
    SHARESTATUS SourceStatus;
    SHARESTATUS DestStatus;
    BOOL    bRenamePerformed = FALSE;


    if ((! m_bUserNameChanged)    ||
        pRedir->WasRedirectionAttempted() ||
        (REDIR_DONT_CARE & m_dwFlags))
    {
        goto HandleUPNChangeEnd;//nothing to do if the username has not changed
                                //since the last logon or if the rename has
                                //already been attempted. Even if the attempted
                                //redirection had failed, it is not fatal.
                                //similarly, if policy didn't set the location
                                //of the folder last time, we don't care.
    }

    if (Programs == m_rID ||  //since programs and startup always follow the
        Startup == m_rID      //Start Menu, rename of Start Menu handles these
                              //folders automatically
        )
    {
        goto HandleUPNChangeEnd;
    }

    //show additional status messages if the verbose status is on.
    DisplayStatusMessage (IDS_REDIR_CALLBACK);
    DebugMsg ((DM_VERBOSE, IDS_UPN_CHANGE, pRedir->GetLocalizedName(), m_szLastUserName, gwszUserName));

    //okay, so there is a change in the user name and policy did care about the
    //the location. check if last path contained the username. if not, we have
    //nothing more to do.
    if (TARGETPATHLIMIT <= wcslen (m_szLastRedirectedPath))
    {
        gpEvents->Report (
                EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                3,
                pRedir->GetLocalizedName(),
                m_szLastRedirectedPath,
                NumberToString ( TARGETPATHLIMIT )
                );
        pRedir->PreventRedirection (STATUS_BUFFER_TOO_SMALL);
        goto HandleUPNChangeEnd;
    }
    wcscpy (wszLastPath, m_szLastRedirectedPath);
    _wcslwr (wszLastPath);

    wszTemp = wcsstr (wszLastPath, L"%username%");

    if (NULL == wszTemp)
        goto HandleUPNChangeEnd;    //there is no %username% string, we are
                                    //done. no rename is required.

    //get the part that needs to be renamed.
    wcscpy (wszRenamePart, wszLastPath);
    wszEnd = wcschr (wszRenamePart + (wszTemp - wszLastPath), L'\\');
    if (wszEnd)
        *wszEnd = L'\0';

    //get expanded versions of the paths -- using the new username and the old
    //username
    wszTemp = wszLastPath;
    RedirStatus = ExpandPathSpecial (pFileDB, wszLastPath, m_szLastUserName, wszExpandedSource);
    if (ERROR_SUCCESS == RedirStatus)
    {
        RedirStatus = ExpandPathSpecial (pFileDB, wszLastPath, gwszUserName, wszExpandedDest);
    }
    if (ERROR_SUCCESS == RedirStatus)
    {
        wszTemp = wszRenamePart;
        RedirStatus = ExpandPathSpecial (pFileDB, wszRenamePart, m_szLastUserName, wszExpandedRenameSource);
    }
    if (ERROR_SUCCESS == RedirStatus)
    {
        RedirStatus = ExpandPathSpecial (pFileDB, wszRenamePart, gwszUserName, wszExpandedRenameDest);
    }

    if (STATUS_BUFFER_TOO_SMALL == RedirStatus)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                3,
                pRedir->GetLocalizedName(),
                wszTemp,
                NumberToString ( TARGETPATHLIMIT )
                );
        pRedir->PreventRedirection (STATUS_BUFFER_TOO_SMALL);
        goto HandleUPNChangeEnd;
    }
    else if (ERROR_SUCCESS != RedirStatus)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                2,
                pRedir->GetLocalizedName(),
                StatusToString ( RedirStatus )
                );
        pRedir->PreventRedirection (RedirStatus);
        goto HandleUPNChangeEnd;
    }

    //get the online/offline status of the shares.
    SourceStatus = GetCSCStatus (wszExpandedRenameSource);
    DestStatus = GetCSCStatus (wszExpandedRenameDest);

    if (ShareOffline == Status || ShareOffline == DestStatus)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_OFFLINE,
                3,
                pRedir->GetLocalizedName(),
                wszExpandedSource,
                wszExpandedDest
                );
        pRedir->PreventRedirection (ERROR_CSCSHARE_OFFLINE);
        goto HandleUPNChangeEnd;
    }

    //we are finally ready to rename. first make sure that the source exists.
    //sometimes an earlier rename operation might have already renamed this
    //folder
    RedirStatus = ERROR_SUCCESS;
    if (0xFFFFFFFF == GetFileAttributes(wszExpandedRenameSource))
    {
        RedirStatus = GetLastError();
    }
    if (ERROR_FILE_NOT_FOUND != RedirStatus)
    {
        bStatus = MoveFile (wszExpandedRenameSource, wszExpandedRenameDest);
        if (!bStatus)
        {
            RedirStatus = GetLastError();
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_FAIL,
                    4,
                    pRedir->GetLocalizedName(),
                    StatusToString (RedirStatus),
                    wszExpandedSource,
                    wszExpandedDest
                    );
            pRedir->PreventRedirection (RedirStatus);
            goto HandleUPNChangeEnd;
        }
    }

    //the rename was successful. now rename the CSC cache.
    if (ShareOnline == SourceStatus)
    {
        MoveDirInCSC (wszExpandedSource, wszExpandedDest, NULL, SourceStatus, DestStatus, TRUE, TRUE);
        DeleteCSCShareIfEmpty (wszExpandedSource, SourceStatus);
    }
    bRenamePerformed = TRUE;

HandleUPNChangeEnd:
    if (m_bUserNameChanged && ERROR_SUCCESS == pRedir->GetRedirStatus())
    {
        UpdateUserNameInCache();
        if (bRenamePerformed)
        {
            gpEvents->Report(
                    EVENT_FDEPLOY_FOLDER_REDIRECT,
                    3,
                    pRedir->GetLocalizedName(),
                    wszExpandedSource,
                    wszExpandedDest);
        }
    }
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::UpdateUserNameInCache
//
//  Synopsis:   updates the user name in the cache with the new username
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS : if successful.
//              an error code otherwise.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::UpdateUserNameInCache (void)
{
    BOOL    bStatus;

    bStatus = WritePrivateProfileString (
                     g_szDisplayNames[(int) m_rID],
                     L"UserName",
                     gwszUserName,
                     m_szSavedSettingsPath
                     );

    if (!bStatus)
        return GetLastError();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpext\fdeploy\util.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  util.cxx
//
//*************************************************************

#include "fdeploy.hxx"

WCHAR* NTPrivs[] = {
    /*SE_CREATE_TOKEN_NAME,
    SE_ASSIGNPRIMARYTOKEN_NAME,
    SE_LOCK_MEMORY_NAME,
    SE_INCREASE_QUOTA_NAME,
    SE_UNSOLICITED_INPUT_NAME,
    SE_MACHINE_ACCOUNT_NAME,
    SE_TCB_NAME,
    SE_SECURITY_NAME,*/
    SE_TAKE_OWNERSHIP_NAME,     //we only need take ownership privileges
    /*SE_LOAD_DRIVER_NAME,
    SE_SYSTEM_PROFILE_NAME,
    SE_SYSTEMTIME_NAME,
    SE_PROF_SINGLE_PROCESS_NAME,
    SE_INC_BASE_PRIORITY_NAME,
    SE_CREATE_PAGEFILE_NAME,
    SE_CREATE_PERMANENT_NAME,
    SE_BACKUP_NAME,*/
    SE_RESTORE_NAME,            //we only need to be able to assign owners
    /*SE_SHUTDOWN_NAME,
    SE_DEBUG_NAME,
    SE_AUDIT_NAME,
    SE_SYSTEM_ENVIRONMENT_NAME,
    SE_CHANGE_NOTIFY_NAME,
    SE_REMOTE_SHUTDOWN_NAME,*/
    L"\0"
};

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::CCopyFailData
//
//  Synopsis:   constructor for the object that contains data about
//              copy failures.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CCopyFailData::CCopyFailData () : m_bCopyFailed (FALSE), m_dwSourceBufLen (0),
                                  m_pwszSourceName (NULL), m_dwDestBufLen (0),
                                  m_pwszDestName (NULL)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::~CCopyFailData
//
//  Synopsis:   destructor for the object that contains data about the last
//              copy failure
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CCopyFailData::~CCopyFailData ()
{
    if (m_dwSourceBufLen)
        delete [] m_pwszSourceName;

    if (m_dwDestBufLen)
        delete [] m_pwszDestName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::RegisterFailure
//
//  Synopsis:   registers information about a failed copy.
//
//  Arguments:  [in] pwszSource : the source file for the copy.
//              [in] pwszDest : the destination file for the copy.
//
//  Returns:    ERROR_SUCCESS : on succesful registration.
//              an error code otherwise.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:      if another failure has already been registered in this
//              object, it is not overwritten with the new info. We only
//              keep track of the first failure. Since folder redirection
//              anyway bails out on the first copy failure, we don't really
//              expect this function to be called more than once.
//
//---------------------------------------------------------------------------
DWORD CCopyFailData::RegisterFailure (LPCTSTR pwszSource, LPCTSTR pwszDest)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwFromLen = 0;
    DWORD   dwToLen = 0;

    //bail out if another copy failure has already been registered.
    if (m_bCopyFailed)
        return dwStatus;

    //first copy the source info.
    dwFromLen = wcslen (pwszSource);
    if (dwFromLen >= m_dwSourceBufLen)
    {
        //we need a bigger buffer.
        delete [] m_pwszSourceName;
        m_dwSourceBufLen = 0;
        m_pwszSourceName = new WCHAR [dwFromLen + 1];
        if (m_pwszSourceName)
            m_dwSourceBufLen = dwFromLen + 1;
        else
            dwStatus = ERROR_OUTOFMEMORY;
    }
    if (ERROR_SUCCESS == dwStatus)
        wcscpy (m_pwszSourceName, pwszSource);

    //now copy the destination info.
    if (ERROR_SUCCESS == dwStatus)
    {
        dwToLen = wcslen (pwszDest);
        if (dwToLen >= m_dwDestBufLen)
        {
            //we need a bigger buffer
            delete [] m_pwszDestName;
            m_dwDestBufLen = 0;
            m_pwszDestName = new WCHAR [dwToLen + 1];
            if (m_pwszDestName)
                m_dwDestBufLen = dwToLen + 1;
            else
                dwStatus = ERROR_OUTOFMEMORY;
        }
    }

    if (ERROR_SUCCESS == dwStatus)
        wcscpy (m_pwszDestName, pwszDest);

    //register the fact that the copy fail data has been
    //successfully incorporated into the object
    if (ERROR_SUCCESS == dwStatus)
        m_bCopyFailed = TRUE;

    return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::IsCopyFailure
//
//  Synopsis:   indicates if copy failure data exists within the object.
//
//  Arguments:  none.
//
//  Returns:    TRUE / FALSE : self-explanatory
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CCopyFailData::IsCopyFailure (void)
{
    return m_bCopyFailed;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::GetSourceName
//
//  Synopsis:   gets the name of the source file of the failed copy.
//
//  Arguments:  none.
//
//  Returns:    name of the source file of the failed copy.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:      returns NULL if the data does not exist or if a
//              copy failure has not been incorporated into the object
//
//---------------------------------------------------------------------------
LPCTSTR CCopyFailData::GetSourceName (void)
{
    if (! m_bCopyFailed)
        return NULL;

    if (! m_dwSourceBufLen)
        return NULL;

    return m_pwszSourceName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::GetDestName
//
//  Synopsis:   gets the name of the destination file of the failed copy.
//
//  Arguments:  none.
//
//  Returns:    name of the destination file of the failed copy.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:      returns NULL if the data does not exist or if a copy failure
//              has not been incorporated into the object.
//
//---------------------------------------------------------------------------
LPCTSTR CCopyFailData::GetDestName (void)
{
    if (! m_bCopyFailed)
        return NULL;

    if (! m_dwDestBufLen)
        return NULL;

    return m_pwszDestName;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsOnNTFS
//
//  Synopsis:   this function determines whether a given file/folder lies
//              on an NTFS volume or not.
//
//  Arguments:  [in] pwszPath : the full pathname of the file.
//
//  Returns:    ERROR_SUCCESS : if it is on NTFS
//              ERROR_NO_SECURITY_ON_OBJECT : if it is on FAT
//              other error codes if something goes wrong
//
//  History:    9/4/1998  RahulTh  created
//
//  Notes:
//              1. the full pathname is required in order to determine
//                 if the file/folder is on an NTFS volume
//              2. If the file/folder lies on a network share, then the
//                 share must be online when this function is executed.
//                 if it is offline and CSC is turned on, then even NTFS
//                 volumes will show up as FAT volumes.
//
//---------------------------------------------------------------------------
DWORD IsOnNTFS (const WCHAR* pwszPath)
{
    WCHAR*  szName = 0;
    DWORD   Status;
    size_t  len;
    BOOL    bAddSlash = FALSE;
    BOOL    bStatus;
    DWORD   dwFlags;
    WCHAR*  szLastSlash;
    WCHAR*  pwszSuccess = NULL;

    // Basic sanity checks
    if (NULL == pwszPath || L'\0' == *pwszPath)
    {
        return ERROR_BAD_PATHNAME;
    }
    
    //GetVolumeInformation requires its 1st argument to be terminated by a slash
    //so we first make sure that this is the case.
    len = wcslen (pwszPath);
    if ('\\' != pwszPath[len-1])
    {
        len++;
        bAddSlash = TRUE;
    }

    szName = (WCHAR*) alloca ((len + 1)*sizeof(WCHAR));
    if (0 == szName)
        return ERROR_OUTOFMEMORY;

    //obtain the absolute path
    pwszSuccess = _wfullpath (szName, pwszPath, len + 1);

    if (!pwszSuccess)
    {
        return ERROR_BAD_PATHNAME;  //_wfullpath will very rarely fail, but
                                    //never hurts to take precautions
    }

    if (bAddSlash)
    {
        szName[len] = '\0';
        szName[len-1] = '\\';
    }
    //now our path name is terminated by a slash, and we have the absolute path
    //too, so we don't have to worry about errors generating from weird paths
    //like \\server\share\hello\..\.\ etc...

    for (szLastSlash = szName + len - 1;;)
    {
        bStatus = GetVolumeInformation (szName, 0, 0, 0, 0, &dwFlags, 0, 0);
        if (!bStatus)
        {
            Status = GetLastError();
            if (ERROR_DIR_NOT_ROOT != Status)
            {
                return Status;
            }

            //GetVolumeInformation requires that the path provided to it be
            //the root of the volume. So if we are here, it means that the
            //function returned ERROR_DIR_NOT_ROOT. So we remove the last
            //component from the path and try with the smaller path. We repeat
            //this until we either succeed or end up with no path in which
            //case we return ERROR_INVALID_NAME
            *szLastSlash = '\0';
            szLastSlash = wcsrchr (szName, '\\');
            if (NULL == szLastSlash)
                return ERROR_INVALID_NAME;  //we have run out of components
            else
                szLastSlash[1] = '\0';  //get rid of the last component.
        }
        else
            break;
    }

    if (dwFlags & FS_PERSISTENT_ACLS)
        return ERROR_SUCCESS;           //NTFS supports persistent ACLs

    //if we are here, then GetVolumeInformation succeeded, but the volume
    //does not support persistent ACLs. So it must be a FAT volume.
    return ERROR_NO_SECURITY_ON_OBJECT;
}

//+--------------------------------------------------------------------------
//
//  Function:   ModifyAccessAllowedAceCounts
//
//  Synopsis:   given an ace, this function determines if the rights of this
//              ace apply to the object itself, propogates to its container
//              descendants and propogates to its non-container (or object)
//              descendants. It increments one or more of the provided counts
//              based on this.
//
//  Arguments:  [in] pAceHeader : pointer to the ACE header structure
//              [in,out] pCount : pointer to count which is incremented if the
//                                ACE applies to the object on whose ACL it is
//                                found
//              [in,out] pContainerCount : pointer to count which is incremented
//                                         if the ACE propagates to all
//                                         container descendants
//              [in,out] pObjectCount : pointer to count which is incremented if
//                                      the ACE propagates to all non-container
//                                      descendants
//
//  Returns:    nothing
//
//  History:    9/4/1998  RahulTh  created
//
//  Notes:      inheritance of the ace is not counted if the
//              NO_PROPAGATE_INHERIT_ACE flag is present.
//
//---------------------------------------------------------------------------
void
ModifyAccessAllowedAceCounts (
    PACE_HEADER pAceHeader,  LONG* pCount,
    LONG* pContainerCount,   LONG* pObjectCount
    )
{
    if (! (INHERIT_ONLY_ACE & pAceHeader->AceFlags))
        (*pCount)++;

    if (NO_PROPAGATE_INHERIT_ACE & pAceHeader->AceFlags)
        return;     //the rights of this Ace will not be propagated all the way

    if (CONTAINER_INHERIT_ACE & pAceHeader->AceFlags)
        (*pContainerCount)++;

    if (OBJECT_INHERIT_ACE & pAceHeader->AceFlags)
        (*pObjectCount)++;

    return;
}


//+--------------------------------------------------------------------------
//
//  Function:   RestrictMyDocsRedirection
//
//  Synopsis:   Disables/Enables the ability of users to redirect the
//              "My Documents" folder
//
//  Arguments:  [in] fRestrict : Disable if TRUE, Enable if FALSE
//
//  Returns:    ERROR_SUCCESS : on success
//              *OR* other Win32 error codes based on the error that occurred
//
//  History:    8/25/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD RestrictMyDocsRedirection (
            HANDLE      hToken,
            HKEY        hKeyRoot,
            BOOL        fRestrict
            )
{
    HKEY    hkRoot;
    HANDLE  hUserToken;
    HKEY    hkPolicies;
    HKEY    hkExplorer;
    DWORD   Status;

    hkRoot = hKeyRoot;
    hUserToken = hToken;

    //
    // This policies key is secured, so we must do this as LocalSystem.
    //
    RevertToSelf();

    Status = RegCreateKeyEx(
                hkRoot,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies",
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ | KEY_WRITE,
                NULL,
                &hkPolicies,
                NULL );

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegCreateKeyEx(
                    hkPolicies,
                    L"Explorer",
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hkExplorer,
                    NULL );

        RegCloseKey( hkPolicies );
    }

    if ( ERROR_SUCCESS == Status )
    {
        if ( fRestrict )
        {
            Status = RegSetValueEx(
                        hkExplorer,
                        L"DisablePersonalDirChange",
                        0,
                        REG_DWORD,
                        (PBYTE) &fRestrict,
                        sizeof(fRestrict) );
        }
        else
        {
            RegDeleteValue( hkExplorer, L"DisablePersonalDirChange" );
        }

        RegCloseKey( hkExplorer );
    }

    //now that the keys have been modified, return to impersonation.
    if (!ImpersonateLoggedOnUser( hUserToken ))
        Status = GetLastError();

    if ( ERROR_SUCCESS == Status )
    {
        if ( fRestrict )
        {
            DebugMsg((DM_VERBOSE, IDS_MYDOCSRESTRICT_ON));
        }
        else
        {
            DebugMsg((DM_VERBOSE, IDS_MYDOCSRESTRICT_OFF));
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GroupInList
//
//  Synopsis:   given a group sid in string format, and a list of group sids
//              in PTOKEN_GROUPS format, this function figures out if the
//              give sid belongs to that list
//
//  Arguments:  [in] pwszSid : the given sid in string format
//              [in] PTOKEN_GROUPS : a list of group sids
//
//  Returns:    TRUE : if the group is found in the list
//              FALSE : otherwise. FALSE is also returned if an error occurs
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL GroupInList (WCHAR * pwszSid, PTOKEN_GROUPS pGroups)
{
    ASSERT (pwszSid);

    PSID    pSid = 0;
    DWORD   Status;
    BOOL    bStatus = FALSE;
    DWORD   i;

    //optimization for the basic case
    if (0 == lstrcmpi (pwszSid, L"s-1-1-0")) //if the user is an earthling
    {
        bStatus = TRUE;
        goto GroupInListEnd;
    }

    Status = AllocateAndInitSidFromString (pwszSid, &pSid);

    if (ERROR_SUCCESS != Status)
        goto GroupInListEnd;

    for (i = 0, bStatus = FALSE;
         i < pGroups->GroupCount && !bStatus;
         i++
        )
    {
        bStatus = RtlEqualSid (pSid, pGroups->Groups[i].Sid);
    }


GroupInListEnd:
    if (pSid)
        RtlFreeSid (pSid);
    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    pSidStr = new WCHAR [lstrlen (lpszSidStr) + 1];
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    lstrcpy (pSidStr, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        delete [] pSidStr;
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = wcslen (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = new WCHAR [len + 1];

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    lstrcpy (pwszNumStr, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        delete [] pwszNumStr;
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyProgressRoutine
//
//  Synopsis:   this is a callback function for PrivCopyFileExW. It is used
//              to track errors that are considered fatal by the folder
//              redirection client. In many cases, PrivCopyFileExW will succeed
//              even if a certain operation like encryption fails. The only
//              way a calling prgram can find out about this is through this
//              callback function by looking at the reason for the callback.
//              currently, the only 3 reasons that are considered fatal for
//              redirection are PRIVCALLBACK_ENCRYPTION_FAILED and
//              PRIVCALLBACK_DACL_ACCESS_DENIED and
//              PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED. All other reasons will
//              either not occur, or can be safely ignored.
//
//              The data passed via lpData is actually a pointer to a DWORD
//              that this callback function uses to store an error code if one
//              occurs.
//
//  Arguments:  see sdk help on CopyProgressRoutine
//
//  Returns:    see sdk help on CopyProgressRoutine
//
//  History:    10/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CALLBACK CopyProgressRoutine (
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD         dwStreamNumber,
    DWORD         dwCallbackReason,
    HANDLE        hSourceFile,
    HANDLE        hDestinationFile,
    LPVOID        lpData
    )
{
    LPDWORD lpStatus = (LPDWORD) lpData;

    //an error condition has already been registered. No need to invoke
    //this callback again
    if (ERROR_SUCCESS != *lpStatus)
        return PROGRESS_QUIET;

    switch (dwCallbackReason)
    {
    case PRIVCALLBACK_ENCRYPTION_FAILED:
        *lpStatus = ERROR_ENCRYPTION_FAILED;
        return PROGRESS_CANCEL; //no point continuing. we have already failed
    case PRIVCALLBACK_DACL_ACCESS_DENIED:
        *lpStatus = ERROR_INVALID_SECURITY_DESCR;
        return PROGRESS_CANCEL; //same as above
    case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        *lpStatus = ERROR_INVALID_OWNER;
        return PROGRESS_CANCEL;
    default:
        return PROGRESS_CONTINUE;   //all other conditions can be safely ignored
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   FullFileCopyW
//
//  Synopsis:   this function makes use of the internal API PrivCopyFileExW
//              to copy not only the contents of a file but also metadata
//              like encryption, compression and DACL
//
//              This function also imposes limits on the lengths of the files
//              that can be copied. Anything longer than MAX_PATH is disallowed
//              because the shell cannot gracefully handle such paths and we
//              don't want to create problems for the user by redirecting their
//              files to paths that explorer cannot get to.
//
//  Arguments:  [in] wszSource : the path of the source file.
//              [in] wszDest : the path of the destination file.
//              [in] bFailIfExists : whether the function should fail if
//                                   the destination exists
//
//  Returns:    ERROR_SUCCESS : if successful
//              ERROR_ENCRYPTION_FAILED : if the source is encrypted and
//                                        the destination cannot be encrypted
//              ERROR_INVALID_SECURITY_DESCR: if the DACL of the source cannot
//                                            be copied over to the destination
//              ERROR_FILE_EXISTS / ERROR_ALREADY_EXISTS : if the destination
//                                             exists and bFailIfExists is TRUE
//              ERROR_INVALID_OWNER : if the owner info. cannot be copied
//              or other error codes.
//
//              ERROR_FILENAME_EXCED_RANGE : if the filename is longer than MAX_PATH.
//
//  History:    10/22/1998  RahulTh  created
//              12/13/2000  RahulTh  added length limitations
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD FullFileCopyW (
    const WCHAR*  wszSource,
    const WCHAR*  wszDest,
    BOOL          bFailIfExists
    )
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwFlags = PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_OWNER_GROUP;
    BOOL    bCancel = FALSE;
    BOOL    bStatus;
    int     lenSource = 0;
    int     lenDest = 0;
    
    if (bFailIfExists)
        dwFlags |= COPY_FILE_FAIL_IF_EXISTS;

    if (! wszSource)
        lenSource = wcslen (wszSource);
    
    if (! wszDest)
        lenDest = wcslen (wszDest);
    
    //
    // Prevent copying of files longer than MAX_PATH characters. This limitation
    // needs to be added because the shell cannot handle paths longer than
    // MAX_PATH gracefully and we don't want to land the users into trouble by
    // creating files / folder that they cannot get to via explorer.
    //
    if (lenDest >= MAX_PATH || lenSource >= MAX_PATH)
        return ERROR_FILENAME_EXCED_RANGE;

    bStatus = PrivCopyFileExW (wszSource, wszDest,
                               (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                               (LPVOID) &Status,
                               &bCancel,
                               dwFlags
                              );

    //get the last error if PrivCopyFileExW failed
    //and the callback function has not already registered a fatal error
    if ((ERROR_SUCCESS == Status) && (!bStatus))
        Status = GetLastError();

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   FullDirCopyW
//
//  Synopsis:   creates a directory using the new PrivCopyFileExW so that
//              all the file metadata and ownership information is retained
//
//              This function also imposes limits on the lengths of the folders
//              that can be copied. Anything longer than MAX_PATH is disallowed
//              because the shell cannot gracefully handle such paths and we
//              don't want to create problems for the user by redirecting their
//              files to paths that explorer cannot get to.
//
//  Arguments:  [in] pwszSource : the full path of the source directory
//              [in] pwszDest : the full path of the destination directory
//              [in] bSkipDacl : Skip DACL copying.
//
//  Returns:    ERROR_SUCCESS : if the copy was successful
//              ERROR_INVALID_SECURITY_DESCR : if the DACL could not be applied
//              ERROR_INVALID_OWNER : if the owner information could not be copied
//              ERROR_ENCRYPTION_FAILED : if the encryption info. could not be copied
//              or other error codes if some other error occurs
//              ERROR_FILENAME_EXCED_RANGE : if the filename is longer than MAX_PATH.
//
//  History:    11/5/1998  RahulTh  created
//              12/13/2000 RahulTh  added length limitations
//              5/2/2002   RahulTh  added the skip DACL flag
//
//  Notes:      Essentially the same as FullFileCopyW, but we have an extra
//              attribute to indicate that we are trying to copy a directory
//              Also, the FAIL_IF_EXSTS flag doesn't have any significance
//              when we are trying to copy directories, so that is something
//              we do not need here.
//
//---------------------------------------------------------------------------
DWORD FullDirCopyW (const WCHAR* pwszSource, const WCHAR* pwszDest, BOOL bSkipDacl)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwFlags = PRIVCOPY_FILE_METADATA |
                        PRIVCOPY_FILE_OWNER_GROUP | PRIVCOPY_FILE_DIRECTORY;
    BOOL    bCancel = FALSE;
    BOOL    bStatus = TRUE;
    int     lenSource = 0;
    int     lenDest = 0;
    
    if (! pwszSource)
        lenSource = wcslen (pwszSource);
    
    if (! pwszDest)
        lenDest = wcslen (pwszDest);
    
    //
    // Prevent copying of files longer than MAX_PATH characters. This limitation
    // needs to be added because the shell cannot handle paths longer than
    // MAX_PATH gracefully and we don't want to land the users into trouble by
    // creating files / folder that they cannot get to via explorer.
    //
    if (lenDest >= MAX_PATH || lenSource >= MAX_PATH)
        return ERROR_FILENAME_EXCED_RANGE;

    if (bSkipDacl)
        dwFlags |= PRIVCOPY_FILE_SKIP_DACL;

    bStatus = PrivCopyFileExW (pwszSource, pwszDest,
                               (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                               (LPVOID) &Status,
                               &bCancel,
                               dwFlags
                              );

    //get the last error if PrivCopyFileExW failed
    //and the callback function has not already registered a fatal error
    if ((ERROR_SUCCESS == Status) && (!bStatus))
        Status = GetLastError();

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   FileInDir
//
//  Synopsis:   given a file and a directory, this function determines if
//              a file with the same name exists in the given directory.
//
//  Arguments:  [in] pwszFile : the name of the file : it can be the full path
//              [in] pwszDir : the directory for which the check needs to be
//                             performed
//              [out] pExists : if the function succeeds, this will contain
//                              the result. TRUE if the file is present in the
//                              directory. FALSE otherwise.
//
//  Returns:    ERROR_SUCCESS : if it is successful
//              ERROR_OUTOFMEMORY : if it runs out of memory
//              ERROR_BAD_NETPATH : if the network path for the given directory
//                                  cannot be found
//
//  History:    10/28/1998  RahulTh  created
//
//  Notes:      pwszDir MUST BE \ terminated
//
//---------------------------------------------------------------------------
DWORD FileInDir (LPCWSTR pwszFile, LPCWSTR pwszDir, BOOL* pExists)
{
    const WCHAR*  pwszFileName = NULL;
    WCHAR*  pwszDestName = NULL;
    int     len;

    //first get the display name of the source file
    pwszFileName = wcsrchr (pwszFile, L'\\');
    if (!pwszFileName)
        pwszFileName = pwszFile;
    else
        pwszFileName++; //go past the slash

    //the dir should be \ terminated
    len = wcslen (pwszFile) + wcslen (pwszDir) + 1;
    pwszDestName = (WCHAR*) alloca (sizeof (WCHAR) * len);
    if (!pwszDestName)
        return ERROR_OUTOFMEMORY;

    wcscpy (pwszDestName, pwszDir);
    wcscat (pwszDestName, pwszFileName);

    if (0xFFFFFFFF == GetFileAttributes(pwszDestName))
    {
        //return an error if it is a bad network name. Saves us the trouble
        //of trying to redirect to a non-existent location later
        if (ERROR_BAD_NETPATH == GetLastError())
            return ERROR_BAD_NETPATH;
        else
            *pExists = FALSE;
    }
    else
        *pExists = TRUE;

    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ComparePaths
//
//  Synopsis:   given 2 paths, this function compares them to check if
//              they are identical or if one is a descendant of the other
//              or if no such relationship can be deduced
//
//  Arguments:  [in] pwszSource : the first path
//              [in] pwszDest : the second path
//              [out] pResult : the result of the comparison if the function
//                              succeeds in comparing the paths.
//                    value of pResult may contain the following values upon
//                    successful completion.
//                      0 : if the 2 paths are identical
//                      -1 : if the second path is a descendant of the first
//                      1 : if no such relationship can be deduced
//
//  Returns:    ERROR_SUCCESS : if the function succeeds in comparing the paths
//              other error codes depending on the failure
//
//  History:    10/28/1998  RahulTh  created
//
//  Notes:      the result of the comparison is unreliable if the paths are
//              expressed in different formats, e.g. TCP/IP, UNC, NetBios etc.
//
//---------------------------------------------------------------------------
DWORD ComparePaths (LPCWSTR pwszSource, LPCWSTR pwszDest, int* pResult)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    WCHAR*  pwszAbsSource = NULL;
    WCHAR*  pwszAbsDest = NULL;
    int     lSource, lDest;
    WCHAR*  pwszSuccess = NULL;

    ASSERT (pResult);
    //first allocate memory for the absolute paths.
    //since the arguments to this function are full pathnames
    //the lengths of the absolute paths cannot exceed the length of
    //the parameters
    //add an extra character because we will add a \ to the end of the abs. path
    lSource = wcslen (pwszSource) + 2;
    pwszAbsSource = (WCHAR*) alloca (sizeof(WCHAR) * lSource);
    if (!pwszAbsSource)
    {
        Status = ERROR_OUTOFMEMORY;
        goto ComparePathsEnd;
    }
    //add an extra character because we will add a \ to the end of the abs. path
    lDest = wcslen (pwszDest) + 2;
    pwszAbsDest = (WCHAR*) alloca (sizeof(WCHAR) * lDest);
    if (!pwszAbsDest)
    {
        Status = ERROR_OUTOFMEMORY;
        goto ComparePathsEnd;
    }

    //first get the absolute paths. after that we will just work with the
    //absolute paths.
    //note: we need the absolute paths so that we can can check if one path
    //is a descendant of the other path by just using wcsncmp. without absolute
    //paths, wcsncmp cannot be used because we can have 2 paths like
    //\\server\share\hello\there and \\server\share\hello\..\hello\there\hi
    //in this case the second path is actually a descendant of the first, but
    //wcsncmp cannot detect that. getting the absolute paths will eliminate
    //the .., . etc.
    //also we must terminate the absolute paths with \, so that wcsncmp does
    //not mistakenly think that \\server\share\hellofubar is a descendant
    //of \\server\share\hello
    pwszSuccess = _wfullpath (pwszAbsSource, pwszSource, lSource);
    if (!pwszSuccess)
    {
        Status = ERROR_BAD_PATHNAME;
        goto ComparePathsEnd;
    }
    pwszSuccess = _wfullpath (pwszAbsDest, pwszDest, lDest);
    if (!pwszSuccess)
    {
        Status = ERROR_BAD_PATHNAME;
        goto ComparePathsEnd;
    }

    //update the lengths with the actual lengths of the absolute paths
    //not including the terminating null character
    lSource = wcslen (pwszAbsSource);
    lDest = wcslen (pwszAbsDest);

    //terminate the absolute paths with '\' if necessary. also make
    //the appropriate changes to the lengths
    if (L'\\' != pwszAbsSource[lSource - 1])
    {
        wcscat (pwszAbsSource, L"\\");  //we won't run out of space here
        //because of the extra character allocation
        lSource++;
    }
    if (L'\\' != pwszAbsDest[lDest - 1])
    {
        wcscat (pwszAbsDest, L"\\");    //won't run out of space here because
        //of the extra allocation above
        lDest++;
    }

    //now we are all set (finally!) to perform the comparisons

    //first do a simple check of whether the paths are identical
    if ((lSource == lDest) && (0 == _wcsicmp (pwszAbsSource, pwszAbsDest)))
    {
        *pResult = 0;
        goto ComparePathsSuccess;
    }

    //check for recursion
    if ((lDest > lSource) && (0 == _wcsnicmp (pwszAbsSource, pwszAbsDest, lSource)))
    {
        *pResult = -1;
        goto ComparePathsSuccess;
    }

    //if we are here, these paths are not identical...
    *pResult = 1;


ComparePathsSuccess:
    Status = ERROR_SUCCESS;
    goto ComparePathsEnd;

ComparePathsEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   CheckIdenticalSpecial
//
//  Synopsis:   given 2 paths, this function determines if they are actually
//              the same path expressed in 2 different formats
//
//  Arguments:  [in] pwszSource : path #1
//              [in] pwszDest   : path #2
//              [out] pResult   : result of the comparison
//
//  Returns:    ERROR_SUCCESS if the function could perform the comparison
//              in this case *pResult will contain the result of comparison
//              Other win32 errors, in which case *pResult should not be used
//              by the calling function
//
//  History:    12/1/1998  RahulTh  created
//
//  Notes:      this function expects both pwszSource and pwszDest to exist and
//              be online when it is called.
//
//---------------------------------------------------------------------------
DWORD CheckIdenticalSpecial (LPCWSTR pwszSource, LPCWSTR pwszDest, int* pResult)
{
    ASSERT (pResult);

    BOOL    bStatus;
    DWORD   Status;
    BOOL    bTempFileCreated = FALSE;
    WCHAR * pwszTempPath;
    UINT    lUnique = 0;
    BOOL    bFileExists;
    WCHAR * pwszSlashTerminatedDest;
    int     lDest;

    //first append a \ to pwszDest if it is not already \ terminated
    //allocate an extra characted just in case we need it
    pwszSlashTerminatedDest = (WCHAR *) alloca (sizeof (WCHAR) * ((lDest = wcslen(pwszDest)) + 2));

    if (!pwszSlashTerminatedDest)
    {
        Status = ERROR_OUTOFMEMORY;
        goto CheckIdenticalEnd;
    }

    wcscpy (pwszSlashTerminatedDest, pwszDest);
    if (L'\\' != pwszSlashTerminatedDest[lDest - 1])
    {
        wcscat (pwszSlashTerminatedDest, L"\\");
        lDest++;
    }

    pwszTempPath = (WCHAR*) alloca (sizeof (WCHAR) * (MAX_PATH + wcslen(pwszSource) + 2));
    if (!pwszTempPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto CheckIdenticalEnd;
    }

    if (0 == (lUnique = GetTempFileName(pwszSource, L"fde", 0, pwszTempPath)))
    {
        //a failure to create the temporary file would mean that the source
        //and destination paths are different...
        *pResult = 1;
        goto CheckIdenticalSuccess;
    }

    //now we have created a temporary file,
    bTempFileCreated = TRUE;

    //check if it exists on the destination
    //note: FileInDir requires that the path in the second parameter is
    //      slash terminated.
    Status = FileInDir (pwszTempPath, pwszSlashTerminatedDest, &bFileExists);

    if (Status != ERROR_SUCCESS)
        goto CheckIdenticalEnd;

    //if the file does not exist at the destination, we know that these 2 paths
    //are different. However, if the file does exist at the destination, we
    //need to watch out for the rare case that the file existed even before we
    //we created the temp file at the source. To do this, we must delete the
    //temp file from the source and make sure that it has indeed disappeared
    //from the destination
    if (!bFileExists)
    {
        *pResult = 1;
    }
    else
    {
        if (!DeleteFile(pwszTempPath))
            goto CheckIdenticalErr;

        //the file has been deleted
        bTempFileCreated = FALSE;
        //make sure that it has disappeared from the destination
        Status = FileInDir (pwszTempPath, pwszSlashTerminatedDest, &bFileExists);

        if (Status != ERROR_SUCCESS)
            goto CheckIdenticalEnd;

        if (bFileExists)
        {
            *pResult = 1;   //by some quirk of fate, a file by the same name as
                            //the tempfile preexisted on the destination, so
                            //in reality they are not the same share.
        }
        else
        {
            //the file has disappeared from the dest. this means that it was
            //indeed the same share
            *pResult = 0;
        }
    }

CheckIdenticalSuccess:
    Status = ERROR_SUCCESS;
    goto CheckIdenticalEnd;

CheckIdenticalErr:
    Status = GetLastError();

CheckIdenticalEnd:
    if (bTempFileCreated)
        DeleteFile (pwszTempPath);  //ignore any errors here.
    return Status;
}

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}


//*************************************************************
//
//  RegDelnodeRecurse()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values.
//              Called by RegDelnode
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     EricFlo    Created
//              11/5/98     RahulTh    Copied from EricFlo's code
//
//*************************************************************

BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    LPTSTR lpEnd;
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;

    //
    // First, see if we can delete the key without having
    // to recurse.
    //


    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }


    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    lpEnd = CheckSlash(lpSubKey);

    //
    // Enumerate the keys
    //

    dwSize = MAX_PATH;
    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                           NULL, NULL, &ftWrite);

    if (lResult == ERROR_SUCCESS) {

        do {

            lstrcpy (lpEnd, szName);

            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }

            //
            // Enumerate again
            //

            dwSize = MAX_PATH;

            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
                                   NULL, NULL, &ftWrite);


        } while (lResult == ERROR_SUCCESS);
    }

    lpEnd--;
    *lpEnd = TEXT('\0');


    RegCloseKey (hKey);


    //
    // Try again to delete the key
    //

    lResult = RegDeleteKey(hKeyRoot, lpSubKey);

    if (lResult == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
}

//*************************************************************
//
//  RegDelnode()
//
//  Purpose:    Deletes a registry key and all it's subkeys / values
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey to delete
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//              11/8/98     RahulTh    Copied from EricFlo's code
//
//*************************************************************

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    TCHAR szDelKey[2 * MAX_PATH];


    lstrcpy (szDelKey, lpSubKey);

    return RegDelnodeRecurse(hKeyRoot, szDelKey);

}

//+--------------------------------------------------------------------------
//
//  Function:   GetSetOwnerPrivileges
//
//  Synopsis:   tries to get privileges to set ownership
//
//  Arguments:  [in] hToken : handle to the token for which we are trying to
//                            obtain the privileges
//
//  Returns:    nothing
//
//  History:    11/6/1998  RahulTh  created
//
//  Notes:      this function never fails. It just tries its best to get all
//              NT privileges. It is not guaranteed that it will get all of
//              them, as it depends on the user's rights
//
//---------------------------------------------------------------------------
void GetSetOwnerPrivileges (HANDLE hToken)
{
    BOOL    bStatus;
    DWORD   Status;
    DWORD   Size = 0;
    DWORD   i;
    DWORD   privCount;
    PTOKEN_PRIVILEGES pPrivs = NULL;

    //try to get all the windows NT privileges.
    for (i=0, privCount=0; *NTPrivs[i]; i++)
        privCount++;

    Size = sizeof (LUID_AND_ATTRIBUTES) * (privCount - 1) +
                sizeof (TOKEN_PRIVILEGES);

    pPrivs = (PTOKEN_PRIVILEGES) alloca (Size);

    if (NULL == pPrivs)
        goto GetAllPrivsEnd;

    for (i=0, privCount = 0; *NTPrivs[i]; i++)
    {
        bStatus = LookupPrivilegeValue (NULL, NTPrivs[i],
                                        &(pPrivs->Privileges[privCount].Luid));
        if (!bStatus)
            continue;

        pPrivs->Privileges[privCount++].Attributes = SE_PRIVILEGE_ENABLED;
    }
    pPrivs->PrivilegeCount = privCount;

    AdjustTokenPrivileges (hToken,
                           FALSE,
                           pPrivs,
                           NULL, NULL, NULL
                           );

GetAllPrivsEnd:
    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   SafeGetPrivateProfileStringW
//
//  Synopsis:   a wrapper for GetPrivateProfileString which takes care of
//              all the error checks etc. so that functions that call
//              this routine won't have to do it.
//
//  Arguments:  very similar to GetPrivateProfileStringW
//
//  Returns:    ERROR_SUCCESS if successful. An error code otherwise
//              Also, upon successful return *pSize contains the size of
//              the data copied -- not including the terminating NULL
//              probably the only Error code this will ever return is
//              ERROR_OUTOFMEMORY
//
//  History:    11/19/1998  RahulTh  created
//              12/13/2000  RahulTh  made prefix happy by initializing vars.
//                                   which anyway get set by GetPrivateProfileString
//
//  Notes:      if *ppwszReturnedString has been allocated memory, it might
//              get freed by this function
//              this function also allocates memory for the data
//
//---------------------------------------------------------------------------
DWORD SafeGetPrivateProfileStringW (
             const WCHAR * pwszSection,
             const WCHAR * pwszKey,
             const WCHAR * pwszDefault,
             WCHAR **      ppwszReturnedString,
             DWORD *       pSize,
             const WCHAR * pwszIniFile
             )
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   retVal;

    *pSize = MAX_PATH;
    do
    {
        if (*ppwszReturnedString)
            delete [] *ppwszReturnedString;

        *ppwszReturnedString = new WCHAR [*pSize];

        if (!(*ppwszReturnedString))
        {
            Status = ERROR_OUTOFMEMORY;
            *pSize = 0;
            goto SafeGetEnd;
        }
        
        (*ppwszReturnedString)[0] = L'*';
        (*ppwszReturnedString)[1] = L'\0';
        

        retVal = GetPrivateProfileString (
                       pwszSection,
                       pwszKey,
                       pwszDefault,
                       *ppwszReturnedString,
                       *pSize,
                       pwszIniFile
                       );

        if (*pSize - 1 != retVal)
        {
            *pSize = retVal;
            break;
        }

        //if we are here, we need more memory
        //try with twice of what we had
        *pSize = (*pSize) * 2;

    } while ( TRUE );

SafeGetEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   MySidCopy
//
//  Synopsis:   copies sids and also allocates memory for the destination Sid
//
//  Arguments:  [out] ppDestSid : pointer the destination Sid;
//              [in] pSourceSid : the source Sid
//
//  Returns:    ERROR_SUCCESS if successful. an error code otherwise
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD MySidCopy (PSID * ppDestSid, PSID pSourceSid)
{
    DWORD Status;
    ULONG Size = 0;

    *ppDestSid = 0;

    if (!pSourceSid)
        return ERROR_SUCCESS;

    Size = RtlLengthSid (pSourceSid);

    if (!Size)
        return ERROR_SUCCESS;

    *ppDestSid = (PSID) new BYTE [Size];

    if (! (*ppDestSid))
        return ERROR_OUTOFMEMORY;

    return RtlCopySid (Size, *ppDestSid, pSourceSid);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetShareStatus
//
//  Synopsis:   this function is a wrapper for CSCQueryFileStatus.
//              basically CSCQueryFileStatus can fail if there was never a net
//              use to a share. So this function tries to create a net use to
//              the share if CSCQueryFileStatus fails and then re-queries the
//              file status
//
//  Arguments:  [in] pwszShare : the share name
//              [out] pdwStatus : the share Status
//              [out] pdwPinCount : the pin count
//              [out] pdwHints : the hints
//
//  Returns:    TRUE : if everything was successful.
//              FALSE : if there was an error. In this case, it GetLastError()
//                      will contain the specific error code.
//
//  History:    5/11/1999  RahulTh  created
//
//  Notes:      it is very important that this function be passed a share name
//              it does not do any parameter validation. So under no
//              circumstance should this function be passed a filename.
//
//---------------------------------------------------------------------------
BOOL GetShareStatus (const WCHAR * pwszShare, DWORD * pdwStatus,
                     DWORD * pdwPinCount, DWORD * pdwHints)
{
    NETRESOURCE nr;
    DWORD       dwResult;
    DWORD       dwErr = NO_ERROR;
    BOOL        bStatus;

    bStatus = CSCQueryFileStatus(pwszShare, pdwStatus, pdwPinCount, pdwHints);

    if (!bStatus)
    {
        //try to connect to the share
        ZeroMemory ((PVOID) (&nr), sizeof (NETRESOURCE));
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = (LPTSTR) pwszShare;
        nr.lpProvider = NULL;

        dwErr = WNetUseConnection(NULL, &nr, NULL, NULL, 0,
                                  NULL, NULL, &dwResult);

        if (NO_ERROR == dwErr)
        {
            bStatus = CSCQueryFileStatus (pwszShare, pdwStatus, pdwPinCount, pdwHints);
            if (!bStatus)
                dwErr = GetLastError();
            else
                dwErr = NO_ERROR;

            WNetCancelConnection2 (pwszShare, 0, FALSE);
        }
        else
        {
            bStatus = FALSE;
        }

    }

    SetLastError(dwErr);
    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetCSCStatus
//
//  Synopsis:   given a path, finds out if it is local and if it is not
//              whether it is online or offline.
//
//  Arguments:  [in] pwszPath : the path to the file
//
//  Returns:    Local/Online/Offline
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:      it is important that the path passed to this function is a
//              a full path and not a relative path
//
//              this function will return offline if the share is not live or
//              if the share is live but CSC thinks that it is offline
//
//              it will return PathLocal if the path is local or if the path
//              is a network path that cannot be handled by CSC e.g. a network
//              share with a pathname longer than what csc can handle or if it
//              is a netware share. in this case it makes sense to return
//              PathLocal because CSC won't maintain a database for these shares
//              -- same as for a local path. so as far as CSC is concerned, this
//              is as good as a local path.
//
//---------------------------------------------------------------------------
SHARESTATUS GetCSCStatus (const WCHAR * pwszPath)
{
    WCHAR * pwszAbsPath = NULL;
    WCHAR * pwszCurr = NULL;
    int     len;
    BOOL    bRetVal;
    DWORD   Status;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (!pwszPath)
        return ShareOffline;    //a path must be provided

    len = wcslen (pwszPath);

    pwszAbsPath = (WCHAR *) alloca (sizeof (WCHAR) * (len + 1));

    if (!pwszAbsPath)
    {
        //we are out of memory, so it is safest to return ShareOffline
        //so that we can bail out of redirection.
        return ShareOffline;
    }

    //get the absolute path
    pwszCurr = _wfullpath (pwszAbsPath, pwszPath, len + 1);

    if (!pwszCurr)
    {
        //in order for _wfullpath to fail, something really bad has to happen
        //so it is best to return ShareOffline so that we can bail out of
        //redirection
        return ShareOffline;
    }

    len = wcslen (pwszAbsPath);

    if (! (
           (2 <= len) &&
           (L'\\' == pwszAbsPath[0]) &&
           (L'\\' == pwszAbsPath[1])
           )
       )
    {
        //it is a local path if it does not begin with 2 backslashes
        return PathLocal;
    }

    //this is a UNC path; so extract the \\server\share part
    pwszCurr = wcschr ( & (pwszAbsPath[2]), L'\\');

    //first make sure that it is at least of the form \\server\share
    //watch out for the \\server\ case
    if (!pwszCurr || !pwszCurr[1])
        return ShareOffline;        //it is an invalid path (no share name)

    //the path is of the form \\server\share
    //note: the use _wfullpath automatically protects us against the \\server\\ case
    pwszCurr = wcschr (&(pwszCurr[1]), L'\\');
    if (pwszCurr)   //if it is of the form \\server\share\...
        *pwszCurr = L'\0';

    //now pwszAbsPath is a share name
    bRetVal = CSCCheckShareOnline (pwszAbsPath);

    if (!bRetVal)
    {
        if (!g_bCSCEnabled)
        {
            //CSC has not been enabled on this machine, so the fact that
            //CSC check share online failed means that the share is indeed
            //offline.
            return ShareOffline;
        }
        if (ERROR_SUCCESS != GetLastError())
        {
           //either there is really a problem (e.g. invalid share name) or
           //it is just a share that is not handled by CSC e.g. a netware share
           //or a share with a name that is longer than can be handled by CSC
           //so check if the share actually exists
           if (0xFFFFFFFF != GetFileAttributes(pwszAbsPath))
           {
              //this can still be a share that is offline since GetFileAttributes
              //will return the attributes stored in the cache
              Status = 0;
              bRetVal = GetShareStatus (pwszAbsPath, &Status, &dwPinCount,
                                            &dwHints);
              if (! bRetVal || (! (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & Status)))
                 return PathLocal;     //this is simply a valid path that CSC cannot handle
              else if (bRetVal &&
                       (FLAG_CSC_SHARE_STATUS_NO_CACHING ==
                            (FLAG_CSC_SHARE_STATUS_CACHING_MASK & Status)))
                  return PathLocal;     //CSC caching is not turned on for the share.
           }
        }

        //it is indeed an inaccessble share
        return ShareOffline;  //for all other cases, treat this as offline
    }
    else
    {
        if (!g_bCSCEnabled)
        {
            //CSC has not been enabled on this machine, so the fact that
            //CSCCheckShareOnline succeed means that the share is indeed
            //accessible. Since nothing can be cached, we must return
            //PathLocal here.
            return PathLocal;
        }
        //if we are here, it means that the share is live, but CSC might still
        //think that it is offline.
       Status = 0;
       bRetVal = GetShareStatus (pwszAbsPath, &Status, &dwPinCount,
                                     &dwHints);
       if (bRetVal && (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & Status))
          return ShareOffline;   //CSC thinks that the share is offline
       else if (bRetVal &&
                (FLAG_CSC_SHARE_STATUS_NO_CACHING ==
                            (FLAG_CSC_SHARE_STATUS_CACHING_MASK & Status)))
           return PathLocal;    //CSC caching is not turned on for the share
       else if (!bRetVal)
           return ShareOffline;

       //in all other cases, consider the share as online since
       //CSCCheckShareOnline has already returned TRUE
       return ShareOnline;
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   MoveDirInCSC
//
//  Synopsis:   this function moves a directory within the CSC cache without
//              prejudice. If the destination is a local path, it just deletes
//              the source tree from the cache
//
//  Arguments:  [in] pwszSource : the source path
//              [in] pwszDest   : the dest path
//              [in] pwszSkipSubdir : the directory to skip while moving
//              [in] StatusFrom : the CSC status of the source path
//              [in] StatusTo   : the CSC status of the dest. path
//              [in] bAllowRdrTimeout : if stuff needs to be deleted from the
//                              cache, we may not succeed immediately since
//                              the rdr keeps the handles to recently opened
//                              files open. This paramaters tells the function
//                              whether it needs to wait and retry
//
//  Returns:    nothing. it just tries its best.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:      the value of bAllowRdrTimeout is always ignored for the
//              in-cache rename operation. we always want to wait for
//              the timeout.
//
//---------------------------------------------------------------------------
void MoveDirInCSC (const WCHAR * pwszSource, const WCHAR * pwszDest,
                   const WCHAR * pwszSkipSubdir,
                   SHARESTATUS   StatusFrom, SHARESTATUS   StatusTo,
                   BOOL  bAllowRdrTimeoutForDel,
                   BOOL  bAllowRdrTimeoutForRen)
{
    WIN32_FIND_DATA findData;
    DWORD   dwFileStatus;
    DWORD   dwPinCount;
    HANDLE  hCSCFind;
    DWORD   dwHintFlags;
    FILETIME origTime;
    WCHAR * pwszPath;
    WCHAR * pwszEnd;
    int     len;
    DWORD   StatusCSCRen = ERROR_SUCCESS;

    if (!g_bCSCEnabled || PathLocal == StatusFrom)
        return;                 //there is nothing to do. nothing was cached.

    if (PathLocal == StatusTo)
    {
        //the destination is a local path, so we should just delete the
        //files from the source
        DeleteCSCFileTree (pwszSource, pwszSkipSubdir, bAllowRdrTimeoutForDel);
    }
    else
    {
        pwszPath = (WCHAR *) alloca (sizeof (WCHAR) * ((len = wcslen (pwszSource)) + MAX_PATH + 2));
        if (!pwszPath || len <= 0)
            return;
        wcscpy (pwszPath, pwszSource);
        pwszEnd = pwszPath + len;
        if (L'\\' != pwszEnd[-1])
        {
            *pwszEnd++ = L'\\';
        }
        hCSCFind = CSCFindFirstFile (pwszSource, &findData, &dwFileStatus,
                                     &dwPinCount, &dwHintFlags, &origTime);

        if (INVALID_HANDLE_VALUE != hCSCFind)
        {
            do
            {
                if (0 != _wcsicmp (L".", findData.cFileName) &&
                    0 != _wcsicmp (L"..", findData.cFileName) &&
                    (!pwszSkipSubdir || (0 != _wcsicmp (findData.cFileName, pwszSkipSubdir))))
                {
                    wcscpy (pwszEnd, findData.cFileName);
                    if (ERROR_SUCCESS == StatusCSCRen)
                    {
                        StatusCSCRen = DoCSCRename (pwszPath, pwszDest, TRUE, bAllowRdrTimeoutForRen);
                    }
                    else
                    {
                        //here we ignore the return value since an error has already occurred.
                        //and we do not wish to spend any more time in timeouts in any subsequent
                        //rename operation.
                        DoCSCRename (pwszPath, pwszDest, TRUE, FALSE);
                    }
                }

            } while ( CSCFindNextFile (hCSCFind, &findData, &dwFileStatus,
                                       &dwPinCount, &dwHintFlags, &origTime)
                     );

            CSCFindClose (hCSCFind);
        }

        //merge the pin info. at the top level folder
        MergePinInfo (pwszSource, pwszDest, StatusFrom, StatusTo);
    }

    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoCSCRename
//
//  Synopsis:   does a file rename within the CSC cache.
//
//  Arguments:  [in] pwszSource : full source path
//              [in] pwszDest : full path to destination directory
//              [in] bOverwrite : overwrite if the file/folder exists at
//                                  the destination
//              [in] bAllowRdrTimeout : if TRUE, retry for 10 seconds on failure
//                              so that rdr and mem. mgr. get enough time to
//                              release the handles.
//
//  Returns:    ERROR_SUCCESS if the rename was successful.
//              an error code otherwise.
//
//  History:    5/26/1999  RahulTh  created
//
//  Notes:      no validation of parameters is done. The caller is responsible
//              for that
//
//---------------------------------------------------------------------------
DWORD DoCSCRename (const WCHAR * pwszSource, const WCHAR * pwszDest,
                   BOOL bOverwrite, BOOL bAllowRdrTimeout)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    int     i;

    bStatus = CSCDoLocalRename (pwszSource, pwszDest, bOverwrite);
    if (!bStatus)
    {
        Status = GetLastError();
        if (ERROR_SUCCESS != Status &&
            ERROR_FILE_NOT_FOUND != Status &&
            ERROR_PATH_NOT_FOUND != Status &&
            ERROR_INVALID_PARAMETER != Status &&
            ERROR_BAD_NETPATH != Status)
        {
            if (bAllowRdrTimeout)
            {
                if (!bOverwrite && ERROR_FILE_EXISTS == Status)
                {
                    Status = ERROR_SUCCESS;
                }
                else
                {
                    for (i = 0; i < 11; i++)
                    {
                        Sleep (1000);   //wait for the handle to be released
                        bStatus = CSCDoLocalRename (pwszSource, pwszDest, bOverwrite);
                        if (bStatus)
                        {
                            Status = ERROR_SUCCESS;
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }

    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_CSCRENAME_FAIL, pwszSource, pwszDest, Status));
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCFileTree
//
//  Synopsis:   deletes a file tree from the CSC
//
//  Arguments:  [in] pwszSource : the path to the folder whose contents should
//                                be deleted
//              [in] pwszSkipSubdir : name of the subdirectory to be skipped.
//              [in] bAllowRdrTimeout : if true, makes multiple attempts to
//                              delete the file since the rdr may have left
//                              the handle open for sometime which can result
//                              in an ACCESS_DENIED message.
//
//  Returns:    ERROR_SUCCESS if the deletion was successful. An error code
//              otherwise.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DeleteCSCFileTree (const WCHAR * pwszSource, const WCHAR * pwszSkipSubdir,
                        BOOL bAllowRdrTimeout)
{
    WIN32_FIND_DATA findData;
    DWORD   dwFileStatus;
    DWORD   dwPinCount;
    HANDLE  hCSCFind;
    DWORD   dwHintFlags;
    FILETIME origTime;
    WCHAR * pwszPath;
    WCHAR * pwszEnd;
    int     len;
    DWORD   Status = ERROR_SUCCESS;

    if (! g_bCSCEnabled)
        return ERROR_SUCCESS;

    pwszPath = (WCHAR *) alloca (sizeof(WCHAR) * ((len = wcslen(pwszSource)) + MAX_PATH + 2));
    if (!pwszPath)
        return ERROR_OUTOFMEMORY;     //nothing much we can do if we run out of memory

    if (len <= 0)
        return ERROR_BAD_PATHNAME;

    wcscpy (pwszPath, pwszSource);
    pwszEnd = pwszPath + len;
    if (L'\\' != pwszEnd[-1])
    {
        *pwszEnd++ = L'\\';
    }

    hCSCFind = CSCFindFirstFile (pwszSource, &findData, &dwFileStatus,
                                 &dwPinCount, &dwHintFlags, &origTime);

    if (INVALID_HANDLE_VALUE != hCSCFind)
    {
        do
        {
            if (0 != _wcsicmp (L".", findData.cFileName) &&
                0 != _wcsicmp (L"..", findData.cFileName) &&
                (!pwszSkipSubdir || (0 != _wcsicmp (pwszSkipSubdir, findData.cFileName))))
            {
                wcscpy (pwszEnd, findData.cFileName);

                if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (ERROR_SUCCESS != Status)
                    {
                        //no point delaying the deletes since a delete has already
                        //failed.
                        DeleteCSCFileTree (pwszPath, NULL, FALSE);
                    }
                    else
                    {
                        Status = DeleteCSCFileTree (pwszPath, NULL, bAllowRdrTimeout);
                    }
                }
                else
                {
                    if (ERROR_SUCCESS != Status)
                    {
                        //no point delaying the delete if we have already failed.
                        DeleteCSCFile (pwszPath, FALSE);
                    }
                    else
                    {
                        Status = DeleteCSCFile (pwszPath, bAllowRdrTimeout);
                    }
                }
            }

        } while ( CSCFindNextFile (hCSCFind, &findData, &dwFileStatus,
                                   &dwPinCount, &dwHintFlags, &origTime)
                 );

        CSCFindClose (hCSCFind);
    }

    if (ERROR_SUCCESS != Status)
    {
        //no point in delaying the delete if we have already failed.
        DeleteCSCFile (pwszSource, FALSE);
    }
    else
    {
        Status = DeleteCSCFile (pwszSource, bAllowRdrTimeout);
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCFile
//
//  Synopsis:   deletes the given path. but might make repeated attempts to
//              make sure that the rdr has enough time to release any handles
//              that it holds.
//
//  Arguments:  [in] pwszPath : the path to delete.
//              [in] bAllowRdrTimeout : make multiple attempts to delete the
//                          file with waits in between so that the rdr has
//                          enough time to release any held handles.
//
//  Returns:    ERROR_SUCCES if the delete was successful. An error code
//              otherwise.
//
//  History:    5/26/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DeleteCSCFile (const WCHAR * pwszPath, BOOL bAllowRdrTimeout)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    int     i;

    bStatus = CSCDelete (pwszPath);
    if (!bStatus)
    {
        Status = GetLastError();
        if (ERROR_SUCCESS != Status &&
            ERROR_FILE_NOT_FOUND != Status &&
            ERROR_PATH_NOT_FOUND != Status &&
            ERROR_INVALID_PARAMETER != Status)
        {
            //this is a valid error.
            //so based on the value of bAllowRdrTimeout and based
            //on whether we have already failed in deleting something
            //we will try repeatedly to delete the file for 10 seconds
            //note: there is no point in repeatedly trying if the deletion
            //failed because this was a directory which was not empty
            if (bAllowRdrTimeout && ERROR_DIR_NOT_EMPTY != Status)
            {
                for (i = 0; i < 11; i++)
                {
                    Sleep (1000);   //wait for 1 second and try again
                    bStatus = CSCDelete (pwszPath);
                    if (bStatus)
                    {
                        Status = ERROR_SUCCESS;
                        break;
                    }
                }
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }

    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_CSCDELETE_FAIL, pwszPath, Status));
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplayStatusMessage
//
//  Synopsis:   displays the status message in the UI when the verbose status
//              is on.
//
//  Arguments:  resource id of the message to be displayed.
//
//  Returns:    nothing
//
//  History:    2/25/1999  RahulTh  created
//
//  Notes:      failures are ignored.
//
//---------------------------------------------------------------------------
void DisplayStatusMessage (UINT rid)
{
    WCHAR   pwszMessage [MAX_PATH];

    if (!gpStatusCallback)
        return;

    if (!LoadString (ghDllInstance, rid, pwszMessage, MAX_PATH))
        return;

    gpStatusCallback (TRUE, pwszMessage);
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCShareIfEmpty
//
//  Synopsis:   given a file name, this function deletes from the local cache
//              the share to which the file belongs if the local cache for that
//              share is empty
//
//  Arguments:  [in] pwszFileName : the full file name -- must be UNC
//              [in] shStatus : the share status - online, offline, local etc.
//
//  Returns:    ERROR_SUCCESS : if successful
//              a win32 error code if something goes wrong
//
//  History:    4/22/1999  RahulTh  created
//
//  Notes:      we do not have to explicitly check if the share is empty
//              because if it is not, then the delete will fail anyway
//
//---------------------------------------------------------------------------
DWORD DeleteCSCShareIfEmpty (LPCTSTR pwszFileName, SHARESTATUS shStatus)
{
    DWORD   Status;
    WCHAR * pwszFullPath = NULL;
    WCHAR * pwszCurr = NULL;
    int     len;
    WCHAR * pwszShrEnd;

    if (PathLocal == shStatus || NoCSC == shStatus)
        return ERROR_SUCCESS;

    if (ShareOffline == shStatus)
        return ERROR_CSCSHARE_OFFLINE;

    len = wcslen (pwszFileName);

    if (len <= 2)
        return ERROR_BAD_PATHNAME;

    if (pwszFileName[0] != L'\\' || pwszFileName[1] != L'\\')
        return ERROR_BAD_PATHNAME;

    pwszFullPath = (WCHAR *) alloca (sizeof (WCHAR) * (len + 1));
    if (NULL == pwszFullPath)
        return ERROR_OUTOFMEMORY;

    if (NULL == _wfullpath(pwszFullPath, pwszFileName, len + 1))
        return ERROR_BAD_PATHNAME;  //canonicalization was unsuccessful.
                                    // -- rarely happens

    pwszShrEnd = wcschr (pwszFullPath + 2, L'\\');

    if (NULL == pwszShrEnd)
        return ERROR_BAD_PATHNAME;  //the path does not have the share component

    pwszShrEnd++;

    pwszShrEnd = wcschr (pwszShrEnd, L'\\');

    if (NULL == pwszShrEnd)
    {
        //we already have the path in \\server\share form, so just try to
        //delete the share.
        return DeleteCSCFile (pwszFullPath, TRUE);
    }

    //if we are here, then we have a path longer than just \\server\share.
    //so try to delete all the way up to the share name. This is necessary
    //because a user might be redirected to something like
    // \\server\share\folder\%username% and we wouldn't want only \\server\share
    // and \\server\share\folder to be cached.
    Status = ERROR_SUCCESS;
    do
    {
        pwszCurr = wcsrchr (pwszFullPath, L'\\');
        if (NULL == pwszCurr)
            break;
        *pwszCurr = L'\0';
        Status = DeleteCSCFile (pwszFullPath, TRUE);
        //no point trying to delete the parent if deletion of this directory
        //failed.
        if (ERROR_SUCCESS != Status)
            break;
    } while ( pwszCurr > pwszShrEnd );

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   MergePinInfo
//
//  Synopsis:   merges the pin info. from the source to destination
//
//  Arguments:  [in] pwszSource : the full path to the source
//              [in] pwszDest   : the full path to the destination
//              [in] StatusFrom : CSC status of the source share
//              [in] StatusTo   : CSC status of the destination share
//
//  Returns:    ERROR_SUCCESS : if it was successful
//              a Win32 error code otherwise
//
//  History:    4/23/1999  RahulTh  created
//
//  Notes:      the hint flags are a union of the source hint flags and
//              destination hint flags. The pin count is the greater of the
//              source and destination pin count
//
//              Usually this function should only be called for folders. The
//              CSC rename API handles files well. But this function will work
//              for files as well.
//
//---------------------------------------------------------------------------
DWORD MergePinInfo (LPCTSTR pwszSource, LPCTSTR pwszDest,
                   SHARESTATUS StatusFrom, SHARESTATUS StatusTo)
{
    BOOL    bStatus;
    DWORD   dwSourceStat, dwDestStat;
    DWORD   dwSourcePinCount, dwDestPinCount;
    DWORD   dwSourceHints, dwDestHints;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   i;

    if (ShareOffline == StatusFrom || ShareOffline == StatusTo)
        return ERROR_CSCSHARE_OFFLINE;

    if (ShareOnline != StatusFrom || ShareOnline != StatusTo)
        return ERROR_SUCCESS;       //there is nothing to do if one of the shares
                                    //is local.
    if (!pwszSource || !pwszDest ||
        0 == wcslen(pwszSource) || 0 == wcslen(pwszDest))
        return ERROR_BAD_PATHNAME;

    bStatus = CSCQueryFileStatus (pwszSource, &dwSourceStat, &dwSourcePinCount,
                                  &dwSourceHints);
    if (!bStatus)
        return GetLastError();

    bStatus = CSCQueryFileStatus (pwszDest, &dwDestStat, &dwDestPinCount,
                                  &dwDestHints);
    if (!bStatus)
        return GetLastError();

    //first set the hint flags on the destination
    if (dwDestHints != dwSourceHints)
    {
        bStatus = CSCPinFile (pwszDest, dwSourceHints, &dwDestStat,
                              &dwDestPinCount, &dwDestHints);
        if (!bStatus)
            Status = GetLastError();    //note: we do not bail out here. we try
                                        //to at least merge the pin count before
                                        //leaving
    }

    //now merge the pin count : there is nothing to be done if the destination
    //pin count is greater than or equal to the source pin count
    if (dwDestPinCount < dwSourcePinCount)
    {
        for (i = 0, bStatus = TRUE; i < (dwSourcePinCount - dwDestPinCount) &&
                                    bStatus;
             i++)
        {
            bStatus = CSCPinFile( pwszDest,
                                  FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                  NULL, NULL, NULL );
        }

        if (!bStatus && ERROR_SUCCESS == Status)
            Status = GetLastError();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   PinIfNecessary
//
//  Synopsis:   this function pins a file if necessary.
//
//  Arguments:  [in] pwszPath : full path of the file/folder to be pinned
//              [in] shStatus : CSC status of the share.
//
//  Returns:    ERROR_SUCCESS if it was successful. An error code otherwise.
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PinIfNecessary (const WCHAR * pwszPath, SHARESTATUS shStatus)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    DWORD   dwStatus;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (!pwszPath || !pwszPath[0])
        return ERROR_BAD_NETPATH;

    if (! g_bCSCEnabled)
        return ERROR_SUCCESS;

    if (ShareOffline == shStatus)
        return ERROR_CSCSHARE_OFFLINE;
    else if (PathLocal == shStatus || NoCSC == shStatus)
        return ERROR_SUCCESS;

    bStatus = CSCQueryFileStatus (pwszPath, &dwStatus, &dwPinCount, &dwHints);
    if (!bStatus || dwPinCount <= 0)
    {
        bStatus = CSCPinFile (pwszPath,
                              FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                              NULL, NULL, NULL);
        if (!bStatus)
            Status = GetLastError();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   CacheDesktopIni
//
//  Synopsis:   some special folders use the desktop.ini file to present
//              special views in explorer (e.g. My Pictures). If a folder is
//              redirected to a network share and a user goes offline without
//              ever looking at the folder in explorer, the desktop.ini file
//              is not in the cache and therefore the special views are lost
//
//              This function tries to cache the desktop.ini file as soon as
//              the folder is pinned so that special views are not lost even
//              if the user goes offline
//
//              When the folder is unpinned, this function merely unpins the
//              dekstop.ini file
//
//  Arguments:  [in] pwszPath : the path to the folder
//              [in] shStatus : the CSC status of the share
//              [in] uCommand : Pin/Unpin
//
//  Returns:    ERROR_SUCCESS if everything is successful.
//              a win32 error code otherwise.
//
//  History:    4/25/1999  RahulTh  created
//
//  Notes:      this function should only be called after the folder has been
//              successfully redirected.
//
//              if desktop.ini is already pinned, this function does not try
//              to pin it again.
//
//---------------------------------------------------------------------------
DWORD CacheDesktopIni (LPCTSTR pwszPath, SHARESTATUS shStatus, CSCPINCOMMAND uCommand)
{
    int     len;
    WCHAR   szDesktopIniName[] = L"desktop.ini";
    WCHAR * pwszDesktopIni = NULL;
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwStatus;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (PathLocal == shStatus)
        return ERROR_SUCCESS;   //nothing to be done.

    if (ShareOffline == shStatus)
        return ERROR_CSCSHARE_OFFLINE;

    if (!pwszPath || 0 == (len = wcslen (pwszPath)))
        return ERROR_BAD_PATHNAME;

    pwszDesktopIni = (WCHAR *) alloca (sizeof (WCHAR) *
                                       (len + wcslen(szDesktopIniName) + 2)); //extra char for backslash
    if (NULL == pwszDesktopIni)
        return ERROR_OUTOFMEMORY;

    wcscpy (pwszDesktopIni, pwszPath);
    if (L'\\' != pwszDesktopIni[len - 1])
    {
        pwszDesktopIni[len] = L'\\';
        pwszDesktopIni[len + 1] = L'\0';
    }
    wcscat (pwszDesktopIni, szDesktopIniName);

    if (PinFile == uCommand)
    {
        bStatus = CSCQueryFileStatus (pwszDesktopIni, &dwStatus, &dwPinCount,
                                      &dwHints);
        //pin only if it has not already been pinned.
        if (!bStatus || dwPinCount <= 0)
        {
            if (bStatus = CSCPinFile(pwszDesktopIni,
                                     FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                     NULL, NULL, NULL)
                )
            {
                bStatus = CSCFillSparseFiles(pwszDesktopIni, FALSE,
                                             CSCCallbackProc, 0);
            }
            if (!bStatus)
                Status = GetLastError();
        }
    }
    else if (UnpinFile == uCommand)
    {
        if (! CSCUnpinFile (pwszDesktopIni, FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                            NULL, NULL, NULL))
            Status = GetLastError();
    }

    return Status;

}

//+--------------------------------------------------------------------------
//
//  Function:   CSCCallbackProc
//
//  Synopsis:   callback function for CSCFillSparseFiles
//
//  Arguments:  see docs
//
//  Returns:    see docs
//
//  History:    4/26/1999  RahulTh  created
//
//  Notes:      just returns a default value for all...
//
//---------------------------------------------------------------------------
DWORD WINAPI
CSCCallbackProc(LPCTSTR             pszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                LPWIN32_FIND_DATA   pFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext)
{
    return CSCPROC_RETURN_CONTINUE;
}

//+--------------------------------------------------------------------------
//
//  Function:   UpdateMyPicsShellLink
//
//  Synopsis:   there is no easy way to get to My Pictures if it is redirected
//              independently of My Documents since the shell does not really
//              address this issue. Therefore, this function is required to
//              make sure that if My Pictures is not located directly under
//              My Documents, there is at least a shell link pointing to the
//              location of My Pictures. This function also makes sure that
//              the shell link is cached in case My Documents is on a network
//              share. This way, if the share were to go offline before the user
//              had a chance to access My Documents, then the shell link would
//              still be accessible.
//
//              Also, if My Pictures is a direct descendant of My Documents,
//              this function gets rid of the shell link to minimize user
//              confusion.
//
//  Arguments:  [in] pwszMyPicsLocName : localized display name of My Pictures.
//
//  Returns:    S_OK : if everything went smoothly.
//              an HRESULT derived from the error if there is one.
//
//  History:    5/2/1999  RahulTh  created
//              2/14/2001 RahulTh  Fixed shortcut creation problem in free
//                                 threaded COM by using SHCoCreateInstance
//                                 to short-circuit COM.
//
//  Notes:      This function shall not be required if the shell comes up with
//              an easy way to get to My Pictures even when it does not lie
//              directly under My Documents.
//
//---------------------------------------------------------------------------
HRESULT UpdateMyPicsShellLinks (HANDLE hUserToken, const WCHAR * pwszMyPicsLocName)
{
    WCHAR   szMyDocsPath [TARGETPATHLIMIT];
    WCHAR   szMyPicsPath [TARGETPATHLIMIT];
    WCHAR * pwszMyPicsLink = NULL;
    int     MyDocsLen;
    int     MyPicsLen;
    HRESULT hr = S_OK;
    SHARESTATUS MyDocsCSCStatus;
    BOOL    fMyPicsFollows = TRUE;
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    IShellLink * psl = NULL;
    IPersistFile * ppf = NULL;
    DWORD   dwPinCount;
    DWORD   dwHints;
    DWORD   dwCSCState;
    BOOL    bComInitialized = FALSE;

    //make sure that we have the user token.
    if (!hUserToken)
    {
        hr = E_FAIL;
        goto UpdateMyPicsLink_End;
    }

    //now get the path to My Documents
    hr = SHGetFolderPath(0, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY,
                         hUserToken, 0, szMyDocsPath);
    if (S_OK != hr)
        goto UpdateMyPicsLink_End;

    //now make sure that we can get enough memory to store the path to the
    //shell link.
    MyDocsLen = wcslen (szMyDocsPath);
    if (0 == MyDocsLen)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto UpdateMyPicsLink_End;
    }

    pwszMyPicsLink = (WCHAR *) alloca (sizeof(WCHAR) * (MyDocsLen + wcslen(pwszMyPicsLocName) + 6));
    if (NULL == pwszMyPicsLink)
    {
        hr = E_OUTOFMEMORY;
        goto UpdateMyPicsLink_End;
    }

    //now make sure that the share on which My Docs exists is not offline
    MyDocsCSCStatus = GetCSCStatus (szMyDocsPath);
    if (ShareOffline == MyDocsCSCStatus)
    {
        hr = HRESULT_FROM_WIN32 (ERROR_CSCSHARE_OFFLINE);
        goto UpdateMyPicsLink_End;
    }

    //now construct the path to the shell link to MyPics in the MyDocs folder
    wcscpy (pwszMyPicsLink, szMyDocsPath);
    if (L'\\' != szMyDocsPath[MyDocsLen - 1])
    {
        pwszMyPicsLink[MyDocsLen] = L'\\';
        pwszMyPicsLink[MyDocsLen+1] = L'\0';
    }
    wcscat (pwszMyPicsLink, pwszMyPicsLocName);
    wcscat (pwszMyPicsLink, L".lnk");

    //now obtain the path to My Pictures
    hr = SHGetFolderPath (0, CSIDL_MYPICTURES | CSIDL_FLAG_DONT_VERIFY,
                          hUserToken, 0, szMyPicsPath);
    if (S_OK != hr)
        goto UpdateMyPicsLink_End;

    //now find out if MyPics is a descendant of My Docs.
    MyPicsLen = wcslen (szMyPicsPath);
    if (0 == MyPicsLen)
    {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_PATHNAME);
        goto UpdateMyPicsLink_End;
    }

    if (MyPicsLen <= MyDocsLen ||
        0 != _wcsnicmp (szMyPicsPath, szMyDocsPath, MyDocsLen)
       )
    {
        fMyPicsFollows = FALSE;
    }

    //delete the shell link if MyPics is supposed to follow MyDocs.
    if (fMyPicsFollows)
    {
        Status = ERROR_SUCCESS;
        if (!DeleteFile (pwszMyPicsLink))
        {
            Status = GetLastError();
            if (ERROR_PATH_NOT_FOUND == Status ||
                ERROR_FILE_NOT_FOUND == Status)
                Status = ERROR_SUCCESS;
        }
        hr = HRESULT_FROM_WIN32 (Status);
        goto UpdateMyPicsLink_End;
    }

    //if we are here, we need to create/update the shell link.
    
    //
    // Note: We need to use SHCoCreateInstance. This is because the GP engine
    // is now freethreaded whereas the threading model for CLSID_ShellLink is
    // still Apartment. This means that if we use CoCreateInstance, it will
    // create the object on a COM thread in its own apartment. This means that
    // it will run as LocalSystem and not impersonated as the logged on user.
    // This is not what we want, especially when we are creating shortcuts on
    // a network share and we need to go across the wire as the logged on user
    // rather than the machine account in order to authenticate successfully.
    // To get around this problem, we use SHCoCreateInstance() which is an
    // internal shell API that completely short-circuits COM and calls into
    // shell32's DllGetClassObject directly thus creating the objects on the
    // same thread. This API is primarily for shell user *ONLY* to handle crufty
    // compat stuff so use this *VERY* *VERY *SPARINGLY*. If you want to do
    // anything remotely fancy with IShellLink, check with the shell team to
    // make sure that it is still okay to use the SHCoCreateInstance API.
    //
    hr = CoInitialize (NULL);
    if (SUCCEEDED(hr))
        bComInitialized = TRUE;
    
    if (SUCCEEDED (hr) || RPC_E_CHANGED_MODE == hr) // If we successfully initialized COM or if it was already initialized.
    {
        hr = SHCoCreateInstance(NULL,
                                &CLSID_ShellLink,
                                NULL,
                                IID_IShellLink,
                                (LPVOID*)&psl);
        if (FAILED(hr))
            psl = NULL; // For safety.
    }
    if (SUCCEEDED(hr))
        hr = psl->SetPath (szMyPicsPath);
    if (SUCCEEDED(hr))
        hr = psl->SetDescription (pwszMyPicsLocName);
    if (SUCCEEDED(hr))
        hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);
    if (SUCCEEDED(hr))
    {
        hr = ppf->Save(pwszMyPicsLink, TRUE);
        ppf->Release();
    }
    
    // Release IShellLink if necessary.
    if (psl)
        psl->Release();
    
    // Uninitialize COM if necessary.
    if (bComInitialized)
    {
        CoUninitialize();
        bComInitialized = FALSE;
    }

    //also cache the shell link if MyDocs is redirected to a cacheable
    //network share
    if (SUCCEEDED(hr) && ShareOnline == MyDocsCSCStatus)
    {
        Status = ERROR_SUCCESS;
        bStatus = TRUE;
        bStatus = CSCQueryFileStatus (pwszMyPicsLink, &dwCSCState,
                                      &dwPinCount, &dwHints);
        if (bStatus)
        {
            if (0 == dwPinCount && (!(dwHints & FLAG_CSC_HINT_PIN_USER)))
            {
                if (bStatus = CSCPinFile(pwszMyPicsLink,
                                         FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                         NULL, NULL, NULL)
                   )
                {
                    bStatus = CSCFillSparseFiles(pwszMyPicsLink, FALSE,
                                                 CSCCallbackProc, 0);
                }
            }
        }

        if (!bStatus)
        {
            Status = GetLastError();
        }

        hr = HRESULT_FROM_WIN32 (Status);
    }

UpdateMyPicsLink_End:
    if (FAILED(hr))
    {
        DebugMsg ((DM_VERBOSE, IDS_MYPICSLINK_FAILED, GetWin32ErrFromHResult(hr)));
    }
    else
    {
        DebugMsg ((DM_VERBOSE, IDS_MYPICSLINK_SUCCEEDED, szMyDocsPath));
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadLocalizedFolderNames
//
//  Synopsis:   loads the localized folder names into global objects of
//              CRedirectInfo class.
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS if everything was successful.
//              an error code otherwise.
//
//  History:    5/6/1999  RahulTh  created
//
//  Notes:      the function bails out at the first failure. Also see notes
//              on CRedirectInfo::LoadLocalizedNames.
//
//---------------------------------------------------------------------------
DWORD LoadLocalizedFolderNames (void)
{
    DWORD   i;
    DWORD   Status;

    for (i = 0, Status = ERROR_SUCCESS; i < (DWORD)EndRedirectable; i++)
    {
        Status = gPolicyResultant[i].LoadLocalizedNames();
        if (ERROR_SUCCESS == Status)
            Status = gAddedPolicyResultant[i].LoadLocalizedNames();
        if (ERROR_SUCCESS == Status)
            Status = gDeletedPolicyResultant[i].LoadLocalizedNames();
        if (ERROR_SUCCESS != Status)
            break;
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCachedConfigFiles
//
//  Synopsis:   deletes the locally cached copies of fdeploy.ini for GPOs
//              in a list of GPOs.
//
//  Arguments:  [in] pGPOList : the list of GPOs
//              [in] pFileDB : a filedb object containing info. about the
//                              location of the files etc.
//
//  Returns:    ERROR_SUCCESS if all the files were successfully deleted.
//              an error code otherwise.
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:      this function tries its best to delete as many files as
//              possible
//
//---------------------------------------------------------------------------
DWORD DeleteCachedConfigFiles (const PGROUP_POLICY_OBJECT pGPOList,
                               CFileDB * pFileDB)
{
    DWORD   Status = ERROR_SUCCESS;
    WCHAR * pwszPath = NULL;
    WCHAR * pwszEnd = NULL;
    int     len;
    PGROUP_POLICY_OBJECT pGPO;

    pwszPath = (WCHAR *) alloca (sizeof (WCHAR) * ((len = wcslen (pFileDB->GetLocalStoragePath())) + MAX_PATH + 2));
    if (!pwszPath)
        return ERROR_OUTOFMEMORY;

    wcscpy (pwszPath, pFileDB->GetLocalStoragePath());
    wcscat (pwszPath, L"\\");
    pwszEnd = pwszPath + len + 1;

    for (pGPO = pGPOList; pGPO; pGPO = pGPO->pNext)
    {
        wcscpy (pwszEnd, pGPO->szGPOName);
        wcscat (pwszEnd, L".ini");
        if (!DeleteFile (pwszPath) && ERROR_SUCCESS == Status)
        {
            Status = GetLastError();
            if (ERROR_PATH_NOT_FOUND == Status ||
                ERROR_FILE_NOT_FOUND == Status)
            {
                Status = ERROR_SUCCESS;
            }
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   SimplifyPath
//
//  Synopsis:   given a path, this function tries to simplify it by
//              canonicalizing it and removing extra slashes by calling
//              _wfullpath
//
//  Arguments:  [in/out] pwszPath : the given path
//
//  Returns:    nothing
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:      the function tries its best to simplify the path. If it fails,
//              it simply returns the path supplied originally.
//
//---------------------------------------------------------------------------
void SimplifyPath (WCHAR * pwszPath)
{
    size_t  len;
    WCHAR * pwszAbsPath;

    if (!pwszPath || !pwszPath[0])
        return;

    len = wcslen (pwszPath);

    pwszAbsPath = (WCHAR *) alloca (sizeof (WCHAR) * (len + 1));

    if (!pwszAbsPath)
        return;

    if (NULL != _wfullpath (pwszAbsPath, pwszPath, len + 1) &&
        wcslen (pwszAbsPath) <= len)
    {
        wcscpy (pwszPath, pwszAbsPath);
    }

    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   PrecreateUnicodeIniFile
//
//  Synopsis:   The WritePrivateProfile* functions do not write in unicode
//              unless the file already exists in unicode format. Therefore,
//              this function is used to precreate a unicode file so that
//              the WritePrivateProfile* functions can preserve the unicodeness.
//
//  Arguments:  [in] lpszFilePath : the full path of the ini file.
//
//  Returns:    ERROR_SUCCESS if successful.
//              an error code otherwise.
//
//  History:    7/9/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PrecreateUnicodeIniFile (LPCTSTR lpszFilePath)
{
    HANDLE      hFile;
    WIN32_FILE_ATTRIBUTE_DATA   fad;
    DWORD       Status = ERROR_ALREADY_EXISTS;
    DWORD       dwWritten;

    if (!GetFileAttributesEx (lpszFilePath, GetFileExInfoStandard, &fad))
    {
        if (ERROR_FILE_NOT_FOUND == (Status = GetLastError()))
        {
            hFile = CreateFile(lpszFilePath, GENERIC_WRITE, 0, NULL,
                               CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                //add the unicode mask to the beginning of the file so that
                //ReadPrivate* APIs do not accidentally think that this an ANSI
                //file.
                WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwWritten, NULL);
                //add a few unicode characters just to be safe.
                WriteFile(hFile, L"     \r\n", 7 * sizeof(WCHAR),
                          &dwWritten, NULL);
                CloseHandle(hFile);
                Status = ERROR_SUCCESS;
            }
            else
            {
                Status = GetLastError();
            }
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsPathLocal
//
//  Synopsis:   this function determines if a given path is a local path
//              or a UNC path.
//
//  Arguments:  pwszPath : the full path of the file.
//
//  Returns:    FALSE : if it is a UNC path.
//              TRUE : otherwise
//
//  History:    7/30/1999  RahulTh  created
//
//  Notes:      this function basically returns TRUE unless the first
//              characters of the supplied path are '\'.
//
//---------------------------------------------------------------------------
BOOL IsPathLocal (LPCWSTR pwszPath)
{
    if (NULL == pwszPath || 2 > wcslen (pwszPath))
        return TRUE;        //assume local

    if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1])
        return FALSE;

    return TRUE;    //local in all other cases.
}

//+--------------------------------------------------------------------------
//
//  Function:   ExpandPathSpecial
//
//  Synopsis:   expands a path using a given user name.
//
//  Arguments:  [in] pFileDB : pointer to the CFileDB object
//              [in] pwszPath : pointer to the path to be expanded.
//              [in] pwszUserName : the user name to be used in expansion
//              [out] wszExpandedPath : the expanded path.
//              [in, out] pDesiredBufferSize (optional) : on input, the size
//              of the wszExpandedPath buffer.  On output, the size needed
//              to expand the path to that buffer.  This may be NULL, in which
//              case the buffer is assumed to be TARGETPATHLIMIT size.
//
//  Returns:    ERROR_SUCCESS : if the expanded path was successfully obtained.
//              STATUS_BUFFER_TOO_SMALL : if the expanded path was too large
//                      to fit in the supplied buffer.
//              other win32 error codes based on what goes wrong.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:      wszExpandedPath is assumed to be a buffer containing
//              TARGETPATHLIMIT characters, unlesss pDesiredBufferSize
//              is specified. It is the caller's responsibility
//              to allocate/free this memory. This function does not try to
//              validate the memory that wszExpandedPath points to.
//
//              This function is also not equipped to handle multiple
//              occurrences of the %username% substring in the last path.
//
//---------------------------------------------------------------------------
DWORD ExpandPathSpecial (
                         CFileDB * pFileDB,
                         const WCHAR * pwszPath,
                         const WCHAR * pwszUserName,
                         WCHAR * wszExpandedPath,
                         ULONG * pDesiredBufferSize
                         )
{
    DWORD           Status = ERROR_SUCCESS;
    UNICODE_STRING  Path;
    UNICODE_STRING  ExpandedPath;
    WCHAR           wszLastPath [TARGETPATHLIMIT];
    WCHAR *         wszTemp = NULL;
    WCHAR           wszSuffix [TARGETPATHLIMIT];

    if (TARGETPATHLIMIT <= wcslen(pwszPath))
        return STATUS_BUFFER_TOO_SMALL;

    wszSuffix[0] = L'\0';
    wszLastPath[0] = L'\0';
    
    wcscpy (wszLastPath, pwszPath);
    //convert it to lower case. useful while searching for other strings
    //within the string.
    _wcslwr (wszLastPath);

    //
    // If the caller does not specify a user name, just use environment
    // variable substitution to take care of %username% instead of
    // doing it ourselves
    //
    if ( pwszUserName )
    {
        //the username has changed since the last logon. must first substitute
        //the occurence of %username% if any with the supplied user name
        wszTemp = wcsstr (wszLastPath, L"%username%");
    }

    //if the %username% string is not present, nothing more needs to be
    //done. we can just go ahead and expand what we've got.
    if (NULL != wszTemp)
    {
        //the last path contains %username%
        //get the parts that appear before and after the %username% string
        //reuse wszLastPath for the prefix
        *wszTemp = L'\0';
        wcscpy (wszSuffix, wszTemp + 10); //go past %username%

        //make sure that we are not running out of space.
        if (TARGETPATHLIMIT <=
                    wcslen (wszLastPath) +
                    wcslen (pwszUserName) +
                    wcslen (wszSuffix))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }
        wcscat (wszLastPath, pwszUserName);
        wcscat (wszLastPath, wszSuffix);
    }

    //
    // In planning mode, we are only interested in %username% --
    // any other environment variables can remain unexpanded since
    // they may depend on local state to which we do not have access
    // in planning mode.
    //
    if ( pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( ERROR_SUCCESS == Status )
        {
            lstrcpy( wszExpandedPath, wszLastPath );
        }

        return Status;
    }

    USHORT ExpandedBufferMax;

    ExpandedBufferMax = (USHORT)(pDesiredBufferSize ? *pDesiredBufferSize : TARGETPATHLIMIT);

    //now expand other variables in the path
    Path.Length = (wcslen (wszLastPath) + 1) * sizeof (WCHAR);
    Path.MaximumLength = sizeof (wszLastPath);
    Path.Buffer = wszLastPath;

    ExpandedPath.Length = 0;
    ExpandedPath.MaximumLength = ExpandedBufferMax * sizeof (WCHAR);
    ExpandedPath.Buffer = wszExpandedPath;

    Status = RtlExpandEnvironmentStrings_U (
                            pFileDB->GetEnvBlock(),
                            &Path,
                            &ExpandedPath,
                            pDesiredBufferSize
                            );

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   ExpandHomeDir
//
//  Synopsis:   Expands the HOMEDIR component in the path.
//
//  Arguments:  [in] rID : the id of the folder
//              [in] pwszPath : the unexpanded path
//              [in] bAllowMyPics : allow expansion of homedir for MyPics
//              [out] ppwszExpandedPath : the expanded result
//              [in, optional] pwszHomedir : the value of homedir to be used in substitution
//
//  Returns:    ERROR_SUCCESS : if successful.
//              a Win32 error code otherwise.
//
//  History:    3/10/2000  RahulTh  created
//
//  Notes:      This function has the following additional restrictions:
//              (a) It is a no-op for all folders except MyDocs and MyPics.
//              (b) It only acts on paths that begin with
//                  %HOMESHARE%%HOMEPATH%
//
//              Also, if the function does not return ERROR_SUCCESS, then
//              *ppwszExpandedPath can be null.
//
//              if the caller does not supply the homedir value for
//              substitution, the value is obtained from the user object.
//
//---------------------------------------------------------------------------
DWORD   ExpandHomeDir (IN REDIRECTABLE  rID,
                       IN const WCHAR * pwszPath,
                       BOOL             bAllowMyPics,
                       OUT WCHAR **     ppwszExpandedPath,
                       IN const WCHAR * pwszHomedir // = NULL
                       )
{
    DWORD         Status = ERROR_SUCCESS;
    int           len;
    const WCHAR * wszSuffix;
    int           expandedLen;
    int           lenHomedir;

    // First free the supplied buffer if necessary
    if (*ppwszExpandedPath)
    {
        delete [] *ppwszExpandedPath;
        *ppwszExpandedPath = NULL;
    }

    if (! pwszPath || L'\0' == *pwszPath)
    {
        Status = ERROR_BAD_PATHNAME;
        goto ExpandHomeDir_End;
    }

    // Proceed only if the HOMEDIR component is in the right place.
    if (! IsHomedirPath (rID, pwszPath, bAllowMyPics))
    {
        if (! HasHomeVariables (pwszPath))
        {
            goto ExpandHomeDir_ReturnSame;
        }
        else
        {
            // This is not a homedir path, so it is not supposed to have any home variables
            Status = ERROR_BAD_PATHNAME;
            goto ExpandHomeDir_End;
        }
    }

    //
    // If we are here, then we need to substitute the HOMEDIR part
    // with the actual home directory. We use the current homedir value
    // only if the caller hasn't already supplied us with one.
    //
    len = lstrlen (HOMEDIR_STR);
    if (! pwszHomedir)
        pwszHomedir = gUserInfo.GetHomeDir(Status);
    //
    // At this point, pwszHomeDir can be NULL even if Status is ERROR_SUCCESS
    // This happens if the user object does not have a homedir set on it
    // So we must fail even in that case.
    //
    if (! pwszHomedir || ERROR_SUCCESS != Status)
    {
        // Do not clobber status set by GetHomeDir if it had failed.
        Status = (ERROR_SUCCESS == Status) ? ERROR_BAD_PATHNAME : Status;
        goto ExpandHomeDir_End;
    }

    //
    // Now we have everything we need to proceed.
    // First allocate the required buffer.
    //
    lenHomedir = lstrlen (pwszHomedir);
    expandedLen = lenHomedir + lstrlen (&pwszPath[len]);
    *ppwszExpandedPath = new WCHAR [expandedLen + 1];
    if (! *ppwszExpandedPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto ExpandHomeDir_End;
    }
    // Generate the new path.
    lstrcpy (*ppwszExpandedPath, pwszHomedir);

    // Append the suffix
    wszSuffix = &pwszPath[len];
    // Eliminate duplicate '\' characters
    if (L'\\' == (*ppwszExpandedPath)[lenHomedir - 1] && L'\\' == pwszPath[len])
        wszSuffix++;
    lstrcat (*ppwszExpandedPath, wszSuffix);

    DebugMsg ((DM_VERBOSE, IDS_HOMEDIR_EXPANDED, pwszPath, *ppwszExpandedPath));

    goto ExpandHomeDir_End;

    //
    // If we are here, then, there was no error, but no substitution was
    // necessary either. So we just return the same path.
    //

ExpandHomeDir_ReturnSame:
    len = lstrlen (pwszPath);
    *ppwszExpandedPath = new WCHAR [len + 1];
    if (! *ppwszExpandedPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto ExpandHomeDir_End;
    }

    // Copy the path.
    lstrcpy (*ppwszExpandedPath, pwszPath);
    Status = ERROR_SUCCESS;

ExpandHomeDir_End:
    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_HOMEDIR_EXPAND_FAIL, pwszPath, Status));
    }
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   ExpandHomeDirPolicyPath
//
//  Synopsis:   Expands the HOMEDIR component in the path as specified in the
//              ini file (ones that begin with \\%HOMESHARE%%HOMEPATH%)
//
//  Arguments:  [in] rID : the id of the folder
//              [in] pwszPath : the unexpanded path
//              [in] bAllowMyPics : allow expansion of homedir for MyPics
//              [out] ppwszExpandedPath : the expanded result
//              [in, optional] pwszHomedir : the value of homedir to be used in substitution
//
//  Returns:    ERROR_SUCCESS : if successful.
//              a Win32 error code otherwise.
//
//  History:    3/10/2000  RahulTh  created
//
//  Notes:      This function has the following additional restrictions:
//              (a) It is a no-op for all folders except MyDocs and MyPics.
//              (b) It only acts on paths that begin with
//                  \\%HOMESHARE%%HOMEPATH% or %HOMESHARE%%HOMEPATH%
//
//              Also, if the function does not return ERROR_SUCCESS, then
//              *ppwszExpandedPath can be null.
//
//              if the caller does not supply the homedir value for
//              substitution, the value is obtained from the user object.
//
//---------------------------------------------------------------------------
DWORD   ExpandHomeDirPolicyPath (IN REDIRECTABLE  rID,
                                 IN const WCHAR * pwszPath,
                                 IN BOOL          bAllowMyPics,
                                 OUT WCHAR **     ppwszExpandedPath,
                                 IN const WCHAR * pwszHomedir // = NULL
                                 )
{
    if (IsHomedirPolicyPath(rID, pwszPath, bAllowMyPics))
    {
        return ExpandHomeDir (rID,
                              &pwszPath[2],
                              bAllowMyPics,
                              ppwszExpandedPath,
                              pwszHomedir
                              );
    }
    else
    {
        return ExpandHomeDir (rID,
                              pwszPath,
                              bAllowMyPics,
                              ppwszExpandedPath,
                              pwszHomedir
                              );
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   IsHomedirPath
//
//  Synopsis:   determines if a given redirection destination is in the homedir.
//              This means all paths that begin with %HOMESHARE%%HOMEPATH
//
//  Arguments:  [in] rID : The folder identifier.
//              [in] pwszPath : The path.
//              [in] bAllowMyPics : allow homedir paths for MyPics folder
//
//  Returns:    TRUE : if it is a homedir path
//              FALSE: otherwise.
//
//  History:    3/12/2000  RahulTh  created
//
//  Notes:      This function returns FALSE for all folders other than
//              MyDocs because that is the only folder for which redirection
//              to the home directory is permitted.
//
//              See additional notes about bAllowMyPics in the comments above
//              IsHomedirPolicyPath
//
//---------------------------------------------------------------------------
BOOL IsHomedirPath (IN REDIRECTABLE rID, IN LPCWSTR pwszPath, BOOL bAllowMyPics)
{
    int     len;

    if ((MyDocs != rID && (MyPics != rID || !bAllowMyPics)) ||
        ! pwszPath ||
        L'\0' == *pwszPath)
    {
        return FALSE;
    }

    //
    // Make sure that the length of the path is longer than that of
    // %HOMESHARE%%HOMEPATH. If not, there is no way that this can be
    // a homedir path
    //
    len = lstrlen (HOMEDIR_STR);
    if (lstrlen (pwszPath) < len)
        return FALSE;

    // If we are here, we need to compare the two strings
    if (0 == _wcsnicmp (HOMEDIR_STR, pwszPath, len) &&
        (L'\0' == pwszPath[len] || L'\\' == pwszPath[len]) &&
        NULL == wcschr (&pwszPath[len], L'%')   // no other variable names allowed
        )
    {
        // If all the conditions above are met, then this is indeed a homedir path
        return TRUE;
    }

    // If we are here, this cannot be a homedir path.
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsHomedirPolicyPath
//
//  Synopsis:   determines if a given redirection destination is in the homedir.
//              This means all paths that begin with \\%HOMESHARE%%HOMEPATH
//
//  Arguments:  [in] rID : The folder identifier.
//              [in] pwszPath : The path.
//              [in] bAllowMyPics : Allow MyPics to have a homedir path
//
//  Returns:    TRUE : if it is a homedir path as specified in the ini file
//              FALSE: otherwise.
//
//  History:    3/12/2000  RahulTh  created
//
//  Notes:      This function returns FALSE for all folders other than
//              MyDocs & MyPics because that is the only folder for which
//              redirection to the home directory is permitted.
//
//              Note: redirection to HOMEDIR is permitted for MyPics only
//              if it is set to follow MyDocs. Not otherwise. That is why
//              we need the third parameter.
//
//---------------------------------------------------------------------------
BOOL IsHomedirPolicyPath (IN REDIRECTABLE   rID,
                          IN LPCWSTR        pwszPath,
                          IN BOOL           bAllowMyPics)
{
    //
    // It is a homedir path as specified by the policy if it begins
    // with \\%HOMESHARE%%HOMEPATH%
    //
    if ((MyDocs == rID || (MyPics == rID && bAllowMyPics)) &&
        pwszPath &&
        lstrlen (pwszPath) > 2 &&
        L'\\' == pwszPath[0] &&
        L'\\' == pwszPath[1] )
    {
        return IsHomedirPath (rID, &pwszPath[2], bAllowMyPics);
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   HasHomeVariables
//
//  Synopsis:   finds if a given string has any of the home variables
//              i.e. HOMESHARE, HOMEPATH or HOMEDRIVE
//
//  Arguments:  [in] pwszPath : the path string
//
//  Returns:    TRUE: if the path has home variables.
//              FALSE: otherwise
//
//  History:    3/22/2000  RahulTh  created
//
//  Notes:      This function is required because we do not wish to allow
//              these variables in the path except in highly restricted
//              conditions, viz. My Docs redirection that begins with
//              \\%HOMESHARE%%HOMEPATH%
//
//              Therefore, we need to explicitly check for the existence of
//              variables in paths that don't meet these requirements.
//
//---------------------------------------------------------------------------
BOOL HasHomeVariables (IN LPCWSTR pwszPath)
{
    WCHAR * pszTmp;

    pszTmp = wcschr (pwszPath, L'%');

    while (pszTmp)
    {
        if (0 == _wcsnicmp (HOMESHARE_VARIABLE, pszTmp, HOMESHARE_VARLEN) ||
            0 == _wcsnicmp (HOMEDRIVE_VARIABLE, pszTmp, HOMEDRIVE_VARLEN) ||
            0 == _wcsnicmp (HOMEPATH_VARIABLE,  pszTmp, HOMEPATH_VARLEN))
        {
            return TRUE;
        }

        pszTmp = wcschr (pszTmp + 1, L'%');
    }

    // If we are here, we did not find any home variables in the path.
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetWin32ErrFromHResult
//
//  Synopsis:   given an HResult, this function tries to extract the
//              corresponding Win 32 error.
//
//  Arguments:  [in] hr : the hresult value
//
//  Returns:    the Win 32 Error code.
//
//  History:    3/13/2000  RahulTh  created
//
//  Notes:      if hr is not S_OK, the return value will be something other
//              than ERROR_SUCCESS;
//
//---------------------------------------------------------------------------
DWORD GetWin32ErrFromHResult (IN HRESULT hr)
{
    DWORD   Status = ERROR_SUCCESS;

    if (S_OK != hr)
    {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            Status = GetLastError();
            if (ERROR_SUCCESS == Status)
            {
                //an error had occurred but nobody called SetLastError
                //should not be mistaken as a success.
                Status = (DWORD) hr;
            }
        }
    }

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetExpandedPath
//
//  Synopsis:   given a redirected path that may contain environment variables,
//              evaluates the variables to produce a fully realized path
//
//  Arguments:  [in]  pFileDB : object containing general context information
//              [in]  wszSourcePath : the unexpanded path
//              [in]  rID : The folder identifier.
//              [in]  bAllowMyPics : allow homedir paths for MyPics folder
//              [out] ppwszExpandedPath -- on output, the address of the
//                    expanded path, must be freed by the caller
//
//  Returns:    the Win 32 Error code.
//
//  History:    5/30/2000  AdamEd  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD
GetExpandedPath(
    IN  CFileDB*      pFileDB,
    IN  WCHAR*        wszSourcePath,
    IN  int           rID,
    IN  BOOL          bAllowMyPics,
    OUT WCHAR**       ppwszExpandedPath)
{
    WCHAR* wszDestination;
    WCHAR* wszHomeDir;
    DWORD  Status;

    const WCHAR* wszUserName;

    *ppwszExpandedPath = NULL;


    wszDestination = NULL;
    wszHomeDir = NULL;

    wszUserName = NULL;

    //
    // In diagnostic mode, we will end up expanding %username% and
    // the %homedir% and %homepath% vars, as well as any other variables that
    // are defined, but in planning mode we will only
    // handle the first 3, and we only do so if a specific user account
    //
    if ( pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
    {
        //
        // In planning mode, the thread context is not that
        // of the desired user, so we must override it
        //
        wszUserName = gUserInfo.GetUserName( Status );

        if ( ERROR_SUCCESS != Status )
        {
            goto GetExpandedPath_Exit;
        }

        if ( ! wszUserName )
        {
            //
            // In planning mode, GetUserName can return success
            // but return a NULL username -- this means that
            // the planning mode target contained only a SOM, not a user
            // name, so we can accept the blank user name and cease
            // further expansion attempts -- we cannot expand %username%
            // or the %home%* variables if we do not have a user account. Thus,
            // we use the unexpanded path.
            //
            wszDestination = StringDuplicate( wszSourcePath );

            if ( ! wszDestination )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }

            goto GetExpandedPath_Exit;
        }
    }

    Status = ExpandHomeDirPolicyPath(
        (REDIRECTABLE) rID,
        wszSourcePath,
        bAllowMyPics,
        &wszHomeDir);

    if ( ERROR_SUCCESS != Status )
    {
        goto GetExpandedPath_Exit;
    }

    USHORT         cchDestination;
    ULONG          ReturnedLength;
    NTSTATUS       NtStatus;

    cchDestination = TARGETPATHLIMIT;

    wszDestination = new WCHAR [ cchDestination + 1 ];

    if ( ! wszDestination )
    {
        goto GetExpandedPath_Exit;
    }

    ReturnedLength = cchDestination * sizeof( *wszDestination );

    NtStatus = ExpandPathSpecial(
        pFileDB,
        wszHomeDir,
        wszUserName,
        wszDestination,
        &ReturnedLength);

    if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
    {
        delete [] wszDestination;

        wszDestination = new WCHAR [ ReturnedLength / sizeof( *wszDestination ) + 1 ];

        if ( ! wszDestination )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto GetExpandedPath_Exit;
        }

        NtStatus = ExpandPathSpecial(
            pFileDB,
            wszHomeDir,
            wszUserName,
            wszDestination,
            &ReturnedLength);
    }

    if ( STATUS_SUCCESS != NtStatus )
    {
        Status = RtlNtStatusToDosError( NtStatus );
    }

GetExpandedPath_Exit:

    delete [] wszHomeDir;

    if ( ERROR_SUCCESS != Status )
    {
        delete [] wszDestination;
    }
    else
    {
        *ppwszExpandedPath = wszDestination;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\gina\gpresult\gpresult.c ===
//*************************************************************
//  File name: GPRESULT.C
//
//  Description:  Command line tool to dump the resultant set
//                of policy.
//
//  Note:         This is just a simple command line tool,
//                SitaramR and team are writing the real
//                resultant set of policy tool.
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//*************************************************************

#include "gpresult.h"
#include <common.ver>

#define GROUPPOLICY_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy")
#define GROUPMEMBERSHIP_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership")
#define GPEXT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")
#define SCRIPTS_KEYNAME   TEXT("Software\\Policies\\Microsoft\\Windows\\System\\Scripts")

#define PROFILE_LIST_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s")

BOOL ParseCommandLine (int argc, char *argv[]);
void DumpGeneralInfo (void);
DWORD DumpPolicyOverview (BOOL bMachine);
void StringToGuid( TCHAR * szValue, GUID * pGuid );
void DumpProfileInfo (void);
void DumpSecurityGroups(BOOL bMachine);
void DumpSecurityPrivileges(void);
void DumpGPOInfo (PGROUP_POLICY_OBJECT pGPO);
void DumpFolderRedir (void);
void DumpIPSec (void);
void DumpDiskQuota (void);
void DumpScripts (PGROUP_POLICY_OBJECT pGPO, LPTSTR lpScriptType, LPTSTR lpTitle);
void DumpAppMgmt (BOOL bMachine);

GUID guidRegistry = REGISTRY_EXTENSION_GUID;

BOOL g_bVerbose = FALSE;
BOOL g_bSuperVerbose = FALSE;
BOOL g_bUser = TRUE;
BOOL g_bMachine = TRUE;
BOOL g_bDebuggerOutput = FALSE;
DWORD g_bNewFunc = FALSE;


//*************************************************************
//
//  main()
//
//  Purpose:    main entry point
//
//  Parameters: argc and argv
//
//
//  Return:     int error code
//
//*************************************************************

int __cdecl main( int argc, char *argv[])
{
    SYSTEMTIME systime;
    TCHAR szDate[100];
    TCHAR szTime[100];
    HANDLE hUser, hMachine;
    BOOL bResult;


    //
    // Parse the command line args
    //

    bResult = ParseCommandLine (argc, argv);


    //
    // Print the legal banner
    //

    PrintString(IDS_LEGAL1);
    PrintString(IDS_LEGAL2);
    PrintString(IDS_2NEWLINE);


    if (!bResult)
    {
        PrintString(IDS_USAGE1);
        PrintString(IDS_USAGE2);
        PrintString(IDS_USAGE3);
        PrintString(IDS_USAGE4);
        PrintString(IDS_USAGE5);
        PrintString(IDS_USAGE6);

        return 0;
    }


    //
    // Claim the policy critical sections while this tool is running so that
    // the data can't change while the report is being generated.
    //

    hUser = EnterCriticalPolicySection(FALSE);
    hMachine = EnterCriticalPolicySection(TRUE);


    //
    // Print the date and time this report is generated
    //

    GetLocalTime (&systime);

    GetDateFormat (LOCALE_USER_DEFAULT, DATE_LONGDATE, &systime,
                   NULL, szDate, ARRAYSIZE(szDate));

    GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                   NULL, szTime, ARRAYSIZE(szTime));

    PrintString(IDS_CREATEINFO, szDate, szTime);


    //
    // Print the general machine info
    //

    DumpGeneralInfo ();


    //
    // Dump out user policy results if appropriate
    //

    if (g_bUser)
    {
        DumpPolicyOverview (FALSE);
        PrintString(IDS_2NEWLINE);
    }


    //
    // Dump out computer policy results if appropriate
    //

    if (g_bMachine)
    {
        DumpPolicyOverview (TRUE);
    }


    //
    // Release the policy critical sections
    //

    LeaveCriticalPolicySection(hUser);
    LeaveCriticalPolicySection(hMachine);

    return 0;
}

//*************************************************************
//
//  DumpGeneralInfo()
//
//  Purpose:    Dumps out the general info about the computer
//
//  Parameters: none
//
//  Return:     void
//
//*************************************************************

void DumpGeneralInfo (void)
{
    OSVERSIONINFOEX   osiv;
    OSVERSIONINFO     osver;
    DWORDLONG   dwlConditionMask;
    BOOL bTSAppServer = FALSE;
    BOOL bTSRemoteAdmin = FALSE;
    BOOL bWks = FALSE;
    HKEY hkey;
    LONG lResult;
    TCHAR szProductType[50];
    DWORD dwType, dwSize;

    PrintString(IDS_OSINFO);

    //
    // Query the registry for the product type.
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                            0,
                            KEY_READ,
                            &hkey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof(szProductType);
        szProductType[0] = TEXT('\0');

        lResult = RegQueryValueEx (hkey,
                                   TEXT("ProductType"),
                                   NULL,
                                   &dwType,
                                   (LPBYTE) szProductType,
                                   &dwSize);

        RegCloseKey (hkey);

        if (lResult == ERROR_SUCCESS)
        {
            if (!lstrcmpi (szProductType, TEXT("WinNT")))
            {
                bWks = TRUE;
                PrintString(IDS_OS_PRO);

            } else if (!lstrcmpi (szProductType, TEXT("ServerNT"))) {
                PrintString(IDS_OS_SRV);

            } else if (!lstrcmpi (szProductType, TEXT("LanmanNT"))) {
                PrintString(IDS_OS_DC);
            }
        }
    }


    //
    // Build number
    //

    ZeroMemory( &osver, sizeof( OSVERSIONINFO ) );
    osver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    if (GetVersionEx(&osver))
    {
        if (osver.szCSDVersion[0] != TEXT('\0'))
            PrintString(IDS_OS_BUILDNUMBER1, osver.dwMajorVersion,
                     osver.dwMinorVersion, osver.dwBuildNumber, osver.szCSDVersion);
        else
            PrintString(IDS_OS_BUILDNUMBER2, osver.dwMajorVersion,
                     osver.dwMinorVersion, osver.dwBuildNumber);
    }


    //
    // Check for a TS App Server
    //

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osiv.wSuiteMask = VER_SUITE_TERMINAL;

    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    bTSAppServer = VerifyVersionInfo(&osiv, VER_SUITENAME, dwlConditionMask);


    //
    // Check for TS running in remote admin mode
    //

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osiv.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    bTSRemoteAdmin = VerifyVersionInfo(&osiv, VER_SUITENAME, dwlConditionMask);


    if (!bWks)
    {
        if (bTSAppServer)
        {
            if (bTSRemoteAdmin)
            {
                PrintString(IDS_TS_REMOTEADMIN);
            }
            else
            {
                PrintString(IDS_TS_APPSERVER);
            }
        }
        else
        {
            PrintString(IDS_TS_NONE);
        }
    }
    else
    {
        PrintString(IDS_TS_NOTSUPPORTED);
    }

}

//*************************************************************
//
//  ParseCommandLine()
//
//  Purpose:    Parses the command line args
//
//  Parameters: argc and argv
//
//  Return:     TRUE if processing should continue
//              FALSE if this tool should exit immediately
//
//*************************************************************

BOOL ParseCommandLine (int argc, char *argv[])
{
    int iIndex = 1;
    LPSTR lpArg;

    while (iIndex < argc)
    {
        lpArg = argv[iIndex] + 1;


        //
        // Enable verbose mode
        //

        if (!lstrcmpiA("V", lpArg))
        {
            g_bVerbose = TRUE;
        }
        else if (!lstrcmpiA("v", lpArg))
        {
            g_bVerbose = TRUE;
        }

        //
        // Enable super verbose mode
        //

        else if (!lstrcmpiA("S", lpArg))
        {
            g_bVerbose = TRUE;
            g_bSuperVerbose = TRUE;
        }
        else if (!lstrcmpiA("s", lpArg))
        {
            g_bVerbose = TRUE;
            g_bSuperVerbose = TRUE;
        }

        //
        // Show computer policy only
        //

        else if (!lstrcmpiA("C", lpArg))
        {
            g_bMachine = TRUE;
            g_bUser = FALSE;
        }
        else if (!lstrcmpiA("c", lpArg))
        {
            g_bMachine = TRUE;
            g_bUser = FALSE;
        }

        //
        // Show user policy only
        //

        else if (!lstrcmpiA("U", lpArg))
        {
            g_bMachine = FALSE;
            g_bUser = TRUE;
        }
        else if (!lstrcmpiA("u", lpArg))
        {
            g_bMachine = FALSE;
            g_bUser = TRUE;
        }

        //
        // Output to the debugger instead of the screen
        //

        else if (!lstrcmpiA("D", lpArg))
        {
            g_bDebuggerOutput = TRUE;
        }
        else if (!lstrcmpiA("d", lpArg))
        {
            g_bDebuggerOutput = TRUE;
        }

        //
        // Show the usage screen
        //

        else if (!lstrcmpiA("?", lpArg))
        {
            return FALSE;
        }

        iIndex++;
    }

    return TRUE;
}

//*************************************************************
//
//  ExtractDomainNameFromSamName()
//
//  Purpose:    Pulls the domain name out of a SAM style
//              name.  eg:  NTDev\ericflo
//
//  Parameters: lpSamName - source
//              lpDomainName - destination
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ExtractDomainNameFromSamName (LPTSTR lpSamName, LPTSTR lpDomainName)
{
    LPTSTR lpSrc, lpDest;

    //
    // Look for the \ between the domain and username and copy
    // the contents to the domain name buffer
    //

    lpSrc = lpSamName;
    lpDest = lpDomainName;

    while (*lpSrc && ((*lpSrc) != TEXT('\\')))
    {
        *lpDest = *lpSrc;
        lpSrc++;
        lpDest++;
    }

    if (*lpSrc != TEXT('\\'))
    {
        return FALSE;
    }

    *lpDest = TEXT('\0');

    return TRUE;
}

//*************************************************************
//
//  GetDomainType()
//
//  Purpose:     Determines if the domain is NT4 or W2k by checking
//               if DS support is available.
//
//  Parameters:  lpDomainName - domain name
//               pbW2K - TRUE if w2k, FALSE if something else
//               pbLocalAccount - TRUE if local account
//
//  Return:      TRUE if successful
//               FALSE if an error occurs
//
//*************************************************************

BOOL GetDomainType (LPTSTR lpDomainName, BOOL * pbW2K, BOOL *pbLocalAccount)
{
    PDOMAIN_CONTROLLER_INFO pDCI;
    DWORD dwResult, dwSize;
    TCHAR szComputerName[MAX_PATH];


    //
    // Check this domain for a DC
    //

    dwResult = DsGetDcName (NULL, lpDomainName, NULL, NULL,
                            DS_DIRECTORY_SERVICE_PREFERRED, &pDCI);

    if (dwResult == ERROR_SUCCESS)
    {

        //
        // Found a DC, does it have a DS ?
        //

        if (pDCI->Flags & DS_DS_FLAG) {
            *pbW2K = TRUE;
        }

        NetApiBufferFree(pDCI);

        return TRUE;
    }


    //
    // Check if the domain name is also the computer name (eg: local account)
    //

    dwSize = ARRAYSIZE(szComputerName);
    if (GetComputerName (szComputerName, &dwSize))
    {
        if (!lstrcmpi(szComputerName, lpDomainName))
        {
            *pbLocalAccount = TRUE;
            return TRUE;
        }
    }

    return FALSE;
}

//*************************************************************
//
//  DumpPolicyOverview()
//
//  Purpose:    Main function that dumps the summary information
//              about each CSE and it's GPOs
//
//  Parameters: bMachine - computer or user policy
//
//  Return:     Win32 error code
//
//*************************************************************

DWORD DumpPolicyOverview (BOOL bMachine)
{
    HKEY hKey, hSubKey;
    DWORD dwType, dwSize, dwIndex, dwNameSize;
    LONG lResult;
    FILETIME ftWrite, ftLocal;
    SYSTEMTIME systime;
    TCHAR szTime[30];
    TCHAR szDate[30];
    TCHAR szName[50];
    TCHAR szBuffer[MAX_PATH] = {0};
    TCHAR szDomainName[150] = {0};
    ULONG ulSize;
    GUID guid;
    PGROUP_POLICY_OBJECT pGPO, pGPOTemp;
    BOOL bW2KDomain = FALSE;
    BOOL bLocalAccount = FALSE;
    LPTSTR lpSiteName = NULL;


    //
    // Print a banner
    //

    if (bMachine)
    {
        ulSize = MAX_PATH;
        GetComputerObjectName (NameSamCompatible, szBuffer, &ulSize);
        ExtractDomainNameFromSamName (szBuffer, szDomainName);

        GetDomainType (szDomainName, &bW2KDomain, &bLocalAccount);

        if (bW2KDomain)
        {
            ulSize = ARRAYSIZE(szBuffer);
            szBuffer[0] = TEXT('\0');
            GetComputerObjectName (NameFullyQualifiedDN, szBuffer, &ulSize);
        }


        PrintString(IDS_NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
        PrintString(IDS_COMPRESULTS1);
        PrintString(IDS_COMPRESULTS2, szBuffer);
        PrintString(IDS_DOMAINNAME, szDomainName);

        if (bW2KDomain)
        {
            PrintString(IDS_W2KDOMAIN);

            DsGetSiteName(NULL, &lpSiteName);
            PrintString(IDS_SITENAME, lpSiteName);
            NetApiBufferFree(lpSiteName);
        }
        else if (bLocalAccount)
        {
            PrintString(IDS_LOCALCOMP);
        }
        else
        {
            PrintString(IDS_NT4DOMAIN);
        }

        //
        // Dump out the computer's security group information
        //

        PrintString(IDS_NEWLINE);
        DumpSecurityGroups(bMachine);

        PrintString(IDS_NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
    }
    else
    {

        ulSize = MAX_PATH;
        GetUserNameEx (NameSamCompatible, szBuffer, &ulSize);
        ExtractDomainNameFromSamName (szBuffer, szDomainName);

        GetDomainType (szDomainName, &bW2KDomain, &bLocalAccount);

        if (bW2KDomain)
        {
            ulSize = ARRAYSIZE(szBuffer);
            szBuffer[0] = TEXT('\0');
            GetUserNameEx (NameFullyQualifiedDN, szBuffer, &ulSize);
        }


        PrintString(IDS_NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
        PrintString(IDS_USERRESULTS1);
        PrintString(IDS_USERRESULTS2, szBuffer);
        PrintString(IDS_DOMAINNAME, szDomainName);

        if (bW2KDomain)
        {
            PrintString(IDS_W2KDOMAIN);

            DsGetSiteName(NULL, &lpSiteName);
            PrintString(IDS_SITENAME, lpSiteName);
            NetApiBufferFree(lpSiteName);
        }
        else if (bLocalAccount)
        {
            PrintString(IDS_LOCALUSER);
        }
        else
        {
            PrintString(IDS_NT4DOMAIN);
        }


        //
        // Dump out the user's profile and security group information
        //

        PrintString(IDS_NEWLINE);
        DumpProfileInfo();
        DumpSecurityGroups(bMachine);

        if (g_bVerbose)
        {
            DumpSecurityPrivileges();
        }

        PrintString(IDS_2NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
    }


    //
    // Find out the last time Group Policy was applied
    //

    lResult = RegOpenKeyEx (bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, GROUPPOLICY_KEY,
                            0, KEY_READ, &hKey);


    if (lResult != ERROR_SUCCESS)
    {
        PrintString(IDS_OPENHISTORYFAILED, lResult);
        return lResult;
    }

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               &ftWrite);

    if (lResult == ERROR_SUCCESS)
    {
        FileTimeToLocalFileTime (&ftWrite, &ftLocal);
        FileTimeToSystemTime (&ftLocal, &systime);
        GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime, NULL, szTime, ARRAYSIZE(szTime));
        GetDateFormat (LOCALE_USER_DEFAULT, DATE_LONGDATE, &systime, NULL, szDate, ARRAYSIZE(szDate));
        PrintString(IDS_LASTTIME, szDate, szTime);
    }
    else
    {
        PrintString(IDS_QUERYKEYINFOFAILED, lResult);
    }

    RegCloseKey (hKey);


    //
    // Find out which DC Group Policy was applied from last time
    //

    if (RegOpenKeyEx (bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');
        if (RegQueryValueEx (hKey, TEXT("DCName"), NULL, &dwType,
                            (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_DCNAME, (szBuffer+2));
            g_bNewFunc = TRUE;
        }

        RegCloseKey (hKey);
    }


    //
    // Dump out registry policy information
    //

    lResult = GetAppliedGPOList (bMachine ? GPO_LIST_FLAG_MACHINE : 0, NULL, NULL,
                                 &guidRegistry, &pGPO);

    if (lResult == ERROR_SUCCESS)
    {
        if (pGPO)
        {
            PrintString(IDS_LINE2);

            if (bMachine)
            {
                PrintString(IDS_COMPREGPOLICY);
            }
            else
            {
                PrintString(IDS_USERREGPOLICY);
            }


            pGPOTemp = pGPO;

            while (pGPOTemp)
            {
                PrintString(IDS_GPONAME, pGPOTemp->lpDisplayName);
                DumpGPOInfo (pGPOTemp);
                pGPOTemp = pGPOTemp->pNext;
            }

            FreeGPOList (pGPO);


            //
            // If we are in verbose mode, dump out the registry settings that
            // were applied
            //

            if (g_bVerbose) {

                if (bMachine)
                    ExpandEnvironmentStrings (TEXT("%ALLUSERSPROFILE%\\ntuser.pol"), szBuffer, MAX_PATH);
                else
                    ExpandEnvironmentStrings (TEXT("%USERPROFILE%\\ntuser.pol"), szBuffer, MAX_PATH);

                DisplayRegistryData (szBuffer);
            }
        }
    }


    //
    // Enumerate the extensions
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, GPEXT_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwIndex = 0;
        dwNameSize = 50;

        while (RegEnumKeyEx (hKey, dwIndex, szName, &dwNameSize, NULL, NULL,
                          NULL, NULL) == ERROR_SUCCESS)
        {

            //
            // Skip the registry extension since we did it above
            //

            if (lstrcmpi(TEXT("{35378EAC-683F-11D2-A89A-00C04FBBCFA2}"), szName))
            {

                //
                // Get the list of GPOs this extension applied
                //

                StringToGuid(szName, &guid);

                lResult = GetAppliedGPOList (bMachine ? GPO_LIST_FLAG_MACHINE : 0, NULL, NULL,
                                             &guid, &pGPO);

                if (lResult == ERROR_SUCCESS)
                {
                    if (pGPO)
                    {
                        //
                        // Get the extension's friendly display name
                        //

                        lResult = RegOpenKeyEx (hKey, szName, 0, KEY_READ, &hSubKey);

                        if (lResult == ERROR_SUCCESS)
                        {

                            dwSize = MAX_PATH * sizeof(TCHAR);
                            lResult = RegQueryValueEx (hSubKey, NULL, 0, &dwType, (LPBYTE) &szBuffer,
                                                       &dwSize);

                            if (lResult == ERROR_SUCCESS)
                            {
                                PrintString(IDS_LINE2);
                                if (bMachine)
                                {
                                    PrintString (IDS_COMPPOLICY, szBuffer);
                                }
                                else
                                {
                                    PrintString (IDS_USERPOLICY, szBuffer);
                                }
                            }
                            else
                            {
                                PrintString(IDS_LINE2);
                                if (bMachine)
                                {
                                    PrintString (IDS_COMPPOLICY, szName);
                                }
                                else
                                {
                                    PrintString (IDS_USERPOLICY, szName);
                                }
                            }


                            //
                            // Dump out the GPO list
                            //

                            pGPOTemp = pGPO;

                            while (pGPOTemp)
                            {
                                PrintString(IDS_GPONAME, pGPOTemp->lpDisplayName);
                                DumpGPOInfo (pGPOTemp);
                                pGPOTemp = pGPOTemp->pNext;
                            }


                            //
                            // If we're in verbose mode, then dump out some addition
                            // information about certain extensions
                            //

                            if (g_bVerbose)
                            {
                                if (!lstrcmpi(TEXT("{827D319E-6EAC-11D2-A4EA-00C04F79F83A}"), szName))
                                {
                                    PrintString(IDS_SECEDIT);
                                }
                                else if (!lstrcmpi(TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}"), szName))
                                {
                                    DumpIPSec ();
                                }
                                else if (!lstrcmpi(TEXT("{25537BA6-77A8-11D2-9B6C-0000F8080861}"), szName))
                                {
                                    DumpFolderRedir ();
                                }
                                else if (!lstrcmpi(TEXT("{3610eda5-77ef-11d2-8dc5-00c04fa31a66}"), szName))
                                {
                                    DumpDiskQuota ();
                                }
                                else if (!lstrcmpi(TEXT("{c6dc5466-785a-11d2-84d0-00c04fb169f7}"), szName))
                                {
                                    DumpAppMgmt (bMachine);
                                }
                                else if (!lstrcmpi(TEXT("{42B5FAAE-6536-11d2-AE5A-0000F87571E3}"), szName))
                                {
                                    if (bMachine)
                                    {
                                        DumpScripts (pGPO, TEXT("Startup"), TEXT("Startup scripts specified in"));
                                        DumpScripts (pGPO, TEXT("Shutdown"), TEXT("Shutdown scripts specified in"));
                                    }
                                    else
                                    {
                                        DumpScripts (pGPO, TEXT("Logon"), TEXT("Logon scripts specified in"));
                                        DumpScripts (pGPO, TEXT("Logoff"), TEXT("Logoff scripts specified in"));
                                    }
                                }
                                else
                                {
                                    PrintString(IDS_NOINFO);
                                }
                            }
                        }

                        FreeGPOList (pGPO);
                    }
                }
            }

            dwIndex++;
            dwNameSize = 50;
        }

        RegCloseKey (hKey);
    }

    return ERROR_SUCCESS;

}

//*************************************************************
//
//  StringToGuid()
//
//  Purpose:    Converts a GUID in string format to a GUID structure
//
//  Parameters: szValue - guid in string format
//              pGuid   - guid structure receiving the guid
//
//
//  Return:     void
//
//*************************************************************

void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

//*************************************************************
//
//  DumpProfileInfo()
//
//  Purpose:    Checks if the user has a roaming profile and if
//              so prints the storage path.
//
//  Parameters: void
//
//  Return:     void
//
//*************************************************************

void DumpProfileInfo (void)
{
    LPTSTR lpSid = NULL;
    HANDLE hProcess = NULL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    HKEY hKey;
    DWORD dwType, dwSize;


    //
    // Get the user's token
    //

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hProcess))
    {
        PrintString(IDS_OPENPROCESSTOKEN, GetLastError());
        goto Exit;
    }


    //
    // Get the user's sid
    //

    lpSid = GetSidString(hProcess);

    if (!lpSid)
    {
        PrintString(IDS_QUERYSID);
        goto Exit;
    }


    //
    // Open the user's profile mapping key
    //

    wsprintf (szBuffer, PROFILE_LIST_PATH, lpSid);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        szBuffer[0] = TEXT('\0');
        dwSize = MAX_PATH * sizeof(TCHAR);


        //
        // Get the roaming profile value
        //

        if (RegQueryValueEx (hKey, TEXT("CentralProfile"), NULL, &dwType,
                             (LPBYTE) &szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            if (szBuffer[0] != TEXT('\0'))
            {
                PrintString(IDS_ROAMINGPROFILE, szBuffer);
            }
            else
            {
                PrintString(IDS_NOROAMINGPROFILE);
            }
        }


        szBuffer[0] = TEXT('\0');
        dwSize = MAX_PATH * sizeof(TCHAR);


        //
        // Get the local profile value
        //

        if (RegQueryValueEx (hKey, TEXT("ProfileImagePath"), NULL, &dwType,
                             (LPBYTE) &szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            if (szBuffer[0] != TEXT('\0'))
            {
                ExpandEnvironmentStrings(szBuffer, szBuffer2, MAX_PATH);
                PrintString(IDS_LOCALPROFILE, szBuffer2);
            }
            else
            {
                PrintString(IDS_NOLOCALPROFILE);
            }
        }


        RegCloseKey (hKey);
    }


Exit:
    if (lpSid)
    {
        DeleteSidString(lpSid);
    }

    if (hProcess)
    {
        CloseHandle (hProcess);
    }
}

//*************************************************************
//
//  DumpSecurityGroups()
//
//  Purpose:    Dumps the user's / computer's security groups
//
//  Parameters: bMachine
//
//  Return:     void
//
//*************************************************************

void DumpSecurityGroups (BOOL bMachine)
{
    DWORD dwSize, dwIndex, dwNameSize, dwDomainSize, dwCount, dwSidSize, dwType;
    TCHAR szName[100];
    TCHAR szDomain[100];
    TCHAR szValueName[25];
    SID_NAME_USE eUse;
    PSID pSid;
    HKEY hKey;
    LONG lResult;
    NTSTATUS status;
    LPTSTR pSidString;


    if (bMachine)
    {
        PrintString(IDS_SECURITYGROUPS2);
    }
    else
    {
        PrintString(IDS_SECURITYGROUPS1);
    }


    //
    // Open the registry key
    //

    lResult = RegOpenKeyEx ((bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership"),
                      0, KEY_READ, &hKey);


    if (lResult != ERROR_SUCCESS)
    {
        if ((lResult != ERROR_FILE_NOT_FOUND) && (lResult != ERROR_PATH_NOT_FOUND))
        {
            PrintString (IDS_OPENHISTORYFAILED, lResult);
        }
        return;
    }


    //
    // Query for the largest sid
    //

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               NULL, &dwSidSize, NULL, NULL);

    if (lResult != ERROR_SUCCESS)
    {
        PrintString(IDS_QUERYKEYINFOFAILED, lResult);
        RegCloseKey (hKey);
        return;
    }


    //
    // Allocate a buffer for the sid
    //

    pSidString = LocalAlloc (LPTR, dwSidSize);

    if (!pSidString)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        RegCloseKey (hKey);
        return;
    }


    //
    // Query for the number of sids
    //

    dwSize = sizeof(dwCount);
    lResult = RegQueryValueEx (hKey, TEXT("Count"), NULL, &dwType,
                               (LPBYTE) &dwCount, &dwSize);

    if (lResult != ERROR_SUCCESS)
    {
        PrintString (IDS_QUERYVALUEFAILED, lResult);
        LocalFree (pSidString);
        RegCloseKey (hKey);
        return;
    }


    //
    // Lookup the friendly display name for each sid and print it on the screen
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        wsprintf (szValueName, TEXT("Group%d"), dwIndex);

        dwSize = dwSidSize;
        lResult = RegQueryValueEx (hKey, szValueName, NULL, &dwType,
                                   (LPBYTE) pSidString, &dwSize);

        if (lResult != ERROR_SUCCESS)
        {
            PrintString (IDS_QUERYVALUEFAILED, lResult);
            LocalFree (pSidString);
            RegCloseKey (hKey);
            return;
        }

        status = AllocateAndInitSidFromString (pSidString, &pSid);

        if (status != STATUS_SUCCESS)
        {
            PrintString (IDS_QUERYSID);
            LocalFree (pSidString);
            RegCloseKey (hKey);
            return;
        }


        dwNameSize = ARRAYSIZE(szName);
        dwDomainSize = ARRAYSIZE(szDomain);

        if (LookupAccountSid(NULL, pSid, szName, &dwNameSize,
                             szDomain, &dwDomainSize, &eUse))
        {
            PrintString(IDS_GROUPNAME, szDomain, szName);
        }
        else
        {
            if (GetLastError() != ERROR_NONE_MAPPED)
            {
                PrintString(IDS_LOOKUPACCOUNT, GetLastError());
            }
        }

        RtlFreeSid(pSid);
    }

    LocalFree (pSidString);

    RegCloseKey (hKey);

}

//*************************************************************
//
//  DumpSecurityPrivileges()
//
//  Purpose:    Dumps the user's security privileges
//
//  Parameters: void
//
//  Return:     void
//
//*************************************************************

void DumpSecurityPrivileges (void)
{
    HANDLE hProcess;
    DWORD dwSize, dwIndex, dwNameSize, dwLang;
    TCHAR szName[100];
    TCHAR szDisplayName[200];
    TOKEN_PRIVILEGES *lpPrivileges;
    PLUID pLuid;
    LUID_AND_ATTRIBUTES *pEntry;


    PrintString(IDS_SECURITYPRIVILEGES);


    //
    // Get the user's token
    //

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hProcess))
    {
        PrintString(IDS_OPENPROCESSTOKEN, GetLastError());
        return;
    }


    //
    // Query the token for the privileges
    //

    dwSize = 0;
    GetTokenInformation(hProcess, TokenPrivileges, NULL, 0, &dwSize);

    if (dwSize == 0)
    {
        PrintString(IDS_PRIVSIZE);
        CloseHandle(hProcess);
        return;
    }

    lpPrivileges = LocalAlloc (LPTR, dwSize);

    if (!lpPrivileges)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        CloseHandle(hProcess);
        return;
    }

    if (!GetTokenInformation(hProcess, TokenPrivileges, lpPrivileges, dwSize, &dwSize))
    {
        PrintString(IDS_TOKENINFO, GetLastError());
        LocalFree(lpPrivileges);
        CloseHandle(hProcess);
        return;
    }


    //
    // Lookup the friendly display name for each privilege and print it on the screen
    //

    for (dwIndex = 0; dwIndex < lpPrivileges->PrivilegeCount; dwIndex++)
    {
        dwNameSize = 100;
        pEntry = &lpPrivileges->Privileges[dwIndex];

        pLuid = &pEntry->Luid;

        if (LookupPrivilegeName(NULL, pLuid, szName, &dwNameSize))
        {

            dwNameSize = 200;
            if (LookupPrivilegeDisplayName (NULL, szName, szDisplayName, &dwNameSize, &dwLang))
            {
                PrintString(IDS_GPONAME, szDisplayName);
            }
            else
            {
                PrintString(IDS_GPONAME, szName);
            }
        }
        else
        {
            if (GetLastError() != ERROR_NONE_MAPPED)
            {
                PrintString(IDS_LOOKUPFAILED, GetLastError());
            }
        }
    }


    LocalFree (lpPrivileges);

    CloseHandle (hProcess);

}


//*************************************************************
//
//  DumpGPOInfo()
//
//  Purpose:    Prints the details about a specific GPO
//
//  Parameters: pGPO - a GPO
//
//  Return:     void
//
//*************************************************************

void DumpGPOInfo (PGROUP_POLICY_OBJECT pGPO)
{
    TCHAR szBuffer[2 * MAX_PATH];
    LPTSTR lpTemp;

    if (!g_bVerbose)
    {
        return;
    }


    //
    // Print the version number and guid
    //

    if (g_bSuperVerbose)
    {
        if (g_bNewFunc)
        {
            PrintString(IDS_REVISIONNUMBER1, LOWORD(pGPO->dwVersion), HIWORD(pGPO->dwVersion));
        }
        else
        {
            PrintString(IDS_REVISIONNUMBER2, pGPO->dwVersion);
        }
    }
    else
    {
        if (g_bNewFunc)
        {
            PrintString(IDS_REVISIONNUMBER2, LOWORD(pGPO->dwVersion));
        }
        else
        {
            PrintString(IDS_REVISIONNUMBER2, pGPO->dwVersion);
        }
    }

    PrintString(IDS_UNIQUENAME, pGPO->szGPOName);


    //
    // To get the domain name, we parse the UNC path because the domain name
    // is also the server name
    //

    lstrcpy (szBuffer, (pGPO->lpFileSysPath+2));

    lpTemp = szBuffer;

    while (*lpTemp && *lpTemp != TEXT('\\'))
        lpTemp++;

    if (*lpTemp == TEXT('\\'))
    {
        *lpTemp = TEXT('\0');
        PrintString(IDS_DOMAINNAME2, szBuffer);
    }


    //
    // Print out where this GPO was linked (LSDOU)
    //

    if (g_bNewFunc)
    {
        switch (pGPO->GPOLink)
        {
            case GPLinkMachine:
                PrintString(IDS_LOCALLINK);
                break;

            case GPLinkSite:
                PrintString(IDS_SITELINK, (pGPO->lpLink + 7));
                break;

            case GPLinkDomain:
                PrintString(IDS_DOMAINLINK, (pGPO->lpLink + 7));
                break;

            case GPLinkOrganizationalUnit:
                PrintString(IDS_OULINK, (pGPO->lpLink + 7));
                break;

            case GPLinkUnknown:
            default:
                PrintString(IDS_UNKNOWNLINK);
                break;
        }
    }


   PrintString(IDS_NEWLINE);
}

//*************************************************************
//
//  DumpFolderRedir()
//
//  Purpose:    Prints any redirected folder locations
//
//  Parameters: void
//
//  Return:     void
//
//*************************************************************

void DumpFolderRedir (void)
{
    TCHAR szPath[2 * MAX_PATH];
    TCHAR szNames[200];
    LPTSTR lpName;
    TCHAR szRdr[2 * MAX_PATH];

    if (!g_bVerbose)
    {
        return;
    }


    //
    // Get the path to the local settings\app data folder
    //

    if (SHGetFolderPath (NULL, CSIDL_LOCAL_APPDATA , NULL, SHGFP_TYPE_CURRENT, szPath) != S_OK)
    {
        PrintString(IDS_GETFOLDERPATH);
        return;
    }


    //
    // Tack on the folder rdr specific stuff
    //

    lstrcat (szPath, TEXT("\\Microsoft\\Windows\\File Deployment\\{25537BA6-77A8-11D2-9B6C-0000F8080861}.ini"));


    //
    // Grab the section names from the ini file
    //

    if (!GetPrivateProfileSectionNames (szNames, 200, szPath))
    {
        PrintString(IDS_GETPRIVATEPROFILE);
        return;
    }


    //
    // Loop through the sections getting the path value for each.  If the path
    // doesn't start with %userprofile%, then we assume it has been redirected.
    //

    lpName = szNames;

    while (*lpName)
    {
        GetPrivateProfileString (lpName, TEXT("Path"), TEXT("%USERPROFILE%"), szRdr,
                                 2 * MAX_PATH, szPath);

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, szRdr, 13,
                           TEXT("%USERPROFILE%"), 13) != CSTR_EQUAL)
        {
            PrintString(IDS_FOLDERREDIR, lpName, szRdr);
        }
        lpName = lpName + lstrlen(lpName) + 1;
    }
}

//*************************************************************
//
//  DumpIPSec()
//
//  Purpose:    Dumps out the IPSec information
//
//  Parameters: none
//
//  Return:     void
//
//*************************************************************

void DumpIPSec (void)
{
    HKEY hKey;
    DWORD dwSize, dwType;
    TCHAR szBuffer[350];



    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy"),
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS)
    {

        dwSize = 350 * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');

        if (RegQueryValueEx (hKey, TEXT("DSIPSECPolicyName"),
                             NULL, &dwType, (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_IPSEC_NAME, szBuffer);
        }


        dwSize = 350 * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');

        if (RegQueryValueEx (hKey, TEXT("DSIPSECPolicyDescription"),
                             NULL, &dwType, (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_IPSEC_DESC, szBuffer);
        }


        dwSize = 350 * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');

        if (RegQueryValueEx (hKey, TEXT("DSIPSECPolicyPath"),
                             NULL, &dwType, (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_IPSEC_PATH, szBuffer);
        }


        RegCloseKey (hKey);
    }

}

//*************************************************************
//
//  DumpDiskQuota()
//
//  Purpose:    Dumps out the disk quota policies
//
//  Parameters: none
//
//  Return:     void
//
//*************************************************************

void DumpDiskQuota (void)
{
    HKEY hKey;
    DWORD dwSize, dwType, dwData;
    TCHAR szBuffer[350];


    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Policies\\Microsoft\\Windows NT\\DiskQuota"),
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS)
    {

        //
        // Query for enabled
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("Enable"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_ENABLED1);
        }
        else
        {
            PrintString (IDS_DQ_ENABLED2);
        }


        //
        // Query for enforced
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("Enforce"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_ENFORCED1);
        }
        else
        {
            PrintString (IDS_DQ_ENFORCED2);
        }


        //
        // Query for limit
        //

        dwSize = sizeof(dwData);
        dwData = 0xFFFFFFFF;

        RegQueryValueEx (hKey, TEXT("Limit"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);


        if (dwData != 0xFFFFFFFF)
        {
            PrintString (IDS_DQ_LIMIT1, dwData);

            dwSize = sizeof(dwData);
            dwData = 2;

            RegQueryValueEx (hKey, TEXT("LimitUnits"),
                             NULL, &dwType, (LPBYTE) &dwData, &dwSize);


            switch (dwData)
            {
                case 1:
                    PrintString (IDS_DQ_KB);
                    break;

                case 2:
                    PrintString (IDS_DQ_MB);
                    break;

                case 3:
                    PrintString (IDS_DQ_GB);
                    break;

                case 4:
                    PrintString (IDS_DQ_TB);
                    break;

                case 5:
                    PrintString (IDS_DQ_PB);
                    break;

                case 6:
                    PrintString (IDS_DQ_EB);
                    break;
            }
        }
        else
        {
            PrintString (IDS_DQ_LIMIT2);
        }


        //
        // Query for warning level
        //

        dwSize = sizeof(dwData);
        dwData = 0xFFFFFFFF;

        RegQueryValueEx (hKey, TEXT("Threshold"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);


        if (dwData != 0xFFFFFFFF)
        {
            PrintString (IDS_DQ_WARNING1, dwData);

            dwSize = sizeof(dwData);
            dwData = 2;

            RegQueryValueEx (hKey, TEXT("ThresholdUnits"),
                             NULL, &dwType, (LPBYTE) &dwData, &dwSize);


            switch (dwData)
            {
                case 1:
                    PrintString (IDS_DQ_KB);
                    break;

                case 2:
                    PrintString (IDS_DQ_MB);
                    break;

                case 3:
                    PrintString (IDS_DQ_GB);
                    break;

                case 4:
                    PrintString (IDS_DQ_TB);
                    break;

                case 5:
                    PrintString (IDS_DQ_PB);
                    break;

                case 6:
                    PrintString (IDS_DQ_EB);
                    break;
            }
        }
        else
        {
            PrintString (IDS_DQ_WARNING2);
        }


        //
        // Log event over limit
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("LogEventOverLimit"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_LIMIT_EXCEED1);
        }
        else
        {
            PrintString (IDS_DQ_LIMIT_EXCEED2);
        }


        //
        // Log event over threshold
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("LogEventOverThreshold"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_LIMIT_EXCEED3);
        }
        else
        {
            PrintString (IDS_DQ_LIMIT_EXCEED4);
        }


        //
        // Apply policy to removable media
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("ApplyToRemovableMedia"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_REMOVABLE1);
        }
        else
        {
            PrintString (IDS_DQ_REMOVABLE2);
        }

        RegCloseKey (hKey);
    }
}

void DumpScripts (PGROUP_POLICY_OBJECT pGPO, LPTSTR lpScriptType, LPTSTR lpTitle)
{
    PGROUP_POLICY_OBJECT pGPOTemp;
    TCHAR szPath[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szArgs[MAX_PATH];
    TCHAR szTemp